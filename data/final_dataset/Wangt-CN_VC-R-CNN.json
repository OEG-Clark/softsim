{"home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.None.setup.get_extensions": [[17, 57], ["os.path.dirname", "os.path.join", "glob.glob", "glob.glob", "glob.glob", "os.path.abspath", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "extension", "torch.cuda.is_available", "os.getenv"], "function", ["None"], ["def", "get_extensions", "(", ")", ":", "\n", "    ", "this_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "extensions_dir", "=", "os", ".", "path", ".", "join", "(", "this_dir", ",", "\"vc_rcnn\"", ",", "\"csrc\"", ")", "\n", "\n", "main_file", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "extensions_dir", ",", "\"*.cpp\"", ")", ")", "\n", "source_cpu", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "extensions_dir", ",", "\"cpu\"", ",", "\"*.cpp\"", ")", ")", "\n", "source_cuda", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "extensions_dir", ",", "\"cuda\"", ",", "\"*.cu\"", ")", ")", "\n", "\n", "sources", "=", "main_file", "+", "source_cpu", "\n", "extension", "=", "CppExtension", "\n", "\n", "extra_compile_args", "=", "{", "\"cxx\"", ":", "[", "]", "}", "\n", "define_macros", "=", "[", "]", "\n", "\n", "if", "(", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "CUDA_HOME", "is", "not", "None", ")", "or", "os", ".", "getenv", "(", "\"FORCE_CUDA\"", ",", "\"0\"", ")", "==", "\"1\"", ":", "\n", "        ", "extension", "=", "CUDAExtension", "\n", "sources", "+=", "source_cuda", "\n", "define_macros", "+=", "[", "(", "\"WITH_CUDA\"", ",", "None", ")", "]", "\n", "extra_compile_args", "[", "\"nvcc\"", "]", "=", "[", "\n", "\"-DCUDA_HAS_FP16=1\"", ",", "\n", "\"-D__CUDA_NO_HALF_OPERATORS__\"", ",", "\n", "\"-D__CUDA_NO_HALF_CONVERSIONS__\"", ",", "\n", "\"-D__CUDA_NO_HALF2_OPERATORS__\"", ",", "\n", "]", "\n", "\n", "", "sources", "=", "[", "os", ".", "path", ".", "join", "(", "extensions_dir", ",", "s", ")", "for", "s", "in", "sources", "]", "\n", "\n", "include_dirs", "=", "[", "extensions_dir", "]", "\n", "\n", "ext_modules", "=", "[", "\n", "extension", "(", "\n", "\"vc_rcnn._C\"", ",", "\n", "sources", ",", "\n", "include_dirs", "=", "include_dirs", ",", "\n", "define_macros", "=", "define_macros", ",", "\n", "extra_compile_args", "=", "extra_compile_args", ",", "\n", ")", "\n", "]", "\n", "\n", "return", "ext_modules", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.model_serialization.align_and_update_state_dicts": [[10, 57], ["sorted", "sorted", "torch.as_tensor().view", "torch.as_tensor().view.max", "logging.getLogger", "enumerate", "list", "list", "len", "len", "max", "max", "idxs.tolist", "logging.getLogger.info", "model_state_dict.keys", "loaded_state_dict.keys", "i.endswith", "len", "torch.as_tensor", "log_str_template.format", "len", "len", "tuple"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["def", "align_and_update_state_dicts", "(", "model_state_dict", ",", "loaded_state_dict", ")", ":", "\n", "    ", "\"\"\"\n    Strategy: suppose that the models that we will create will have prefixes appended\n    to each of its keys, for example due to an extra level of nesting that the original\n    pre-trained weights from ImageNet won't contain. For example, model.state_dict()\n    might return backbone[0].body.res2.conv1.weight, while the pre-trained model contains\n    res2.conv1.weight. We thus want to match both parameters together.\n    For that, we look for each model weight, look among all loaded keys if there is one\n    that is a suffix of the current weight name, and use it if that's the case.\n    If multiple matches exist, take the one with longest size\n    of the corresponding name. For example, for the same model as before, the pretrained\n    weight file can contain both res2.conv1.weight, as well as conv1.weight. In this case,\n    we want to match backbone[0].body.conv1.weight to conv1.weight, and\n    backbone[0].body.res2.conv1.weight to res2.conv1.weight.\n    \"\"\"", "\n", "current_keys", "=", "sorted", "(", "list", "(", "model_state_dict", ".", "keys", "(", ")", ")", ")", "\n", "loaded_keys", "=", "sorted", "(", "list", "(", "loaded_state_dict", ".", "keys", "(", ")", ")", ")", "\n", "# get a matrix of string matches, where each (i, j) entry correspond to the size of the", "\n", "# loaded_key string, if it matches", "\n", "match_matrix", "=", "[", "\n", "len", "(", "j", ")", "if", "i", ".", "endswith", "(", "j", ")", "else", "0", "for", "i", "in", "current_keys", "for", "j", "in", "loaded_keys", "\n", "]", "\n", "match_matrix", "=", "torch", ".", "as_tensor", "(", "match_matrix", ")", ".", "view", "(", "\n", "len", "(", "current_keys", ")", ",", "len", "(", "loaded_keys", ")", "\n", ")", "\n", "max_match_size", ",", "idxs", "=", "match_matrix", ".", "max", "(", "1", ")", "\n", "# remove indices that correspond to no-match", "\n", "idxs", "[", "max_match_size", "==", "0", "]", "=", "-", "1", "\n", "\n", "# used for logging", "\n", "max_size", "=", "max", "(", "[", "len", "(", "key", ")", "for", "key", "in", "current_keys", "]", ")", "if", "current_keys", "else", "1", "\n", "max_size_loaded", "=", "max", "(", "[", "len", "(", "key", ")", "for", "key", "in", "loaded_keys", "]", ")", "if", "loaded_keys", "else", "1", "\n", "log_str_template", "=", "\"{: <{}} loaded from {: <{}} of shape {}\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "for", "idx_new", ",", "idx_old", "in", "enumerate", "(", "idxs", ".", "tolist", "(", ")", ")", ":", "\n", "        ", "if", "idx_old", "==", "-", "1", ":", "\n", "            ", "continue", "\n", "", "key", "=", "current_keys", "[", "idx_new", "]", "\n", "key_old", "=", "loaded_keys", "[", "idx_old", "]", "\n", "model_state_dict", "[", "key", "]", "=", "loaded_state_dict", "[", "key_old", "]", "\n", "logger", ".", "info", "(", "\n", "log_str_template", ".", "format", "(", "\n", "key", ",", "\n", "max_size", ",", "\n", "key_old", ",", "\n", "max_size_loaded", ",", "\n", "tuple", "(", "loaded_state_dict", "[", "key_old", "]", ".", "shape", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.model_serialization.strip_prefix_if_present": [[61, 69], ["sorted", "collections.OrderedDict", "state_dict.items", "state_dict.keys", "all", "key.startswith", "key.replace"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys"], ["", "", "def", "strip_prefix_if_present", "(", "state_dict", ",", "prefix", ")", ":", "\n", "    ", "keys", "=", "sorted", "(", "state_dict", ".", "keys", "(", ")", ")", "\n", "if", "not", "all", "(", "key", ".", "startswith", "(", "prefix", ")", "for", "key", "in", "keys", ")", ":", "\n", "        ", "return", "state_dict", "\n", "", "stripped_state_dict", "=", "OrderedDict", "(", ")", "\n", "for", "key", ",", "value", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "        ", "stripped_state_dict", "[", "key", ".", "replace", "(", "prefix", ",", "\"\"", ")", "]", "=", "value", "\n", "", "return", "stripped_state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.model_serialization.load_state_dict": [[71, 81], ["model.state_dict", "model_serialization.strip_prefix_if_present", "model_serialization.align_and_update_state_dicts", "model.load_state_dict"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.model_serialization.strip_prefix_if_present", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.model_serialization.align_and_update_state_dicts", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["", "def", "load_state_dict", "(", "model", ",", "loaded_state_dict", ")", ":", "\n", "    ", "model_state_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "# if the state_dict comes from a model that was wrapped in a", "\n", "# DataParallel or DistributedDataParallel during serialization,", "\n", "# remove the \"module\" prefix before performing the matching", "\n", "loaded_state_dict", "=", "strip_prefix_if_present", "(", "loaded_state_dict", ",", "prefix", "=", "\"module.\"", ")", "\n", "align_and_update_state_dicts", "(", "model_state_dict", ",", "loaded_state_dict", ")", "\n", "\n", "# use strict loading", "\n", "model", ".", "load_state_dict", "(", "model_state_dict", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir": [[9, 15], ["os.makedirs"], "function", ["None"], ["def", "mkdir", "(", "path", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "os", ".", "makedirs", "(", "path", ")", "\n", "", "except", "OSError", "as", "e", ":", "\n", "        ", "if", "e", ".", "errno", "!=", "errno", ".", "EEXIST", ":", "\n", "            ", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.save_labels": [[17, 34], ["comm.is_main_process", "logging.getLogger", "hasattr", "os.path.join", "logging.getLogger.info", "ids_to_labels.update", "logging.getLogger.warning", "open", "json.dump"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.is_main_process", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update"], ["", "", "", "def", "save_labels", "(", "dataset_list", ",", "output_dir", ")", ":", "\n", "    ", "if", "is_main_process", "(", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "ids_to_labels", "=", "{", "}", "\n", "for", "dataset", "in", "dataset_list", ":", "\n", "            ", "if", "hasattr", "(", "dataset", ",", "'categories'", ")", ":", "\n", "                ", "ids_to_labels", ".", "update", "(", "dataset", ".", "categories", ")", "\n", "", "else", ":", "\n", "                ", "logger", ".", "warning", "(", "\"Dataset [{}] has no categories attribute, labels.json file won't be created\"", ".", "format", "(", "\n", "dataset", ".", "__class__", ".", "__name__", ")", ")", "\n", "\n", "", "", "if", "ids_to_labels", ":", "\n", "            ", "labels_file", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'labels.json'", ")", "\n", "logger", ".", "info", "(", "\"Saving labels mapping into {}\"", ".", "format", "(", "labels_file", ")", ")", "\n", "with", "open", "(", "labels_file", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "json", ".", "dump", "(", "ids_to_labels", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.save_config": [[36, 40], ["comm.is_main_process", "open", "f.write", "cfg.dump"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.is_main_process"], ["", "", "", "", "def", "save_config", "(", "cfg", ",", "path", ")", ":", "\n", "    ", "if", "is_main_process", "(", ")", ":", "\n", "        ", "with", "open", "(", "path", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "cfg", ".", "dump", "(", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size": [[13, 19], ["torch.get_world_size", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size"], ["def", "get_world_size", "(", ")", ":", "\n", "    ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "return", "dist", ".", "get_world_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank": [[21, 27], ["torch.get_rank", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank"], ["", "def", "get_rank", "(", ")", ":", "\n", "    ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "return", "dist", ".", "get_rank", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.is_main_process": [[29, 31], ["comm.get_rank"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank"], ["", "def", "is_main_process", "(", ")", ":", "\n", "    ", "return", "get_rank", "(", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize": [[33, 46], ["torch.get_world_size", "torch.barrier", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size"], ["", "def", "synchronize", "(", ")", ":", "\n", "    ", "\"\"\"\n    Helper function to synchronize (barrier) among all processes when\n    using distributed training\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "\n", "", "world_size", "=", "dist", ".", "get_world_size", "(", ")", "\n", "if", "world_size", "==", "1", ":", "\n", "        ", "return", "\n", "", "dist", ".", "barrier", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.all_gather": [[48, 89], ["comm.get_world_size", "pickle.dumps", "torch.ByteStorage.from_buffer", "torch.ByteStorage.from_buffer", "torch.ByteTensor().to", "torch.ByteTensor().to", "torch.LongTensor().to", "torch.LongTensor().to", "torch.all_gather", "max", "torch.all_gather", "zip", "torch.LongTensor().to", "torch.LongTensor().to", "int", "tensor_list.append", "torch.ByteTensor().to", "torch.ByteTensor().to", "torch.cat", "torch.cat", "data_list.append", "torch.ByteTensor", "torch.ByteTensor", "torch.LongTensor", "torch.LongTensor", "range", "size.item", "torch.ByteTensor().to", "torch.ByteTensor().to", "torch.cat.cpu().numpy().tobytes", "pickle.loads", "torch.LongTensor", "torch.LongTensor", "torch.ByteTensor", "torch.ByteTensor", "torch.cat.numel", "torch.ByteTensor", "torch.ByteTensor", "torch.cat.cpu().numpy", "torch.cat.cpu"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.all_gather", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.all_gather", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "all_gather", "(", "data", ")", ":", "\n", "    ", "\"\"\"\n    Run all_gather on arbitrary picklable data (not necessarily tensors)\n    Args:\n        data: any picklable object\n    Returns:\n        list[data]: list of data gathered from each rank\n    \"\"\"", "\n", "world_size", "=", "get_world_size", "(", ")", "\n", "if", "world_size", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "\n", "# serialized to a Tensor", "\n", "", "buffer", "=", "pickle", ".", "dumps", "(", "data", ")", "\n", "storage", "=", "torch", ".", "ByteStorage", ".", "from_buffer", "(", "buffer", ")", "\n", "tensor", "=", "torch", ".", "ByteTensor", "(", "storage", ")", ".", "to", "(", "\"cuda\"", ")", "\n", "\n", "# obtain Tensor size of each rank", "\n", "local_size", "=", "torch", ".", "LongTensor", "(", "[", "tensor", ".", "numel", "(", ")", "]", ")", ".", "to", "(", "\"cuda\"", ")", "\n", "size_list", "=", "[", "torch", ".", "LongTensor", "(", "[", "0", "]", ")", ".", "to", "(", "\"cuda\"", ")", "for", "_", "in", "range", "(", "world_size", ")", "]", "\n", "dist", ".", "all_gather", "(", "size_list", ",", "local_size", ")", "\n", "size_list", "=", "[", "int", "(", "size", ".", "item", "(", ")", ")", "for", "size", "in", "size_list", "]", "\n", "max_size", "=", "max", "(", "size_list", ")", "\n", "\n", "# receiving Tensor from all ranks", "\n", "# we pad the tensor because torch all_gather does not support", "\n", "# gathering tensors of different shapes", "\n", "tensor_list", "=", "[", "]", "\n", "for", "_", "in", "size_list", ":", "\n", "        ", "tensor_list", ".", "append", "(", "torch", ".", "ByteTensor", "(", "size", "=", "(", "max_size", ",", ")", ")", ".", "to", "(", "\"cuda\"", ")", ")", "\n", "", "if", "local_size", "!=", "max_size", ":", "\n", "        ", "padding", "=", "torch", ".", "ByteTensor", "(", "size", "=", "(", "max_size", "-", "local_size", ",", ")", ")", ".", "to", "(", "\"cuda\"", ")", "\n", "tensor", "=", "torch", ".", "cat", "(", "(", "tensor", ",", "padding", ")", ",", "dim", "=", "0", ")", "\n", "", "dist", ".", "all_gather", "(", "tensor_list", ",", "tensor", ")", "\n", "\n", "data_list", "=", "[", "]", "\n", "for", "size", ",", "tensor", "in", "zip", "(", "size_list", ",", "tensor_list", ")", ":", "\n", "        ", "buffer", "=", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", "[", ":", "size", "]", "\n", "data_list", ".", "append", "(", "pickle", ".", "loads", "(", "buffer", ")", ")", "\n", "\n", "", "return", "data_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.reduce_dict": [[91, 118], ["comm.get_world_size", "torch.no_grad", "torch.no_grad", "sorted", "torch.stack", "torch.stack", "torch.reduce", "input_dict.keys", "names.append", "torch.stack.append", "torch.get_rank", "zip"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank"], ["", "def", "reduce_dict", "(", "input_dict", ",", "average", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        input_dict (dict): all the values will be reduced\n        average (bool): whether to do average or sum\n    Reduce the values in the dictionary from all processes so that process with rank\n    0 has the averaged results. Returns a dict with the same fields as\n    input_dict, after reduction.\n    \"\"\"", "\n", "world_size", "=", "get_world_size", "(", ")", "\n", "if", "world_size", "<", "2", ":", "\n", "        ", "return", "input_dict", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "names", "=", "[", "]", "\n", "values", "=", "[", "]", "\n", "# sort the keys so that they are consistent across processes", "\n", "for", "k", "in", "sorted", "(", "input_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "names", ".", "append", "(", "k", ")", "\n", "values", ".", "append", "(", "input_dict", "[", "k", "]", ")", "\n", "", "values", "=", "torch", ".", "stack", "(", "values", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "values", ",", "dst", "=", "0", ")", "\n", "if", "dist", ".", "get_rank", "(", ")", "==", "0", "and", "average", ":", "\n", "# only main process gets accumulated, so only divide by", "\n", "# world_size in this case", "\n", "            ", "values", "/=", "world_size", "\n", "", "reduced_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "names", ",", "values", ")", "}", "\n", "", "return", "reduced_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.__init__": [[9, 11], ["timer.Timer.reset"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.reset"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.average_time": [[12, 15], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "average_time", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "total_time", "/", "self", ".", "calls", "if", "self", ".", "calls", ">", "0", "else", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.tic": [[16, 20], ["time.time"], "methods", ["None"], ["", "def", "tic", "(", "self", ")", ":", "\n", "# using time.time instead of time.clock because time time.clock", "\n", "# does not normalize for multithreading", "\n", "        ", "self", ".", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.toc": [[21, 27], ["timer.Timer.add", "time.time"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.add"], ["", "def", "toc", "(", "self", ",", "average", "=", "True", ")", ":", "\n", "        ", "self", ".", "add", "(", "time", ".", "time", "(", ")", "-", "self", ".", "start_time", ")", "\n", "if", "average", ":", "\n", "            ", "return", "self", ".", "average_time", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "diff", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.add": [[28, 32], ["None"], "methods", ["None"], ["", "", "def", "add", "(", "self", ",", "time_diff", ")", ":", "\n", "        ", "self", ".", "diff", "=", "time_diff", "\n", "self", ".", "total_time", "+=", "self", ".", "diff", "\n", "self", ".", "calls", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.reset": [[33, 38], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "total_time", "=", "0.0", "\n", "self", ".", "calls", "=", "0", "\n", "self", ".", "start_time", "=", "0.0", "\n", "self", ".", "diff", "=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.avg_time_str": [[39, 42], ["str", "datetime.timedelta"], "methods", ["None"], ["", "def", "avg_time_str", "(", "self", ")", ":", "\n", "        ", "time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "self", ".", "average_time", ")", ")", "\n", "return", "time_str", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.get_time_str": [[44, 47], ["str", "datetime.timedelta"], "function", ["None"], ["", "", "def", "get_time_str", "(", "time_diff", ")", ":", "\n", "    ", "time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "time_diff", ")", ")", "\n", "return", "time_str", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.logger.setup_logger": [[7, 26], ["logging.getLogger", "logging.getLogger.setLevel", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.Formatter", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logging.FileHandler", "logging.FileHandler.setLevel", "logging.FileHandler.setFormatter", "logging.getLogger.addHandler", "os.path.join"], "function", ["None"], ["def", "setup_logger", "(", "name", ",", "save_dir", ",", "distributed_rank", ",", "filename", "=", "\"log.txt\"", ")", ":", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "name", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "# don't log results for the non-master process", "\n", "if", "distributed_rank", ">", "0", ":", "\n", "        ", "return", "logger", "\n", "", "ch", "=", "logging", ".", "StreamHandler", "(", "stream", "=", "sys", ".", "stdout", ")", "\n", "ch", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "\"%(asctime)s %(name)s %(levelname)s: %(message)s\"", ")", "\n", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "logger", ".", "addHandler", "(", "ch", ")", "\n", "\n", "if", "save_dir", ":", "\n", "        ", "fh", "=", "logging", ".", "FileHandler", "(", "os", ".", "path", ".", "join", "(", "save_dir", ",", "filename", ")", ")", "\n", "fh", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "fh", ".", "setFormatter", "(", "formatter", ")", "\n", "logger", ".", "addHandler", "(", "fh", ")", "\n", "\n", "", "return", "logger", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.__init__": [[31, 33], ["dict.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Registry", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register": [[34, 46], ["registry._register_generic", "registry._register_generic"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry._register_generic", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry._register_generic"], ["", "def", "register", "(", "self", ",", "module_name", ",", "module", "=", "None", ")", ":", "\n", "# used as function call", "\n", "        ", "if", "module", "is", "not", "None", ":", "\n", "            ", "_register_generic", "(", "self", ",", "module_name", ",", "module", ")", "\n", "return", "\n", "\n", "# used as decorator", "\n", "", "def", "register_fn", "(", "fn", ")", ":", "\n", "            ", "_register_generic", "(", "self", ",", "module_name", ",", "fn", ")", "\n", "return", "fn", "\n", "\n", "", "return", "register_fn", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry._register_generic": [[4, 7], ["None"], "function", ["None"], ["def", "_register_generic", "(", "module_dict", ",", "module_name", ",", "module", ")", ":", "\n", "    ", "assert", "module_name", "not", "in", "module_dict", "\n", "module_dict", "[", "module_name", "]", "=", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.cv2_util.findContours": [[8, 25], ["cv2.__version__.startswith", "cv2.findContours", "cv2.__version__.startswith", "cv2.findContours", "AssertionError"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.cv2_util.findContours", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.cv2_util.findContours"], ["def", "findContours", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Wraps cv2.findContours to maintain compatiblity between versions\n    3 and 4\n\n    Returns:\n        contours, hierarchy\n    \"\"\"", "\n", "if", "cv2", ".", "__version__", ".", "startswith", "(", "'4'", ")", ":", "\n", "        ", "contours", ",", "hierarchy", "=", "cv2", ".", "findContours", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "cv2", ".", "__version__", ".", "startswith", "(", "'3'", ")", ":", "\n", "        ", "_", ",", "contours", ",", "hierarchy", "=", "cv2", ".", "findContours", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "AssertionError", "(", "\n", "'cv2 must be either version 3 or 4 to call this method'", ")", "\n", "\n", "", "return", "contours", ",", "hierarchy", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.model_zoo.cache_url": [[20, 62], ["urlparse", "os.path.basename", "os.path.join", "vc_rcnn.utils.comm.synchronize", "os.path.expanduser", "os.getenv", "os.path.exists", "os.makedirs", "urlparse.path.replace", "vc_rcnn.utils.comm.is_main_process", "sys.stderr.write", "HASH_REGEX.search", "_download_url_to_file", "os.getenv", "os.path.join", "os.path.exists", "hash_prefix.group.group", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.is_main_process"], ["def", "cache_url", "(", "url", ",", "model_dir", "=", "None", ",", "progress", "=", "True", ")", ":", "\n", "    ", "r\"\"\"Loads the Torch serialized object at the given URL.\n    If the object is already present in `model_dir`, it's deserialized and\n    returned. The filename part of the URL should follow the naming convention\n    ``filename-<sha256>.ext`` where ``<sha256>`` is the first eight or more\n    digits of the SHA256 hash of the contents of the file. The hash is used to\n    ensure unique names and to verify the contents of the file.\n    The default value of `model_dir` is ``$TORCH_HOME/models`` where\n    ``$TORCH_HOME`` defaults to ``~/.torch``. The default directory can be\n    overridden with the ``$TORCH_MODEL_ZOO`` environment variable.\n    Args:\n        url (string): URL of the object to download\n        model_dir (string, optional): directory in which to save the object\n        progress (bool, optional): whether or not to display a progress bar to stderr\n    Example:\n        >>> cached_file = vc_rcnn.utils.model_zoo.cache_url('https://s3.amazonaws.com/pytorch/models/resnet18-5c106cde.pth')\n    \"\"\"", "\n", "if", "model_dir", "is", "None", ":", "\n", "        ", "torch_home", "=", "os", ".", "path", ".", "expanduser", "(", "os", ".", "getenv", "(", "\"TORCH_HOME\"", ",", "\"~/.torch\"", ")", ")", "\n", "model_dir", "=", "os", ".", "getenv", "(", "\"TORCH_MODEL_ZOO\"", ",", "os", ".", "path", ".", "join", "(", "torch_home", ",", "\"models\"", ")", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "model_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "model_dir", ")", "\n", "", "parts", "=", "urlparse", "(", "url", ")", "\n", "filename", "=", "os", ".", "path", ".", "basename", "(", "parts", ".", "path", ")", "\n", "if", "filename", "==", "\"model_final.pkl\"", ":", "\n", "# workaround as pre-trained Caffe2 models from Detectron have all the same filename", "\n", "# so make the full path the filename by replacing / with _", "\n", "        ", "filename", "=", "parts", ".", "path", ".", "replace", "(", "\"/\"", ",", "\"_\"", ")", "\n", "", "cached_file", "=", "os", ".", "path", ".", "join", "(", "model_dir", ",", "filename", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "cached_file", ")", "and", "is_main_process", "(", ")", ":", "\n", "        ", "sys", ".", "stderr", ".", "write", "(", "'Downloading: \"{}\" to {}\\n'", ".", "format", "(", "url", ",", "cached_file", ")", ")", "\n", "hash_prefix", "=", "HASH_REGEX", ".", "search", "(", "filename", ")", "\n", "if", "hash_prefix", "is", "not", "None", ":", "\n", "            ", "hash_prefix", "=", "hash_prefix", ".", "group", "(", "1", ")", "\n", "# workaround: Caffe2 models don't have a hash, but follow the R-50 convention,", "\n", "# which matches the hash PyTorch uses. So we skip the hash matching", "\n", "# if the hash_prefix is less than 6 characters", "\n", "if", "len", "(", "hash_prefix", ")", "<", "6", ":", "\n", "                ", "hash_prefix", "=", "None", "\n", "", "", "_download_url_to_file", "(", "url", ",", "cached_file", ",", "hash_prefix", ",", "progress", "=", "progress", ")", "\n", "", "synchronize", "(", ")", "\n", "return", "cached_file", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.SmoothedValue.__init__": [[15, 20], ["collections.deque"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "self", ".", "deque", "=", "deque", "(", "maxlen", "=", "window_size", ")", "\n", "self", ".", "series", "=", "[", "]", "\n", "self", ".", "total", "=", "0.0", "\n", "self", ".", "count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.SmoothedValue.update": [[21, 26], ["metric_logger.SmoothedValue.deque.append", "metric_logger.SmoothedValue.series.append"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "value", ")", ":", "\n", "        ", "self", ".", "deque", ".", "append", "(", "value", ")", "\n", "self", ".", "series", ".", "append", "(", "value", ")", "\n", "self", ".", "count", "+=", "1", "\n", "self", ".", "total", "+=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.SmoothedValue.median": [[27, 31], ["torch.tensor", "torch.tensor.median().item", "list", "torch.tensor.median"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.SmoothedValue.median"], ["", "@", "property", "\n", "def", "median", "(", "self", ")", ":", "\n", "        ", "d", "=", "torch", ".", "tensor", "(", "list", "(", "self", ".", "deque", ")", ")", "\n", "return", "d", ".", "median", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.SmoothedValue.avg": [[32, 36], ["torch.tensor", "torch.tensor.mean().item", "list", "torch.tensor.mean"], "methods", ["None"], ["", "@", "property", "\n", "def", "avg", "(", "self", ")", ":", "\n", "        ", "d", "=", "torch", ".", "tensor", "(", "list", "(", "self", ".", "deque", ")", ")", "\n", "return", "d", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.SmoothedValue.global_avg": [[37, 40], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "global_avg", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "total", "/", "self", ".", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.MetricLogger.__init__": [[43, 46], ["collections.defaultdict"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "delimiter", "=", "\"\\t\"", ")", ":", "\n", "        ", "self", ".", "meters", "=", "defaultdict", "(", "SmoothedValue", ")", "\n", "self", ".", "delimiter", "=", "delimiter", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.MetricLogger.update": [[47, 53], ["kwargs.items", "isinstance", "isinstance", "metric_logger.MetricLogger.meters[].update", "v.item.item.item"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update"], ["", "def", "update", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "v", "=", "v", ".", "item", "(", ")", "\n", "", "assert", "isinstance", "(", "v", ",", "(", "float", ",", "int", ")", ")", "\n", "self", ".", "meters", "[", "k", "]", ".", "update", "(", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.MetricLogger.__getattr__": [[54, 61], ["AttributeError", "type"], "methods", ["None"], ["", "", "def", "__getattr__", "(", "self", ",", "attr", ")", ":", "\n", "        ", "if", "attr", "in", "self", ".", "meters", ":", "\n", "            ", "return", "self", ".", "meters", "[", "attr", "]", "\n", "", "if", "attr", "in", "self", ".", "__dict__", ":", "\n", "            ", "return", "self", ".", "__dict__", "[", "attr", "]", "\n", "", "raise", "AttributeError", "(", "\"'{}' object has no attribute '{}'\"", ".", "format", "(", "\n", "type", "(", "self", ")", ".", "__name__", ",", "attr", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.MetricLogger.__str__": [[62, 69], ["metric_logger.MetricLogger.meters.items", "metric_logger.MetricLogger.delimiter.join", "loss_str.append"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "loss_str", "=", "[", "]", "\n", "for", "name", ",", "meter", "in", "self", ".", "meters", ".", "items", "(", ")", ":", "\n", "            ", "loss_str", ".", "append", "(", "\n", "\"{}: {:.4f} ({:.4f})\"", ".", "format", "(", "name", ",", "meter", ".", "median", ",", "meter", ".", "global_avg", ")", "\n", ")", "\n", "", "return", "self", ".", "delimiter", ".", "join", "(", "loss_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.TensorboardLogger.__init__": [[73, 81], ["metric_logger.MetricLogger.__init__", "metric_logger.TensorboardLogger._get_tensorboard_writer"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.TensorboardLogger._get_tensorboard_writer"], ["    ", "def", "__init__", "(", "self", ",", "\n", "log_dir", ",", "\n", "start_iter", "=", "0", ",", "\n", "delimiter", "=", "'\\t'", ")", ":", "\n", "\n", "        ", "super", "(", "TensorboardLogger", ",", "self", ")", ".", "__init__", "(", "delimiter", ")", "\n", "self", ".", "iteration", "=", "start_iter", "\n", "self", ".", "writer", "=", "self", ".", "_get_tensorboard_writer", "(", "log_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.TensorboardLogger._get_tensorboard_writer": [[82, 98], ["comm.is_main_process", "datetime.datetime.datetime.fromtimestamp().strftime", "SummaryWriter", "ImportError", "datetime.datetime.datetime.fromtimestamp", "time.time"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.is_main_process"], ["", "@", "staticmethod", "\n", "def", "_get_tensorboard_writer", "(", "log_dir", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from", "tensorboardX", "import", "SummaryWriter", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "\n", "'To use tensorboard please install tensorboardX '", "\n", "'[ pip install tensorflow tensorboardX ].'", "\n", ")", "\n", "\n", "", "if", "is_main_process", "(", ")", ":", "\n", "            ", "timestamp", "=", "datetime", ".", "fromtimestamp", "(", "time", ".", "time", "(", ")", ")", ".", "strftime", "(", "'%Y%m%d-%H:%M'", ")", "\n", "tb_logger", "=", "SummaryWriter", "(", "'{}-{}'", ".", "format", "(", "log_dir", ",", "timestamp", ")", ")", "\n", "return", "tb_logger", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.metric_logger.TensorboardLogger.update": [[99, 108], ["metric_logger.MetricLogger.update", "kwargs.items", "isinstance", "isinstance", "metric_logger.TensorboardLogger.writer.add_scalar", "v.item.item.item"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update"], ["", "", "def", "update", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "TensorboardLogger", ",", "self", ")", ".", "update", "(", "**", "kwargs", ")", "\n", "if", "self", ".", "writer", ":", "\n", "            ", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                    ", "v", "=", "v", ".", "item", "(", ")", "\n", "", "assert", "isinstance", "(", "v", ",", "(", "float", ",", "int", ")", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "k", ",", "v", ",", "self", ".", "iteration", ")", "\n", "", "self", ".", "iteration", "+=", "1", "", "", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._rename_basic_resnet_weights": [[12, 63], ["k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace"], "function", ["None"], ["def", "_rename_basic_resnet_weights", "(", "layer_keys", ")", ":", "\n", "    ", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"_\"", ",", "\".\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".w\"", ",", "\".weight\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".bn\"", ",", "\"_bn\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".b\"", ",", "\".bias\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"_bn.s\"", ",", "\"_bn.scale\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".biasranch\"", ",", "\".branch\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"bbox.pred\"", ",", "\"bbox_pred\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"cls.score\"", ",", "\"cls_score\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"res.conv1_\"", ",", "\"conv1_\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# RPN / Faster RCNN", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".biasbox\"", ",", "\".bbox\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv.rpn\"", ",", "\"rpn.conv\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"rpn.bbox.pred\"", ",", "\"rpn.bbox_pred\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"rpn.cls.logits\"", ",", "\"rpn.cls_logits\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# Affine-Channel -> BatchNorm enaming", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"_bn.scale\"", ",", "\"_bn.weight\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# Make torchvision-compatible", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv1_bn.\"", ",", "\"bn1.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"res2.\"", ",", "\"layer1.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"res3.\"", ",", "\"layer2.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"res4.\"", ",", "\"layer3.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"res5.\"", ",", "\"layer4.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2a.\"", ",", "\".conv1.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2a_bn.\"", ",", "\".bn1.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2b.\"", ",", "\".conv2.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2b_bn.\"", ",", "\".bn2.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2c.\"", ",", "\".conv3.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2c_bn.\"", ",", "\".bn3.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch1.\"", ",", "\".downsample.0.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch1_bn.\"", ",", "\".downsample.1.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# GroupNorm", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv1.gn.s\"", ",", "\"bn1.weight\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv1.gn.bias\"", ",", "\"bn1.bias\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv2.gn.s\"", ",", "\"bn2.weight\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv2.gn.bias\"", ",", "\"bn2.bias\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv3.gn.s\"", ",", "\"bn3.weight\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv3.gn.bias\"", ",", "\"bn3.bias\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"downsample.0.gn.s\"", ",", "\"downsample.1.weight\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"downsample.0.gn.bias\"", ",", "\"downsample.1.bias\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "return", "layer_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._rename_fpn_weights": [[64, 82], ["enumerate", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace"], "function", ["None"], ["", "def", "_rename_fpn_weights", "(", "layer_keys", ",", "stage_names", ")", ":", "\n", "    ", "for", "mapped_idx", ",", "stage_name", "in", "enumerate", "(", "stage_names", ",", "1", ")", ":", "\n", "        ", "suffix", "=", "\"\"", "\n", "if", "mapped_idx", "<", "4", ":", "\n", "            ", "suffix", "=", "\".lateral\"", "\n", "", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"fpn.inner.layer{}.sum{}\"", ".", "format", "(", "stage_name", ",", "suffix", ")", ",", "\"fpn_inner{}\"", ".", "format", "(", "mapped_idx", ")", ")", "for", "k", "in", "layer_keys", "\n", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"fpn.layer{}.sum\"", ".", "format", "(", "stage_name", ")", ",", "\"fpn_layer{}\"", ".", "format", "(", "mapped_idx", ")", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "\n", "", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"rpn.conv.fpn2\"", ",", "\"rpn.conv\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"rpn.bbox_pred.fpn2\"", ",", "\"rpn.bbox_pred\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"rpn.cls_logits.fpn2\"", ",", "\"rpn.cls_logits\"", ")", "for", "k", "in", "layer_keys", "\n", "]", "\n", "\n", "return", "layer_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._rename_weights_for_resnet": [[84, 131], ["sorted", "sorted", "c2_model_loading._rename_basic_resnet_weights", "c2_model_loading._rename_fpn_weights", "logging.getLogger", "logging.getLogger.info", "max", "collections.OrderedDict", "weights.keys", "weights.keys", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "torch.from_numpy", "logging.getLogger.info", "zip", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._rename_basic_resnet_weights", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._rename_fpn_weights", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info"], ["", "def", "_rename_weights_for_resnet", "(", "weights", ",", "stage_names", ")", ":", "\n", "    ", "original_keys", "=", "sorted", "(", "weights", ".", "keys", "(", ")", ")", "\n", "layer_keys", "=", "sorted", "(", "weights", ".", "keys", "(", ")", ")", "\n", "\n", "# for X-101, rename output to fc1000 to avoid conflicts afterwards", "\n", "layer_keys", "=", "[", "k", "if", "k", "!=", "\"pred_b\"", "else", "\"fc1000_b\"", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", "if", "k", "!=", "\"pred_w\"", "else", "\"fc1000_w\"", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# performs basic renaming: _ -> . , etc", "\n", "layer_keys", "=", "_rename_basic_resnet_weights", "(", "layer_keys", ")", "\n", "\n", "# FPN", "\n", "layer_keys", "=", "_rename_fpn_weights", "(", "layer_keys", ",", "stage_names", ")", "\n", "\n", "# Mask R-CNN", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"mask.fcn.logits\"", ",", "\"mask_fcn_logits\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".[mask].fcn\"", ",", "\"mask_fcn\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv5.mask\"", ",", "\"conv5_mask\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# Keypoint R-CNN", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"kps.score.lowres\"", ",", "\"kps_score_lowres\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"kps.score\"", ",", "\"kps_score\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv.fcn\"", ",", "\"conv_fcn\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# Rename for our RPN structure", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"rpn.\"", ",", "\"rpn.head.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "key_map", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "original_keys", ",", "layer_keys", ")", "}", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Remapping C2 weights\"", ")", "\n", "max_c2_key_size", "=", "max", "(", "[", "len", "(", "k", ")", "for", "k", "in", "original_keys", "if", "\"_momentum\"", "not", "in", "k", "]", ")", "\n", "\n", "new_weights", "=", "OrderedDict", "(", ")", "\n", "for", "k", "in", "original_keys", ":", "\n", "        ", "v", "=", "weights", "[", "k", "]", "\n", "if", "\"_momentum\"", "in", "k", ":", "\n", "            ", "continue", "\n", "# if 'fc1000' in k:", "\n", "#     continue", "\n", "", "w", "=", "torch", ".", "from_numpy", "(", "v", ")", "\n", "# if \"bn\" in k:", "\n", "#     w = w.view(1, -1, 1, 1)", "\n", "logger", ".", "info", "(", "\"C2 name: {: <{}} mapped name: {}\"", ".", "format", "(", "k", ",", "max_c2_key_size", ",", "key_map", "[", "k", "]", ")", ")", "\n", "new_weights", "[", "key_map", "[", "k", "]", "]", "=", "w", "\n", "\n", "", "return", "new_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._load_c2_pickled_weights": [[133, 144], ["open", "pickle.load", "pickle.load"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["", "def", "_load_c2_pickled_weights", "(", "file_path", ")", ":", "\n", "    ", "with", "open", "(", "file_path", ",", "\"rb\"", ")", "as", "f", ":", "\n", "        ", "if", "torch", ".", "_six", ".", "PY3", ":", "\n", "            ", "data", "=", "pickle", ".", "load", "(", "f", ",", "encoding", "=", "\"latin1\"", ")", "\n", "", "else", ":", "\n", "            ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "", "if", "\"blobs\"", "in", "data", ":", "\n", "        ", "weights", "=", "data", "[", "\"blobs\"", "]", "\n", "", "else", ":", "\n", "        ", "weights", "=", "data", "\n", "", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._rename_conv_weights_for_deformable_conv_layers": [[146, 171], ["logging.getLogger", "logging.getLogger.info", "sorted", "enumerate", "state_dict.keys", "re.match", "old_key.replace", "logging.getLogger.info", "old_key.find"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info"], ["", "def", "_rename_conv_weights_for_deformable_conv_layers", "(", "state_dict", ",", "cfg", ")", ":", "\n", "    ", "import", "re", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Remapping conv weights for deformable conv weights\"", ")", "\n", "layer_keys", "=", "sorted", "(", "state_dict", ".", "keys", "(", ")", ")", "\n", "for", "ix", ",", "stage_with_dcn", "in", "enumerate", "(", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STAGE_WITH_DCN", ",", "1", ")", ":", "\n", "        ", "if", "not", "stage_with_dcn", ":", "\n", "            ", "continue", "\n", "", "for", "old_key", "in", "layer_keys", ":", "\n", "            ", "pattern", "=", "\".*layer{}.*conv2.*\"", ".", "format", "(", "ix", ")", "\n", "r", "=", "re", ".", "match", "(", "pattern", ",", "old_key", ")", "\n", "if", "r", "is", "None", ":", "\n", "                ", "continue", "\n", "", "for", "param", "in", "[", "\"weight\"", ",", "\"bias\"", "]", ":", "\n", "                ", "if", "old_key", ".", "find", "(", "param", ")", "is", "-", "1", ":", "\n", "                    ", "continue", "\n", "", "new_key", "=", "old_key", ".", "replace", "(", "\n", "\"conv2.{}\"", ".", "format", "(", "param", ")", ",", "\"conv2.conv.{}\"", ".", "format", "(", "param", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\"pattern: {}, old_key: {}, new_key: {}\"", ".", "format", "(", "\n", "pattern", ",", "old_key", ",", "new_key", "\n", ")", ")", "\n", "state_dict", "[", "new_key", "]", "=", "state_dict", "[", "old_key", "]", "\n", "del", "state_dict", "[", "old_key", "]", "\n", "", "", "", "return", "state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading.load_resnet_c2_format": [[182, 203], ["C2_FORMAT_LOADER.register", "C2_FORMAT_LOADER.register", "C2_FORMAT_LOADER.register", "C2_FORMAT_LOADER.register", "C2_FORMAT_LOADER.register", "C2_FORMAT_LOADER.register", "C2_FORMAT_LOADER.register", "C2_FORMAT_LOADER.register", "C2_FORMAT_LOADER.register", "c2_model_loading._load_c2_pickled_weights", "conv_body.replace().replace().replace", "arch.replace.replace", "c2_model_loading._rename_weights_for_resnet", "c2_model_loading._rename_conv_weights_for_deformable_conv_layers", "dict", "conv_body.replace().replace", "conv_body.replace"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._load_c2_pickled_weights", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._rename_weights_for_resnet", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading._rename_conv_weights_for_deformable_conv_layers"], ["@", "C2_FORMAT_LOADER", ".", "register", "(", "\"R-50-C4\"", ")", "\n", "@", "C2_FORMAT_LOADER", ".", "register", "(", "\"R-50-C5\"", ")", "\n", "@", "C2_FORMAT_LOADER", ".", "register", "(", "\"R-101-C4\"", ")", "\n", "@", "C2_FORMAT_LOADER", ".", "register", "(", "\"R-101-C5\"", ")", "\n", "@", "C2_FORMAT_LOADER", ".", "register", "(", "\"R-50-FPN\"", ")", "\n", "@", "C2_FORMAT_LOADER", ".", "register", "(", "\"R-50-FPN-RETINANET\"", ")", "\n", "@", "C2_FORMAT_LOADER", ".", "register", "(", "\"R-101-FPN\"", ")", "\n", "@", "C2_FORMAT_LOADER", ".", "register", "(", "\"R-101-FPN-RETINANET\"", ")", "\n", "@", "C2_FORMAT_LOADER", ".", "register", "(", "\"R-152-FPN\"", ")", "\n", "def", "load_resnet_c2_format", "(", "cfg", ",", "f", ")", ":", "\n", "    ", "state_dict", "=", "_load_c2_pickled_weights", "(", "f", ")", "\n", "conv_body", "=", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "CONV_BODY", "\n", "arch", "=", "conv_body", ".", "replace", "(", "\"-C4\"", ",", "\"\"", ")", ".", "replace", "(", "\"-C5\"", ",", "\"\"", ")", ".", "replace", "(", "\"-FPN\"", ",", "\"\"", ")", "\n", "arch", "=", "arch", ".", "replace", "(", "\"-RETINANET\"", ",", "\"\"", ")", "\n", "stages", "=", "_C2_STAGE_NAMES", "[", "arch", "]", "\n", "state_dict", "=", "_rename_weights_for_resnet", "(", "state_dict", ",", "stages", ")", "\n", "# ***********************************", "\n", "# for deformable convolutional layer", "\n", "state_dict", "=", "_rename_conv_weights_for_deformable_conv_layers", "(", "state_dict", ",", "cfg", ")", "\n", "# ***********************************", "\n", "return", "dict", "(", "model", "=", "state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading.load_c2_format": [[205, 207], ["None"], "function", ["None"], ["", "def", "load_c2_format", "(", "cfg", ",", "f", ")", ":", "\n", "    ", "return", "C2_FORMAT_LOADER", "[", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "CONV_BODY", "]", "(", "cfg", ",", "f", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.collect_env.get_pil_version": [[7, 9], ["None"], "function", ["None"], ["def", "get_pil_version", "(", ")", ":", "\n", "    ", "return", "\"\\n        Pillow ({})\"", ".", "format", "(", "PIL", ".", "__version__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.collect_env.collect_env_info": [[11, 15], ["torch.utils.collect_env.get_pretty_env_info", "collect_env.get_pil_version"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.collect_env.get_pil_version"], ["", "def", "collect_env_info", "(", ")", ":", "\n", "    ", "env_str", "=", "get_pretty_env_info", "(", ")", "\n", "env_str", "+=", "get_pil_version", "(", ")", "\n", "return", "env_str", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.__init__": [[14, 31], ["logging.getLogger"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ",", "\n", "optimizer", "=", "None", ",", "\n", "scheduler", "=", "None", ",", "\n", "save_dir", "=", "\"\"", ",", "\n", "save_to_disk", "=", "None", ",", "\n", "logger", "=", "None", ",", "\n", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "scheduler", "=", "scheduler", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "save_to_disk", "=", "save_to_disk", "\n", "if", "logger", "is", "None", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "", "self", ".", "logger", "=", "logger", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save": [[32, 51], ["checkpoint.Checkpointer.model.state_dict", "data.update", "os.path.join", "checkpoint.Checkpointer.logger.info", "torch.save", "checkpoint.Checkpointer.tag_last_checkpoint", "checkpoint.Checkpointer.optimizer.state_dict", "checkpoint.Checkpointer.scheduler.state_dict"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.tag_last_checkpoint", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict"], ["", "def", "save", "(", "self", ",", "name", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "not", "self", ".", "save_dir", ":", "\n", "            ", "return", "\n", "\n", "", "if", "not", "self", ".", "save_to_disk", ":", "\n", "            ", "return", "\n", "\n", "", "data", "=", "{", "}", "\n", "data", "[", "\"model\"", "]", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "if", "self", ".", "optimizer", "is", "not", "None", ":", "\n", "            ", "data", "[", "\"optimizer\"", "]", "=", "self", ".", "optimizer", ".", "state_dict", "(", ")", "\n", "", "if", "self", ".", "scheduler", "is", "not", "None", ":", "\n", "            ", "data", "[", "\"scheduler\"", "]", "=", "self", ".", "scheduler", ".", "state_dict", "(", ")", "\n", "", "data", ".", "update", "(", "kwargs", ")", "\n", "\n", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"{}.pth\"", ".", "format", "(", "name", ")", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Saving checkpoint to {}\"", ".", "format", "(", "save_file", ")", ")", "\n", "torch", ".", "save", "(", "data", ",", "save_file", ")", "\n", "self", ".", "tag_last_checkpoint", "(", "save_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load": [[52, 72], ["checkpoint.Checkpointer.Checkpointer.logger.info", "checkpoint.Checkpointer.Checkpointer._load_file", "checkpoint.Checkpointer.Checkpointer._load_model", "checkpoint.Checkpointer.Checkpointer.has_checkpoint", "checkpoint.Checkpointer.Checkpointer.get_checkpoint_file", "checkpoint.Checkpointer.Checkpointer.logger.info", "checkpoint.Checkpointer.Checkpointer.logger.info", "checkpoint.Checkpointer.Checkpointer.optimizer.load_state_dict", "checkpoint.Checkpointer.Checkpointer.logger.info", "checkpoint.Checkpointer.Checkpointer.scheduler.load_state_dict", "checkpoint.Checkpointer.Checkpointer.pop", "checkpoint.Checkpointer.Checkpointer.pop"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.DetectronCheckpointer._load_file", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer._load_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.has_checkpoint", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.get_checkpoint_file", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["", "def", "load", "(", "self", ",", "f", "=", "None", ",", "use_latest", "=", "True", ")", ":", "\n", "        ", "if", "self", ".", "has_checkpoint", "(", ")", "and", "use_latest", ":", "\n", "# override argument with existing checkpoint", "\n", "            ", "f", "=", "self", ".", "get_checkpoint_file", "(", ")", "\n", "", "if", "not", "f", ":", "\n", "# no checkpoint could be found", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"No checkpoint found. Initializing model from scratch\"", ")", "\n", "return", "{", "}", "\n", "", "self", ".", "logger", ".", "info", "(", "\"Loading checkpoint from {}\"", ".", "format", "(", "f", ")", ")", "\n", "checkpoint", "=", "self", ".", "_load_file", "(", "f", ")", "\n", "self", ".", "_load_model", "(", "checkpoint", ")", "\n", "if", "\"optimizer\"", "in", "checkpoint", "and", "self", ".", "optimizer", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"Loading optimizer from {}\"", ".", "format", "(", "f", ")", ")", "\n", "self", ".", "optimizer", ".", "load_state_dict", "(", "checkpoint", ".", "pop", "(", "\"optimizer\"", ")", ")", "\n", "", "if", "\"scheduler\"", "in", "checkpoint", "and", "self", ".", "scheduler", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"Loading scheduler from {}\"", ".", "format", "(", "f", ")", ")", "\n", "self", ".", "scheduler", ".", "load_state_dict", "(", "checkpoint", ".", "pop", "(", "\"scheduler\"", ")", ")", "\n", "\n", "# return any further checkpoint data", "\n", "", "return", "checkpoint", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.has_checkpoint": [[73, 76], ["os.path.join", "os.path.exists"], "methods", ["None"], ["", "def", "has_checkpoint", "(", "self", ")", ":", "\n", "        ", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"last_checkpoint\"", ")", "\n", "return", "os", ".", "path", ".", "exists", "(", "save_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.get_checkpoint_file": [[77, 88], ["os.path.join", "open", "f.read", "last_saved.strip.strip.strip"], "methods", ["None"], ["", "def", "get_checkpoint_file", "(", "self", ")", ":", "\n", "        ", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"last_checkpoint\"", ")", "\n", "try", ":", "\n", "            ", "with", "open", "(", "save_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "last_saved", "=", "f", ".", "read", "(", ")", "\n", "last_saved", "=", "last_saved", ".", "strip", "(", ")", "\n", "", "", "except", "IOError", ":", "\n", "# if file doesn't exist, maybe because it has just been", "\n", "# deleted by a separate process", "\n", "            ", "last_saved", "=", "\"\"", "\n", "", "return", "last_saved", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.tag_last_checkpoint": [[89, 93], ["os.path.join", "open", "f.write"], "methods", ["None"], ["", "def", "tag_last_checkpoint", "(", "self", ",", "last_filename", ")", ":", "\n", "        ", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"last_checkpoint\"", ")", "\n", "with", "open", "(", "save_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "last_filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer._load_file": [[94, 96], ["torch.load", "torch.device"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["", "", "def", "_load_file", "(", "self", ",", "f", ")", ":", "\n", "        ", "return", "torch", ".", "load", "(", "f", ",", "map_location", "=", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer._load_model": [[97, 99], ["vc_rcnn.utils.model_serialization.load_state_dict", "checkpoint.pop"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["", "def", "_load_model", "(", "self", ",", "checkpoint", ")", ":", "\n", "        ", "load_state_dict", "(", "self", ".", "model", ",", "checkpoint", ".", "pop", "(", "\"model\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.DetectronCheckpointer.__init__": [[102, 116], ["checkpoint.Checkpointer.__init__", "cfg.clone"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "cfg", ",", "\n", "model", ",", "\n", "optimizer", "=", "None", ",", "\n", "scheduler", "=", "None", ",", "\n", "save_dir", "=", "\"\"", ",", "\n", "save_to_disk", "=", "None", ",", "\n", "logger", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "DetectronCheckpointer", ",", "self", ")", ".", "__init__", "(", "\n", "model", ",", "optimizer", ",", "scheduler", ",", "save_dir", ",", "save_to_disk", ",", "logger", "\n", ")", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.DetectronCheckpointer._load_file": [[117, 140], ["f.startswith", "f.startswith", "f.endswith", "checkpoint.Checkpointer._load_file", "vc_rcnn.utils.imports.import_file", "vc_rcnn.utils.imports.import_file.ModelCatalog.get", "checkpoint.DetectronCheckpointer.logger.info", "vc_rcnn.utils.model_zoo.cache_url", "checkpoint.DetectronCheckpointer.logger.info", "vc_rcnn.utils.c2_model_loading.load_c2_format", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.DetectronCheckpointer._load_file", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.model_zoo.cache_url", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.c2_model_loading.load_c2_format"], ["", "def", "_load_file", "(", "self", ",", "f", ")", ":", "\n", "# catalog lookup", "\n", "        ", "if", "f", ".", "startswith", "(", "\"catalog://\"", ")", ":", "\n", "            ", "paths_catalog", "=", "import_file", "(", "\n", "\"vc_rcnn.config.paths_catalog\"", ",", "self", ".", "cfg", ".", "PATHS_CATALOG", ",", "True", "\n", ")", "\n", "catalog_f", "=", "paths_catalog", ".", "ModelCatalog", ".", "get", "(", "f", "[", "len", "(", "\"catalog://\"", ")", ":", "]", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"{} points to {}\"", ".", "format", "(", "f", ",", "catalog_f", ")", ")", "\n", "f", "=", "catalog_f", "\n", "# download url files", "\n", "", "if", "f", ".", "startswith", "(", "\"http\"", ")", ":", "\n", "# if the file is a url path, download it and cache it", "\n", "            ", "cached_f", "=", "cache_url", "(", "f", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"url {} cached in {}\"", ".", "format", "(", "f", ",", "cached_f", ")", ")", "\n", "f", "=", "cached_f", "\n", "# convert Caffe2 checkpoint from pkl", "\n", "", "if", "f", ".", "endswith", "(", "\".pkl\"", ")", ":", "\n", "            ", "return", "load_c2_format", "(", "self", ".", "cfg", ",", "f", ")", "\n", "# load native detectron.pytorch checkpoint", "\n", "", "loaded", "=", "super", "(", "DetectronCheckpointer", ",", "self", ")", ".", "_load_file", "(", "f", ")", "\n", "if", "\"model\"", "not", "in", "loaded", ":", "\n", "            ", "loaded", "=", "dict", "(", "model", "=", "loaded", ")", "\n", "", "return", "loaded", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.env.setup_environment": [[7, 18], ["os.environ.get", "env.setup_custom_environment"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.env.setup_custom_environment"], ["def", "setup_environment", "(", ")", ":", "\n", "    ", "\"\"\"Perform environment setup work. The default setup is a no-op, but this\n    function allows the user to specify a Python source file that performs\n    custom setup work that may be necessary to their computing environment.\n    \"\"\"", "\n", "custom_module_path", "=", "os", ".", "environ", ".", "get", "(", "\"TORCH_DETECTRON_ENV_MODULE\"", ")", "\n", "if", "custom_module_path", ":", "\n", "        ", "setup_custom_environment", "(", "custom_module_path", ")", "\n", "", "else", ":", "\n", "# The default setup is a no-op", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.env.setup_custom_environment": [[20, 34], ["vc_rcnn.utils.imports.import_file", "vc_rcnn.utils.imports.import_file.setup_environment", "hasattr", "callable"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.env.setup_environment"], ["", "", "def", "setup_custom_environment", "(", "custom_module_path", ")", ":", "\n", "    ", "\"\"\"Load custom environment setup from a Python source file and run the setup\n    function.\n    \"\"\"", "\n", "module", "=", "import_file", "(", "\"vc_rcnn.utils.env.custom_module\"", ",", "custom_module_path", ")", "\n", "assert", "hasattr", "(", "module", ",", "\"setup_environment\"", ")", "and", "callable", "(", "\n", "module", ".", "setup_environment", "\n", ")", ",", "(", "\n", "\"Custom environment module defined in {} does not have the \"", "\n", "\"required callable attribute 'setup_environment'.\"", "\n", ")", ".", "format", "(", "\n", "custom_module_path", "\n", ")", "\n", "module", ".", "setup_environment", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.proc_ansdict.ans_stat": [[26, 48], ["ans_freq_dict.copy", "core.data.ans_punct.prep_ans", "ans_to_ix.__len__", "ans_freq_dict.copy.pop", "ans_to_ix.__len__"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.ans_punct.prep_ans", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__"], ["def", "ans_stat", "(", "stat_ans_list", ")", ":", "\n", "    ", "ans_to_ix", "=", "{", "}", "\n", "ix_to_ans", "=", "{", "}", "\n", "ans_freq_dict", "=", "{", "}", "\n", "\n", "for", "ans", "in", "stat_ans_list", ":", "\n", "        ", "ans_proc", "=", "prep_ans", "(", "ans", "[", "'multiple_choice_answer'", "]", ")", "\n", "if", "ans_proc", "not", "in", "ans_freq_dict", ":", "\n", "            ", "ans_freq_dict", "[", "ans_proc", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "ans_freq_dict", "[", "ans_proc", "]", "+=", "1", "\n", "\n", "", "", "ans_freq_filter", "=", "ans_freq_dict", ".", "copy", "(", ")", "\n", "for", "ans", "in", "ans_freq_dict", ":", "\n", "        ", "if", "ans_freq_dict", "[", "ans", "]", "<=", "8", ":", "\n", "            ", "ans_freq_filter", ".", "pop", "(", "ans", ")", "\n", "\n", "", "", "for", "ans", "in", "ans_freq_filter", ":", "\n", "        ", "ix_to_ans", "[", "ans_to_ix", ".", "__len__", "(", ")", "]", "=", "ans", "\n", "ans_to_ix", "[", "ans", "]", "=", "ans_to_ix", ".", "__len__", "(", ")", "\n", "\n", "", "return", "ans_to_ix", ",", "ix_to_ans", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.__init__": [[11, 66], ["re.compile", "re.compile", "vqa.getQuesIds"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.getQuesIds"], ["\t", "def", "__init__", "(", "self", ",", "vqa", ",", "vqaRes", ",", "n", "=", "2", ")", ":", "\n", "\t\t", "self", ".", "n", "=", "n", "\n", "self", ".", "accuracy", "=", "{", "}", "\n", "self", ".", "evalQA", "=", "{", "}", "\n", "self", ".", "evalQuesType", "=", "{", "}", "\n", "self", ".", "evalAnsType", "=", "{", "}", "\n", "self", ".", "vqa", "=", "vqa", "\n", "self", ".", "vqaRes", "=", "vqaRes", "\n", "self", ".", "params", "=", "{", "'question_id'", ":", "vqa", ".", "getQuesIds", "(", ")", "}", "\n", "self", ".", "contractions", "=", "{", "\"aint\"", ":", "\"ain't\"", ",", "\"arent\"", ":", "\"aren't\"", ",", "\"cant\"", ":", "\"can't\"", ",", "\"couldve\"", ":", "\"could've\"", ",", "\"couldnt\"", ":", "\"couldn't\"", ",", "\n", "\"couldn'tve\"", ":", "\"couldn't've\"", ",", "\"couldnt've\"", ":", "\"couldn't've\"", ",", "\"didnt\"", ":", "\"didn't\"", ",", "\"doesnt\"", ":", "\"doesn't\"", ",", "\"dont\"", ":", "\"don't\"", ",", "\"hadnt\"", ":", "\"hadn't\"", ",", "\n", "\"hadnt've\"", ":", "\"hadn't've\"", ",", "\"hadn'tve\"", ":", "\"hadn't've\"", ",", "\"hasnt\"", ":", "\"hasn't\"", ",", "\"havent\"", ":", "\"haven't\"", ",", "\"hed\"", ":", "\"he'd\"", ",", "\"hed've\"", ":", "\"he'd've\"", ",", "\n", "\"he'dve\"", ":", "\"he'd've\"", ",", "\"hes\"", ":", "\"he's\"", ",", "\"howd\"", ":", "\"how'd\"", ",", "\"howll\"", ":", "\"how'll\"", ",", "\"hows\"", ":", "\"how's\"", ",", "\"Id've\"", ":", "\"I'd've\"", ",", "\"I'dve\"", ":", "\"I'd've\"", ",", "\n", "\"Im\"", ":", "\"I'm\"", ",", "\"Ive\"", ":", "\"I've\"", ",", "\"isnt\"", ":", "\"isn't\"", ",", "\"itd\"", ":", "\"it'd\"", ",", "\"itd've\"", ":", "\"it'd've\"", ",", "\"it'dve\"", ":", "\"it'd've\"", ",", "\"itll\"", ":", "\"it'll\"", ",", "\"let's\"", ":", "\"let's\"", ",", "\n", "\"maam\"", ":", "\"ma'am\"", ",", "\"mightnt\"", ":", "\"mightn't\"", ",", "\"mightnt've\"", ":", "\"mightn't've\"", ",", "\"mightn'tve\"", ":", "\"mightn't've\"", ",", "\"mightve\"", ":", "\"might've\"", ",", "\n", "\"mustnt\"", ":", "\"mustn't\"", ",", "\"mustve\"", ":", "\"must've\"", ",", "\"neednt\"", ":", "\"needn't\"", ",", "\"notve\"", ":", "\"not've\"", ",", "\"oclock\"", ":", "\"o'clock\"", ",", "\"oughtnt\"", ":", "\"oughtn't\"", ",", "\n", "\"ow's'at\"", ":", "\"'ow's'at\"", ",", "\"'ows'at\"", ":", "\"'ow's'at\"", ",", "\"'ow'sat\"", ":", "\"'ow's'at\"", ",", "\"shant\"", ":", "\"shan't\"", ",", "\"shed've\"", ":", "\"she'd've\"", ",", "\"she'dve\"", ":", "\"she'd've\"", ",", "\n", "\"she's\"", ":", "\"she's\"", ",", "\"shouldve\"", ":", "\"should've\"", ",", "\"shouldnt\"", ":", "\"shouldn't\"", ",", "\"shouldnt've\"", ":", "\"shouldn't've\"", ",", "\"shouldn'tve\"", ":", "\"shouldn't've\"", ",", "\n", "\"somebody'd\"", ":", "\"somebodyd\"", ",", "\"somebodyd've\"", ":", "\"somebody'd've\"", ",", "\"somebody'dve\"", ":", "\"somebody'd've\"", ",", "\"somebodyll\"", ":", "\"somebody'll\"", ",", "\n", "\"somebodys\"", ":", "\"somebody's\"", ",", "\"someoned\"", ":", "\"someone'd\"", ",", "\"someoned've\"", ":", "\"someone'd've\"", ",", "\"someone'dve\"", ":", "\"someone'd've\"", ",", "\n", "\"someonell\"", ":", "\"someone'll\"", ",", "\"someones\"", ":", "\"someone's\"", ",", "\"somethingd\"", ":", "\"something'd\"", ",", "\"somethingd've\"", ":", "\"something'd've\"", ",", "\n", "\"something'dve\"", ":", "\"something'd've\"", ",", "\"somethingll\"", ":", "\"something'll\"", ",", "\"thats\"", ":", "\"that's\"", ",", "\"thered\"", ":", "\"there'd\"", ",", "\"thered've\"", ":", "\"there'd've\"", ",", "\n", "\"there'dve\"", ":", "\"there'd've\"", ",", "\"therere\"", ":", "\"there're\"", ",", "\"theres\"", ":", "\"there's\"", ",", "\"theyd\"", ":", "\"they'd\"", ",", "\"theyd've\"", ":", "\"they'd've\"", ",", "\n", "\"they'dve\"", ":", "\"they'd've\"", ",", "\"theyll\"", ":", "\"they'll\"", ",", "\"theyre\"", ":", "\"they're\"", ",", "\"theyve\"", ":", "\"they've\"", ",", "\"twas\"", ":", "\"'twas\"", ",", "\"wasnt\"", ":", "\"wasn't\"", ",", "\n", "\"wed've\"", ":", "\"we'd've\"", ",", "\"we'dve\"", ":", "\"we'd've\"", ",", "\"weve\"", ":", "\"we've\"", ",", "\"werent\"", ":", "\"weren't\"", ",", "\"whatll\"", ":", "\"what'll\"", ",", "\"whatre\"", ":", "\"what're\"", ",", "\n", "\"whats\"", ":", "\"what's\"", ",", "\"whatve\"", ":", "\"what've\"", ",", "\"whens\"", ":", "\"when's\"", ",", "\"whered\"", ":", "\"where'd\"", ",", "\"wheres\"", ":", "\"where's\"", ",", "\"whereve\"", ":", "\"where've\"", ",", "\n", "\"whod\"", ":", "\"who'd\"", ",", "\"whod've\"", ":", "\"who'd've\"", ",", "\"who'dve\"", ":", "\"who'd've\"", ",", "\"wholl\"", ":", "\"who'll\"", ",", "\"whos\"", ":", "\"who's\"", ",", "\"whove\"", ":", "\"who've\"", ",", "\"whyll\"", ":", "\"why'll\"", ",", "\n", "\"whyre\"", ":", "\"why're\"", ",", "\"whys\"", ":", "\"why's\"", ",", "\"wont\"", ":", "\"won't\"", ",", "\"wouldve\"", ":", "\"would've\"", ",", "\"wouldnt\"", ":", "\"wouldn't\"", ",", "\"wouldnt've\"", ":", "\"wouldn't've\"", ",", "\n", "\"wouldn'tve\"", ":", "\"wouldn't've\"", ",", "\"yall\"", ":", "\"y'all\"", ",", "\"yall'll\"", ":", "\"y'all'll\"", ",", "\"y'allll\"", ":", "\"y'all'll\"", ",", "\"yall'd've\"", ":", "\"y'all'd've\"", ",", "\n", "\"y'alld've\"", ":", "\"y'all'd've\"", ",", "\"y'all'dve\"", ":", "\"y'all'd've\"", ",", "\"youd\"", ":", "\"you'd\"", ",", "\"youd've\"", ":", "\"you'd've\"", ",", "\"you'dve\"", ":", "\"you'd've\"", ",", "\n", "\"youll\"", ":", "\"you'll\"", ",", "\"youre\"", ":", "\"you're\"", ",", "\"youve\"", ":", "\"you've\"", "}", "\n", "self", ".", "manualMap", "=", "{", "'none'", ":", "'0'", ",", "\n", "'zero'", ":", "'0'", ",", "\n", "'one'", ":", "'1'", ",", "\n", "'two'", ":", "'2'", ",", "\n", "'three'", ":", "'3'", ",", "\n", "'four'", ":", "'4'", ",", "\n", "'five'", ":", "'5'", ",", "\n", "'six'", ":", "'6'", ",", "\n", "'seven'", ":", "'7'", ",", "\n", "'eight'", ":", "'8'", ",", "\n", "'nine'", ":", "'9'", ",", "\n", "'ten'", ":", "'10'", "\n", "}", "\n", "self", ".", "articles", "=", "[", "'a'", ",", "\n", "'an'", ",", "\n", "'the'", "\n", "]", "\n", "\n", "\n", "self", ".", "periodStrip", "=", "re", ".", "compile", "(", "\"(?!<=\\d)(\\.)(?!\\d)\"", ")", "\n", "self", ".", "commaStrip", "=", "re", ".", "compile", "(", "\"(\\d)(,)(\\d)\"", ")", "\n", "self", ".", "punct", "=", "[", "';'", ",", "r\"/\"", ",", "'['", ",", "']'", ",", "'\"'", ",", "'{'", ",", "'}'", ",", "\n", "'('", ",", "')'", ",", "'='", ",", "'+'", ",", "'\\\\'", ",", "'_'", ",", "'-'", ",", "\n", "'>'", ",", "'<'", ",", "'@'", ",", "'`'", ",", "','", ",", "'?'", ",", "'!'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.evaluate": [[68, 121], ["print", "vqaEval.VQAEval.setAccuracy", "print", "vqaEval.VQAEval.replace", "vqaEval.VQAEval.replace", "vqaEval.VQAEval.strip", "vqaEval.VQAEval.processPunctuation", "vqaEval.VQAEval.processDigitArticle", "accQA.append", "accQuesType[].append", "accAnsType[].append", "vqaEval.VQAEval.setEvalQA", "vqaEval.VQAEval.setEvalQuesType", "vqaEval.VQAEval.setEvalAnsType", "len", "min", "gtAcc.append", "float", "len", "vqaEval.VQAEval.updateProgress", "set", "vqaEval.VQAEval.processPunctuation", "sum", "float", "float", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.setAccuracy", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.processPunctuation", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.processDigitArticle", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.setEvalQA", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.setEvalQuesType", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.setEvalAnsType", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.updateProgress", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.processPunctuation"], ["", "def", "evaluate", "(", "self", ",", "quesIds", "=", "None", ")", ":", "\n", "\t\t", "if", "quesIds", "==", "None", ":", "\n", "\t\t\t", "quesIds", "=", "[", "quesId", "for", "quesId", "in", "self", ".", "params", "[", "'question_id'", "]", "]", "\n", "", "gts", "=", "{", "}", "\n", "res", "=", "{", "}", "\n", "for", "quesId", "in", "quesIds", ":", "\n", "\t\t\t", "gts", "[", "quesId", "]", "=", "self", ".", "vqa", ".", "qa", "[", "quesId", "]", "\n", "res", "[", "quesId", "]", "=", "self", ".", "vqaRes", ".", "qa", "[", "quesId", "]", "\n", "\n", "# =================================================", "\n", "# Compute accuracy", "\n", "# =================================================", "\n", "", "accQA", "=", "[", "]", "\n", "accQuesType", "=", "{", "}", "\n", "accAnsType", "=", "{", "}", "\n", "print", "(", "\"computing accuracy\"", ")", "\n", "step", "=", "0", "\n", "for", "quesId", "in", "quesIds", ":", "\n", "\t\t\t", "resAns", "=", "res", "[", "quesId", "]", "[", "'answer'", "]", "\n", "resAns", "=", "resAns", ".", "replace", "(", "'\\n'", ",", "' '", ")", "\n", "resAns", "=", "resAns", ".", "replace", "(", "'\\t'", ",", "' '", ")", "\n", "resAns", "=", "resAns", ".", "strip", "(", ")", "\n", "resAns", "=", "self", ".", "processPunctuation", "(", "resAns", ")", "\n", "resAns", "=", "self", ".", "processDigitArticle", "(", "resAns", ")", "\n", "gtAcc", "=", "[", "]", "\n", "gtAnswers", "=", "[", "ans", "[", "'answer'", "]", "for", "ans", "in", "gts", "[", "quesId", "]", "[", "'answers'", "]", "]", "\n", "if", "len", "(", "set", "(", "gtAnswers", ")", ")", ">", "1", ":", "\n", "\t\t\t\t", "for", "ansDic", "in", "gts", "[", "quesId", "]", "[", "'answers'", "]", ":", "\n", "\t\t\t\t\t", "ansDic", "[", "'answer'", "]", "=", "self", ".", "processPunctuation", "(", "ansDic", "[", "'answer'", "]", ")", "\n", "", "", "for", "gtAnsDatum", "in", "gts", "[", "quesId", "]", "[", "'answers'", "]", ":", "\n", "\t\t\t\t", "otherGTAns", "=", "[", "item", "for", "item", "in", "gts", "[", "quesId", "]", "[", "'answers'", "]", "if", "item", "!=", "gtAnsDatum", "]", "\n", "matchingAns", "=", "[", "item", "for", "item", "in", "otherGTAns", "if", "item", "[", "'answer'", "]", "==", "resAns", "]", "\n", "acc", "=", "min", "(", "1", ",", "float", "(", "len", "(", "matchingAns", ")", ")", "/", "3", ")", "\n", "gtAcc", ".", "append", "(", "acc", ")", "\n", "", "quesType", "=", "gts", "[", "quesId", "]", "[", "'question_type'", "]", "\n", "ansType", "=", "gts", "[", "quesId", "]", "[", "'answer_type'", "]", "\n", "avgGTAcc", "=", "float", "(", "sum", "(", "gtAcc", ")", ")", "/", "len", "(", "gtAcc", ")", "\n", "accQA", ".", "append", "(", "avgGTAcc", ")", "\n", "if", "quesType", "not", "in", "accQuesType", ":", "\n", "\t\t\t\t", "accQuesType", "[", "quesType", "]", "=", "[", "]", "\n", "", "accQuesType", "[", "quesType", "]", ".", "append", "(", "avgGTAcc", ")", "\n", "if", "ansType", "not", "in", "accAnsType", ":", "\n", "\t\t\t\t", "accAnsType", "[", "ansType", "]", "=", "[", "]", "\n", "", "accAnsType", "[", "ansType", "]", ".", "append", "(", "avgGTAcc", ")", "\n", "self", ".", "setEvalQA", "(", "quesId", ",", "avgGTAcc", ")", "\n", "self", ".", "setEvalQuesType", "(", "quesId", ",", "quesType", ",", "avgGTAcc", ")", "\n", "self", ".", "setEvalAnsType", "(", "quesId", ",", "ansType", ",", "avgGTAcc", ")", "\n", "if", "step", "%", "100", "==", "0", ":", "\n", "\t\t\t\t", "self", ".", "updateProgress", "(", "step", "/", "float", "(", "len", "(", "quesIds", ")", ")", ")", "\n", "", "step", "=", "step", "+", "1", "\n", "\n", "", "self", ".", "setAccuracy", "(", "accQA", ",", "accQuesType", ",", "accAnsType", ")", "\n", "print", "(", "\"Done computing accuracy\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.processPunctuation": [[122, 133], ["vqaEval.VQAEval.periodStrip.sub", "outText.replace.replace.replace", "outText.replace.replace.replace", "re.search"], "methods", ["None"], ["", "def", "processPunctuation", "(", "self", ",", "inText", ")", ":", "\n", "\t\t", "outText", "=", "inText", "\n", "for", "p", "in", "self", ".", "punct", ":", "\n", "\t\t\t", "if", "(", "p", "+", "' '", "in", "inText", "or", "' '", "+", "p", "in", "inText", ")", "or", "(", "re", ".", "search", "(", "self", ".", "commaStrip", ",", "inText", ")", "!=", "None", ")", ":", "\n", "\t\t\t\t", "outText", "=", "outText", ".", "replace", "(", "p", ",", "''", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "outText", "=", "outText", ".", "replace", "(", "p", ",", "' '", ")", "\n", "", "", "outText", "=", "self", ".", "periodStrip", ".", "sub", "(", "\"\"", ",", "\n", "outText", ",", "\n", "re", ".", "UNICODE", ")", "\n", "return", "outText", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.processDigitArticle": [[134, 148], ["inText.lower().split", "enumerate", "vqaEval.VQAEval.manualMap.setdefault", "inText.lower", "outText.append"], "methods", ["None"], ["", "def", "processDigitArticle", "(", "self", ",", "inText", ")", ":", "\n", "\t\t", "outText", "=", "[", "]", "\n", "tempText", "=", "inText", ".", "lower", "(", ")", ".", "split", "(", ")", "\n", "for", "word", "in", "tempText", ":", "\n", "\t\t\t", "word", "=", "self", ".", "manualMap", ".", "setdefault", "(", "word", ",", "word", ")", "\n", "if", "word", "not", "in", "self", ".", "articles", ":", "\n", "\t\t\t\t", "outText", ".", "append", "(", "word", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "pass", "\n", "", "", "for", "wordId", ",", "word", "in", "enumerate", "(", "outText", ")", ":", "\n", "\t\t\t", "if", "word", "in", "self", ".", "contractions", ":", "\n", "\t\t\t\t", "outText", "[", "wordId", "]", "=", "self", ".", "contractions", "[", "word", "]", "\n", "", "", "outText", "=", "' '", ".", "join", "(", "outText", ")", "\n", "return", "outText", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.setAccuracy": [[149, 153], ["round", "round", "round", "len", "float", "len", "len", "sum", "float", "float", "sum", "sum"], "methods", ["None"], ["", "def", "setAccuracy", "(", "self", ",", "accQA", ",", "accQuesType", ",", "accAnsType", ")", ":", "\n", "\t\t", "self", ".", "accuracy", "[", "'overall'", "]", "=", "round", "(", "100", "*", "float", "(", "sum", "(", "accQA", ")", ")", "/", "len", "(", "accQA", ")", ",", "self", ".", "n", ")", "\n", "self", ".", "accuracy", "[", "'perQuestionType'", "]", "=", "{", "quesType", ":", "round", "(", "100", "*", "float", "(", "sum", "(", "accQuesType", "[", "quesType", "]", ")", ")", "/", "len", "(", "accQuesType", "[", "quesType", "]", ")", ",", "self", ".", "n", ")", "for", "quesType", "in", "accQuesType", "}", "\n", "self", ".", "accuracy", "[", "'perAnswerType'", "]", "=", "{", "ansType", ":", "round", "(", "100", "*", "float", "(", "sum", "(", "accAnsType", "[", "ansType", "]", ")", ")", "/", "len", "(", "accAnsType", "[", "ansType", "]", ")", ",", "self", ".", "n", ")", "for", "ansType", "in", "accAnsType", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.setEvalQA": [[154, 156], ["round"], "methods", ["None"], ["", "def", "setEvalQA", "(", "self", ",", "quesId", ",", "acc", ")", ":", "\n", "\t\t", "self", ".", "evalQA", "[", "quesId", "]", "=", "round", "(", "100", "*", "acc", ",", "self", ".", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.setEvalQuesType": [[157, 161], ["round"], "methods", ["None"], ["", "def", "setEvalQuesType", "(", "self", ",", "quesId", ",", "quesType", ",", "acc", ")", ":", "\n", "\t\t", "if", "quesType", "not", "in", "self", ".", "evalQuesType", ":", "\n", "\t\t\t", "self", ".", "evalQuesType", "[", "quesType", "]", "=", "{", "}", "\n", "", "self", ".", "evalQuesType", "[", "quesType", "]", "[", "quesId", "]", "=", "round", "(", "100", "*", "acc", ",", "self", ".", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.setEvalAnsType": [[162, 166], ["round"], "methods", ["None"], ["", "def", "setEvalAnsType", "(", "self", ",", "quesId", ",", "ansType", ",", "acc", ")", ":", "\n", "\t\t", "if", "ansType", "not", "in", "self", ".", "evalAnsType", ":", "\n", "\t\t\t", "self", ".", "evalAnsType", "[", "ansType", "]", "=", "{", "}", "\n", "", "self", ".", "evalAnsType", "[", "ansType", "]", "[", "quesId", "]", "=", "round", "(", "100", "*", "acc", ",", "self", ".", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqaEval.VQAEval.updateProgress": [[167, 185], ["isinstance", "int", "sys.stdout.write", "sys.stdout.flush", "float", "isinstance", "round", "int"], "methods", ["None"], ["", "def", "updateProgress", "(", "self", ",", "progress", ")", ":", "\n", "\t\t", "barLength", "=", "20", "\n", "status", "=", "\"\"", "\n", "if", "isinstance", "(", "progress", ",", "int", ")", ":", "\n", "\t\t\t", "progress", "=", "float", "(", "progress", ")", "\n", "", "if", "not", "isinstance", "(", "progress", ",", "float", ")", ":", "\n", "\t\t\t", "progress", "=", "0", "\n", "status", "=", "\"error: progress var must be float\\r\\n\"", "\n", "", "if", "progress", "<", "0", ":", "\n", "\t\t\t", "progress", "=", "0", "\n", "status", "=", "\"Halt...\\r\\n\"", "\n", "", "if", "progress", ">=", "1", ":", "\n", "\t\t\t", "progress", "=", "1", "\n", "status", "=", "\"Done...\\r\\n\"", "\n", "", "block", "=", "int", "(", "round", "(", "barLength", "*", "progress", ")", ")", "\n", "text", "=", "\"\\rFinshed Percent: [{0}] {1}% {2}\"", ".", "format", "(", "\"#\"", "*", "block", "+", "\"-\"", "*", "(", "barLength", "-", "block", ")", ",", "int", "(", "progress", "*", "100", ")", ",", "status", ")", "\n", "sys", ".", "stdout", ".", "write", "(", "text", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.__init__": [[25, 46], ["print", "datetime.datetime.utcnow", "json.load", "json.load", "print", "vqa.VQA.createIndex", "open", "open", "datetime.datetime.utcnow"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.createIndex"], ["\t", "def", "__init__", "(", "self", ",", "annotation_file", "=", "None", ",", "question_file", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n       \tConstructor of VQA helper class for reading and visualizing questions and answers.\n        :param annotation_file (str): location of VQA annotation file\n        :return:\n\t\t\"\"\"", "\n", "# load dataset", "\n", "self", ".", "dataset", "=", "{", "}", "\n", "self", ".", "questions", "=", "{", "}", "\n", "self", ".", "qa", "=", "{", "}", "\n", "self", ".", "qqa", "=", "{", "}", "\n", "self", ".", "imgToQA", "=", "{", "}", "\n", "if", "not", "annotation_file", "==", "None", "and", "not", "question_file", "==", "None", ":", "\n", "\t\t\t", "print", "(", "'loading VQA annotations and questions into memory...'", ")", "\n", "time_t", "=", "datetime", ".", "datetime", ".", "utcnow", "(", ")", "\n", "dataset", "=", "json", ".", "load", "(", "open", "(", "annotation_file", ",", "'r'", ")", ")", "\n", "questions", "=", "json", ".", "load", "(", "open", "(", "question_file", ",", "'r'", ")", ")", "\n", "print", "(", "datetime", ".", "datetime", ".", "utcnow", "(", ")", "-", "time_t", ")", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "questions", "=", "questions", "\n", "self", ".", "createIndex", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.createIndex": [[47, 64], ["print", "print"], "methods", ["None"], ["", "", "def", "createIndex", "(", "self", ")", ":", "\n", "# create index", "\n", "\t\t", "print", "(", "'creating index...'", ")", "\n", "imgToQA", "=", "{", "ann", "[", "'image_id'", "]", ":", "[", "]", "for", "ann", "in", "self", ".", "dataset", "[", "'annotations'", "]", "}", "\n", "qa", "=", "{", "ann", "[", "'question_id'", "]", ":", "[", "]", "for", "ann", "in", "self", ".", "dataset", "[", "'annotations'", "]", "}", "\n", "qqa", "=", "{", "ann", "[", "'question_id'", "]", ":", "[", "]", "for", "ann", "in", "self", ".", "dataset", "[", "'annotations'", "]", "}", "\n", "for", "ann", "in", "self", ".", "dataset", "[", "'annotations'", "]", ":", "\n", "\t\t\t", "imgToQA", "[", "ann", "[", "'image_id'", "]", "]", "+=", "[", "ann", "]", "\n", "qa", "[", "ann", "[", "'question_id'", "]", "]", "=", "ann", "\n", "", "for", "ques", "in", "self", ".", "questions", "[", "'questions'", "]", ":", "\n", "\t\t\t", "qqa", "[", "ques", "[", "'question_id'", "]", "]", "=", "ques", "\n", "", "print", "(", "'index created!'", ")", "\n", "\n", "# create class members", "\n", "self", ".", "qa", "=", "qa", "\n", "self", ".", "qqa", "=", "qqa", "\n", "self", ".", "imgToQA", "=", "imgToQA", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info": [[65, 72], ["vqa.VQA.dataset[].items", "print"], "methods", ["None"], ["", "def", "info", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tPrint information about the VQA annotation file.\n\t\t:return:\n\t\t\"\"\"", "\n", "for", "key", ",", "value", "in", "self", ".", "dataset", "[", "'info'", "]", ".", "items", "(", ")", ":", "\n", "\t\t\t", "print", "(", "'%s: %s'", "%", "(", "key", ",", "value", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.getQuesIds": [[73, 96], ["len", "len", "len", "type", "type", "type", "sum", "len", "len", "len"], "methods", ["None"], ["", "", "def", "getQuesIds", "(", "self", ",", "imgIds", "=", "[", "]", ",", "quesTypes", "=", "[", "]", ",", "ansTypes", "=", "[", "]", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tGet question ids that satisfy given filter conditions. default skips that filter\n\t\t:param \timgIds    (int array)   : get question ids for given imgs\n\t\t\t\tquesTypes (str array)   : get question ids for given question types\n\t\t\t\tansTypes  (str array)   : get question ids for given answer types\n\t\t:return:    ids   (int array)   : integer array of question ids\n\t\t\"\"\"", "\n", "imgIds", "=", "imgIds", "if", "type", "(", "imgIds", ")", "==", "list", "else", "[", "imgIds", "]", "\n", "quesTypes", "=", "quesTypes", "if", "type", "(", "quesTypes", ")", "==", "list", "else", "[", "quesTypes", "]", "\n", "ansTypes", "=", "ansTypes", "if", "type", "(", "ansTypes", ")", "==", "list", "else", "[", "ansTypes", "]", "\n", "\n", "if", "len", "(", "imgIds", ")", "==", "len", "(", "quesTypes", ")", "==", "len", "(", "ansTypes", ")", "==", "0", ":", "\n", "\t\t\t", "anns", "=", "self", ".", "dataset", "[", "'annotations'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "if", "not", "len", "(", "imgIds", ")", "==", "0", ":", "\n", "\t\t\t\t", "anns", "=", "sum", "(", "[", "self", ".", "imgToQA", "[", "imgId", "]", "for", "imgId", "in", "imgIds", "if", "imgId", "in", "self", ".", "imgToQA", "]", ",", "[", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "anns", "=", "self", ".", "dataset", "[", "'annotations'", "]", "\n", "", "anns", "=", "anns", "if", "len", "(", "quesTypes", ")", "==", "0", "else", "[", "ann", "for", "ann", "in", "anns", "if", "ann", "[", "'question_type'", "]", "in", "quesTypes", "]", "\n", "anns", "=", "anns", "if", "len", "(", "ansTypes", ")", "==", "0", "else", "[", "ann", "for", "ann", "in", "anns", "if", "ann", "[", "'answer_type'", "]", "in", "ansTypes", "]", "\n", "", "ids", "=", "[", "ann", "[", "'question_id'", "]", "for", "ann", "in", "anns", "]", "\n", "return", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.getImgIds": [[97, 120], ["len", "len", "len", "type", "type", "type", "sum", "len", "len", "len"], "methods", ["None"], ["", "def", "getImgIds", "(", "self", ",", "quesIds", "=", "[", "]", ",", "quesTypes", "=", "[", "]", ",", "ansTypes", "=", "[", "]", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tGet image ids that satisfy given filter conditions. default skips that filter\n\t\t:param quesIds   (int array)   : get image ids for given question ids\n               quesTypes (str array)   : get image ids for given question types\n               ansTypes  (str array)   : get image ids for given answer types\n\t\t:return: ids     (int array)   : integer array of image ids\n\t\t\"\"\"", "\n", "quesIds", "=", "quesIds", "if", "type", "(", "quesIds", ")", "==", "list", "else", "[", "quesIds", "]", "\n", "quesTypes", "=", "quesTypes", "if", "type", "(", "quesTypes", ")", "==", "list", "else", "[", "quesTypes", "]", "\n", "ansTypes", "=", "ansTypes", "if", "type", "(", "ansTypes", ")", "==", "list", "else", "[", "ansTypes", "]", "\n", "\n", "if", "len", "(", "quesIds", ")", "==", "len", "(", "quesTypes", ")", "==", "len", "(", "ansTypes", ")", "==", "0", ":", "\n", "\t\t\t", "anns", "=", "self", ".", "dataset", "[", "'annotations'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "if", "not", "len", "(", "quesIds", ")", "==", "0", ":", "\n", "\t\t\t\t", "anns", "=", "sum", "(", "[", "self", ".", "qa", "[", "quesId", "]", "for", "quesId", "in", "quesIds", "if", "quesId", "in", "self", ".", "qa", "]", ",", "[", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "anns", "=", "self", ".", "dataset", "[", "'annotations'", "]", "\n", "", "anns", "=", "anns", "if", "len", "(", "quesTypes", ")", "==", "0", "else", "[", "ann", "for", "ann", "in", "anns", "if", "ann", "[", "'question_type'", "]", "in", "quesTypes", "]", "\n", "anns", "=", "anns", "if", "len", "(", "ansTypes", ")", "==", "0", "else", "[", "ann", "for", "ann", "in", "anns", "if", "ann", "[", "'answer_type'", "]", "in", "ansTypes", "]", "\n", "", "ids", "=", "[", "ann", "[", "'image_id'", "]", "for", "ann", "in", "anns", "]", "\n", "return", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.loadQA": [[121, 131], ["type", "type"], "methods", ["None"], ["", "def", "loadQA", "(", "self", ",", "ids", "=", "[", "]", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tLoad questions and answers with the specified question ids.\n\t\t:param ids (int array)       : integer ids specifying question ids\n\t\t:return: qa (object array)   : loaded qa objects\n\t\t\"\"\"", "\n", "if", "type", "(", "ids", ")", "==", "list", ":", "\n", "\t\t\t", "return", "[", "self", ".", "qa", "[", "id", "]", "for", "id", "in", "ids", "]", "\n", "", "elif", "type", "(", "ids", ")", "==", "int", ":", "\n", "\t\t\t", "return", "[", "self", ".", "qa", "[", "ids", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.showQA": [[132, 145], ["len", "print", "print"], "methods", ["None"], ["", "", "def", "showQA", "(", "self", ",", "anns", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tDisplay the specified annotations.\n\t\t:param anns (array of object): annotations to display\n\t\t:return: None\n\t\t\"\"\"", "\n", "if", "len", "(", "anns", ")", "==", "0", ":", "\n", "\t\t\t", "return", "0", "\n", "", "for", "ann", "in", "anns", ":", "\n", "\t\t\t", "quesId", "=", "ann", "[", "'question_id'", "]", "\n", "print", "(", "\"Question: %s\"", "%", "(", "self", ".", "qqa", "[", "quesId", "]", "[", "'question'", "]", ")", ")", "\n", "for", "ans", "in", "ann", "[", "'answers'", "]", ":", "\n", "\t\t\t\t", "print", "(", "\"Answer %d: %s\"", "%", "(", "ans", "[", "'answer_id'", "]", ",", "ans", "[", "'answer'", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.loadRes": [[146, 181], ["vqa.VQA", "json.load", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "print", "datetime.datetime.utcnow", "json.load", "print", "vqa.VQA.createIndex", "open", "open", "type", "set", "set", "vqa.VQA.getQuesIds", "datetime.datetime.utcnow"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.createIndex", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.getQuesIds"], ["", "", "", "def", "loadRes", "(", "self", ",", "resFile", ",", "quesFile", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tLoad result file and return a result object.\n\t\t:param   resFile (str)     : file name of result file\n\t\t:return: res (obj)         : result api object\n\t\t\"\"\"", "\n", "res", "=", "VQA", "(", ")", "\n", "res", ".", "questions", "=", "json", ".", "load", "(", "open", "(", "quesFile", ")", ")", "\n", "res", ".", "dataset", "[", "'info'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "questions", "[", "'info'", "]", ")", "\n", "res", ".", "dataset", "[", "'task_type'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "questions", "[", "'task_type'", "]", ")", "\n", "res", ".", "dataset", "[", "'data_type'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "questions", "[", "'data_type'", "]", ")", "\n", "res", ".", "dataset", "[", "'data_subtype'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "questions", "[", "'data_subtype'", "]", ")", "\n", "res", ".", "dataset", "[", "'license'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "questions", "[", "'license'", "]", ")", "\n", "\n", "print", "(", "'Loading and preparing results...     '", ")", "\n", "time_t", "=", "datetime", ".", "datetime", ".", "utcnow", "(", ")", "\n", "anns", "=", "json", ".", "load", "(", "open", "(", "resFile", ")", ")", "\n", "assert", "type", "(", "anns", ")", "==", "list", ",", "'results is not an array of objects'", "\n", "annsQuesIds", "=", "[", "ann", "[", "'question_id'", "]", "for", "ann", "in", "anns", "]", "\n", "assert", "set", "(", "annsQuesIds", ")", "==", "set", "(", "self", ".", "getQuesIds", "(", ")", ")", ",", "'Results do not correspond to current VQA set. Either the results do not have predictions for all question ids in annotation file or there is atleast one question id that does not belong to the question ids in the annotation file.'", "\n", "for", "ann", "in", "anns", ":", "\n", "\t\t\t", "quesId", "=", "ann", "[", "'question_id'", "]", "\n", "if", "res", ".", "dataset", "[", "'task_type'", "]", "==", "'Multiple Choice'", ":", "\n", "\t\t\t\t", "assert", "ann", "[", "'answer'", "]", "in", "self", ".", "qqa", "[", "quesId", "]", "[", "\n", "'multiple_choices'", "]", ",", "'predicted answer is not one of the multiple choices'", "\n", "", "qaAnn", "=", "self", ".", "qa", "[", "quesId", "]", "\n", "ann", "[", "'image_id'", "]", "=", "qaAnn", "[", "'image_id'", "]", "\n", "ann", "[", "'question_type'", "]", "=", "qaAnn", "[", "'question_type'", "]", "\n", "ann", "[", "'answer_type'", "]", "=", "qaAnn", "[", "'answer_type'", "]", "\n", "", "print", "(", "'DONE (t=%0.2fs)'", "%", "(", "(", "datetime", ".", "datetime", ".", "utcnow", "(", ")", "-", "time_t", ")", ".", "total_seconds", "(", ")", ")", ")", "\n", "\n", "res", ".", "dataset", "[", "'annotations'", "]", "=", "anns", "\n", "res", ".", "createIndex", "(", ")", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.detector.SimpleDetector.__init__": [[49, 96], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torchvision.layers.ROIAlign", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "detector._load_resnet_imagenet", "detector._load_resnet", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.AvgPool2d", "torch.AvgPool2d", "torch.AvgPool2d", "torch.AvgPool2d", "utils.pytorch_misc.Flattener"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.detector._load_resnet_imagenet", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.detector._load_resnet"], ["    ", "def", "__init__", "(", "self", ",", "pretrained", "=", "True", ",", "average_pool", "=", "True", ",", "semantic", "=", "True", ",", "final_dim", "=", "1024", ")", ":", "\n", "        ", "\"\"\"\n        :param average_pool: whether or not to average pool the representations\n        :param pretrained: Whether we need to load from scratch\n        :param semantic: Whether or not we want to introduce the mask and the class label early on (default Yes)\n        \"\"\"", "\n", "super", "(", "SimpleDetector", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# huge thx to https://github.com/ruotianluo/pytorch-faster-rcnn/blob/master/lib/nets/resnet_v1.py", "\n", "backbone", "=", "_load_resnet_imagenet", "(", "pretrained", "=", "pretrained", ")", "if", "USE_IMAGENET_PRETRAINED", "else", "_load_resnet", "(", "\n", "pretrained", "=", "pretrained", ")", "\n", "\n", "self", ".", "backbone", "=", "nn", ".", "Sequential", "(", "\n", "backbone", ".", "conv1", ",", "\n", "backbone", ".", "bn1", ",", "\n", "backbone", ".", "relu", ",", "\n", "backbone", ".", "maxpool", ",", "\n", "backbone", ".", "layer1", ",", "\n", "backbone", ".", "layer2", ",", "\n", "backbone", ".", "layer3", ",", "\n", "# backbone.layer4", "\n", ")", "\n", "self", ".", "roi_align", "=", "ROIAlign", "(", "(", "7", ",", "7", ")", "if", "USE_IMAGENET_PRETRAINED", "else", "(", "14", ",", "14", ")", ",", "\n", "spatial_scale", "=", "1", "/", "16", ",", "sampling_ratio", "=", "0", ")", "\n", "\n", "if", "semantic", ":", "\n", "            ", "self", ".", "mask_dims", "=", "32", "\n", "self", ".", "object_embed", "=", "torch", ".", "nn", ".", "Embedding", "(", "num_embeddings", "=", "81", ",", "embedding_dim", "=", "128", ")", "\n", "self", ".", "mask_upsample", "=", "torch", ".", "nn", ".", "Conv2d", "(", "1", ",", "self", ".", "mask_dims", ",", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", "if", "USE_IMAGENET_PRETRAINED", "else", "1", ",", "\n", "padding", "=", "1", ",", "bias", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "object_embed", "=", "None", "\n", "self", ".", "mask_upsample", "=", "None", "\n", "\n", "", "after_roi_align", "=", "[", "backbone", ".", "layer4", "]", "\n", "self", ".", "final_dim", "=", "final_dim", "\n", "if", "average_pool", ":", "\n", "            ", "after_roi_align", "+=", "[", "nn", ".", "AvgPool2d", "(", "7", ",", "stride", "=", "1", ")", ",", "Flattener", "(", ")", "]", "\n", "\n", "", "self", ".", "after_roi_align", "=", "torch", ".", "nn", ".", "Sequential", "(", "*", "after_roi_align", ")", "\n", "\n", "self", ".", "obj_downsample", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Dropout", "(", "p", "=", "0.1", ")", ",", "\n", "torch", ".", "nn", ".", "Linear", "(", "2048", "+", "(", "128", "if", "semantic", "else", "0", ")", ",", "final_dim", ")", ",", "\n", "torch", ".", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", "self", ".", "regularizing_predictor", "=", "torch", ".", "nn", ".", "Linear", "(", "2048", ",", "81", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.detector.SimpleDetector.forward": [[97, 145], ["detector.SimpleDetector.backbone", "box_mask.nonzero", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "detector.SimpleDetector.roi_align", "detector.SimpleDetector.after_roi_align", "detector.SimpleDetector.regularizing_predictor", "detector.SimpleDetector.obj_downsample", "utils.pytorch_misc.pad_sequence", "detector.SimpleDetector.mask_upsample", "torch.nn.functional.cross_entropy", "torch.nn.functional.cross_entropy", "torch.nn.functional.cross_entropy", "torch.nn.functional.cross_entropy", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "box_mask.sum().tolist", "box_inds[].type", "detector.SimpleDetector.object_embed", "box_mask.sum"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.pad_sequence", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "\n", "images", ":", "torch", ".", "Tensor", ",", "\n", "boxes", ":", "torch", ".", "Tensor", ",", "\n", "box_mask", ":", "torch", ".", "LongTensor", ",", "\n", "classes", ":", "torch", ".", "Tensor", "=", "None", ",", "\n", "segms", ":", "torch", ".", "Tensor", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param images: [batch_size, 3, im_height, im_width]\n        :param boxes:  [batch_size, max_num_objects, 4] Padded boxes\n        :param box_mask: [batch_size, max_num_objects] Mask for whether or not each box is OK\n        :return: object reps [batch_size, max_num_objects, dim]\n        \"\"\"", "\n", "# [batch_size, 2048, im_height // 32, im_width // 32", "\n", "img_feats", "=", "self", ".", "backbone", "(", "images", ")", "\n", "box_inds", "=", "box_mask", ".", "nonzero", "(", ")", "\n", "assert", "box_inds", ".", "shape", "[", "0", "]", ">", "0", "\n", "rois", "=", "torch", ".", "cat", "(", "(", "\n", "box_inds", "[", ":", ",", "0", ",", "None", "]", ".", "type", "(", "boxes", ".", "dtype", ")", ",", "\n", "boxes", "[", "box_inds", "[", ":", ",", "0", "]", ",", "box_inds", "[", ":", ",", "1", "]", "]", ",", "\n", ")", ",", "1", ")", "\n", "\n", "# Object class and segmentation representations", "\n", "roi_align_res", "=", "self", ".", "roi_align", "(", "img_feats", ",", "rois", ")", "\n", "if", "self", ".", "mask_upsample", "is", "not", "None", ":", "\n", "            ", "assert", "segms", "is", "not", "None", "\n", "segms_indexed", "=", "segms", "[", "box_inds", "[", ":", ",", "0", "]", ",", "None", ",", "box_inds", "[", ":", ",", "1", "]", "]", "-", "0.5", "\n", "roi_align_res", "[", ":", ",", ":", "self", ".", "mask_dims", "]", "+=", "self", ".", "mask_upsample", "(", "segms_indexed", ")", "\n", "\n", "\n", "", "post_roialign", "=", "self", ".", "after_roi_align", "(", "roi_align_res", ")", "\n", "\n", "# Add some regularization, encouraging the model to keep giving decent enough predictions", "\n", "obj_logits", "=", "self", ".", "regularizing_predictor", "(", "post_roialign", ")", "\n", "obj_labels", "=", "classes", "[", "box_inds", "[", ":", ",", "0", "]", ",", "box_inds", "[", ":", ",", "1", "]", "]", "\n", "cnn_regularization", "=", "F", ".", "cross_entropy", "(", "obj_logits", ",", "obj_labels", ",", "size_average", "=", "True", ")", "[", "None", "]", "\n", "\n", "feats_to_downsample", "=", "post_roialign", "if", "self", ".", "object_embed", "is", "None", "else", "torch", ".", "cat", "(", "(", "post_roialign", ",", "self", ".", "object_embed", "(", "obj_labels", ")", ")", ",", "-", "1", ")", "\n", "roi_aligned_feats", "=", "self", ".", "obj_downsample", "(", "feats_to_downsample", ")", "\n", "\n", "# Reshape into a padded sequence - this is expensive and annoying but easier to implement and debug...", "\n", "obj_reps", "=", "pad_sequence", "(", "roi_aligned_feats", ",", "box_mask", ".", "sum", "(", "1", ")", ".", "tolist", "(", ")", ")", "\n", "return", "{", "\n", "'obj_reps_raw'", ":", "post_roialign", ",", "\n", "'obj_reps'", ":", "obj_reps", ",", "\n", "'obj_logits'", ":", "obj_logits", ",", "\n", "'obj_labels'", ":", "obj_labels", ",", "\n", "'cnn_regularization_loss'", ":", "cnn_regularization", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.detector._load_resnet": [[18, 28], ["torchvision.models.resnet.resnet50", "range", "resnet.resnet50.load_state_dict", "torch.load_url", "getattr", "getattr"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet.resnet50", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["def", "_load_resnet", "(", "pretrained", "=", "True", ")", ":", "\n", "# huge thx to https://github.com/ruotianluo/pytorch-faster-rcnn/blob/master/lib/nets/resnet_v1.py", "\n", "    ", "backbone", "=", "resnet", ".", "resnet50", "(", "pretrained", "=", "False", ")", "\n", "if", "pretrained", ":", "\n", "        ", "backbone", ".", "load_state_dict", "(", "model_zoo", ".", "load_url", "(", "\n", "'https://s3.us-west-2.amazonaws.com/ai2-rowanz/resnet50-e13db6895d81.th'", ")", ")", "\n", "", "for", "i", "in", "range", "(", "2", ",", "4", ")", ":", "\n", "        ", "getattr", "(", "backbone", ",", "'layer%d'", "%", "i", ")", "[", "0", "]", ".", "conv1", ".", "stride", "=", "(", "2", ",", "2", ")", "\n", "getattr", "(", "backbone", ",", "'layer%d'", "%", "i", ")", "[", "0", "]", ".", "conv2", ".", "stride", "=", "(", "1", ",", "1", ")", "\n", "", "return", "backbone", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.detector._load_resnet_imagenet": [[30, 46], ["torchvision.models.resnet.resnet50", "range", "getattr", "getattr"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet.resnet50"], ["", "def", "_load_resnet_imagenet", "(", "pretrained", "=", "True", ")", ":", "\n", "# huge thx to https://github.com/ruotianluo/pytorch-faster-rcnn/blob/master/lib/nets/resnet_v1.py", "\n", "    ", "backbone", "=", "resnet", ".", "resnet50", "(", "pretrained", "=", "pretrained", ")", "\n", "for", "i", "in", "range", "(", "2", ",", "4", ")", ":", "\n", "        ", "getattr", "(", "backbone", ",", "'layer%d'", "%", "i", ")", "[", "0", "]", ".", "conv1", ".", "stride", "=", "(", "2", ",", "2", ")", "\n", "getattr", "(", "backbone", ",", "'layer%d'", "%", "i", ")", "[", "0", "]", ".", "conv2", ".", "stride", "=", "(", "1", ",", "1", ")", "\n", "# use stride 1 for the last conv4 layer (same as tf-faster-rcnn)", "\n", "", "backbone", ".", "layer4", "[", "0", "]", ".", "conv2", ".", "stride", "=", "(", "1", ",", "1", ")", "\n", "backbone", ".", "layer4", "[", "0", "]", ".", "downsample", "[", "0", "]", ".", "stride", "=", "(", "1", ",", "1", ")", "\n", "\n", "# # Make batchnorm more sensible", "\n", "# for submodule in backbone.modules():", "\n", "#     if isinstance(submodule, torch.nn.BatchNorm2d):", "\n", "#         submodule.momentum = 0.01", "\n", "\n", "return", "backbone", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils._image_features_reader.ImageFeaturesH5Reader.__init__": [[35, 52], ["lmdb.open", "_image_features_reader.ImageFeaturesH5Reader.env.begin", "pickle.loads", "len", "len", "len", "len", "txn.get"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["def", "__init__", "(", "self", ",", "features_path", ":", "str", ",", "in_memory", ":", "bool", "=", "False", ")", ":", "\n", "        ", "self", ".", "features_path", "=", "features_path", "\n", "self", ".", "_in_memory", "=", "in_memory", "\n", "\n", "# with h5py.File(self.features_h5path, \"r\", libver='latest', swmr=True) as features_h5:", "\n", "# self._image_ids = list(features_h5[\"image_ids\"])", "\n", "# If not loaded in memory, then list of None.", "\n", "self", ".", "env", "=", "lmdb", ".", "open", "(", "self", ".", "features_path", ",", "max_readers", "=", "1", ",", "readonly", "=", "True", ",", "\n", "lock", "=", "False", ",", "readahead", "=", "False", ",", "meminit", "=", "False", ")", "\n", "\n", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "self", ".", "_image_ids", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "'keys'", ".", "encode", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "features", "=", "[", "None", "]", "*", "len", "(", "self", ".", "_image_ids", ")", "\n", "self", ".", "num_boxes", "=", "[", "None", "]", "*", "len", "(", "self", ".", "_image_ids", ")", "\n", "self", ".", "boxes", "=", "[", "None", "]", "*", "len", "(", "self", ".", "_image_ids", ")", "\n", "self", ".", "boxes_ori", "=", "[", "None", "]", "*", "len", "(", "self", ".", "_image_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils._image_features_reader.ImageFeaturesH5Reader.__len__": [[53, 55], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_image_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils._image_features_reader.ImageFeaturesH5Reader.__getitem__": [[56, 162], ["str().encode", "_image_features_reader.ImageFeaturesH5Reader._image_ids.index", "str", "_image_features_reader.ImageFeaturesH5Reader.env.begin", "pickle.loads", "int", "int", "int", "numpy.frombuffer().reshape", "numpy.frombuffer().reshape", "numpy.concatenate", "numpy.zeros", "copy.deepcopy", "numpy.array", "numpy.concatenate", "numpy.array", "numpy.concatenate", "_image_features_reader.ImageFeaturesH5Reader.env.begin", "pickle.loads", "int", "int", "int", "numpy.frombuffer().reshape", "numpy.frombuffer().reshape", "numpy.concatenate", "numpy.zeros", "copy.deepcopy", "numpy.array", "numpy.concatenate", "numpy.array", "numpy.concatenate", "txn.get", "numpy.sum", "float", "float", "float", "float", "txn.get", "numpy.sum", "float", "float", "float", "float", "numpy.frombuffer", "numpy.frombuffer", "numpy.expand_dims", "float", "float", "numpy.expand_dims", "numpy.expand_dims", "numpy.frombuffer", "numpy.frombuffer", "numpy.expand_dims", "float", "float", "numpy.expand_dims", "numpy.expand_dims", "base64.b64decode", "base64.b64decode", "base64.b64decode", "base64.b64decode"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["", "def", "__getitem__", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "image_id", "=", "str", "(", "image_id", ")", ".", "encode", "(", ")", "\n", "index", "=", "self", ".", "_image_ids", ".", "index", "(", "image_id", ")", "\n", "if", "self", ".", "_in_memory", ":", "\n", "# Load features during first epoch, all not loaded together as it", "\n", "# has a slow start.", "\n", "            ", "if", "self", ".", "features", "[", "index", "]", "is", "not", "None", ":", "\n", "                ", "features", "=", "self", ".", "features", "[", "index", "]", "\n", "num_boxes", "=", "self", ".", "num_boxes", "[", "index", "]", "\n", "image_location", "=", "self", ".", "boxes", "[", "index", "]", "\n", "image_location_ori", "=", "self", ".", "boxes_ori", "[", "index", "]", "\n", "", "else", ":", "\n", "                ", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "                    ", "item", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "image_id", ")", ")", "\n", "image_id_", "=", "item", "[", "'image_id'", "]", "\n", "image_h", "=", "int", "(", "item", "[", "'image_h'", "]", ")", "\n", "image_w", "=", "int", "(", "item", "[", "'image_w'", "]", ")", "\n", "num_boxes", "=", "int", "(", "item", "[", "'num_boxes'", "]", ")", "\n", "\n", "features", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "\"features\"", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "2048", ")", "\n", "# if 'gt' not in self.features_path:", "\n", "#     features_vc = np.load('/data3/wangtan/vc/vilbert_beta/data/VCR/vcr_coco_xy/' + str(index) + '.npy')", "\n", "# else:", "\n", "#     features_vc = np.load('/data3/wangtan/vc/vilbert_beta/data/VCR/vcr_coco_xy_gt/' + str(index) + '.npy')", "\n", "# assert features_vc.shape[0] == features.shape[0]", "\n", "\n", "boxes", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "'boxes'", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "4", ")", "\n", "\n", "g_feat", "=", "np", ".", "sum", "(", "features", ",", "axis", "=", "0", ")", "/", "num_boxes", "\n", "# g_feat_vc = np.sum(features_vc, axis=0) / num_boxes", "\n", "\n", "num_boxes", "=", "num_boxes", "+", "1", "\n", "\n", "features", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_feat", ",", "axis", "=", "0", ")", ",", "features", "]", ",", "axis", "=", "0", ")", "\n", "# features_vc = np.concatenate([np.expand_dims(g_feat_vc, axis=0), features_vc], axis=0)", "\n", "# features = np.concatenate([features, features_vc], axis=1)", "\n", "\n", "self", ".", "features", "[", "index", "]", "=", "features", "\n", "\n", "image_location", "=", "np", ".", "zeros", "(", "(", "boxes", ".", "shape", "[", "0", "]", ",", "5", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "image_location", "[", ":", ",", ":", "4", "]", "=", "boxes", "\n", "image_location", "[", ":", ",", "4", "]", "=", "(", "image_location", "[", ":", ",", "3", "]", "-", "image_location", "[", ":", ",", "1", "]", ")", "*", "(", "image_location", "[", ":", ",", "2", "]", "-", "image_location", "[", ":", ",", "0", "]", ")", "/", "(", "float", "(", "image_w", ")", "*", "float", "(", "image_h", ")", ")", "\n", "\n", "image_location_ori", "=", "copy", ".", "deepcopy", "(", "image_location", ")", "\n", "\n", "image_location", "[", ":", ",", "0", "]", "=", "image_location", "[", ":", ",", "0", "]", "/", "float", "(", "image_w", ")", "\n", "image_location", "[", ":", ",", "1", "]", "=", "image_location", "[", ":", ",", "1", "]", "/", "float", "(", "image_h", ")", "\n", "image_location", "[", ":", ",", "2", "]", "=", "image_location", "[", ":", ",", "2", "]", "/", "float", "(", "image_w", ")", "\n", "image_location", "[", ":", ",", "3", "]", "=", "image_location", "[", ":", ",", "3", "]", "/", "float", "(", "image_h", ")", "\n", "\n", "g_location", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "image_location", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_location", ",", "axis", "=", "0", ")", ",", "image_location", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "boxes", "[", "index", "]", "=", "image_location", "\n", "\n", "g_location_ori", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "image_w", ",", "image_h", ",", "image_w", "*", "image_h", "]", ")", "\n", "image_location_ori", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_location_ori", ",", "axis", "=", "0", ")", ",", "image_location_ori", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "boxes_ori", "[", "index", "]", "=", "image_location_ori", "\n", "self", ".", "num_boxes", "[", "index", "]", "=", "num_boxes", "\n", "", "", "", "else", ":", "\n", "# Read chunk from file everytime if not loaded in memory.    ", "\n", "            ", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "                ", "item", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "image_id", ")", ")", "\n", "image_id_", "=", "item", "[", "'image_id'", "]", "\n", "image_h", "=", "int", "(", "item", "[", "'image_h'", "]", ")", "\n", "image_w", "=", "int", "(", "item", "[", "'image_w'", "]", ")", "\n", "num_boxes", "=", "int", "(", "item", "[", "'num_boxes'", "]", ")", "\n", "\n", "features", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "\"features\"", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "2048", ")", "\n", "boxes", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "'boxes'", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "4", ")", "\n", "g_feat", "=", "np", ".", "sum", "(", "features", ",", "axis", "=", "0", ")", "/", "num_boxes", "\n", "\n", "# if 'gt' not in self.features_path:", "\n", "#     features_vc = np.load('/data3/wangtan/vc/vilbert_beta/data/VCR/vcr_coco_xy/' + image_id.decode() + '.npy')", "\n", "# else:", "\n", "#     features_vc = np.load(", "\n", "#         '/data3/wangtan/vc/vilbert_beta/data/VCR/vcr_coco_xy_gt2/' + image_id.decode() + '.npy')", "\n", "# try:", "\n", "#     assert features_vc.shape[0] == features.shape[0]", "\n", "# except:", "\n", "#     print('error')", "\n", "# g_feat_vc = np.sum(features_vc, axis=0) / num_boxes", "\n", "\n", "\n", "num_boxes", "=", "num_boxes", "+", "1", "\n", "features", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_feat", ",", "axis", "=", "0", ")", ",", "features", "]", ",", "axis", "=", "0", ")", "\n", "# features_vc = np.concatenate([np.expand_dims(g_feat_vc, axis=0), features_vc], axis=0)", "\n", "# features = np.concatenate([features, features_vc], axis=1)", "\n", "\n", "\n", "image_location", "=", "np", ".", "zeros", "(", "(", "boxes", ".", "shape", "[", "0", "]", ",", "5", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "image_location", "[", ":", ",", ":", "4", "]", "=", "boxes", "\n", "image_location", "[", ":", ",", "4", "]", "=", "(", "image_location", "[", ":", ",", "3", "]", "-", "image_location", "[", ":", ",", "1", "]", ")", "*", "(", "image_location", "[", ":", ",", "2", "]", "-", "image_location", "[", ":", ",", "0", "]", ")", "/", "(", "float", "(", "image_w", ")", "*", "float", "(", "image_h", ")", ")", "\n", "\n", "image_location_ori", "=", "copy", ".", "deepcopy", "(", "image_location", ")", "\n", "image_location", "[", ":", ",", "0", "]", "=", "image_location", "[", ":", ",", "0", "]", "/", "float", "(", "image_w", ")", "\n", "image_location", "[", ":", ",", "1", "]", "=", "image_location", "[", ":", ",", "1", "]", "/", "float", "(", "image_h", ")", "\n", "image_location", "[", ":", ",", "2", "]", "=", "image_location", "[", ":", ",", "2", "]", "/", "float", "(", "image_w", ")", "\n", "image_location", "[", ":", ",", "3", "]", "=", "image_location", "[", ":", ",", "3", "]", "/", "float", "(", "image_h", ")", "\n", "\n", "g_location", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "image_location", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_location", ",", "axis", "=", "0", ")", ",", "image_location", "]", ",", "axis", "=", "0", ")", "\n", "\n", "g_location_ori", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "image_w", ",", "image_h", ",", "image_w", "*", "image_h", "]", ")", "\n", "image_location_ori", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_location_ori", ",", "axis", "=", "0", ")", ",", "image_location_ori", "]", ",", "axis", "=", "0", ")", "\n", "\n", "", "", "return", "features", ",", "num_boxes", ",", "image_location", ",", "image_location_ori", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils._image_features_reader.ImageFeaturesH5Reader.keys": [[163, 165], ["None"], "methods", ["None"], ["", "def", "keys", "(", "self", ")", "->", "List", "[", "int", "]", ":", "\n", "        ", "return", "self", ".", "_image_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.Flattener.__init__": [[38, 43], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Flattens last 3 dimensions to make it only batch size, -1\n        \"\"\"", "\n", "super", "(", "Flattener", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.Flattener.forward": [[44, 46], ["x.view", "x.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.time_batch": [[20, 35], ["time.time", "enumerate", "time.time", "time.time"], "function", ["None"], ["def", "time_batch", "(", "gen", ",", "reset_every", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Gets timing info for a batch\n    :param gen:\n    :param reset_every: How often we'll reset\n    :return:\n    \"\"\"", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "start_t", "=", "0", "\n", "for", "i", ",", "item", "in", "enumerate", "(", "gen", ")", ":", "\n", "        ", "time_per_batch", "=", "(", "time", ".", "time", "(", ")", "-", "start", ")", "/", "(", "i", "+", "1", "-", "start_t", ")", "\n", "yield", "time_per_batch", ",", "item", "\n", "if", "i", "%", "reset_every", "==", "0", ":", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "start_t", "=", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.pad_sequence": [[48, 61], ["sequence.new_zeros", "enumerate", "len", "max"], "function", ["None"], ["", "", "def", "pad_sequence", "(", "sequence", ",", "lengths", ")", ":", "\n", "    ", "\"\"\"\n    :param sequence: [\\sum b, .....] sequence\n    :param lengths: [b1, b2, b3...] that sum to \\sum b\n    :return: [len(lengths), maxlen(b), .....] tensor\n    \"\"\"", "\n", "output", "=", "sequence", ".", "new_zeros", "(", "len", "(", "lengths", ")", ",", "max", "(", "lengths", ")", ",", "*", "sequence", ".", "shape", "[", "1", ":", "]", ")", "\n", "start", "=", "0", "\n", "for", "i", ",", "diff", "in", "enumerate", "(", "lengths", ")", ":", "\n", "        ", "if", "diff", ">", "0", ":", "\n", "            ", "output", "[", "i", ",", ":", "diff", "]", "=", "sequence", "[", "start", ":", "(", "start", "+", "diff", ")", "]", "\n", "", "start", "+=", "diff", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.extra_leading_dim_in_sequence": [[63, 65], ["f().view", "f", "x.view", "mask.view"], "function", ["None"], ["", "def", "extra_leading_dim_in_sequence", "(", "f", ",", "x", ",", "mask", ")", ":", "\n", "    ", "return", "f", "(", "x", ".", "view", "(", "-", "1", ",", "*", "x", ".", "shape", "[", "2", ":", "]", ")", ",", "mask", ".", "view", "(", "-", "1", ",", "mask", ".", "shape", "[", "2", "]", ")", ")", ".", "view", "(", "*", "x", ".", "shape", "[", ":", "3", "]", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.clip_grad_norm": [[67, 107], ["float", "pandas.Series", "p.grad.data.norm", "tuple", "numpy.isnan", "print", "sorted", "print", "p.size", "p.grad.data.norm.item", "ValueError", "clip_coef.item", "p.grad.data.mul_", "param_to_norm.items", "print", "norm.item", "param_to_norm.items", "numpy.prod"], "function", ["None"], ["", "def", "clip_grad_norm", "(", "named_parameters", ",", "max_norm", ",", "clip", "=", "True", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Clips gradient norm of an iterable of parameters.\n\n    The norm is computed over all gradients together, as if they were\n    concatenated into a single vector. Gradients are modified in-place.\n\n    Arguments:\n        parameters (Iterable[Variable]): an iterable of Variables that will have\n            gradients normalized\n        max_norm (float or int): max norm of the gradients\n\n    Returns:\n        Total norm of the parameters (viewed as a single vector).\n    \"\"\"", "\n", "max_norm", "=", "float", "(", "max_norm", ")", "\n", "parameters", "=", "[", "(", "n", ",", "p", ")", "for", "n", ",", "p", "in", "named_parameters", "if", "p", ".", "grad", "is", "not", "None", "]", "\n", "total_norm", "=", "0", "\n", "param_to_norm", "=", "{", "}", "\n", "param_to_shape", "=", "{", "}", "\n", "for", "n", ",", "p", "in", "parameters", ":", "\n", "        ", "param_norm", "=", "p", ".", "grad", ".", "data", ".", "norm", "(", "2", ")", "\n", "total_norm", "+=", "param_norm", "**", "2", "\n", "param_to_norm", "[", "n", "]", "=", "param_norm", "\n", "param_to_shape", "[", "n", "]", "=", "tuple", "(", "p", ".", "size", "(", ")", ")", "\n", "if", "np", ".", "isnan", "(", "param_norm", ".", "item", "(", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"the param {} was null.\"", ".", "format", "(", "n", ")", ")", "\n", "\n", "", "", "total_norm", "=", "total_norm", "**", "(", "1.", "/", "2", ")", "\n", "clip_coef", "=", "max_norm", "/", "(", "total_norm", "+", "1e-6", ")", "\n", "if", "clip_coef", ".", "item", "(", ")", "<", "1", "and", "clip", ":", "\n", "        ", "for", "n", ",", "p", "in", "parameters", ":", "\n", "            ", "p", ".", "grad", ".", "data", ".", "mul_", "(", "clip_coef", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'---Total norm {:.3f} clip coef {:.3f}-----------------'", ".", "format", "(", "total_norm", ",", "clip_coef", ")", ")", "\n", "for", "name", ",", "norm", "in", "sorted", "(", "param_to_norm", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", ")", ":", "\n", "            ", "print", "(", "\"{:<60s}: {:.3f}, ({}: {})\"", ".", "format", "(", "name", ",", "norm", ",", "np", ".", "prod", "(", "param_to_shape", "[", "name", "]", ")", ",", "param_to_shape", "[", "name", "]", ")", ")", "\n", "", "print", "(", "'-------------------------------'", ",", "flush", "=", "True", ")", "\n", "\n", "", "return", "pd", ".", "Series", "(", "{", "name", ":", "norm", ".", "item", "(", ")", "for", "name", ",", "norm", "in", "param_to_norm", ".", "items", "(", ")", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.find_latest_checkpoint": [[109, 150], ["os.listdir", "os.path.join", "os.path.join", "any", "re.search().group", "epoch.split", "sorted", "str", "len", "int_epochs.append", "int_epochs.append", "re.search", "os.listdir", "int", "int"], "function", ["None"], ["", "def", "find_latest_checkpoint", "(", "serialization_dir", ")", ":", "\n", "    ", "\"\"\"\n    Return the location of the latest model and training state files.\n    If there isn't a valid checkpoint then return None.\n    \"\"\"", "\n", "have_checkpoint", "=", "(", "serialization_dir", "is", "not", "None", "and", "\n", "any", "(", "\"model_state_epoch_\"", "in", "x", "for", "x", "in", "os", ".", "listdir", "(", "serialization_dir", ")", ")", ")", "\n", "\n", "if", "not", "have_checkpoint", ":", "\n", "        ", "return", "None", "\n", "\n", "", "serialization_files", "=", "os", ".", "listdir", "(", "serialization_dir", ")", "\n", "model_checkpoints", "=", "[", "x", "for", "x", "in", "serialization_files", "if", "\"model_state_epoch\"", "in", "x", "]", "\n", "# Get the last checkpoint file.  Epochs are specified as either an", "\n", "# int (for end of epoch files) or with epoch and timestamp for", "\n", "# within epoch checkpoints, e.g. 5.2018-02-02-15-33-42", "\n", "found_epochs", "=", "[", "\n", "# pylint: disable=anomalous-backslash-in-string", "\n", "re", ".", "search", "(", "\"model_state_epoch_([0-9\\.\\-]+)\\.th\"", ",", "x", ")", ".", "group", "(", "1", ")", "\n", "for", "x", "in", "model_checkpoints", "\n", "]", "\n", "int_epochs", "=", "[", "]", "\n", "for", "epoch", "in", "found_epochs", ":", "\n", "        ", "pieces", "=", "epoch", ".", "split", "(", "'.'", ")", "\n", "if", "len", "(", "pieces", ")", "==", "1", ":", "\n", "# Just a single epoch without timestamp", "\n", "            ", "int_epochs", ".", "append", "(", "[", "int", "(", "pieces", "[", "0", "]", ")", ",", "0", "]", ")", "\n", "", "else", ":", "\n", "# has a timestamp", "\n", "            ", "int_epochs", ".", "append", "(", "[", "int", "(", "pieces", "[", "0", "]", ")", ",", "pieces", "[", "1", "]", "]", ")", "\n", "", "", "last_epoch", "=", "sorted", "(", "int_epochs", ",", "reverse", "=", "True", ")", "[", "0", "]", "\n", "if", "last_epoch", "[", "1", "]", "==", "0", ":", "\n", "        ", "epoch_to_load", "=", "str", "(", "last_epoch", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "        ", "epoch_to_load", "=", "'{0}.{1}'", ".", "format", "(", "last_epoch", "[", "0", "]", ",", "last_epoch", "[", "1", "]", ")", "\n", "\n", "", "model_path", "=", "os", ".", "path", ".", "join", "(", "serialization_dir", ",", "\n", "\"model_state_epoch_{}.th\"", ".", "format", "(", "epoch_to_load", ")", ")", "\n", "training_state_path", "=", "os", ".", "path", ".", "join", "(", "serialization_dir", ",", "\n", "\"training_state_epoch_{}.th\"", ".", "format", "(", "epoch_to_load", ")", ")", "\n", "return", "model_path", ",", "training_state_path", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.save_checkpoint": [[152, 185], ["os.path.join", "torch.save", "os.path.join", "torch.save", "isinstance", "model.module.state_dict", "model.state_dict", "optimizer.state_dict", "learning_rate_scheduler.lr_scheduler.state_dict", "print", "shutil.copyfile", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict"], ["", "def", "save_checkpoint", "(", "model", ",", "optimizer", ",", "serialization_dir", ",", "epoch", ",", "val_metric_per_epoch", ",", "is_best", "=", "None", ",", "\n", "learning_rate_scheduler", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Saves a checkpoint of the model to self._serialization_dir.\n    Is a no-op if self._serialization_dir is None.\n    Parameters\n    ----------\n    epoch : Union[int, str], required.\n        The epoch of training.  If the checkpoint is saved in the middle\n        of an epoch, the parameter is a string with the epoch and timestamp.\n    is_best: bool, optional (default = None)\n        A flag which causes the model weights at the given epoch to\n        be copied to a \"best.th\" file. The value of this flag should\n        be based on some validation metric computed by your model.\n    \"\"\"", "\n", "if", "serialization_dir", "is", "not", "None", ":", "\n", "        ", "model_path", "=", "os", ".", "path", ".", "join", "(", "serialization_dir", ",", "\"model_state_epoch_{}.th\"", ".", "format", "(", "epoch", ")", ")", "\n", "model_state", "=", "model", ".", "module", ".", "state_dict", "(", ")", "if", "isinstance", "(", "model", ",", "DataParallel", ")", "else", "model", ".", "state_dict", "(", ")", "\n", "torch", ".", "save", "(", "model_state", ",", "model_path", ")", "\n", "\n", "training_state", "=", "{", "'epoch'", ":", "epoch", ",", "\n", "'val_metric_per_epoch'", ":", "val_metric_per_epoch", ",", "\n", "'optimizer'", ":", "optimizer", ".", "state_dict", "(", ")", "\n", "}", "\n", "if", "learning_rate_scheduler", "is", "not", "None", ":", "\n", "            ", "training_state", "[", "\"learning_rate_scheduler\"", "]", "=", "learning_rate_scheduler", ".", "lr_scheduler", ".", "state_dict", "(", ")", "\n", "", "training_path", "=", "os", ".", "path", ".", "join", "(", "serialization_dir", ",", "\n", "\"training_state_epoch_{}.th\"", ".", "format", "(", "epoch", ")", ")", "\n", "torch", ".", "save", "(", "training_state", ",", "training_path", ")", "\n", "if", "is_best", ":", "\n", "            ", "print", "(", "\"Best validation performance so far. Copying weights to '{}/best.th'.\"", ".", "format", "(", "serialization_dir", ")", ")", "\n", "shutil", ".", "copyfile", "(", "model_path", ",", "os", ".", "path", ".", "join", "(", "serialization_dir", ",", "\"best.th\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.restore_best_checkpoint": [[187, 195], ["os.path.join", "torch.load", "os.path.exists", "isinstance", "model.module.load_state_dict", "model.load_state_dict", "allennlp.nn.util.device_mapping"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["", "", "", "def", "restore_best_checkpoint", "(", "model", ",", "serialization_dir", ")", ":", "\n", "    ", "fn", "=", "os", ".", "path", ".", "join", "(", "serialization_dir", ",", "'best.th'", ")", "\n", "model_state", "=", "torch", ".", "load", "(", "fn", ",", "map_location", "=", "device_mapping", "(", "-", "1", ")", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "fn", ")", "\n", "if", "isinstance", "(", "model", ",", "DataParallel", ")", ":", "\n", "        ", "model", ".", "module", ".", "load_state_dict", "(", "model_state", ")", "\n", "", "else", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "model_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.restore_checkpoint": [[197, 254], ["pytorch_misc.find_latest_checkpoint", "torch.load", "torch.load", "isinstance", "optimizer.load_state_dict", "allennlp.training.trainer.move_optimizer_to_cuda", "isinstance", "model.module.load_state_dict", "model.load_state_dict", "learning_rate_scheduler.lr_scheduler.load_state_dict", "print", "allennlp.nn.util.device_mapping", "allennlp.nn.util.device_mapping", "int", "training_state[].split"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.find_latest_checkpoint", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["", "", "def", "restore_checkpoint", "(", "model", ",", "optimizer", ",", "serialization_dir", ",", "learning_rate_scheduler", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Restores a model from a serialization_dir to the last saved checkpoint.\n    This includes an epoch count and optimizer state, which is serialized separately\n    from  model parameters. This function should only be used to continue training -\n    if you wish to load a model for inference/load parts of a model into a new\n    computation graph, you should use the native Pytorch functions:\n    `` model.load_state_dict(torch.load(\"/path/to/model/weights.th\"))``\n    If ``self._serialization_dir`` does not exist or does not contain any checkpointed weights,\n    this function will do nothing and return 0.\n    Returns\n    -------\n    epoch: int\n        The epoch at which to resume training, which should be one after the epoch\n        in the saved training state.\n    \"\"\"", "\n", "latest_checkpoint", "=", "find_latest_checkpoint", "(", "serialization_dir", ")", "\n", "\n", "if", "latest_checkpoint", "is", "None", ":", "\n", "# No checkpoint to restore, start at 0", "\n", "        ", "return", "0", ",", "[", "]", "\n", "\n", "", "model_path", ",", "training_state_path", "=", "latest_checkpoint", "\n", "\n", "# Load the parameters onto CPU, then transfer to GPU.", "\n", "# This avoids potential OOM on GPU for large models that", "\n", "# load parameters onto GPU then make a new GPU copy into the parameter", "\n", "# buffer. The GPU transfer happens implicitly in load_state_dict.", "\n", "model_state", "=", "torch", ".", "load", "(", "model_path", ",", "map_location", "=", "device_mapping", "(", "-", "1", ")", ")", "\n", "training_state", "=", "torch", ".", "load", "(", "training_state_path", ",", "map_location", "=", "device_mapping", "(", "-", "1", ")", ")", "\n", "if", "isinstance", "(", "model", ",", "DataParallel", ")", ":", "\n", "        ", "model", ".", "module", ".", "load_state_dict", "(", "model_state", ")", "\n", "", "else", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "model_state", ")", "\n", "\n", "# idk this is always bad luck for me", "\n", "", "optimizer", ".", "load_state_dict", "(", "training_state", "[", "\"optimizer\"", "]", ")", "\n", "\n", "if", "learning_rate_scheduler", "is", "not", "None", "and", "\"learning_rate_scheduler\"", "in", "training_state", ":", "\n", "        ", "learning_rate_scheduler", ".", "lr_scheduler", ".", "load_state_dict", "(", "\n", "training_state", "[", "\"learning_rate_scheduler\"", "]", ")", "\n", "", "move_optimizer_to_cuda", "(", "optimizer", ")", "\n", "\n", "# We didn't used to save `validation_metric_per_epoch`, so we can't assume", "\n", "# that it's part of the trainer state. If it's not there, an empty list is all", "\n", "# we can do.", "\n", "if", "\"val_metric_per_epoch\"", "not", "in", "training_state", ":", "\n", "        ", "print", "(", "\"trainer state `val_metric_per_epoch` not found, using empty list\"", ")", "\n", "val_metric_per_epoch", ":", "[", "]", "\n", "", "else", ":", "\n", "        ", "val_metric_per_epoch", "=", "training_state", "[", "\"val_metric_per_epoch\"", "]", "\n", "\n", "", "if", "isinstance", "(", "training_state", "[", "\"epoch\"", "]", ",", "int", ")", ":", "\n", "        ", "epoch_to_return", "=", "training_state", "[", "\"epoch\"", "]", "+", "1", "\n", "", "else", ":", "\n", "        ", "epoch_to_return", "=", "int", "(", "training_state", "[", "\"epoch\"", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", "+", "1", "\n", "", "return", "epoch_to_return", ",", "val_metric_per_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.detokenize": [[256, 266], ["vocab.get_token_from_index", "pytorch_misc.detokenize"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.detokenize"], ["", "def", "detokenize", "(", "array", ",", "vocab", ")", ":", "\n", "    ", "\"\"\"\n    Given an array of ints, we'll turn this into a string or a list of strings.\n    :param array: possibly multidimensional numpy array\n    :return:\n    \"\"\"", "\n", "if", "array", ".", "ndim", ">", "1", ":", "\n", "        ", "return", "[", "detokenize", "(", "x", ",", "vocab", ")", "for", "x", "in", "array", "]", "\n", "", "tokenized", "=", "[", "vocab", ".", "get_token_from_index", "(", "v", ")", "for", "v", "in", "array", "]", "\n", "return", "' '", ".", "join", "(", "[", "x", "for", "x", "in", "tokenized", "if", "x", "not", "in", "(", "vocab", ".", "_padding_token", ",", "START_SYMBOL", ",", "END_SYMBOL", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.print_para": [[268, 293], ["model.named_parameters", "pandas.set_option", "pandas.DataFrame().set_index", "print", "numpy.prod", "numpy.prod", "p.size", "numpy.prod", "pandas.DataFrame", "pd.DataFrame().set_index.to_string", "str", "p.size", "p.size", "p.size", "sorted", "st.items"], "function", ["None"], ["", "def", "print_para", "(", "model", ")", ":", "\n", "    ", "\"\"\"\n    Prints parameters of a model\n    :param opt:\n    :return:\n    \"\"\"", "\n", "st", "=", "{", "}", "\n", "total_params", "=", "0", "\n", "total_params_training", "=", "0", "\n", "for", "p_name", ",", "p", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "# if not ('bias' in p_name.split('.')[-1] or 'bn' in p_name.split('.')[-1]):", "\n", "        ", "st", "[", "p_name", "]", "=", "(", "[", "str", "(", "x", ")", "for", "x", "in", "p", ".", "size", "(", ")", "]", ",", "np", ".", "prod", "(", "p", ".", "size", "(", ")", ")", ",", "p", ".", "requires_grad", ")", "\n", "total_params", "+=", "np", ".", "prod", "(", "p", ".", "size", "(", ")", ")", "\n", "if", "p", ".", "requires_grad", ":", "\n", "            ", "total_params_training", "+=", "np", ".", "prod", "(", "p", ".", "size", "(", ")", ")", "\n", "", "", "pd", ".", "set_option", "(", "'display.max_columns'", ",", "None", ")", "\n", "shapes_df", "=", "pd", ".", "DataFrame", "(", "[", "(", "p_name", ",", "'[{}]'", ".", "format", "(", "','", ".", "join", "(", "size", ")", ")", ",", "prod", ",", "p_req_grad", ")", "\n", "for", "p_name", ",", "(", "size", ",", "prod", ",", "p_req_grad", ")", "in", "sorted", "(", "st", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", "[", "1", "]", ")", "]", ",", "\n", "columns", "=", "[", "'name'", ",", "'shape'", ",", "'size'", ",", "'requires_grad'", "]", ")", ".", "set_index", "(", "'name'", ")", "\n", "\n", "print", "(", "'\\n {:.1f}M total parameters. {:.1f}M training \\n ----- \\n {} \\n ----'", ".", "format", "(", "total_params", "/", "1000000.0", ",", "\n", "total_params_training", "/", "1000000.0", ",", "\n", "shapes_df", ".", "to_string", "(", ")", ")", ",", "\n", "flush", "=", "True", ")", "\n", "return", "shapes_df", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.batch_index_iterator": [[295, 311], ["range", "min"], "function", ["None"], ["", "def", "batch_index_iterator", "(", "len_l", ",", "batch_size", ",", "skip_end", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Provides indices that iterate over a list\n    :param len_l: int representing size of thing that we will\n        iterate over\n    :param batch_size: size of each batch\n    :param skip_end: if true, don't iterate over the last batch\n    :return: A generator that returns (start, end) tuples\n        as it goes through all batches\n    \"\"\"", "\n", "iterate_until", "=", "len_l", "\n", "if", "skip_end", ":", "\n", "        ", "iterate_until", "=", "(", "len_l", "//", "batch_size", ")", "*", "batch_size", "\n", "\n", "", "for", "b_start", "in", "range", "(", "0", ",", "iterate_until", ",", "batch_size", ")", ":", "\n", "        ", "yield", "(", "b_start", ",", "min", "(", "b_start", "+", "batch_size", ",", "len_l", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.batch_iterator": [[313, 316], ["pytorch_misc.batch_index_iterator", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.batch_index_iterator"], ["", "", "def", "batch_iterator", "(", "seq", ",", "batch_size", ",", "skip_end", "=", "True", ")", ":", "\n", "    ", "for", "b_start", ",", "b_end", "in", "batch_index_iterator", "(", "len", "(", "seq", ")", ",", "batch_size", ",", "skip_end", "=", "skip_end", ")", ":", "\n", "        ", "yield", "seq", "[", "b_start", ":", "b_end", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.box_coder.BoxCoder.__init__": [[13, 21], ["math.log"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "weights", ",", "bbox_xform_clip", "=", "math", ".", "log", "(", "1000.", "/", "16", ")", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            weights (4-element tuple)\n            bbox_xform_clip (float)\n        \"\"\"", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "bbox_xform_clip", "=", "bbox_xform_clip", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.box_coder.BoxCoder.encode": [[22, 51], ["torch.stack", "torch.log", "torch.log"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "reference_boxes", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Encode a set of proposals with respect to some\n        reference boxes\n\n        Arguments:\n            reference_boxes (Tensor): reference boxes\n            proposals (Tensor): boxes to be encoded\n        \"\"\"", "\n", "\n", "TO_REMOVE", "=", "1", "# TODO remove", "\n", "ex_widths", "=", "proposals", "[", ":", ",", "2", "]", "-", "proposals", "[", ":", ",", "0", "]", "+", "TO_REMOVE", "\n", "ex_heights", "=", "proposals", "[", ":", ",", "3", "]", "-", "proposals", "[", ":", ",", "1", "]", "+", "TO_REMOVE", "\n", "ex_ctr_x", "=", "proposals", "[", ":", ",", "0", "]", "+", "0.5", "*", "ex_widths", "\n", "ex_ctr_y", "=", "proposals", "[", ":", ",", "1", "]", "+", "0.5", "*", "ex_heights", "\n", "\n", "gt_widths", "=", "reference_boxes", "[", ":", ",", "2", "]", "-", "reference_boxes", "[", ":", ",", "0", "]", "+", "TO_REMOVE", "\n", "gt_heights", "=", "reference_boxes", "[", ":", ",", "3", "]", "-", "reference_boxes", "[", ":", ",", "1", "]", "+", "TO_REMOVE", "\n", "gt_ctr_x", "=", "reference_boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "gt_widths", "\n", "gt_ctr_y", "=", "reference_boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "gt_heights", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", "=", "self", ".", "weights", "\n", "targets_dx", "=", "wx", "*", "(", "gt_ctr_x", "-", "ex_ctr_x", ")", "/", "ex_widths", "\n", "targets_dy", "=", "wy", "*", "(", "gt_ctr_y", "-", "ex_ctr_y", ")", "/", "ex_heights", "\n", "targets_dw", "=", "ww", "*", "torch", ".", "log", "(", "gt_widths", "/", "ex_widths", ")", "\n", "targets_dh", "=", "wh", "*", "torch", ".", "log", "(", "gt_heights", "/", "ex_heights", ")", "\n", "\n", "targets", "=", "torch", ".", "stack", "(", "(", "targets_dx", ",", "targets_dy", ",", "targets_dw", ",", "targets_dh", ")", ",", "dim", "=", "1", ")", "\n", "return", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.box_coder.BoxCoder.decode": [[52, 96], ["boxes.to.to.to", "torch.clamp", "torch.clamp", "torch.zeros_like", "torch.exp", "torch.exp"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "decode", "(", "self", ",", "rel_codes", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"\n        From a set of original boxes and encoded relative box offsets,\n        get the decoded boxes.\n\n        Arguments:\n            rel_codes (Tensor): encoded boxes\n            boxes (Tensor): reference boxes.\n        \"\"\"", "\n", "\n", "boxes", "=", "boxes", ".", "to", "(", "rel_codes", ".", "dtype", ")", "\n", "\n", "TO_REMOVE", "=", "1", "# TODO remove", "\n", "widths", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "+", "TO_REMOVE", "\n", "heights", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "+", "TO_REMOVE", "\n", "ctr_x", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "widths", "\n", "ctr_y", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "heights", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", "=", "self", ".", "weights", "\n", "dx", "=", "rel_codes", "[", ":", ",", "0", ":", ":", "4", "]", "/", "wx", "\n", "dy", "=", "rel_codes", "[", ":", ",", "1", ":", ":", "4", "]", "/", "wy", "\n", "dw", "=", "rel_codes", "[", ":", ",", "2", ":", ":", "4", "]", "/", "ww", "\n", "dh", "=", "rel_codes", "[", ":", ",", "3", ":", ":", "4", "]", "/", "wh", "\n", "\n", "# Prevent sending too large values into torch.exp()", "\n", "dw", "=", "torch", ".", "clamp", "(", "dw", ",", "max", "=", "self", ".", "bbox_xform_clip", ")", "\n", "dh", "=", "torch", ".", "clamp", "(", "dh", ",", "max", "=", "self", ".", "bbox_xform_clip", ")", "\n", "\n", "pred_ctr_x", "=", "dx", "*", "widths", "[", ":", ",", "None", "]", "+", "ctr_x", "[", ":", ",", "None", "]", "\n", "pred_ctr_y", "=", "dy", "*", "heights", "[", ":", ",", "None", "]", "+", "ctr_y", "[", ":", ",", "None", "]", "\n", "pred_w", "=", "torch", ".", "exp", "(", "dw", ")", "*", "widths", "[", ":", ",", "None", "]", "\n", "pred_h", "=", "torch", ".", "exp", "(", "dh", ")", "*", "heights", "[", ":", ",", "None", "]", "\n", "\n", "pred_boxes", "=", "torch", ".", "zeros_like", "(", "rel_codes", ")", "\n", "# x1", "\n", "pred_boxes", "[", ":", ",", "0", ":", ":", "4", "]", "=", "pred_ctr_x", "-", "0.5", "*", "pred_w", "\n", "# y1", "\n", "pred_boxes", "[", ":", ",", "1", ":", ":", "4", "]", "=", "pred_ctr_y", "-", "0.5", "*", "pred_h", "\n", "# x2 (note: \"- 1\" is correct; don't be fooled by the asymmetry)", "\n", "pred_boxes", "[", ":", ",", "2", ":", ":", "4", "]", "=", "pred_ctr_x", "+", "0.5", "*", "pred_w", "-", "1", "\n", "# y2 (note: \"- 1\" is correct; don't be fooled by the asymmetry)", "\n", "pred_boxes", "[", ":", ",", "3", ":", ":", "4", "]", "=", "pred_ctr_y", "+", "0.5", "*", "pred_h", "-", "1", "\n", "\n", "return", "pred_boxes", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.balanced_positive_negative_sampler.BalancedPositiveNegativeSampler.__init__": [[10, 18], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "batch_size_per_image", ",", "positive_fraction", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            batch_size_per_image (int): number of elements to be selected per image\n            positive_fraction (float): percentage of positive elements per batch\n        \"\"\"", "\n", "self", ".", "batch_size_per_image", "=", "batch_size_per_image", "\n", "self", ".", "positive_fraction", "=", "positive_fraction", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.balanced_positive_negative_sampler.BalancedPositiveNegativeSampler.__call__": [[19, 69], ["torch.nonzero().squeeze", "torch.nonzero().squeeze", "int", "min", "min", "torch.zeros_like", "torch.zeros_like", "pos_idx.append", "neg_idx.append", "torch.nonzero().squeeze.numel", "torch.nonzero().squeeze.numel", "torch.randperm", "torch.randperm", "torch.nonzero", "torch.nonzero", "torch.nonzero().squeeze.numel", "torch.nonzero().squeeze.numel"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "matched_idxs", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            matched idxs: list of tensors containing -1, 0 or positive values.\n                Each tensor corresponds to a specific image.\n                -1 values are ignored, 0 are considered as negatives and > 0 as\n                positives.\n\n        Returns:\n            pos_idx (list[tensor])\n            neg_idx (list[tensor])\n\n        Returns two lists of binary masks for each image.\n        The first list contains the positive elements that were selected,\n        and the second list the negative example.\n        \"\"\"", "\n", "pos_idx", "=", "[", "]", "\n", "neg_idx", "=", "[", "]", "\n", "for", "matched_idxs_per_image", "in", "matched_idxs", ":", "\n", "            ", "positive", "=", "torch", ".", "nonzero", "(", "matched_idxs_per_image", ">=", "1", ")", ".", "squeeze", "(", "1", ")", "\n", "negative", "=", "torch", ".", "nonzero", "(", "matched_idxs_per_image", "==", "0", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "num_pos", "=", "int", "(", "self", ".", "batch_size_per_image", "*", "self", ".", "positive_fraction", ")", "\n", "# protect against not enough positive examples", "\n", "num_pos", "=", "min", "(", "positive", ".", "numel", "(", ")", ",", "num_pos", ")", "\n", "num_neg", "=", "self", ".", "batch_size_per_image", "-", "num_pos", "\n", "# protect against not enough negative examples", "\n", "num_neg", "=", "min", "(", "negative", ".", "numel", "(", ")", ",", "num_neg", ")", "\n", "\n", "# randomly select positive and negative examples", "\n", "perm1", "=", "torch", ".", "randperm", "(", "positive", ".", "numel", "(", ")", ",", "device", "=", "positive", ".", "device", ")", "[", ":", "num_pos", "]", "\n", "perm2", "=", "torch", ".", "randperm", "(", "negative", ".", "numel", "(", ")", ",", "device", "=", "negative", ".", "device", ")", "[", ":", "num_neg", "]", "\n", "\n", "pos_idx_per_image", "=", "positive", "[", "perm1", "]", "\n", "neg_idx_per_image", "=", "negative", "[", "perm2", "]", "\n", "\n", "# create binary mask from indices", "\n", "pos_idx_per_image_mask", "=", "torch", ".", "zeros_like", "(", "\n", "matched_idxs_per_image", ",", "dtype", "=", "torch", ".", "uint8", "\n", ")", "\n", "neg_idx_per_image_mask", "=", "torch", ".", "zeros_like", "(", "\n", "matched_idxs_per_image", ",", "dtype", "=", "torch", ".", "uint8", "\n", ")", "\n", "pos_idx_per_image_mask", "[", "pos_idx_per_image", "]", "=", "1", "\n", "neg_idx_per_image_mask", "[", "neg_idx_per_image", "]", "=", "1", "\n", "\n", "pos_idx", ".", "append", "(", "pos_idx_per_image_mask", ")", "\n", "neg_idx", ".", "append", "(", "neg_idx_per_image_mask", ")", "\n", "\n", "", "return", "pos_idx", ",", "neg_idx", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.matcher.Matcher.__init__": [[23, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "high_threshold", ",", "low_threshold", ",", "allow_low_quality_matches", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            high_threshold (float): quality values greater than or equal to\n                this value are candidate matches.\n            low_threshold (float): a lower quality threshold used to stratify\n                matches into three levels:\n                1) matches >= high_threshold\n                2) BETWEEN_THRESHOLDS matches in [low_threshold, high_threshold)\n                3) BELOW_LOW_THRESHOLD matches in [0, low_threshold)\n            allow_low_quality_matches (bool): if True, produce additional matches\n                for predictions that have only low-quality match candidates. See\n                set_low_quality_matches_ for more details.\n        \"\"\"", "\n", "assert", "low_threshold", "<=", "high_threshold", "\n", "self", ".", "high_threshold", "=", "high_threshold", "\n", "self", ".", "low_threshold", "=", "low_threshold", "\n", "self", ".", "allow_low_quality_matches", "=", "allow_low_quality_matches", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.matcher.Matcher.__call__": [[42, 82], ["match_quality_matrix.max", "match_quality_matrix.numel", "matches.clone", "matcher.Matcher.set_low_quality_matches_", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.matcher.Matcher.set_low_quality_matches_"], ["", "def", "__call__", "(", "self", ",", "match_quality_matrix", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            match_quality_matrix (Tensor[float]): an MxN tensor, containing the\n            pairwise quality between M ground-truth elements and N predicted elements.\n\n        Returns:\n            matches (Tensor[int64]): an N tensor where N[i] is a matched gt in\n            [0, M - 1] or a negative value indicating that prediction i could not\n            be matched.\n        \"\"\"", "\n", "if", "match_quality_matrix", ".", "numel", "(", ")", "==", "0", ":", "\n", "# empty targets or proposals not supported during training", "\n", "            ", "if", "match_quality_matrix", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"No ground-truth boxes available for one of the images \"", "\n", "\"during training\"", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"No proposal boxes available for one of the images \"", "\n", "\"during training\"", ")", "\n", "\n", "# match_quality_matrix is M (gt) x N (predicted)", "\n", "# Max over gt elements (dim 0) to find best gt candidate for each prediction", "\n", "", "", "matched_vals", ",", "matches", "=", "match_quality_matrix", ".", "max", "(", "dim", "=", "0", ")", "\n", "if", "self", ".", "allow_low_quality_matches", ":", "\n", "            ", "all_matches", "=", "matches", ".", "clone", "(", ")", "\n", "\n", "# Assign candidate matches with low quality to negative (unassigned) values", "\n", "", "below_low_threshold", "=", "matched_vals", "<", "self", ".", "low_threshold", "\n", "between_thresholds", "=", "(", "matched_vals", ">=", "self", ".", "low_threshold", ")", "&", "(", "\n", "matched_vals", "<", "self", ".", "high_threshold", "\n", ")", "\n", "matches", "[", "below_low_threshold", "]", "=", "Matcher", ".", "BELOW_LOW_THRESHOLD", "\n", "matches", "[", "between_thresholds", "]", "=", "Matcher", ".", "BETWEEN_THRESHOLDS", "\n", "\n", "if", "self", ".", "allow_low_quality_matches", ":", "\n", "            ", "self", ".", "set_low_quality_matches_", "(", "matches", ",", "all_matches", ",", "match_quality_matrix", ")", "\n", "\n", "", "return", "matches", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.matcher.Matcher.set_low_quality_matches_": [[83, 113], ["match_quality_matrix.max", "torch.nonzero"], "methods", ["None"], ["", "def", "set_low_quality_matches_", "(", "self", ",", "matches", ",", "all_matches", ",", "match_quality_matrix", ")", ":", "\n", "        ", "\"\"\"\n        Produce additional matches for predictions that have only low-quality matches.\n        Specifically, for each ground-truth find the set of predictions that have\n        maximum overlap with it (including ties); for each prediction in that set, if\n        it is unmatched, then match it to the ground-truth with which it has the highest\n        quality value.\n        \"\"\"", "\n", "# For each gt, find the prediction with which it has highest quality", "\n", "highest_quality_foreach_gt", ",", "_", "=", "match_quality_matrix", ".", "max", "(", "dim", "=", "1", ")", "\n", "# Find highest quality match available, even if it is low, including ties", "\n", "gt_pred_pairs_of_highest_quality", "=", "torch", ".", "nonzero", "(", "\n", "match_quality_matrix", "==", "highest_quality_foreach_gt", "[", ":", ",", "None", "]", "\n", ")", "\n", "# Example gt_pred_pairs_of_highest_quality:", "\n", "#   tensor([[    0, 39796],", "\n", "#           [    1, 32055],", "\n", "#           [    1, 32070],", "\n", "#           [    2, 39190],", "\n", "#           [    2, 40255],", "\n", "#           [    3, 40390],", "\n", "#           [    3, 41455],", "\n", "#           [    4, 45470],", "\n", "#           [    5, 45325],", "\n", "#           [    5, 46390]])", "\n", "# Each row is a (gt index, prediction index)", "\n", "# Note how gt items 1, 2, 3, and 5 each have two ties", "\n", "\n", "pred_inds_to_update", "=", "gt_pred_pairs_of_highest_quality", "[", ":", ",", "1", "]", "\n", "matches", "[", "pred_inds_to_update", "]", "=", "all_matches", "[", "pred_inds_to_update", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.poolers.LevelMapper.__init__": [[16, 30], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "k_min", ",", "k_max", ",", "canonical_scale", "=", "224", ",", "canonical_level", "=", "4", ",", "eps", "=", "1e-6", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            k_min (int)\n            k_max (int)\n            canonical_scale (int)\n            canonical_level (int)\n            eps (float)\n        \"\"\"", "\n", "self", ".", "k_min", "=", "k_min", "\n", "self", ".", "k_max", "=", "k_max", "\n", "self", ".", "s0", "=", "canonical_scale", "\n", "self", ".", "lvl0", "=", "canonical_level", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.poolers.LevelMapper.__call__": [[31, 43], ["torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.floor", "torch.floor", "torch.floor", "torch.floor", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "utils.cat", "torch.clamp.to", "torch.clamp.to", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "boxlist.area"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.area"], ["", "def", "__call__", "(", "self", ",", "boxlists", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            boxlists (list[BoxList])\n        \"\"\"", "\n", "# Compute level ids", "\n", "s", "=", "torch", ".", "sqrt", "(", "cat", "(", "[", "boxlist", ".", "area", "(", ")", "for", "boxlist", "in", "boxlists", "]", ")", ")", "\n", "\n", "# Eqn.(1) in FPN paper", "\n", "target_lvls", "=", "torch", ".", "floor", "(", "self", ".", "lvl0", "+", "torch", ".", "log2", "(", "s", "/", "self", ".", "s0", "+", "self", ".", "eps", ")", ")", "\n", "target_lvls", "=", "torch", ".", "clamp", "(", "target_lvls", ",", "min", "=", "self", ".", "k_min", ",", "max", "=", "self", ".", "k_max", ")", "\n", "return", "target_lvls", ".", "to", "(", "torch", ".", "int64", ")", "-", "self", ".", "k_min", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.poolers.Pooler.__init__": [[55, 77], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "torch.nn.ModuleList", "poolers.LevelMapper", "poolers.append", "torch.log2().item", "torch.log2().item", "torch.log2().item", "torch.log2().item", "torch.log2().item", "torch.log2().item", "torch.log2().item", "torch.log2().item", "vc_rcnn.layers.ROIAlign", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "output_size", ",", "scales", ",", "sampling_ratio", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            output_size (list[tuple[int]] or list[int]): output size for the pooled region\n            scales (list[float]): scales for each Pooler\n            sampling_ratio (int): sampling ratio for ROIAlign\n        \"\"\"", "\n", "super", "(", "Pooler", ",", "self", ")", ".", "__init__", "(", ")", "\n", "poolers", "=", "[", "]", "\n", "for", "scale", "in", "scales", ":", "\n", "            ", "poolers", ".", "append", "(", "\n", "ROIAlign", "(", "\n", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", "\n", ")", "\n", ")", "\n", "", "self", ".", "poolers", "=", "nn", ".", "ModuleList", "(", "poolers", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "# get the levels in the feature map by leveraging the fact that the network always", "\n", "# downsamples by a factor of 2 at each level.", "\n", "lvl_min", "=", "-", "torch", ".", "log2", "(", "torch", ".", "tensor", "(", "scales", "[", "0", "]", ",", "dtype", "=", "torch", ".", "float32", ")", ")", ".", "item", "(", ")", "\n", "lvl_max", "=", "-", "torch", ".", "log2", "(", "torch", ".", "tensor", "(", "scales", "[", "-", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ")", ")", ".", "item", "(", ")", "\n", "self", ".", "map_levels", "=", "LevelMapper", "(", "lvl_min", ",", "lvl_max", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.poolers.Pooler.convert_to_roi_format": [[78, 90], ["utils.cat", "utils.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.full", "torch.full", "torch.full", "torch.full", "enumerate", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "convert_to_roi_format", "(", "self", ",", "boxes", ")", ":", "\n", "        ", "concat_boxes", "=", "cat", "(", "[", "b", ".", "bbox", "for", "b", "in", "boxes", "]", ",", "dim", "=", "0", ")", "\n", "device", ",", "dtype", "=", "concat_boxes", ".", "device", ",", "concat_boxes", ".", "dtype", "\n", "ids", "=", "cat", "(", "\n", "[", "\n", "torch", ".", "full", "(", "(", "len", "(", "b", ")", ",", "1", ")", ",", "i", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "for", "i", ",", "b", "in", "enumerate", "(", "boxes", ")", "\n", "]", ",", "\n", "dim", "=", "0", ",", "\n", ")", "\n", "rois", "=", "torch", ".", "cat", "(", "[", "ids", ",", "concat_boxes", "]", ",", "dim", "=", "1", ")", "\n", "return", "rois", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.poolers.Pooler.forward": [[91, 122], ["len", "poolers.Pooler.convert_to_roi_format", "poolers.Pooler.map_levels", "len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "zip", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "pooler().to", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "pooler"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.poolers.Pooler.convert_to_roi_format", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "forward", "(", "self", ",", "x", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            x (list[Tensor]): feature maps for each level\n            boxes (list[BoxList]): boxes to be used to perform the pooling operation.\n        Returns:\n            result (Tensor)\n        \"\"\"", "\n", "num_levels", "=", "len", "(", "self", ".", "poolers", ")", "\n", "rois", "=", "self", ".", "convert_to_roi_format", "(", "boxes", ")", "\n", "if", "num_levels", "==", "1", ":", "\n", "            ", "return", "self", ".", "poolers", "[", "0", "]", "(", "x", "[", "0", "]", ",", "rois", ")", "\n", "\n", "", "levels", "=", "self", ".", "map_levels", "(", "boxes", ")", "\n", "\n", "num_rois", "=", "len", "(", "rois", ")", "\n", "num_channels", "=", "x", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "output_size", "=", "self", ".", "output_size", "[", "0", "]", "\n", "\n", "dtype", ",", "device", "=", "x", "[", "0", "]", ".", "dtype", ",", "x", "[", "0", "]", ".", "device", "\n", "result", "=", "torch", ".", "zeros", "(", "\n", "(", "num_rois", ",", "num_channels", ",", "output_size", ",", "output_size", ")", ",", "\n", "dtype", "=", "dtype", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "for", "level", ",", "(", "per_level_feature", ",", "pooler", ")", "in", "enumerate", "(", "zip", "(", "x", ",", "self", ".", "poolers", ")", ")", ":", "\n", "            ", "idx_in_level", "=", "torch", ".", "nonzero", "(", "levels", "==", "level", ")", ".", "squeeze", "(", "1", ")", "\n", "rois_per_level", "=", "rois", "[", "idx_in_level", "]", "\n", "result", "[", "idx_in_level", "]", "=", "pooler", "(", "per_level_feature", ",", "rois_per_level", ")", ".", "to", "(", "dtype", ")", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.poolers.make_pooler": [[124, 134], ["poolers.Pooler"], "function", ["None"], ["", "", "def", "make_pooler", "(", "cfg", ",", "head_name", ")", ":", "\n", "    ", "resolution", "=", "cfg", ".", "MODEL", "[", "head_name", "]", ".", "POOLER_RESOLUTION", "\n", "scales", "=", "cfg", ".", "MODEL", "[", "head_name", "]", ".", "POOLER_SCALES", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", "[", "head_name", "]", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler", "=", "Pooler", "(", "\n", "output_size", "=", "(", "resolution", ",", "resolution", ")", ",", "\n", "scales", "=", "scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", ")", "\n", "return", "pooler", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat": [[9, 17], ["isinstance", "torch.cat", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["def", "cat", "(", "tensors", ",", "dim", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Efficient version of torch.cat that avoids a copy if there is only a single element in a list\n    \"\"\"", "\n", "assert", "isinstance", "(", "tensors", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "len", "(", "tensors", ")", "==", "1", ":", "\n", "        ", "return", "tensors", "[", "0", "]", "\n", "", "return", "torch", ".", "cat", "(", "tensors", ",", "dim", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.get_group_gn": [[14, 29], ["None"], "function", ["None"], ["def", "get_group_gn", "(", "dim", ",", "dim_per_gp", ",", "num_groups", ")", ":", "\n", "    ", "\"\"\"get number of groups used by GroupNorm, based on number of channels.\"\"\"", "\n", "assert", "dim_per_gp", "==", "-", "1", "or", "num_groups", "==", "-", "1", ",", "\"GroupNorm: can only specify G or C/G.\"", "\n", "\n", "if", "dim_per_gp", ">", "0", ":", "\n", "        ", "assert", "dim", "%", "dim_per_gp", "==", "0", ",", "\"dim: {}, dim_per_gp: {}\"", ".", "format", "(", "dim", ",", "dim_per_gp", ")", "\n", "group_gn", "=", "dim", "//", "dim_per_gp", "\n", "", "else", ":", "\n", "        ", "assert", "dim", "%", "num_groups", "==", "0", ",", "\"dim: {}, num_groups: {}\"", ".", "format", "(", "dim", ",", "num_groups", ")", "\n", "group_gn", "=", "num_groups", "\n", "\n", "", "return", "group_gn", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.group_norm": [[31, 41], ["torch.nn.GroupNorm", "make_layers.get_group_gn"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.get_group_gn"], ["", "def", "group_norm", "(", "out_channels", ",", "affine", "=", "True", ",", "divisor", "=", "1", ")", ":", "\n", "    ", "out_channels", "=", "out_channels", "//", "divisor", "\n", "dim_per_gp", "=", "cfg", ".", "MODEL", ".", "GROUP_NORM", ".", "DIM_PER_GP", "//", "divisor", "\n", "num_groups", "=", "cfg", ".", "MODEL", ".", "GROUP_NORM", ".", "NUM_GROUPS", "//", "divisor", "\n", "eps", "=", "cfg", ".", "MODEL", ".", "GROUP_NORM", ".", "EPSILON", "# default: 1e-5", "\n", "return", "torch", ".", "nn", ".", "GroupNorm", "(", "\n", "get_group_gn", "(", "out_channels", ",", "dim_per_gp", ",", "num_groups", ")", ",", "\n", "out_channels", ",", "\n", "eps", ",", "\n", "affine", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.make_conv3x3": [[44, 78], ["vc_rcnn.layers.Conv2d", "torch.nn.init.kaiming_normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "module.append", "module.append", "len", "torch.nn.Sequential", "make_layers.group_norm", "torch.nn.ReLU"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.group_norm"], ["", "def", "make_conv3x3", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "dilation", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "use_gn", "=", "False", ",", "\n", "use_relu", "=", "False", ",", "\n", "kaiming_init", "=", "True", "\n", ")", ":", "\n", "    ", "conv", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", "bias", "=", "False", "if", "use_gn", "else", "True", "\n", ")", "\n", "if", "kaiming_init", ":", "\n", "        ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "conv", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", "\n", ")", "\n", "", "else", ":", "\n", "        ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "conv", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "", "if", "not", "use_gn", ":", "\n", "        ", "nn", ".", "init", ".", "constant_", "(", "conv", ".", "bias", ",", "0", ")", "\n", "", "module", "=", "[", "conv", ",", "]", "\n", "if", "use_gn", ":", "\n", "        ", "module", ".", "append", "(", "group_norm", "(", "out_channels", ")", ")", "\n", "", "if", "use_relu", ":", "\n", "        ", "module", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "", "if", "len", "(", "module", ")", ">", "1", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "*", "module", ")", "\n", "", "return", "conv", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.make_fc": [[80, 93], ["torch.nn.Linear", "torch.nn.init.kaiming_uniform_", "torch.nn.init.constant_", "torch.nn.Linear", "torch.nn.init.kaiming_uniform_", "torch.nn.Sequential", "make_layers.group_norm"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.group_norm"], ["", "def", "make_fc", "(", "dim_in", ",", "hidden_dim", ",", "use_gn", "=", "False", ")", ":", "\n", "    ", "'''\n        Caffe2 implementation uses XavierFill, which in fact\n        corresponds to kaiming_uniform_ in PyTorch\n    '''", "\n", "if", "use_gn", ":", "\n", "        ", "fc", "=", "nn", ".", "Linear", "(", "dim_in", ",", "hidden_dim", ",", "bias", "=", "False", ")", "\n", "nn", ".", "init", ".", "kaiming_uniform_", "(", "fc", ".", "weight", ",", "a", "=", "1", ")", "\n", "return", "nn", ".", "Sequential", "(", "fc", ",", "group_norm", "(", "hidden_dim", ")", ")", "\n", "", "fc", "=", "nn", ".", "Linear", "(", "dim_in", ",", "hidden_dim", ")", "\n", "nn", ".", "init", ".", "kaiming_uniform_", "(", "fc", ".", "weight", ",", "a", "=", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "fc", ".", "bias", ",", "0", ")", "\n", "return", "fc", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.conv_with_kaiming_uniform": [[95, 123], ["vc_rcnn.layers.Conv2d", "torch.nn.init.kaiming_uniform_", "torch.nn.init.constant_", "module.append", "module.append", "len", "torch.nn.Sequential", "make_layers.group_norm", "torch.nn.ReLU"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.group_norm"], ["", "def", "conv_with_kaiming_uniform", "(", "use_gn", "=", "False", ",", "use_relu", "=", "False", ")", ":", "\n", "    ", "def", "make_conv", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", "=", "1", ",", "dilation", "=", "1", "\n", ")", ":", "\n", "        ", "conv", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "dilation", "*", "(", "kernel_size", "-", "1", ")", "//", "2", ",", "\n", "dilation", "=", "dilation", ",", "\n", "bias", "=", "False", "if", "use_gn", "else", "True", "\n", ")", "\n", "# Caffe2 implementation uses XavierFill, which in fact", "\n", "# corresponds to kaiming_uniform_ in PyTorch", "\n", "nn", ".", "init", ".", "kaiming_uniform_", "(", "conv", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "use_gn", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "conv", ".", "bias", ",", "0", ")", "\n", "", "module", "=", "[", "conv", ",", "]", "\n", "if", "use_gn", ":", "\n", "            ", "module", ".", "append", "(", "group_norm", "(", "out_channels", ")", ")", "\n", "", "if", "use_relu", ":", "\n", "            ", "module", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "", "if", "len", "(", "module", ")", ">", "1", ":", "\n", "            ", "return", "nn", ".", "Sequential", "(", "*", "module", ")", "\n", "", "return", "conv", "\n", "\n", "", "return", "make_conv", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNHeadConvRegressor.__init__": [[19, 35], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ",", "num_anchors", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            cfg              : config\n            in_channels (int): number of channels of the input feature\n            num_anchors (int): number of anchors to be predicted\n        \"\"\"", "\n", "super", "(", "RPNHeadConvRegressor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cls_logits", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "num_anchors", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "num_anchors", "*", "4", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", "\n", ")", "\n", "\n", "for", "l", "in", "[", "self", ".", "cls_logits", ",", "self", ".", "bbox_pred", "]", ":", "\n", "            ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "l", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNHeadConvRegressor.forward": [[36, 42], ["isinstance", "rpn.RPNHeadConvRegressor.cls_logits", "rpn.RPNHeadConvRegressor.bbox_pred"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "isinstance", "(", "x", ",", "(", "list", ",", "tuple", ")", ")", "\n", "logits", "=", "[", "self", ".", "cls_logits", "(", "y", ")", "for", "y", "in", "x", "]", "\n", "bbox_reg", "=", "[", "self", ".", "bbox_pred", "(", "y", ")", "for", "y", "in", "x", "]", "\n", "\n", "return", "logits", ",", "bbox_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNHeadFeatureSingleConv.__init__": [[49, 65], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            cfg              : config\n            in_channels (int): number of channels of the input feature\n        \"\"\"", "\n", "super", "(", "RPNHeadFeatureSingleConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "in_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "\n", "for", "l", "in", "[", "self", ".", "conv", "]", ":", "\n", "            ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "l", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "self", ".", "out_channels", "=", "in_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNHeadFeatureSingleConv.forward": [[66, 71], ["isinstance", "torch.relu", "torch.relu", "rpn.RPNHeadFeatureSingleConv.conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "isinstance", "(", "x", ",", "(", "list", ",", "tuple", ")", ")", "\n", "x", "=", "[", "F", ".", "relu", "(", "self", ".", "conv", "(", "z", ")", ")", "for", "z", "in", "x", "]", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNHead.__init__": [[79, 98], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ",", "num_anchors", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            cfg              : config\n            in_channels (int): number of channels of the input feature\n            num_anchors (int): number of anchors to be predicted\n        \"\"\"", "\n", "super", "(", "RPNHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "in_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "self", ".", "cls_logits", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "num_anchors", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "num_anchors", "*", "4", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", "\n", ")", "\n", "\n", "for", "l", "in", "[", "self", ".", "conv", ",", "self", ".", "cls_logits", ",", "self", ".", "bbox_pred", "]", ":", "\n", "            ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "l", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNHead.forward": [[99, 107], ["torch.relu", "torch.relu", "logits.append", "bbox_reg.append", "rpn.RPNHead.conv", "rpn.RPNHead.cls_logits", "rpn.RPNHead.bbox_pred"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "logits", "=", "[", "]", "\n", "bbox_reg", "=", "[", "]", "\n", "for", "feature", "in", "x", ":", "\n", "            ", "t", "=", "F", ".", "relu", "(", "self", ".", "conv", "(", "feature", ")", ")", "\n", "logits", ".", "append", "(", "self", ".", "cls_logits", "(", "t", ")", ")", "\n", "bbox_reg", ".", "append", "(", "self", ".", "bbox_pred", "(", "t", ")", ")", "\n", "", "return", "logits", ",", "bbox_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNModule.__init__": [[115, 139], ["super().__init__", "cfg.clone", "anchor_generator.make_anchor_generator.make_anchor_generator", "rpn_head", "vc_rcnn.modeling.box_coder.BoxCoder", "inference.make_rpn_postprocessor", "inference.make_rpn_postprocessor", "loss.make_rpn_loss_evaluator", "anchor_generator.make_anchor_generator.make_anchor_generator.num_anchors_per_location"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.make_anchor_generator", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.inference.make_rpn_postprocessor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.inference.make_rpn_postprocessor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.loss.make_rpn_loss_evaluator", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.AnchorGenerator.num_anchors_per_location"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "RPNModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "\n", "anchor_generator", "=", "make_anchor_generator", "(", "cfg", ")", "\n", "\n", "rpn_head", "=", "registry", ".", "RPN_HEADS", "[", "cfg", ".", "MODEL", ".", "RPN", ".", "RPN_HEAD", "]", "\n", "head", "=", "rpn_head", "(", "\n", "cfg", ",", "in_channels", ",", "anchor_generator", ".", "num_anchors_per_location", "(", ")", "[", "0", "]", "\n", ")", "\n", "\n", "rpn_box_coder", "=", "BoxCoder", "(", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", "\n", "\n", "box_selector_train", "=", "make_rpn_postprocessor", "(", "cfg", ",", "rpn_box_coder", ",", "is_train", "=", "True", ")", "\n", "box_selector_test", "=", "make_rpn_postprocessor", "(", "cfg", ",", "rpn_box_coder", ",", "is_train", "=", "False", ")", "\n", "\n", "loss_evaluator", "=", "make_rpn_loss_evaluator", "(", "cfg", ",", "rpn_box_coder", ")", "\n", "\n", "self", ".", "anchor_generator", "=", "anchor_generator", "\n", "self", ".", "head", "=", "head", "\n", "self", ".", "box_selector_train", "=", "box_selector_train", "\n", "self", ".", "box_selector_test", "=", "box_selector_test", "\n", "self", ".", "loss_evaluator", "=", "loss_evaluator", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNModule.forward": [[140, 162], ["rpn.RPNModule.head", "rpn.RPNModule.anchor_generator", "rpn.RPNModule._forward_train", "rpn.RPNModule._forward_test"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetModule._forward_train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetModule._forward_test"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            images (ImageList): images for which we want to compute the predictions\n            features (list[Tensor]): features computed from the images that are\n                used for computing the predictions. Each tensor in the list\n                correspond to different feature levels\n            targets (list[BoxList): ground-truth boxes present in the image (optional)\n\n        Returns:\n            boxes (list[BoxList]): the predicted boxes from the RPN, one BoxList per\n                image.\n            losses (dict[Tensor]): the losses for the model during training. During\n                testing, it is an empty dict.\n        \"\"\"", "\n", "objectness", ",", "rpn_box_regression", "=", "self", ".", "head", "(", "features", ")", "\n", "anchors", "=", "self", ".", "anchor_generator", "(", "images", ",", "features", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "self", ".", "_forward_train", "(", "anchors", ",", "objectness", ",", "rpn_box_regression", ",", "targets", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_forward_test", "(", "anchors", ",", "objectness", ",", "rpn_box_regression", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNModule._forward_train": [[163, 185], ["rpn.RPNModule.loss_evaluator", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "rpn.RPNModule.box_selector_train"], "methods", ["None"], ["", "", "def", "_forward_train", "(", "self", ",", "anchors", ",", "objectness", ",", "rpn_box_regression", ",", "targets", ")", ":", "\n", "        ", "if", "self", ".", "cfg", ".", "MODEL", ".", "RPN_ONLY", ":", "\n", "# When training an RPN-only model, the loss is determined by the", "\n", "# predicted objectness and rpn_box_regression values and there is", "\n", "# no need to transform the anchors into predicted boxes; this is an", "\n", "# optimization that avoids the unnecessary transformation.", "\n", "            ", "boxes", "=", "anchors", "\n", "", "else", ":", "\n", "# For end-to-end models, anchors must be transformed into boxes and", "\n", "# sampled into a training batch.", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "boxes", "=", "self", ".", "box_selector_train", "(", "\n", "anchors", ",", "objectness", ",", "rpn_box_regression", ",", "targets", "\n", ")", "\n", "", "", "loss_objectness", ",", "loss_rpn_box_reg", "=", "self", ".", "loss_evaluator", "(", "\n", "anchors", ",", "objectness", ",", "rpn_box_regression", ",", "targets", "\n", ")", "\n", "losses", "=", "{", "\n", "\"loss_objectness\"", ":", "loss_objectness", ",", "\n", "\"loss_rpn_box_reg\"", ":", "loss_rpn_box_reg", ",", "\n", "}", "\n", "return", "boxes", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.RPNModule._forward_test": [[186, 198], ["rpn.RPNModule.box_selector_test", "box.get_field().sort", "zip", "box.get_field"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "_forward_test", "(", "self", ",", "anchors", ",", "objectness", ",", "rpn_box_regression", ")", ":", "\n", "        ", "boxes", "=", "self", ".", "box_selector_test", "(", "anchors", ",", "objectness", ",", "rpn_box_regression", ")", "\n", "if", "self", ".", "cfg", ".", "MODEL", ".", "RPN_ONLY", ":", "\n", "# For end-to-end models, the RPN proposals are an intermediate state", "\n", "# and don't bother to sort them in decreasing score order. For RPN-only", "\n", "# models, the proposals are the final output and we return them in", "\n", "# high-to-low confidence order.", "\n", "            ", "inds", "=", "[", "\n", "box", ".", "get_field", "(", "\"objectness\"", ")", ".", "sort", "(", "descending", "=", "True", ")", "[", "1", "]", "for", "box", "in", "boxes", "\n", "]", "\n", "boxes", "=", "[", "box", "[", "ind", "]", "for", "box", ",", "ind", "in", "zip", "(", "boxes", ",", "inds", ")", "]", "\n", "", "return", "boxes", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.rpn.build_rpn": [[200, 208], ["rpn.RPNModule", "vc_rcnn.modeling.rpn.retinanet.retinanet.build_retinanet"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.build_retinanet"], ["", "", "def", "build_rpn", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "\"\"\"\n    This gives the gist of it. Not super important because it doesn't change as much\n    \"\"\"", "\n", "if", "cfg", ".", "MODEL", ".", "RETINANET_ON", ":", "\n", "        ", "return", "build_retinanet", "(", "cfg", ",", "in_channels", ")", "\n", "\n", "", "return", "RPNModule", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.__init__": [[16, 20], ["torch.nn.Module.__init__", "anchor_generator.BufferList.extend"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend"], ["def", "__init__", "(", "self", ",", "buffers", "=", "None", ")", ":", "\n", "        ", "super", "(", "BufferList", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "buffers", "is", "not", "None", ":", "\n", "            ", "self", ".", "extend", "(", "buffers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend": [[21, 26], ["len", "enumerate", "anchor_generator.BufferList.register_buffer", "str"], "methods", ["None"], ["", "", "def", "extend", "(", "self", ",", "buffers", ")", ":", "\n", "        ", "offset", "=", "len", "(", "self", ")", "\n", "for", "i", ",", "buffer", "in", "enumerate", "(", "buffers", ")", ":", "\n", "            ", "self", ".", "register_buffer", "(", "str", "(", "offset", "+", "i", ")", ",", "buffer", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.__len__": [[27, 29], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_buffers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.__iter__": [[30, 32], ["iter", "anchor_generator.BufferList._buffers.values"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "_buffers", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.AnchorGenerator.__init__": [[40, 69], ["torch.nn.Module.__init__", "anchor_generator.BufferList", "len", "generate_anchors().float", "len", "len", "RuntimeError", "generate_anchors().float", "zip", "anchor_generator.generate_anchors", "anchor_generator.generate_anchors", "isinstance"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.generate_anchors", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.generate_anchors"], ["def", "__init__", "(", "\n", "self", ",", "\n", "sizes", "=", "(", "128", ",", "256", ",", "512", ")", ",", "\n", "aspect_ratios", "=", "(", "0.5", ",", "1.0", ",", "2.0", ")", ",", "\n", "anchor_strides", "=", "(", "8", ",", "16", ",", "32", ")", ",", "\n", "straddle_thresh", "=", "0", ",", "\n", ")", ":", "\n", "        ", "super", "(", "AnchorGenerator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "len", "(", "anchor_strides", ")", "==", "1", ":", "\n", "            ", "anchor_stride", "=", "anchor_strides", "[", "0", "]", "\n", "cell_anchors", "=", "[", "\n", "generate_anchors", "(", "anchor_stride", ",", "sizes", ",", "aspect_ratios", ")", ".", "float", "(", ")", "\n", "]", "\n", "", "else", ":", "\n", "            ", "if", "len", "(", "anchor_strides", ")", "!=", "len", "(", "sizes", ")", ":", "\n", "                ", "raise", "RuntimeError", "(", "\"FPN should have #anchor_strides == #sizes\"", ")", "\n", "\n", "", "cell_anchors", "=", "[", "\n", "generate_anchors", "(", "\n", "anchor_stride", ",", "\n", "size", "if", "isinstance", "(", "size", ",", "(", "tuple", ",", "list", ")", ")", "else", "(", "size", ",", ")", ",", "\n", "aspect_ratios", "\n", ")", ".", "float", "(", ")", "\n", "for", "anchor_stride", ",", "size", "in", "zip", "(", "anchor_strides", ",", "sizes", ")", "\n", "]", "\n", "", "self", ".", "strides", "=", "anchor_strides", "\n", "self", ".", "cell_anchors", "=", "BufferList", "(", "cell_anchors", ")", "\n", "self", ".", "straddle_thresh", "=", "straddle_thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.AnchorGenerator.num_anchors_per_location": [[70, 72], ["len"], "methods", ["None"], ["", "def", "num_anchors_per_location", "(", "self", ")", ":", "\n", "        ", "return", "[", "len", "(", "cell_anchors", ")", "for", "cell_anchors", "in", "self", ".", "cell_anchors", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.AnchorGenerator.grid_anchors": [[73, 96], ["zip", "torch.arange", "torch.arange", "torch.meshgrid", "shift_x.reshape.reshape.reshape", "shift_y.reshape.reshape.reshape", "torch.stack", "anchors.append", "torch.stack.view", "base_anchors.view"], "methods", ["None"], ["", "def", "grid_anchors", "(", "self", ",", "grid_sizes", ")", ":", "\n", "        ", "anchors", "=", "[", "]", "\n", "for", "size", ",", "stride", ",", "base_anchors", "in", "zip", "(", "\n", "grid_sizes", ",", "self", ".", "strides", ",", "self", ".", "cell_anchors", "\n", ")", ":", "\n", "            ", "grid_height", ",", "grid_width", "=", "size", "\n", "device", "=", "base_anchors", ".", "device", "\n", "shifts_x", "=", "torch", ".", "arange", "(", "\n", "0", ",", "grid_width", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shifts_y", "=", "torch", ".", "arange", "(", "\n", "0", ",", "grid_height", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shift_y", ",", "shift_x", "=", "torch", ".", "meshgrid", "(", "shifts_y", ",", "shifts_x", ")", "\n", "shift_x", "=", "shift_x", ".", "reshape", "(", "-", "1", ")", "\n", "shift_y", "=", "shift_y", ".", "reshape", "(", "-", "1", ")", "\n", "shifts", "=", "torch", ".", "stack", "(", "(", "shift_x", ",", "shift_y", ",", "shift_x", ",", "shift_y", ")", ",", "dim", "=", "1", ")", "\n", "\n", "anchors", ".", "append", "(", "\n", "(", "shifts", ".", "view", "(", "-", "1", ",", "1", ",", "4", ")", "+", "base_anchors", ".", "view", "(", "1", ",", "-", "1", ",", "4", ")", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", ")", "\n", "\n", "", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.AnchorGenerator.add_visibility_to": [[97, 111], ["boxlist.add_field", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["", "def", "add_visibility_to", "(", "self", ",", "boxlist", ")", ":", "\n", "        ", "image_width", ",", "image_height", "=", "boxlist", ".", "size", "\n", "anchors", "=", "boxlist", ".", "bbox", "\n", "if", "self", ".", "straddle_thresh", ">=", "0", ":", "\n", "            ", "inds_inside", "=", "(", "\n", "(", "anchors", "[", "...", ",", "0", "]", ">=", "-", "self", ".", "straddle_thresh", ")", "\n", "&", "(", "anchors", "[", "...", ",", "1", "]", ">=", "-", "self", ".", "straddle_thresh", ")", "\n", "&", "(", "anchors", "[", "...", ",", "2", "]", "<", "image_width", "+", "self", ".", "straddle_thresh", ")", "\n", "&", "(", "anchors", "[", "...", ",", "3", "]", "<", "image_height", "+", "self", ".", "straddle_thresh", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "device", "=", "anchors", ".", "device", "\n", "inds_inside", "=", "torch", ".", "ones", "(", "anchors", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "device", ")", "\n", "", "boxlist", ".", "add_field", "(", "\"visibility\"", ",", "inds_inside", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.AnchorGenerator.forward": [[112, 126], ["anchor_generator.AnchorGenerator.grid_anchors", "enumerate", "anchors.append", "vc_rcnn.structures.bounding_box.BoxList", "anchor_generator.AnchorGenerator.add_visibility_to", "anchors_in_image.append"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.AnchorGenerator.grid_anchors", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.AnchorGenerator.add_visibility_to"], ["", "def", "forward", "(", "self", ",", "image_list", ",", "feature_maps", ")", ":", "\n", "        ", "grid_sizes", "=", "[", "feature_map", ".", "shape", "[", "-", "2", ":", "]", "for", "feature_map", "in", "feature_maps", "]", "\n", "anchors_over_all_feature_maps", "=", "self", ".", "grid_anchors", "(", "grid_sizes", ")", "\n", "anchors", "=", "[", "]", "\n", "for", "i", ",", "(", "image_height", ",", "image_width", ")", "in", "enumerate", "(", "image_list", ".", "image_sizes", ")", ":", "\n", "            ", "anchors_in_image", "=", "[", "]", "\n", "for", "anchors_per_feature_map", "in", "anchors_over_all_feature_maps", ":", "\n", "                ", "boxlist", "=", "BoxList", "(", "\n", "anchors_per_feature_map", ",", "(", "image_width", ",", "image_height", ")", ",", "mode", "=", "\"xyxy\"", "\n", ")", "\n", "self", ".", "add_visibility_to", "(", "boxlist", ")", "\n", "anchors_in_image", ".", "append", "(", "boxlist", ")", "\n", "", "anchors", ".", "append", "(", "anchors_in_image", ")", "\n", "", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.make_anchor_generator": [[128, 144], ["anchor_generator.AnchorGenerator", "len", "len", "len"], "function", ["None"], ["", "", "def", "make_anchor_generator", "(", "config", ")", ":", "\n", "    ", "anchor_sizes", "=", "config", ".", "MODEL", ".", "RPN", ".", "ANCHOR_SIZES", "\n", "aspect_ratios", "=", "config", ".", "MODEL", ".", "RPN", ".", "ASPECT_RATIOS", "\n", "anchor_stride", "=", "config", ".", "MODEL", ".", "RPN", ".", "ANCHOR_STRIDE", "\n", "straddle_thresh", "=", "config", ".", "MODEL", ".", "RPN", ".", "STRADDLE_THRESH", "\n", "\n", "if", "config", ".", "MODEL", ".", "RPN", ".", "USE_FPN", ":", "\n", "        ", "assert", "len", "(", "anchor_stride", ")", "==", "len", "(", "\n", "anchor_sizes", "\n", ")", ",", "\"FPN should have len(ANCHOR_STRIDE) == len(ANCHOR_SIZES)\"", "\n", "", "else", ":", "\n", "        ", "assert", "len", "(", "anchor_stride", ")", "==", "1", ",", "\"Non-FPN should have a single ANCHOR_STRIDE\"", "\n", "", "anchor_generator", "=", "AnchorGenerator", "(", "\n", "anchor_sizes", ",", "aspect_ratios", ",", "anchor_stride", ",", "straddle_thresh", "\n", ")", "\n", "return", "anchor_generator", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.make_anchor_generator_retinanet": [[146, 167], ["anchor_generator.AnchorGenerator", "len", "len", "range", "new_anchor_sizes.append", "tuple", "per_layer_anchor_sizes.append", "tuple", "float"], "function", ["None"], ["", "def", "make_anchor_generator_retinanet", "(", "config", ")", ":", "\n", "    ", "anchor_sizes", "=", "config", ".", "MODEL", ".", "RETINANET", ".", "ANCHOR_SIZES", "\n", "aspect_ratios", "=", "config", ".", "MODEL", ".", "RETINANET", ".", "ASPECT_RATIOS", "\n", "anchor_strides", "=", "config", ".", "MODEL", ".", "RETINANET", ".", "ANCHOR_STRIDES", "\n", "straddle_thresh", "=", "config", ".", "MODEL", ".", "RETINANET", ".", "STRADDLE_THRESH", "\n", "octave", "=", "config", ".", "MODEL", ".", "RETINANET", ".", "OCTAVE", "\n", "scales_per_octave", "=", "config", ".", "MODEL", ".", "RETINANET", ".", "SCALES_PER_OCTAVE", "\n", "\n", "assert", "len", "(", "anchor_strides", ")", "==", "len", "(", "anchor_sizes", ")", ",", "\"Only support FPN now\"", "\n", "new_anchor_sizes", "=", "[", "]", "\n", "for", "size", "in", "anchor_sizes", ":", "\n", "        ", "per_layer_anchor_sizes", "=", "[", "]", "\n", "for", "scale_per_octave", "in", "range", "(", "scales_per_octave", ")", ":", "\n", "            ", "octave_scale", "=", "octave", "**", "(", "scale_per_octave", "/", "float", "(", "scales_per_octave", ")", ")", "\n", "per_layer_anchor_sizes", ".", "append", "(", "octave_scale", "*", "size", ")", "\n", "", "new_anchor_sizes", ".", "append", "(", "tuple", "(", "per_layer_anchor_sizes", ")", ")", "\n", "\n", "", "anchor_generator", "=", "AnchorGenerator", "(", "\n", "tuple", "(", "new_anchor_sizes", ")", ",", "aspect_ratios", ",", "anchor_strides", ",", "straddle_thresh", "\n", ")", "\n", "return", "anchor_generator", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.generate_anchors": [[220, 231], ["anchor_generator._generate_anchors", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._generate_anchors"], ["", "def", "generate_anchors", "(", "\n", "stride", "=", "16", ",", "sizes", "=", "(", "32", ",", "64", ",", "128", ",", "256", ",", "512", ")", ",", "aspect_ratios", "=", "(", "0.5", ",", "1", ",", "2", ")", "\n", ")", ":", "\n", "    ", "\"\"\"Generates a matrix of anchor boxes in (x1, y1, x2, y2) format. Anchors\n    are centered on stride / 2, have (approximate) sqrt areas of the specified\n    sizes, and aspect ratios as given.\n    \"\"\"", "\n", "return", "_generate_anchors", "(", "\n", "stride", ",", "\n", "np", ".", "array", "(", "sizes", ",", "dtype", "=", "np", ".", "float", ")", "/", "stride", ",", "\n", "np", ".", "array", "(", "aspect_ratios", ",", "dtype", "=", "np", ".", "float", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._generate_anchors": [[234, 244], ["anchor_generator._ratio_enum", "numpy.vstack", "torch.from_numpy", "numpy.array", "anchor_generator._scale_enum", "range"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._ratio_enum", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._scale_enum"], ["", "def", "_generate_anchors", "(", "base_size", ",", "scales", ",", "aspect_ratios", ")", ":", "\n", "    ", "\"\"\"Generate anchor (reference) windows by enumerating aspect ratios X\n    scales wrt a reference (0, 0, base_size - 1, base_size - 1) window.\n    \"\"\"", "\n", "anchor", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "base_size", ",", "base_size", "]", ",", "dtype", "=", "np", ".", "float", ")", "-", "1", "\n", "anchors", "=", "_ratio_enum", "(", "anchor", ",", "aspect_ratios", ")", "\n", "anchors", "=", "np", ".", "vstack", "(", "\n", "[", "_scale_enum", "(", "anchors", "[", "i", ",", ":", "]", ",", "scales", ")", "for", "i", "in", "range", "(", "anchors", ".", "shape", "[", "0", "]", ")", "]", "\n", ")", "\n", "return", "torch", ".", "from_numpy", "(", "anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._whctrs": [[246, 253], ["None"], "function", ["None"], ["", "def", "_whctrs", "(", "anchor", ")", ":", "\n", "    ", "\"\"\"Return width, height, x center, and y center for an anchor (window).\"\"\"", "\n", "w", "=", "anchor", "[", "2", "]", "-", "anchor", "[", "0", "]", "+", "1", "\n", "h", "=", "anchor", "[", "3", "]", "-", "anchor", "[", "1", "]", "+", "1", "\n", "x_ctr", "=", "anchor", "[", "0", "]", "+", "0.5", "*", "(", "w", "-", "1", ")", "\n", "y_ctr", "=", "anchor", "[", "1", "]", "+", "0.5", "*", "(", "h", "-", "1", ")", "\n", "return", "w", ",", "h", ",", "x_ctr", ",", "y_ctr", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._mkanchors": [[255, 270], ["numpy.hstack"], "function", ["None"], ["", "def", "_mkanchors", "(", "ws", ",", "hs", ",", "x_ctr", ",", "y_ctr", ")", ":", "\n", "    ", "\"\"\"Given a vector of widths (ws) and heights (hs) around a center\n    (x_ctr, y_ctr), output a set of anchors (windows).\n    \"\"\"", "\n", "ws", "=", "ws", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "hs", "=", "hs", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "anchors", "=", "np", ".", "hstack", "(", "\n", "(", "\n", "x_ctr", "-", "0.5", "*", "(", "ws", "-", "1", ")", ",", "\n", "y_ctr", "-", "0.5", "*", "(", "hs", "-", "1", ")", ",", "\n", "x_ctr", "+", "0.5", "*", "(", "ws", "-", "1", ")", ",", "\n", "y_ctr", "+", "0.5", "*", "(", "hs", "-", "1", ")", ",", "\n", ")", "\n", ")", "\n", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._ratio_enum": [[272, 281], ["anchor_generator._whctrs", "numpy.round", "numpy.round", "anchor_generator._mkanchors", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._whctrs", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._mkanchors"], ["", "def", "_ratio_enum", "(", "anchor", ",", "ratios", ")", ":", "\n", "    ", "\"\"\"Enumerate a set of anchors for each aspect ratio wrt an anchor.\"\"\"", "\n", "w", ",", "h", ",", "x_ctr", ",", "y_ctr", "=", "_whctrs", "(", "anchor", ")", "\n", "size", "=", "w", "*", "h", "\n", "size_ratios", "=", "size", "/", "ratios", "\n", "ws", "=", "np", ".", "round", "(", "np", ".", "sqrt", "(", "size_ratios", ")", ")", "\n", "hs", "=", "np", ".", "round", "(", "ws", "*", "ratios", ")", "\n", "anchors", "=", "_mkanchors", "(", "ws", ",", "hs", ",", "x_ctr", ",", "y_ctr", ")", "\n", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._scale_enum": [[283, 290], ["anchor_generator._whctrs", "anchor_generator._mkanchors"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._whctrs", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator._mkanchors"], ["", "def", "_scale_enum", "(", "anchor", ",", "scales", ")", ":", "\n", "    ", "\"\"\"Enumerate a set of anchors for each scale wrt an anchor.\"\"\"", "\n", "w", ",", "h", ",", "x_ctr", ",", "y_ctr", "=", "_whctrs", "(", "anchor", ")", "\n", "ws", "=", "w", "*", "scales", "\n", "hs", "=", "h", "*", "scales", "\n", "anchors", "=", "_mkanchors", "(", "ws", ",", "hs", ",", "x_ctr", ",", "y_ctr", ")", "\n", "return", "anchors", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.inference.RPNPostProcessor.__init__": [[19, 52], ["super().__init__", "vc_rcnn.modeling.box_coder.BoxCoder"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "pre_nms_top_n", ",", "\n", "post_nms_top_n", ",", "\n", "nms_thresh", ",", "\n", "min_size", ",", "\n", "box_coder", "=", "None", ",", "\n", "fpn_post_nms_top_n", "=", "None", ",", "\n", "fpn_post_nms_per_batch", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            pre_nms_top_n (int)\n            post_nms_top_n (int)\n            nms_thresh (float)\n            min_size (int)\n            box_coder (BoxCoder)\n            fpn_post_nms_top_n (int)\n        \"\"\"", "\n", "super", "(", "RPNPostProcessor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pre_nms_top_n", "=", "pre_nms_top_n", "\n", "self", ".", "post_nms_top_n", "=", "post_nms_top_n", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "self", ".", "min_size", "=", "min_size", "\n", "\n", "if", "box_coder", "is", "None", ":", "\n", "            ", "box_coder", "=", "BoxCoder", "(", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", "\n", "", "self", ".", "box_coder", "=", "box_coder", "\n", "\n", "if", "fpn_post_nms_top_n", "is", "None", ":", "\n", "            ", "fpn_post_nms_top_n", "=", "post_nms_top_n", "\n", "", "self", ".", "fpn_post_nms_top_n", "=", "fpn_post_nms_top_n", "\n", "self", ".", "fpn_post_nms_per_batch", "=", "fpn_post_nms_per_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.inference.RPNPostProcessor.add_gt_proposals": [[53, 75], ["target.copy_with_fields", "gt_box.add_field", "vc_rcnn.structures.boxlist_ops.cat_boxlist", "torch.ones", "zip", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.copy_with_fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.cat_boxlist"], ["", "def", "add_gt_proposals", "(", "self", ",", "proposals", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposals: list[BoxList]\n            targets: list[BoxList]\n        \"\"\"", "\n", "# Get the device we're operating on", "\n", "device", "=", "proposals", "[", "0", "]", ".", "bbox", ".", "device", "\n", "\n", "gt_boxes", "=", "[", "target", ".", "copy_with_fields", "(", "[", "]", ")", "for", "target", "in", "targets", "]", "\n", "\n", "# later cat of bbox requires all fields to be present for all bbox", "\n", "# so we need to add a dummy for objectness that's missing", "\n", "for", "gt_box", "in", "gt_boxes", ":", "\n", "            ", "gt_box", ".", "add_field", "(", "\"objectness\"", ",", "torch", ".", "ones", "(", "len", "(", "gt_box", ")", ",", "device", "=", "device", ")", ")", "\n", "\n", "", "proposals", "=", "[", "\n", "cat_boxlist", "(", "(", "proposal", ",", "gt_box", ")", ")", "\n", "for", "proposal", ",", "gt_box", "in", "zip", "(", "proposals", ",", "gt_boxes", ")", "\n", "]", "\n", "\n", "return", "proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.inference.RPNPostProcessor.forward_for_single_feature_map": [[76, 124], ["utils.permute_and_flatten().view", "objectness.sigmoid.sigmoid.sigmoid", "utils.permute_and_flatten", "min", "objectness.sigmoid.sigmoid.topk", "torch.cat", "inference.RPNPostProcessor.box_coder.decode", "proposals.view.view.view", "zip", "torch.arange", "torch.cat.reshape", "utils.permute_and_flatten.view", "torch.cat.view", "vc_rcnn.structures.bounding_box.BoxList", "vc_rcnn.structures.boxlist_ops.boxlist_nms.add_field", "vc_rcnn.structures.boxlist_ops.boxlist_nms.clip_to_image", "vc_rcnn.structures.boxlist_ops.remove_small_boxes", "vc_rcnn.structures.boxlist_ops.boxlist_nms", "result.append", "utils.permute_and_flatten"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.permute_and_flatten", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.clip_to_image", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.remove_small_boxes", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_nms", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.permute_and_flatten"], ["", "def", "forward_for_single_feature_map", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors: list[BoxList]\n            objectness: tensor of size N, A, H, W\n            box_regression: tensor of size N, A * 4, H, W\n        \"\"\"", "\n", "device", "=", "objectness", ".", "device", "\n", "N", ",", "A", ",", "H", ",", "W", "=", "objectness", ".", "shape", "\n", "\n", "# put in the same format as anchors", "\n", "objectness", "=", "permute_and_flatten", "(", "objectness", ",", "N", ",", "A", ",", "1", ",", "H", ",", "W", ")", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "objectness", "=", "objectness", ".", "sigmoid", "(", ")", "\n", "\n", "box_regression", "=", "permute_and_flatten", "(", "box_regression", ",", "N", ",", "A", ",", "4", ",", "H", ",", "W", ")", "\n", "\n", "num_anchors", "=", "A", "*", "H", "*", "W", "\n", "\n", "pre_nms_top_n", "=", "min", "(", "self", ".", "pre_nms_top_n", ",", "num_anchors", ")", "\n", "objectness", ",", "topk_idx", "=", "objectness", ".", "topk", "(", "pre_nms_top_n", ",", "dim", "=", "1", ",", "sorted", "=", "True", ")", "\n", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "N", ",", "device", "=", "device", ")", "[", ":", ",", "None", "]", "\n", "box_regression", "=", "box_regression", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "image_shapes", "=", "[", "box", ".", "size", "for", "box", "in", "anchors", "]", "\n", "concat_anchors", "=", "torch", ".", "cat", "(", "[", "a", ".", "bbox", "for", "a", "in", "anchors", "]", ",", "dim", "=", "0", ")", "\n", "concat_anchors", "=", "concat_anchors", ".", "reshape", "(", "N", ",", "-", "1", ",", "4", ")", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "proposals", "=", "self", ".", "box_coder", ".", "decode", "(", "\n", "box_regression", ".", "view", "(", "-", "1", ",", "4", ")", ",", "concat_anchors", ".", "view", "(", "-", "1", ",", "4", ")", "\n", ")", "\n", "\n", "proposals", "=", "proposals", ".", "view", "(", "N", ",", "-", "1", ",", "4", ")", "\n", "\n", "result", "=", "[", "]", "\n", "for", "proposal", ",", "score", ",", "im_shape", "in", "zip", "(", "proposals", ",", "objectness", ",", "image_shapes", ")", ":", "\n", "            ", "boxlist", "=", "BoxList", "(", "proposal", ",", "im_shape", ",", "mode", "=", "\"xyxy\"", ")", "\n", "boxlist", ".", "add_field", "(", "\"objectness\"", ",", "score", ")", "\n", "boxlist", "=", "boxlist", ".", "clip_to_image", "(", "remove_empty", "=", "False", ")", "\n", "boxlist", "=", "remove_small_boxes", "(", "boxlist", ",", "self", ".", "min_size", ")", "\n", "boxlist", "=", "boxlist_nms", "(", "\n", "boxlist", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "max_proposals", "=", "self", ".", "post_nms_top_n", ",", "\n", "score_field", "=", "\"objectness\"", ",", "\n", ")", "\n", "result", ".", "append", "(", "boxlist", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.inference.RPNPostProcessor.forward": [[125, 153], ["len", "list", "zip", "list", "zip", "sampled_boxes.append", "zip", "vc_rcnn.structures.boxlist_ops.cat_boxlist", "inference.RPNPostProcessor.select_over_all_levels", "inference.RPNPostProcessor.add_gt_proposals", "inference.RPNPostProcessor.forward_for_single_feature_map"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.cat_boxlist", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.inference.RetinaNetPostProcessor.select_over_all_levels", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.inference.RetinaNetPostProcessor.add_gt_proposals", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.inference.RetinaNetPostProcessor.forward_for_single_feature_map"], ["", "def", "forward", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors: list[list[BoxList]]\n            objectness: list[tensor]\n            box_regression: list[tensor]\n\n        Returns:\n            boxlists (list[BoxList]): the post-processed anchors, after\n                applying box decoding and NMS\n        \"\"\"", "\n", "sampled_boxes", "=", "[", "]", "\n", "num_levels", "=", "len", "(", "objectness", ")", "\n", "anchors", "=", "list", "(", "zip", "(", "*", "anchors", ")", ")", "\n", "for", "a", ",", "o", ",", "b", "in", "zip", "(", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "            ", "sampled_boxes", ".", "append", "(", "self", ".", "forward_for_single_feature_map", "(", "a", ",", "o", ",", "b", ")", ")", "\n", "\n", "", "boxlists", "=", "list", "(", "zip", "(", "*", "sampled_boxes", ")", ")", "\n", "boxlists", "=", "[", "cat_boxlist", "(", "boxlist", ")", "for", "boxlist", "in", "boxlists", "]", "\n", "\n", "if", "num_levels", ">", "1", ":", "\n", "            ", "boxlists", "=", "self", ".", "select_over_all_levels", "(", "boxlists", ")", "\n", "\n", "# append ground-truth bboxes to proposals", "\n", "", "if", "self", ".", "training", "and", "targets", "is", "not", "None", ":", "\n", "            ", "boxlists", "=", "self", ".", "add_gt_proposals", "(", "boxlists", ",", "targets", ")", "\n", "\n", "", "return", "boxlists", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.inference.RPNPostProcessor.select_over_all_levels": [[154, 182], ["len", "torch.cat", "min", "torch.topk", "torch.zeros_like", "inds_mask.split.split.split", "range", "range", "len", "len", "boxlists[].get_field", "min", "torch.topk", "boxlist.get_field", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "select_over_all_levels", "(", "self", ",", "boxlists", ")", ":", "\n", "        ", "num_images", "=", "len", "(", "boxlists", ")", "\n", "# different behavior during training and during testing:", "\n", "# during training, post_nms_top_n is over *all* the proposals combined, while", "\n", "# during testing, it is over the proposals for each image", "\n", "# NOTE: it should be per image, and not per batch. However, to be consistent ", "\n", "# with Detectron, the default is per batch (see Issue #672)", "\n", "if", "self", ".", "training", "and", "self", ".", "fpn_post_nms_per_batch", ":", "\n", "            ", "objectness", "=", "torch", ".", "cat", "(", "\n", "[", "boxlist", ".", "get_field", "(", "\"objectness\"", ")", "for", "boxlist", "in", "boxlists", "]", ",", "dim", "=", "0", "\n", ")", "\n", "box_sizes", "=", "[", "len", "(", "boxlist", ")", "for", "boxlist", "in", "boxlists", "]", "\n", "post_nms_top_n", "=", "min", "(", "self", ".", "fpn_post_nms_top_n", ",", "len", "(", "objectness", ")", ")", "\n", "_", ",", "inds_sorted", "=", "torch", ".", "topk", "(", "objectness", ",", "post_nms_top_n", ",", "dim", "=", "0", ",", "sorted", "=", "True", ")", "\n", "inds_mask", "=", "torch", ".", "zeros_like", "(", "objectness", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "inds_mask", "[", "inds_sorted", "]", "=", "1", "\n", "inds_mask", "=", "inds_mask", ".", "split", "(", "box_sizes", ")", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "                ", "boxlists", "[", "i", "]", "=", "boxlists", "[", "i", "]", "[", "inds_mask", "[", "i", "]", "]", "\n", "", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "                ", "objectness", "=", "boxlists", "[", "i", "]", ".", "get_field", "(", "\"objectness\"", ")", "\n", "post_nms_top_n", "=", "min", "(", "self", ".", "fpn_post_nms_top_n", ",", "len", "(", "objectness", ")", ")", "\n", "_", ",", "inds_sorted", "=", "torch", ".", "topk", "(", "\n", "objectness", ",", "post_nms_top_n", ",", "dim", "=", "0", ",", "sorted", "=", "True", "\n", ")", "\n", "boxlists", "[", "i", "]", "=", "boxlists", "[", "i", "]", "[", "inds_sorted", "]", "\n", "", "", "return", "boxlists", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.inference.make_rpn_postprocessor": [[184, 207], ["inference.RPNPostProcessor"], "function", ["None"], ["", "", "def", "make_rpn_postprocessor", "(", "config", ",", "rpn_box_coder", ",", "is_train", ")", ":", "\n", "    ", "fpn_post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_TOP_N_TRAIN", "\n", "if", "not", "is_train", ":", "\n", "        ", "fpn_post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_TOP_N_TEST", "\n", "\n", "", "pre_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOP_N_TRAIN", "\n", "post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOP_N_TRAIN", "\n", "if", "not", "is_train", ":", "\n", "        ", "pre_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOP_N_TEST", "\n", "post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOP_N_TEST", "\n", "", "fpn_post_nms_per_batch", "=", "config", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_PER_BATCH", "\n", "nms_thresh", "=", "config", ".", "MODEL", ".", "RPN", ".", "NMS_THRESH", "\n", "min_size", "=", "config", ".", "MODEL", ".", "RPN", ".", "MIN_SIZE", "\n", "box_selector", "=", "RPNPostProcessor", "(", "\n", "pre_nms_top_n", "=", "pre_nms_top_n", ",", "\n", "post_nms_top_n", "=", "post_nms_top_n", ",", "\n", "nms_thresh", "=", "nms_thresh", ",", "\n", "min_size", "=", "min_size", ",", "\n", "box_coder", "=", "rpn_box_coder", ",", "\n", "fpn_post_nms_top_n", "=", "fpn_post_nms_top_n", ",", "\n", "fpn_post_nms_per_batch", "=", "fpn_post_nms_per_batch", ",", "\n", ")", "\n", "return", "box_selector", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.loss.RPNLossComputation.__init__": [[26, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "proposal_matcher", ",", "fg_bg_sampler", ",", "box_coder", ",", "\n", "generate_labels_func", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposal_matcher (Matcher)\n            fg_bg_sampler (BalancedPositiveNegativeSampler)\n            box_coder (BoxCoder)\n        \"\"\"", "\n", "# self.target_preparator = target_preparator", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "fg_bg_sampler", "=", "fg_bg_sampler", "\n", "self", ".", "box_coder", "=", "box_coder", "\n", "self", ".", "copied_fields", "=", "[", "]", "\n", "self", ".", "generate_labels_func", "=", "generate_labels_func", "\n", "self", ".", "discard_cases", "=", "[", "'not_visibility'", ",", "'between_thresholds'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.loss.RPNLossComputation.match_targets_to_anchors": [[42, 55], ["vc_rcnn.structures.boxlist_ops.boxlist_iou", "loss.RPNLossComputation.proposal_matcher", "target.copy_with_fields.copy_with_fields.copy_with_fields", "matched_targets.add_field", "loss.RPNLossComputation.clamp"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_iou", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.copy_with_fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["", "def", "match_targets_to_anchors", "(", "self", ",", "anchor", ",", "target", ",", "copied_fields", "=", "[", "]", ")", ":", "\n", "        ", "match_quality_matrix", "=", "boxlist_iou", "(", "target", ",", "anchor", ")", "\n", "matched_idxs", "=", "self", ".", "proposal_matcher", "(", "match_quality_matrix", ")", "\n", "# RPN doesn't need any fields from target", "\n", "# for creating the labels, so clear them all", "\n", "target", "=", "target", ".", "copy_with_fields", "(", "copied_fields", ")", "\n", "# get the targets corresponding GT for each anchor", "\n", "# NB: need to clamp the indices because we can have a single", "\n", "# GT in the image, and matched_idxs can be -2, which goes", "\n", "# out of bounds", "\n", "matched_targets", "=", "target", "[", "matched_idxs", ".", "clamp", "(", "min", "=", "0", ")", "]", "\n", "matched_targets", ".", "add_field", "(", "\"matched_idxs\"", ",", "matched_idxs", ")", "\n", "return", "matched_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.loss.RPNLossComputation.prepare_targets": [[56, 90], ["zip", "loss.RPNLossComputation.match_targets_to_anchors", "loss.RPNLossComputation.get_field", "loss.RPNLossComputation.generate_labels_func", "labels_per_image.to.to.to", "loss.RPNLossComputation.box_coder.encode", "labels.append", "regression_targets.append", "anchors_per_image.get_field"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.loss.RPNLossComputation.match_targets_to_anchors", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "prepare_targets", "(", "self", ",", "anchors", ",", "targets", ")", ":", "\n", "        ", "labels", "=", "[", "]", "\n", "regression_targets", "=", "[", "]", "\n", "for", "anchors_per_image", ",", "targets_per_image", "in", "zip", "(", "anchors", ",", "targets", ")", ":", "\n", "            ", "matched_targets", "=", "self", ".", "match_targets_to_anchors", "(", "\n", "anchors_per_image", ",", "targets_per_image", ",", "self", ".", "copied_fields", "\n", ")", "\n", "\n", "matched_idxs", "=", "matched_targets", ".", "get_field", "(", "\"matched_idxs\"", ")", "\n", "labels_per_image", "=", "self", ".", "generate_labels_func", "(", "matched_targets", ")", "\n", "labels_per_image", "=", "labels_per_image", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# Background (negative examples)", "\n", "bg_indices", "=", "matched_idxs", "==", "Matcher", ".", "BELOW_LOW_THRESHOLD", "\n", "labels_per_image", "[", "bg_indices", "]", "=", "0", "\n", "\n", "# discard anchors that go out of the boundaries of the image", "\n", "if", "\"not_visibility\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "labels_per_image", "[", "~", "anchors_per_image", ".", "get_field", "(", "\"visibility\"", ")", "]", "=", "-", "1", "\n", "\n", "# discard indices that are between thresholds", "\n", "", "if", "\"between_thresholds\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "inds_to_discard", "=", "matched_idxs", "==", "Matcher", ".", "BETWEEN_THRESHOLDS", "\n", "labels_per_image", "[", "inds_to_discard", "]", "=", "-", "1", "\n", "\n", "# compute regression targets", "\n", "", "regression_targets_per_image", "=", "self", ".", "box_coder", ".", "encode", "(", "\n", "matched_targets", ".", "bbox", ",", "anchors_per_image", ".", "bbox", "\n", ")", "\n", "\n", "labels", ".", "append", "(", "labels_per_image", ")", "\n", "regression_targets", ".", "append", "(", "regression_targets_per_image", ")", "\n", "\n", "", "return", "labels", ",", "regression_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.loss.RPNLossComputation.__call__": [[92, 132], ["loss.RPNLossComputation.prepare_targets", "loss.RPNLossComputation.fg_bg_sampler", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.cat", "utils.concat_box_prediction_layers", "objectness.squeeze.squeeze.squeeze", "torch.cat", "torch.cat", "torch.nn.functional.binary_cross_entropy_with_logits", "vc_rcnn.structures.boxlist_ops.cat_boxlist", "vc_rcnn.layers.smooth_l1_loss", "torch.cat.numel", "torch.nonzero", "torch.nonzero", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.prepare_targets", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.concat_box_prediction_layers", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.cat_boxlist", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.smooth_l1_loss.smooth_l1_loss", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "__call__", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors (list[list[BoxList]])\n            objectness (list[Tensor])\n            box_regression (list[Tensor])\n            targets (list[BoxList])\n\n        Returns:\n            objectness_loss (Tensor)\n            box_loss (Tensor)\n        \"\"\"", "\n", "anchors", "=", "[", "cat_boxlist", "(", "anchors_per_image", ")", "for", "anchors_per_image", "in", "anchors", "]", "\n", "labels", ",", "regression_targets", "=", "self", ".", "prepare_targets", "(", "anchors", ",", "targets", ")", "\n", "sampled_pos_inds", ",", "sampled_neg_inds", "=", "self", ".", "fg_bg_sampler", "(", "labels", ")", "\n", "sampled_pos_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_pos_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "sampled_neg_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_neg_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "sampled_inds", "=", "torch", ".", "cat", "(", "[", "sampled_pos_inds", ",", "sampled_neg_inds", "]", ",", "dim", "=", "0", ")", "\n", "\n", "objectness", ",", "box_regression", "=", "concat_box_prediction_layers", "(", "objectness", ",", "box_regression", ")", "\n", "\n", "objectness", "=", "objectness", ".", "squeeze", "(", ")", "\n", "\n", "labels", "=", "torch", ".", "cat", "(", "labels", ",", "dim", "=", "0", ")", "\n", "regression_targets", "=", "torch", ".", "cat", "(", "regression_targets", ",", "dim", "=", "0", ")", "\n", "\n", "box_loss", "=", "smooth_l1_loss", "(", "\n", "box_regression", "[", "sampled_pos_inds", "]", ",", "\n", "regression_targets", "[", "sampled_pos_inds", "]", ",", "\n", "beta", "=", "1.0", "/", "9", ",", "\n", "size_average", "=", "False", ",", "\n", ")", "/", "(", "sampled_inds", ".", "numel", "(", ")", ")", "\n", "\n", "objectness_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "objectness", "[", "sampled_inds", "]", ",", "labels", "[", "sampled_inds", "]", "\n", ")", "\n", "\n", "return", "objectness_loss", ",", "box_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.loss.generate_rpn_labels": [[134, 138], ["matched_targets.get_field"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "", "def", "generate_rpn_labels", "(", "matched_targets", ")", ":", "\n", "    ", "matched_idxs", "=", "matched_targets", ".", "get_field", "(", "\"matched_idxs\"", ")", "\n", "labels_per_image", "=", "matched_idxs", ">=", "0", "\n", "return", "labels_per_image", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.loss.make_rpn_loss_evaluator": [[140, 158], ["vc_rcnn.modeling.matcher.Matcher", "balanced_positive_negative_sampler.BalancedPositiveNegativeSampler", "loss.RPNLossComputation"], "function", ["None"], ["", "def", "make_rpn_loss_evaluator", "(", "cfg", ",", "box_coder", ")", ":", "\n", "    ", "matcher", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "FG_IOU_THRESHOLD", ",", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BG_IOU_THRESHOLD", ",", "\n", "allow_low_quality_matches", "=", "True", ",", "\n", ")", "\n", "\n", "fg_bg_sampler", "=", "BalancedPositiveNegativeSampler", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BATCH_SIZE_PER_IMAGE", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "POSITIVE_FRACTION", "\n", ")", "\n", "\n", "loss_evaluator", "=", "RPNLossComputation", "(", "\n", "matcher", ",", "\n", "fg_bg_sampler", ",", "\n", "box_coder", ",", "\n", "generate_rpn_labels", "\n", ")", "\n", "return", "loss_evaluator", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.permute_and_flatten": [[10, 15], ["layer.reshape.view", "layer.reshape.permute", "layer.reshape.reshape"], "function", ["None"], ["    ", "\"\"\"\n    Efficient version of torch.cat that avoids a copy if there is only a single element in a list\n    \"\"\"", "\n", "assert", "isinstance", "(", "tensors", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "len", "(", "tensors", ")", "==", "1", ":", "\n", "        ", "return", "tensors", "[", "0", "]", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.concat_box_prediction_layers": [[17, 46], ["zip", "utils.cat().reshape", "utils.cat().reshape", "utils.permute_and_flatten", "box_cls_flattened.append", "utils.permute_and_flatten", "box_regression_flattened.append", "utils.cat", "utils.cat"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.permute_and_flatten", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.permute_and_flatten", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetHead.__init__": [[18, 78], ["super().__init__", "range", "retinanet.RetinaNetHead.add_module", "retinanet.RetinaNetHead.add_module", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "len", "cls_tower.append", "cls_tower.append", "bbox_tower.append", "bbox_tower.append", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "modules.modules", "math.log", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "isinstance", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            in_channels (int): number of channels of the input feature\n            num_anchors (int): number of anchors to be predicted\n        \"\"\"", "\n", "super", "(", "RetinaNetHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# TODO: Implement the sigmoid version first.", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NUM_CLASSES", "-", "1", "\n", "num_anchors", "=", "len", "(", "cfg", ".", "MODEL", ".", "RETINANET", ".", "ASPECT_RATIOS", ")", "*", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SCALES_PER_OCTAVE", "\n", "\n", "cls_tower", "=", "[", "]", "\n", "bbox_tower", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NUM_CONVS", ")", ":", "\n", "            ", "cls_tower", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "\n", "in_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", "\n", ")", "\n", ")", "\n", "cls_tower", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "bbox_tower", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "\n", "in_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", "\n", ")", "\n", ")", "\n", "bbox_tower", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "self", ".", "add_module", "(", "'cls_tower'", ",", "nn", ".", "Sequential", "(", "*", "cls_tower", ")", ")", "\n", "self", ".", "add_module", "(", "'bbox_tower'", ",", "nn", ".", "Sequential", "(", "*", "bbox_tower", ")", ")", "\n", "self", ".", "cls_logits", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "num_anchors", "*", "num_classes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "\n", "padding", "=", "1", "\n", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "num_anchors", "*", "4", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "\n", "padding", "=", "1", "\n", ")", "\n", "\n", "# Initialization", "\n", "for", "modules", "in", "[", "self", ".", "cls_tower", ",", "self", ".", "bbox_tower", ",", "self", ".", "cls_logits", ",", "\n", "self", ".", "bbox_pred", "]", ":", "\n", "            ", "for", "l", "in", "modules", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "l", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "l", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "\n", "# retinanet_bias_init", "\n", "", "", "", "prior_prob", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "PRIOR_PROB", "\n", "bias_value", "=", "-", "math", ".", "log", "(", "(", "1", "-", "prior_prob", ")", "/", "prior_prob", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "self", ".", "cls_logits", ".", "bias", ",", "bias_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetHead.forward": [[79, 86], ["logits.append", "bbox_reg.append", "retinanet.RetinaNetHead.cls_logits", "retinanet.RetinaNetHead.bbox_pred", "retinanet.RetinaNetHead.cls_tower", "retinanet.RetinaNetHead.bbox_tower"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "logits", "=", "[", "]", "\n", "bbox_reg", "=", "[", "]", "\n", "for", "feature", "in", "x", ":", "\n", "            ", "logits", ".", "append", "(", "self", ".", "cls_logits", "(", "self", ".", "cls_tower", "(", "feature", ")", ")", ")", "\n", "bbox_reg", ".", "append", "(", "self", ".", "bbox_pred", "(", "self", ".", "bbox_tower", "(", "feature", ")", ")", ")", "\n", "", "return", "logits", ",", "bbox_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetModule.__init__": [[94, 111], ["super().__init__", "cfg.clone", "anchor_generator.make_anchor_generator_retinanet.make_anchor_generator_retinanet", "retinanet.RetinaNetHead", "vc_rcnn.modeling.box_coder.BoxCoder", "inference.make_retinanet_postprocessor", "loss.make_retinanet_loss_evaluator"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.make_anchor_generator_retinanet", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.inference.make_retinanet_postprocessor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.loss.make_retinanet_loss_evaluator"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "RetinaNetModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "\n", "anchor_generator", "=", "make_anchor_generator_retinanet", "(", "cfg", ")", "\n", "head", "=", "RetinaNetHead", "(", "cfg", ",", "in_channels", ")", "\n", "box_coder", "=", "BoxCoder", "(", "weights", "=", "(", "10.", ",", "10.", ",", "5.", ",", "5.", ")", ")", "\n", "\n", "box_selector_test", "=", "make_retinanet_postprocessor", "(", "cfg", ",", "box_coder", ",", "is_train", "=", "False", ")", "\n", "\n", "loss_evaluator", "=", "make_retinanet_loss_evaluator", "(", "cfg", ",", "box_coder", ")", "\n", "\n", "self", ".", "anchor_generator", "=", "anchor_generator", "\n", "self", ".", "head", "=", "head", "\n", "self", ".", "box_selector_test", "=", "box_selector_test", "\n", "self", ".", "loss_evaluator", "=", "loss_evaluator", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetModule.forward": [[112, 134], ["retinanet.RetinaNetModule.head", "retinanet.RetinaNetModule.anchor_generator", "retinanet.RetinaNetModule._forward_train", "retinanet.RetinaNetModule._forward_test"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetModule._forward_train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetModule._forward_test"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            images (ImageList): images for which we want to compute the predictions\n            features (list[Tensor]): features computed from the images that are\n                used for computing the predictions. Each tensor in the list\n                correspond to different feature levels\n            targets (list[BoxList): ground-truth boxes present in the image (optional)\n\n        Returns:\n            boxes (list[BoxList]): the predicted boxes from the RPN, one BoxList per\n                image.\n            losses (dict[Tensor]): the losses for the model during training. During\n                testing, it is an empty dict.\n        \"\"\"", "\n", "box_cls", ",", "box_regression", "=", "self", ".", "head", "(", "features", ")", "\n", "anchors", "=", "self", ".", "anchor_generator", "(", "images", ",", "features", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "self", ".", "_forward_train", "(", "anchors", ",", "box_cls", ",", "box_regression", ",", "targets", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_forward_test", "(", "anchors", ",", "box_cls", ",", "box_regression", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetModule._forward_train": [[135, 145], ["retinanet.RetinaNetModule.loss_evaluator"], "methods", ["None"], ["", "", "def", "_forward_train", "(", "self", ",", "anchors", ",", "box_cls", ",", "box_regression", ",", "targets", ")", ":", "\n", "\n", "        ", "loss_box_cls", ",", "loss_box_reg", "=", "self", ".", "loss_evaluator", "(", "\n", "anchors", ",", "box_cls", ",", "box_regression", ",", "targets", "\n", ")", "\n", "losses", "=", "{", "\n", "\"loss_retina_cls\"", ":", "loss_box_cls", ",", "\n", "\"loss_retina_reg\"", ":", "loss_box_reg", ",", "\n", "}", "\n", "return", "anchors", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.RetinaNetModule._forward_test": [[146, 149], ["retinanet.RetinaNetModule.box_selector_test"], "methods", ["None"], ["", "def", "_forward_test", "(", "self", ",", "anchors", ",", "box_cls", ",", "box_regression", ")", ":", "\n", "        ", "boxes", "=", "self", ".", "box_selector_test", "(", "anchors", ",", "box_cls", ",", "box_regression", ")", "\n", "return", "boxes", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.retinanet.build_retinanet": [[151, 153], ["retinanet.RetinaNetModule"], "function", ["None"], ["", "", "def", "build_retinanet", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "return", "RetinaNetModule", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.inference.RetinaNetPostProcessor.__init__": [[19, 52], ["inference.RPNPostProcessor.__init__", "vc_rcnn.modeling.box_coder.BoxCoder"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "pre_nms_top_n", ",", "\n", "post_nms_top_n", ",", "\n", "nms_thresh", ",", "\n", "min_size", ",", "\n", "box_coder", "=", "None", ",", "\n", "fpn_post_nms_top_n", "=", "None", ",", "\n", "fpn_post_nms_per_batch", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            pre_nms_top_n (int)\n            post_nms_top_n (int)\n            nms_thresh (float)\n            min_size (int)\n            box_coder (BoxCoder)\n            fpn_post_nms_top_n (int)\n        \"\"\"", "\n", "super", "(", "RPNPostProcessor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pre_nms_top_n", "=", "pre_nms_top_n", "\n", "self", ".", "post_nms_top_n", "=", "post_nms_top_n", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "self", ".", "min_size", "=", "min_size", "\n", "\n", "if", "box_coder", "is", "None", ":", "\n", "            ", "box_coder", "=", "BoxCoder", "(", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", "\n", "", "self", ".", "box_coder", "=", "box_coder", "\n", "\n", "if", "fpn_post_nms_top_n", "is", "None", ":", "\n", "            ", "fpn_post_nms_top_n", "=", "post_nms_top_n", "\n", "", "self", ".", "fpn_post_nms_top_n", "=", "fpn_post_nms_top_n", "\n", "self", ".", "fpn_post_nms_per_batch", "=", "fpn_post_nms_per_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.inference.RetinaNetPostProcessor.add_gt_proposals": [[53, 58], ["None"], "methods", ["None"], ["", "def", "add_gt_proposals", "(", "self", ",", "proposals", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposals: list[BoxList]\n            targets: list[BoxList]\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.inference.RetinaNetPostProcessor.forward_for_single_feature_map": [[59, 125], ["utils.permute_and_flatten", "box_cls.sigmoid.sigmoid.sigmoid", "utils.permute_and_flatten", "candidate_inds.view().sum", "pre_nms_top_n.clamp.clamp.clamp", "zip", "utils.permute_and_flatten.size", "box_cls.sigmoid.sigmoid.size", "per_box_cls.topk", "inference.RetinaNetPostProcessor.box_coder.decode", "vc_rcnn.structures.bounding_box.BoxList", "vc_rcnn.structures.boxlist_ops.remove_small_boxes.add_field", "vc_rcnn.structures.boxlist_ops.remove_small_boxes.add_field", "vc_rcnn.structures.boxlist_ops.remove_small_boxes.clip_to_image", "vc_rcnn.structures.boxlist_ops.remove_small_boxes", "results.append", "candidate_inds.view", "per_candidate_inds.nonzero", "per_box_regression[].view", "per_anchors.bbox[].view"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.permute_and_flatten", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.permute_and_flatten", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.clip_to_image", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.remove_small_boxes"], ["# Get the device we're operating on", "\n", "device", "=", "proposals", "[", "0", "]", ".", "bbox", ".", "device", "\n", "\n", "gt_boxes", "=", "[", "target", ".", "copy_with_fields", "(", "[", "]", ")", "for", "target", "in", "targets", "]", "\n", "\n", "# later cat of bbox requires all fields to be present for all bbox", "\n", "# so we need to add a dummy for objectness that's missing", "\n", "for", "gt_box", "in", "gt_boxes", ":", "\n", "            ", "gt_box", ".", "add_field", "(", "\"objectness\"", ",", "torch", ".", "ones", "(", "len", "(", "gt_box", ")", ",", "device", "=", "device", ")", ")", "\n", "\n", "", "proposals", "=", "[", "\n", "cat_boxlist", "(", "(", "proposal", ",", "gt_box", ")", ")", "\n", "for", "proposal", ",", "gt_box", "in", "zip", "(", "proposals", ",", "gt_boxes", ")", "\n", "]", "\n", "\n", "return", "proposals", "\n", "\n", "", "def", "forward_for_single_feature_map", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors: list[BoxList]\n            objectness: tensor of size N, A, H, W\n            box_regression: tensor of size N, A * 4, H, W\n        \"\"\"", "\n", "device", "=", "objectness", ".", "device", "\n", "N", ",", "A", ",", "H", ",", "W", "=", "objectness", ".", "shape", "\n", "\n", "# put in the same format as anchors", "\n", "objectness", "=", "permute_and_flatten", "(", "objectness", ",", "N", ",", "A", ",", "1", ",", "H", ",", "W", ")", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "objectness", "=", "objectness", ".", "sigmoid", "(", ")", "\n", "\n", "box_regression", "=", "permute_and_flatten", "(", "box_regression", ",", "N", ",", "A", ",", "4", ",", "H", ",", "W", ")", "\n", "\n", "num_anchors", "=", "A", "*", "H", "*", "W", "\n", "\n", "pre_nms_top_n", "=", "min", "(", "self", ".", "pre_nms_top_n", ",", "num_anchors", ")", "\n", "objectness", ",", "topk_idx", "=", "objectness", ".", "topk", "(", "pre_nms_top_n", ",", "dim", "=", "1", ",", "sorted", "=", "True", ")", "\n", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "N", ",", "device", "=", "device", ")", "[", ":", ",", "None", "]", "\n", "box_regression", "=", "box_regression", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "image_shapes", "=", "[", "box", ".", "size", "for", "box", "in", "anchors", "]", "\n", "concat_anchors", "=", "torch", ".", "cat", "(", "[", "a", ".", "bbox", "for", "a", "in", "anchors", "]", ",", "dim", "=", "0", ")", "\n", "concat_anchors", "=", "concat_anchors", ".", "reshape", "(", "N", ",", "-", "1", ",", "4", ")", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "proposals", "=", "self", ".", "box_coder", ".", "decode", "(", "\n", "box_regression", ".", "view", "(", "-", "1", ",", "4", ")", ",", "concat_anchors", ".", "view", "(", "-", "1", ",", "4", ")", "\n", ")", "\n", "\n", "proposals", "=", "proposals", ".", "view", "(", "N", ",", "-", "1", ",", "4", ")", "\n", "\n", "result", "=", "[", "]", "\n", "for", "proposal", ",", "score", ",", "im_shape", "in", "zip", "(", "proposals", ",", "objectness", ",", "image_shapes", ")", ":", "\n", "            ", "boxlist", "=", "BoxList", "(", "proposal", ",", "im_shape", ",", "mode", "=", "\"xyxy\"", ")", "\n", "boxlist", ".", "add_field", "(", "\"objectness\"", ",", "score", ")", "\n", "boxlist", "=", "boxlist", ".", "clip_to_image", "(", "remove_empty", "=", "False", ")", "\n", "boxlist", "=", "remove_small_boxes", "(", "boxlist", ",", "self", ".", "min_size", ")", "\n", "boxlist", "=", "boxlist_nms", "(", "\n", "boxlist", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "max_proposals", "=", "self", ".", "post_nms_top_n", ",", "\n", "score_field", "=", "\"objectness\"", ",", "\n", ")", "\n", "result", ".", "append", "(", "boxlist", ")", "\n", "", "return", "result", "\n", "\n", "", "def", "forward", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.inference.RetinaNetPostProcessor.select_over_all_levels": [[130, 174], ["len", "range", "boxlists[].get_field", "boxlists[].get_field", "range", "vc_rcnn.structures.boxlist_ops.cat_boxlist", "len", "results.append", "boxes[].view", "vc_rcnn.structures.bounding_box.BoxList", "vc_rcnn.structures.boxlist_ops.boxlist_nms.add_field", "vc_rcnn.structures.boxlist_ops.boxlist_nms", "len", "vc_rcnn.structures.boxlist_ops.boxlist_nms.add_field", "vc_rcnn.structures.boxlist_ops.cat_boxlist.append", "vc_rcnn.structures.boxlist_ops.cat_boxlist.get_field", "torch.kthvalue", "torch.nonzero().squeeze", "torch.full", "vc_rcnn.structures.boxlist_ops.cat_boxlist.get_field.cpu", "image_thresh.item", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.cat_boxlist", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_nms", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["\n", "sampled_boxes", "=", "[", "]", "\n", "num_levels", "=", "len", "(", "objectness", ")", "\n", "anchors", "=", "list", "(", "zip", "(", "*", "anchors", ")", ")", "\n", "for", "a", ",", "o", ",", "b", "in", "zip", "(", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "            ", "sampled_boxes", ".", "append", "(", "self", ".", "forward_for_single_feature_map", "(", "a", ",", "o", ",", "b", ")", ")", "\n", "\n", "", "boxlists", "=", "list", "(", "zip", "(", "*", "sampled_boxes", ")", ")", "\n", "boxlists", "=", "[", "cat_boxlist", "(", "boxlist", ")", "for", "boxlist", "in", "boxlists", "]", "\n", "\n", "if", "num_levels", ">", "1", ":", "\n", "            ", "boxlists", "=", "self", ".", "select_over_all_levels", "(", "boxlists", ")", "\n", "\n", "# append ground-truth bboxes to proposals", "\n", "", "if", "self", ".", "training", "and", "targets", "is", "not", "None", ":", "\n", "            ", "boxlists", "=", "self", ".", "add_gt_proposals", "(", "boxlists", ",", "targets", ")", "\n", "\n", "", "return", "boxlists", "\n", "\n", "", "def", "select_over_all_levels", "(", "self", ",", "boxlists", ")", ":", "\n", "        ", "num_images", "=", "len", "(", "boxlists", ")", "\n", "# different behavior during training and during testing:", "\n", "# during training, post_nms_top_n is over *all* the proposals combined, while", "\n", "# during testing, it is over the proposals for each image", "\n", "# NOTE: it should be per image, and not per batch. However, to be consistent ", "\n", "# with Detectron, the default is per batch (see Issue #672)", "\n", "if", "self", ".", "training", "and", "self", ".", "fpn_post_nms_per_batch", ":", "\n", "            ", "objectness", "=", "torch", ".", "cat", "(", "\n", "[", "boxlist", ".", "get_field", "(", "\"objectness\"", ")", "for", "boxlist", "in", "boxlists", "]", ",", "dim", "=", "0", "\n", ")", "\n", "box_sizes", "=", "[", "len", "(", "boxlist", ")", "for", "boxlist", "in", "boxlists", "]", "\n", "post_nms_top_n", "=", "min", "(", "self", ".", "fpn_post_nms_top_n", ",", "len", "(", "objectness", ")", ")", "\n", "_", ",", "inds_sorted", "=", "torch", ".", "topk", "(", "objectness", ",", "post_nms_top_n", ",", "dim", "=", "0", ",", "sorted", "=", "True", ")", "\n", "inds_mask", "=", "torch", ".", "zeros_like", "(", "objectness", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "inds_mask", "[", "inds_sorted", "]", "=", "1", "\n", "inds_mask", "=", "inds_mask", ".", "split", "(", "box_sizes", ")", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "                ", "boxlists", "[", "i", "]", "=", "boxlists", "[", "i", "]", "[", "inds_mask", "[", "i", "]", "]", "\n", "", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.inference.make_retinanet_postprocessor": [[176, 194], ["inference.RetinaNetPostProcessor"], "function", ["None"], ["post_nms_top_n", "=", "min", "(", "self", ".", "fpn_post_nms_top_n", ",", "len", "(", "objectness", ")", ")", "\n", "_", ",", "inds_sorted", "=", "torch", ".", "topk", "(", "\n", "objectness", ",", "post_nms_top_n", ",", "dim", "=", "0", ",", "sorted", "=", "True", "\n", ")", "\n", "boxlists", "[", "i", "]", "=", "boxlists", "[", "i", "]", "[", "inds_sorted", "]", "\n", "", "", "return", "boxlists", "\n", "\n", "\n", "", "", "def", "make_rpn_postprocessor", "(", "config", ",", "rpn_box_coder", ",", "is_train", ")", ":", "\n", "    ", "fpn_post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_TOP_N_TRAIN", "\n", "if", "not", "is_train", ":", "\n", "        ", "fpn_post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_TOP_N_TEST", "\n", "\n", "", "pre_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOP_N_TRAIN", "\n", "post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOP_N_TRAIN", "\n", "if", "not", "is_train", ":", "\n", "        ", "pre_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOP_N_TEST", "\n", "post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOP_N_TEST", "\n", "", "fpn_post_nms_per_batch", "=", "config", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_PER_BATCH", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.loss.RetinaNetLossComputation.__init__": [[24, 42], ["None"], "methods", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "proposal_matcher", ",", "fg_bg_sampler", ",", "box_coder", ",", "\n", "generate_labels_func", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposal_matcher (Matcher)\n            fg_bg_sampler (BalancedPositiveNegativeSampler)\n            box_coder (BoxCoder)\n        \"\"\"", "\n", "# self.target_preparator = target_preparator", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "fg_bg_sampler", "=", "fg_bg_sampler", "\n", "self", ".", "box_coder", "=", "box_coder", "\n", "self", ".", "copied_fields", "=", "[", "]", "\n", "self", ".", "generate_labels_func", "=", "generate_labels_func", "\n", "self", ".", "discard_cases", "=", "[", "'not_visibility'", ",", "'between_thresholds'", "]", "\n", "\n", "", "def", "match_targets_to_anchors", "(", "self", ",", "anchor", ",", "target", ",", "copied_fields", "=", "[", "]", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.loss.RetinaNetLossComputation.__call__": [[43, 81], ["loss.RetinaNetLossComputation.prepare_targets", "len", "utils.concat_box_prediction_layers", "torch.cat", "torch.cat", "torch.nonzero().squeeze", "labels.int.int.int", "vc_rcnn.structures.boxlist_ops.cat_boxlist", "vc_rcnn.layers.smooth_l1_loss", "max", "loss.RetinaNetLossComputation.box_cls_loss_func", "torch.nonzero", "torch.nonzero().squeeze.numel", "torch.nonzero().squeeze.numel"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.prepare_targets", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.utils.concat_box_prediction_layers", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.cat_boxlist", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.smooth_l1_loss.smooth_l1_loss"], ["        ", "match_quality_matrix", "=", "boxlist_iou", "(", "target", ",", "anchor", ")", "\n", "matched_idxs", "=", "self", ".", "proposal_matcher", "(", "match_quality_matrix", ")", "\n", "# RPN doesn't need any fields from target", "\n", "# for creating the labels, so clear them all", "\n", "target", "=", "target", ".", "copy_with_fields", "(", "copied_fields", ")", "\n", "# get the targets corresponding GT for each anchor", "\n", "# NB: need to clamp the indices because we can have a single", "\n", "# GT in the image, and matched_idxs can be -2, which goes", "\n", "# out of bounds", "\n", "matched_targets", "=", "target", "[", "matched_idxs", ".", "clamp", "(", "min", "=", "0", ")", "]", "\n", "matched_targets", ".", "add_field", "(", "\"matched_idxs\"", ",", "matched_idxs", ")", "\n", "return", "matched_targets", "\n", "\n", "", "def", "prepare_targets", "(", "self", ",", "anchors", ",", "targets", ")", ":", "\n", "        ", "labels", "=", "[", "]", "\n", "regression_targets", "=", "[", "]", "\n", "for", "anchors_per_image", ",", "targets_per_image", "in", "zip", "(", "anchors", ",", "targets", ")", ":", "\n", "            ", "matched_targets", "=", "self", ".", "match_targets_to_anchors", "(", "\n", "anchors_per_image", ",", "targets_per_image", ",", "self", ".", "copied_fields", "\n", ")", "\n", "\n", "matched_idxs", "=", "matched_targets", ".", "get_field", "(", "\"matched_idxs\"", ")", "\n", "labels_per_image", "=", "self", ".", "generate_labels_func", "(", "matched_targets", ")", "\n", "labels_per_image", "=", "labels_per_image", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# Background (negative examples)", "\n", "bg_indices", "=", "matched_idxs", "==", "Matcher", ".", "BELOW_LOW_THRESHOLD", "\n", "labels_per_image", "[", "bg_indices", "]", "=", "0", "\n", "\n", "# discard anchors that go out of the boundaries of the image", "\n", "if", "\"not_visibility\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "labels_per_image", "[", "~", "anchors_per_image", ".", "get_field", "(", "\"visibility\"", ")", "]", "=", "-", "1", "\n", "\n", "# discard indices that are between thresholds", "\n", "", "if", "\"between_thresholds\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "inds_to_discard", "=", "matched_idxs", "==", "Matcher", ".", "BETWEEN_THRESHOLDS", "\n", "labels_per_image", "[", "inds_to_discard", "]", "=", "-", "1", "\n", "\n", "# compute regression targets", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.loss.generate_retinanet_labels": [[83, 86], ["matched_targets.get_field"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["matched_targets", ".", "bbox", ",", "anchors_per_image", ".", "bbox", "\n", ")", "\n", "\n", "labels", ".", "append", "(", "labels_per_image", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.retinanet.loss.make_retinanet_loss_evaluator": [[88, 108], ["vc_rcnn.modeling.matcher.Matcher", "vc_rcnn.layers.SigmoidFocalLoss", "loss.RetinaNetLossComputation"], "function", ["None"], ["\n", "", "return", "labels", ",", "regression_targets", "\n", "\n", "\n", "", "def", "__call__", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors (list[list[BoxList]])\n            objectness (list[Tensor])\n            box_regression (list[Tensor])\n            targets (list[BoxList])\n\n        Returns:\n            objectness_loss (Tensor)\n            box_loss (Tensor)\n        \"\"\"", "\n", "anchors", "=", "[", "cat_boxlist", "(", "anchors_per_image", ")", "for", "anchors_per_image", "in", "anchors", "]", "\n", "labels", ",", "regression_targets", "=", "self", ".", "prepare_targets", "(", "anchors", ",", "targets", ")", "\n", "sampled_pos_inds", ",", "sampled_neg_inds", "=", "self", ".", "fg_bg_sampler", "(", "labels", ")", "\n", "sampled_pos_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_pos_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "sampled_neg_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_neg_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.roi_heads.roi_heads.CombinedROIHeads.__init__": [[15, 22], ["super().__init__", "cfg.clone"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "heads", ")", ":", "\n", "        ", "super", "(", "CombinedROIHeads", ",", "self", ")", ".", "__init__", "(", "heads", ")", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "if", "cfg", ".", "MODEL", ".", "MASK_ON", "and", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "SHARE_BOX_FEATURE_EXTRACTOR", ":", "\n", "            ", "self", ".", "mask", ".", "feature_extractor", "=", "self", ".", "box", ".", "feature_extractor", "\n", "", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", "and", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "SHARE_BOX_FEATURE_EXTRACTOR", ":", "\n", "            ", "self", ".", "keypoint", ".", "feature_extractor", "=", "self", ".", "box", ".", "feature_extractor", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.roi_heads.roi_heads.CombinedROIHeads.forward": [[23, 56], ["roi_heads.CombinedROIHeads.box", "losses.update", "roi_heads.CombinedROIHeads.mask", "losses.update", "roi_heads.CombinedROIHeads.keypoint", "losses.update"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update"], ["", "", "def", "forward", "(", "self", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "losses", "=", "{", "}", "\n", "# TODO rename x to roi_box_features, if it doesn't increase memory consumption", "\n", "x", ",", "detections", ",", "loss_box", "=", "self", ".", "box", "(", "features", ",", "proposals", ",", "targets", ")", "\n", "losses", ".", "update", "(", "loss_box", ")", "\n", "if", "self", ".", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "            ", "mask_features", "=", "features", "\n", "# optimization: during training, if we share the feature extractor between", "\n", "# the box and the mask heads, then we can reuse the features already computed", "\n", "if", "(", "\n", "self", ".", "training", "\n", "and", "self", ".", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "SHARE_BOX_FEATURE_EXTRACTOR", "\n", ")", ":", "\n", "                ", "mask_features", "=", "x", "\n", "# During training, self.box() will return the unaltered proposals as \"detections\"", "\n", "# this makes the API consistent during training and testing", "\n", "", "x", ",", "detections", ",", "loss_mask", "=", "self", ".", "mask", "(", "mask_features", ",", "detections", ",", "targets", ")", "\n", "losses", ".", "update", "(", "loss_mask", ")", "\n", "\n", "", "if", "self", ".", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "keypoint_features", "=", "features", "\n", "# optimization: during training, if we share the feature extractor between", "\n", "# the box and the mask heads, then we can reuse the features already computed", "\n", "if", "(", "\n", "self", ".", "training", "\n", "and", "self", ".", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "SHARE_BOX_FEATURE_EXTRACTOR", "\n", ")", ":", "\n", "                ", "keypoint_features", "=", "x", "\n", "# During training, self.box() will return the unaltered proposals as \"detections\"", "\n", "# this makes the API consistent during training and testing", "\n", "", "x", ",", "detections", ",", "loss_keypoint", "=", "self", ".", "keypoint", "(", "keypoint_features", ",", "detections", ",", "targets", ")", "\n", "losses", ".", "update", "(", "loss_keypoint", ")", "\n", "", "return", "x", ",", "detections", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.roi_heads.roi_heads.build_roi_heads": [[58, 77], ["CombinedROIHeads.append", "CombinedROIHeads.append", "CombinedROIHeads.append", "roi_heads.CombinedROIHeads", "box_head.box_head.build_roi_box_head", "mask_head.mask_head.build_roi_mask_head", "keypoint_head.keypoint_head.build_roi_keypoint_head"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.box_head.build_roi_box_head", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.mask_head.build_roi_mask_head", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.keypoint_head.build_roi_keypoint_head"], ["", "", "def", "build_roi_heads", "(", "cfg", ",", "in_channels", ")", ":", "\n", "# individually create the heads, that will be combined together", "\n", "# afterwards", "\n", "    ", "roi_heads", "=", "[", "]", "\n", "if", "cfg", ".", "MODEL", ".", "RETINANET_ON", ":", "\n", "        ", "return", "[", "]", "\n", "\n", "", "if", "not", "cfg", ".", "MODEL", ".", "RPN_ONLY", ":", "\n", "        ", "roi_heads", ".", "append", "(", "(", "\"box\"", ",", "build_roi_box_head", "(", "cfg", ",", "in_channels", ")", ")", ")", "\n", "", "if", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "        ", "roi_heads", ".", "append", "(", "(", "\"mask\"", ",", "build_roi_mask_head", "(", "cfg", ",", "in_channels", ")", ")", ")", "\n", "", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "        ", "roi_heads", ".", "append", "(", "(", "\"keypoint\"", ",", "build_roi_keypoint_head", "(", "cfg", ",", "in_channels", ")", ")", ")", "\n", "\n", "# combine individual heads in a single module", "\n", "", "if", "roi_heads", ":", "\n", "        ", "roi_heads", "=", "CombinedROIHeads", "(", "cfg", ",", "roi_heads", ")", "\n", "\n", "", "return", "roi_heads", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.mask_head.ROIMaskHead.__init__": [[37, 45], ["super().__init__", "cfg.clone", "roi_mask_feature_extractors.make_roi_mask_feature_extractor", "roi_mask_predictors.make_roi_mask_predictor", "inference.make_roi_mask_post_processor", "loss.make_roi_mask_loss_evaluator"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_feature_extractors.make_roi_mask_feature_extractor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_predictors.make_roi_mask_predictor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.make_roi_mask_post_processor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.loss.make_roi_mask_loss_evaluator"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "ROIMaskHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "self", ".", "feature_extractor", "=", "make_roi_mask_feature_extractor", "(", "cfg", ",", "in_channels", ")", "\n", "self", ".", "predictor", "=", "make_roi_mask_predictor", "(", "\n", "cfg", ",", "self", ".", "feature_extractor", ".", "out_channels", ")", "\n", "self", ".", "post_processor", "=", "make_roi_mask_post_processor", "(", "cfg", ")", "\n", "self", ".", "loss_evaluator", "=", "make_roi_mask_loss_evaluator", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.mask_head.ROIMaskHead.forward": [[46, 80], ["mask_head.ROIMaskHead.predictor", "mask_head.ROIMaskHead.loss_evaluator", "mask_head.keep_only_positive_boxes", "mask_head.ROIMaskHead.feature_extractor", "mask_head.ROIMaskHead.post_processor", "dict", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.mask_head.keep_only_positive_boxes", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            features (list[Tensor]): feature-maps from possibly several levels\n            proposals (list[BoxList]): proposal boxes\n            targets (list[BoxList], optional): the ground-truth targets.\n\n        Returns:\n            x (Tensor): the result of the feature extractor\n            proposals (list[BoxList]): during training, the original proposals\n                are returned. During testing, the predicted boxlists are returned\n                with the `mask` field set\n            losses (dict[Tensor]): During training, returns the losses for the\n                head. During testing, returns an empty dict.\n        \"\"\"", "\n", "\n", "if", "self", ".", "training", ":", "\n", "# during training, only focus on positive boxes", "\n", "            ", "all_proposals", "=", "proposals", "\n", "proposals", ",", "positive_inds", "=", "keep_only_positive_boxes", "(", "proposals", ")", "\n", "", "if", "self", ".", "training", "and", "self", ".", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "SHARE_BOX_FEATURE_EXTRACTOR", ":", "\n", "            ", "x", "=", "features", "\n", "x", "=", "x", "[", "torch", ".", "cat", "(", "positive_inds", ",", "dim", "=", "0", ")", "]", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "feature_extractor", "(", "features", ",", "proposals", ")", "\n", "", "mask_logits", "=", "self", ".", "predictor", "(", "x", ")", "\n", "\n", "if", "not", "self", ".", "training", ":", "\n", "            ", "result", "=", "self", ".", "post_processor", "(", "mask_logits", ",", "proposals", ")", "\n", "return", "x", ",", "result", ",", "{", "}", "\n", "\n", "", "loss_mask", "=", "self", ".", "loss_evaluator", "(", "proposals", ",", "mask_logits", ",", "targets", ")", "\n", "\n", "return", "x", ",", "all_proposals", ",", "dict", "(", "loss_mask", "=", "loss_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.mask_head.keep_only_positive_boxes": [[13, 34], ["isinstance", "isinstance", "boxes[].has_field", "boxes_per_image.get_field", "inds_mask.nonzero().squeeze", "positive_boxes.append", "positive_inds.append", "inds_mask.nonzero"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.has_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["def", "keep_only_positive_boxes", "(", "boxes", ")", ":", "\n", "    ", "\"\"\"\n    Given a set of BoxList containing the `labels` field,\n    return a set of BoxList for which `labels > 0`.\n\n    Arguments:\n        boxes (list of BoxList)\n    \"\"\"", "\n", "assert", "isinstance", "(", "boxes", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "boxes", "[", "0", "]", ",", "BoxList", ")", "\n", "assert", "boxes", "[", "0", "]", ".", "has_field", "(", "\"labels\"", ")", "\n", "positive_boxes", "=", "[", "]", "\n", "positive_inds", "=", "[", "]", "\n", "num_boxes", "=", "0", "\n", "for", "boxes_per_image", "in", "boxes", ":", "\n", "        ", "labels", "=", "boxes_per_image", ".", "get_field", "(", "\"labels\"", ")", "\n", "inds_mask", "=", "labels", ">", "0", "\n", "inds", "=", "inds_mask", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "positive_boxes", ".", "append", "(", "boxes_per_image", "[", "inds", "]", ")", "\n", "positive_inds", ".", "append", "(", "inds_mask", ")", "\n", "", "return", "positive_boxes", ",", "positive_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.mask_head.build_roi_mask_head": [[82, 84], ["mask_head.ROIMaskHead"], "function", ["None"], ["", "", "def", "build_roi_mask_head", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "return", "ROIMaskHead", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_predictors.MaskRCNNC4Predictor.__init__": [[12, 28], ["torch.nn.Module.__init__", "vc_rcnn.layers.ConvTranspose2d", "vc_rcnn.layers.Conv2d", "roi_mask_predictors.MaskRCNNC4Predictor.named_parameters", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "MaskRCNNC4Predictor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CLASSES", "\n", "dim_reduced", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_LAYERS", "[", "-", "1", "]", "\n", "num_inputs", "=", "in_channels", "\n", "\n", "self", ".", "conv5_mask", "=", "ConvTranspose2d", "(", "num_inputs", ",", "dim_reduced", ",", "2", ",", "2", ",", "0", ")", "\n", "self", ".", "mask_fcn_logits", "=", "Conv2d", "(", "dim_reduced", ",", "num_classes", ",", "1", ",", "1", ",", "0", ")", "\n", "\n", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "\"bias\"", "in", "name", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n", "# Caffe2 implementation uses MSRAFill, which in fact", "\n", "# corresponds to kaiming_normal_ in PyTorch", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "param", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_predictors.MaskRCNNC4Predictor.forward": [[29, 32], ["torch.nn.functional.relu", "roi_mask_predictors.MaskRCNNC4Predictor.mask_fcn_logits", "roi_mask_predictors.MaskRCNNC4Predictor.conv5_mask"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "F", ".", "relu", "(", "self", ".", "conv5_mask", "(", "x", ")", ")", "\n", "return", "self", ".", "mask_fcn_logits", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_predictors.MaskRCNNConv1x1Predictor.__init__": [[36, 50], ["torch.nn.Module.__init__", "vc_rcnn.layers.Conv2d", "roi_mask_predictors.MaskRCNNConv1x1Predictor.named_parameters", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "MaskRCNNConv1x1Predictor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CLASSES", "\n", "num_inputs", "=", "in_channels", "\n", "\n", "self", ".", "mask_fcn_logits", "=", "Conv2d", "(", "num_inputs", ",", "num_classes", ",", "1", ",", "1", ",", "0", ")", "\n", "\n", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "\"bias\"", "in", "name", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n", "# Caffe2 implementation uses MSRAFill, which in fact", "\n", "# corresponds to kaiming_normal_ in PyTorch", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "param", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_predictors.MaskRCNNConv1x1Predictor.forward": [[51, 53], ["roi_mask_predictors.MaskRCNNConv1x1Predictor.mask_fcn_logits"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "mask_fcn_logits", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_predictors.make_roi_mask_predictor": [[55, 58], ["func"], "function", ["None"], ["", "", "def", "make_roi_mask_predictor", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "func", "=", "registry", ".", "ROI_MASK_PREDICTOR", "[", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "PREDICTOR", "]", "\n", "return", "func", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.MaskPostProcessor.__init__": [[23, 26], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["nms_thresh", ",", "\n", "min_size", ",", "\n", "box_coder", "=", "None", ",", "\n", "fpn_post_nms_top_n", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.MaskPostProcessor.forward": [[27, 62], ["x.sigmoid", "torch.cat", "torch.arange", "inference.MaskPostProcessor.split", "zip", "vc_rcnn.structures.bounding_box.BoxList.get_field", "len", "inference.MaskPostProcessor.masker", "vc_rcnn.structures.bounding_box.BoxList", "box.fields", "vc_rcnn.structures.bounding_box.BoxList.add_field", "results.append", "vc_rcnn.structures.bounding_box.BoxList.add_field", "box.get_field"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["fpn_post_nms_per_batch", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            pre_nms_top_n (int)\n            post_nms_top_n (int)\n            nms_thresh (float)\n            min_size (int)\n            box_coder (BoxCoder)\n            fpn_post_nms_top_n (int)\n        \"\"\"", "\n", "super", "(", "RPNPostProcessor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pre_nms_top_n", "=", "pre_nms_top_n", "\n", "self", ".", "post_nms_top_n", "=", "post_nms_top_n", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "self", ".", "min_size", "=", "min_size", "\n", "\n", "if", "box_coder", "is", "None", ":", "\n", "            ", "box_coder", "=", "BoxCoder", "(", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", "\n", "", "self", ".", "box_coder", "=", "box_coder", "\n", "\n", "if", "fpn_post_nms_top_n", "is", "None", ":", "\n", "            ", "fpn_post_nms_top_n", "=", "post_nms_top_n", "\n", "", "self", ".", "fpn_post_nms_top_n", "=", "fpn_post_nms_top_n", "\n", "self", ".", "fpn_post_nms_per_batch", "=", "fpn_post_nms_per_batch", "\n", "\n", "", "def", "add_gt_proposals", "(", "self", ",", "proposals", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposals: list[BoxList]\n            targets: list[BoxList]\n        \"\"\"", "\n", "# Get the device we're operating on", "\n", "device", "=", "proposals", "[", "0", "]", ".", "bbox", ".", "device", "\n", "\n", "gt_boxes", "=", "[", "target", ".", "copy_with_fields", "(", "[", "]", ")", "for", "target", "in", "targets", "]", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.MaskPostProcessorCOCOFormat.forward": [[71, 86], ["inference.MaskPostProcessor.forward", "result.get_field().cpu", "result.add_field", "rle[].decode", "result.get_field", "mask_util.encode", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.forward", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode"], ["for", "proposal", ",", "gt_box", "in", "zip", "(", "proposals", ",", "gt_boxes", ")", "\n", "]", "\n", "\n", "return", "proposals", "\n", "\n", "", "def", "forward_for_single_feature_map", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors: list[BoxList]\n            objectness: tensor of size N, A, H, W\n            box_regression: tensor of size N, A * 4, H, W\n        \"\"\"", "\n", "device", "=", "objectness", ".", "device", "\n", "N", ",", "A", ",", "H", ",", "W", "=", "objectness", ".", "shape", "\n", "\n", "# put in the same format as anchors", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.Masker.__init__": [[168, 171], ["None"], "methods", ["None"], ["inds_mask", "=", "torch", ".", "zeros_like", "(", "objectness", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "inds_mask", "[", "inds_sorted", "]", "=", "1", "\n", "inds_mask", "=", "inds_mask", ".", "split", "(", "box_sizes", ")", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.Masker.forward_single_image": [[172, 184], ["boxes.convert.convert.convert", "inference.paste_mask_in_image", "len", "masks.new_empty", "zip", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.paste_mask_in_image"], ["                ", "boxlists", "[", "i", "]", "=", "boxlists", "[", "i", "]", "[", "inds_mask", "[", "i", "]", "]", "\n", "", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "                ", "objectness", "=", "boxlists", "[", "i", "]", ".", "get_field", "(", "\"objectness\"", ")", "\n", "post_nms_top_n", "=", "min", "(", "self", ".", "fpn_post_nms_top_n", ",", "len", "(", "objectness", ")", ")", "\n", "_", ",", "inds_sorted", "=", "torch", ".", "topk", "(", "\n", "objectness", ",", "post_nms_top_n", ",", "dim", "=", "0", ",", "sorted", "=", "True", "\n", ")", "\n", "boxlists", "[", "i", "]", "=", "boxlists", "[", "i", "]", "[", "inds_sorted", "]", "\n", "", "", "return", "boxlists", "\n", "\n", "\n", "", "", "def", "make_rpn_postprocessor", "(", "config", ",", "rpn_box_coder", ",", "is_train", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.Masker.__call__": [[185, 200], ["isinstance", "zip", "len", "len", "inference.Masker.forward_single_image", "results.append", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.Masker.forward_single_image"], ["    ", "fpn_post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_TOP_N_TRAIN", "\n", "if", "not", "is_train", ":", "\n", "        ", "fpn_post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_TOP_N_TEST", "\n", "\n", "", "pre_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOP_N_TRAIN", "\n", "post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOP_N_TRAIN", "\n", "if", "not", "is_train", ":", "\n", "        ", "pre_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOP_N_TEST", "\n", "post_nms_top_n", "=", "config", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOP_N_TEST", "\n", "", "fpn_post_nms_per_batch", "=", "config", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_PER_BATCH", "\n", "nms_thresh", "=", "config", ".", "MODEL", ".", "RPN", ".", "NMS_THRESH", "\n", "min_size", "=", "config", ".", "MODEL", ".", "RPN", ".", "MIN_SIZE", "\n", "box_selector", "=", "RPNPostProcessor", "(", "\n", "pre_nms_top_n", "=", "pre_nms_top_n", ",", "\n", "post_nms_top_n", "=", "post_nms_top_n", ",", "\n", "nms_thresh", "=", "nms_thresh", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.expand_boxes": [[91, 106], ["torch.zeros_like"], "function", ["None"], ["\n", "num_anchors", "=", "A", "*", "H", "*", "W", "\n", "\n", "pre_nms_top_n", "=", "min", "(", "self", ".", "pre_nms_top_n", ",", "num_anchors", ")", "\n", "objectness", ",", "topk_idx", "=", "objectness", ".", "topk", "(", "pre_nms_top_n", ",", "dim", "=", "1", ",", "sorted", "=", "True", ")", "\n", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "N", ",", "device", "=", "device", ")", "[", ":", ",", "None", "]", "\n", "box_regression", "=", "box_regression", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "image_shapes", "=", "[", "box", ".", "size", "for", "box", "in", "anchors", "]", "\n", "concat_anchors", "=", "torch", ".", "cat", "(", "[", "a", ".", "bbox", "for", "a", "in", "anchors", "]", ",", "dim", "=", "0", ")", "\n", "concat_anchors", "=", "concat_anchors", ".", "reshape", "(", "N", ",", "-", "1", ",", "4", ")", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "proposals", "=", "self", ".", "box_coder", ".", "decode", "(", "\n", "box_regression", ".", "view", "(", "-", "1", ",", "4", ")", ",", "concat_anchors", ".", "view", "(", "-", "1", ",", "4", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.expand_masks": [[108, 117], ["mask.new_zeros", "float"], "function", ["None"], ["proposals", "=", "proposals", ".", "view", "(", "N", ",", "-", "1", ",", "4", ")", "\n", "\n", "result", "=", "[", "]", "\n", "for", "proposal", ",", "score", ",", "im_shape", "in", "zip", "(", "proposals", ",", "objectness", ",", "image_shapes", ")", ":", "\n", "            ", "boxlist", "=", "BoxList", "(", "proposal", ",", "im_shape", ",", "mode", "=", "\"xyxy\"", ")", "\n", "boxlist", ".", "add_field", "(", "\"objectness\"", ",", "score", ")", "\n", "boxlist", "=", "boxlist", ".", "clip_to_image", "(", "remove_empty", "=", "False", ")", "\n", "boxlist", "=", "remove_small_boxes", "(", "boxlist", ",", "self", ".", "min_size", ")", "\n", "boxlist", "=", "boxlist_nms", "(", "\n", "boxlist", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.paste_mask_in_image": [[119, 160], ["vc_rcnn.layers.misc.interpolate.float", "box.to.float", "inference.expand_masks", "box.to.to", "int", "int", "max", "max", "vc_rcnn.layers.misc.interpolate.expand", "vc_rcnn.layers.misc.interpolate.to", "vc_rcnn.layers.misc.interpolate", "torch.zeros", "max", "min", "max", "min", "inference.expand_boxes"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.expand_masks", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.interpolate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.expand_boxes"], ["max_proposals", "=", "self", ".", "post_nms_top_n", ",", "\n", "score_field", "=", "\"objectness\"", ",", "\n", ")", "\n", "result", ".", "append", "(", "boxlist", ")", "\n", "", "return", "result", "\n", "\n", "", "def", "forward", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors: list[list[BoxList]]\n            objectness: list[tensor]\n            box_regression: list[tensor]\n\n        Returns:\n            boxlists (list[BoxList]): the post-processed anchors, after\n                applying box decoding and NMS\n        \"\"\"", "\n", "sampled_boxes", "=", "[", "]", "\n", "num_levels", "=", "len", "(", "objectness", ")", "\n", "anchors", "=", "list", "(", "zip", "(", "*", "anchors", ")", ")", "\n", "for", "a", ",", "o", ",", "b", "in", "zip", "(", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "            ", "sampled_boxes", ".", "append", "(", "self", ".", "forward_for_single_feature_map", "(", "a", ",", "o", ",", "b", ")", ")", "\n", "\n", "", "boxlists", "=", "list", "(", "zip", "(", "*", "sampled_boxes", ")", ")", "\n", "boxlists", "=", "[", "cat_boxlist", "(", "boxlist", ")", "for", "boxlist", "in", "boxlists", "]", "\n", "\n", "if", "num_levels", ">", "1", ":", "\n", "            ", "boxlists", "=", "self", ".", "select_over_all_levels", "(", "boxlists", ")", "\n", "\n", "# append ground-truth bboxes to proposals", "\n", "", "if", "self", ".", "training", "and", "targets", "is", "not", "None", ":", "\n", "            ", "boxlists", "=", "self", ".", "add_gt_proposals", "(", "boxlists", ",", "targets", ")", "\n", "\n", "", "return", "boxlists", "\n", "\n", "", "def", "select_over_all_levels", "(", "self", ",", "boxlists", ")", ":", "\n", "        ", "num_images", "=", "len", "(", "boxlists", ")", "\n", "# different behavior during training and during testing:", "\n", "# during training, post_nms_top_n is over *all* the proposals combined, while", "\n", "# during testing, it is over the proposals for each image", "\n", "# NOTE: it should be per image, and not per batch. However, to be consistent ", "\n", "# with Detectron, the default is per batch (see Issue #672)", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.make_roi_mask_post_processor": [[202, 210], ["inference.MaskPostProcessor", "inference.Masker"], "function", ["None"], ["box_coder", "=", "rpn_box_coder", ",", "\n", "fpn_post_nms_top_n", "=", "fpn_post_nms_top_n", ",", "\n", "fpn_post_nms_per_batch", "=", "fpn_post_nms_per_batch", ",", "\n", ")", "\n", "return", "box_selector", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_feature_extractors.MaskRCNNFPNFeatureExtractor.__init__": [[22, 58], ["torch.nn.Module.__init__", "vc_rcnn.modeling.poolers.Pooler", "enumerate", "vc_rcnn.modeling.make_layers.make_conv3x3", "roi_mask_feature_extractors.MaskRCNNFPNFeatureExtractor.add_module", "roi_mask_feature_extractors.MaskRCNNFPNFeatureExtractor.blocks.append"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.make_conv3x3"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            num_classes (int): number of output classes\n            input_size (int): number of channels of the input once it's flattened\n            representation_size (int): size of the intermediate representation\n        \"\"\"", "\n", "super", "(", "MaskRCNNFPNFeatureExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "resolution", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "\n", "scales", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_SCALES", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler", "=", "Pooler", "(", "\n", "output_size", "=", "(", "resolution", ",", "resolution", ")", ",", "\n", "scales", "=", "scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", ")", "\n", "input_size", "=", "in_channels", "\n", "self", ".", "pooler", "=", "pooler", "\n", "\n", "use_gn", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "USE_GN", "\n", "layers", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_LAYERS", "\n", "dilation", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "DILATION", "\n", "\n", "next_feature", "=", "input_size", "\n", "self", ".", "blocks", "=", "[", "]", "\n", "for", "layer_idx", ",", "layer_features", "in", "enumerate", "(", "layers", ",", "1", ")", ":", "\n", "            ", "layer_name", "=", "\"mask_fcn{}\"", ".", "format", "(", "layer_idx", ")", "\n", "module", "=", "make_conv3x3", "(", "\n", "next_feature", ",", "layer_features", ",", "\n", "dilation", "=", "dilation", ",", "stride", "=", "1", ",", "use_gn", "=", "use_gn", "\n", ")", "\n", "self", ".", "add_module", "(", "layer_name", ",", "module", ")", "\n", "next_feature", "=", "layer_features", "\n", "self", ".", "blocks", ".", "append", "(", "layer_name", ")", "\n", "", "self", ".", "out_channels", "=", "layer_features", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_feature_extractors.MaskRCNNFPNFeatureExtractor.forward": [[59, 66], ["roi_mask_feature_extractors.MaskRCNNFPNFeatureExtractor.pooler", "torch.nn.functional.relu", "getattr"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "x", "=", "self", ".", "pooler", "(", "x", ",", "proposals", ")", "\n", "\n", "for", "layer_name", "in", "self", ".", "blocks", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "getattr", "(", "self", ",", "layer_name", ")", "(", "x", ")", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.roi_mask_feature_extractors.make_roi_mask_feature_extractor": [[68, 73], ["func"], "function", ["None"], ["", "", "def", "make_roi_mask_feature_extractor", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "func", "=", "registry", ".", "ROI_MASK_FEATURE_EXTRACTORS", "[", "\n", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "FEATURE_EXTRACTOR", "\n", "]", "\n", "return", "func", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.loss.MaskRCNNLossComputation.__init__": [[46, 54], ["None"], "methods", ["None"], ["# for creating the labels, so clear them all", "\n", "target", "=", "target", ".", "copy_with_fields", "(", "copied_fields", ")", "\n", "# get the targets corresponding GT for each anchor", "\n", "# NB: need to clamp the indices because we can have a single", "\n", "# GT in the image, and matched_idxs can be -2, which goes", "\n", "# out of bounds", "\n", "matched_targets", "=", "target", "[", "matched_idxs", ".", "clamp", "(", "min", "=", "0", ")", "]", "\n", "matched_targets", ".", "add_field", "(", "\"matched_idxs\"", ",", "matched_idxs", ")", "\n", "return", "matched_targets", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.loss.MaskRCNNLossComputation.match_targets_to_proposals": [[55, 67], ["vc_rcnn.structures.boxlist_ops.boxlist_iou", "loss.MaskRCNNLossComputation.proposal_matcher", "target.copy_with_fields.copy_with_fields.copy_with_fields", "matched_targets.add_field", "loss.MaskRCNNLossComputation.clamp"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_iou", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.copy_with_fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["\n", "", "def", "prepare_targets", "(", "self", ",", "anchors", ",", "targets", ")", ":", "\n", "        ", "labels", "=", "[", "]", "\n", "regression_targets", "=", "[", "]", "\n", "for", "anchors_per_image", ",", "targets_per_image", "in", "zip", "(", "anchors", ",", "targets", ")", ":", "\n", "            ", "matched_targets", "=", "self", ".", "match_targets_to_anchors", "(", "\n", "anchors_per_image", ",", "targets_per_image", ",", "self", ".", "copied_fields", "\n", ")", "\n", "\n", "matched_idxs", "=", "matched_targets", ".", "get_field", "(", "\"matched_idxs\"", ")", "\n", "labels_per_image", "=", "self", ".", "generate_labels_func", "(", "matched_targets", ")", "\n", "labels_per_image", "=", "labels_per_image", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.loss.MaskRCNNLossComputation.prepare_targets": [[68, 101], ["zip", "loss.MaskRCNNLossComputation.match_targets_to_proposals", "loss.MaskRCNNLossComputation.get_field", "loss.MaskRCNNLossComputation.get_field", "labels_per_image.to.to.to", "torch.nonzero().squeeze", "loss.MaskRCNNLossComputation.get_field", "loss.project_masks_on_boxes", "labels.append", "masks.append", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.match_targets_to_proposals", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.loss.project_masks_on_boxes"], ["# Background (negative examples)", "\n", "bg_indices", "=", "matched_idxs", "==", "Matcher", ".", "BELOW_LOW_THRESHOLD", "\n", "labels_per_image", "[", "bg_indices", "]", "=", "0", "\n", "\n", "# discard anchors that go out of the boundaries of the image", "\n", "if", "\"not_visibility\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "labels_per_image", "[", "~", "anchors_per_image", ".", "get_field", "(", "\"visibility\"", ")", "]", "=", "-", "1", "\n", "\n", "# discard indices that are between thresholds", "\n", "", "if", "\"between_thresholds\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "inds_to_discard", "=", "matched_idxs", "==", "Matcher", ".", "BETWEEN_THRESHOLDS", "\n", "labels_per_image", "[", "inds_to_discard", "]", "=", "-", "1", "\n", "\n", "# compute regression targets", "\n", "", "regression_targets_per_image", "=", "self", ".", "box_coder", ".", "encode", "(", "\n", "matched_targets", ".", "bbox", ",", "anchors_per_image", ".", "bbox", "\n", ")", "\n", "\n", "labels", ".", "append", "(", "labels_per_image", ")", "\n", "regression_targets", ".", "append", "(", "regression_targets_per_image", ")", "\n", "\n", "", "return", "labels", ",", "regression_targets", "\n", "\n", "\n", "", "def", "__call__", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.loss.MaskRCNNLossComputation.__call__": [[102, 129], ["loss.MaskRCNNLossComputation.prepare_targets", "vc_rcnn.modeling.utils.cat", "vc_rcnn.modeling.utils.cat", "torch.nonzero().squeeze", "torch.nn.functional.binary_cross_entropy_with_logits", "vc_rcnn.modeling.utils.cat.numel", "torch.nonzero", "mask_logits.sum"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.prepare_targets", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["\n", "anchors", "=", "[", "cat_boxlist", "(", "anchors_per_image", ")", "for", "anchors_per_image", "in", "anchors", "]", "\n", "labels", ",", "regression_targets", "=", "self", ".", "prepare_targets", "(", "anchors", ",", "targets", ")", "\n", "sampled_pos_inds", ",", "sampled_neg_inds", "=", "self", ".", "fg_bg_sampler", "(", "labels", ")", "\n", "sampled_pos_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_pos_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "sampled_neg_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_neg_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "sampled_inds", "=", "torch", ".", "cat", "(", "[", "sampled_pos_inds", ",", "sampled_neg_inds", "]", ",", "dim", "=", "0", ")", "\n", "\n", "objectness", ",", "box_regression", "=", "concat_box_prediction_layers", "(", "objectness", ",", "box_regression", ")", "\n", "\n", "objectness", "=", "objectness", ".", "squeeze", "(", ")", "\n", "\n", "labels", "=", "torch", ".", "cat", "(", "labels", ",", "dim", "=", "0", ")", "\n", "regression_targets", "=", "torch", ".", "cat", "(", "regression_targets", ",", "dim", "=", "0", ")", "\n", "\n", "box_loss", "=", "smooth_l1_loss", "(", "\n", "box_regression", "[", "sampled_pos_inds", "]", ",", "\n", "regression_targets", "[", "sampled_pos_inds", "]", ",", "\n", "beta", "=", "1.0", "/", "9", ",", "\n", "size_average", "=", "False", ",", "\n", ")", "/", "(", "sampled_inds", ".", "numel", "(", ")", ")", "\n", "\n", "objectness_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "objectness", "[", "sampled_inds", "]", ",", "labels", "[", "sampled_inds", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.loss.project_masks_on_boxes": [[11, 43], ["proposals.bbox.to.convert", "proposals.bbox.to.bbox.to", "zip", "torch.stack().to", "torch.device", "segmentation_mask.crop", "segmentation_mask.crop.resize", "cropped_mask.resize.get_mask_tensor", "masks.append", "len", "torch.empty", "torch.stack"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.crop", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.get_mask_tensor"], ["\n", "from", ".", ".", "balanced_positive_negative_sampler", "import", "BalancedPositiveNegativeSampler", "\n", "from", ".", ".", "utils", "import", "cat", "\n", "\n", "from", "vc_rcnn", ".", "layers", "import", "smooth_l1_loss", "\n", "from", "vc_rcnn", ".", "modeling", ".", "matcher", "import", "Matcher", "\n", "from", "vc_rcnn", ".", "structures", ".", "boxlist_ops", "import", "boxlist_iou", "\n", "from", "vc_rcnn", ".", "structures", ".", "boxlist_ops", "import", "cat_boxlist", "\n", "\n", "\n", "class", "RPNLossComputation", "(", "object", ")", ":", "\n", "    ", "\"\"\"\n    This class computes the RPN loss.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "proposal_matcher", ",", "fg_bg_sampler", ",", "box_coder", ",", "\n", "generate_labels_func", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposal_matcher (Matcher)\n            fg_bg_sampler (BalancedPositiveNegativeSampler)\n            box_coder (BoxCoder)\n        \"\"\"", "\n", "# self.target_preparator = target_preparator", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "fg_bg_sampler", "=", "fg_bg_sampler", "\n", "self", ".", "box_coder", "=", "box_coder", "\n", "self", ".", "copied_fields", "=", "[", "]", "\n", "self", ".", "generate_labels_func", "=", "generate_labels_func", "\n", "self", ".", "discard_cases", "=", "[", "'not_visibility'", ",", "'between_thresholds'", "]", "\n", "\n", "", "def", "match_targets_to_anchors", "(", "self", ",", "anchor", ",", "target", ",", "copied_fields", "=", "[", "]", ")", ":", "\n", "        ", "match_quality_matrix", "=", "boxlist_iou", "(", "target", ",", "anchor", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.loss.make_roi_mask_loss_evaluator": [[131, 143], ["vc_rcnn.modeling.matcher.Matcher", "loss.MaskRCNNLossComputation"], "function", ["None"], ["return", "objectness_loss", ",", "box_loss", "\n", "\n", "# This function should be overwritten in RetinaNet", "\n", "", "", "def", "generate_rpn_labels", "(", "matched_targets", ")", ":", "\n", "    ", "matched_idxs", "=", "matched_targets", ".", "get_field", "(", "\"matched_idxs\"", ")", "\n", "labels_per_image", "=", "matched_idxs", ">=", "0", "\n", "return", "labels_per_image", "\n", "\n", "\n", "", "def", "make_rpn_loss_evaluator", "(", "cfg", ",", "box_coder", ")", ":", "\n", "    ", "matcher", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "FG_IOU_THRESHOLD", ",", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BG_IOU_THRESHOLD", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.FastRCNNPredictor.__init__": [[11, 28], ["torch.nn.Module.__init__", "torch.nn.AdaptiveAvgPool2d", "torch.nn.AdaptiveAvgPool2d", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "FastRCNNPredictor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "in_channels", "is", "not", "None", "\n", "\n", "num_inputs", "=", "in_channels", "\n", "\n", "num_classes", "=", "config", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CLASSES", "\n", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "self", ".", "cls_score", "=", "nn", ".", "Linear", "(", "num_inputs", ",", "num_classes", ")", "\n", "num_bbox_reg_classes", "=", "2", "if", "config", ".", "MODEL", ".", "CLS_AGNOSTIC_BBOX_REG", "else", "num_classes", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Linear", "(", "num_inputs", ",", "num_bbox_reg_classes", "*", "4", ")", "\n", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "cls_score", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "cls_score", ".", "bias", ",", "0", ")", "\n", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "bbox_pred", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "bbox_pred", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.FastRCNNPredictor.forward": [[29, 35], ["roi_box_predictors.FastRCNNPredictor.avgpool", "x.view.view.view", "roi_box_predictors.FastRCNNPredictor.cls_score", "roi_box_predictors.FastRCNNPredictor.bbox_pred", "x.view.view.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "cls_logit", "=", "self", ".", "cls_score", "(", "x", ")", "\n", "bbox_pred", "=", "self", ".", "bbox_pred", "(", "x", ")", "\n", "return", "cls_logit", ",", "bbox_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.FPNPredictor.__init__": [[39, 49], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "FPNPredictor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CLASSES", "\n", "representation_size", "=", "in_channels", "\n", "\n", "self", ".", "cls_score", "=", "nn", ".", "Linear", "(", "representation_size", ",", "num_classes", ")", "\n", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "cls_score", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "cls_score", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.FPNPredictor.forward": [[50, 57], ["roi_box_predictors.FPNPredictor.cls_score", "x.view.view.ndimension", "x.view.view.view", "list", "x.view.view.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "ndimension", "(", ")", "==", "4", ":", "\n", "            ", "assert", "list", "(", "x", ".", "shape", "[", "2", ":", "]", ")", "==", "[", "1", ",", "1", "]", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "", "scores", "=", "self", ".", "cls_score", "(", "x", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.CausalPredictor.__init__": [[67, 88], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "numpy.load", "numpy.load"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "CausalPredictor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CLASSES", "\n", "self", ".", "embedding_size", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "EMBEDDING", "\n", "representation_size", "=", "in_channels", "\n", "\n", "self", ".", "causal_score", "=", "nn", ".", "Linear", "(", "2", "*", "representation_size", ",", "num_classes", ")", "\n", "self", ".", "Wy", "=", "nn", ".", "Linear", "(", "representation_size", ",", "self", ".", "embedding_size", ")", "\n", "self", ".", "Wz", "=", "nn", ".", "Linear", "(", "representation_size", ",", "self", ".", "embedding_size", ")", "\n", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "causal_score", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "Wy", ".", "weight", ",", "std", "=", "0.02", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "Wz", ".", "weight", ",", "std", "=", "0.02", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "Wy", ".", "bias", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "Wz", ".", "bias", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "causal_score", ".", "bias", ",", "0", ")", "\n", "\n", "self", ".", "feature_size", "=", "representation_size", "\n", "self", ".", "dic", "=", "torch", ".", "tensor", "(", "np", ".", "load", "(", "cfg", ".", "DIC_FILE", ")", "[", "1", ":", "]", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "self", ".", "prior", "=", "torch", ".", "tensor", "(", "np", ".", "load", "(", "cfg", ".", "PRIOR_PROB", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.CausalPredictor.forward": [[89, 102], ["x.get_device", "roi_box_predictors.CausalPredictor.dic.to", "roi_box_predictors.CausalPredictor.prior.to", "x.split", "proposal.bbox.size", "roi_box_predictors.CausalPredictor.z_dic", "roi_box_predictors.CausalPredictor.causal_score"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.CausalPredictor.z_dic"], ["", "def", "forward", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "device", "=", "x", ".", "get_device", "(", ")", "\n", "dic_z", "=", "self", ".", "dic", ".", "to", "(", "device", ")", "\n", "prior", "=", "self", ".", "prior", ".", "to", "(", "device", ")", "\n", "\n", "box_size_list", "=", "[", "proposal", ".", "bbox", ".", "size", "(", "0", ")", "for", "proposal", "in", "proposals", "]", "\n", "feature_split", "=", "x", ".", "split", "(", "box_size_list", ")", "\n", "xzs", "=", "[", "self", ".", "z_dic", "(", "feature_pre_obj", ",", "dic_z", ",", "prior", ")", "for", "feature_pre_obj", "in", "feature_split", "]", "\n", "\n", "causal_logits_list", "=", "[", "self", ".", "causal_score", "(", "xz", ")", "for", "xz", "in", "xzs", "]", "\n", "\n", "\n", "return", "causal_logits_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.CausalPredictor.z_dic": [[104, 121], ["y.size", "torch.softmax", "torch.softmax", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.isnan().sum", "torch.isnan().sum", "torch.isnan().sum", "torch.isnan().sum", "print", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.softmax.unsqueeze", "dic_z.unsqueeze", "print", "roi_box_predictors.CausalPredictor.Wy", "roi_box_predictors.CausalPredictor.Wz().t", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "y.size", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "prior.unsqueeze", "roi_box_predictors.CausalPredictor.Wz", "y.unsqueeze().repeat", "torch.matmul().squeeze.unsqueeze().repeat", "torch.matmul().squeeze.unsqueeze().repeat", "y.unsqueeze", "torch.matmul().squeeze.unsqueeze", "torch.matmul().squeeze.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "z_dic", "(", "self", ",", "y", ",", "dic_z", ",", "prior", ")", ":", "\n", "        ", "\"\"\"\n        Please note that we computer the intervention in the whole batch rather than for one object in the main paper.\n        \"\"\"", "\n", "length", "=", "y", ".", "size", "(", "0", ")", "\n", "if", "length", "==", "1", ":", "\n", "            ", "print", "(", "'debug'", ")", "\n", "", "attention", "=", "torch", ".", "mm", "(", "self", ".", "Wy", "(", "y", ")", ",", "self", ".", "Wz", "(", "dic_z", ")", ".", "t", "(", ")", ")", "/", "(", "self", ".", "embedding_size", "**", "0.5", ")", "\n", "attention", "=", "F", ".", "softmax", "(", "attention", ",", "1", ")", "\n", "z_hat", "=", "attention", ".", "unsqueeze", "(", "2", ")", "*", "dic_z", ".", "unsqueeze", "(", "0", ")", "\n", "z", "=", "torch", ".", "matmul", "(", "prior", ".", "unsqueeze", "(", "0", ")", ",", "z_hat", ")", ".", "squeeze", "(", "1", ")", "\n", "xz", "=", "torch", ".", "cat", "(", "(", "y", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "length", ",", "1", ")", ",", "z", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "length", ",", "1", ",", "1", ")", ")", ",", "2", ")", ".", "view", "(", "-", "1", ",", "2", "*", "y", ".", "size", "(", "1", ")", ")", "\n", "\n", "# detect if encounter nan", "\n", "if", "torch", ".", "isnan", "(", "xz", ")", ".", "sum", "(", ")", ":", "\n", "            ", "print", "(", "xz", ")", "\n", "", "return", "xz", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.make_roi_box_predictor": [[59, 62], ["func"], "function", ["None"], ["", "", "def", "make_roi_box_predictor", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "func", "=", "registry", ".", "ROI_BOX_PREDICTOR", "[", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "PREDICTOR", "]", "\n", "return", "func", "(", "cfg", ",", "in_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.make_causal_predictor": [[122, 125], ["func"], "function", ["None"], ["", "", "def", "make_causal_predictor", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "func", "=", "registry", ".", "ROI_BOX_PREDICTOR", "[", "\"CausalPredictor\"", "]", "\n", "return", "func", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.inference.PostProcessor.__init__": [[19, 44], ["torch.nn.Module.__init__", "vc_rcnn.modeling.box_coder.BoxCoder"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "pre_nms_top_n", ",", "\n", "post_nms_top_n", ",", "\n", "nms_thresh", ",", "\n", "min_size", ",", "\n", "box_coder", "=", "None", ",", "\n", "fpn_post_nms_top_n", "=", "None", ",", "\n", "fpn_post_nms_per_batch", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            pre_nms_top_n (int)\n            post_nms_top_n (int)\n            nms_thresh (float)\n            min_size (int)\n            box_coder (BoxCoder)\n            fpn_post_nms_top_n (int)\n        \"\"\"", "\n", "super", "(", "RPNPostProcessor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pre_nms_top_n", "=", "pre_nms_top_n", "\n", "self", ".", "post_nms_top_n", "=", "post_nms_top_n", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "self", ".", "min_size", "=", "min_size", "\n", "\n", "if", "box_coder", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.inference.PostProcessor.forward": [[45, 88], ["torch.softmax", "torch.softmax", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "inference.PostProcessor.box_coder.decode", "proposals.repeat.repeat.split", "class_prob.split.split.split", "zip", "len", "box_regression.view", "proposals.repeat.repeat.repeat", "inference.PostProcessor.prepare_boxlist", "inference.PostProcessor.clip_to_image", "results.append", "sum", "inference.PostProcessor.filter_results"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.inference.PostProcessor.prepare_boxlist", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.clip_to_image", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.inference.PostProcessor.filter_results"], ["            ", "box_coder", "=", "BoxCoder", "(", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", "\n", "", "self", ".", "box_coder", "=", "box_coder", "\n", "\n", "if", "fpn_post_nms_top_n", "is", "None", ":", "\n", "            ", "fpn_post_nms_top_n", "=", "post_nms_top_n", "\n", "", "self", ".", "fpn_post_nms_top_n", "=", "fpn_post_nms_top_n", "\n", "self", ".", "fpn_post_nms_per_batch", "=", "fpn_post_nms_per_batch", "\n", "\n", "", "def", "add_gt_proposals", "(", "self", ",", "proposals", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposals: list[BoxList]\n            targets: list[BoxList]\n        \"\"\"", "\n", "# Get the device we're operating on", "\n", "device", "=", "proposals", "[", "0", "]", ".", "bbox", ".", "device", "\n", "\n", "gt_boxes", "=", "[", "target", ".", "copy_with_fields", "(", "[", "]", ")", "for", "target", "in", "targets", "]", "\n", "\n", "# later cat of bbox requires all fields to be present for all bbox", "\n", "# so we need to add a dummy for objectness that's missing", "\n", "for", "gt_box", "in", "gt_boxes", ":", "\n", "            ", "gt_box", ".", "add_field", "(", "\"objectness\"", ",", "torch", ".", "ones", "(", "len", "(", "gt_box", ")", ",", "device", "=", "device", ")", ")", "\n", "\n", "", "proposals", "=", "[", "\n", "cat_boxlist", "(", "(", "proposal", ",", "gt_box", ")", ")", "\n", "for", "proposal", ",", "gt_box", "in", "zip", "(", "proposals", ",", "gt_boxes", ")", "\n", "]", "\n", "\n", "return", "proposals", "\n", "\n", "", "def", "forward_for_single_feature_map", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors: list[BoxList]\n            objectness: tensor of size N, A, H, W\n            box_regression: tensor of size N, A * 4, H, W\n        \"\"\"", "\n", "device", "=", "objectness", ".", "device", "\n", "N", ",", "A", ",", "H", ",", "W", "=", "objectness", ".", "shape", "\n", "\n", "# put in the same format as anchors", "\n", "objectness", "=", "permute_and_flatten", "(", "objectness", ",", "N", ",", "A", ",", "1", ",", "H", ",", "W", ")", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "objectness", "=", "objectness", ".", "sigmoid", "(", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.inference.PostProcessor.prepare_boxlist": [[89, 107], ["boxes.reshape.reshape.reshape", "scores.reshape.reshape.reshape", "vc_rcnn.structures.bounding_box.BoxList", "vc_rcnn.structures.bounding_box.BoxList.add_field"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["\n", "box_regression", "=", "permute_and_flatten", "(", "box_regression", ",", "N", ",", "A", ",", "4", ",", "H", ",", "W", ")", "\n", "\n", "num_anchors", "=", "A", "*", "H", "*", "W", "\n", "\n", "pre_nms_top_n", "=", "min", "(", "self", ".", "pre_nms_top_n", ",", "num_anchors", ")", "\n", "objectness", ",", "topk_idx", "=", "objectness", ".", "topk", "(", "pre_nms_top_n", ",", "dim", "=", "1", ",", "sorted", "=", "True", ")", "\n", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "N", ",", "device", "=", "device", ")", "[", ":", ",", "None", "]", "\n", "box_regression", "=", "box_regression", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "image_shapes", "=", "[", "box", ".", "size", "for", "box", "in", "anchors", "]", "\n", "concat_anchors", "=", "torch", ".", "cat", "(", "[", "a", ".", "bbox", "for", "a", "in", "anchors", "]", ",", "dim", "=", "0", ")", "\n", "concat_anchors", "=", "concat_anchors", ".", "reshape", "(", "N", ",", "-", "1", ",", "4", ")", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "proposals", "=", "self", ".", "box_coder", ".", "decode", "(", "\n", "box_regression", ".", "view", "(", "-", "1", ",", "4", ")", ",", "concat_anchors", ".", "view", "(", "-", "1", ",", "4", ")", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.inference.PostProcessor.filter_results": [[108, 150], ["boxlist.bbox.reshape", "boxlist.get_field().reshape", "range", "vc_rcnn.structures.boxlist_ops.cat_boxlist", "len", "inds_all[].nonzero().squeeze", "vc_rcnn.structures.bounding_box.BoxList", "vc_rcnn.structures.boxlist_ops.boxlist_nms.add_field", "vc_rcnn.structures.boxlist_ops.boxlist_nms", "len", "vc_rcnn.structures.boxlist_ops.boxlist_nms.add_field", "vc_rcnn.structures.boxlist_ops.cat_boxlist.append", "vc_rcnn.structures.boxlist_ops.cat_boxlist.get_field", "torch.kthvalue", "torch.kthvalue", "torch.kthvalue", "torch.kthvalue", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "boxlist.get_field", "torch.full", "torch.full", "torch.full", "torch.full", "vc_rcnn.structures.boxlist_ops.cat_boxlist.get_field.cpu", "image_thresh.item", "inds_all[].nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.cat_boxlist", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_nms", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["proposals", "=", "proposals", ".", "view", "(", "N", ",", "-", "1", ",", "4", ")", "\n", "\n", "result", "=", "[", "]", "\n", "for", "proposal", ",", "score", ",", "im_shape", "in", "zip", "(", "proposals", ",", "objectness", ",", "image_shapes", ")", ":", "\n", "            ", "boxlist", "=", "BoxList", "(", "proposal", ",", "im_shape", ",", "mode", "=", "\"xyxy\"", ")", "\n", "boxlist", ".", "add_field", "(", "\"objectness\"", ",", "score", ")", "\n", "boxlist", "=", "boxlist", ".", "clip_to_image", "(", "remove_empty", "=", "False", ")", "\n", "boxlist", "=", "remove_small_boxes", "(", "boxlist", ",", "self", ".", "min_size", ")", "\n", "boxlist", "=", "boxlist_nms", "(", "\n", "boxlist", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "max_proposals", "=", "self", ".", "post_nms_top_n", ",", "\n", "score_field", "=", "\"objectness\"", ",", "\n", ")", "\n", "result", ".", "append", "(", "boxlist", ")", "\n", "", "return", "result", "\n", "\n", "", "def", "forward", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors: list[list[BoxList]]\n            objectness: list[tensor]\n            box_regression: list[tensor]\n\n        Returns:\n            boxlists (list[BoxList]): the post-processed anchors, after\n                applying box decoding and NMS\n        \"\"\"", "\n", "sampled_boxes", "=", "[", "]", "\n", "num_levels", "=", "len", "(", "objectness", ")", "\n", "anchors", "=", "list", "(", "zip", "(", "*", "anchors", ")", ")", "\n", "for", "a", ",", "o", ",", "b", "in", "zip", "(", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "            ", "sampled_boxes", ".", "append", "(", "self", ".", "forward_for_single_feature_map", "(", "a", ",", "o", ",", "b", ")", ")", "\n", "\n", "", "boxlists", "=", "list", "(", "zip", "(", "*", "sampled_boxes", ")", ")", "\n", "boxlists", "=", "[", "cat_boxlist", "(", "boxlist", ")", "for", "boxlist", "in", "boxlists", "]", "\n", "\n", "if", "num_levels", ">", "1", ":", "\n", "            ", "boxlists", "=", "self", ".", "select_over_all_levels", "(", "boxlists", ")", "\n", "\n", "# append ground-truth bboxes to proposals", "\n", "", "if", "self", ".", "training", "and", "targets", "is", "not", "None", ":", "\n", "            ", "boxlists", "=", "self", ".", "add_gt_proposals", "(", "boxlists", ",", "targets", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.inference.make_roi_box_post_processor": [[152, 173], ["vc_rcnn.modeling.box_coder.BoxCoder", "inference.PostProcessor"], "function", ["None"], ["", "return", "boxlists", "\n", "\n", "", "def", "select_over_all_levels", "(", "self", ",", "boxlists", ")", ":", "\n", "        ", "num_images", "=", "len", "(", "boxlists", ")", "\n", "# different behavior during training and during testing:", "\n", "# during training, post_nms_top_n is over *all* the proposals combined, while", "\n", "# during testing, it is over the proposals for each image", "\n", "# NOTE: it should be per image, and not per batch. However, to be consistent ", "\n", "# with Detectron, the default is per batch (see Issue #672)", "\n", "if", "self", ".", "training", "and", "self", ".", "fpn_post_nms_per_batch", ":", "\n", "            ", "objectness", "=", "torch", ".", "cat", "(", "\n", "[", "boxlist", ".", "get_field", "(", "\"objectness\"", ")", "for", "boxlist", "in", "boxlists", "]", ",", "dim", "=", "0", "\n", ")", "\n", "box_sizes", "=", "[", "len", "(", "boxlist", ")", "for", "boxlist", "in", "boxlists", "]", "\n", "post_nms_top_n", "=", "min", "(", "self", ".", "fpn_post_nms_top_n", ",", "len", "(", "objectness", ")", ")", "\n", "_", ",", "inds_sorted", "=", "torch", ".", "topk", "(", "objectness", ",", "post_nms_top_n", ",", "dim", "=", "0", ",", "sorted", "=", "True", ")", "\n", "inds_mask", "=", "torch", ".", "zeros_like", "(", "objectness", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "inds_mask", "[", "inds_sorted", "]", "=", "1", "\n", "inds_mask", "=", "inds_mask", ".", "split", "(", "box_sizes", ")", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "                ", "boxlists", "[", "i", "]", "=", "boxlists", "[", "i", "]", "[", "inds_mask", "[", "i", "]", "]", "\n", "", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_feature_extractors.ResNet50Conv5ROIFeatureExtractor.__init__": [[15, 42], ["torch.nn.Module.__init__", "vc_rcnn.modeling.poolers.Pooler", "vc_rcnn.modeling.backbone.resnet.StageSpec", "vc_rcnn.modeling.backbone.resnet.ResNetHead"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "ResNet50Conv5ROIFeatureExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "resolution", "=", "config", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "scales", "=", "config", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SCALES", "\n", "sampling_ratio", "=", "config", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler", "=", "Pooler", "(", "\n", "output_size", "=", "(", "resolution", ",", "resolution", ")", ",", "\n", "scales", "=", "scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", ")", "\n", "\n", "stage", "=", "resnet", ".", "StageSpec", "(", "index", "=", "4", ",", "block_count", "=", "3", ",", "return_features", "=", "False", ")", "\n", "head", "=", "resnet", ".", "ResNetHead", "(", "\n", "block_module", "=", "config", ".", "MODEL", ".", "RESNETS", ".", "TRANS_FUNC", ",", "\n", "stages", "=", "(", "stage", ",", ")", ",", "\n", "num_groups", "=", "config", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", ",", "\n", "width_per_group", "=", "config", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", ",", "\n", "stride_in_1x1", "=", "config", ".", "MODEL", ".", "RESNETS", ".", "STRIDE_IN_1X1", ",", "\n", "stride_init", "=", "None", ",", "\n", "res2_out_channels", "=", "config", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", ",", "\n", "dilation", "=", "config", ".", "MODEL", ".", "RESNETS", ".", "RES5_DILATION", "\n", ")", "\n", "\n", "self", ".", "pooler", "=", "pooler", "\n", "self", ".", "head", "=", "head", "\n", "self", ".", "out_channels", "=", "head", ".", "out_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_feature_extractors.ResNet50Conv5ROIFeatureExtractor.forward": [[43, 47], ["roi_box_feature_extractors.ResNet50Conv5ROIFeatureExtractor.pooler", "roi_box_feature_extractors.ResNet50Conv5ROIFeatureExtractor.head"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "x", "=", "self", ".", "pooler", "(", "x", ",", "proposals", ")", "\n", "x", "=", "self", ".", "head", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_feature_extractors.FPN2MLPFeatureExtractor.__init__": [[55, 73], ["torch.nn.Module.__init__", "vc_rcnn.modeling.poolers.Pooler", "vc_rcnn.modeling.make_layers.make_fc", "vc_rcnn.modeling.make_layers.make_fc"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.make_fc", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.make_fc"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "FPN2MLPFeatureExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "scales", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SCALES", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler", "=", "Pooler", "(", "\n", "output_size", "=", "(", "resolution", ",", "resolution", ")", ",", "\n", "scales", "=", "scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", ")", "\n", "input_size", "=", "in_channels", "*", "resolution", "**", "2", "\n", "representation_size", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "MLP_HEAD_DIM", "\n", "use_gn", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "USE_GN", "\n", "self", ".", "pooler", "=", "pooler", "\n", "self", ".", "fc6", "=", "make_fc", "(", "input_size", ",", "representation_size", ",", "use_gn", ")", "\n", "self", ".", "fc7", "=", "make_fc", "(", "representation_size", ",", "representation_size", ",", "use_gn", ")", "\n", "self", ".", "out_channels", "=", "representation_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_feature_extractors.FPN2MLPFeatureExtractor.forward": [[74, 82], ["roi_box_feature_extractors.FPN2MLPFeatureExtractor.pooler", "torch.nn.functional.relu.view", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu.size", "roi_box_feature_extractors.FPN2MLPFeatureExtractor.fc6", "roi_box_feature_extractors.FPN2MLPFeatureExtractor.fc7"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "x", "=", "self", ".", "pooler", "(", "x", ",", "proposals", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "fc6", "(", "x", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "fc7", "(", "x", ")", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_feature_extractors.FPNXconv1fcFeatureExtractor.__init__": [[90, 138], ["torch.nn.Module.__init__", "vc_rcnn.modeling.poolers.Pooler", "range", "roi_box_feature_extractors.FPNXconv1fcFeatureExtractor.add_module", "vc_rcnn.modeling.make_layers.make_fc", "xconvs.append", "xconvs.append", "torch.nn.Sequential", "modules.modules", "torch.nn.Conv2d", "xconvs.append", "torch.nn.ReLU", "isinstance", "vc_rcnn.modeling.make_layers.group_norm", "torch.nn.init.normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.make_fc", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.group_norm"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "FPNXconv1fcFeatureExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "scales", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SCALES", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler", "=", "Pooler", "(", "\n", "output_size", "=", "(", "resolution", ",", "resolution", ")", ",", "\n", "scales", "=", "scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", ")", "\n", "self", ".", "pooler", "=", "pooler", "\n", "\n", "use_gn", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "USE_GN", "\n", "conv_head_dim", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CONV_HEAD_DIM", "\n", "num_stacked_convs", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_STACKED_CONVS", "\n", "dilation", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "DILATION", "\n", "\n", "xconvs", "=", "[", "]", "\n", "for", "ix", "in", "range", "(", "num_stacked_convs", ")", ":", "\n", "            ", "xconvs", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "\n", "conv_head_dim", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", "bias", "=", "False", "if", "use_gn", "else", "True", "\n", ")", "\n", ")", "\n", "in_channels", "=", "conv_head_dim", "\n", "if", "use_gn", ":", "\n", "                ", "xconvs", ".", "append", "(", "group_norm", "(", "in_channels", ")", ")", "\n", "", "xconvs", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "\n", "", "self", ".", "add_module", "(", "\"xconvs\"", ",", "nn", ".", "Sequential", "(", "*", "xconvs", ")", ")", "\n", "for", "modules", "in", "[", "self", ".", "xconvs", ",", "]", ":", "\n", "            ", "for", "l", "in", "modules", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "l", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "l", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "if", "not", "use_gn", ":", "\n", "                        ", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "", "input_size", "=", "conv_head_dim", "*", "resolution", "**", "2", "\n", "representation_size", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "MLP_HEAD_DIM", "\n", "self", ".", "fc6", "=", "make_fc", "(", "input_size", ",", "representation_size", ",", "use_gn", "=", "False", ")", "\n", "self", ".", "out_channels", "=", "representation_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_feature_extractors.FPNXconv1fcFeatureExtractor.forward": [[139, 145], ["roi_box_feature_extractors.FPNXconv1fcFeatureExtractor.pooler", "roi_box_feature_extractors.FPNXconv1fcFeatureExtractor.xconvs", "torch.nn.functional.relu.view", "torch.nn.functional.relu", "torch.nn.functional.relu.size", "roi_box_feature_extractors.FPNXconv1fcFeatureExtractor.fc6"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "x", "=", "self", ".", "pooler", "(", "x", ",", "proposals", ")", "\n", "x", "=", "self", ".", "xconvs", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "fc6", "(", "x", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_feature_extractors.make_roi_box_feature_extractor": [[147, 152], ["func"], "function", ["None"], ["", "", "def", "make_roi_box_feature_extractor", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "func", "=", "registry", ".", "ROI_BOX_FEATURE_EXTRACTORS", "[", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "FEATURE_EXTRACTOR", "\n", "]", "\n", "return", "func", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.loss.FastRCNNLossComputation.__init__": [[21, 38], ["None"], "methods", ["None"], ["class", "RPNLossComputation", "(", "object", ")", ":", "\n", "    ", "\"\"\"\n    This class computes the RPN loss.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "proposal_matcher", ",", "fg_bg_sampler", ",", "box_coder", ",", "\n", "generate_labels_func", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposal_matcher (Matcher)\n            fg_bg_sampler (BalancedPositiveNegativeSampler)\n            box_coder (BoxCoder)\n        \"\"\"", "\n", "# self.target_preparator = target_preparator", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "fg_bg_sampler", "=", "fg_bg_sampler", "\n", "self", ".", "box_coder", "=", "box_coder", "\n", "self", ".", "copied_fields", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.loss.FastRCNNLossComputation.match_targets_to_proposals": [[39, 51], ["vc_rcnn.structures.boxlist_ops.boxlist_iou", "loss.FastRCNNLossComputation.proposal_matcher", "target.copy_with_fields.copy_with_fields.copy_with_fields", "matched_targets.add_field", "loss.FastRCNNLossComputation.clamp"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_iou", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.copy_with_fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["self", ".", "generate_labels_func", "=", "generate_labels_func", "\n", "self", ".", "discard_cases", "=", "[", "'not_visibility'", ",", "'between_thresholds'", "]", "\n", "\n", "", "def", "match_targets_to_anchors", "(", "self", ",", "anchor", ",", "target", ",", "copied_fields", "=", "[", "]", ")", ":", "\n", "        ", "match_quality_matrix", "=", "boxlist_iou", "(", "target", ",", "anchor", ")", "\n", "matched_idxs", "=", "self", ".", "proposal_matcher", "(", "match_quality_matrix", ")", "\n", "# RPN doesn't need any fields from target", "\n", "# for creating the labels, so clear them all", "\n", "target", "=", "target", ".", "copy_with_fields", "(", "copied_fields", ")", "\n", "# get the targets corresponding GT for each anchor", "\n", "# NB: need to clamp the indices because we can have a single", "\n", "# GT in the image, and matched_idxs can be -2, which goes", "\n", "# out of bounds", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.loss.FastRCNNLossComputation.prepare_targets": [[52, 81], ["zip", "loss.FastRCNNLossComputation.match_targets_to_proposals", "loss.FastRCNNLossComputation.get_field", "loss.FastRCNNLossComputation.get_field", "labels_per_image.to.to.to", "loss.FastRCNNLossComputation.box_coder.encode", "labels.append", "regression_targets.append"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.match_targets_to_proposals", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode"], ["matched_targets", "=", "target", "[", "matched_idxs", ".", "clamp", "(", "min", "=", "0", ")", "]", "\n", "matched_targets", ".", "add_field", "(", "\"matched_idxs\"", ",", "matched_idxs", ")", "\n", "return", "matched_targets", "\n", "\n", "", "def", "prepare_targets", "(", "self", ",", "anchors", ",", "targets", ")", ":", "\n", "        ", "labels", "=", "[", "]", "\n", "regression_targets", "=", "[", "]", "\n", "for", "anchors_per_image", ",", "targets_per_image", "in", "zip", "(", "anchors", ",", "targets", ")", ":", "\n", "            ", "matched_targets", "=", "self", ".", "match_targets_to_anchors", "(", "\n", "anchors_per_image", ",", "targets_per_image", ",", "self", ".", "copied_fields", "\n", ")", "\n", "\n", "matched_idxs", "=", "matched_targets", ".", "get_field", "(", "\"matched_idxs\"", ")", "\n", "labels_per_image", "=", "self", ".", "generate_labels_func", "(", "matched_targets", ")", "\n", "labels_per_image", "=", "labels_per_image", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# Background (negative examples)", "\n", "bg_indices", "=", "matched_idxs", "==", "Matcher", ".", "BELOW_LOW_THRESHOLD", "\n", "labels_per_image", "[", "bg_indices", "]", "=", "0", "\n", "\n", "# discard anchors that go out of the boundaries of the image", "\n", "if", "\"not_visibility\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "labels_per_image", "[", "~", "anchors_per_image", ".", "get_field", "(", "\"visibility\"", ")", "]", "=", "-", "1", "\n", "\n", "# discard indices that are between thresholds", "\n", "", "if", "\"between_thresholds\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "inds_to_discard", "=", "matched_idxs", "==", "Matcher", ".", "BETWEEN_THRESHOLDS", "\n", "labels_per_image", "[", "inds_to_discard", "]", "=", "-", "1", "\n", "\n", "# compute regression targets", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.loss.FastRCNNLossComputation.subsample": [[82, 117], ["loss.FastRCNNLossComputation.prepare_targets", "loss.FastRCNNLossComputation.fg_bg_sampler", "list", "zip", "enumerate", "proposals_per_image.add_field", "proposals_per_image.add_field", "zip", "torch.nonzero().squeeze", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.prepare_targets", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["", "regression_targets_per_image", "=", "self", ".", "box_coder", ".", "encode", "(", "\n", "matched_targets", ".", "bbox", ",", "anchors_per_image", ".", "bbox", "\n", ")", "\n", "\n", "labels", ".", "append", "(", "labels_per_image", ")", "\n", "regression_targets", ".", "append", "(", "regression_targets_per_image", ")", "\n", "\n", "", "return", "labels", ",", "regression_targets", "\n", "\n", "\n", "", "def", "__call__", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors (list[list[BoxList]])\n            objectness (list[Tensor])\n            box_regression (list[Tensor])\n            targets (list[BoxList])\n\n        Returns:\n            objectness_loss (Tensor)\n            box_loss (Tensor)\n        \"\"\"", "\n", "anchors", "=", "[", "cat_boxlist", "(", "anchors_per_image", ")", "for", "anchors_per_image", "in", "anchors", "]", "\n", "labels", ",", "regression_targets", "=", "self", ".", "prepare_targets", "(", "anchors", ",", "targets", ")", "\n", "sampled_pos_inds", ",", "sampled_neg_inds", "=", "self", ".", "fg_bg_sampler", "(", "labels", ")", "\n", "sampled_pos_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_pos_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "sampled_neg_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_neg_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "sampled_inds", "=", "torch", ".", "cat", "(", "[", "sampled_pos_inds", ",", "sampled_neg_inds", "]", ",", "dim", "=", "0", ")", "\n", "\n", "objectness", ",", "box_regression", "=", "concat_box_prediction_layers", "(", "objectness", ",", "box_regression", ")", "\n", "\n", "objectness", "=", "objectness", ".", "squeeze", "(", ")", "\n", "\n", "labels", "=", "torch", ".", "cat", "(", "labels", ",", "dim", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.loss.FastRCNNLossComputation.__call__": [[118, 153], ["vc_rcnn.modeling.utils.cat", "vc_rcnn.modeling.utils.cat", "torch.nn.functional.cross_entropy", "zip", "proposal.get_field().to", "label.unsqueeze().repeat", "torch.nn.functional.cross_entropy", "torch.mean", "label.size", "torch.eye().to", "label.unsqueeze().repeat.view", "mask.view", "proposal.get_field", "label.unsqueeze", "torch.eye", "label.unsqueeze().repeat.size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["regression_targets", "=", "torch", ".", "cat", "(", "regression_targets", ",", "dim", "=", "0", ")", "\n", "\n", "box_loss", "=", "smooth_l1_loss", "(", "\n", "box_regression", "[", "sampled_pos_inds", "]", ",", "\n", "regression_targets", "[", "sampled_pos_inds", "]", ",", "\n", "beta", "=", "1.0", "/", "9", ",", "\n", "size_average", "=", "False", ",", "\n", ")", "/", "(", "sampled_inds", ".", "numel", "(", ")", ")", "\n", "\n", "objectness_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "objectness", "[", "sampled_inds", "]", ",", "labels", "[", "sampled_inds", "]", "\n", ")", "\n", "\n", "return", "objectness_loss", ",", "box_loss", "\n", "\n", "# This function should be overwritten in RetinaNet", "\n", "", "", "def", "generate_rpn_labels", "(", "matched_targets", ")", ":", "\n", "    ", "matched_idxs", "=", "matched_targets", ".", "get_field", "(", "\"matched_idxs\"", ")", "\n", "labels_per_image", "=", "matched_idxs", ">=", "0", "\n", "return", "labels_per_image", "\n", "\n", "\n", "", "def", "make_rpn_loss_evaluator", "(", "cfg", ",", "box_coder", ")", ":", "\n", "    ", "matcher", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "FG_IOU_THRESHOLD", ",", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BG_IOU_THRESHOLD", ",", "\n", "allow_low_quality_matches", "=", "True", ",", "\n", ")", "\n", "\n", "fg_bg_sampler", "=", "BalancedPositiveNegativeSampler", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BATCH_SIZE_PER_IMAGE", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "POSITIVE_FRACTION", "\n", ")", "\n", "\n", "loss_evaluator", "=", "RPNLossComputation", "(", "\n", "matcher", ",", "\n", "fg_bg_sampler", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.loss.make_roi_box_loss_evaluator": [[155, 179], ["vc_rcnn.modeling.matcher.Matcher", "vc_rcnn.modeling.box_coder.BoxCoder", "vc_rcnn.modeling.balanced_positive_negative_sampler.BalancedPositiveNegativeSampler", "loss.FastRCNNLossComputation"], "function", ["None"], ["generate_rpn_labels", "\n", ")", "\n", "return", "loss_evaluator", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.box_head.ROIBoxHead.__init__": [[18, 27], ["super().__init__", "roi_box_feature_extractors.make_roi_box_feature_extractor", "roi_box_predictors.make_roi_box_predictor", "inference.make_roi_box_post_processor", "loss.make_roi_box_loss_evaluator", "roi_box_predictors.make_causal_predictor"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_feature_extractors.make_roi_box_feature_extractor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.make_roi_box_predictor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.inference.make_roi_box_post_processor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.loss.make_roi_box_loss_evaluator", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.roi_box_predictors.make_causal_predictor"], ["def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "ROIBoxHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "feature_extractor", "=", "make_roi_box_feature_extractor", "(", "cfg", ",", "in_channels", ")", "\n", "self", ".", "predictor", "=", "make_roi_box_predictor", "(", "\n", "cfg", ",", "self", ".", "feature_extractor", ".", "out_channels", ")", "\n", "self", ".", "post_processor", "=", "make_roi_box_post_processor", "(", "cfg", ")", "\n", "self", ".", "loss_evaluator", "=", "make_roi_box_loss_evaluator", "(", "cfg", ")", "\n", "self", ".", "causal_predictor", "=", "make_causal_predictor", "(", "cfg", ",", "self", ".", "feature_extractor", ".", "out_channels", ")", "\n", "self", ".", "feature_save_path", "=", "cfg", ".", "FEATURE_SAVE_PATH", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.box_head.ROIBoxHead.forward": [[28, 72], ["box_head.ROIBoxHead.feature_extractor", "box_head.ROIBoxHead.predictor", "box_head.ROIBoxHead.causal_predictor", "box_head.ROIBoxHead.loss_evaluator", "box_head.ROIBoxHead.post_processor_gt", "box_head.ROIBoxHead.save_object_feature_gt_bu", "dict"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.box_head.ROIBoxHead.post_processor_gt", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.box_head.ROIBoxHead.save_object_feature_gt_bu"], ["", "def", "forward", "(", "self", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            features (list[Tensor]): feature-maps from possibly several levels\n            proposals (list[BoxList]): proposal boxes\n            targets (list[BoxList], optional): the ground-truth targets.\n\n        Returns:\n            x (Tensor): the result of the feature extractor\n            proposals (list[BoxList]): during training, the subsampled proposals\n                are returned. During testing, the predicted boxlists are returned\n            losses (dict[Tensor]): During training, returns the losses for the\n                head. During testing, returns an empty dict.\n        \"\"\"", "\n", "\n", "\n", "# extract features that will be fed to the final classifier. The", "\n", "# feature_extractor generally corresponds to the pooler + heads", "\n", "x", "=", "self", ".", "feature_extractor", "(", "features", ",", "proposals", ")", "\n", "\n", "# self predictor", "\n", "class_logits", "=", "self", ".", "predictor", "(", "x", ")", "\n", "\n", "# context predictor", "\n", "class_logits_causal_list", "=", "self", ".", "causal_predictor", "(", "x", ",", "proposals", ")", "\n", "# pdb.set_trace()", "\n", "\n", "\n", "if", "not", "self", ".", "training", ":", "\n", "\n", "            ", "result", "=", "self", ".", "post_processor_gt", "(", "x", ",", "class_logits", ",", "proposals", ")", "\n", "\n", "# save object feature", "\n", "self", ".", "save_object_feature_gt_bu", "(", "x", ",", "result", ",", "targets", ")", "\n", "\n", "return", "x", ",", "result", ",", "{", "}", "\n", "\n", "", "loss_classifier", ",", "loss_causal", "=", "self", ".", "loss_evaluator", "(", "\n", "[", "class_logits", "]", ",", "class_logits_causal_list", ",", "proposals", "\n", ")", "\n", "return", "(", "\n", "x", ",", "\n", "proposals", ",", "\n", "dict", "(", "loss_self", "=", "loss_classifier", ",", "loss_causal", "=", "loss_causal", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.box_head.ROIBoxHead.post_processor_gt": [[74, 87], ["torch.softmax", "torch.softmax", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "class_prob.split.split.split", "bbx_idx.split.split.split", "enumerate", "class_logits.size", "len", "zip", "boxes[].add_field", "boxes[].add_field", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["", "def", "post_processor_gt", "(", "self", ",", "x", ",", "class_logits", ",", "boxes", ")", ":", "\n", "        ", "class_prob", "=", "F", ".", "softmax", "(", "class_logits", ",", "-", "1", ")", "\n", "bbx_idx", "=", "torch", ".", "arange", "(", "0", ",", "class_logits", ".", "size", "(", "0", ")", ")", "\n", "# image_shapes = [box.size for box in boxes]", "\n", "boxes_per_image", "=", "[", "len", "(", "box", ")", "for", "box", "in", "boxes", "]", "\n", "class_prob", "=", "class_prob", ".", "split", "(", "boxes_per_image", ",", "dim", "=", "0", ")", "\n", "bbx_idx", "=", "bbx_idx", ".", "split", "(", "boxes_per_image", ",", "dim", "=", "0", ")", "\n", "\n", "for", "i", ",", "(", "class_prob_image", ",", "bbx_idx_image", ")", "in", "enumerate", "(", "zip", "(", "class_prob", ",", "bbx_idx", ")", ")", ":", "\n", "            ", "boxes", "[", "i", "]", ".", "add_field", "(", "\"labels_classify\"", ",", "torch", ".", "max", "(", "class_prob_image", ",", "1", ")", "[", "0", "]", ")", "\n", "boxes", "[", "i", "]", ".", "add_field", "(", "\"features\"", ",", "x", "[", "bbx_idx_image", "]", ")", "\n", "\n", "", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.box_head.ROIBoxHead.save_object_feature_gt_bu": [[89, 100], ["enumerate", "image.get_field().cpu().numpy", "str", "numpy.save", "image.get_field().cpu", "[].cpu().numpy", "os.path.join", "print", "image.get_field", "image.get_field", "[].cpu", "image.get_field"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "save_object_feature_gt_bu", "(", "self", ",", "x", ",", "result", ",", "targets", ")", ":", "\n", "\n", "        ", "for", "i", ",", "image", "in", "enumerate", "(", "result", ")", ":", "\n", "            ", "feature_pre_image", "=", "image", ".", "get_field", "(", "\"features\"", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "try", ":", "\n", "                ", "assert", "image", ".", "get_field", "(", "\"num_box\"", ")", "[", "0", "]", "==", "feature_pre_image", ".", "shape", "[", "0", "]", "\n", "image_id", "=", "str", "(", "image", ".", "get_field", "(", "\"image_id\"", ")", "[", "0", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "feature_save_path", ",", "image_id", ")", "+", "'.npy'", "\n", "np", ".", "save", "(", "path", ",", "feature_pre_image", ")", "\n", "", "except", ":", "\n", "                ", "print", "(", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.box_head.box_head.build_roi_box_head": [[104, 111], ["box_head.ROIBoxHead"], "function", ["None"], ["", "", "", "", "def", "build_roi_box_head", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "\"\"\"\n    Constructs a new box head.\n    By default, uses ROIBoxHead, but if it turns out not to be enough, just register a new class\n    and make it a parameter in the config\n    \"\"\"", "\n", "return", "ROIBoxHead", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.roi_keypoint_feature_extractors.KeypointRCNNFeatureExtractor.__init__": [[12, 38], ["torch.nn.Module.__init__", "vc_rcnn.modeling.poolers.Pooler", "enumerate", "vc_rcnn.layers.Conv2d", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "roi_keypoint_feature_extractors.KeypointRCNNFeatureExtractor.add_module", "roi_keypoint_feature_extractors.KeypointRCNNFeatureExtractor.blocks.append"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "KeypointRCNNFeatureExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "resolution", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_RESOLUTION", "\n", "scales", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_SCALES", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler", "=", "Pooler", "(", "\n", "output_size", "=", "(", "resolution", ",", "resolution", ")", ",", "\n", "scales", "=", "scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", ")", "\n", "self", ".", "pooler", "=", "pooler", "\n", "\n", "input_features", "=", "in_channels", "\n", "layers", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "CONV_LAYERS", "\n", "next_feature", "=", "input_features", "\n", "self", ".", "blocks", "=", "[", "]", "\n", "for", "layer_idx", ",", "layer_features", "in", "enumerate", "(", "layers", ",", "1", ")", ":", "\n", "            ", "layer_name", "=", "\"conv_fcn{}\"", ".", "format", "(", "layer_idx", ")", "\n", "module", "=", "Conv2d", "(", "next_feature", ",", "layer_features", ",", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "nn", ".", "init", ".", "kaiming_normal_", "(", "module", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "0", ")", "\n", "self", ".", "add_module", "(", "layer_name", ",", "module", ")", "\n", "next_feature", "=", "layer_features", "\n", "self", ".", "blocks", ".", "append", "(", "layer_name", ")", "\n", "", "self", ".", "out_channels", "=", "layer_features", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.roi_keypoint_feature_extractors.KeypointRCNNFeatureExtractor.forward": [[39, 44], ["roi_keypoint_feature_extractors.KeypointRCNNFeatureExtractor.pooler", "torch.nn.functional.relu", "getattr"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "x", "=", "self", ".", "pooler", "(", "x", ",", "proposals", ")", "\n", "for", "layer_name", "in", "self", ".", "blocks", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "getattr", "(", "self", ",", "layer_name", ")", "(", "x", ")", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.roi_keypoint_feature_extractors.make_roi_keypoint_feature_extractor": [[46, 51], ["func"], "function", ["None"], ["", "", "def", "make_roi_keypoint_feature_extractor", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "func", "=", "registry", ".", "ROI_KEYPOINT_FEATURE_EXTRACTORS", "[", "\n", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "FEATURE_EXTRACTOR", "\n", "]", "\n", "return", "func", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.roi_keypoint_predictors.KeypointRCNNPredictor.__init__": [[9, 27], ["torch.nn.Module.__init__", "vc_rcnn.layers.ConvTranspose2d", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "KeypointRCNNPredictor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "input_features", "=", "in_channels", "\n", "num_keypoints", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NUM_CLASSES", "\n", "deconv_kernel", "=", "4", "\n", "self", ".", "kps_score_lowres", "=", "layers", ".", "ConvTranspose2d", "(", "\n", "input_features", ",", "\n", "num_keypoints", ",", "\n", "deconv_kernel", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "deconv_kernel", "//", "2", "-", "1", ",", "\n", ")", "\n", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "self", ".", "kps_score_lowres", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", "\n", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "kps_score_lowres", ".", "bias", ",", "0", ")", "\n", "self", ".", "up_scale", "=", "2", "\n", "self", ".", "out_channels", "=", "num_keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.roi_keypoint_predictors.KeypointRCNNPredictor.forward": [[28, 34], ["roi_keypoint_predictors.KeypointRCNNPredictor.kps_score_lowres", "vc_rcnn.layers.interpolate"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.interpolate"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "kps_score_lowres", "(", "x", ")", "\n", "x", "=", "layers", ".", "interpolate", "(", "\n", "x", ",", "scale_factor", "=", "self", ".", "up_scale", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.roi_keypoint_predictors.make_roi_keypoint_predictor": [[36, 39], ["func"], "function", ["None"], ["", "", "def", "make_roi_keypoint_predictor", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "func", "=", "registry", ".", "ROI_KEYPOINT_PREDICTOR", "[", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "PREDICTOR", "]", "\n", "return", "func", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.inference.KeypointPostProcessor.__init__": [[6, 9], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["from", "vc_rcnn", ".", "structures", ".", "boxlist_ops", "import", "cat_boxlist", "\n", "from", "vc_rcnn", ".", "structures", ".", "boxlist_ops", "import", "boxlist_nms", "\n", "from", "vc_rcnn", ".", "structures", ".", "boxlist_ops", "import", "remove_small_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.inference.KeypointPostProcessor.forward": [[10, 33], ["mask_prob.split.split.split", "scores.split.split.split", "zip", "inference.KeypointPostProcessor.keypointer", "len", "box.bbox.size", "vc_rcnn.structures.bounding_box.BoxList", "box.fields", "vc_rcnn.structures.keypoint.PersonKeypoints", "vc_rcnn.structures.keypoint.PersonKeypoints.add_field", "vc_rcnn.structures.bounding_box.BoxList.add_field", "results.append", "vc_rcnn.structures.bounding_box.BoxList.add_field", "box.get_field"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["from", ".", ".", "utils", "import", "cat", "\n", "from", ".", "utils", "import", "permute_and_flatten", "\n", "\n", "class", "RPNPostProcessor", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    Performs post-processing on the outputs of the RPN boxes, before feeding the\n    proposals to the heads\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "pre_nms_top_n", ",", "\n", "post_nms_top_n", ",", "\n", "nms_thresh", ",", "\n", "min_size", ",", "\n", "box_coder", "=", "None", ",", "\n", "fpn_post_nms_top_n", "=", "None", ",", "\n", "fpn_post_nms_per_batch", "=", "True", ",", "\n", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.inference.Keypointer.__init__": [[107, 109], ["None"], "methods", ["None"], ["\n", "proposals", "=", "proposals", ".", "view", "(", "N", ",", "-", "1", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.inference.Keypointer.__call__": [[110, 120], ["isinstance", "inference.heatmaps_to_keypoints", "len", "masks.detach().cpu().numpy", "boxes[].bbox.cpu().numpy", "torch.from_numpy().to", "torch.as_tensor", "masks.detach().cpu", "boxes[].bbox.cpu", "torch.from_numpy", "masks.detach"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.inference.heatmaps_to_keypoints", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["result", "=", "[", "]", "\n", "for", "proposal", ",", "score", ",", "im_shape", "in", "zip", "(", "proposals", ",", "objectness", ",", "image_shapes", ")", ":", "\n", "            ", "boxlist", "=", "BoxList", "(", "proposal", ",", "im_shape", ",", "mode", "=", "\"xyxy\"", ")", "\n", "boxlist", ".", "add_field", "(", "\"objectness\"", ",", "score", ")", "\n", "boxlist", "=", "boxlist", ".", "clip_to_image", "(", "remove_empty", "=", "False", ")", "\n", "boxlist", "=", "remove_small_boxes", "(", "boxlist", ",", "self", ".", "min_size", ")", "\n", "boxlist", "=", "boxlist_nms", "(", "\n", "boxlist", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "max_proposals", "=", "self", ".", "post_nms_top_n", ",", "\n", "score_field", "=", "\"objectness\"", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.inference.heatmaps_to_keypoints": [[40, 95], ["numpy.maximum", "numpy.maximum", "numpy.ceil", "numpy.ceil", "numpy.transpose", "numpy.zeros", "numpy.zeros", "range", "len", "cv2.resize", "numpy.transpose", "np.transpose.reshape().argmax", "numpy.transpose", "len", "len", "int", "int", "numpy.maximum", "numpy.maximum", "np.transpose.reshape", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["self", ".", "post_nms_top_n", "=", "post_nms_top_n", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "self", ".", "min_size", "=", "min_size", "\n", "\n", "if", "box_coder", "is", "None", ":", "\n", "            ", "box_coder", "=", "BoxCoder", "(", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", "\n", "", "self", ".", "box_coder", "=", "box_coder", "\n", "\n", "if", "fpn_post_nms_top_n", "is", "None", ":", "\n", "            ", "fpn_post_nms_top_n", "=", "post_nms_top_n", "\n", "", "self", ".", "fpn_post_nms_top_n", "=", "fpn_post_nms_top_n", "\n", "self", ".", "fpn_post_nms_per_batch", "=", "fpn_post_nms_per_batch", "\n", "\n", "", "def", "add_gt_proposals", "(", "self", ",", "proposals", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposals: list[BoxList]\n            targets: list[BoxList]\n        \"\"\"", "\n", "# Get the device we're operating on", "\n", "device", "=", "proposals", "[", "0", "]", ".", "bbox", ".", "device", "\n", "\n", "gt_boxes", "=", "[", "target", ".", "copy_with_fields", "(", "[", "]", ")", "for", "target", "in", "targets", "]", "\n", "\n", "# later cat of bbox requires all fields to be present for all bbox", "\n", "# so we need to add a dummy for objectness that's missing", "\n", "for", "gt_box", "in", "gt_boxes", ":", "\n", "            ", "gt_box", ".", "add_field", "(", "\"objectness\"", ",", "torch", ".", "ones", "(", "len", "(", "gt_box", ")", ",", "device", "=", "device", ")", ")", "\n", "\n", "", "proposals", "=", "[", "\n", "cat_boxlist", "(", "(", "proposal", ",", "gt_box", ")", ")", "\n", "for", "proposal", ",", "gt_box", "in", "zip", "(", "proposals", ",", "gt_boxes", ")", "\n", "]", "\n", "\n", "return", "proposals", "\n", "\n", "", "def", "forward_for_single_feature_map", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors: list[BoxList]\n            objectness: tensor of size N, A, H, W\n            box_regression: tensor of size N, A * 4, H, W\n        \"\"\"", "\n", "device", "=", "objectness", ".", "device", "\n", "N", ",", "A", ",", "H", ",", "W", "=", "objectness", ".", "shape", "\n", "\n", "# put in the same format as anchors", "\n", "objectness", "=", "permute_and_flatten", "(", "objectness", ",", "N", ",", "A", ",", "1", ",", "H", ",", "W", ")", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "objectness", "=", "objectness", ".", "sigmoid", "(", ")", "\n", "\n", "box_regression", "=", "permute_and_flatten", "(", "box_regression", ",", "N", ",", "A", ",", "4", ",", "H", ",", "W", ")", "\n", "\n", "num_anchors", "=", "A", "*", "H", "*", "W", "\n", "\n", "pre_nms_top_n", "=", "min", "(", "self", ".", "pre_nms_top_n", ",", "num_anchors", ")", "\n", "objectness", ",", "topk_idx", "=", "objectness", ".", "topk", "(", "pre_nms_top_n", ",", "dim", "=", "1", ",", "sorted", "=", "True", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.inference.make_roi_keypoint_post_processor": [[122, 126], ["inference.Keypointer", "inference.KeypointPostProcessor"], "function", ["None"], ["result", ".", "append", "(", "boxlist", ")", "\n", "", "return", "result", "\n", "\n", "", "def", "forward", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", "=", "None", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.keypoint_head.ROIKeypointHead.__init__": [[10, 18], ["super().__init__", "cfg.clone", "roi_keypoint_feature_extractors.make_roi_keypoint_feature_extractor", "roi_keypoint_predictors.make_roi_keypoint_predictor", "inference.make_roi_keypoint_post_processor", "loss.make_roi_keypoint_loss_evaluator"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.roi_keypoint_feature_extractors.make_roi_keypoint_feature_extractor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.roi_keypoint_predictors.make_roi_keypoint_predictor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.inference.make_roi_keypoint_post_processor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.make_roi_keypoint_loss_evaluator"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "ROIKeypointHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "self", ".", "feature_extractor", "=", "make_roi_keypoint_feature_extractor", "(", "cfg", ",", "in_channels", ")", "\n", "self", ".", "predictor", "=", "make_roi_keypoint_predictor", "(", "\n", "cfg", ",", "self", ".", "feature_extractor", ".", "out_channels", ")", "\n", "self", ".", "post_processor", "=", "make_roi_keypoint_post_processor", "(", "cfg", ")", "\n", "self", ".", "loss_evaluator", "=", "make_roi_keypoint_loss_evaluator", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.keypoint_head.ROIKeypointHead.forward": [[19, 48], ["keypoint_head.ROIKeypointHead.feature_extractor", "keypoint_head.ROIKeypointHead.predictor", "keypoint_head.ROIKeypointHead.loss_evaluator", "keypoint_head.ROIKeypointHead.post_processor", "dict", "torch.no_grad", "keypoint_head.ROIKeypointHead.loss_evaluator.subsample"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.subsample"], ["", "def", "forward", "(", "self", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            features (list[Tensor]): feature-maps from possibly several levels\n            proposals (list[BoxList]): proposal boxes\n            targets (list[BoxList], optional): the ground-truth targets.\n\n        Returns:\n            x (Tensor): the result of the feature extractor\n            proposals (list[BoxList]): during training, the original proposals\n                are returned. During testing, the predicted boxlists are returned\n                with the `mask` field set\n            losses (dict[Tensor]): During training, returns the losses for the\n                head. During testing, returns an empty dict.\n        \"\"\"", "\n", "if", "self", ".", "training", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "proposals", "=", "self", ".", "loss_evaluator", ".", "subsample", "(", "proposals", ",", "targets", ")", "\n", "\n", "", "", "x", "=", "self", ".", "feature_extractor", "(", "features", ",", "proposals", ")", "\n", "kp_logits", "=", "self", ".", "predictor", "(", "x", ")", "\n", "\n", "if", "not", "self", ".", "training", ":", "\n", "            ", "result", "=", "self", ".", "post_processor", "(", "kp_logits", ",", "proposals", ")", "\n", "return", "x", ",", "result", ",", "{", "}", "\n", "\n", "", "loss_kp", "=", "self", ".", "loss_evaluator", "(", "proposals", ",", "kp_logits", ")", "\n", "\n", "return", "x", ",", "proposals", ",", "dict", "(", "loss_kp", "=", "loss_kp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.keypoint_head.build_roi_keypoint_head": [[50, 52], ["keypoint_head.ROIKeypointHead"], "function", ["None"], ["", "", "def", "build_roi_keypoint_head", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "return", "ROIKeypointHead", "(", "cfg", ",", "in_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.__init__": [[55, 65], ["None"], "methods", ["None"], ["\n", "", "def", "prepare_targets", "(", "self", ",", "anchors", ",", "targets", ")", ":", "\n", "        ", "labels", "=", "[", "]", "\n", "regression_targets", "=", "[", "]", "\n", "for", "anchors_per_image", ",", "targets_per_image", "in", "zip", "(", "anchors", ",", "targets", ")", ":", "\n", "            ", "matched_targets", "=", "self", ".", "match_targets_to_anchors", "(", "\n", "anchors_per_image", ",", "targets_per_image", ",", "self", ".", "copied_fields", "\n", ")", "\n", "\n", "matched_idxs", "=", "matched_targets", ".", "get_field", "(", "\"matched_idxs\"", ")", "\n", "labels_per_image", "=", "self", ".", "generate_labels_func", "(", "matched_targets", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.match_targets_to_proposals": [[66, 78], ["vc_rcnn.structures.boxlist_ops.boxlist_iou", "loss.KeypointRCNNLossComputation.proposal_matcher", "target.copy_with_fields.copy_with_fields.copy_with_fields", "matched_targets.add_field", "loss.KeypointRCNNLossComputation.clamp"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_iou", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.copy_with_fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["labels_per_image", "=", "labels_per_image", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# Background (negative examples)", "\n", "bg_indices", "=", "matched_idxs", "==", "Matcher", ".", "BELOW_LOW_THRESHOLD", "\n", "labels_per_image", "[", "bg_indices", "]", "=", "0", "\n", "\n", "# discard anchors that go out of the boundaries of the image", "\n", "if", "\"not_visibility\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "labels_per_image", "[", "~", "anchors_per_image", ".", "get_field", "(", "\"visibility\"", ")", "]", "=", "-", "1", "\n", "\n", "# discard indices that are between thresholds", "\n", "", "if", "\"between_thresholds\"", "in", "self", ".", "discard_cases", ":", "\n", "                ", "inds_to_discard", "=", "matched_idxs", "==", "Matcher", ".", "BETWEEN_THRESHOLDS", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.prepare_targets": [[79, 110], ["zip", "loss.KeypointRCNNLossComputation.match_targets_to_proposals", "loss.KeypointRCNNLossComputation.get_field", "loss.KeypointRCNNLossComputation.get_field", "labels_per_image.to.to.to", "loss.KeypointRCNNLossComputation.get_field", "loss._within_box", "labels.append", "keypoints.append"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.match_targets_to_proposals", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss._within_box"], ["labels_per_image", "[", "inds_to_discard", "]", "=", "-", "1", "\n", "\n", "# compute regression targets", "\n", "", "regression_targets_per_image", "=", "self", ".", "box_coder", ".", "encode", "(", "\n", "matched_targets", ".", "bbox", ",", "anchors_per_image", ".", "bbox", "\n", ")", "\n", "\n", "labels", ".", "append", "(", "labels_per_image", ")", "\n", "regression_targets", ".", "append", "(", "regression_targets_per_image", ")", "\n", "\n", "", "return", "labels", ",", "regression_targets", "\n", "\n", "\n", "", "def", "__call__", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors (list[list[BoxList]])\n            objectness (list[Tensor])\n            box_regression (list[Tensor])\n            targets (list[BoxList])\n\n        Returns:\n            objectness_loss (Tensor)\n            box_loss (Tensor)\n        \"\"\"", "\n", "anchors", "=", "[", "cat_boxlist", "(", "anchors_per_image", ")", "for", "anchors_per_image", "in", "anchors", "]", "\n", "labels", ",", "regression_targets", "=", "self", ".", "prepare_targets", "(", "anchors", ",", "targets", ")", "\n", "sampled_pos_inds", ",", "sampled_neg_inds", "=", "self", ".", "fg_bg_sampler", "(", "labels", ")", "\n", "sampled_pos_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_pos_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "sampled_neg_inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "cat", "(", "sampled_neg_inds", ",", "dim", "=", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "sampled_inds", "=", "torch", ".", "cat", "(", "[", "sampled_pos_inds", ",", "sampled_neg_inds", "]", ",", "dim", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.subsample": [[111, 144], ["loss.KeypointRCNNLossComputation.prepare_targets", "loss.KeypointRCNNLossComputation.fg_bg_sampler", "list", "zip", "enumerate", "proposals_per_image.add_field", "proposals_per_image.add_field", "zip", "torch.nonzero().squeeze", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.prepare_targets", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["\n", "objectness", ",", "box_regression", "=", "concat_box_prediction_layers", "(", "objectness", ",", "box_regression", ")", "\n", "\n", "objectness", "=", "objectness", ".", "squeeze", "(", ")", "\n", "\n", "labels", "=", "torch", ".", "cat", "(", "labels", ",", "dim", "=", "0", ")", "\n", "regression_targets", "=", "torch", ".", "cat", "(", "regression_targets", ",", "dim", "=", "0", ")", "\n", "\n", "box_loss", "=", "smooth_l1_loss", "(", "\n", "box_regression", "[", "sampled_pos_inds", "]", ",", "\n", "regression_targets", "[", "sampled_pos_inds", "]", ",", "\n", "beta", "=", "1.0", "/", "9", ",", "\n", "size_average", "=", "False", ",", "\n", ")", "/", "(", "sampled_inds", ".", "numel", "(", ")", ")", "\n", "\n", "objectness_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "objectness", "[", "sampled_inds", "]", ",", "labels", "[", "sampled_inds", "]", "\n", ")", "\n", "\n", "return", "objectness_loss", ",", "box_loss", "\n", "\n", "# This function should be overwritten in RetinaNet", "\n", "", "", "def", "generate_rpn_labels", "(", "matched_targets", ")", ":", "\n", "    ", "matched_idxs", "=", "matched_targets", ".", "get_field", "(", "\"matched_idxs\"", ")", "\n", "labels_per_image", "=", "matched_idxs", ">=", "0", "\n", "return", "labels_per_image", "\n", "\n", "\n", "", "def", "make_rpn_loss_evaluator", "(", "cfg", ",", "box_coder", ")", ":", "\n", "    ", "matcher", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "FG_IOU_THRESHOLD", ",", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BG_IOU_THRESHOLD", ",", "\n", "allow_low_quality_matches", "=", "True", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.KeypointRCNNLossComputation.__call__": [[145, 170], ["vc_rcnn.modeling.utils.cat", "vc_rcnn.modeling.utils.cat().to", "torch.nonzero().squeeze", "keypoint_logits.view.view.view", "torch.nn.functional.cross_entropy", "proposals_per_image.get_field", "loss.project_keypoints_to_heatmap", "heatmaps.append", "torch.nonzero().squeeze.append", "heatmaps_per_image.view", "valid_per_image.view", "vc_rcnn.modeling.utils.cat", "torch.nonzero", "vc_rcnn.modeling.utils.cat.numel", "len", "keypoint_logits.view.view.sum"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.project_keypoints_to_heatmap", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], [")", "\n", "\n", "fg_bg_sampler", "=", "BalancedPositiveNegativeSampler", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BATCH_SIZE_PER_IMAGE", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "POSITIVE_FRACTION", "\n", ")", "\n", "\n", "loss_evaluator", "=", "RPNLossComputation", "(", "\n", "matcher", ",", "\n", "fg_bg_sampler", ",", "\n", "box_coder", ",", "\n", "generate_rpn_labels", "\n", ")", "\n", "return", "loss_evaluator", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.project_keypoints_to_heatmap": [[17, 21], ["proposals.convert.convert", "vc_rcnn.structures.keypoint.keypoints_to_heat_map"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.keypoints_to_heat_map"], ["from", "vc_rcnn", ".", "structures", ".", "boxlist_ops", "import", "boxlist_iou", "\n", "from", "vc_rcnn", ".", "structures", ".", "boxlist_ops", "import", "cat_boxlist", "\n", "\n", "\n", "class", "RPNLossComputation", "(", "object", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.cat_boxlist_with_keypoints": [[24, 37], ["all", "vc_rcnn.modeling.utils.cat", "boxlists[].get_fields", "vc_rcnn.structures.boxlist_ops.cat_boxlist", "vc_rcnn.structures.boxlist_ops.cat_boxlist.add_field", "boxlist.copy_with_fields", "boxlist.has_field", "boxlist.get_field"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.cat_boxlist", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.copy_with_fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.has_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["\n", "\n", "def", "__init__", "(", "self", ",", "proposal_matcher", ",", "fg_bg_sampler", ",", "box_coder", ",", "\n", "generate_labels_func", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposal_matcher (Matcher)\n            fg_bg_sampler (BalancedPositiveNegativeSampler)\n            box_coder (BoxCoder)\n        \"\"\"", "\n", "# self.target_preparator = target_preparator", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "fg_bg_sampler", "=", "fg_bg_sampler", "\n", "self", ".", "box_coder", "=", "box_coder", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss._within_box": [[39, 52], ["None"], "function", ["None"], ["self", ".", "generate_labels_func", "=", "generate_labels_func", "\n", "self", ".", "discard_cases", "=", "[", "'not_visibility'", ",", "'between_thresholds'", "]", "\n", "\n", "", "def", "match_targets_to_anchors", "(", "self", ",", "anchor", ",", "target", ",", "copied_fields", "=", "[", "]", ")", ":", "\n", "        ", "match_quality_matrix", "=", "boxlist_iou", "(", "target", ",", "anchor", ")", "\n", "matched_idxs", "=", "self", ".", "proposal_matcher", "(", "match_quality_matrix", ")", "\n", "# RPN doesn't need any fields from target", "\n", "# for creating the labels, so clear them all", "\n", "target", "=", "target", ".", "copy_with_fields", "(", "copied_fields", ")", "\n", "# get the targets corresponding GT for each anchor", "\n", "# NB: need to clamp the indices because we can have a single", "\n", "# GT in the image, and matched_idxs can be -2, which goes", "\n", "# out of bounds", "\n", "matched_targets", "=", "target", "[", "matched_idxs", ".", "clamp", "(", "min", "=", "0", ")", "]", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.keypoint_head.loss.make_roi_keypoint_loss_evaluator": [[172, 184], ["vc_rcnn.modeling.matcher.Matcher", "vc_rcnn.modeling.balanced_positive_negative_sampler.BalancedPositiveNegativeSampler", "loss.KeypointRCNNLossComputation"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_modeldef.add_archs": [[4, 9], ["None"], "function", ["None"], ["def", "add_archs", "(", "archs", ")", ":", "\n", "    ", "global", "MODEL_ARCH", "\n", "for", "x", "in", "archs", ":", "\n", "        ", "assert", "x", "not", "in", "MODEL_ARCH", ",", "\"Duplicated model name {} existed\"", ".", "format", "(", "x", ")", "\n", "MODEL_ARCH", "[", "x", "]", "=", "archs", "[", "x", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fpn.FPN.__init__": [[14, 42], ["torch.nn.Module.__init__", "enumerate", "conv_block", "conv_block", "fpn.FPN.add_module", "fpn.FPN.add_module", "fpn.FPN.inner_blocks.append", "fpn.FPN.layer_blocks.append"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "\n", "self", ",", "in_channels_list", ",", "out_channels", ",", "conv_block", ",", "top_blocks", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            in_channels_list (list[int]): number of channels for each feature map that\n                will be fed\n            out_channels (int): number of channels of the FPN representation\n            top_blocks (nn.Module or None): if provided, an extra operation will\n                be performed on the output of the last (smallest resolution)\n                FPN output, and the result will extend the result list\n        \"\"\"", "\n", "super", "(", "FPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inner_blocks", "=", "[", "]", "\n", "self", ".", "layer_blocks", "=", "[", "]", "\n", "for", "idx", ",", "in_channels", "in", "enumerate", "(", "in_channels_list", ",", "1", ")", ":", "\n", "            ", "inner_block", "=", "\"fpn_inner{}\"", ".", "format", "(", "idx", ")", "\n", "layer_block", "=", "\"fpn_layer{}\"", ".", "format", "(", "idx", ")", "\n", "\n", "if", "in_channels", "==", "0", ":", "\n", "                ", "continue", "\n", "", "inner_block_module", "=", "conv_block", "(", "in_channels", ",", "out_channels", ",", "1", ")", "\n", "layer_block_module", "=", "conv_block", "(", "out_channels", ",", "out_channels", ",", "3", ",", "1", ")", "\n", "self", ".", "add_module", "(", "inner_block", ",", "inner_block_module", ")", "\n", "self", ".", "add_module", "(", "layer_block", ",", "layer_block_module", ")", "\n", "self", ".", "inner_blocks", ".", "append", "(", "inner_block", ")", "\n", "self", ".", "layer_blocks", ".", "append", "(", "layer_block", ")", "\n", "", "self", ".", "top_blocks", "=", "top_blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fpn.FPN.forward": [[43, 75], ["results.append", "zip", "isinstance", "tuple", "getattr", "torch.interpolate", "torch.interpolate", "results.insert", "fpn.FPN.top_blocks", "results.extend", "isinstance", "getattr", "getattr", "fpn.FPN.top_blocks", "results.extend", "getattr"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.interpolate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.interpolate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            x (list[Tensor]): feature maps for each feature level.\n        Returns:\n            results (tuple[Tensor]): feature maps after FPN layers.\n                They are ordered from highest resolution first.\n        \"\"\"", "\n", "last_inner", "=", "getattr", "(", "self", ",", "self", ".", "inner_blocks", "[", "-", "1", "]", ")", "(", "x", "[", "-", "1", "]", ")", "\n", "results", "=", "[", "]", "\n", "results", ".", "append", "(", "getattr", "(", "self", ",", "self", ".", "layer_blocks", "[", "-", "1", "]", ")", "(", "last_inner", ")", ")", "\n", "for", "feature", ",", "inner_block", ",", "layer_block", "in", "zip", "(", "\n", "x", "[", ":", "-", "1", "]", "[", ":", ":", "-", "1", "]", ",", "self", ".", "inner_blocks", "[", ":", "-", "1", "]", "[", ":", ":", "-", "1", "]", ",", "self", ".", "layer_blocks", "[", ":", "-", "1", "]", "[", ":", ":", "-", "1", "]", "\n", ")", ":", "\n", "            ", "if", "not", "inner_block", ":", "\n", "                ", "continue", "\n", "", "inner_top_down", "=", "F", ".", "interpolate", "(", "last_inner", ",", "scale_factor", "=", "2", ",", "mode", "=", "\"nearest\"", ")", "\n", "inner_lateral", "=", "getattr", "(", "self", ",", "inner_block", ")", "(", "feature", ")", "\n", "# TODO use size instead of scale to make it robust to different sizes", "\n", "# inner_top_down = F.upsample(last_inner, size=inner_lateral.shape[-2:],", "\n", "# mode='bilinear', align_corners=False)", "\n", "last_inner", "=", "inner_lateral", "+", "inner_top_down", "\n", "results", ".", "insert", "(", "0", ",", "getattr", "(", "self", ",", "layer_block", ")", "(", "last_inner", ")", ")", "\n", "\n", "", "if", "isinstance", "(", "self", ".", "top_blocks", ",", "LastLevelP6P7", ")", ":", "\n", "            ", "last_results", "=", "self", ".", "top_blocks", "(", "x", "[", "-", "1", "]", ",", "results", "[", "-", "1", "]", ")", "\n", "results", ".", "extend", "(", "last_results", ")", "\n", "", "elif", "isinstance", "(", "self", ".", "top_blocks", ",", "LastLevelMaxPool", ")", ":", "\n", "            ", "last_results", "=", "self", ".", "top_blocks", "(", "results", "[", "-", "1", "]", ")", "\n", "results", ".", "extend", "(", "last_results", ")", "\n", "\n", "", "return", "tuple", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fpn.LastLevelMaxPool.forward": [[78, 80], ["torch.max_pool2d", "torch.max_pool2d"], "methods", ["None"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "[", "F", ".", "max_pool2d", "(", "x", ",", "1", ",", "2", ",", "0", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fpn.LastLevelP6P7.__init__": [[86, 94], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", "LastLevelP6P7", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "p6", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "3", ",", "2", ",", "1", ")", "\n", "self", ".", "p7", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "out_channels", ",", "3", ",", "2", ",", "1", ")", "\n", "for", "module", "in", "[", "self", ".", "p6", ",", "self", ".", "p7", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "module", ".", "weight", ",", "a", "=", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "0", ")", "\n", "", "self", ".", "use_P5", "=", "in_channels", "==", "out_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fpn.LastLevelP6P7.forward": [[95, 100], ["fpn.LastLevelP6P7.p6", "fpn.LastLevelP6P7.p7", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "c5", ",", "p5", ")", ":", "\n", "        ", "x", "=", "p5", "if", "self", ".", "use_P5", "else", "c5", "\n", "p6", "=", "self", ".", "p6", "(", "x", ")", "\n", "p7", "=", "self", ".", "p7", "(", "F", ".", "relu", "(", "p6", ")", ")", "\n", "return", "[", "p6", ",", "p7", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.ResNet.__init__": [[82, 133], ["torch.nn.Module.__init__", "stem_module", "resnet.ResNet._freeze_backbone", "resnet._make_stage", "resnet.ResNet.add_module", "resnet.ResNet.stages.append", "str", "int"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.ResNet._freeze_backbone", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet._make_stage"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# If we want to use the cfg in forward(), then we should make a copy", "\n", "# of it and store it for later use:", "\n", "# self.cfg = cfg.clone()", "\n", "\n", "# Translate string names to implementations", "\n", "stem_module", "=", "_STEM_MODULES", "[", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_FUNC", "]", "\n", "stage_specs", "=", "_STAGE_SPECS", "[", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "CONV_BODY", "]", "\n", "transformation_module", "=", "_TRANSFORMATION_MODULES", "[", "cfg", ".", "MODEL", ".", "RESNETS", ".", "TRANS_FUNC", "]", "\n", "\n", "# Construct the stem module", "\n", "self", ".", "stem", "=", "stem_module", "(", "cfg", ")", "\n", "\n", "# Constuct the specified ResNet stages", "\n", "num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", "\n", "width_per_group", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", "\n", "in_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", "\n", "stage2_bottleneck_channels", "=", "num_groups", "*", "width_per_group", "\n", "stage2_out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "\n", "self", ".", "stages", "=", "[", "]", "\n", "self", ".", "return_features", "=", "{", "}", "\n", "for", "stage_spec", "in", "stage_specs", ":", "\n", "            ", "name", "=", "\"layer\"", "+", "str", "(", "stage_spec", ".", "index", ")", "\n", "stage2_relative_factor", "=", "2", "**", "(", "stage_spec", ".", "index", "-", "1", ")", "\n", "bottleneck_channels", "=", "stage2_bottleneck_channels", "*", "stage2_relative_factor", "\n", "out_channels", "=", "stage2_out_channels", "*", "stage2_relative_factor", "\n", "stage_with_dcn", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STAGE_WITH_DCN", "[", "stage_spec", ".", "index", "-", "1", "]", "\n", "module", "=", "_make_stage", "(", "\n", "transformation_module", ",", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "stage_spec", ".", "block_count", ",", "\n", "num_groups", ",", "\n", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STRIDE_IN_1X1", ",", "\n", "first_stride", "=", "int", "(", "stage_spec", ".", "index", ">", "1", ")", "+", "1", ",", "\n", "dcn_config", "=", "{", "\n", "\"stage_with_dcn\"", ":", "stage_with_dcn", ",", "\n", "\"with_modulated_dcn\"", ":", "cfg", ".", "MODEL", ".", "RESNETS", ".", "WITH_MODULATED_DCN", ",", "\n", "\"deformable_groups\"", ":", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORMABLE_GROUPS", ",", "\n", "}", "\n", ")", "\n", "in_channels", "=", "out_channels", "\n", "self", ".", "add_module", "(", "name", ",", "module", ")", "\n", "self", ".", "stages", ".", "append", "(", "name", ")", "\n", "self", ".", "return_features", "[", "name", "]", "=", "stage_spec", ".", "return_features", "\n", "\n", "# Optionally freeze (requires_grad=False) parts of the backbone", "\n", "", "self", ".", "_freeze_backbone", "(", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "FREEZE_CONV_BODY_AT", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.ResNet._freeze_backbone": [[134, 144], ["range", "getattr.parameters", "getattr", "str"], "methods", ["None"], ["", "def", "_freeze_backbone", "(", "self", ",", "freeze_at", ")", ":", "\n", "        ", "if", "freeze_at", "<", "0", ":", "\n", "            ", "return", "\n", "", "for", "stage_index", "in", "range", "(", "freeze_at", ")", ":", "\n", "            ", "if", "stage_index", "==", "0", ":", "\n", "                ", "m", "=", "self", ".", "stem", "# stage 0 is the stem", "\n", "", "else", ":", "\n", "                ", "m", "=", "getattr", "(", "self", ",", "\"layer\"", "+", "str", "(", "stage_index", ")", ")", "\n", "", "for", "p", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.ResNet.forward": [[145, 153], ["resnet.ResNet.stem", "getattr", "outputs.append"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "outputs", "=", "[", "]", "\n", "x", "=", "self", ".", "stem", "(", "x", ")", "\n", "for", "stage_name", "in", "self", ".", "stages", ":", "\n", "            ", "x", "=", "getattr", "(", "self", ",", "stage_name", ")", "(", "x", ")", "\n", "if", "self", ".", "return_features", "[", "stage_name", "]", ":", "\n", "                ", "outputs", ".", "append", "(", "x", ")", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.ResNetHead.__init__": [[156, 200], ["torch.nn.Module.__init__", "resnet._make_stage", "resnet.ResNetHead.add_module", "resnet.ResNetHead.stages.append", "str", "int"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet._make_stage"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "block_module", ",", "\n", "stages", ",", "\n", "num_groups", "=", "1", ",", "\n", "width_per_group", "=", "64", ",", "\n", "stride_in_1x1", "=", "True", ",", "\n", "stride_init", "=", "None", ",", "\n", "res2_out_channels", "=", "256", ",", "\n", "dilation", "=", "1", ",", "\n", "dcn_config", "=", "{", "}", "\n", ")", ":", "\n", "        ", "super", "(", "ResNetHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "stage2_relative_factor", "=", "2", "**", "(", "stages", "[", "0", "]", ".", "index", "-", "1", ")", "\n", "stage2_bottleneck_channels", "=", "num_groups", "*", "width_per_group", "\n", "out_channels", "=", "res2_out_channels", "*", "stage2_relative_factor", "\n", "in_channels", "=", "out_channels", "//", "2", "\n", "bottleneck_channels", "=", "stage2_bottleneck_channels", "*", "stage2_relative_factor", "\n", "\n", "block_module", "=", "_TRANSFORMATION_MODULES", "[", "block_module", "]", "\n", "\n", "self", ".", "stages", "=", "[", "]", "\n", "stride", "=", "stride_init", "\n", "for", "stage", "in", "stages", ":", "\n", "            ", "name", "=", "\"layer\"", "+", "str", "(", "stage", ".", "index", ")", "\n", "if", "not", "stride", ":", "\n", "                ", "stride", "=", "int", "(", "stage", ".", "index", ">", "1", ")", "+", "1", "\n", "", "module", "=", "_make_stage", "(", "\n", "block_module", ",", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "stage", ".", "block_count", ",", "\n", "num_groups", ",", "\n", "stride_in_1x1", ",", "\n", "first_stride", "=", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "dcn_config", "=", "dcn_config", "\n", ")", "\n", "stride", "=", "None", "\n", "self", ".", "add_module", "(", "name", ",", "module", ")", "\n", "self", ".", "stages", ".", "append", "(", "name", ")", "\n", "", "self", ".", "out_channels", "=", "out_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.ResNetHead.forward": [[201, 205], ["getattr"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "stage", "in", "self", ".", "stages", ":", "\n", "            ", "x", "=", "getattr", "(", "self", ",", "stage", ")", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.Bottleneck.__init__": [[240, 323], ["torch.nn.Module.__init__", "vc_rcnn.layers.Conv2d", "norm_func", "dcn_config.get", "norm_func", "vc_rcnn.layers.Conv2d", "norm_func", "torch.nn.Sequential", "torch.nn.Sequential", "dcn_config.get", "dcn_config.get", "vc_rcnn.layers.DFConv2d", "vc_rcnn.layers.Conv2d", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "vc_rcnn.layers.Conv2d", "norm_func", "modules.modules", "isinstance", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "num_groups", ",", "\n", "stride_in_1x1", ",", "\n", "stride", ",", "\n", "dilation", ",", "\n", "norm_func", ",", "\n", "dcn_config", "\n", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "downsample", "=", "None", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "down_stride", "=", "stride", "if", "dilation", "==", "1", "else", "1", "\n", "self", ".", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "Conv2d", "(", "\n", "in_channels", ",", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "down_stride", ",", "bias", "=", "False", "\n", ")", ",", "\n", "norm_func", "(", "out_channels", ")", ",", "\n", ")", "\n", "for", "modules", "in", "[", "self", ".", "downsample", ",", "]", ":", "\n", "                ", "for", "l", "in", "modules", ".", "modules", "(", ")", ":", "\n", "                    ", "if", "isinstance", "(", "l", ",", "Conv2d", ")", ":", "\n", "                        ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "l", ".", "weight", ",", "a", "=", "1", ")", "\n", "\n", "", "", "", "", "if", "dilation", ">", "1", ":", "\n", "            ", "stride", "=", "1", "# reset to be 1", "\n", "\n", "# The original MSRA ResNet models have stride in the first 1x1 conv", "\n", "# The subsequent fb.torch.resnet and Caffe2 ResNe[X]t implementations have", "\n", "# stride in the 3x3 conv", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n", "bias", "=", "False", ",", "\n", ")", "\n", "self", ".", "bn1", "=", "norm_func", "(", "bottleneck_channels", ")", "\n", "# TODO: specify init for the above", "\n", "with_dcn", "=", "dcn_config", ".", "get", "(", "\"stage_with_dcn\"", ",", "False", ")", "\n", "if", "with_dcn", ":", "\n", "            ", "deformable_groups", "=", "dcn_config", ".", "get", "(", "\"deformable_groups\"", ",", "1", ")", "\n", "with_modulated_dcn", "=", "dcn_config", ".", "get", "(", "\"with_modulated_dcn\"", ",", "False", ")", "\n", "self", ".", "conv2", "=", "DFConv2d", "(", "\n", "bottleneck_channels", ",", "\n", "bottleneck_channels", ",", "\n", "with_modulated_dcn", "=", "with_modulated_dcn", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "groups", "=", "num_groups", ",", "\n", "dilation", "=", "dilation", ",", "\n", "deformable_groups", "=", "deformable_groups", ",", "\n", "bias", "=", "False", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv2", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "padding", "=", "dilation", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "num_groups", ",", "\n", "dilation", "=", "dilation", "\n", ")", "\n", "nn", ".", "init", ".", "kaiming_uniform_", "(", "self", ".", "conv2", ".", "weight", ",", "a", "=", "1", ")", "\n", "\n", "", "self", ".", "bn2", "=", "norm_func", "(", "bottleneck_channels", ")", "\n", "\n", "self", ".", "conv3", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "bn3", "=", "norm_func", "(", "out_channels", ")", "\n", "\n", "for", "l", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv3", ",", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "l", ".", "weight", ",", "a", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.Bottleneck.forward": [[324, 345], ["resnet.Bottleneck.conv1", "resnet.Bottleneck.bn1", "torch.relu_", "torch.relu_", "resnet.Bottleneck.conv2", "resnet.Bottleneck.bn2", "torch.relu_", "torch.relu_", "resnet.Bottleneck.conv3", "resnet.Bottleneck.bn3", "torch.relu_", "torch.relu_", "resnet.Bottleneck.downsample"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.BaseStem.__init__": [[348, 360], ["torch.nn.Module.__init__", "vc_rcnn.layers.Conv2d", "norm_func", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "norm_func", ")", ":", "\n", "        ", "super", "(", "BaseStem", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "3", ",", "out_channels", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "bn1", "=", "norm_func", "(", "out_channels", ")", "\n", "\n", "for", "l", "in", "[", "self", ".", "conv1", ",", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "l", ".", "weight", ",", "a", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.BaseStem.forward": [[361, 367], ["resnet.BaseStem.conv1", "resnet.BaseStem.bn1", "torch.relu_", "torch.relu_", "torch.max_pool2d", "torch.max_pool2d"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "F", ".", "relu_", "(", "x", ")", "\n", "x", "=", "F", ".", "max_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.BottleneckWithFixedBatchNorm.__init__": [[370, 391], ["resnet.Bottleneck.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "num_groups", "=", "1", ",", "\n", "stride_in_1x1", "=", "True", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "dcn_config", "=", "{", "}", "\n", ")", ":", "\n", "        ", "super", "(", "BottleneckWithFixedBatchNorm", ",", "self", ")", ".", "__init__", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "bottleneck_channels", "=", "bottleneck_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "num_groups", "=", "num_groups", ",", "\n", "stride_in_1x1", "=", "stride_in_1x1", ",", "\n", "stride", "=", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "norm_func", "=", "FrozenBatchNorm2d", ",", "\n", "dcn_config", "=", "dcn_config", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.StemWithFixedBatchNorm.__init__": [[395, 398], ["resnet.BaseStem.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", "StemWithFixedBatchNorm", ",", "self", ")", ".", "__init__", "(", "\n", "cfg", ",", "norm_func", "=", "FrozenBatchNorm2d", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.BottleneckWithGN.__init__": [[402, 423], ["resnet.Bottleneck.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "num_groups", "=", "1", ",", "\n", "stride_in_1x1", "=", "True", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "dcn_config", "=", "{", "}", "\n", ")", ":", "\n", "        ", "super", "(", "BottleneckWithGN", ",", "self", ")", ".", "__init__", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "bottleneck_channels", "=", "bottleneck_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "num_groups", "=", "num_groups", ",", "\n", "stride_in_1x1", "=", "stride_in_1x1", ",", "\n", "stride", "=", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "norm_func", "=", "group_norm", ",", "\n", "dcn_config", "=", "dcn_config", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet.StemWithGN.__init__": [[427, 429], ["resnet.BaseStem.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", "StemWithGN", ",", "self", ")", ".", "__init__", "(", "cfg", ",", "norm_func", "=", "group_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.resnet._make_stage": [[207, 237], ["range", "torch.nn.Sequential", "blocks.append", "transformation_module"], "function", ["None"], ["", "", "def", "_make_stage", "(", "\n", "transformation_module", ",", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "block_count", ",", "\n", "num_groups", ",", "\n", "stride_in_1x1", ",", "\n", "first_stride", ",", "\n", "dilation", "=", "1", ",", "\n", "dcn_config", "=", "{", "}", "\n", ")", ":", "\n", "    ", "blocks", "=", "[", "]", "\n", "stride", "=", "first_stride", "\n", "for", "_", "in", "range", "(", "block_count", ")", ":", "\n", "        ", "blocks", ".", "append", "(", "\n", "transformation_module", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "num_groups", ",", "\n", "stride_in_1x1", ",", "\n", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "dcn_config", "=", "dcn_config", "\n", ")", "\n", ")", "\n", "stride", "=", "1", "\n", "in_channels", "=", "out_channels", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "blocks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.Identity.__init__": [[196, 211], ["torch.Module.__init__", "fbnet_builder.ConvBNRelu"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "C_in", ",", "C_out", ",", "stride", ")", ":", "\n", "        ", "super", "(", "Identity", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "(", "\n", "ConvBNRelu", "(", "\n", "C_in", ",", "\n", "C_out", ",", "\n", "kernel", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "pad", "=", "0", ",", "\n", "no_bias", "=", "1", ",", "\n", "use_relu", "=", "\"relu\"", ",", "\n", "bn_type", "=", "\"bn\"", ",", "\n", ")", "\n", "if", "C_in", "!=", "C_out", "or", "stride", "!=", "1", "\n", "else", "None", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.Identity.forward": [[213, 219], ["fbnet_builder.Identity.conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "conv", ":", "\n", "            ", "out", "=", "self", ".", "conv", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "x", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.CascadeConv3x3.__init__": [[222, 233], ["torch.Sequential.__init__", "vc_rcnn.layers.Conv2d", "vc_rcnn.layers.BatchNorm2d", "torch.ReLU", "torch.ReLU", "vc_rcnn.layers.Conv2d", "vc_rcnn.layers.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "C_in", ",", "C_out", ",", "stride", ")", ":", "\n", "        ", "assert", "stride", "in", "[", "1", ",", "2", "]", "\n", "ops", "=", "[", "\n", "Conv2d", "(", "C_in", ",", "C_in", ",", "3", ",", "stride", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "C_in", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "Conv2d", "(", "C_in", ",", "C_out", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "C_out", ")", ",", "\n", "]", "\n", "super", "(", "CascadeConv3x3", ",", "self", ")", ".", "__init__", "(", "*", "ops", ")", "\n", "self", ".", "res_connect", "=", "(", "stride", "==", "1", ")", "and", "(", "C_in", "==", "C_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.CascadeConv3x3.forward": [[234, 239], ["super().forward"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "y", "=", "super", "(", "CascadeConv3x3", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "if", "self", ".", "res_connect", ":", "\n", "            ", "y", "+=", "x", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.Shift.__init__": [[242, 268], ["torch.Module.__init__", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "fbnet_builder.Shift.register_parameter", "torch.Parameter", "torch.Parameter", "range"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "C", ",", "kernel_size", ",", "stride", ",", "padding", ")", ":", "\n", "        ", "super", "(", "Shift", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "C", "=", "C", "\n", "kernel", "=", "torch", ".", "zeros", "(", "(", "C", ",", "1", ",", "kernel_size", ",", "kernel_size", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ch_idx", "=", "0", "\n", "\n", "assert", "stride", "in", "[", "1", ",", "2", "]", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "dilation", "=", "1", "\n", "\n", "hks", "=", "kernel_size", "//", "2", "\n", "ksq", "=", "kernel_size", "**", "2", "\n", "\n", "for", "i", "in", "range", "(", "kernel_size", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "kernel_size", ")", ":", "\n", "                ", "if", "i", "==", "hks", "and", "j", "==", "hks", ":", "\n", "                    ", "num_ch", "=", "C", "//", "ksq", "+", "C", "%", "ksq", "\n", "", "else", ":", "\n", "                    ", "num_ch", "=", "C", "//", "ksq", "\n", "", "kernel", "[", "ch_idx", ":", "ch_idx", "+", "num_ch", ",", "0", ",", "i", ",", "j", "]", "=", "1", "\n", "ch_idx", "+=", "num_ch", "\n", "\n", "", "", "self", ".", "register_parameter", "(", "\"bias\"", ",", "None", ")", "\n", "self", ".", "kernel", "=", "nn", ".", "Parameter", "(", "kernel", ",", "requires_grad", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.Shift.forward": [[269, 293], ["vc_rcnn.layers.misc._NewEmptyTensorOp.apply", "x.numel", "torch.functional.conv2d", "torch.functional.conv2d", "zip"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "return", "nn", ".", "functional", ".", "conv2d", "(", "\n", "x", ",", "\n", "self", ".", "kernel", ",", "\n", "self", ".", "bias", ",", "\n", "(", "self", ".", "stride", ",", "self", ".", "stride", ")", ",", "\n", "(", "self", ".", "padding", ",", "self", ".", "padding", ")", ",", "\n", "self", ".", "dilation", ",", "\n", "self", ".", "C", ",", "# groups", "\n", ")", "\n", "\n", "", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "d", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "d", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "\n", "(", "self", ".", "padding", ",", "self", ".", "dilation", ")", ",", "\n", "(", "self", ".", "dilation", ",", "self", ".", "dilation", ")", ",", "\n", "(", "self", ".", "kernel_size", ",", "self", ".", "kernel_size", ")", ",", "\n", "(", "self", ".", "stride", ",", "self", ".", "stride", ")", ",", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "C", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.ShiftBlock5x5.__init__": [[296, 314], ["fbnet_builder._get_divisible_by", "torch.Sequential.__init__", "vc_rcnn.layers.Conv2d", "vc_rcnn.layers.BatchNorm2d", "torch.ReLU", "torch.ReLU", "fbnet_builder.Shift", "vc_rcnn.layers.Conv2d", "vc_rcnn.layers.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._get_divisible_by", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "C_in", ",", "C_out", ",", "expansion", ",", "stride", ")", ":", "\n", "        ", "assert", "stride", "in", "[", "1", ",", "2", "]", "\n", "self", ".", "res_connect", "=", "(", "stride", "==", "1", ")", "and", "(", "C_in", "==", "C_out", ")", "\n", "\n", "C_mid", "=", "_get_divisible_by", "(", "C_in", "*", "expansion", ",", "8", ",", "8", ")", "\n", "\n", "ops", "=", "[", "\n", "# pw", "\n", "Conv2d", "(", "C_in", ",", "C_mid", ",", "1", ",", "1", ",", "0", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "C_mid", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "# shift", "\n", "Shift", "(", "C_mid", ",", "5", ",", "stride", ",", "2", ")", ",", "\n", "# pw-linear", "\n", "Conv2d", "(", "C_mid", ",", "C_out", ",", "1", ",", "1", ",", "0", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "C_out", ")", ",", "\n", "]", "\n", "super", "(", "ShiftBlock5x5", ",", "self", ")", ".", "__init__", "(", "*", "ops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.ShiftBlock5x5.forward": [[315, 320], ["super().forward"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "y", "=", "super", "(", "ShiftBlock5x5", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "if", "self", ".", "res_connect", ":", "\n", "            ", "y", "+=", "x", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.ChannelShuffle.__init__": [[323, 326], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "groups", ")", ":", "\n", "        ", "super", "(", "ChannelShuffle", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "groups", "=", "groups", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.ChannelShuffle.forward": [[327, 339], ["x.size", "x.view().permute().contiguous().view", "x.view().permute().contiguous", "x.view().permute", "x.view", "int"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Channel shuffle: [N,C,H,W] -> [N,g,C/g,H,W] -> [N,C/g,g,H,w] -> [N,C,H,W]\"\"\"", "\n", "N", ",", "C", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "g", "=", "self", ".", "groups", "\n", "assert", "C", "%", "g", "==", "0", ",", "\"Incompatible group size {} for input channel {}\"", ".", "format", "(", "\n", "g", ",", "C", "\n", ")", "\n", "return", "(", "\n", "x", ".", "view", "(", "N", ",", "g", ",", "int", "(", "C", "/", "g", ")", ",", "H", ",", "W", ")", "\n", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", "\n", ".", "contiguous", "(", ")", "\n", ".", "view", "(", "N", ",", "C", ",", "H", ",", "W", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.ConvBNRelu.__init__": [[343, 395], ["torch.Sequential.__init__", "isinstance", "vc_rcnn.layers.Conv2d", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "fbnet_builder.ConvBNRelu.add_module", "torch.init.constant_", "torch.init.constant_", "vc_rcnn.layers.BatchNorm2d", "fbnet_builder.ConvBNRelu.add_module", "fbnet_builder.ConvBNRelu.add_module", "len", "torch.GroupNorm", "torch.GroupNorm", "torch.ReLU", "torch.ReLU", "vc_rcnn.layers.FrozenBatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_depth", ",", "\n", "output_depth", ",", "\n", "kernel", ",", "\n", "stride", ",", "\n", "pad", ",", "\n", "no_bias", ",", "\n", "use_relu", ",", "\n", "bn_type", ",", "\n", "group", "=", "1", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "super", "(", "ConvBNRelu", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "use_relu", "in", "[", "\"relu\"", ",", "None", "]", "\n", "if", "isinstance", "(", "bn_type", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "assert", "len", "(", "bn_type", ")", "==", "2", "\n", "assert", "bn_type", "[", "0", "]", "==", "\"gn\"", "\n", "gn_group", "=", "bn_type", "[", "1", "]", "\n", "bn_type", "=", "bn_type", "[", "0", "]", "\n", "", "assert", "bn_type", "in", "[", "\"bn\"", ",", "\"af\"", ",", "\"gn\"", ",", "None", "]", "\n", "assert", "stride", "in", "[", "1", ",", "2", ",", "4", "]", "\n", "\n", "op", "=", "Conv2d", "(", "\n", "input_depth", ",", "\n", "output_depth", ",", "\n", "kernel_size", "=", "kernel", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "pad", ",", "\n", "bias", "=", "not", "no_bias", ",", "\n", "groups", "=", "group", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", "\n", ")", "\n", "nn", ".", "init", ".", "kaiming_normal_", "(", "op", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "if", "op", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "op", ".", "bias", ",", "0.0", ")", "\n", "", "self", ".", "add_module", "(", "\"conv\"", ",", "op", ")", "\n", "\n", "if", "bn_type", "==", "\"bn\"", ":", "\n", "            ", "bn_op", "=", "BatchNorm2d", "(", "output_depth", ")", "\n", "", "elif", "bn_type", "==", "\"gn\"", ":", "\n", "            ", "bn_op", "=", "nn", ".", "GroupNorm", "(", "num_groups", "=", "gn_group", ",", "num_channels", "=", "output_depth", ")", "\n", "", "elif", "bn_type", "==", "\"af\"", ":", "\n", "            ", "bn_op", "=", "FrozenBatchNorm2d", "(", "output_depth", ")", "\n", "", "if", "bn_type", "is", "not", "None", ":", "\n", "            ", "self", ".", "add_module", "(", "\"bn\"", ",", "bn_op", ")", "\n", "\n", "", "if", "use_relu", "==", "\"relu\"", ":", "\n", "            ", "self", ".", "add_module", "(", "\"relu\"", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.SEModule.__init__": [[400, 408], ["torch.Module.__init__", "max", "vc_rcnn.layers.Conv2d", "vc_rcnn.layers.Conv2d", "torch.Sequential", "torch.Sequential", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.ReLU", "torch.ReLU", "torch.Sigmoid", "torch.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "C", ")", ":", "\n", "        ", "super", "(", "SEModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "mid", "=", "max", "(", "C", "//", "self", ".", "reduction", ",", "8", ")", "\n", "conv1", "=", "Conv2d", "(", "C", ",", "mid", ",", "1", ",", "1", ",", "0", ")", "\n", "conv2", "=", "Conv2d", "(", "mid", ",", "C", ",", "1", ",", "1", ",", "0", ")", "\n", "\n", "self", ".", "op", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", ",", "conv1", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "conv2", ",", "nn", ".", "Sigmoid", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.SEModule.forward": [[410, 412], ["fbnet_builder.SEModule.op"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "op", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.Upsample.__init__": [[415, 420], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "scale_factor", ",", "mode", ",", "align_corners", "=", "None", ")", ":", "\n", "        ", "super", "(", "Upsample", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "scale", "=", "scale_factor", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "align_corners", "=", "align_corners", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.Upsample.forward": [[421, 425], ["vc_rcnn.layers.interpolate"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.interpolate"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "interpolate", "(", "\n", "x", ",", "scale_factor", "=", "self", ".", "scale", ",", "mode", "=", "self", ".", "mode", ",", "\n", "align_corners", "=", "self", ".", "align_corners", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.IRFBlock.__init__": [[446, 548], ["torch.Module.__init__", "int", "fbnet_builder._get_divisible_by", "fbnet_builder.ConvBNRelu", "fbnet_builder._get_upsample_op", "fbnet_builder.ConvBNRelu", "torch.Sequential", "torch.Sequential", "fbnet_builder.ChannelShuffle", "fbnet_builder.SEModule", "torch.Sequential", "torch.Sequential", "fbnet_builder.ConvBNRelu", "fbnet_builder.ConvBNRelu", "torch.Sequential", "torch.Sequential", "fbnet_builder.ConvBNRelu", "collections.OrderedDict"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._get_divisible_by", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._get_upsample_op"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_depth", ",", "\n", "output_depth", ",", "\n", "expansion", ",", "\n", "stride", ",", "\n", "bn_type", "=", "\"bn\"", ",", "\n", "kernel", "=", "3", ",", "\n", "width_divisor", "=", "1", ",", "\n", "shuffle_type", "=", "None", ",", "\n", "pw_group", "=", "1", ",", "\n", "se", "=", "False", ",", "\n", "cdw", "=", "False", ",", "\n", "dw_skip_bn", "=", "False", ",", "\n", "dw_skip_relu", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", "IRFBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "kernel", "in", "[", "1", ",", "3", ",", "5", ",", "7", "]", ",", "kernel", "\n", "\n", "self", ".", "use_res_connect", "=", "stride", "==", "1", "and", "input_depth", "==", "output_depth", "\n", "self", ".", "output_depth", "=", "output_depth", "\n", "\n", "mid_depth", "=", "int", "(", "input_depth", "*", "expansion", ")", "\n", "mid_depth", "=", "_get_divisible_by", "(", "mid_depth", ",", "width_divisor", ",", "width_divisor", ")", "\n", "\n", "# pw", "\n", "self", ".", "pw", "=", "ConvBNRelu", "(", "\n", "input_depth", ",", "\n", "mid_depth", ",", "\n", "kernel", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "pad", "=", "0", ",", "\n", "no_bias", "=", "1", ",", "\n", "use_relu", "=", "\"relu\"", ",", "\n", "bn_type", "=", "bn_type", ",", "\n", "group", "=", "pw_group", ",", "\n", ")", "\n", "\n", "# negative stride to do upsampling", "\n", "self", ".", "upscale", ",", "stride", "=", "_get_upsample_op", "(", "stride", ")", "\n", "\n", "# dw", "\n", "if", "kernel", "==", "1", ":", "\n", "            ", "self", ".", "dw", "=", "nn", ".", "Sequential", "(", ")", "\n", "", "elif", "cdw", ":", "\n", "            ", "dw1", "=", "ConvBNRelu", "(", "\n", "mid_depth", ",", "\n", "mid_depth", ",", "\n", "kernel", "=", "kernel", ",", "\n", "stride", "=", "stride", ",", "\n", "pad", "=", "(", "kernel", "//", "2", ")", ",", "\n", "group", "=", "mid_depth", ",", "\n", "no_bias", "=", "1", ",", "\n", "use_relu", "=", "\"relu\"", ",", "\n", "bn_type", "=", "bn_type", ",", "\n", ")", "\n", "dw2", "=", "ConvBNRelu", "(", "\n", "mid_depth", ",", "\n", "mid_depth", ",", "\n", "kernel", "=", "kernel", ",", "\n", "stride", "=", "1", ",", "\n", "pad", "=", "(", "kernel", "//", "2", ")", ",", "\n", "group", "=", "mid_depth", ",", "\n", "no_bias", "=", "1", ",", "\n", "use_relu", "=", "\"relu\"", "if", "not", "dw_skip_relu", "else", "None", ",", "\n", "bn_type", "=", "bn_type", "if", "not", "dw_skip_bn", "else", "None", ",", "\n", ")", "\n", "self", ".", "dw", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "(", "\"dw1\"", ",", "dw1", ")", ",", "(", "\"dw2\"", ",", "dw2", ")", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "dw", "=", "ConvBNRelu", "(", "\n", "mid_depth", ",", "\n", "mid_depth", ",", "\n", "kernel", "=", "kernel", ",", "\n", "stride", "=", "stride", ",", "\n", "pad", "=", "(", "kernel", "//", "2", ")", ",", "\n", "group", "=", "mid_depth", ",", "\n", "no_bias", "=", "1", ",", "\n", "use_relu", "=", "\"relu\"", "if", "not", "dw_skip_relu", "else", "None", ",", "\n", "bn_type", "=", "bn_type", "if", "not", "dw_skip_bn", "else", "None", ",", "\n", ")", "\n", "\n", "# pw-linear", "\n", "", "self", ".", "pwl", "=", "ConvBNRelu", "(", "\n", "mid_depth", ",", "\n", "output_depth", ",", "\n", "kernel", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "pad", "=", "0", ",", "\n", "no_bias", "=", "1", ",", "\n", "use_relu", "=", "None", ",", "\n", "bn_type", "=", "bn_type", ",", "\n", "group", "=", "pw_group", ",", "\n", ")", "\n", "\n", "self", ".", "shuffle_type", "=", "shuffle_type", "\n", "if", "shuffle_type", "is", "not", "None", ":", "\n", "            ", "self", ".", "shuffle", "=", "ChannelShuffle", "(", "pw_group", ")", "\n", "\n", "", "self", ".", "se4", "=", "SEModule", "(", "output_depth", ")", "if", "se", "else", "nn", ".", "Sequential", "(", ")", "\n", "\n", "self", ".", "output_depth", "=", "output_depth", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.IRFBlock.forward": [[549, 561], ["fbnet_builder.IRFBlock.pw", "fbnet_builder.IRFBlock.dw", "fbnet_builder.IRFBlock.pwl", "fbnet_builder.IRFBlock.se4", "fbnet_builder.IRFBlock.shuffle", "fbnet_builder.IRFBlock.upscale"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "y", "=", "self", ".", "pw", "(", "x", ")", "\n", "if", "self", ".", "shuffle_type", "==", "\"mid\"", ":", "\n", "            ", "y", "=", "self", ".", "shuffle", "(", "y", ")", "\n", "", "if", "self", ".", "upscale", "is", "not", "None", ":", "\n", "            ", "y", "=", "self", ".", "upscale", "(", "y", ")", "\n", "", "y", "=", "self", ".", "dw", "(", "y", ")", "\n", "y", "=", "self", ".", "pwl", "(", "y", ")", "\n", "if", "self", ".", "use_res_connect", ":", "\n", "            ", "y", "+=", "x", "\n", "", "y", "=", "self", ".", "se4", "(", "y", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.__init__": [[694, 708], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "width_ratio", ",", "\n", "bn_type", "=", "\"bn\"", ",", "\n", "width_divisor", "=", "1", ",", "\n", "dw_skip_bn", "=", "False", ",", "\n", "dw_skip_relu", "=", "False", ",", "\n", ")", ":", "\n", "        ", "self", ".", "width_ratio", "=", "width_ratio", "\n", "self", ".", "last_depth", "=", "-", "1", "\n", "self", ".", "bn_type", "=", "bn_type", "\n", "self", ".", "width_divisor", "=", "width_divisor", "\n", "self", ".", "dw_skip_bn", "=", "dw_skip_bn", "\n", "self", ".", "dw_skip_relu", "=", "dw_skip_relu", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_first": [[709, 731], ["fbnet_builder.FBNetBuilder._get_divisible_width", "fbnet_builder.ConvBNRelu", "len", "int", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder._get_divisible_width"], ["", "def", "add_first", "(", "self", ",", "stage_info", ",", "dim_in", "=", "3", ",", "pad", "=", "True", ")", ":", "\n", "# stage_info: [c, s, kernel]", "\n", "        ", "assert", "len", "(", "stage_info", ")", ">=", "2", "\n", "channel", "=", "stage_info", "[", "0", "]", "\n", "stride", "=", "stage_info", "[", "1", "]", "\n", "out_depth", "=", "self", ".", "_get_divisible_width", "(", "int", "(", "channel", "*", "self", ".", "width_ratio", ")", ")", "\n", "kernel", "=", "3", "\n", "if", "len", "(", "stage_info", ")", ">", "2", ":", "\n", "            ", "kernel", "=", "stage_info", "[", "2", "]", "\n", "\n", "", "out", "=", "ConvBNRelu", "(", "\n", "dim_in", ",", "\n", "out_depth", ",", "\n", "kernel", "=", "kernel", ",", "\n", "stride", "=", "stride", ",", "\n", "pad", "=", "kernel", "//", "2", "if", "pad", "else", "0", ",", "\n", "no_bias", "=", "1", ",", "\n", "use_relu", "=", "\"relu\"", ",", "\n", "bn_type", "=", "self", ".", "bn_type", ",", "\n", ")", "\n", "self", ".", "last_depth", "=", "out_depth", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_blocks": [[732, 753], ["collections.OrderedDict", "torch.Sequential", "torch.Sequential", "isinstance", "all", "fbnet_builder.FBNetBuilder.add_ir_block", "isinstance"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_ir_block"], ["", "def", "add_blocks", "(", "self", ",", "blocks", ")", ":", "\n", "        ", "\"\"\" blocks: [{}, {}, ...]\n        \"\"\"", "\n", "assert", "isinstance", "(", "blocks", ",", "list", ")", "and", "all", "(", "\n", "isinstance", "(", "x", ",", "dict", ")", "for", "x", "in", "blocks", "\n", ")", ",", "blocks", "\n", "\n", "modules", "=", "OrderedDict", "(", ")", "\n", "for", "block", "in", "blocks", ":", "\n", "            ", "stage_idx", "=", "block", "[", "\"stage_idx\"", "]", "\n", "block_idx", "=", "block", "[", "\"block_idx\"", "]", "\n", "block_op_type", "=", "block", "[", "\"block_op_type\"", "]", "\n", "tcns", "=", "block", "[", "\"block\"", "]", "\n", "n", "=", "tcns", "[", "2", "]", "\n", "assert", "n", "==", "1", "\n", "nnblock", "=", "self", ".", "add_ir_block", "(", "tcns", ",", "[", "block_op_type", "]", ")", "\n", "nn_name", "=", "\"xif{}_{}\"", ".", "format", "(", "stage_idx", ",", "block_idx", ")", "\n", "assert", "nn_name", "not", "in", "modules", "\n", "modules", "[", "nn_name", "]", "=", "nnblock", "\n", "", "ret", "=", "nn", ".", "Sequential", "(", "modules", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_last": [[754, 790], ["fbnet_builder.FBNetBuilder._get_divisible_width", "fbnet_builder.ConvBNRelu", "len", "torch.Sequential", "torch.Sequential", "int", "int", "torch.Sequential", "torch.Sequential", "int"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder._get_divisible_width"], ["", "def", "add_last", "(", "self", ",", "stage_info", ")", ":", "\n", "        ", "\"\"\" skip last layer if channel_scale == 0\n            use the same output channel if channel_scale < 0\n        \"\"\"", "\n", "assert", "len", "(", "stage_info", ")", "==", "2", "\n", "channels", "=", "stage_info", "[", "0", "]", "\n", "channel_scale", "=", "stage_info", "[", "1", "]", "\n", "\n", "if", "channel_scale", "==", "0.0", ":", "\n", "            ", "return", "nn", ".", "Sequential", "(", ")", "\n", "\n", "", "if", "channel_scale", ">", "0", ":", "\n", "            ", "last_channel", "=", "(", "\n", "int", "(", "channels", "*", "self", ".", "width_ratio", ")", "if", "self", ".", "width_ratio", ">", "1.0", "else", "channels", "\n", ")", "\n", "last_channel", "=", "int", "(", "last_channel", "*", "channel_scale", ")", "\n", "", "else", ":", "\n", "            ", "last_channel", "=", "int", "(", "self", ".", "last_depth", "*", "(", "-", "channel_scale", ")", ")", "\n", "", "last_channel", "=", "self", ".", "_get_divisible_width", "(", "last_channel", ")", "\n", "\n", "if", "last_channel", "==", "0", ":", "\n", "            ", "return", "nn", ".", "Sequential", "(", ")", "\n", "\n", "", "dim_in", "=", "self", ".", "last_depth", "\n", "ret", "=", "ConvBNRelu", "(", "\n", "dim_in", ",", "\n", "last_channel", ",", "\n", "kernel", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "pad", "=", "0", ",", "\n", "no_bias", "=", "1", ",", "\n", "use_relu", "=", "\"relu\"", ",", "\n", "bn_type", "=", "self", ".", "bn_type", ",", "\n", ")", "\n", "self", ".", "last_depth", "=", "last_channel", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder._add_ir_block": [[795, 810], ["None"], "methods", ["None"], ["", "def", "_add_ir_block", "(", "\n", "self", ",", "dim_in", ",", "dim_out", ",", "stride", ",", "expand_ratio", ",", "block_op_type", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "ret", "=", "PRIMITIVES", "[", "block_op_type", "]", "(", "\n", "dim_in", ",", "\n", "dim_out", ",", "\n", "expansion", "=", "expand_ratio", ",", "\n", "stride", "=", "stride", ",", "\n", "bn_type", "=", "self", ".", "bn_type", ",", "\n", "width_divisor", "=", "self", ".", "width_divisor", ",", "\n", "dw_skip_bn", "=", "self", ".", "dw_skip_bn", ",", "\n", "dw_skip_relu", "=", "self", ".", "dw_skip_relu", ",", "\n", "**", "kwargs", "\n", ")", "\n", "return", "ret", ",", "ret", ".", "output_depth", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_ir_block": [[811, 826], ["fbnet_builder.FBNetBuilder._get_divisible_width", "fbnet_builder.FBNetBuilder._add_ir_block", "int"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder._get_divisible_width", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder._add_ir_block"], ["", "def", "add_ir_block", "(", "self", ",", "tcns", ",", "block_op_types", ",", "**", "kwargs", ")", ":", "\n", "        ", "t", ",", "c", ",", "n", ",", "s", "=", "tcns", "\n", "assert", "n", "==", "1", "\n", "out_depth", "=", "self", ".", "_get_divisible_width", "(", "int", "(", "c", "*", "self", ".", "width_ratio", ")", ")", "\n", "dim_in", "=", "self", ".", "last_depth", "\n", "op", ",", "ret_depth", "=", "self", ".", "_add_ir_block", "(", "\n", "dim_in", ",", "\n", "out_depth", ",", "\n", "stride", "=", "s", ",", "\n", "expand_ratio", "=", "t", ",", "\n", "block_op_type", "=", "block_op_types", "[", "0", "]", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "last_depth", "=", "ret_depth", "\n", "return", "op", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder._get_divisible_width": [[827, 830], ["fbnet_builder._get_divisible_by", "int"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._get_divisible_by"], ["", "def", "_get_divisible_width", "(", "self", ",", "width", ")", ":", "\n", "        ", "ret", "=", "_get_divisible_by", "(", "int", "(", "width", ")", ",", "self", ".", "width_divisor", ",", "self", ".", "width_divisor", ")", "\n", "return", "ret", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._py2_round": [[26, 28], ["math.floor", "math.ceil"], "function", ["None"], ["def", "_py2_round", "(", "x", ")", ":", "\n", "    ", "return", "math", ".", "floor", "(", "x", "+", "0.5", ")", "if", "x", ">=", "0.0", "else", "math", ".", "ceil", "(", "x", "-", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._get_divisible_by": [[30, 35], ["int", "int", "fbnet_builder._py2_round"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._py2_round"], ["", "def", "_get_divisible_by", "(", "num", ",", "divisible_by", ",", "min_val", ")", ":", "\n", "    ", "ret", "=", "int", "(", "num", ")", "\n", "if", "divisible_by", ">", "0", "and", "num", "%", "divisible_by", "!=", "0", ":", "\n", "        ", "ret", "=", "int", "(", "(", "_py2_round", "(", "num", "/", "divisible_by", ")", "or", "min_val", ")", "*", "divisible_by", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._get_upsample_op": [[428, 443], ["isinstance", "fbnet_builder.Upsample", "isinstance", "all", "isinstance"], "function", ["None"], ["", "", "def", "_get_upsample_op", "(", "stride", ")", ":", "\n", "    ", "assert", "(", "\n", "stride", "in", "[", "1", ",", "2", ",", "4", "]", "\n", "or", "stride", "in", "[", "-", "1", ",", "-", "2", ",", "-", "4", "]", "\n", "or", "(", "isinstance", "(", "stride", ",", "tuple", ")", "and", "all", "(", "x", "in", "[", "-", "1", ",", "-", "2", ",", "-", "4", "]", "for", "x", "in", "stride", ")", ")", "\n", ")", "\n", "\n", "scales", "=", "stride", "\n", "ret", "=", "None", "\n", "if", "isinstance", "(", "stride", ",", "tuple", ")", "or", "stride", "<", "0", ":", "\n", "        ", "scales", "=", "[", "-", "x", "for", "x", "in", "stride", "]", "if", "isinstance", "(", "stride", ",", "tuple", ")", "else", "-", "stride", "\n", "stride", "=", "1", "\n", "ret", "=", "Upsample", "(", "scale_factor", "=", "scales", ",", "mode", "=", "\"nearest\"", ",", "align_corners", "=", "None", ")", "\n", "\n", "", "return", "ret", ",", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._expand_block_cfg": [[563, 572], ["isinstance", "range", "copy.deepcopy", "ret.append"], "function", ["None"], ["", "", "def", "_expand_block_cfg", "(", "block_cfg", ")", ":", "\n", "    ", "assert", "isinstance", "(", "block_cfg", ",", "list", ")", "\n", "ret", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "block_cfg", "[", "2", "]", ")", ":", "\n", "        ", "cur", "=", "copy", ".", "deepcopy", "(", "block_cfg", ")", "\n", "cur", "[", "2", "]", "=", "1", "\n", "cur", "[", "3", "]", "=", "1", "if", "idx", ">=", "1", "else", "cur", "[", "3", "]", "\n", "ret", ".", "append", "(", "cur", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.expand_stage_cfg": [[574, 581], ["isinstance", "fbnet_builder._expand_block_cfg"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._expand_block_cfg"], ["", "def", "expand_stage_cfg", "(", "stage_cfg", ")", ":", "\n", "    ", "\"\"\" For a single stage \"\"\"", "\n", "assert", "isinstance", "(", "stage_cfg", ",", "list", ")", "\n", "ret", "=", "[", "]", "\n", "for", "x", "in", "stage_cfg", ":", "\n", "        ", "ret", "+=", "_expand_block_cfg", "(", "x", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.expand_stages_cfg": [[583, 590], ["isinstance", "ret.append", "fbnet_builder.expand_stage_cfg"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.expand_stage_cfg"], ["", "def", "expand_stages_cfg", "(", "stage_cfgs", ")", ":", "\n", "    ", "\"\"\" For a list of stages \"\"\"", "\n", "assert", "isinstance", "(", "stage_cfgs", ",", "list", ")", "\n", "ret", "=", "[", "]", "\n", "for", "x", "in", "stage_cfgs", ":", "\n", "        ", "ret", ".", "append", "(", "expand_stage_cfg", "(", "x", ")", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._block_cfgs_to_list": [[592, 601], ["isinstance", "enumerate", "fbnet_builder.expand_stage_cfg", "enumerate", "ret.append"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.expand_stage_cfg"], ["", "def", "_block_cfgs_to_list", "(", "block_cfgs", ")", ":", "\n", "    ", "assert", "isinstance", "(", "block_cfgs", ",", "list", ")", "\n", "ret", "=", "[", "]", "\n", "for", "stage_idx", ",", "stage", "in", "enumerate", "(", "block_cfgs", ")", ":", "\n", "        ", "stage", "=", "expand_stage_cfg", "(", "stage", ")", "\n", "for", "block_idx", ",", "block", "in", "enumerate", "(", "stage", ")", ":", "\n", "            ", "cur", "=", "{", "\"stage_idx\"", ":", "stage_idx", ",", "\"block_idx\"", ":", "block_idx", ",", "\"block\"", ":", "block", "}", "\n", "ret", ".", "append", "(", "cur", ")", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._add_to_arch": [[603, 639], ["enumerate", "isinstance", "all", "isinstance", "all", "enumerate", "isinstance", "isinstance"], "function", ["None"], ["", "def", "_add_to_arch", "(", "arch", ",", "info", ",", "name", ")", ":", "\n", "    ", "\"\"\" arch = [{block_0}, {block_1}, ...]\n        info = [\n            # stage 0\n            [\n                block0_info,\n                block1_info,\n                ...\n            ], ...\n        ]\n        convert to:\n        arch = [\n            {\n                block_0,\n                name: block0_info,\n            },\n            {\n                block_1,\n                name: block1_info,\n            }, ...\n        ]\n    \"\"\"", "\n", "assert", "isinstance", "(", "arch", ",", "list", ")", "and", "all", "(", "isinstance", "(", "x", ",", "dict", ")", "for", "x", "in", "arch", ")", "\n", "assert", "isinstance", "(", "info", ",", "list", ")", "and", "all", "(", "isinstance", "(", "x", ",", "list", ")", "for", "x", "in", "info", ")", "\n", "idx", "=", "0", "\n", "for", "stage_idx", ",", "stage", "in", "enumerate", "(", "info", ")", ":", "\n", "        ", "for", "block_idx", ",", "block", "in", "enumerate", "(", "stage", ")", ":", "\n", "            ", "assert", "(", "\n", "arch", "[", "idx", "]", "[", "\"stage_idx\"", "]", "==", "stage_idx", "\n", "and", "arch", "[", "idx", "]", "[", "\"block_idx\"", "]", "==", "block_idx", "\n", ")", ",", "\"Index ({}, {}) does not match for block {}\"", ".", "format", "(", "\n", "stage_idx", ",", "block_idx", ",", "arch", "[", "idx", "]", "\n", ")", "\n", "assert", "name", "not", "in", "arch", "[", "idx", "]", "\n", "arch", "[", "idx", "]", "[", "name", "]", "=", "block", "\n", "idx", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.unify_arch_def": [[641, 669], ["copy.deepcopy", "copy.deepcopy.update", "fbnet_builder._block_cfgs_to_list", "fbnet_builder._add_to_arch"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._block_cfgs_to_list", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder._add_to_arch"], ["", "", "", "def", "unify_arch_def", "(", "arch_def", ")", ":", "\n", "    ", "\"\"\" unify the arch_def to:\n        {\n            ...,\n            \"arch\": [\n                {\n                    \"stage_idx\": idx,\n                    \"block_idx\": idx,\n                    ...\n                },\n                {}, ...\n            ]\n        }\n    \"\"\"", "\n", "ret", "=", "copy", ".", "deepcopy", "(", "arch_def", ")", "\n", "\n", "assert", "\"block_cfg\"", "in", "arch_def", "and", "\"stages\"", "in", "arch_def", "[", "\"block_cfg\"", "]", "\n", "assert", "\"stages\"", "not", "in", "ret", "\n", "# copy 'first', 'last' etc. inside arch_def['block_cfg'] to ret", "\n", "ret", ".", "update", "(", "{", "x", ":", "arch_def", "[", "\"block_cfg\"", "]", "[", "x", "]", "for", "x", "in", "arch_def", "[", "\"block_cfg\"", "]", "}", ")", "\n", "ret", "[", "\"stages\"", "]", "=", "_block_cfgs_to_list", "(", "arch_def", "[", "\"block_cfg\"", "]", "[", "\"stages\"", "]", ")", "\n", "del", "ret", "[", "\"block_cfg\"", "]", "\n", "\n", "assert", "\"block_op_type\"", "in", "arch_def", "\n", "_add_to_arch", "(", "ret", "[", "\"stages\"", "]", ",", "arch_def", "[", "\"block_op_type\"", "]", ",", "\"block_op_type\"", ")", "\n", "del", "ret", "[", "\"block_op_type\"", "]", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.get_num_stages": [[671, 677], ["max"], "function", ["None"], ["", "def", "get_num_stages", "(", "arch_def", ")", ":", "\n", "    ", "ret", "=", "0", "\n", "for", "x", "in", "arch_def", "[", "\"stages\"", "]", ":", "\n", "        ", "ret", "=", "max", "(", "x", "[", "\"stage_idx\"", "]", ",", "ret", ")", "\n", "", "ret", "=", "ret", "+", "1", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.get_blocks": [[679, 691], ["copy.deepcopy", "ret[].append"], "function", ["None"], ["", "def", "get_blocks", "(", "arch_def", ",", "stage_indices", "=", "None", ",", "block_indices", "=", "None", ")", ":", "\n", "    ", "ret", "=", "copy", ".", "deepcopy", "(", "arch_def", ")", "\n", "ret", "[", "\"stages\"", "]", "=", "[", "]", "\n", "for", "block", "in", "arch_def", "[", "\"stages\"", "]", ":", "\n", "        ", "keep", "=", "True", "\n", "if", "stage_indices", "not", "in", "(", "None", ",", "[", "]", ")", "and", "block", "[", "\"stage_idx\"", "]", "not", "in", "stage_indices", ":", "\n", "            ", "keep", "=", "False", "\n", "", "if", "block_indices", "not", "in", "(", "None", ",", "[", "]", ")", "and", "block", "[", "\"block_idx\"", "]", "not", "in", "block_indices", ":", "\n", "            ", "keep", "=", "False", "\n", "", "if", "keep", ":", "\n", "            ", "ret", "[", "\"stages\"", "]", ".", "append", "(", "block", ")", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.FBNetTrunk.__init__": [[80, 87], ["torch.Module.__init__", "builder.add_first", "fbnet._get_trunk_cfg", "builder.add_blocks"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_first", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet._get_trunk_cfg", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_blocks"], ["    ", "def", "__init__", "(", "\n", "self", ",", "builder", ",", "arch_def", ",", "dim_in", ",", "\n", ")", ":", "\n", "        ", "super", "(", "FBNetTrunk", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "first", "=", "builder", ".", "add_first", "(", "arch_def", "[", "\"first\"", "]", ",", "dim_in", "=", "dim_in", ")", "\n", "trunk_cfg", "=", "_get_trunk_cfg", "(", "arch_def", ")", "\n", "self", ".", "stages", "=", "builder", ".", "add_blocks", "(", "trunk_cfg", "[", "\"stages\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.FBNetTrunk.forward": [[89, 94], ["fbnet.FBNetTrunk.first", "fbnet.FBNetTrunk.stages"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "y", "=", "self", ".", "first", "(", "x", ")", "\n", "y", "=", "self", ".", "stages", "(", "y", ")", "\n", "ret", "=", "[", "y", "]", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.FBNetRPNHead.__init__": [[122, 137], ["torch.Module.__init__", "fbnet._get_rpn_stage", "builder.add_blocks", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet._get_rpn_stage", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_blocks"], ["    ", "def", "__init__", "(", "\n", "self", ",", "cfg", ",", "in_channels", ",", "builder", ",", "arch_def", ",", "\n", ")", ":", "\n", "        ", "super", "(", "FBNetRPNHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "in_channels", "==", "builder", ".", "last_depth", "\n", "\n", "rpn_bn_type", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "RPN_BN_TYPE", "\n", "if", "len", "(", "rpn_bn_type", ")", ">", "0", ":", "\n", "            ", "builder", ".", "bn_type", "=", "rpn_bn_type", "\n", "\n", "", "use_blocks", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "RPN_HEAD_BLOCKS", "\n", "stages", "=", "_get_rpn_stage", "(", "arch_def", ",", "use_blocks", ")", "\n", "\n", "self", ".", "head", "=", "builder", ".", "add_blocks", "(", "stages", ")", "\n", "self", ".", "out_channels", "=", "builder", ".", "last_depth", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.FBNetRPNHead.forward": [[138, 141], ["fbnet.FBNetRPNHead.head"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "[", "self", ".", "head", "(", "y", ")", "for", "y", "in", "x", "]", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.FBNetROIHead.__init__": [[175, 203], ["torch.Module.__init__", "isinstance", "vc_rcnn.modeling.poolers.make_pooler", "fbnet._get_head_stage", "builder.add_blocks", "copy.deepcopy", "builder.add_last", "torch.Sequential", "collections.OrderedDict"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.poolers.make_pooler", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet._get_head_stage", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_blocks", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.FBNetBuilder.add_last"], ["    ", "def", "__init__", "(", "\n", "self", ",", "cfg", ",", "in_channels", ",", "builder", ",", "arch_def", ",", "\n", "head_name", ",", "use_blocks", ",", "stride_init", ",", "last_layer_scale", ",", "\n", ")", ":", "\n", "        ", "super", "(", "FBNetROIHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "in_channels", "==", "builder", ".", "last_depth", "\n", "assert", "isinstance", "(", "use_blocks", ",", "list", ")", "\n", "\n", "head_cfg_name", "=", "ARCH_CFG_NAME_MAPPING", "[", "head_name", "]", "\n", "self", ".", "pooler", "=", "poolers", ".", "make_pooler", "(", "cfg", ",", "head_cfg_name", ")", "\n", "\n", "stage", "=", "_get_head_stage", "(", "arch_def", ",", "head_name", ",", "use_blocks", ")", "\n", "\n", "assert", "stride_init", "in", "[", "0", ",", "1", ",", "2", "]", "\n", "if", "stride_init", "!=", "0", ":", "\n", "            ", "stage", "[", "0", "]", "[", "\"block\"", "]", "[", "3", "]", "=", "stride_init", "\n", "", "blocks", "=", "builder", ".", "add_blocks", "(", "stage", ")", "\n", "\n", "last_info", "=", "copy", ".", "deepcopy", "(", "arch_def", "[", "\"last\"", "]", ")", "\n", "last_info", "[", "1", "]", "=", "last_layer_scale", "\n", "last", "=", "builder", ".", "add_last", "(", "last_info", ")", "\n", "\n", "self", ".", "head", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "\"blocks\"", ",", "blocks", ")", ",", "\n", "(", "\"last\"", ",", "last", ")", "\n", "]", ")", ")", "\n", "\n", "self", ".", "out_channels", "=", "builder", ".", "last_depth", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.FBNetROIHead.forward": [[204, 208], ["fbnet.FBNetROIHead.pooler", "fbnet.FBNetROIHead.head"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "proposals", ")", ":", "\n", "        ", "x", "=", "self", ".", "pooler", "(", "x", ",", "proposals", ")", "\n", "x", "=", "self", ".", "head", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.create_builder": [[21, 69], ["fbnet_builder.unify_arch_def", "json.loads.get", "logger.info", "fbnet_builder.FBNetBuilder", "len", "json.loads", "len", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.unify_arch_def", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info"], ["def", "create_builder", "(", "cfg", ")", ":", "\n", "    ", "bn_type", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "BN_TYPE", "\n", "if", "bn_type", "==", "\"gn\"", ":", "\n", "        ", "bn_type", "=", "(", "bn_type", ",", "cfg", ".", "GROUP_NORM", ".", "NUM_GROUPS", ")", "\n", "", "factor", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "SCALE_FACTOR", "\n", "\n", "arch", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "ARCH", "\n", "arch_def", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "ARCH_DEF", "\n", "if", "len", "(", "arch_def", ")", ">", "0", ":", "\n", "        ", "arch_def", "=", "json", ".", "loads", "(", "arch_def", ")", "\n", "", "if", "arch", "in", "modeldef", ".", "MODEL_ARCH", ":", "\n", "        ", "if", "len", "(", "arch_def", ")", ">", "0", ":", "\n", "            ", "assert", "(", "\n", "arch_def", "==", "modeldef", ".", "MODEL_ARCH", "[", "arch", "]", "\n", ")", ",", "\"Two architectures with the same name {},\\n{},\\n{}\"", ".", "format", "(", "\n", "arch", ",", "arch_def", ",", "modeldef", ".", "MODEL_ARCH", "[", "arch", "]", "\n", ")", "\n", "", "arch_def", "=", "modeldef", ".", "MODEL_ARCH", "[", "arch", "]", "\n", "", "else", ":", "\n", "        ", "assert", "arch_def", "is", "not", "None", "and", "len", "(", "arch_def", ")", ">", "0", "\n", "", "arch_def", "=", "mbuilder", ".", "unify_arch_def", "(", "arch_def", ")", "\n", "\n", "rpn_stride", "=", "arch_def", ".", "get", "(", "\"rpn_stride\"", ",", "None", ")", "\n", "if", "rpn_stride", "is", "not", "None", ":", "\n", "        ", "assert", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "ANCHOR_STRIDE", "[", "0", "]", "==", "rpn_stride", "\n", ")", ",", "\"Needs to set cfg.MODEL.RPN.ANCHOR_STRIDE to {}, got {}\"", ".", "format", "(", "\n", "rpn_stride", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "ANCHOR_STRIDE", "\n", ")", "\n", "", "width_divisor", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "WIDTH_DIVISOR", "\n", "dw_skip_bn", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "DW_CONV_SKIP_BN", "\n", "dw_skip_relu", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "DW_CONV_SKIP_RELU", "\n", "\n", "logger", ".", "info", "(", "\n", "\"Building fbnet model with arch {} (without scaling):\\n{}\"", ".", "format", "(", "\n", "arch", ",", "arch_def", "\n", ")", "\n", ")", "\n", "\n", "builder", "=", "mbuilder", ".", "FBNetBuilder", "(", "\n", "width_ratio", "=", "factor", ",", "\n", "bn_type", "=", "bn_type", ",", "\n", "width_divisor", "=", "width_divisor", ",", "\n", "dw_skip_bn", "=", "dw_skip_bn", ",", "\n", "dw_skip_relu", "=", "dw_skip_relu", ",", "\n", ")", "\n", "\n", "return", "builder", ",", "arch_def", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet._get_trunk_cfg": [[71, 77], ["fbnet_builder.get_num_stages", "arch_def.get", "fbnet_builder.get_blocks", "range"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.get_num_stages", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.get_blocks"], ["", "def", "_get_trunk_cfg", "(", "arch_def", ")", ":", "\n", "    ", "\"\"\" Get all stages except the last one \"\"\"", "\n", "num_stages", "=", "mbuilder", ".", "get_num_stages", "(", "arch_def", ")", "\n", "trunk_stages", "=", "arch_def", ".", "get", "(", "\"backbone\"", ",", "range", "(", "num_stages", "-", "1", ")", ")", "\n", "ret", "=", "mbuilder", ".", "get_blocks", "(", "arch_def", ",", "stage_indices", "=", "trunk_stages", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.add_conv_body": [[96, 105], ["vc_rcnn.modeling.registry.BACKBONES.register", "fbnet.create_builder", "fbnet.FBNetTrunk", "torch.Sequential", "collections.OrderedDict"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.create_builder"], ["", "", "@", "registry", ".", "BACKBONES", ".", "register", "(", "\"FBNet\"", ")", "\n", "def", "add_conv_body", "(", "cfg", ",", "dim_in", "=", "3", ")", ":", "\n", "    ", "builder", ",", "arch_def", "=", "create_builder", "(", "cfg", ")", "\n", "\n", "body", "=", "FBNetTrunk", "(", "builder", ",", "arch_def", ",", "dim_in", ")", "\n", "model", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "(", "\"body\"", ",", "body", ")", "]", ")", ")", "\n", "model", ".", "out_channels", "=", "builder", ".", "last_depth", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet._get_rpn_stage": [[107, 119], ["arch_def.get", "fbnet_builder.get_blocks", "logger.warn", "len", "range", "fbnet_builder.get_blocks"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.get_blocks", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.get_blocks"], ["", "def", "_get_rpn_stage", "(", "arch_def", ",", "num_blocks", ")", ":", "\n", "    ", "rpn_stage", "=", "arch_def", ".", "get", "(", "\"rpn\"", ")", "\n", "ret", "=", "mbuilder", ".", "get_blocks", "(", "arch_def", ",", "stage_indices", "=", "rpn_stage", ")", "\n", "if", "num_blocks", ">", "0", ":", "\n", "        ", "logger", ".", "warn", "(", "'Use last {} blocks in {} as rpn'", ".", "format", "(", "num_blocks", ",", "ret", ")", ")", "\n", "block_count", "=", "len", "(", "ret", "[", "\"stages\"", "]", ")", "\n", "assert", "num_blocks", "<=", "block_count", ",", "\"use block {}, block count {}\"", ".", "format", "(", "\n", "num_blocks", ",", "block_count", "\n", ")", "\n", "blocks", "=", "range", "(", "block_count", "-", "num_blocks", ",", "block_count", ")", "\n", "ret", "=", "mbuilder", ".", "get_blocks", "(", "ret", ",", "block_indices", "=", "blocks", ")", "\n", "", "return", "ret", "[", "\"stages\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.add_rpn_head": [[143, 155], ["vc_rcnn.modeling.registry.RPN_HEADS.register", "fbnet.create_builder", "fbnet.FBNetRPNHead", "vc_rcnn.modeling.rpn.rpn.RPNHeadConvRegressor", "torch.Sequential"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.create_builder"], ["", "", "@", "registry", ".", "RPN_HEADS", ".", "register", "(", "\"FBNet.rpn_head\"", ")", "\n", "def", "add_rpn_head", "(", "cfg", ",", "in_channels", ",", "num_anchors", ")", ":", "\n", "    ", "builder", ",", "model_arch", "=", "create_builder", "(", "cfg", ")", "\n", "builder", ".", "last_depth", "=", "in_channels", "\n", "\n", "assert", "in_channels", "==", "builder", ".", "last_depth", "\n", "# builder.name_prefix = \"[rpn]\"", "\n", "\n", "rpn_feature", "=", "FBNetRPNHead", "(", "cfg", ",", "in_channels", ",", "builder", ",", "model_arch", ")", "\n", "rpn_regressor", "=", "rpn", ".", "RPNHeadConvRegressor", "(", "\n", "cfg", ",", "rpn_feature", ".", "out_channels", ",", "num_anchors", ")", "\n", "return", "nn", ".", "Sequential", "(", "rpn_feature", ",", "rpn_regressor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet._get_head_stage": [[157, 164], ["arch.get", "fbnet_builder.get_blocks"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet_builder.get_blocks"], ["", "def", "_get_head_stage", "(", "arch", ",", "head_name", ",", "blocks", ")", ":", "\n", "# use default name 'head' if the specific name 'head_name' does not existed", "\n", "    ", "if", "head_name", "not", "in", "arch", ":", "\n", "        ", "head_name", "=", "\"head\"", "\n", "", "head_stage", "=", "arch", ".", "get", "(", "head_name", ")", "\n", "ret", "=", "mbuilder", ".", "get_blocks", "(", "arch", ",", "stage_indices", "=", "head_stage", ",", "block_indices", "=", "blocks", ")", "\n", "return", "ret", "[", "\"stages\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.add_roi_head": [[210, 222], ["vc_rcnn.modeling.registry.ROI_BOX_FEATURE_EXTRACTORS.register", "fbnet.create_builder", "fbnet.FBNetROIHead"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.create_builder"], ["", "", "@", "registry", ".", "ROI_BOX_FEATURE_EXTRACTORS", ".", "register", "(", "\"FBNet.roi_head\"", ")", "\n", "def", "add_roi_head", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "builder", ",", "model_arch", "=", "create_builder", "(", "cfg", ")", "\n", "builder", ".", "last_depth", "=", "in_channels", "\n", "# builder.name_prefix = \"_[bbox]_\"", "\n", "\n", "return", "FBNetROIHead", "(", "\n", "cfg", ",", "in_channels", ",", "builder", ",", "model_arch", ",", "\n", "head_name", "=", "\"bbox\"", ",", "\n", "use_blocks", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "DET_HEAD_BLOCKS", ",", "\n", "stride_init", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "DET_HEAD_STRIDE", ",", "\n", "last_layer_scale", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "DET_HEAD_LAST_SCALE", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.add_roi_head_keypoints": [[225, 237], ["vc_rcnn.modeling.registry.ROI_KEYPOINT_FEATURE_EXTRACTORS.register", "fbnet.create_builder", "fbnet.FBNetROIHead"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.create_builder"], ["", "@", "registry", ".", "ROI_KEYPOINT_FEATURE_EXTRACTORS", ".", "register", "(", "\"FBNet.roi_head_keypoints\"", ")", "\n", "def", "add_roi_head_keypoints", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "builder", ",", "model_arch", "=", "create_builder", "(", "cfg", ")", "\n", "builder", ".", "last_depth", "=", "in_channels", "\n", "# builder.name_prefix = \"_[kpts]_\"", "\n", "\n", "return", "FBNetROIHead", "(", "\n", "cfg", ",", "in_channels", ",", "builder", ",", "model_arch", ",", "\n", "head_name", "=", "\"kpts\"", ",", "\n", "use_blocks", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "KPTS_HEAD_BLOCKS", ",", "\n", "stride_init", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "KPTS_HEAD_STRIDE", ",", "\n", "last_layer_scale", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "KPTS_HEAD_LAST_SCALE", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.add_roi_head_mask": [[240, 252], ["vc_rcnn.modeling.registry.ROI_MASK_FEATURE_EXTRACTORS.register", "fbnet.create_builder", "fbnet.FBNetROIHead"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.fbnet.create_builder"], ["", "@", "registry", ".", "ROI_MASK_FEATURE_EXTRACTORS", ".", "register", "(", "\"FBNet.roi_head_mask\"", ")", "\n", "def", "add_roi_head_mask", "(", "cfg", ",", "in_channels", ")", ":", "\n", "    ", "builder", ",", "model_arch", "=", "create_builder", "(", "cfg", ")", "\n", "builder", ".", "last_depth", "=", "in_channels", "\n", "# builder.name_prefix = \"_[mask]_\"", "\n", "\n", "return", "FBNetROIHead", "(", "\n", "cfg", ",", "in_channels", ",", "builder", ",", "model_arch", ",", "\n", "head_name", "=", "\"mask\"", ",", "\n", "use_blocks", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "MASK_HEAD_BLOCKS", ",", "\n", "stride_init", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "MASK_HEAD_STRIDE", ",", "\n", "last_layer_scale", "=", "cfg", ".", "MODEL", ".", "FBNET", ".", "MASK_HEAD_LAST_SCALE", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.backbone.build_resnet_backbone": [[12, 21], ["vc_rcnn.modeling.registry.BACKBONES.register", "vc_rcnn.modeling.registry.BACKBONES.register", "vc_rcnn.modeling.registry.BACKBONES.register", "vc_rcnn.modeling.registry.BACKBONES.register", "resnet.ResNet", "torch.nn.Sequential", "collections.OrderedDict"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register"], ["@", "registry", ".", "BACKBONES", ".", "register", "(", "\"R-50-C4\"", ")", "\n", "@", "registry", ".", "BACKBONES", ".", "register", "(", "\"R-50-C5\"", ")", "\n", "@", "registry", ".", "BACKBONES", ".", "register", "(", "\"R-101-C4\"", ")", "\n", "@", "registry", ".", "BACKBONES", ".", "register", "(", "\"R-101-C5\"", ")", "\n", "def", "build_resnet_backbone", "(", "cfg", ")", ":", "\n", "    ", "body", "=", "resnet", ".", "ResNet", "(", "cfg", ")", "\n", "model", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "(", "\"body\"", ",", "body", ")", "]", ")", ")", "\n", "model", ".", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "BACKBONE_OUT_CHANNELS", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.backbone.build_resnet_fpn_backbone": [[23, 46], ["vc_rcnn.modeling.registry.BACKBONES.register", "vc_rcnn.modeling.registry.BACKBONES.register", "vc_rcnn.modeling.registry.BACKBONES.register", "resnet.ResNet", "fpn.FPN", "torch.nn.Sequential", "collections.OrderedDict", "vc_rcnn.modeling.make_layers.conv_with_kaiming_uniform", "fpn.LastLevelMaxPool"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.conv_with_kaiming_uniform"], ["", "@", "registry", ".", "BACKBONES", ".", "register", "(", "\"R-50-FPN\"", ")", "\n", "@", "registry", ".", "BACKBONES", ".", "register", "(", "\"R-101-FPN\"", ")", "\n", "@", "registry", ".", "BACKBONES", ".", "register", "(", "\"R-152-FPN\"", ")", "\n", "def", "build_resnet_fpn_backbone", "(", "cfg", ")", ":", "\n", "    ", "body", "=", "resnet", ".", "ResNet", "(", "cfg", ")", "\n", "in_channels_stage2", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "BACKBONE_OUT_CHANNELS", "\n", "fpn", "=", "fpn_module", ".", "FPN", "(", "\n", "in_channels_list", "=", "[", "\n", "in_channels_stage2", ",", "\n", "in_channels_stage2", "*", "2", ",", "\n", "in_channels_stage2", "*", "4", ",", "\n", "in_channels_stage2", "*", "8", ",", "\n", "]", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "conv_block", "=", "conv_with_kaiming_uniform", "(", "\n", "cfg", ".", "MODEL", ".", "FPN", ".", "USE_GN", ",", "cfg", ".", "MODEL", ".", "FPN", ".", "USE_RELU", "\n", ")", ",", "\n", "top_blocks", "=", "fpn_module", ".", "LastLevelMaxPool", "(", ")", ",", "\n", ")", "\n", "model", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "(", "\"body\"", ",", "body", ")", ",", "(", "\"fpn\"", ",", "fpn", ")", "]", ")", ")", "\n", "model", ".", "out_channels", "=", "out_channels", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.backbone.build_resnet_fpn_p3p7_backbone": [[48, 72], ["vc_rcnn.modeling.registry.BACKBONES.register", "vc_rcnn.modeling.registry.BACKBONES.register", "resnet.ResNet", "fpn.FPN", "torch.nn.Sequential", "collections.OrderedDict", "vc_rcnn.modeling.make_layers.conv_with_kaiming_uniform", "fpn.LastLevelP6P7"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.make_layers.conv_with_kaiming_uniform"], ["", "@", "registry", ".", "BACKBONES", ".", "register", "(", "\"R-50-FPN-RETINANET\"", ")", "\n", "@", "registry", ".", "BACKBONES", ".", "register", "(", "\"R-101-FPN-RETINANET\"", ")", "\n", "def", "build_resnet_fpn_p3p7_backbone", "(", "cfg", ")", ":", "\n", "    ", "body", "=", "resnet", ".", "ResNet", "(", "cfg", ")", "\n", "in_channels_stage2", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "BACKBONE_OUT_CHANNELS", "\n", "in_channels_p6p7", "=", "in_channels_stage2", "*", "8", "if", "cfg", ".", "MODEL", ".", "RETINANET", ".", "USE_C5", "else", "out_channels", "\n", "fpn", "=", "fpn_module", ".", "FPN", "(", "\n", "in_channels_list", "=", "[", "\n", "0", ",", "\n", "in_channels_stage2", "*", "2", ",", "\n", "in_channels_stage2", "*", "4", ",", "\n", "in_channels_stage2", "*", "8", ",", "\n", "]", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "conv_block", "=", "conv_with_kaiming_uniform", "(", "\n", "cfg", ".", "MODEL", ".", "FPN", ".", "USE_GN", ",", "cfg", ".", "MODEL", ".", "FPN", ".", "USE_RELU", "\n", ")", ",", "\n", "top_blocks", "=", "fpn_module", ".", "LastLevelP6P7", "(", "in_channels_p6p7", ",", "out_channels", ")", ",", "\n", ")", "\n", "model", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "(", "\"body\"", ",", "body", ")", ",", "(", "\"fpn\"", ",", "fpn", ")", "]", ")", ")", "\n", "model", ".", "out_channels", "=", "out_channels", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.backbone.build_backbone": [[74, 80], ["None"], "function", ["None"], ["", "def", "build_backbone", "(", "cfg", ")", ":", "\n", "    ", "assert", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "CONV_BODY", "in", "registry", ".", "BACKBONES", ",", "\"cfg.MODEL.BACKBONE.CONV_BODY: {} are not registered in registry\"", ".", "format", "(", "\n", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "CONV_BODY", "\n", ")", "\n", "return", "registry", ".", "BACKBONES", "[", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "CONV_BODY", "]", "(", "cfg", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.detector.detectors.build_detection_model": [[8, 11], ["meta_arch"], "function", ["None"], ["def", "build_detection_model", "(", "cfg", ")", ":", "\n", "    ", "meta_arch", "=", "_DETECTION_META_ARCHITECTURES", "[", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "]", "\n", "return", "meta_arch", "(", "cfg", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.detector.generalized_rcnn.GeneralizedRCNN.__init__": [[26, 35], ["torch.nn.Module.__init__", "backbone.build_backbone", "roi_heads.roi_heads.build_roi_heads"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.backbone.backbone.build_backbone", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.roi_heads.roi_heads.build_roi_heads"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", "GeneralizedRCNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "\"\"\"\n        Please note that here we disgard the rpn network since we needn't to detect the spatial coordinate of objects\n        \"\"\"", "\n", "# self.rpn = build_rpn(cfg, self.backbone.out_channels)", "\n", "self", ".", "roi_heads", "=", "build_roi_heads", "(", "cfg", ",", "self", ".", "backbone", ".", "out_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.detector.generalized_rcnn.GeneralizedRCNN.forward": [[36, 75], ["vc_rcnn.structures.image_list.to_image_list", "generalized_rcnn.GeneralizedRCNN.backbone", "ValueError", "features[].get_device", "generalized_rcnn.GeneralizedRCNN.roi_heads", "losses.update", "target.to"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.image_list.to_image_list", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "forward", "(", "self", ",", "images", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            images (list[Tensor] or ImageList): images to be processed\n            targets (list[BoxList]): ground-truth boxes present in the image (optional)\n\n        Returns:\n            result (list[BoxList] or dict[Tensor]): the output from the model.\n                During training, it returns a dict[Tensor] which contains the losses.\n                During testing, it returns list[BoxList] contains additional fields\n                like `scores`, `labels` and `mask` (for Mask R-CNN models).\n\n        \"\"\"", "\n", "if", "self", ".", "training", "and", "targets", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"In training mode, targets should be passed\"", ")", "\n", "", "images", "=", "to_image_list", "(", "images", ")", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensors", ")", "\n", "\n", "# we directly use bounding box coordinates from ground truth label", "\n", "if", "self", ".", "training", ":", "\n", "            ", "proposals", "=", "[", "target", "for", "target", "in", "targets", "]", "\n", "", "else", ":", "\n", "            ", "devices", "=", "features", "[", "0", "]", ".", "get_device", "(", ")", "\n", "proposals", "=", "[", "target", ".", "to", "(", "devices", ")", "for", "target", "in", "targets", "]", "\n", "", "if", "self", ".", "roi_heads", ":", "\n", "            ", "x", ",", "result", ",", "detector_losses", "=", "self", ".", "roi_heads", "(", "features", ",", "proposals", ",", "targets", ")", "\n", "", "else", ":", "\n", "# RPN-only models don't have roi_heads", "\n", "            ", "x", "=", "features", "\n", "result", "=", "proposals", "\n", "detector_losses", "=", "{", "}", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "{", "}", "\n", "losses", ".", "update", "(", "detector_losses", ")", "\n", "# losses.update(proposal_losses)", "\n", "return", "losses", "\n", "\n", "", "return", "result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.__init__": [[38, 112], ["isinstance", "isinstance", "tuple", "len", "[].type_as.clone", "isinstance", "len", "len", "isinstance", "len", "torch.empty", "isinstance", "[].type_as.masks.clone", "RuntimeError", "torch.stack().clone", "isinstance", "isinstance", "pycocotools.decode", "torch.tensor().permute", "RuntimeError", "type", "torch.stack", "pycocotools.frPyObjects", "tuple", "rle_sizes.count", "len", "[].type_as", "torch.tensor", "type", "vc_rcnn.layers.misc.interpolate", "masks[].float"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.interpolate"], ["def", "__init__", "(", "self", ",", "masks", ",", "size", ")", ":", "\n", "        ", "\"\"\"\n            Arguments:\n                masks: Either torch.tensor of [num_instances, H, W]\n                    or list of torch.tensors of [H, W] with num_instances elems,\n                    or RLE (Run Length Encoding) - interpreted as list of dicts,\n                    or BinaryMaskList.\n                size: absolute image size, width first\n\n            After initialization, a hard copy will be made, to leave the\n            initializing source data intact.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "size", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "len", "(", "size", ")", "==", "2", "\n", "\n", "if", "isinstance", "(", "masks", ",", "torch", ".", "Tensor", ")", ":", "\n", "# The raw data representation is passed as argument", "\n", "            ", "masks", "=", "masks", ".", "clone", "(", ")", "\n", "", "elif", "isinstance", "(", "masks", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "                ", "masks", "=", "torch", ".", "empty", "(", "[", "0", ",", "size", "[", "1", "]", ",", "size", "[", "0", "]", "]", ")", "# num_instances = 0!", "\n", "", "elif", "isinstance", "(", "masks", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "masks", "=", "torch", ".", "stack", "(", "masks", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "", "elif", "isinstance", "(", "masks", "[", "0", "]", ",", "dict", ")", "and", "\"counts\"", "in", "masks", "[", "0", "]", ":", "\n", "                ", "if", "(", "isinstance", "(", "masks", "[", "0", "]", "[", "\"counts\"", "]", ",", "(", "list", ",", "tuple", ")", ")", ")", ":", "\n", "                    ", "masks", "=", "mask_utils", ".", "frPyObjects", "(", "masks", ",", "size", "[", "1", "]", ",", "size", "[", "0", "]", ")", "\n", "# RLE interpretation", "\n", "", "rle_sizes", "=", "[", "tuple", "(", "inst", "[", "\"size\"", "]", ")", "for", "inst", "in", "masks", "]", "\n", "\n", "masks", "=", "mask_utils", ".", "decode", "(", "masks", ")", "# [h, w, n]", "\n", "masks", "=", "torch", ".", "tensor", "(", "masks", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "# [n, h, w]", "\n", "\n", "assert", "rle_sizes", ".", "count", "(", "rle_sizes", "[", "0", "]", ")", "==", "len", "(", "rle_sizes", ")", ",", "(", "\n", "\"All the sizes must be the same size: %s\"", "%", "rle_sizes", "\n", ")", "\n", "\n", "# in RLE, height come first in \"size\"", "\n", "rle_height", ",", "rle_width", "=", "rle_sizes", "[", "0", "]", "\n", "assert", "masks", ".", "shape", "[", "1", "]", "==", "rle_height", "\n", "assert", "masks", ".", "shape", "[", "2", "]", "==", "rle_width", "\n", "\n", "width", ",", "height", "=", "size", "\n", "if", "width", "!=", "rle_width", "or", "height", "!=", "rle_height", ":", "\n", "                    ", "masks", "=", "interpolate", "(", "\n", "input", "=", "masks", "[", "None", "]", ".", "float", "(", ")", ",", "\n", "size", "=", "(", "height", ",", "width", ")", ",", "\n", "mode", "=", "\"bilinear\"", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", "[", "0", "]", ".", "type_as", "(", "masks", ")", "\n", "", "", "else", ":", "\n", "                ", "RuntimeError", "(", "\n", "\"Type of `masks[0]` could not be interpreted: %s\"", "\n", "%", "type", "(", "masks", ")", "\n", ")", "\n", "", "", "elif", "isinstance", "(", "masks", ",", "BinaryMaskList", ")", ":", "\n", "# just hard copy the BinaryMaskList instance's underlying data", "\n", "            ", "masks", "=", "masks", ".", "masks", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "            ", "RuntimeError", "(", "\n", "\"Type of `masks` argument could not be interpreted:%s\"", "\n", "%", "type", "(", "masks", ")", "\n", ")", "\n", "\n", "", "if", "len", "(", "masks", ".", "shape", ")", "==", "2", ":", "\n", "# if only a single instance mask is passed", "\n", "            ", "masks", "=", "masks", "[", "None", "]", "\n", "\n", "", "assert", "len", "(", "masks", ".", "shape", ")", "==", "3", "\n", "assert", "masks", ".", "shape", "[", "1", "]", "==", "size", "[", "1", "]", ",", "\"%s != %s\"", "%", "(", "masks", ".", "shape", "[", "1", "]", ",", "size", "[", "1", "]", ")", "\n", "assert", "masks", ".", "shape", "[", "2", "]", "==", "size", "[", "0", "]", ",", "\"%s != %s\"", "%", "(", "masks", ".", "shape", "[", "2", "]", ",", "size", "[", "0", "]", ")", "\n", "\n", "self", ".", "masks", "=", "masks", "\n", "self", ".", "size", "=", "tuple", "(", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.transpose": [[113, 117], ["segmentation_mask.BinaryMaskList.masks.flip", "segmentation_mask.BinaryMaskList"], "methods", ["None"], ["", "def", "transpose", "(", "self", ",", "method", ")", ":", "\n", "        ", "dim", "=", "1", "if", "method", "==", "FLIP_TOP_BOTTOM", "else", "2", "\n", "flipped_masks", "=", "self", ".", "masks", ".", "flip", "(", "dim", ")", "\n", "return", "BinaryMaskList", "(", "flipped_masks", ",", "self", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.crop": [[118, 138], ["isinstance", "str", "str", "min", "min", "min", "min", "max", "max", "segmentation_mask.BinaryMaskList", "type", "round", "max", "max", "max", "max", "float"], "methods", ["None"], ["", "def", "crop", "(", "self", ",", "box", ")", ":", "\n", "        ", "assert", "isinstance", "(", "box", ",", "(", "list", ",", "tuple", ",", "torch", ".", "Tensor", ")", ")", ",", "str", "(", "type", "(", "box", ")", ")", "\n", "# box is assumed to be xyxy", "\n", "current_width", ",", "current_height", "=", "self", ".", "size", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "[", "round", "(", "float", "(", "b", ")", ")", "for", "b", "in", "box", "]", "\n", "\n", "assert", "xmin", "<=", "xmax", "and", "ymin", "<=", "ymax", ",", "str", "(", "box", ")", "\n", "xmin", "=", "min", "(", "max", "(", "xmin", ",", "0", ")", ",", "current_width", "-", "1", ")", "\n", "ymin", "=", "min", "(", "max", "(", "ymin", ",", "0", ")", ",", "current_height", "-", "1", ")", "\n", "\n", "xmax", "=", "min", "(", "max", "(", "xmax", ",", "0", ")", ",", "current_width", ")", "\n", "ymax", "=", "min", "(", "max", "(", "ymax", ",", "0", ")", ",", "current_height", ")", "\n", "\n", "xmax", "=", "max", "(", "xmax", ",", "xmin", "+", "1", ")", "\n", "ymax", "=", "max", "(", "ymax", ",", "ymin", "+", "1", ")", "\n", "\n", "width", ",", "height", "=", "xmax", "-", "xmin", ",", "ymax", "-", "ymin", "\n", "cropped_masks", "=", "self", ".", "masks", "[", ":", ",", "ymin", ":", "ymax", ",", "xmin", ":", "xmax", "]", "\n", "cropped_size", "=", "width", ",", "height", "\n", "return", "BinaryMaskList", "(", "cropped_masks", ",", "cropped_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.resize": [[139, 159], ["map", "[].type_as", "segmentation_mask.BinaryMaskList", "iter", "isinstance", "vc_rcnn.layers.misc.interpolate", "segmentation_mask.BinaryMaskList.masks[].float"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.interpolate"], ["", "def", "resize", "(", "self", ",", "size", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "iter", "(", "size", ")", "\n", "", "except", "TypeError", ":", "\n", "            ", "assert", "isinstance", "(", "size", ",", "(", "int", ",", "float", ")", ")", "\n", "size", "=", "size", ",", "size", "\n", "", "width", ",", "height", "=", "map", "(", "int", ",", "size", ")", "\n", "\n", "assert", "width", ">", "0", "\n", "assert", "height", ">", "0", "\n", "\n", "# Height comes first here!", "\n", "resized_masks", "=", "interpolate", "(", "\n", "input", "=", "self", ".", "masks", "[", "None", "]", ".", "float", "(", ")", ",", "\n", "size", "=", "(", "height", ",", "width", ")", ",", "\n", "mode", "=", "\"bilinear\"", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", "[", "0", "]", ".", "type_as", "(", "self", ".", "masks", ")", "\n", "resized_size", "=", "width", ",", "height", "\n", "return", "BinaryMaskList", "(", "resized_masks", ",", "resized_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.convert_to_polygon": [[160, 166], ["segmentation_mask.BinaryMaskList._findContours", "segmentation_mask.PolygonList", "segmentation_mask.BinaryMaskList.masks.numel", "segmentation_mask.PolygonList"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList._findContours"], ["", "def", "convert_to_polygon", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "masks", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "return", "PolygonList", "(", "[", "]", ",", "self", ".", "size", ")", "\n", "\n", "", "contours", "=", "self", ".", "_findContours", "(", ")", "\n", "return", "PolygonList", "(", "contours", ",", "self", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.to": [[167, 169], ["None"], "methods", ["None"], ["", "def", "to", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList._findContours": [[170, 188], ["segmentation_mask.BinaryMaskList.masks.detach().numpy", "cv2.UMat", "vc_rcnn.utils.cv2_util.findContours", "contours.append", "segmentation_mask.BinaryMaskList.masks.detach", "reshaped_contour.append", "len", "entity.reshape().tolist", "entity.reshape"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.cv2_util.findContours"], ["", "def", "_findContours", "(", "self", ")", ":", "\n", "        ", "contours", "=", "[", "]", "\n", "masks", "=", "self", ".", "masks", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "for", "mask", "in", "masks", ":", "\n", "            ", "mask", "=", "cv2", ".", "UMat", "(", "mask", ")", "\n", "contour", ",", "hierarchy", "=", "cv2_util", ".", "findContours", "(", "\n", "mask", ",", "cv2", ".", "RETR_EXTERNAL", ",", "cv2", ".", "CHAIN_APPROX_TC89_L1", "\n", ")", "\n", "\n", "reshaped_contour", "=", "[", "]", "\n", "for", "entity", "in", "contour", ":", "\n", "                ", "assert", "len", "(", "entity", ".", "shape", ")", "==", "3", "\n", "assert", "(", "\n", "entity", ".", "shape", "[", "1", "]", "==", "1", "\n", ")", ",", "\"Hierarchical contours are not allowed\"", "\n", "reshaped_contour", ".", "append", "(", "entity", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", ")", "\n", "", "contours", ".", "append", "(", "reshaped_contour", ")", "\n", "", "return", "contours", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.__len__": [[189, 191], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.__getitem__": [[192, 196], ["segmentation_mask.BinaryMaskList", "segmentation_mask.BinaryMaskList.masks.numel", "RuntimeError"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "if", "self", ".", "masks", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Indexing empty BinaryMaskList\"", ")", "\n", "", "return", "BinaryMaskList", "(", "self", ".", "masks", "[", "index", "]", ",", "self", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.__iter__": [[197, 199], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.__repr__": [[200, 206], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={}, \"", ".", "format", "(", "len", "(", "self", ".", "masks", ")", ")", "\n", "s", "+=", "\"image_width={}, \"", ".", "format", "(", "self", ".", "size", "[", "0", "]", ")", "\n", "s", "+=", "\"image_height={})\"", ".", "format", "(", "self", ".", "size", "[", "1", "]", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonInstance.__init__": [[215, 249], ["isinstance", "tuple", "isinstance", "torch.as_tensor", "copy.copy", "RuntimeError", "len", "valid_polygons.append", "type"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["def", "__init__", "(", "self", ",", "polygons", ",", "size", ")", ":", "\n", "        ", "\"\"\"\n            Arguments:\n                a list of lists of numbers.\n                The first level refers to all the polygons that compose the\n                object, and the second level to the polygon coordinates.\n        \"\"\"", "\n", "if", "isinstance", "(", "polygons", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "valid_polygons", "=", "[", "]", "\n", "for", "p", "in", "polygons", ":", "\n", "                ", "p", "=", "torch", ".", "as_tensor", "(", "p", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "if", "len", "(", "p", ")", ">=", "6", ":", "# 3 * 2 coordinates", "\n", "                    ", "valid_polygons", ".", "append", "(", "p", ")", "\n", "", "", "polygons", "=", "valid_polygons", "\n", "\n", "", "elif", "isinstance", "(", "polygons", ",", "PolygonInstance", ")", ":", "\n", "            ", "polygons", "=", "copy", ".", "copy", "(", "polygons", ".", "polygons", ")", "\n", "\n", "", "else", ":", "\n", "            ", "RuntimeError", "(", "\n", "\"Type of argument `polygons` is not allowed:%s\"", "\n", "%", "(", "type", "(", "polygons", ")", ")", "\n", ")", "\n", "\n", "", "\"\"\" This crashes the training way too many times...\n        for p in polygons:\n            assert p[::2].min() >= 0\n            assert p[::2].max() < size[0]\n            assert p[1::2].min() >= 0\n            assert p[1::2].max() , size[1]\n        \"\"\"", "\n", "\n", "self", ".", "polygons", "=", "polygons", "\n", "self", ".", "size", "=", "tuple", "(", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonInstance.transpose": [[250, 272], ["segmentation_mask.PolygonInstance", "NotImplementedError", "poly.clone", "flipped_polygons.append"], "methods", ["None"], ["", "def", "transpose", "(", "self", ",", "method", ")", ":", "\n", "        ", "if", "method", "not", "in", "(", "FLIP_LEFT_RIGHT", ",", "FLIP_TOP_BOTTOM", ")", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Only FLIP_LEFT_RIGHT and FLIP_TOP_BOTTOM implemented\"", "\n", ")", "\n", "\n", "", "flipped_polygons", "=", "[", "]", "\n", "width", ",", "height", "=", "self", ".", "size", "\n", "if", "method", "==", "FLIP_LEFT_RIGHT", ":", "\n", "            ", "dim", "=", "width", "\n", "idx", "=", "0", "\n", "", "elif", "method", "==", "FLIP_TOP_BOTTOM", ":", "\n", "            ", "dim", "=", "height", "\n", "idx", "=", "1", "\n", "\n", "", "for", "poly", "in", "self", ".", "polygons", ":", "\n", "            ", "p", "=", "poly", ".", "clone", "(", ")", "\n", "TO_REMOVE", "=", "1", "\n", "p", "[", "idx", ":", ":", "2", "]", "=", "dim", "-", "poly", "[", "idx", ":", ":", "2", "]", "-", "TO_REMOVE", "\n", "flipped_polygons", ".", "append", "(", "p", ")", "\n", "\n", "", "return", "PolygonInstance", "(", "flipped_polygons", ",", "size", "=", "self", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonInstance.crop": [[273, 300], ["isinstance", "str", "map", "str", "min", "min", "min", "min", "max", "max", "segmentation_mask.PolygonInstance", "type", "max", "max", "max", "max", "poly.clone", "cropped_polygons.append"], "methods", ["None"], ["", "def", "crop", "(", "self", ",", "box", ")", ":", "\n", "        ", "assert", "isinstance", "(", "box", ",", "(", "list", ",", "tuple", ",", "torch", ".", "Tensor", ")", ")", ",", "str", "(", "type", "(", "box", ")", ")", "\n", "\n", "# box is assumed to be xyxy", "\n", "current_width", ",", "current_height", "=", "self", ".", "size", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "map", "(", "float", ",", "box", ")", "\n", "\n", "assert", "xmin", "<=", "xmax", "and", "ymin", "<=", "ymax", ",", "str", "(", "box", ")", "\n", "xmin", "=", "min", "(", "max", "(", "xmin", ",", "0", ")", ",", "current_width", "-", "1", ")", "\n", "ymin", "=", "min", "(", "max", "(", "ymin", ",", "0", ")", ",", "current_height", "-", "1", ")", "\n", "\n", "xmax", "=", "min", "(", "max", "(", "xmax", ",", "0", ")", ",", "current_width", ")", "\n", "ymax", "=", "min", "(", "max", "(", "ymax", ",", "0", ")", ",", "current_height", ")", "\n", "\n", "xmax", "=", "max", "(", "xmax", ",", "xmin", "+", "1", ")", "\n", "ymax", "=", "max", "(", "ymax", ",", "ymin", "+", "1", ")", "\n", "\n", "w", ",", "h", "=", "xmax", "-", "xmin", ",", "ymax", "-", "ymin", "\n", "\n", "cropped_polygons", "=", "[", "]", "\n", "for", "poly", "in", "self", ".", "polygons", ":", "\n", "            ", "p", "=", "poly", ".", "clone", "(", ")", "\n", "p", "[", "0", ":", ":", "2", "]", "=", "p", "[", "0", ":", ":", "2", "]", "-", "xmin", "# .clamp(min=0, max=w)", "\n", "p", "[", "1", ":", ":", "2", "]", "=", "p", "[", "1", ":", ":", "2", "]", "-", "ymin", "# .clamp(min=0, max=h)", "\n", "cropped_polygons", ".", "append", "(", "p", ")", "\n", "\n", "", "return", "PolygonInstance", "(", "cropped_polygons", ",", "size", "=", "(", "w", ",", "h", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonInstance.resize": [[301, 326], ["tuple", "segmentation_mask.PolygonInstance", "iter", "segmentation_mask.PolygonInstance", "poly.clone", "scaled_polygons.append", "isinstance", "float", "float", "zip"], "methods", ["None"], ["", "def", "resize", "(", "self", ",", "size", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "iter", "(", "size", ")", "\n", "", "except", "TypeError", ":", "\n", "            ", "assert", "isinstance", "(", "size", ",", "(", "int", ",", "float", ")", ")", "\n", "size", "=", "size", ",", "size", "\n", "\n", "", "ratios", "=", "tuple", "(", "\n", "float", "(", "s", ")", "/", "float", "(", "s_orig", ")", "for", "s", ",", "s_orig", "in", "zip", "(", "size", ",", "self", ".", "size", ")", "\n", ")", "\n", "\n", "if", "ratios", "[", "0", "]", "==", "ratios", "[", "1", "]", ":", "\n", "            ", "ratio", "=", "ratios", "[", "0", "]", "\n", "scaled_polys", "=", "[", "p", "*", "ratio", "for", "p", "in", "self", ".", "polygons", "]", "\n", "return", "PolygonInstance", "(", "scaled_polys", ",", "size", ")", "\n", "\n", "", "ratio_w", ",", "ratio_h", "=", "ratios", "\n", "scaled_polygons", "=", "[", "]", "\n", "for", "poly", "in", "self", ".", "polygons", ":", "\n", "            ", "p", "=", "poly", ".", "clone", "(", ")", "\n", "p", "[", "0", ":", ":", "2", "]", "*=", "ratio_w", "\n", "p", "[", "1", ":", ":", "2", "]", "*=", "ratio_h", "\n", "scaled_polygons", ".", "append", "(", "p", ")", "\n", "\n", "", "return", "PolygonInstance", "(", "scaled_polygons", ",", "size", "=", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonInstance.convert_to_binarymask": [[327, 336], ["pycocotools.frPyObjects", "pycocotools.merge", "pycocotools.decode", "torch.from_numpy", "p.numpy"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode"], ["", "def", "convert_to_binarymask", "(", "self", ")", ":", "\n", "        ", "width", ",", "height", "=", "self", ".", "size", "\n", "# formatting for COCO PythonAPI", "\n", "polygons", "=", "[", "p", ".", "numpy", "(", ")", "for", "p", "in", "self", ".", "polygons", "]", "\n", "rles", "=", "mask_utils", ".", "frPyObjects", "(", "polygons", ",", "height", ",", "width", ")", "\n", "rle", "=", "mask_utils", ".", "merge", "(", "rles", ")", "\n", "mask", "=", "mask_utils", ".", "decode", "(", "rle", ")", "\n", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonInstance.__len__": [[337, 339], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "polygons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonInstance.__repr__": [[340, 346], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_groups={}, \"", ".", "format", "(", "len", "(", "self", ".", "polygons", ")", ")", "\n", "s", "+=", "\"image_width={}, \"", ".", "format", "(", "self", ".", "size", "[", "0", "]", ")", "\n", "s", "+=", "\"image_height={})\"", ".", "format", "(", "self", ".", "size", "[", "1", "]", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.__init__": [[353, 404], ["isinstance", "isinstance", "str", "tuple", "isinstance", "isinstance", "type", "segmentation_mask.PolygonInstance", "len", "isinstance", "str", "isinstance", "str", "RuntimeError", "len", "segmentation_mask.PolygonList.polygons.append", "type", "type", "type"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "polygons", ",", "size", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            polygons:\n                a list of list of lists of numbers. The first\n                level of the list correspond to individual instances,\n                the second level to all the polygons that compose the\n                object, and the third level to the polygon coordinates.\n\n                OR\n\n                a list of PolygonInstances.\n\n                OR\n\n                a PolygonList\n\n            size: absolute image size\n\n        \"\"\"", "\n", "if", "isinstance", "(", "polygons", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "if", "len", "(", "polygons", ")", "==", "0", ":", "\n", "                ", "polygons", "=", "[", "[", "[", "]", "]", "]", "\n", "", "if", "isinstance", "(", "polygons", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "                ", "assert", "isinstance", "(", "polygons", "[", "0", "]", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ",", "str", "(", "\n", "type", "(", "polygons", "[", "0", "]", "[", "0", "]", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "assert", "isinstance", "(", "polygons", "[", "0", "]", ",", "PolygonInstance", ")", ",", "str", "(", "\n", "type", "(", "polygons", "[", "0", "]", ")", "\n", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "polygons", ",", "PolygonList", ")", ":", "\n", "            ", "size", "=", "polygons", ".", "size", "\n", "polygons", "=", "polygons", ".", "polygons", "\n", "\n", "", "else", ":", "\n", "            ", "RuntimeError", "(", "\n", "\"Type of argument `polygons` is not allowed:%s\"", "\n", "%", "(", "type", "(", "polygons", ")", ")", "\n", ")", "\n", "\n", "", "assert", "isinstance", "(", "size", ",", "(", "list", ",", "tuple", ")", ")", ",", "str", "(", "type", "(", "size", ")", ")", "\n", "\n", "self", ".", "polygons", "=", "[", "]", "\n", "for", "p", "in", "polygons", ":", "\n", "            ", "p", "=", "PolygonInstance", "(", "p", ",", "size", ")", "\n", "if", "len", "(", "p", ")", ">", "0", ":", "\n", "                ", "self", ".", "polygons", ".", "append", "(", "p", ")", "\n", "\n", "", "", "self", ".", "size", "=", "tuple", "(", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.transpose": [[405, 416], ["segmentation_mask.PolygonList", "NotImplementedError", "flipped_polygons.append", "polygon.transpose"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "transpose", "(", "self", ",", "method", ")", ":", "\n", "        ", "if", "method", "not", "in", "(", "FLIP_LEFT_RIGHT", ",", "FLIP_TOP_BOTTOM", ")", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Only FLIP_LEFT_RIGHT and FLIP_TOP_BOTTOM implemented\"", "\n", ")", "\n", "\n", "", "flipped_polygons", "=", "[", "]", "\n", "for", "polygon", "in", "self", ".", "polygons", ":", "\n", "            ", "flipped_polygons", ".", "append", "(", "polygon", ".", "transpose", "(", "method", ")", ")", "\n", "\n", "", "return", "PolygonList", "(", "flipped_polygons", ",", "size", "=", "self", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.crop": [[417, 425], ["segmentation_mask.PolygonList", "cropped_polygons.append", "polygon.crop"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.crop"], ["", "def", "crop", "(", "self", ",", "box", ")", ":", "\n", "        ", "w", ",", "h", "=", "box", "[", "2", "]", "-", "box", "[", "0", "]", ",", "box", "[", "3", "]", "-", "box", "[", "1", "]", "\n", "cropped_polygons", "=", "[", "]", "\n", "for", "polygon", "in", "self", ".", "polygons", ":", "\n", "            ", "cropped_polygons", ".", "append", "(", "polygon", ".", "crop", "(", "box", ")", ")", "\n", "\n", "", "cropped_size", "=", "w", ",", "h", "\n", "return", "PolygonList", "(", "cropped_polygons", ",", "cropped_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.resize": [[426, 433], ["segmentation_mask.PolygonList", "resized_polygons.append", "polygon.resize"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize"], ["", "def", "resize", "(", "self", ",", "size", ")", ":", "\n", "        ", "resized_polygons", "=", "[", "]", "\n", "for", "polygon", "in", "self", ".", "polygons", ":", "\n", "            ", "resized_polygons", ".", "append", "(", "polygon", ".", "resize", "(", "size", ")", ")", "\n", "\n", "", "resized_size", "=", "size", "\n", "return", "PolygonList", "(", "resized_polygons", ",", "resized_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.to": [[434, 436], ["None"], "methods", ["None"], ["", "def", "to", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.convert_to_binarymask": [[437, 447], ["segmentation_mask.BinaryMaskList", "len", "torch.stack", "torch.empty", "p.convert_to_binarymask"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.convert_to_binarymask"], ["", "def", "convert_to_binarymask", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ")", ">", "0", ":", "\n", "            ", "masks", "=", "torch", ".", "stack", "(", "\n", "[", "p", ".", "convert_to_binarymask", "(", ")", "for", "p", "in", "self", ".", "polygons", "]", "\n", ")", "\n", "", "else", ":", "\n", "            ", "size", "=", "self", ".", "size", "\n", "masks", "=", "torch", ".", "empty", "(", "[", "0", ",", "size", "[", "1", "]", ",", "size", "[", "0", "]", "]", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "\n", "", "return", "BinaryMaskList", "(", "masks", ",", "size", "=", "self", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.__len__": [[448, 450], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "polygons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.__getitem__": [[451, 466], ["isinstance", "segmentation_mask.PolygonList", "isinstance", "isinstance", "item.tolist.tolist.nonzero", "item.tolist.tolist.tolist", "selected_polygons.append", "item.tolist.tolist.squeeze", "item.tolist.tolist.numel"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "selected_polygons", "=", "[", "self", ".", "polygons", "[", "item", "]", "]", "\n", "", "elif", "isinstance", "(", "item", ",", "slice", ")", ":", "\n", "            ", "selected_polygons", "=", "self", ".", "polygons", "[", "item", "]", "\n", "", "else", ":", "\n", "# advanced indexing on a single dimension", "\n", "            ", "selected_polygons", "=", "[", "]", "\n", "if", "isinstance", "(", "item", ",", "torch", ".", "Tensor", ")", "and", "item", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "                ", "item", "=", "item", ".", "nonzero", "(", ")", "\n", "item", "=", "item", ".", "squeeze", "(", "1", ")", "if", "item", ".", "numel", "(", ")", ">", "0", "else", "item", "\n", "item", "=", "item", ".", "tolist", "(", ")", "\n", "", "for", "i", "in", "item", ":", "\n", "                ", "selected_polygons", ".", "append", "(", "self", ".", "polygons", "[", "i", "]", ")", "\n", "", "", "return", "PolygonList", "(", "selected_polygons", ",", "size", "=", "self", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.__iter__": [[467, 469], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "polygons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.__repr__": [[470, 476], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={}, \"", ".", "format", "(", "len", "(", "self", ".", "polygons", ")", ")", "\n", "s", "+=", "\"image_width={}, \"", ".", "format", "(", "self", ".", "size", "[", "0", "]", ")", "\n", "s", "+=", "\"image_height={})\"", ".", "format", "(", "self", ".", "size", "[", "1", "]", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.__init__": [[485, 513], ["isinstance", "isinstance", "isinstance", "isinstance", "tuple", "len", "isinstance", "segmentation_mask.PolygonList", "size[].item", "size[].item", "segmentation_mask.BinaryMaskList", "NotImplementedError", "str"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "instances", ",", "size", ",", "mode", "=", "\"poly\"", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            instances: two types\n                (1) polygon\n                (2) binary mask\n            size: (width, height)\n            mode: 'poly', 'mask'. if mode is 'mask', convert mask of any format to binary mask\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "size", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "len", "(", "size", ")", "==", "2", "\n", "if", "isinstance", "(", "size", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "assert", "isinstance", "(", "size", "[", "1", "]", ",", "torch", ".", "Tensor", ")", "\n", "size", "=", "size", "[", "0", "]", ".", "item", "(", ")", ",", "size", "[", "1", "]", ".", "item", "(", ")", "\n", "\n", "", "assert", "isinstance", "(", "size", "[", "0", "]", ",", "(", "int", ",", "float", ")", ")", "\n", "assert", "isinstance", "(", "size", "[", "1", "]", ",", "(", "int", ",", "float", ")", ")", "\n", "\n", "if", "mode", "==", "\"poly\"", ":", "\n", "            ", "self", ".", "instances", "=", "PolygonList", "(", "instances", ",", "size", ")", "\n", "", "elif", "mode", "==", "\"mask\"", ":", "\n", "            ", "self", ".", "instances", "=", "BinaryMaskList", "(", "instances", ",", "size", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Unknown mode: %s\"", "%", "str", "(", "mode", ")", ")", "\n", "\n", "", "self", ".", "mode", "=", "mode", "\n", "self", ".", "size", "=", "tuple", "(", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.transpose": [[514, 517], ["segmentation_mask.SegmentationMask.instances.transpose", "segmentation_mask.SegmentationMask"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "transpose", "(", "self", ",", "method", ")", ":", "\n", "        ", "flipped_instances", "=", "self", ".", "instances", ".", "transpose", "(", "method", ")", "\n", "return", "SegmentationMask", "(", "flipped_instances", ",", "self", ".", "size", ",", "self", ".", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.crop": [[518, 522], ["segmentation_mask.SegmentationMask.instances.crop", "segmentation_mask.SegmentationMask"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.crop"], ["", "def", "crop", "(", "self", ",", "box", ")", ":", "\n", "        ", "cropped_instances", "=", "self", ".", "instances", ".", "crop", "(", "box", ")", "\n", "cropped_size", "=", "cropped_instances", ".", "size", "\n", "return", "SegmentationMask", "(", "cropped_instances", ",", "cropped_size", ",", "self", ".", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.resize": [[523, 527], ["segmentation_mask.SegmentationMask.instances.resize", "segmentation_mask.SegmentationMask"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize"], ["", "def", "resize", "(", "self", ",", "size", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "resized_instances", "=", "self", ".", "instances", ".", "resize", "(", "size", ")", "\n", "resized_size", "=", "size", "\n", "return", "SegmentationMask", "(", "resized_instances", ",", "resized_size", ",", "self", ".", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.to": [[528, 530], ["None"], "methods", ["None"], ["", "def", "to", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.convert": [[531, 543], ["segmentation_mask.SegmentationMask", "segmentation_mask.SegmentationMask.instances.convert_to_polygon", "segmentation_mask.SegmentationMask.instances.convert_to_binarymask", "NotImplementedError", "str"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.BinaryMaskList.convert_to_polygon", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.convert_to_binarymask"], ["", "def", "convert", "(", "self", ",", "mode", ")", ":", "\n", "        ", "if", "mode", "==", "self", ".", "mode", ":", "\n", "            ", "return", "self", "\n", "\n", "", "if", "mode", "==", "\"poly\"", ":", "\n", "            ", "converted_instances", "=", "self", ".", "instances", ".", "convert_to_polygon", "(", ")", "\n", "", "elif", "mode", "==", "\"mask\"", ":", "\n", "            ", "converted_instances", "=", "self", ".", "instances", ".", "convert_to_binarymask", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Unknown mode: %s\"", "%", "str", "(", "mode", ")", ")", "\n", "\n", "", "return", "SegmentationMask", "(", "converted_instances", ",", "self", ".", "size", ",", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.get_mask_tensor": [[544, 550], ["instances.convert_to_binarymask.convert_to_binarymask.masks.squeeze", "instances.convert_to_binarymask.convert_to_binarymask.convert_to_binarymask"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.PolygonList.convert_to_binarymask"], ["", "def", "get_mask_tensor", "(", "self", ")", ":", "\n", "        ", "instances", "=", "self", ".", "instances", "\n", "if", "self", ".", "mode", "==", "\"poly\"", ":", "\n", "            ", "instances", "=", "instances", ".", "convert_to_binarymask", "(", ")", "\n", "# If there is only 1 instance", "\n", "", "return", "instances", ".", "masks", ".", "squeeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.__len__": [[551, 553], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.__getitem__": [[554, 557], ["segmentation_mask.SegmentationMask.instances.__getitem__", "segmentation_mask.SegmentationMask"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR.__getitem__"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "selected_instances", "=", "self", ".", "instances", ".", "__getitem__", "(", "item", ")", "\n", "return", "SegmentationMask", "(", "selected_instances", ",", "self", ".", "size", ",", "self", ".", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.__iter__": [[558, 561], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "iter_idx", "=", "0", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.__next__": [[562, 568], ["StopIteration", "segmentation_mask.SegmentationMask.__len__", "segmentation_mask.SegmentationMask.__getitem__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR.__getitem__"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "iter_idx", "<", "self", ".", "__len__", "(", ")", ":", "\n", "            ", "next_segmentation", "=", "self", ".", "__getitem__", "(", "self", ".", "iter_idx", ")", "\n", "self", ".", "iter_idx", "+=", "1", "\n", "return", "next_segmentation", "\n", "", "raise", "StopIteration", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.__repr__": [[571, 578], ["len"], "methods", ["None"], ["def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={}, \"", ".", "format", "(", "len", "(", "self", ".", "instances", ")", ")", "\n", "s", "+=", "\"image_width={}, \"", ".", "format", "(", "self", ".", "size", "[", "0", "]", ")", "\n", "s", "+=", "\"image_height={}, \"", ".", "format", "(", "self", ".", "size", "[", "1", "]", ")", "\n", "s", "+=", "\"mode={})\"", ".", "format", "(", "self", ".", "mode", ")", "\n", "return", "s", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.image_list.ImageList.__init__": [[15, 23], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "tensors", ",", "image_sizes", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            tensors (tensor)\n            image_sizes (list[tuple[int, int]])\n        \"\"\"", "\n", "self", ".", "tensors", "=", "tensors", "\n", "self", ".", "image_sizes", "=", "image_sizes", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.image_list.ImageList.to": [[24, 27], ["image_list.ImageList.tensors.to", "image_list.ImageList"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "to", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "cast_tensor", "=", "self", ".", "tensors", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "return", "ImageList", "(", "cast_tensor", ",", "self", ".", "image_sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.image_list.to_image_list": [[29, 73], ["isinstance", "isinstance", "isinstance", "image_list.ImageList", "isinstance", "tensors.dim", "tensors.dim", "tuple", "tensors[].new().zero_", "zip", "image_list.ImageList", "TypeError", "list", "int", "int", "tuple", "pad_img[].copy_", "max", "len", "tensors[].new", "type", "zip", "math.ceil", "math.ceil"], "function", ["None"], ["", "", "def", "to_image_list", "(", "tensors", ",", "size_divisible", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    tensors can be an ImageList, a torch.Tensor or\n    an iterable of Tensors. It can't be a numpy array.\n    When tensors is an iterable of Tensors, it pads\n    the Tensors with zeros so that they have the same\n    shape\n    \"\"\"", "\n", "if", "isinstance", "(", "tensors", ",", "torch", ".", "Tensor", ")", "and", "size_divisible", ">", "0", ":", "\n", "        ", "tensors", "=", "[", "tensors", "]", "\n", "\n", "", "if", "isinstance", "(", "tensors", ",", "ImageList", ")", ":", "\n", "        ", "return", "tensors", "\n", "", "elif", "isinstance", "(", "tensors", ",", "torch", ".", "Tensor", ")", ":", "\n", "# single tensor shape can be inferred", "\n", "        ", "if", "tensors", ".", "dim", "(", ")", "==", "3", ":", "\n", "            ", "tensors", "=", "tensors", "[", "None", "]", "\n", "", "assert", "tensors", ".", "dim", "(", ")", "==", "4", "\n", "image_sizes", "=", "[", "tensor", ".", "shape", "[", "-", "2", ":", "]", "for", "tensor", "in", "tensors", "]", "\n", "return", "ImageList", "(", "tensors", ",", "image_sizes", ")", "\n", "", "elif", "isinstance", "(", "tensors", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "        ", "max_size", "=", "tuple", "(", "max", "(", "s", ")", "for", "s", "in", "zip", "(", "*", "[", "img", ".", "shape", "for", "img", "in", "tensors", "]", ")", ")", "\n", "\n", "# TODO Ideally, just remove this and let me model handle arbitrary", "\n", "# input sizs", "\n", "if", "size_divisible", ">", "0", ":", "\n", "            ", "import", "math", "\n", "\n", "stride", "=", "size_divisible", "\n", "max_size", "=", "list", "(", "max_size", ")", "\n", "max_size", "[", "1", "]", "=", "int", "(", "math", ".", "ceil", "(", "max_size", "[", "1", "]", "/", "stride", ")", "*", "stride", ")", "\n", "max_size", "[", "2", "]", "=", "int", "(", "math", ".", "ceil", "(", "max_size", "[", "2", "]", "/", "stride", ")", "*", "stride", ")", "\n", "max_size", "=", "tuple", "(", "max_size", ")", "\n", "\n", "", "batch_shape", "=", "(", "len", "(", "tensors", ")", ",", ")", "+", "max_size", "\n", "batched_imgs", "=", "tensors", "[", "0", "]", ".", "new", "(", "*", "batch_shape", ")", ".", "zero_", "(", ")", "\n", "for", "img", ",", "pad_img", "in", "zip", "(", "tensors", ",", "batched_imgs", ")", ":", "\n", "            ", "pad_img", "[", ":", "img", ".", "shape", "[", "0", "]", ",", ":", "img", ".", "shape", "[", "1", "]", ",", ":", "img", ".", "shape", "[", "2", "]", "]", ".", "copy_", "(", "img", ")", "\n", "\n", "", "image_sizes", "=", "[", "im", ".", "shape", "[", "-", "2", ":", "]", "for", "im", "in", "tensors", "]", "\n", "\n", "return", "ImageList", "(", "batched_imgs", ",", "image_sizes", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "\"Unsupported type for to_image_list: {}\"", ".", "format", "(", "type", "(", "tensors", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.__init__": [[19, 38], ["torch.as_tensor", "isinstance", "torch.device", "torch.as_tensor.ndimension", "ValueError", "torch.as_tensor.size", "ValueError", "ValueError", "torch.as_tensor.ndimension", "torch.as_tensor.size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["def", "__init__", "(", "self", ",", "bbox", ",", "image_size", ",", "mode", "=", "\"xyxy\"", ")", ":", "\n", "        ", "device", "=", "bbox", ".", "device", "if", "isinstance", "(", "bbox", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "bbox", "=", "torch", ".", "as_tensor", "(", "bbox", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "if", "bbox", ".", "ndimension", "(", ")", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"bbox should have 2 dimensions, got {}\"", ".", "format", "(", "bbox", ".", "ndimension", "(", ")", ")", "\n", ")", "\n", "", "if", "bbox", ".", "size", "(", "-", "1", ")", "!=", "4", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"last dimension of bbox should have a \"", "\n", "\"size of 4, got {}\"", ".", "format", "(", "bbox", ".", "size", "(", "-", "1", ")", ")", "\n", ")", "\n", "", "if", "mode", "not", "in", "(", "\"xyxy\"", ",", "\"xywh\"", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"mode should be 'xyxy' or 'xywh'\"", ")", "\n", "\n", "", "self", ".", "bbox", "=", "bbox", "\n", "self", ".", "size", "=", "image_size", "# (image_width, image_height)", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "extra_fields", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.add_field": [[39, 41], ["None"], "methods", ["None"], ["", "def", "add_field", "(", "self", ",", "field", ",", "field_data", ")", ":", "\n", "        ", "self", ".", "extra_fields", "[", "field", "]", "=", "field_data", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.get_field": [[42, 44], ["None"], "methods", ["None"], ["", "def", "get_field", "(", "self", ",", "field", ")", ":", "\n", "        ", "return", "self", ".", "extra_fields", "[", "field", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.has_field": [[45, 47], ["None"], "methods", ["None"], ["", "def", "has_field", "(", "self", ",", "field", ")", ":", "\n", "        ", "return", "field", "in", "self", ".", "extra_fields", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.fields": [[48, 50], ["list", "bounding_box.BoxList.extra_fields.keys"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys"], ["", "def", "fields", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "self", ".", "extra_fields", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList._copy_extra_fields": [[51, 54], ["bbox.extra_fields.items"], "methods", ["None"], ["", "def", "_copy_extra_fields", "(", "self", ",", "bbox", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "bbox", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "extra_fields", "[", "k", "]", "=", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert": [[55, 74], ["bounding_box.BoxList._split_into_xyxy", "bounding_box.BoxList._copy_extra_fields", "ValueError", "torch.cat", "bounding_box.BoxList", "torch.cat", "bounding_box.BoxList"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList._split_into_xyxy", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList._copy_extra_fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "", "def", "convert", "(", "self", ",", "mode", ")", ":", "\n", "        ", "if", "mode", "not", "in", "(", "\"xyxy\"", ",", "\"xywh\"", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"mode should be 'xyxy' or 'xywh'\"", ")", "\n", "", "if", "mode", "==", "self", ".", "mode", ":", "\n", "            ", "return", "self", "\n", "# we only have two modes, so don't need to check", "\n", "# self.mode", "\n", "", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "self", ".", "_split_into_xyxy", "(", ")", "\n", "if", "mode", "==", "\"xyxy\"", ":", "\n", "            ", "bbox", "=", "torch", ".", "cat", "(", "(", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", ")", ",", "dim", "=", "-", "1", ")", "\n", "bbox", "=", "BoxList", "(", "bbox", ",", "self", ".", "size", ",", "mode", "=", "mode", ")", "\n", "", "else", ":", "\n", "            ", "TO_REMOVE", "=", "1", "\n", "bbox", "=", "torch", ".", "cat", "(", "\n", "(", "xmin", ",", "ymin", ",", "xmax", "-", "xmin", "+", "TO_REMOVE", ",", "ymax", "-", "ymin", "+", "TO_REMOVE", ")", ",", "dim", "=", "-", "1", "\n", ")", "\n", "bbox", "=", "BoxList", "(", "bbox", ",", "self", ".", "size", ",", "mode", "=", "mode", ")", "\n", "", "bbox", ".", "_copy_extra_fields", "(", "self", ")", "\n", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList._split_into_xyxy": [[75, 90], ["bounding_box.BoxList.bbox.split", "bounding_box.BoxList.bbox.split", "RuntimeError"], "methods", ["None"], ["", "def", "_split_into_xyxy", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "mode", "==", "\"xyxy\"", ":", "\n", "            ", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "self", ".", "bbox", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "return", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "\n", "", "elif", "self", ".", "mode", "==", "\"xywh\"", ":", "\n", "            ", "TO_REMOVE", "=", "1", "\n", "xmin", ",", "ymin", ",", "w", ",", "h", "=", "self", ".", "bbox", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "return", "(", "\n", "xmin", ",", "\n", "ymin", ",", "\n", "xmin", "+", "(", "w", "-", "TO_REMOVE", ")", ".", "clamp", "(", "min", "=", "0", ")", ",", "\n", "ymin", "+", "(", "h", "-", "TO_REMOVE", ")", ".", "clamp", "(", "min", "=", "0", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Should not be here\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.resize": [[91, 128], ["tuple", "bounding_box.BoxList._split_into_xyxy", "torch.cat", "bounding_box.BoxList", "bounding_box.BoxList.extra_fields.items", "bounding_box.BoxList.convert", "bounding_box.BoxList", "bounding_box.BoxList.extra_fields.items", "bounding_box.BoxList.add_field", "bounding_box.BoxList.add_field", "isinstance", "v.resize.resize.resize", "float", "float", "zip", "isinstance", "v.resize.resize.resize"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList._split_into_xyxy", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize"], ["", "", "def", "resize", "(", "self", ",", "size", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Returns a resized copy of this bounding box\n\n        :param size: The requested size in pixels, as a 2-tuple:\n            (width, height).\n        \"\"\"", "\n", "\n", "ratios", "=", "tuple", "(", "float", "(", "s", ")", "/", "float", "(", "s_orig", ")", "for", "s", ",", "s_orig", "in", "zip", "(", "size", ",", "self", ".", "size", ")", ")", "\n", "if", "ratios", "[", "0", "]", "==", "ratios", "[", "1", "]", ":", "\n", "            ", "ratio", "=", "ratios", "[", "0", "]", "\n", "scaled_box", "=", "self", ".", "bbox", "*", "ratio", "\n", "bbox", "=", "BoxList", "(", "scaled_box", ",", "size", ",", "mode", "=", "self", ".", "mode", ")", "\n", "# bbox._copy_extra_fields(self)", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "                ", "if", "not", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                    ", "v", "=", "v", ".", "resize", "(", "size", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "bbox", ".", "add_field", "(", "k", ",", "v", ")", "\n", "", "return", "bbox", "\n", "\n", "", "ratio_width", ",", "ratio_height", "=", "ratios", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "self", ".", "_split_into_xyxy", "(", ")", "\n", "scaled_xmin", "=", "xmin", "*", "ratio_width", "\n", "scaled_xmax", "=", "xmax", "*", "ratio_width", "\n", "scaled_ymin", "=", "ymin", "*", "ratio_height", "\n", "scaled_ymax", "=", "ymax", "*", "ratio_height", "\n", "scaled_box", "=", "torch", ".", "cat", "(", "\n", "(", "scaled_xmin", ",", "scaled_ymin", ",", "scaled_xmax", ",", "scaled_ymax", ")", ",", "dim", "=", "-", "1", "\n", ")", "\n", "bbox", "=", "BoxList", "(", "scaled_box", ",", "size", ",", "mode", "=", "\"xyxy\"", ")", "\n", "# bbox._copy_extra_fields(self)", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "v", "=", "v", ".", "resize", "(", "size", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "bbox", ".", "add_field", "(", "k", ",", "v", ")", "\n", "\n", "", "return", "bbox", ".", "convert", "(", "self", ".", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.transpose": [[129, 166], ["bounding_box.BoxList._split_into_xyxy", "torch.cat", "bounding_box.BoxList", "bounding_box.BoxList.extra_fields.items", "bounding_box.BoxList.convert", "NotImplementedError", "bounding_box.BoxList.add_field", "isinstance", "v.transpose.transpose.transpose"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList._split_into_xyxy", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "transpose", "(", "self", ",", "method", ")", ":", "\n", "        ", "\"\"\"\n        Transpose bounding box (flip or rotate in 90 degree steps)\n        :param method: One of :py:attr:`PIL.Image.FLIP_LEFT_RIGHT`,\n          :py:attr:`PIL.Image.FLIP_TOP_BOTTOM`, :py:attr:`PIL.Image.ROTATE_90`,\n          :py:attr:`PIL.Image.ROTATE_180`, :py:attr:`PIL.Image.ROTATE_270`,\n          :py:attr:`PIL.Image.TRANSPOSE` or :py:attr:`PIL.Image.TRANSVERSE`.\n        \"\"\"", "\n", "if", "method", "not", "in", "(", "FLIP_LEFT_RIGHT", ",", "FLIP_TOP_BOTTOM", ")", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Only FLIP_LEFT_RIGHT and FLIP_TOP_BOTTOM implemented\"", "\n", ")", "\n", "\n", "", "image_width", ",", "image_height", "=", "self", ".", "size", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "self", ".", "_split_into_xyxy", "(", ")", "\n", "if", "method", "==", "FLIP_LEFT_RIGHT", ":", "\n", "            ", "TO_REMOVE", "=", "1", "\n", "transposed_xmin", "=", "image_width", "-", "xmax", "-", "TO_REMOVE", "\n", "transposed_xmax", "=", "image_width", "-", "xmin", "-", "TO_REMOVE", "\n", "transposed_ymin", "=", "ymin", "\n", "transposed_ymax", "=", "ymax", "\n", "", "elif", "method", "==", "FLIP_TOP_BOTTOM", ":", "\n", "            ", "transposed_xmin", "=", "xmin", "\n", "transposed_xmax", "=", "xmax", "\n", "transposed_ymin", "=", "image_height", "-", "ymax", "\n", "transposed_ymax", "=", "image_height", "-", "ymin", "\n", "\n", "", "transposed_boxes", "=", "torch", ".", "cat", "(", "\n", "(", "transposed_xmin", ",", "transposed_ymin", ",", "transposed_xmax", ",", "transposed_ymax", ")", ",", "dim", "=", "-", "1", "\n", ")", "\n", "bbox", "=", "BoxList", "(", "transposed_boxes", ",", "self", ".", "size", ",", "mode", "=", "\"xyxy\"", ")", "\n", "# bbox._copy_extra_fields(self)", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "v", "=", "v", ".", "transpose", "(", "method", ")", "\n", "", "bbox", ".", "add_field", "(", "k", ",", "v", ")", "\n", "", "return", "bbox", ".", "convert", "(", "self", ".", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.crop": [[167, 194], ["bounding_box.BoxList._split_into_xyxy", "torch.cat", "bounding_box.BoxList", "bounding_box.BoxList.extra_fields.items", "bounding_box.BoxList.convert", "bounding_box.BoxList.add_field", "isinstance", "v.crop.crop.crop"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList._split_into_xyxy", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.crop"], ["", "def", "crop", "(", "self", ",", "box", ")", ":", "\n", "        ", "\"\"\"\n        Crops a rectangular region from this bounding box. The box is a\n        4-tuple defining the left, upper, right, and lower pixel\n        coordinate.\n        \"\"\"", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "self", ".", "_split_into_xyxy", "(", ")", "\n", "w", ",", "h", "=", "box", "[", "2", "]", "-", "box", "[", "0", "]", ",", "box", "[", "3", "]", "-", "box", "[", "1", "]", "\n", "cropped_xmin", "=", "(", "xmin", "-", "box", "[", "0", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "cropped_ymin", "=", "(", "ymin", "-", "box", "[", "1", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "cropped_xmax", "=", "(", "xmax", "-", "box", "[", "0", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "cropped_ymax", "=", "(", "ymax", "-", "box", "[", "1", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "\n", "# TODO should I filter empty boxes here?", "\n", "if", "False", ":", "\n", "            ", "is_empty", "=", "(", "cropped_xmin", "==", "cropped_xmax", ")", "|", "(", "cropped_ymin", "==", "cropped_ymax", ")", "\n", "\n", "", "cropped_box", "=", "torch", ".", "cat", "(", "\n", "(", "cropped_xmin", ",", "cropped_ymin", ",", "cropped_xmax", ",", "cropped_ymax", ")", ",", "dim", "=", "-", "1", "\n", ")", "\n", "bbox", "=", "BoxList", "(", "cropped_box", ",", "(", "w", ",", "h", ")", ",", "mode", "=", "\"xyxy\"", ")", "\n", "# bbox._copy_extra_fields(self)", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "v", "=", "v", ".", "crop", "(", "box", ")", "\n", "", "bbox", ".", "add_field", "(", "k", ",", "v", ")", "\n", "", "return", "bbox", ".", "convert", "(", "self", ".", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.to": [[197, 204], ["bounding_box.BoxList", "bounding_box.BoxList.extra_fields.items", "bounding_box.BoxList.bbox.to", "hasattr", "bounding_box.BoxList.add_field", "v.to.to.to"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "bbox", "=", "BoxList", "(", "self", ".", "bbox", ".", "to", "(", "device", ")", ",", "self", ".", "size", ",", "self", ".", "mode", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "v", ",", "\"to\"", ")", ":", "\n", "                ", "v", "=", "v", ".", "to", "(", "device", ")", "\n", "", "bbox", ".", "add_field", "(", "k", ",", "v", ")", "\n", "", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.__getitem__": [[205, 210], ["bounding_box.BoxList", "bounding_box.BoxList.extra_fields.items", "bounding_box.BoxList.add_field"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "bbox", "=", "BoxList", "(", "self", ".", "bbox", "[", "item", "]", ",", "self", ".", "size", ",", "self", ".", "mode", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "bbox", ".", "add_field", "(", "k", ",", "v", "[", "item", "]", ")", "\n", "", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.__len__": [[211, 213], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "bbox", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.clip_to_image": [[214, 225], ["bounding_box.BoxList.bbox[].clamp_", "bounding_box.BoxList.bbox[].clamp_", "bounding_box.BoxList.bbox[].clamp_", "bounding_box.BoxList.bbox[].clamp_"], "methods", ["None"], ["", "def", "clip_to_image", "(", "self", ",", "remove_empty", "=", "True", ")", ":", "\n", "        ", "TO_REMOVE", "=", "1", "\n", "self", ".", "bbox", "[", ":", ",", "0", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "self", ".", "size", "[", "0", "]", "-", "TO_REMOVE", ")", "\n", "self", ".", "bbox", "[", ":", ",", "1", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "self", ".", "size", "[", "1", "]", "-", "TO_REMOVE", ")", "\n", "self", ".", "bbox", "[", ":", ",", "2", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "self", ".", "size", "[", "0", "]", "-", "TO_REMOVE", ")", "\n", "self", ".", "bbox", "[", ":", ",", "3", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "self", ".", "size", "[", "1", "]", "-", "TO_REMOVE", ")", "\n", "if", "remove_empty", ":", "\n", "            ", "box", "=", "self", ".", "bbox", "\n", "keep", "=", "(", "box", "[", ":", ",", "3", "]", ">", "box", "[", ":", ",", "1", "]", ")", "&", "(", "box", "[", ":", ",", "2", "]", ">", "box", "[", ":", ",", "0", "]", ")", "\n", "return", "self", "[", "keep", "]", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.area": [[226, 237], ["RuntimeError"], "methods", ["None"], ["", "def", "area", "(", "self", ")", ":", "\n", "        ", "box", "=", "self", ".", "bbox", "\n", "if", "self", ".", "mode", "==", "\"xyxy\"", ":", "\n", "            ", "TO_REMOVE", "=", "1", "\n", "area", "=", "(", "box", "[", ":", ",", "2", "]", "-", "box", "[", ":", ",", "0", "]", "+", "TO_REMOVE", ")", "*", "(", "box", "[", ":", ",", "3", "]", "-", "box", "[", ":", ",", "1", "]", "+", "TO_REMOVE", ")", "\n", "", "elif", "self", ".", "mode", "==", "\"xywh\"", ":", "\n", "            ", "area", "=", "box", "[", ":", ",", "2", "]", "*", "box", "[", ":", ",", "3", "]", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Should not be here\"", ")", "\n", "\n", "", "return", "area", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.copy_with_fields": [[238, 248], ["bounding_box.BoxList", "isinstance", "bounding_box.BoxList.has_field", "bounding_box.BoxList.add_field", "bounding_box.BoxList.get_field", "KeyError"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.has_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "copy_with_fields", "(", "self", ",", "fields", ",", "skip_missing", "=", "False", ")", ":", "\n", "        ", "bbox", "=", "BoxList", "(", "self", ".", "bbox", ",", "self", ".", "size", ",", "self", ".", "mode", ")", "\n", "if", "not", "isinstance", "(", "fields", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "fields", "=", "[", "fields", "]", "\n", "", "for", "field", "in", "fields", ":", "\n", "            ", "if", "self", ".", "has_field", "(", "field", ")", ":", "\n", "                ", "bbox", ".", "add_field", "(", "field", ",", "self", ".", "get_field", "(", "field", ")", ")", "\n", "", "elif", "not", "skip_missing", ":", "\n", "                ", "raise", "KeyError", "(", "\"Field '{}' not found in {}\"", ".", "format", "(", "field", ",", "self", ")", ")", "\n", "", "", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.__repr__": [[249, 256], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_boxes={}, \"", ".", "format", "(", "len", "(", "self", ")", ")", "\n", "s", "+=", "\"image_width={}, \"", ".", "format", "(", "self", ".", "size", "[", "0", "]", ")", "\n", "s", "+=", "\"image_height={}, \"", ".", "format", "(", "self", ".", "size", "[", "1", "]", ")", "\n", "s", "+=", "\"mode={})\"", ".", "format", "(", "self", ".", "mode", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_nms": [[9, 32], ["boxlist.convert.convert", "boxlist.convert.get_field", "vc_rcnn.layers.nms", "boxlist.convert.convert"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert"], ["def", "boxlist_nms", "(", "boxlist", ",", "nms_thresh", ",", "max_proposals", "=", "-", "1", ",", "score_field", "=", "\"scores\"", ")", ":", "\n", "    ", "\"\"\"\n    Performs non-maximum suppression on a boxlist, with scores specified\n    in a boxlist field via score_field.\n\n    Arguments:\n        boxlist(BoxList)\n        nms_thresh (float)\n        max_proposals (int): if > 0, then only the top max_proposals are kept\n            after non-maximum suppression\n        score_field (str)\n    \"\"\"", "\n", "if", "nms_thresh", "<=", "0", ":", "\n", "        ", "return", "boxlist", "\n", "", "mode", "=", "boxlist", ".", "mode", "\n", "boxlist", "=", "boxlist", ".", "convert", "(", "\"xyxy\"", ")", "\n", "boxes", "=", "boxlist", ".", "bbox", "\n", "score", "=", "boxlist", ".", "get_field", "(", "score_field", ")", "\n", "keep", "=", "_box_nms", "(", "boxes", ",", "score", ",", "nms_thresh", ")", "\n", "if", "max_proposals", ">", "0", ":", "\n", "        ", "keep", "=", "keep", "[", ":", "max_proposals", "]", "\n", "", "boxlist", "=", "boxlist", "[", "keep", "]", "\n", "return", "boxlist", ".", "convert", "(", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.remove_small_boxes": [[34, 49], ["xywh_boxes.unbind", "boxlist.convert"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert"], ["", "def", "remove_small_boxes", "(", "boxlist", ",", "min_size", ")", ":", "\n", "    ", "\"\"\"\n    Only keep boxes with both sides >= min_size\n\n    Arguments:\n        boxlist (Boxlist)\n        min_size (int)\n    \"\"\"", "\n", "# TODO maybe add an API for querying the ws / hs", "\n", "xywh_boxes", "=", "boxlist", ".", "convert", "(", "\"xywh\"", ")", ".", "bbox", "\n", "_", ",", "_", ",", "ws", ",", "hs", "=", "xywh_boxes", ".", "unbind", "(", "dim", "=", "1", ")", "\n", "keep", "=", "(", "\n", "(", "ws", ">=", "min_size", ")", "&", "(", "hs", ">=", "min_size", ")", "\n", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "return", "boxlist", "[", "keep", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_iou": [[53, 90], ["boxlist1.convert.convert", "boxlist2.convert.convert", "len", "len", "boxlist1.convert.area", "boxlist2.convert.area", "torch.max", "torch.min", "RuntimeError"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.area", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.area"], ["", "def", "boxlist_iou", "(", "boxlist1", ",", "boxlist2", ")", ":", "\n", "    ", "\"\"\"Compute the intersection over union of two set of boxes.\n    The box order must be (xmin, ymin, xmax, ymax).\n\n    Arguments:\n      box1: (BoxList) bounding boxes, sized [N,4].\n      box2: (BoxList) bounding boxes, sized [M,4].\n\n    Returns:\n      (tensor) iou, sized [N,M].\n\n    Reference:\n      https://github.com/chainer/chainercv/blob/master/chainercv/utils/bbox/bbox_iou.py\n    \"\"\"", "\n", "if", "boxlist1", ".", "size", "!=", "boxlist2", ".", "size", ":", "\n", "        ", "raise", "RuntimeError", "(", "\n", "\"boxlists should have same image size, got {}, {}\"", ".", "format", "(", "boxlist1", ",", "boxlist2", ")", ")", "\n", "", "boxlist1", "=", "boxlist1", ".", "convert", "(", "\"xyxy\"", ")", "\n", "boxlist2", "=", "boxlist2", ".", "convert", "(", "\"xyxy\"", ")", "\n", "N", "=", "len", "(", "boxlist1", ")", "\n", "M", "=", "len", "(", "boxlist2", ")", "\n", "\n", "area1", "=", "boxlist1", ".", "area", "(", ")", "\n", "area2", "=", "boxlist2", ".", "area", "(", ")", "\n", "\n", "box1", ",", "box2", "=", "boxlist1", ".", "bbox", ",", "boxlist2", ".", "bbox", "\n", "\n", "lt", "=", "torch", ".", "max", "(", "box1", "[", ":", ",", "None", ",", ":", "2", "]", ",", "box2", "[", ":", ",", ":", "2", "]", ")", "# [N,M,2]", "\n", "rb", "=", "torch", ".", "min", "(", "box1", "[", ":", ",", "None", ",", "2", ":", "]", ",", "box2", "[", ":", ",", "2", ":", "]", ")", "# [N,M,2]", "\n", "\n", "TO_REMOVE", "=", "1", "\n", "\n", "wh", "=", "(", "rb", "-", "lt", "+", "TO_REMOVE", ")", ".", "clamp", "(", "min", "=", "0", ")", "# [N,M,2]", "\n", "inter", "=", "wh", "[", ":", ",", ":", ",", "0", "]", "*", "wh", "[", ":", ",", ":", ",", "1", "]", "# [N,M]", "\n", "\n", "iou", "=", "inter", "/", "(", "area1", "[", ":", ",", "None", "]", "+", "area2", "-", "inter", ")", "\n", "return", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops._cat": [[93, 101], ["isinstance", "torch.cat", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "_cat", "(", "tensors", ",", "dim", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Efficient version of torch.cat that avoids a copy if there is only a single element in a list\n    \"\"\"", "\n", "assert", "isinstance", "(", "tensors", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "len", "(", "tensors", ")", "==", "1", ":", "\n", "        ", "return", "tensors", "[", "0", "]", "\n", "", "return", "torch", ".", "cat", "(", "tensors", ",", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.cat_boxlist": [[103, 130], ["isinstance", "all", "all", "all", "set", "all", "bounding_box.BoxList", "bboxes[].fields", "boxlist_ops._cat", "boxlist_ops._cat", "bounding_box.BoxList.add_field", "isinstance", "set", "bbox.get_field", "bbox.fields"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops._cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops._cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.fields"], ["", "def", "cat_boxlist", "(", "bboxes", ")", ":", "\n", "    ", "\"\"\"\n    Concatenates a list of BoxList (having the same image size) into a\n    single BoxList\n\n    Arguments:\n        bboxes (list[BoxList])\n    \"\"\"", "\n", "assert", "isinstance", "(", "bboxes", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "all", "(", "isinstance", "(", "bbox", ",", "BoxList", ")", "for", "bbox", "in", "bboxes", ")", "\n", "\n", "size", "=", "bboxes", "[", "0", "]", ".", "size", "\n", "assert", "all", "(", "bbox", ".", "size", "==", "size", "for", "bbox", "in", "bboxes", ")", "\n", "\n", "mode", "=", "bboxes", "[", "0", "]", ".", "mode", "\n", "assert", "all", "(", "bbox", ".", "mode", "==", "mode", "for", "bbox", "in", "bboxes", ")", "\n", "\n", "fields", "=", "set", "(", "bboxes", "[", "0", "]", ".", "fields", "(", ")", ")", "\n", "assert", "all", "(", "set", "(", "bbox", ".", "fields", "(", ")", ")", "==", "fields", "for", "bbox", "in", "bboxes", ")", "\n", "\n", "cat_boxes", "=", "BoxList", "(", "_cat", "(", "[", "bbox", ".", "bbox", "for", "bbox", "in", "bboxes", "]", ",", "dim", "=", "0", ")", ",", "size", ",", "mode", ")", "\n", "\n", "for", "field", "in", "fields", ":", "\n", "        ", "data", "=", "_cat", "(", "[", "bbox", ".", "get_field", "(", "field", ")", "for", "bbox", "in", "bboxes", "]", ",", "dim", "=", "0", ")", "\n", "cat_boxes", ".", "add_field", "(", "field", ",", "data", ")", "\n", "\n", "", "return", "cat_boxes", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.__init__": [[9, 25], ["torch.as_tensor", "isinstance", "torch.device", "keypoints.view.view.view"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["    ", "def", "__init__", "(", "self", ",", "keypoints", ",", "size", ",", "mode", "=", "None", ")", ":", "\n", "# FIXME remove check once we have better integration with device", "\n", "# in my version this would consistently return a CPU tensor", "\n", "        ", "device", "=", "keypoints", ".", "device", "if", "isinstance", "(", "keypoints", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "'cpu'", ")", "\n", "keypoints", "=", "torch", ".", "as_tensor", "(", "keypoints", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "num_keypoints", "=", "keypoints", ".", "shape", "[", "0", "]", "\n", "if", "num_keypoints", ":", "\n", "            ", "keypoints", "=", "keypoints", ".", "view", "(", "num_keypoints", ",", "-", "1", ",", "3", ")", "\n", "\n", "# TODO should I split them?", "\n", "# self.visibility = keypoints[..., 2]", "\n", "", "self", ".", "keypoints", "=", "keypoints", "# [..., :2]", "\n", "\n", "self", ".", "size", "=", "size", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "extra_fields", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.crop": [[26, 28], ["NotImplementedError"], "methods", ["None"], ["", "def", "crop", "(", "self", ",", "box", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize": [[29, 39], ["tuple", "keypoint.Keypoints.keypoints.clone", "keypoint.Keypoints.extra_fields.items", "type", "keypoints.add_field", "float", "float", "zip"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["", "def", "resize", "(", "self", ",", "size", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "ratios", "=", "tuple", "(", "float", "(", "s", ")", "/", "float", "(", "s_orig", ")", "for", "s", ",", "s_orig", "in", "zip", "(", "size", ",", "self", ".", "size", ")", ")", "\n", "ratio_w", ",", "ratio_h", "=", "ratios", "\n", "resized_data", "=", "self", ".", "keypoints", ".", "clone", "(", ")", "\n", "resized_data", "[", "...", ",", "0", "]", "*=", "ratio_w", "\n", "resized_data", "[", "...", ",", "1", "]", "*=", "ratio_h", "\n", "keypoints", "=", "type", "(", "self", ")", "(", "resized_data", ",", "size", ",", "self", ".", "mode", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "keypoints", ".", "add_field", "(", "k", ",", "v", ")", "\n", "", "return", "keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose": [[40, 60], ["keypoint.Keypoints.extra_fields.items", "NotImplementedError", "type", "type", "keypoints.add_field"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["", "def", "transpose", "(", "self", ",", "method", ")", ":", "\n", "        ", "if", "method", "not", "in", "(", "FLIP_LEFT_RIGHT", ",", ")", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Only FLIP_LEFT_RIGHT implemented\"", ")", "\n", "\n", "", "flip_inds", "=", "type", "(", "self", ")", ".", "FLIP_INDS", "\n", "flipped_data", "=", "self", ".", "keypoints", "[", ":", ",", "flip_inds", "]", "\n", "width", "=", "self", ".", "size", "[", "0", "]", "\n", "TO_REMOVE", "=", "1", "\n", "# Flip x coordinates", "\n", "flipped_data", "[", "...", ",", "0", "]", "=", "width", "-", "flipped_data", "[", "...", ",", "0", "]", "-", "TO_REMOVE", "\n", "\n", "# Maintain COCO convention that if visibility == 0, then x, y = 0", "\n", "inds", "=", "flipped_data", "[", "...", ",", "2", "]", "==", "0", "\n", "flipped_data", "[", "inds", "]", "=", "0", "\n", "\n", "keypoints", "=", "type", "(", "self", ")", "(", "flipped_data", ",", "self", ".", "size", ",", "self", ".", "mode", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "keypoints", ".", "add_field", "(", "k", ",", "v", ")", "\n", "", "return", "keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to": [[61, 68], ["keypoint.Keypoints.extra_fields.items", "type", "keypoint.Keypoints.keypoints.to", "hasattr", "keypoints.add_field", "v.to.to.to"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "to", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "keypoints", "=", "type", "(", "self", ")", "(", "self", ".", "keypoints", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", ",", "self", ".", "size", ",", "self", ".", "mode", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "v", ",", "\"to\"", ")", ":", "\n", "                ", "v", "=", "v", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "keypoints", ".", "add_field", "(", "k", ",", "v", ")", "\n", "", "return", "keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.__getitem__": [[69, 74], ["keypoint.Keypoints.extra_fields.items", "type", "keypoints.add_field"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "keypoints", "=", "type", "(", "self", ")", "(", "self", ".", "keypoints", "[", "item", "]", ",", "self", ".", "size", ",", "self", ".", "mode", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "keypoints", ".", "add_field", "(", "k", ",", "v", "[", "item", "]", ")", "\n", "", "return", "keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field": [[75, 77], ["None"], "methods", ["None"], ["", "def", "add_field", "(", "self", ",", "field", ",", "field_data", ")", ":", "\n", "        ", "self", ".", "extra_fields", "[", "field", "]", "=", "field_data", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field": [[78, 80], ["None"], "methods", ["None"], ["", "def", "get_field", "(", "self", ",", "field", ")", ":", "\n", "        ", "return", "self", ".", "extra_fields", "[", "field", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.__repr__": [[81, 87], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "'('", "\n", "s", "+=", "'num_instances={}, '", ".", "format", "(", "len", "(", "self", ".", "keypoints", ")", ")", "\n", "s", "+=", "'image_width={}, '", ".", "format", "(", "self", ".", "size", "[", "0", "]", ")", "\n", "s", "+=", "'image_height={})'", ".", "format", "(", "self", ".", "size", "[", "1", "]", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint._create_flip_indices": [[89, 95], ["flip_map.copy", "flip_map.copy.update", "torch.tensor", "names.index", "flip_map.items"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update"], ["", "", "def", "_create_flip_indices", "(", "names", ",", "flip_map", ")", ":", "\n", "    ", "full_flip_map", "=", "flip_map", ".", "copy", "(", ")", "\n", "full_flip_map", ".", "update", "(", "{", "v", ":", "k", "for", "k", ",", "v", "in", "flip_map", ".", "items", "(", ")", "}", ")", "\n", "flipped_names", "=", "[", "i", "if", "i", "not", "in", "full_flip_map", "else", "full_flip_map", "[", "i", "]", "for", "i", "in", "names", "]", "\n", "flip_indices", "=", "[", "names", ".", "index", "(", "i", ")", "for", "i", "in", "flipped_names", "]", "\n", "return", "torch", ".", "tensor", "(", "flip_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.kp_connections": [[131, 150], ["keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index", "keypoints.index"], "function", ["None"], ["def", "kp_connections", "(", "keypoints", ")", ":", "\n", "    ", "kp_lines", "=", "[", "\n", "[", "keypoints", ".", "index", "(", "'left_eye'", ")", ",", "keypoints", ".", "index", "(", "'right_eye'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'left_eye'", ")", ",", "keypoints", ".", "index", "(", "'nose'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'right_eye'", ")", ",", "keypoints", ".", "index", "(", "'nose'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'right_eye'", ")", ",", "keypoints", ".", "index", "(", "'right_ear'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'left_eye'", ")", ",", "keypoints", ".", "index", "(", "'left_ear'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'right_shoulder'", ")", ",", "keypoints", ".", "index", "(", "'right_elbow'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'right_elbow'", ")", ",", "keypoints", ".", "index", "(", "'right_wrist'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'left_shoulder'", ")", ",", "keypoints", ".", "index", "(", "'left_elbow'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'left_elbow'", ")", ",", "keypoints", ".", "index", "(", "'left_wrist'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'right_hip'", ")", ",", "keypoints", ".", "index", "(", "'right_knee'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'right_knee'", ")", ",", "keypoints", ".", "index", "(", "'right_ankle'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'left_hip'", ")", ",", "keypoints", ".", "index", "(", "'left_knee'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'left_knee'", ")", ",", "keypoints", ".", "index", "(", "'left_ankle'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'right_shoulder'", ")", ",", "keypoints", ".", "index", "(", "'left_shoulder'", ")", "]", ",", "\n", "[", "keypoints", ".", "index", "(", "'right_hip'", ")", ",", "keypoints", ".", "index", "(", "'left_hip'", ")", "]", ",", "\n", "]", "\n", "return", "kp_lines", "\n", "", "PersonKeypoints", ".", "CONNECTIONS", "=", "kp_connections", "(", "PersonKeypoints", ".", "NAMES", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.keypoints_to_heat_map": [[154, 189], ["x.floor().long.floor().long", "y.floor().long.floor().long", "rois.numel", "rois.new().long", "rois.new().long", "x.floor().long.floor", "y.floor().long.floor", "rois.new", "rois.new"], "function", ["None"], ["def", "keypoints_to_heat_map", "(", "keypoints", ",", "rois", ",", "heatmap_size", ")", ":", "\n", "    ", "if", "rois", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "return", "rois", ".", "new", "(", ")", ".", "long", "(", ")", ",", "rois", ".", "new", "(", ")", ".", "long", "(", ")", "\n", "", "offset_x", "=", "rois", "[", ":", ",", "0", "]", "\n", "offset_y", "=", "rois", "[", ":", ",", "1", "]", "\n", "scale_x", "=", "heatmap_size", "/", "(", "rois", "[", ":", ",", "2", "]", "-", "rois", "[", ":", ",", "0", "]", ")", "\n", "scale_y", "=", "heatmap_size", "/", "(", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", ")", "\n", "\n", "offset_x", "=", "offset_x", "[", ":", ",", "None", "]", "\n", "offset_y", "=", "offset_y", "[", ":", ",", "None", "]", "\n", "scale_x", "=", "scale_x", "[", ":", ",", "None", "]", "\n", "scale_y", "=", "scale_y", "[", ":", ",", "None", "]", "\n", "\n", "x", "=", "keypoints", "[", "...", ",", "0", "]", "\n", "y", "=", "keypoints", "[", "...", ",", "1", "]", "\n", "\n", "x_boundary_inds", "=", "x", "==", "rois", "[", ":", ",", "2", "]", "[", ":", ",", "None", "]", "\n", "y_boundary_inds", "=", "y", "==", "rois", "[", ":", ",", "3", "]", "[", ":", ",", "None", "]", "\n", "\n", "x", "=", "(", "x", "-", "offset_x", ")", "*", "scale_x", "\n", "x", "=", "x", ".", "floor", "(", ")", ".", "long", "(", ")", "\n", "y", "=", "(", "y", "-", "offset_y", ")", "*", "scale_y", "\n", "y", "=", "y", ".", "floor", "(", ")", ".", "long", "(", ")", "\n", "\n", "x", "[", "x_boundary_inds", "]", "=", "heatmap_size", "-", "1", "\n", "y", "[", "y_boundary_inds", "]", "=", "heatmap_size", "-", "1", "\n", "\n", "valid_loc", "=", "(", "x", ">=", "0", ")", "&", "(", "y", ">=", "0", ")", "&", "(", "x", "<", "heatmap_size", ")", "&", "(", "y", "<", "heatmap_size", ")", "\n", "vis", "=", "keypoints", "[", "...", ",", "2", "]", ">", "0", "\n", "valid", "=", "(", "valid_loc", "&", "vis", ")", ".", "long", "(", ")", "\n", "\n", "lin_ind", "=", "y", "*", "heatmap_size", "+", "x", "\n", "heatmaps", "=", "lin_ind", "*", "valid", "\n", "\n", "return", "heatmaps", ",", "valid", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.config.paths_catalog.DatasetCatalog.get": [[129, 165], ["RuntimeError", "dict", "dict", "dict", "dict", "dict", "dict", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "get", "(", "name", ")", ":", "\n", "        ", "if", "\"coco\"", "in", "name", ":", "\n", "            ", "data_dir", "=", "DatasetCatalog", ".", "DATA_DIR", "\n", "attrs", "=", "DatasetCatalog", ".", "DATASETS", "[", "name", "]", "\n", "args", "=", "dict", "(", "\n", "root", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "attrs", "[", "\"img_dir\"", "]", ")", ",", "\n", "ann_file", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "attrs", "[", "\"ann_file\"", "]", ")", ",", "\n", ")", "\n", "return", "dict", "(", "\n", "factory", "=", "\"COCODataset\"", ",", "\n", "args", "=", "args", ",", "\n", ")", "\n", "", "if", "\"vcr\"", "in", "name", ":", "\n", "            ", "data_dir", "=", "DatasetCatalog", ".", "DATA_DIR", "\n", "attrs", "=", "DatasetCatalog", ".", "DATASETS", "[", "name", "]", "\n", "args", "=", "dict", "(", "\n", "datadir", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "attrs", "[", "\"img_dir\"", "]", ")", ",", "\n", "ann_file", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "attrs", "[", "\"ann_file\"", "]", ")", ",", "\n", ")", "\n", "return", "dict", "(", "\n", "factory", "=", "\"vcrDataset\"", ",", "\n", "args", "=", "args", ",", "\n", ")", "\n", "", "elif", "\"voc\"", "in", "name", ":", "\n", "            ", "data_dir", "=", "DatasetCatalog", ".", "DATA_DIR", "\n", "attrs", "=", "DatasetCatalog", ".", "DATASETS", "[", "name", "]", "\n", "args", "=", "dict", "(", "\n", "data_dir", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "attrs", "[", "\"data_dir\"", "]", ")", ",", "\n", "split", "=", "attrs", "[", "\"split\"", "]", ",", "\n", ")", "\n", "return", "dict", "(", "\n", "factory", "=", "\"PascalVOCDataset\"", ",", "\n", "args", "=", "args", ",", "\n", ")", "\n", "", "raise", "RuntimeError", "(", "\"Dataset not available: {}\"", ".", "format", "(", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.config.paths_catalog.ModelCatalog.get": [[192, 199], ["name.startswith", "name.startswith", "RuntimeError", "paths_catalog.ModelCatalog.get_c2_detectron_12_2017_baselines", "paths_catalog.ModelCatalog.get_c2_imagenet_pretrained"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.config.paths_catalog.ModelCatalog.get_c2_detectron_12_2017_baselines", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.config.paths_catalog.ModelCatalog.get_c2_imagenet_pretrained"], ["@", "staticmethod", "\n", "def", "get", "(", "name", ")", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "\"Caffe2Detectron/COCO\"", ")", ":", "\n", "            ", "return", "ModelCatalog", ".", "get_c2_detectron_12_2017_baselines", "(", "name", ")", "\n", "", "if", "name", ".", "startswith", "(", "\"ImageNetPretrained\"", ")", ":", "\n", "            ", "return", "ModelCatalog", ".", "get_c2_imagenet_pretrained", "(", "name", ")", "\n", "", "raise", "RuntimeError", "(", "\"model not present in the catalog {}\"", ".", "format", "(", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.config.paths_catalog.ModelCatalog.get_c2_imagenet_pretrained": [[200, 207], ["len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_c2_imagenet_pretrained", "(", "name", ")", ":", "\n", "        ", "prefix", "=", "ModelCatalog", ".", "S3_C2_DETECTRON_URL", "\n", "name", "=", "name", "[", "len", "(", "\"ImageNetPretrained/\"", ")", ":", "]", "\n", "name", "=", "ModelCatalog", ".", "C2_IMAGENET_MODELS", "[", "name", "]", "\n", "url", "=", "\"/\"", ".", "join", "(", "[", "prefix", ",", "name", "]", ")", "\n", "return", "url", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.config.paths_catalog.ModelCatalog.get_c2_detectron_12_2017_baselines": [[208, 226], ["ModelCatalog.C2_DETECTRON_SUFFIX.format", "name.split", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_c2_detectron_12_2017_baselines", "(", "name", ")", ":", "\n", "# Detectron C2 models are stored following the structure", "\n", "# prefix/<model_id>/2012_2017_baselines/<model_name>.yaml.<signature>/suffix", "\n", "# we use as identifiers in the catalog Caffe2Detectron/COCO/<model_id>/<model_name>", "\n", "        ", "prefix", "=", "ModelCatalog", ".", "S3_C2_DETECTRON_URL", "\n", "dataset_tag", "=", "\"keypoints_\"", "if", "\"keypoint\"", "in", "name", "else", "\"\"", "\n", "suffix", "=", "ModelCatalog", ".", "C2_DETECTRON_SUFFIX", ".", "format", "(", "dataset_tag", ",", "dataset_tag", ")", "\n", "# remove identification prefix", "\n", "name", "=", "name", "[", "len", "(", "\"Caffe2Detectron/COCO/\"", ")", ":", "]", "\n", "# split in <model_id> and <model_name>", "\n", "model_id", ",", "model_name", "=", "name", ".", "split", "(", "\"/\"", ")", "\n", "# parsing to make it match the url address from the Caffe2 models", "\n", "model_name", "=", "\"{}.yaml\"", ".", "format", "(", "model_name", ")", "\n", "signature", "=", "ModelCatalog", ".", "C2_DETECTRON_MODELS", "[", "name", "]", "\n", "unique_name", "=", "\".\"", ".", "join", "(", "[", "model_name", ",", "signature", "]", ")", "\n", "url", "=", "\"/\"", ".", "join", "(", "[", "prefix", ",", "model_id", ",", "\"12_2017_baselines\"", ",", "unique_name", ",", "suffix", "]", ")", "\n", "return", "url", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers._utils._load_C_extensions": [[14, 36], ["os.path.dirname", "os.path.dirname", "os.path.join", "glob.glob", "glob.glob", "glob.glob", "load_ext", "os.path.abspath", "os.path.join", "os.path.join", "os.path.join", "torch.cuda.is_available", "source.extend", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend"], ["", "def", "_load_C_extensions", "(", ")", ":", "\n", "    ", "this_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "this_dir", "=", "os", ".", "path", ".", "dirname", "(", "this_dir", ")", "\n", "this_dir", "=", "os", ".", "path", ".", "join", "(", "this_dir", ",", "\"csrc\"", ")", "\n", "\n", "main_file", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "this_dir", ",", "\"*.cpp\"", ")", ")", "\n", "source_cpu", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "this_dir", ",", "\"cpu\"", ",", "\"*.cpp\"", ")", ")", "\n", "source_cuda", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "this_dir", ",", "\"cuda\"", ",", "\"*.cu\"", ")", ")", "\n", "\n", "source", "=", "main_file", "+", "source_cpu", "\n", "\n", "extra_cflags", "=", "[", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "CUDA_HOME", "is", "not", "None", ":", "\n", "        ", "source", ".", "extend", "(", "source_cuda", ")", "\n", "extra_cflags", "=", "[", "\"-DWITH_CUDA\"", "]", "\n", "", "source", "=", "[", "os", ".", "path", ".", "join", "(", "this_dir", ",", "s", ")", "for", "s", "in", "source", "]", "\n", "extra_include_paths", "=", "[", "this_dir", "]", "\n", "return", "load_ext", "(", "\n", "\"torchvision\"", ",", "\n", "source", ",", "\n", "extra_cflags", "=", "extra_cflags", ",", "\n", "extra_include_paths", "=", "extra_include_paths", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.sigmoid_focal_loss._SigmoidFocalLoss.forward": [[10, 22], ["ctx.save_for_backward", "vc_rcnn._C.sigmoid_focalloss_forward"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "logits", ",", "targets", ",", "gamma", ",", "alpha", ")", ":", "\n", "        ", "ctx", ".", "save_for_backward", "(", "logits", ",", "targets", ")", "\n", "num_classes", "=", "logits", ".", "shape", "[", "1", "]", "\n", "ctx", ".", "num_classes", "=", "num_classes", "\n", "ctx", ".", "gamma", "=", "gamma", "\n", "ctx", ".", "alpha", "=", "alpha", "\n", "\n", "losses", "=", "_C", ".", "sigmoid_focalloss_forward", "(", "\n", "logits", ",", "targets", ",", "num_classes", ",", "gamma", ",", "alpha", "\n", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.sigmoid_focal_loss._SigmoidFocalLoss.backward": [[23, 35], ["d_loss.contiguous.contiguous.contiguous", "vc_rcnn._C.sigmoid_focalloss_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "d_loss", ")", ":", "\n", "        ", "logits", ",", "targets", "=", "ctx", ".", "saved_tensors", "\n", "num_classes", "=", "ctx", ".", "num_classes", "\n", "gamma", "=", "ctx", ".", "gamma", "\n", "alpha", "=", "ctx", ".", "alpha", "\n", "d_loss", "=", "d_loss", ".", "contiguous", "(", ")", "\n", "d_logits", "=", "_C", ".", "sigmoid_focalloss_backward", "(", "\n", "logits", ",", "targets", ",", "d_loss", ",", "num_classes", ",", "gamma", ",", "alpha", "\n", ")", "\n", "return", "d_logits", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.sigmoid_focal_loss.SigmoidFocalLoss.__init__": [[54, 58], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "gamma", ",", "alpha", ")", ":", "\n", "        ", "super", "(", "SigmoidFocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.sigmoid_focal_loss.SigmoidFocalLoss.forward": [[59, 68], ["loss_func", "loss_func.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "logits", ",", "targets", ")", ":", "\n", "        ", "device", "=", "logits", ".", "device", "\n", "if", "logits", ".", "is_cuda", ":", "\n", "            ", "loss_func", "=", "sigmoid_focal_loss_cuda", "\n", "", "else", ":", "\n", "            ", "loss_func", "=", "sigmoid_focal_loss_cpu", "\n", "\n", "", "loss", "=", "loss_func", "(", "logits", ",", "targets", ",", "self", ".", "gamma", ",", "self", ".", "alpha", ")", "\n", "return", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.sigmoid_focal_loss.SigmoidFocalLoss.__repr__": [[69, 75], ["str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "tmpstr", "+=", "\"gamma=\"", "+", "str", "(", "self", ".", "gamma", ")", "\n", "tmpstr", "+=", "\", alpha=\"", "+", "str", "(", "self", ".", "alpha", ")", "\n", "tmpstr", "+=", "\")\"", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.sigmoid_focal_loss.sigmoid_focal_loss_cpu": [[40, 51], ["torch.arange().unsqueeze", "targets.unsqueeze", "torch.sigmoid", "torch.log", "torch.log", "torch.arange"], "function", ["None"], ["def", "sigmoid_focal_loss_cpu", "(", "logits", ",", "targets", ",", "gamma", ",", "alpha", ")", ":", "\n", "    ", "num_classes", "=", "logits", ".", "shape", "[", "1", "]", "\n", "dtype", "=", "targets", ".", "dtype", "\n", "device", "=", "targets", ".", "device", "\n", "class_range", "=", "torch", ".", "arange", "(", "1", ",", "num_classes", "+", "1", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "t", "=", "targets", ".", "unsqueeze", "(", "1", ")", "\n", "p", "=", "torch", ".", "sigmoid", "(", "logits", ")", "\n", "term1", "=", "(", "1", "-", "p", ")", "**", "gamma", "*", "torch", ".", "log", "(", "p", ")", "\n", "term2", "=", "p", "**", "gamma", "*", "torch", ".", "log", "(", "1", "-", "p", ")", "\n", "return", "-", "(", "t", "==", "class_range", ")", ".", "float", "(", ")", "*", "term1", "*", "alpha", "-", "(", "(", "t", "!=", "class_range", ")", "*", "(", "t", ">=", "0", ")", ")", ".", "float", "(", ")", "*", "term2", "*", "(", "1", "-", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_pool._ROIPool.forward": [[13, 23], ["torch.nn.modules.utils._pair", "input.size", "vc_rcnn._C.roi_pool_forward", "ctx.save_for_backward"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ",", "roi", ",", "output_size", ",", "spatial_scale", ")", ":", "\n", "        ", "ctx", ".", "output_size", "=", "_pair", "(", "output_size", ")", "\n", "ctx", ".", "spatial_scale", "=", "spatial_scale", "\n", "ctx", ".", "input_shape", "=", "input", ".", "size", "(", ")", "\n", "output", ",", "argmax", "=", "_C", ".", "roi_pool_forward", "(", "\n", "input", ",", "roi", ",", "spatial_scale", ",", "output_size", "[", "0", "]", ",", "output_size", "[", "1", "]", "\n", ")", "\n", "ctx", ".", "save_for_backward", "(", "input", ",", "roi", ",", "argmax", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_pool._ROIPool.backward": [[24, 45], ["vc_rcnn._C.roi_pool_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "input", ",", "rois", ",", "argmax", "=", "ctx", ".", "saved_tensors", "\n", "output_size", "=", "ctx", ".", "output_size", "\n", "spatial_scale", "=", "ctx", ".", "spatial_scale", "\n", "bs", ",", "ch", ",", "h", ",", "w", "=", "ctx", ".", "input_shape", "\n", "grad_input", "=", "_C", ".", "roi_pool_backward", "(", "\n", "grad_output", ",", "\n", "input", ",", "\n", "rois", ",", "\n", "argmax", ",", "\n", "spatial_scale", ",", "\n", "output_size", "[", "0", "]", ",", "\n", "output_size", "[", "1", "]", ",", "\n", "bs", ",", "\n", "ch", ",", "\n", "h", ",", "\n", "w", ",", "\n", ")", "\n", "return", "grad_input", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_pool.ROIPool.__init__": [[51, 55], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "output_size", ",", "spatial_scale", ")", ":", "\n", "        ", "super", "(", "ROIPool", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_pool.ROIPool.forward": [[56, 59], ["roi_pool"], "methods", ["None"], ["", "@", "amp", ".", "float_function", "\n", "def", "forward", "(", "self", ",", "input", ",", "rois", ")", ":", "\n", "        ", "return", "roi_pool", "(", "input", ",", "rois", ",", "self", ".", "output_size", ",", "self", ".", "spatial_scale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_pool.ROIPool.__repr__": [[60, 66], ["str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "tmpstr", "+=", "\"output_size=\"", "+", "str", "(", "self", ".", "output_size", ")", "\n", "tmpstr", "+=", "\", spatial_scale=\"", "+", "str", "(", "self", ".", "spatial_scale", ")", "\n", "tmpstr", "+=", "\")\"", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.batch_norm.FrozenBatchNorm2d.__init__": [[12, 18], ["torch.nn.Module.__init__", "batch_norm.FrozenBatchNorm2d.register_buffer", "batch_norm.FrozenBatchNorm2d.register_buffer", "batch_norm.FrozenBatchNorm2d.register_buffer", "batch_norm.FrozenBatchNorm2d.register_buffer", "torch.ones", "torch.zeros", "torch.zeros", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "n", ")", ":", "\n", "        ", "super", "(", "FrozenBatchNorm2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "register_buffer", "(", "\"weight\"", ",", "torch", ".", "ones", "(", "n", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"bias\"", ",", "torch", ".", "zeros", "(", "n", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"running_mean\"", ",", "torch", ".", "zeros", "(", "n", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"running_var\"", ",", "torch", ".", "ones", "(", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.batch_norm.FrozenBatchNorm2d.forward": [[19, 32], ["scale.reshape.reshape.reshape", "bias.reshape.reshape.reshape", "batch_norm.FrozenBatchNorm2d.weight.half", "batch_norm.FrozenBatchNorm2d.bias.half", "batch_norm.FrozenBatchNorm2d.running_mean.half", "batch_norm.FrozenBatchNorm2d.running_var.half", "batch_norm.FrozenBatchNorm2d.running_var.rsqrt"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# Cast all fixed parameters to half() if necessary", "\n", "        ", "if", "x", ".", "dtype", "==", "torch", ".", "float16", ":", "\n", "            ", "self", ".", "weight", "=", "self", ".", "weight", ".", "half", "(", ")", "\n", "self", ".", "bias", "=", "self", ".", "bias", ".", "half", "(", ")", "\n", "self", ".", "running_mean", "=", "self", ".", "running_mean", ".", "half", "(", ")", "\n", "self", ".", "running_var", "=", "self", ".", "running_var", ".", "half", "(", ")", "\n", "\n", "", "scale", "=", "self", ".", "weight", "*", "self", ".", "running_var", ".", "rsqrt", "(", ")", "\n", "bias", "=", "self", ".", "bias", "-", "self", ".", "running_mean", "*", "scale", "\n", "scale", "=", "scale", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "bias", "=", "bias", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "return", "x", "*", "scale", "+", "bias", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_align._ROIAlign.forward": [[13, 24], ["ctx.save_for_backward", "torch.nn.modules.utils._pair", "input.size", "vc_rcnn._C.roi_align_forward"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ",", "roi", ",", "output_size", ",", "spatial_scale", ",", "sampling_ratio", ")", ":", "\n", "        ", "ctx", ".", "save_for_backward", "(", "roi", ")", "\n", "ctx", ".", "output_size", "=", "_pair", "(", "output_size", ")", "\n", "ctx", ".", "spatial_scale", "=", "spatial_scale", "\n", "ctx", ".", "sampling_ratio", "=", "sampling_ratio", "\n", "ctx", ".", "input_shape", "=", "input", ".", "size", "(", ")", "\n", "output", "=", "_C", ".", "roi_align_forward", "(", "\n", "input", ",", "roi", ",", "spatial_scale", ",", "output_size", "[", "0", "]", ",", "output_size", "[", "1", "]", ",", "sampling_ratio", "\n", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_align._ROIAlign.backward": [[25, 46], ["vc_rcnn._C.roi_align_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "rois", ",", "=", "ctx", ".", "saved_tensors", "\n", "output_size", "=", "ctx", ".", "output_size", "\n", "spatial_scale", "=", "ctx", ".", "spatial_scale", "\n", "sampling_ratio", "=", "ctx", ".", "sampling_ratio", "\n", "bs", ",", "ch", ",", "h", ",", "w", "=", "ctx", ".", "input_shape", "\n", "grad_input", "=", "_C", ".", "roi_align_backward", "(", "\n", "grad_output", ",", "\n", "rois", ",", "\n", "spatial_scale", ",", "\n", "output_size", "[", "0", "]", ",", "\n", "output_size", "[", "1", "]", ",", "\n", "bs", ",", "\n", "ch", ",", "\n", "h", ",", "\n", "w", ",", "\n", "sampling_ratio", ",", "\n", ")", "\n", "return", "grad_input", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_align.ROIAlign.__init__": [[51, 56], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "output_size", ",", "spatial_scale", ",", "sampling_ratio", ")", ":", "\n", "        ", "super", "(", "ROIAlign", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "self", ".", "sampling_ratio", "=", "sampling_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_align.ROIAlign.forward": [[57, 61], ["roi_align"], "methods", ["None"], ["", "@", "amp", ".", "float_function", "\n", "def", "forward", "(", "self", ",", "input", ",", "rois", ")", ":", "\n", "        ", "return", "roi_align", "(", "\n", "input", ",", "rois", ",", "self", ".", "output_size", ",", "self", ".", "spatial_scale", ",", "self", ".", "sampling_ratio", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.roi_align.ROIAlign.__repr__": [[63, 70], ["str", "str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "tmpstr", "+=", "\"output_size=\"", "+", "str", "(", "self", ".", "output_size", ")", "\n", "tmpstr", "+=", "\", spatial_scale=\"", "+", "str", "(", "self", ".", "spatial_scale", ")", "\n", "tmpstr", "+=", "\", sampling_ratio=\"", "+", "str", "(", "self", ".", "sampling_ratio", ")", "\n", "tmpstr", "+=", "\")\"", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc._NewEmptyTensorOp.forward": [[19, 23], ["x.new_empty"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "x", ",", "new_shape", ")", ":", "\n", "        ", "ctx", ".", "shape", "=", "x", ".", "shape", "\n", "return", "x", ".", "new_empty", "(", "new_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc._NewEmptyTensorOp.backward": [[24, 28], ["_NewEmptyTensorOp.apply"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad", ")", ":", "\n", "        ", "shape", "=", "ctx", ".", "shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "grad", ",", "shape", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.Conv2d.forward": [[31, 44], ["_NewEmptyTensorOp.apply", "x.numel", "super().forward", "zip"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.forward"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "return", "super", "(", "Conv2d", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "# get output shape", "\n", "\n", "", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "d", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "d", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.ConvTranspose2d.forward": [[47, 65], ["_NewEmptyTensorOp.apply", "x.numel", "super().forward", "zip"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.forward"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "return", "super", "(", "ConvTranspose2d", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "# get output shape", "\n", "\n", "", "output_shape", "=", "[", "\n", "(", "i", "-", "1", ")", "*", "d", "-", "2", "*", "p", "+", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", "+", "op", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "d", ",", "op", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "\n", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "\n", "self", ".", "kernel_size", ",", "\n", "self", ".", "stride", ",", "\n", "self", ".", "output_padding", ",", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "bias", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.BatchNorm2d.forward": [[68, 74], ["_NewEmptyTensorOp.apply", "x.numel", "super().forward"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.forward"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "return", "super", "(", "BatchNorm2d", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "# get output shape", "\n", "", "output_shape", "=", "x", ".", "shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.DFConv2d.__init__": [[116, 179], ["torch.nn.Module.__init__", "isinstance", "misc.Conv2d", "conv_block", "isinstance", "isinstance", "torch.nn.init.kaiming_uniform_", "torch.nn.init.constant_", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "with_modulated_dcn", "=", "True", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "False", "\n", ")", ":", "\n", "        ", "super", "(", "DFConv2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "kernel_size", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "assert", "isinstance", "(", "stride", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "dilation", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "len", "(", "kernel_size", ")", "==", "2", "\n", "assert", "len", "(", "stride", ")", "==", "2", "\n", "assert", "len", "(", "dilation", ")", "==", "2", "\n", "padding", "=", "(", "\n", "dilation", "[", "0", "]", "*", "(", "kernel_size", "[", "0", "]", "-", "1", ")", "//", "2", ",", "\n", "dilation", "[", "1", "]", "*", "(", "kernel_size", "[", "1", "]", "-", "1", ")", "//", "2", "\n", ")", "\n", "offset_base_channels", "=", "kernel_size", "[", "0", "]", "*", "kernel_size", "[", "1", "]", "\n", "", "else", ":", "\n", "            ", "padding", "=", "dilation", "*", "(", "kernel_size", "-", "1", ")", "//", "2", "\n", "offset_base_channels", "=", "kernel_size", "*", "kernel_size", "\n", "", "if", "with_modulated_dcn", ":", "\n", "            ", "from", "vc_rcnn", ".", "layers", "import", "ModulatedDeformConv", "\n", "offset_channels", "=", "offset_base_channels", "*", "3", "#default: 27", "\n", "conv_block", "=", "ModulatedDeformConv", "\n", "", "else", ":", "\n", "            ", "from", "vc_rcnn", ".", "layers", "import", "DeformConv", "\n", "offset_channels", "=", "offset_base_channels", "*", "2", "#default: 18", "\n", "conv_block", "=", "DeformConv", "\n", "", "self", ".", "offset", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "deformable_groups", "*", "offset_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "groups", "=", "1", ",", "\n", "dilation", "=", "dilation", "\n", ")", "\n", "for", "l", "in", "[", "self", ".", "offset", ",", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "l", ".", "weight", ",", "a", "=", "1", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0.", ")", "\n", "", "self", ".", "conv", "=", "conv_block", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "dilation", "=", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "deformable_groups", "=", "deformable_groups", ",", "\n", "bias", "=", "bias", "\n", ")", "\n", "self", ".", "with_modulated_dcn", "=", "with_modulated_dcn", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilation", "=", "dilation", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.DFConv2d.forward": [[180, 204], ["_NewEmptyTensorOp.apply", "misc.DFConv2d.numel", "misc.DFConv2d.offset", "misc.DFConv2d.conv", "misc.DFConv2d.offset", "offset_mask[].sigmoid", "misc.DFConv2d.conv", "zip"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "if", "not", "self", ".", "with_modulated_dcn", ":", "\n", "                ", "offset", "=", "self", ".", "offset", "(", "x", ")", "\n", "x", "=", "self", ".", "conv", "(", "x", ",", "offset", ")", "\n", "", "else", ":", "\n", "                ", "offset_mask", "=", "self", ".", "offset", "(", "x", ")", "\n", "offset", "=", "offset_mask", "[", ":", ",", ":", "18", ",", ":", ",", ":", "]", "\n", "mask", "=", "offset_mask", "[", ":", ",", "-", "9", ":", ",", ":", ",", ":", "]", ".", "sigmoid", "(", ")", "\n", "x", "=", "self", ".", "conv", "(", "x", ",", "offset", ",", "mask", ")", "\n", "", "return", "x", "\n", "# get output shape", "\n", "", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "d", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "d", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "\n", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "\n", "self", ".", "kernel_size", ",", "\n", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "conv", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.interpolate": [[76, 112], ["tuple", "_NewEmptyTensorOp.apply", "input.numel", "torch.nn.functional.interpolate", "misc.interpolate._check_size_scale_factor"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.misc.interpolate"], ["", "", "def", "interpolate", "(", "\n", "input", ",", "size", "=", "None", ",", "scale_factor", "=", "None", ",", "mode", "=", "\"nearest\"", ",", "align_corners", "=", "None", "\n", ")", ":", "\n", "    ", "if", "input", ".", "numel", "(", ")", ">", "0", ":", "\n", "        ", "return", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "\n", "input", ",", "size", ",", "scale_factor", ",", "mode", ",", "align_corners", "\n", ")", "\n", "\n", "", "def", "_check_size_scale_factor", "(", "dim", ")", ":", "\n", "        ", "if", "size", "is", "None", "and", "scale_factor", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"either size or scale_factor should be defined\"", ")", "\n", "", "if", "size", "is", "not", "None", "and", "scale_factor", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"only one of size or scale_factor should be defined\"", ")", "\n", "", "if", "(", "\n", "scale_factor", "is", "not", "None", "\n", "and", "isinstance", "(", "scale_factor", ",", "tuple", ")", "\n", "and", "len", "(", "scale_factor", ")", "!=", "dim", "\n", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"scale_factor shape must match input shape. \"", "\n", "\"Input is {}D, scale_factor size is {}\"", ".", "format", "(", "dim", ",", "len", "(", "scale_factor", ")", ")", "\n", ")", "\n", "\n", "", "", "def", "_output_size", "(", "dim", ")", ":", "\n", "        ", "_check_size_scale_factor", "(", "dim", ")", "\n", "if", "size", "is", "not", "None", ":", "\n", "            ", "return", "size", "\n", "", "scale_factors", "=", "_ntuple", "(", "dim", ")", "(", "scale_factor", ")", "\n", "# math.floor might return float in py2.7", "\n", "return", "[", "\n", "int", "(", "math", ".", "floor", "(", "input", ".", "size", "(", "i", "+", "2", ")", "*", "scale_factors", "[", "i", "]", ")", ")", "for", "i", "in", "range", "(", "dim", ")", "\n", "]", "\n", "\n", "", "output_shape", "=", "tuple", "(", "_output_size", "(", "2", ")", ")", "\n", "output_shape", "=", "input", ".", "shape", "[", ":", "-", "2", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "input", ",", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.layers.smooth_l1_loss.smooth_l1_loss": [[6, 17], ["torch.abs", "torch.where", "torch.where.sum", "torch.where.mean"], "function", ["None"], ["def", "smooth_l1_loss", "(", "input", ",", "target", ",", "beta", "=", "1.", "/", "9", ",", "size_average", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    very similar to the smooth_l1_loss from pytorch, but with\n    the extra beta parameter\n    \"\"\"", "\n", "n", "=", "torch", ".", "abs", "(", "input", "-", "target", ")", "\n", "cond", "=", "n", "<", "beta", "\n", "loss", "=", "torch", ".", "where", "(", "cond", ",", "0.5", "*", "n", "**", "2", "/", "beta", ",", "n", "-", "0.5", "*", "beta", ")", "\n", "if", "size_average", ":", "\n", "        ", "return", "loss", ".", "mean", "(", ")", "\n", "", "return", "loss", ".", "sum", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_func.DeformConvFunction.forward": [[11, 69], ["torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "ctx.save_for_backward", "input.new_empty", "ValueError", "deform_conv_func.DeformConvFunction._output_size", "input.new_empty", "input.new_empty", "min", "vc_rcnn._C.deform_conv_forward", "input.dim", "weight.size", "weight.size", "input.dim"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_func.DeformConvFunction._output_size"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "\n", "ctx", ",", "\n", "input", ",", "\n", "offset", ",", "\n", "weight", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "im2col_step", "=", "64", "\n", ")", ":", "\n", "        ", "if", "input", "is", "not", "None", "and", "input", ".", "dim", "(", ")", "!=", "4", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Expected 4D tensor as input, got {}D tensor instead.\"", ".", "format", "(", "\n", "input", ".", "dim", "(", ")", ")", ")", "\n", "", "ctx", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "ctx", ".", "padding", "=", "_pair", "(", "padding", ")", "\n", "ctx", ".", "dilation", "=", "_pair", "(", "dilation", ")", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "im2col_step", "=", "im2col_step", "\n", "\n", "ctx", ".", "save_for_backward", "(", "input", ",", "offset", ",", "weight", ")", "\n", "\n", "output", "=", "input", ".", "new_empty", "(", "\n", "DeformConvFunction", ".", "_output_size", "(", "input", ",", "weight", ",", "ctx", ".", "padding", ",", "\n", "ctx", ".", "dilation", ",", "ctx", ".", "stride", ")", ")", "\n", "\n", "ctx", ".", "bufs_", "=", "[", "input", ".", "new_empty", "(", "0", ")", ",", "input", ".", "new_empty", "(", "0", ")", "]", "# columns, ones", "\n", "\n", "if", "not", "input", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "else", ":", "\n", "            ", "cur_im2col_step", "=", "min", "(", "ctx", ".", "im2col_step", ",", "input", ".", "shape", "[", "0", "]", ")", "\n", "assert", "(", "input", ".", "shape", "[", "0", "]", "%", "\n", "cur_im2col_step", ")", "==", "0", ",", "'im2col step must divide batchsize'", "\n", "_C", ".", "deform_conv_forward", "(", "\n", "input", ",", "\n", "weight", ",", "\n", "offset", ",", "\n", "output", ",", "\n", "ctx", ".", "bufs_", "[", "0", "]", ",", "\n", "ctx", ".", "bufs_", "[", "1", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "\n", "ctx", ".", "stride", "[", "1", "]", ",", "\n", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "\n", "ctx", ".", "padding", "[", "0", "]", ",", "\n", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "cur_im2col_step", "\n", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_func.DeformConvFunction.backward": [[70, 132], ["min", "torch.zeros_like", "torch.zeros_like", "vc_rcnn._C.deform_conv_backward_input", "torch.zeros_like", "vc_rcnn._C.deform_conv_backward_parameters", "weight.size", "weight.size", "weight.size", "weight.size"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "input", ",", "offset", ",", "weight", "=", "ctx", ".", "saved_tensors", "\n", "\n", "grad_input", "=", "grad_offset", "=", "grad_weight", "=", "None", "\n", "\n", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "else", ":", "\n", "            ", "cur_im2col_step", "=", "min", "(", "ctx", ".", "im2col_step", ",", "input", ".", "shape", "[", "0", "]", ")", "\n", "assert", "(", "input", ".", "shape", "[", "0", "]", "%", "\n", "cur_im2col_step", ")", "==", "0", ",", "'im2col step must divide batchsize'", "\n", "\n", "if", "ctx", ".", "needs_input_grad", "[", "0", "]", "or", "ctx", ".", "needs_input_grad", "[", "1", "]", ":", "\n", "                ", "grad_input", "=", "torch", ".", "zeros_like", "(", "input", ")", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "_C", ".", "deform_conv_backward_input", "(", "\n", "input", ",", "\n", "offset", ",", "\n", "grad_output", ",", "\n", "grad_input", ",", "\n", "grad_offset", ",", "\n", "weight", ",", "\n", "ctx", ".", "bufs_", "[", "0", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "\n", "ctx", ".", "stride", "[", "1", "]", ",", "\n", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "\n", "ctx", ".", "padding", "[", "0", "]", ",", "\n", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "cur_im2col_step", "\n", ")", "\n", "\n", "", "if", "ctx", ".", "needs_input_grad", "[", "2", "]", ":", "\n", "                ", "grad_weight", "=", "torch", ".", "zeros_like", "(", "weight", ")", "\n", "_C", ".", "deform_conv_backward_parameters", "(", "\n", "input", ",", "\n", "offset", ",", "\n", "grad_output", ",", "\n", "grad_weight", ",", "\n", "ctx", ".", "bufs_", "[", "0", "]", ",", "\n", "ctx", ".", "bufs_", "[", "1", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "\n", "ctx", ".", "stride", "[", "1", "]", ",", "\n", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "\n", "ctx", ".", "padding", "[", "0", "]", ",", "\n", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "1", ",", "\n", "cur_im2col_step", "\n", ")", "\n", "\n", "", "", "return", "(", "grad_input", ",", "grad_offset", ",", "grad_weight", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_func.DeformConvFunction._output_size": [[133, 148], ["weight.size", "range", "input.size", "input.size", "all", "ValueError", "input.dim", "map", "weight.size", "map"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_output_size", "(", "input", ",", "weight", ",", "padding", ",", "dilation", ",", "stride", ")", ":", "\n", "        ", "channels", "=", "weight", ".", "size", "(", "0", ")", "\n", "output_size", "=", "(", "input", ".", "size", "(", "0", ")", ",", "channels", ")", "\n", "for", "d", "in", "range", "(", "input", ".", "dim", "(", ")", "-", "2", ")", ":", "\n", "            ", "in_size", "=", "input", ".", "size", "(", "d", "+", "2", ")", "\n", "pad", "=", "padding", "[", "d", "]", "\n", "kernel", "=", "dilation", "[", "d", "]", "*", "(", "weight", ".", "size", "(", "d", "+", "2", ")", "-", "1", ")", "+", "1", "\n", "stride_", "=", "stride", "[", "d", "]", "\n", "output_size", "+=", "(", "(", "in_size", "+", "(", "2", "*", "pad", ")", "-", "kernel", ")", "//", "stride_", "+", "1", ",", ")", "\n", "", "if", "not", "all", "(", "map", "(", "lambda", "s", ":", "s", ">", "0", ",", "output_size", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"convolution input is too small (output would be {})\"", ".", "format", "(", "\n", "'x'", ".", "join", "(", "map", "(", "str", ",", "output_size", ")", ")", ")", ")", "\n", "", "return", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_func.ModulatedDeformConvFunction.forward": [[152, 204], ["input.new_empty", "vc_rcnn._C.modulated_deform_conv_forward", "input.new_empty", "ctx.save_for_backward", "deform_conv_func.ModulatedDeformConvFunction._infer_shape", "input.new_empty", "input.new_empty"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_func.ModulatedDeformConvFunction._infer_shape"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "\n", "ctx", ",", "\n", "input", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "weight", ",", "\n", "bias", "=", "None", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", "\n", ")", ":", "\n", "        ", "ctx", ".", "stride", "=", "stride", "\n", "ctx", ".", "padding", "=", "padding", "\n", "ctx", ".", "dilation", "=", "dilation", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "with_bias", "=", "bias", "is", "not", "None", "\n", "if", "not", "ctx", ".", "with_bias", ":", "\n", "            ", "bias", "=", "input", ".", "new_empty", "(", "1", ")", "# fake tensor", "\n", "", "if", "not", "input", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "if", "weight", ".", "requires_grad", "or", "mask", ".", "requires_grad", "or", "offset", ".", "requires_grad", "or", "input", ".", "requires_grad", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "input", ",", "offset", ",", "mask", ",", "weight", ",", "bias", ")", "\n", "", "output", "=", "input", ".", "new_empty", "(", "\n", "ModulatedDeformConvFunction", ".", "_infer_shape", "(", "ctx", ",", "input", ",", "weight", ")", ")", "\n", "ctx", ".", "_bufs", "=", "[", "input", ".", "new_empty", "(", "0", ")", ",", "input", ".", "new_empty", "(", "0", ")", "]", "\n", "_C", ".", "modulated_deform_conv_forward", "(", "\n", "input", ",", "\n", "weight", ",", "\n", "bias", ",", "\n", "ctx", ".", "_bufs", "[", "0", "]", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "output", ",", "\n", "ctx", ".", "_bufs", "[", "1", "]", ",", "\n", "weight", ".", "shape", "[", "2", "]", ",", "\n", "weight", ".", "shape", "[", "3", "]", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "ctx", ".", "with_bias", "\n", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_func.ModulatedDeformConvFunction.backward": [[205, 247], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "vc_rcnn._C.modulated_deform_conv_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "input", ",", "offset", ",", "mask", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "grad_input", "=", "torch", ".", "zeros_like", "(", "input", ")", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "grad_mask", "=", "torch", ".", "zeros_like", "(", "mask", ")", "\n", "grad_weight", "=", "torch", ".", "zeros_like", "(", "weight", ")", "\n", "grad_bias", "=", "torch", ".", "zeros_like", "(", "bias", ")", "\n", "_C", ".", "modulated_deform_conv_backward", "(", "\n", "input", ",", "\n", "weight", ",", "\n", "bias", ",", "\n", "ctx", ".", "_bufs", "[", "0", "]", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "ctx", ".", "_bufs", "[", "1", "]", ",", "\n", "grad_input", ",", "\n", "grad_weight", ",", "\n", "grad_bias", ",", "\n", "grad_offset", ",", "\n", "grad_mask", ",", "\n", "grad_output", ",", "\n", "weight", ".", "shape", "[", "2", "]", ",", "\n", "weight", ".", "shape", "[", "3", "]", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "ctx", ".", "with_bias", "\n", ")", "\n", "if", "not", "ctx", ".", "with_bias", ":", "\n", "            ", "grad_bias", "=", "None", "\n", "\n", "", "return", "(", "grad_input", ",", "grad_offset", ",", "grad_mask", ",", "grad_weight", ",", "grad_bias", ",", "\n", "None", ",", "None", ",", "None", ",", "None", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_func.ModulatedDeformConvFunction._infer_shape": [[248, 259], ["input.size", "weight.size"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_infer_shape", "(", "ctx", ",", "input", ",", "weight", ")", ":", "\n", "        ", "n", "=", "input", ".", "size", "(", "0", ")", "\n", "channels_out", "=", "weight", ".", "size", "(", "0", ")", "\n", "height", ",", "width", "=", "input", ".", "shape", "[", "2", ":", "4", "]", "\n", "kernel_h", ",", "kernel_w", "=", "weight", ".", "shape", "[", "2", ":", "4", "]", "\n", "height_out", "=", "(", "height", "+", "2", "*", "ctx", ".", "padding", "-", "\n", "(", "ctx", ".", "dilation", "*", "(", "kernel_h", "-", "1", ")", "+", "1", ")", ")", "//", "ctx", ".", "stride", "+", "1", "\n", "width_out", "=", "(", "width", "+", "2", "*", "ctx", ".", "padding", "-", "\n", "(", "ctx", ".", "dilation", "*", "(", "kernel_w", "-", "1", ")", "+", "1", ")", ")", "//", "ctx", ".", "stride", "+", "1", "\n", "return", "n", ",", "channels_out", ",", "height_out", ",", "width_out", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.DeformConv.__init__": [[12, 48], ["torch.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.Parameter", "torch.Parameter", "deform_conv_module.DeformConv.reset_parameters", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConv.reset_parameters"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "False", "\n", ")", ":", "\n", "        ", "assert", "not", "bias", "\n", "super", "(", "DeformConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_bias", "=", "bias", "\n", "\n", "assert", "in_channels", "%", "groups", "==", "0", ",", "'in_channels {} cannot be divisible by groups {}'", ".", "format", "(", "\n", "in_channels", ",", "groups", ")", "\n", "assert", "out_channels", "%", "groups", "==", "0", ",", "'out_channels {} cannot be divisible by groups {}'", ".", "format", "(", "\n", "out_channels", ",", "groups", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "self", ".", "padding", "=", "_pair", "(", "padding", ")", "\n", "self", ".", "dilation", "=", "_pair", "(", "dilation", ")", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "deformable_groups", "=", "deformable_groups", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "self", ".", "groups", ",", "\n", "*", "self", ".", "kernel_size", ")", ")", "\n", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.DeformConv.reset_parameters": [[49, 55], ["deform_conv_module.DeformConv.weight.data.uniform_", "math.sqrt"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "n", "=", "self", ".", "in_channels", "\n", "for", "k", "in", "self", ".", "kernel_size", ":", "\n", "            ", "n", "*=", "k", "\n", "", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "n", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.DeformConv.forward": [[56, 60], ["deform_conv_func.deform_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "offset", ")", ":", "\n", "        ", "return", "deform_conv", "(", "input", ",", "offset", ",", "self", ".", "weight", ",", "self", ".", "stride", ",", "\n", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "groups", ",", "\n", "self", ".", "deformable_groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.DeformConv.__repr__": [[61, 73], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"\"", ".", "join", "(", "[", "\n", "\"{}(\"", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ")", ",", "\n", "\"in_channels={}, \"", ".", "format", "(", "self", ".", "in_channels", ")", ",", "\n", "\"out_channels={}, \"", ".", "format", "(", "self", ".", "out_channels", ")", ",", "\n", "\"kernel_size={}, \"", ".", "format", "(", "self", ".", "kernel_size", ")", ",", "\n", "\"stride={}, \"", ".", "format", "(", "self", ".", "stride", ")", ",", "\n", "\"dilation={}, \"", ".", "format", "(", "self", ".", "dilation", ")", ",", "\n", "\"padding={}, \"", ".", "format", "(", "self", ".", "padding", ")", ",", "\n", "\"groups={}, \"", ".", "format", "(", "self", ".", "groups", ")", ",", "\n", "\"deformable_groups={}, \"", ".", "format", "(", "self", ".", "deformable_groups", ")", ",", "\n", "\"bias={})\"", ".", "format", "(", "self", ".", "with_bias", ")", ",", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConv.__init__": [[78, 111], ["torch.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.Parameter", "torch.Parameter", "deform_conv_module.ModulatedDeformConv.reset_parameters", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Parameter", "torch.Parameter", "deform_conv_module.ModulatedDeformConv.register_parameter", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConv.reset_parameters"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "True", "\n", ")", ":", "\n", "        ", "super", "(", "ModulatedDeformConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "deformable_groups", "=", "deformable_groups", "\n", "self", ".", "with_bias", "=", "bias", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "\n", "out_channels", ",", "\n", "in_channels", "//", "groups", ",", "\n", "*", "self", ".", "kernel_size", "\n", ")", ")", "\n", "if", "bias", ":", "\n", "            ", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_channels", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConv.reset_parameters": [[112, 120], ["deform_conv_module.ModulatedDeformConv.weight.data.uniform_", "math.sqrt", "deform_conv_module.ModulatedDeformConv.bias.data.zero_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "n", "=", "self", ".", "in_channels", "\n", "for", "k", "in", "self", ".", "kernel_size", ":", "\n", "            ", "n", "*=", "k", "\n", "", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "n", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "self", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConv.forward": [[121, 125], ["deform_conv_func.modulated_deform_conv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ",", "offset", ",", "mask", ")", ":", "\n", "        ", "return", "modulated_deform_conv", "(", "\n", "input", ",", "offset", ",", "mask", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "\n", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "groups", ",", "self", ".", "deformable_groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConv.__repr__": [[126, 138], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"\"", ".", "join", "(", "[", "\n", "\"{}(\"", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ")", ",", "\n", "\"in_channels={}, \"", ".", "format", "(", "self", ".", "in_channels", ")", ",", "\n", "\"out_channels={}, \"", ".", "format", "(", "self", ".", "out_channels", ")", ",", "\n", "\"kernel_size={}, \"", ".", "format", "(", "self", ".", "kernel_size", ")", ",", "\n", "\"stride={}, \"", ".", "format", "(", "self", ".", "stride", ")", ",", "\n", "\"dilation={}, \"", ".", "format", "(", "self", ".", "dilation", ")", ",", "\n", "\"padding={}, \"", ".", "format", "(", "self", ".", "padding", ")", ",", "\n", "\"groups={}, \"", ".", "format", "(", "self", ".", "groups", ")", ",", "\n", "\"deformable_groups={}, \"", ".", "format", "(", "self", ".", "deformable_groups", ")", ",", "\n", "\"bias={})\"", ".", "format", "(", "self", ".", "with_bias", ")", ",", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConvPack.__init__": [[142, 165], ["deform_conv_module.ModulatedDeformConv.__init__", "torch.Conv2d", "torch.Conv2d", "deform_conv_module.ModulatedDeformConvPack.init_offset", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConvPack.init_offset"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "ModulatedDeformConvPack", ",", "self", ")", ".", "__init__", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", ",", "padding", ",", "dilation", ",", "\n", "groups", ",", "deformable_groups", ",", "bias", ")", "\n", "\n", "self", ".", "conv_offset_mask", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "in_channels", "//", "self", ".", "groups", ",", "\n", "self", ".", "deformable_groups", "*", "3", "*", "self", ".", "kernel_size", "[", "0", "]", "*", "\n", "self", ".", "kernel_size", "[", "1", "]", ",", "\n", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "stride", "=", "_pair", "(", "self", ".", "stride", ")", ",", "\n", "padding", "=", "_pair", "(", "self", ".", "padding", ")", ",", "\n", "bias", "=", "True", ")", "\n", "self", ".", "init_offset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConvPack.init_offset": [[166, 169], ["deform_conv_module.ModulatedDeformConvPack.conv_offset_mask.weight.data.zero_", "deform_conv_module.ModulatedDeformConvPack.conv_offset_mask.bias.data.zero_"], "methods", ["None"], ["", "def", "init_offset", "(", "self", ")", ":", "\n", "        ", "self", ".", "conv_offset_mask", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv_offset_mask", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_conv_module.ModulatedDeformConvPack.forward": [[170, 178], ["deform_conv_module.ModulatedDeformConvPack.conv_offset_mask", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "deform_conv_func.modulated_deform_conv"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv_offset_mask", "(", "input", ")", "\n", "o1", ",", "o2", ",", "mask", "=", "torch", ".", "chunk", "(", "out", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "o1", ",", "o2", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "torch", ".", "sigmoid", "(", "mask", ")", "\n", "return", "modulated_deform_conv", "(", "\n", "input", ",", "offset", ",", "mask", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "\n", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "groups", ",", "self", ".", "deformable_groups", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_module.DeformRoIPooling.__init__": [[8, 26], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "spatial_scale", ",", "\n", "out_size", ",", "\n", "out_channels", ",", "\n", "no_trans", ",", "\n", "group_size", "=", "1", ",", "\n", "part_size", "=", "None", ",", "\n", "sample_per_part", "=", "4", ",", "\n", "trans_std", "=", ".0", ")", ":", "\n", "        ", "super", "(", "DeformRoIPooling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "self", ".", "out_size", "=", "out_size", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "no_trans", "=", "no_trans", "\n", "self", ".", "group_size", "=", "group_size", "\n", "self", ".", "part_size", "=", "out_size", "if", "part_size", "is", "None", "else", "part_size", "\n", "self", ".", "sample_per_part", "=", "sample_per_part", "\n", "self", ".", "trans_std", "=", "trans_std", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_module.DeformRoIPooling.forward": [[27, 34], ["deform_pool_func.deform_roi_pooling", "data.new_empty"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "data", ",", "rois", ",", "offset", ")", ":", "\n", "        ", "if", "self", ".", "no_trans", ":", "\n", "            ", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "", "return", "deform_roi_pooling", "(", "\n", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "self", ".", "out_size", ",", "\n", "self", ".", "out_channels", ",", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "self", ".", "part_size", ",", "\n", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_module.DeformRoIPoolingPack.__init__": [[38, 65], ["deform_pool_module.DeformRoIPooling.__init__", "torch.nn.Sequential", "deform_pool_module.DeformRoIPoolingPack.offset_fc[].weight.data.zero_", "deform_pool_module.DeformRoIPoolingPack.offset_fc[].bias.data.zero_", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "spatial_scale", ",", "\n", "out_size", ",", "\n", "out_channels", ",", "\n", "no_trans", ",", "\n", "group_size", "=", "1", ",", "\n", "part_size", "=", "None", ",", "\n", "sample_per_part", "=", "4", ",", "\n", "trans_std", "=", ".0", ",", "\n", "deform_fc_channels", "=", "1024", ")", ":", "\n", "        ", "super", "(", "DeformRoIPoolingPack", ",", "\n", "self", ")", ".", "__init__", "(", "spatial_scale", ",", "out_size", ",", "out_channels", ",", "no_trans", ",", "\n", "group_size", ",", "part_size", ",", "sample_per_part", ",", "trans_std", ")", "\n", "\n", "self", ".", "deform_fc_channels", "=", "deform_fc_channels", "\n", "\n", "if", "not", "no_trans", ":", "\n", "            ", "self", ".", "offset_fc", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "out_size", "*", "self", ".", "out_size", "*", "self", ".", "out_channels", ",", "\n", "self", ".", "deform_fc_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "deform_fc_channels", ",", "self", ".", "deform_fc_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "deform_fc_channels", ",", "\n", "self", ".", "out_size", "*", "self", ".", "out_size", "*", "2", ")", ")", "\n", "self", ".", "offset_fc", "[", "-", "1", "]", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "offset_fc", "[", "-", "1", "]", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_module.DeformRoIPoolingPack.forward": [[66, 87], ["data.size", "data.new_empty", "deform_pool_func.deform_roi_pooling", "data.new_empty", "deform_pool_func.deform_roi_pooling", "deform_pool_module.DeformRoIPoolingPack.offset_fc", "offset.view.view.view", "deform_pool_func.deform_roi_pooling", "deform_pool_func.deform_roi_pooling.view"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "data", ",", "rois", ")", ":", "\n", "        ", "assert", "data", ".", "size", "(", "1", ")", "==", "self", ".", "out_channels", "\n", "if", "self", ".", "no_trans", ":", "\n", "            ", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "return", "deform_roi_pooling", "(", "\n", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "self", ".", "out_size", ",", "\n", "self", ".", "out_channels", ",", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "\n", "self", ".", "part_size", ",", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "\n", "", "else", ":", "\n", "            ", "n", "=", "rois", ".", "shape", "[", "0", "]", "\n", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "x", "=", "deform_roi_pooling", "(", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "\n", "self", ".", "out_size", ",", "self", ".", "out_channels", ",", "True", ",", "\n", "self", ".", "group_size", ",", "self", ".", "part_size", ",", "\n", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "\n", "offset", "=", "self", ".", "offset_fc", "(", "x", ".", "view", "(", "n", ",", "-", "1", ")", ")", "\n", "offset", "=", "offset", ".", "view", "(", "n", ",", "2", ",", "self", ".", "out_size", ",", "self", ".", "out_size", ")", "\n", "return", "deform_roi_pooling", "(", "\n", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "self", ".", "out_size", ",", "\n", "self", ".", "out_channels", ",", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "\n", "self", ".", "part_size", ",", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_module.ModulatedDeformRoIPoolingPack.__init__": [[91, 127], ["deform_pool_module.DeformRoIPooling.__init__", "torch.nn.Sequential", "deform_pool_module.ModulatedDeformRoIPoolingPack.offset_fc[].weight.data.zero_", "deform_pool_module.ModulatedDeformRoIPoolingPack.offset_fc[].bias.data.zero_", "torch.nn.Sequential", "deform_pool_module.ModulatedDeformRoIPoolingPack.mask_fc[].weight.data.zero_", "deform_pool_module.ModulatedDeformRoIPoolingPack.mask_fc[].bias.data.zero_", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "spatial_scale", ",", "\n", "out_size", ",", "\n", "out_channels", ",", "\n", "no_trans", ",", "\n", "group_size", "=", "1", ",", "\n", "part_size", "=", "None", ",", "\n", "sample_per_part", "=", "4", ",", "\n", "trans_std", "=", ".0", ",", "\n", "deform_fc_channels", "=", "1024", ")", ":", "\n", "        ", "super", "(", "ModulatedDeformRoIPoolingPack", ",", "self", ")", ".", "__init__", "(", "\n", "spatial_scale", ",", "out_size", ",", "out_channels", ",", "no_trans", ",", "group_size", ",", "\n", "part_size", ",", "sample_per_part", ",", "trans_std", ")", "\n", "\n", "self", ".", "deform_fc_channels", "=", "deform_fc_channels", "\n", "\n", "if", "not", "no_trans", ":", "\n", "            ", "self", ".", "offset_fc", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "out_size", "*", "self", ".", "out_size", "*", "self", ".", "out_channels", ",", "\n", "self", ".", "deform_fc_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "deform_fc_channels", ",", "self", ".", "deform_fc_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "deform_fc_channels", ",", "\n", "self", ".", "out_size", "*", "self", ".", "out_size", "*", "2", ")", ")", "\n", "self", ".", "offset_fc", "[", "-", "1", "]", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "offset_fc", "[", "-", "1", "]", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "mask_fc", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "out_size", "*", "self", ".", "out_size", "*", "self", ".", "out_channels", ",", "\n", "self", ".", "deform_fc_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "deform_fc_channels", ",", "\n", "self", ".", "out_size", "*", "self", ".", "out_size", "*", "1", ")", ",", "\n", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "self", ".", "mask_fc", "[", "2", "]", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "mask_fc", "[", "2", "]", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_module.ModulatedDeformRoIPoolingPack.forward": [[128, 151], ["data.size", "data.new_empty", "deform_pool_func.deform_roi_pooling", "data.new_empty", "deform_pool_func.deform_roi_pooling", "deform_pool_module.ModulatedDeformRoIPoolingPack.offset_fc", "offset.view.view.view", "deform_pool_module.ModulatedDeformRoIPoolingPack.mask_fc", "mask.view.view.view", "deform_pool_func.deform_roi_pooling.view", "deform_pool_func.deform_roi_pooling.view", "deform_pool_func.deform_roi_pooling"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "data", ",", "rois", ")", ":", "\n", "        ", "assert", "data", ".", "size", "(", "1", ")", "==", "self", ".", "out_channels", "\n", "if", "self", ".", "no_trans", ":", "\n", "            ", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "return", "deform_roi_pooling", "(", "\n", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "self", ".", "out_size", ",", "\n", "self", ".", "out_channels", ",", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "\n", "self", ".", "part_size", ",", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "\n", "", "else", ":", "\n", "            ", "n", "=", "rois", ".", "shape", "[", "0", "]", "\n", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "x", "=", "deform_roi_pooling", "(", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "\n", "self", ".", "out_size", ",", "self", ".", "out_channels", ",", "True", ",", "\n", "self", ".", "group_size", ",", "self", ".", "part_size", ",", "\n", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "\n", "offset", "=", "self", ".", "offset_fc", "(", "x", ".", "view", "(", "n", ",", "-", "1", ")", ")", "\n", "offset", "=", "offset", ".", "view", "(", "n", ",", "2", ",", "self", ".", "out_size", ",", "self", ".", "out_size", ")", "\n", "mask", "=", "self", ".", "mask_fc", "(", "x", ".", "view", "(", "n", ",", "-", "1", ")", ")", "\n", "mask", "=", "mask", ".", "view", "(", "n", ",", "1", ",", "self", ".", "out_size", ",", "self", ".", "out_size", ")", "\n", "return", "deform_roi_pooling", "(", "\n", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "self", ".", "out_size", ",", "\n", "self", ".", "out_channels", ",", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "\n", "self", ".", "part_size", ",", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "*", "mask", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_func.DeformRoIPoolingFunction.forward": [[10, 62], ["data.new_empty", "data.new_empty", "vc_rcnn._C.deform_psroi_pooling_forward", "ctx.save_for_backward"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "\n", "ctx", ",", "\n", "data", ",", "\n", "rois", ",", "\n", "offset", ",", "\n", "spatial_scale", ",", "\n", "out_size", ",", "\n", "out_channels", ",", "\n", "no_trans", ",", "\n", "group_size", "=", "1", ",", "\n", "part_size", "=", "None", ",", "\n", "sample_per_part", "=", "4", ",", "\n", "trans_std", "=", ".0", "\n", ")", ":", "\n", "        ", "ctx", ".", "spatial_scale", "=", "spatial_scale", "\n", "ctx", ".", "out_size", "=", "out_size", "\n", "ctx", ".", "out_channels", "=", "out_channels", "\n", "ctx", ".", "no_trans", "=", "no_trans", "\n", "ctx", ".", "group_size", "=", "group_size", "\n", "ctx", ".", "part_size", "=", "out_size", "if", "part_size", "is", "None", "else", "part_size", "\n", "ctx", ".", "sample_per_part", "=", "sample_per_part", "\n", "ctx", ".", "trans_std", "=", "trans_std", "\n", "\n", "assert", "0.0", "<=", "ctx", ".", "trans_std", "<=", "1.0", "\n", "if", "not", "data", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "n", "=", "rois", ".", "shape", "[", "0", "]", "\n", "output", "=", "data", ".", "new_empty", "(", "n", ",", "out_channels", ",", "out_size", ",", "out_size", ")", "\n", "output_count", "=", "data", ".", "new_empty", "(", "n", ",", "out_channels", ",", "out_size", ",", "out_size", ")", "\n", "_C", ".", "deform_psroi_pooling_forward", "(", "\n", "data", ",", "\n", "rois", ",", "\n", "offset", ",", "\n", "output", ",", "\n", "output_count", ",", "\n", "ctx", ".", "no_trans", ",", "\n", "ctx", ".", "spatial_scale", ",", "\n", "ctx", ".", "out_channels", ",", "\n", "ctx", ".", "group_size", ",", "\n", "ctx", ".", "out_size", ",", "\n", "ctx", ".", "part_size", ",", "\n", "ctx", ".", "sample_per_part", ",", "\n", "ctx", ".", "trans_std", "\n", ")", "\n", "\n", "if", "data", ".", "requires_grad", "or", "rois", ".", "requires_grad", "or", "offset", ".", "requires_grad", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "data", ",", "rois", ",", "offset", ")", "\n", "", "ctx", ".", "output_count", "=", "output_count", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_func.DeformRoIPoolingFunction.backward": [[63, 93], ["torch.zeros_like", "torch.zeros_like", "vc_rcnn._C.deform_psroi_pooling_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "data", ",", "rois", ",", "offset", "=", "ctx", ".", "saved_tensors", "\n", "output_count", "=", "ctx", ".", "output_count", "\n", "grad_input", "=", "torch", ".", "zeros_like", "(", "data", ")", "\n", "grad_rois", "=", "None", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "\n", "_C", ".", "deform_psroi_pooling_backward", "(", "\n", "grad_output", ",", "\n", "data", ",", "\n", "rois", ",", "\n", "offset", ",", "\n", "output_count", ",", "\n", "grad_input", ",", "\n", "grad_offset", ",", "\n", "ctx", ".", "no_trans", ",", "\n", "ctx", ".", "spatial_scale", ",", "\n", "ctx", ".", "out_channels", ",", "\n", "ctx", ".", "group_size", ",", "\n", "ctx", ".", "out_size", ",", "\n", "ctx", ".", "part_size", ",", "\n", "ctx", ".", "sample_per_part", ",", "\n", "ctx", ".", "trans_std", "\n", ")", "\n", "return", "(", "grad_input", ",", "grad_rois", ",", "grad_offset", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.bbox_aug.im_detect_bbox_aug": [[11, 69], ["range", "bbox_aug.im_detect_bbox", "bbox_aug.im_detect_bbox_aug.add_preds_t"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.bbox_aug.im_detect_bbox"], ["def", "im_detect_bbox_aug", "(", "model", ",", "images", ",", "device", ")", ":", "\n", "# Collect detections computed under different transformations", "\n", "    ", "boxlists_ts", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "len", "(", "images", ")", ")", ":", "\n", "        ", "boxlists_ts", ".", "append", "(", "[", "]", ")", "\n", "\n", "", "def", "add_preds_t", "(", "boxlists_t", ")", ":", "\n", "        ", "for", "i", ",", "boxlist_t", "in", "enumerate", "(", "boxlists_t", ")", ":", "\n", "            ", "if", "len", "(", "boxlists_ts", "[", "i", "]", ")", "==", "0", ":", "\n", "# The first one is identity transform, no need to resize the boxlist", "\n", "                ", "boxlists_ts", "[", "i", "]", ".", "append", "(", "boxlist_t", ")", "\n", "", "else", ":", "\n", "# Resize the boxlist as the first one", "\n", "                ", "boxlists_ts", "[", "i", "]", ".", "append", "(", "boxlist_t", ".", "resize", "(", "boxlists_ts", "[", "i", "]", "[", "0", "]", ".", "size", ")", ")", "\n", "\n", "# Compute detections for the original image (identity transform)", "\n", "", "", "", "boxlists_i", "=", "im_detect_bbox", "(", "\n", "model", ",", "images", ",", "cfg", ".", "INPUT", ".", "MIN_SIZE_TEST", ",", "cfg", ".", "INPUT", ".", "MAX_SIZE_TEST", ",", "device", "\n", ")", "\n", "add_preds_t", "(", "boxlists_i", ")", "\n", "\n", "# Perform detection on the horizontally flipped image", "\n", "if", "cfg", ".", "TEST", ".", "BBOX_AUG", ".", "H_FLIP", ":", "\n", "        ", "boxlists_hf", "=", "im_detect_bbox_hflip", "(", "\n", "model", ",", "images", ",", "cfg", ".", "INPUT", ".", "MIN_SIZE_TEST", ",", "cfg", ".", "INPUT", ".", "MAX_SIZE_TEST", ",", "device", "\n", ")", "\n", "add_preds_t", "(", "boxlists_hf", ")", "\n", "\n", "# Compute detections at different scales", "\n", "", "for", "scale", "in", "cfg", ".", "TEST", ".", "BBOX_AUG", ".", "SCALES", ":", "\n", "        ", "max_size", "=", "cfg", ".", "TEST", ".", "BBOX_AUG", ".", "MAX_SIZE", "\n", "boxlists_scl", "=", "im_detect_bbox_scale", "(", "\n", "model", ",", "images", ",", "scale", ",", "max_size", ",", "device", "\n", ")", "\n", "add_preds_t", "(", "boxlists_scl", ")", "\n", "\n", "if", "cfg", ".", "TEST", ".", "BBOX_AUG", ".", "SCALE_H_FLIP", ":", "\n", "            ", "boxlists_scl_hf", "=", "im_detect_bbox_scale", "(", "\n", "model", ",", "images", ",", "scale", ",", "max_size", ",", "device", ",", "hflip", "=", "True", "\n", ")", "\n", "add_preds_t", "(", "boxlists_scl_hf", ")", "\n", "\n", "# Merge boxlists detected by different bbox aug params", "\n", "", "", "boxlists", "=", "[", "]", "\n", "for", "i", ",", "boxlist_ts", "in", "enumerate", "(", "boxlists_ts", ")", ":", "\n", "        ", "bbox", "=", "torch", ".", "cat", "(", "[", "boxlist_t", ".", "bbox", "for", "boxlist_t", "in", "boxlist_ts", "]", ")", "\n", "scores", "=", "torch", ".", "cat", "(", "[", "boxlist_t", ".", "get_field", "(", "'scores'", ")", "for", "boxlist_t", "in", "boxlist_ts", "]", ")", "\n", "boxlist", "=", "BoxList", "(", "bbox", ",", "boxlist_ts", "[", "0", "]", ".", "size", ",", "boxlist_ts", "[", "0", "]", ".", "mode", ")", "\n", "boxlist", ".", "add_field", "(", "'scores'", ",", "scores", ")", "\n", "boxlists", ".", "append", "(", "boxlist", ")", "\n", "\n", "# Apply NMS and limit the final detections", "\n", "", "results", "=", "[", "]", "\n", "post_processor", "=", "make_roi_box_post_processor", "(", "cfg", ")", "\n", "for", "boxlist", "in", "boxlists", ":", "\n", "        ", "results", ".", "append", "(", "post_processor", ".", "filter_results", "(", "boxlist", ",", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CLASSES", ")", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.bbox_aug.im_detect_bbox": [[71, 85], ["torchvision.Compose", "vc_rcnn.structures.image_list.to_image_list", "model", "TT.Compose.", "vc_rcnn.structures.image_list.to_image_list.to", "vc_rcnn.data.transforms.Resize", "torchvision.ToTensor", "vc_rcnn.data.transforms.Normalize", "vc_rcnn.config.cfg.INPUT.MIN_SIZE_TEST", "vc_rcnn.config.cfg.INPUT.MAX_SIZE_TEST"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.image_list.to_image_list", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "im_detect_bbox", "(", "model", ",", "images", ",", "target_scale", ",", "target_max_size", ",", "device", ")", ":", "\n", "    ", "\"\"\"\n    Performs bbox detection on the original image.\n    \"\"\"", "\n", "transform", "=", "TT", ".", "Compose", "(", "[", "\n", "T", ".", "Resize", "(", "target_scale", ",", "target_max_size", ")", ",", "\n", "TT", ".", "ToTensor", "(", ")", ",", "\n", "T", ".", "Normalize", "(", "\n", "mean", "=", "cfg", ".", "INPUT", ".", "PIXEL_MEAN", ",", "std", "=", "cfg", ".", "INPUT", ".", "PIXEL_STD", ",", "to_bgr255", "=", "cfg", ".", "INPUT", ".", "TO_BGR255", "\n", ")", "\n", "]", ")", "\n", "images", "=", "[", "transform", "(", "image", ")", "for", "image", "in", "images", "]", "\n", "images", "=", "to_image_list", "(", "images", ",", "cfg", ".", "DATALOADER", ".", "SIZE_DIVISIBILITY", ")", "\n", "return", "model", "(", "images", ".", "to", "(", "device", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.bbox_aug.im_detect_bbox_hflip": [[87, 107], ["torchvision.Compose", "vc_rcnn.structures.image_list.to_image_list", "model", "TT.Compose.", "vc_rcnn.structures.image_list.to_image_list.to", "boxlist.transpose", "vc_rcnn.data.transforms.Resize", "torchvision.RandomHorizontalFlip", "torchvision.ToTensor", "vc_rcnn.data.transforms.Normalize", "vc_rcnn.config.cfg.INPUT.MIN_SIZE_TEST", "vc_rcnn.config.cfg.INPUT.MAX_SIZE_TEST"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.image_list.to_image_list", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "im_detect_bbox_hflip", "(", "model", ",", "images", ",", "target_scale", ",", "target_max_size", ",", "device", ")", ":", "\n", "    ", "\"\"\"\n    Performs bbox detection on the horizontally flipped image.\n    Function signature is the same as for im_detect_bbox.\n    \"\"\"", "\n", "transform", "=", "TT", ".", "Compose", "(", "[", "\n", "T", ".", "Resize", "(", "target_scale", ",", "target_max_size", ")", ",", "\n", "TT", ".", "RandomHorizontalFlip", "(", "1.0", ")", ",", "\n", "TT", ".", "ToTensor", "(", ")", ",", "\n", "T", ".", "Normalize", "(", "\n", "mean", "=", "cfg", ".", "INPUT", ".", "PIXEL_MEAN", ",", "std", "=", "cfg", ".", "INPUT", ".", "PIXEL_STD", ",", "to_bgr255", "=", "cfg", ".", "INPUT", ".", "TO_BGR255", "\n", ")", "\n", "]", ")", "\n", "images", "=", "[", "transform", "(", "image", ")", "for", "image", "in", "images", "]", "\n", "images", "=", "to_image_list", "(", "images", ",", "cfg", ".", "DATALOADER", ".", "SIZE_DIVISIBILITY", ")", "\n", "boxlists", "=", "model", "(", "images", ".", "to", "(", "device", ")", ")", "\n", "\n", "# Invert the detections computed on the flipped image", "\n", "boxlists_inv", "=", "[", "boxlist", ".", "transpose", "(", "0", ")", "for", "boxlist", "in", "boxlists", "]", "\n", "return", "boxlists_inv", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.bbox_aug.im_detect_bbox_scale": [[109, 119], ["bbox_aug.im_detect_bbox_hflip", "bbox_aug.im_detect_bbox"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.bbox_aug.im_detect_bbox_hflip", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.bbox_aug.im_detect_bbox"], ["", "def", "im_detect_bbox_scale", "(", "model", ",", "images", ",", "target_scale", ",", "target_max_size", ",", "device", ",", "hflip", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Computes bbox detections at the given scale.\n    Returns predictions in the scaled image space.\n    \"\"\"", "\n", "if", "hflip", ":", "\n", "        ", "boxlists_scl", "=", "im_detect_bbox_hflip", "(", "model", ",", "images", ",", "target_scale", ",", "target_max_size", ",", "device", ")", "\n", "", "else", ":", "\n", "        ", "boxlists_scl", "=", "im_detect_bbox", "(", "model", ",", "images", ",", "target_scale", ",", "target_max_size", ",", "device", ")", "\n", "", "return", "boxlists_scl", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.inference.compute_on_dataset": [[18, 40], ["model.eval", "torch.device", "enumerate", "tqdm.tqdm", "results_dict.update", "torch.no_grad", "timer.tic", "bbox_aug.im_detect_bbox_aug", "model", "timer.toc", "o.to", "images.to", "torch.cuda.synchronize", "zip"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.tic", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.bbox_aug.im_detect_bbox_aug", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.toc", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize"], ["\n", "def", "__init__", "(", "\n", "self", ",", "\n", "pre_nms_top_n", ",", "\n", "post_nms_top_n", ",", "\n", "nms_thresh", ",", "\n", "min_size", ",", "\n", "box_coder", "=", "None", ",", "\n", "fpn_post_nms_top_n", "=", "None", ",", "\n", "fpn_post_nms_per_batch", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            pre_nms_top_n (int)\n            post_nms_top_n (int)\n            nms_thresh (float)\n            min_size (int)\n            box_coder (BoxCoder)\n            fpn_post_nms_top_n (int)\n        \"\"\"", "\n", "super", "(", "RPNPostProcessor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pre_nms_top_n", "=", "pre_nms_top_n", "\n", "self", ".", "post_nms_top_n", "=", "post_nms_top_n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.inference._accumulate_predictions_from_multiple_gpus": [[42, 62], ["utils.comm.all_gather", "list", "utils.comm.is_main_process", "predictions.update", "sorted", "len", "logging.getLogger", "logging.getLogger.warning", "predictions.keys"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.all_gather", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.is_main_process", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys"], ["self", ".", "min_size", "=", "min_size", "\n", "\n", "if", "box_coder", "is", "None", ":", "\n", "            ", "box_coder", "=", "BoxCoder", "(", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", "\n", "", "self", ".", "box_coder", "=", "box_coder", "\n", "\n", "if", "fpn_post_nms_top_n", "is", "None", ":", "\n", "            ", "fpn_post_nms_top_n", "=", "post_nms_top_n", "\n", "", "self", ".", "fpn_post_nms_top_n", "=", "fpn_post_nms_top_n", "\n", "self", ".", "fpn_post_nms_per_batch", "=", "fpn_post_nms_per_batch", "\n", "\n", "", "def", "add_gt_proposals", "(", "self", ",", "proposals", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            proposals: list[BoxList]\n            targets: list[BoxList]\n        \"\"\"", "\n", "# Get the device we're operating on", "\n", "device", "=", "proposals", "[", "0", "]", ".", "bbox", ".", "device", "\n", "\n", "gt_boxes", "=", "[", "target", ".", "copy_with_fields", "(", "[", "]", ")", "for", "target", "in", "targets", "]", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.inference.inference": [[64, 125], ["torch.device", "utils.comm.get_world_size", "logging.getLogger", "logging.getLogger.info", "utils.timer.Timer", "utils.timer.Timer", "utils.timer.Timer.tic", "inference.compute_on_dataset", "utils.comm.synchronize", "utils.timer.Timer.toc", "utils.timer.get_time_str", "logging.getLogger.info", "utils.timer.get_time_str", "logging.getLogger.info", "print", "sys.exit", "inference._accumulate_predictions_from_multiple_gpus", "dict", "vc_rcnn.data.datasets.evaluation.evaluate", "utils.comm.is_main_process", "torch.save", "len", "os.path.join", "len", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.tic", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.inference.compute_on_dataset", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.Timer.toc", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.get_time_str", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.timer.get_time_str", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.inference._accumulate_predictions_from_multiple_gpus", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.evaluation.__init__.evaluate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.is_main_process", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save"], ["# later cat of bbox requires all fields to be present for all bbox", "\n", "# so we need to add a dummy for objectness that's missing", "\n", "for", "gt_box", "in", "gt_boxes", ":", "\n", "            ", "gt_box", ".", "add_field", "(", "\"objectness\"", ",", "torch", ".", "ones", "(", "len", "(", "gt_box", ")", ",", "device", "=", "device", ")", ")", "\n", "\n", "", "proposals", "=", "[", "\n", "cat_boxlist", "(", "(", "proposal", ",", "gt_box", ")", ")", "\n", "for", "proposal", ",", "gt_box", "in", "zip", "(", "proposals", ",", "gt_boxes", ")", "\n", "]", "\n", "\n", "return", "proposals", "\n", "\n", "", "def", "forward_for_single_feature_map", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors: list[BoxList]\n            objectness: tensor of size N, A, H, W\n            box_regression: tensor of size N, A * 4, H, W\n        \"\"\"", "\n", "device", "=", "objectness", ".", "device", "\n", "N", ",", "A", ",", "H", ",", "W", "=", "objectness", ".", "shape", "\n", "\n", "# put in the same format as anchors", "\n", "objectness", "=", "permute_and_flatten", "(", "objectness", ",", "N", ",", "A", ",", "1", ",", "H", ",", "W", ")", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "objectness", "=", "objectness", ".", "sigmoid", "(", ")", "\n", "\n", "box_regression", "=", "permute_and_flatten", "(", "box_regression", ",", "N", ",", "A", ",", "4", ",", "H", ",", "W", ")", "\n", "\n", "num_anchors", "=", "A", "*", "H", "*", "W", "\n", "\n", "pre_nms_top_n", "=", "min", "(", "self", ".", "pre_nms_top_n", ",", "num_anchors", ")", "\n", "objectness", ",", "topk_idx", "=", "objectness", ".", "topk", "(", "pre_nms_top_n", ",", "dim", "=", "1", ",", "sorted", "=", "True", ")", "\n", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "N", ",", "device", "=", "device", ")", "[", ":", ",", "None", "]", "\n", "box_regression", "=", "box_regression", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "image_shapes", "=", "[", "box", ".", "size", "for", "box", "in", "anchors", "]", "\n", "concat_anchors", "=", "torch", ".", "cat", "(", "[", "a", ".", "bbox", "for", "a", "in", "anchors", "]", ",", "dim", "=", "0", ")", "\n", "concat_anchors", "=", "concat_anchors", ".", "reshape", "(", "N", ",", "-", "1", ",", "4", ")", "[", "batch_idx", ",", "topk_idx", "]", "\n", "\n", "proposals", "=", "self", ".", "box_coder", ".", "decode", "(", "\n", "box_regression", ".", "view", "(", "-", "1", ",", "4", ")", ",", "concat_anchors", ".", "view", "(", "-", "1", ",", "4", ")", "\n", ")", "\n", "\n", "proposals", "=", "proposals", ".", "view", "(", "N", ",", "-", "1", ",", "4", ")", "\n", "\n", "result", "=", "[", "]", "\n", "for", "proposal", ",", "score", ",", "im_shape", "in", "zip", "(", "proposals", ",", "objectness", ",", "image_shapes", ")", ":", "\n", "            ", "boxlist", "=", "BoxList", "(", "proposal", ",", "im_shape", ",", "mode", "=", "\"xyxy\"", ")", "\n", "boxlist", ".", "add_field", "(", "\"objectness\"", ",", "score", ")", "\n", "boxlist", "=", "boxlist", ".", "clip_to_image", "(", "remove_empty", "=", "False", ")", "\n", "boxlist", "=", "remove_small_boxes", "(", "boxlist", ",", "self", ".", "min_size", ")", "\n", "boxlist", "=", "boxlist_nms", "(", "\n", "boxlist", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "max_proposals", "=", "self", ".", "post_nms_top_n", ",", "\n", "score_field", "=", "\"objectness\"", ",", "\n", ")", "\n", "result", ".", "append", "(", "boxlist", ")", "\n", "", "return", "result", "\n", "\n", "", "def", "forward", "(", "self", ",", "anchors", ",", "objectness", ",", "box_regression", ",", "targets", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.trainer.reduce_loss_dict": [[14, 37], ["vc_rcnn.utils.comm.get_world_size", "torch.no_grad", "torch.no_grad", "sorted", "torch.stack", "torch.stack", "torch.reduce", "loss_dict.keys", "loss_names.append", "torch.stack.append", "torch.get_rank", "zip"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank"], ["def", "reduce_loss_dict", "(", "loss_dict", ")", ":", "\n", "    ", "\"\"\"\n    Reduce the loss dictionary from all processes so that process with rank\n    0 has the averaged results. Returns a dict with the same fields as\n    loss_dict, after reduction.\n    \"\"\"", "\n", "world_size", "=", "get_world_size", "(", ")", "\n", "if", "world_size", "<", "2", ":", "\n", "        ", "return", "loss_dict", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "loss_names", "=", "[", "]", "\n", "all_losses", "=", "[", "]", "\n", "for", "k", "in", "sorted", "(", "loss_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "loss_names", ".", "append", "(", "k", ")", "\n", "all_losses", ".", "append", "(", "loss_dict", "[", "k", "]", ")", "\n", "", "all_losses", "=", "torch", ".", "stack", "(", "all_losses", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "all_losses", ",", "dst", "=", "0", ")", "\n", "if", "dist", ".", "get_rank", "(", ")", "==", "0", ":", "\n", "# only main process gets accumulated, so only divide by", "\n", "# world_size in this case", "\n", "            ", "all_losses", "/=", "world_size", "\n", "", "reduced_losses", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "loss_names", ",", "all_losses", ")", "}", "\n", "", "return", "reduced_losses", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.trainer.do_train": [[39, 123], ["logging.getLogger", "logging.getLogger.info", "len", "model.train", "time.time", "time.time", "enumerate", "str", "logging.getLogger.info", "any", "images.to.to", "model", "sum", "trainer.reduce_loss_dict", "sum", "meters.update", "optimizer.zero_grad", "optimizer.step", "scheduler.step", "time.time", "meters.update", "str", "time.time", "datetime.timedelta", "logging.getLogger.error", "time.time", "target.to", "apex.amp.scale_loss", "scaled_losses.backward", "time.time", "datetime.timedelta", "logging.getLogger.info", "checkpointer.save", "checkpointer.save", "meters.delimiter.join().format", "len", "model.values", "reduce_loss_dict.values", "int", "meters.delimiter.join", "str", "len", "torch.cuda.max_memory_allocated", "torch.cuda.max_memory_allocated"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.trainer.reduce_loss_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.zero_grad", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.step", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.step", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_func.DeformRoIPoolingFunction.backward", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save"], ["", "def", "do_train", "(", "\n", "model", ",", "\n", "data_loader", ",", "\n", "optimizer", ",", "\n", "scheduler", ",", "\n", "checkpointer", ",", "\n", "device", ",", "\n", "checkpoint_period", ",", "\n", "arguments", ",", "\n", "meters", ",", "\n", "cfg", "\n", ")", ":", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "\"vc_rcnn.trainer\"", ")", "\n", "logger", ".", "info", "(", "\"Start training\"", ")", "\n", "# meters = MetricLogger(delimiter=\"  \")", "\n", "max_iter", "=", "len", "(", "data_loader", ")", "\n", "start_iter", "=", "arguments", "[", "\"iteration\"", "]", "\n", "model", ".", "train", "(", ")", "\n", "start_training_time", "=", "time", ".", "time", "(", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "for", "iteration", ",", "(", "images", ",", "targets", ",", "_", ")", "in", "enumerate", "(", "data_loader", ",", "start_iter", ")", ":", "\n", "\n", "        ", "if", "any", "(", "len", "(", "target", ")", "<", "1", "for", "target", "in", "targets", ")", ":", "\n", "            ", "logger", ".", "error", "(", "f\"Iteration={iteration + 1} || Image Ids used for training {_} || targets Length={[len(target) for target in targets]}\"", ")", "\n", "continue", "\n", "", "data_time", "=", "time", ".", "time", "(", ")", "-", "end", "\n", "iteration", "=", "iteration", "+", "1", "\n", "arguments", "[", "\"iteration\"", "]", "=", "iteration", "\n", "\n", "images", "=", "images", ".", "to", "(", "device", ")", "\n", "targets", "=", "[", "target", ".", "to", "(", "device", ")", "for", "target", "in", "targets", "]", "\n", "\n", "loss_dict", "=", "model", "(", "images", ",", "targets", ")", "\n", "\n", "losses", "=", "sum", "(", "loss", "for", "loss", "in", "loss_dict", ".", "values", "(", ")", ")", "\n", "\n", "# reduce losses over all GPUs for logging purposes", "\n", "loss_dict_reduced", "=", "reduce_loss_dict", "(", "loss_dict", ")", "\n", "losses_reduced", "=", "sum", "(", "loss", "for", "loss", "in", "loss_dict_reduced", ".", "values", "(", ")", ")", "\n", "meters", ".", "update", "(", "loss", "=", "losses_reduced", ",", "**", "loss_dict_reduced", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "# Note: If mixed precision is not used, this ends up doing nothing", "\n", "# Otherwise apply loss scaling for mixed-precision recipe", "\n", "with", "amp", ".", "scale_loss", "(", "losses", ",", "optimizer", ")", "as", "scaled_losses", ":", "\n", "            ", "scaled_losses", ".", "backward", "(", ")", "\n", "", "optimizer", ".", "step", "(", ")", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n", "batch_time", "=", "time", ".", "time", "(", ")", "-", "end", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "meters", ".", "update", "(", "time", "=", "batch_time", ",", "data", "=", "data_time", ")", "\n", "\n", "eta_seconds", "=", "meters", ".", "time", ".", "global_avg", "*", "(", "max_iter", "-", "iteration", ")", "\n", "eta_string", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "eta_seconds", ")", ")", ")", "\n", "\n", "if", "iteration", "%", "20", "==", "0", "or", "iteration", "==", "max_iter", ":", "\n", "            ", "logger", ".", "info", "(", "\n", "meters", ".", "delimiter", ".", "join", "(", "\n", "[", "\n", "\"eta: {eta}\"", ",", "\n", "\"iter: {iter}\"", ",", "\n", "\"{meters}\"", ",", "\n", "\"lr: {lr:.6f}\"", ",", "\n", "\"max mem: {memory:.0f}\"", ",", "\n", "]", "\n", ")", ".", "format", "(", "\n", "eta", "=", "eta_string", ",", "\n", "iter", "=", "iteration", ",", "\n", "meters", "=", "str", "(", "meters", ")", ",", "\n", "lr", "=", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", ",", "\n", "memory", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "/", "1024.0", "/", "1024.0", ",", "\n", ")", "\n", ")", "\n", "", "if", "iteration", "%", "checkpoint_period", "==", "0", ":", "\n", "            ", "checkpointer", ".", "save", "(", "\"model_{:07d}\"", ".", "format", "(", "iteration", ")", ",", "**", "arguments", ")", "\n", "", "if", "iteration", "==", "max_iter", ":", "\n", "            ", "checkpointer", ".", "save", "(", "\"model_final\"", ",", "**", "arguments", ")", "\n", "\n", "", "", "total_training_time", "=", "time", ".", "time", "(", ")", "-", "start_training_time", "\n", "total_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "total_training_time", ")", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total training time: {} ({:.4f} s / it)\"", ".", "format", "(", "\n", "total_time_str", ",", "total_training_time", "/", "(", "max_iter", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.build_dataset": [[18, 61], ["isinstance", "RuntimeError", "dataset_catalog.get", "getattr", "getattr.", "datasets.append", "len", "datasets.ConcatDataset"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["def", "build_dataset", "(", "dataset_list", ",", "transforms", ",", "dataset_catalog", ",", "cfg", ",", "is_train", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Arguments:\n        dataset_list (list[str]): Contains the names of the datasets, i.e.,\n            coco_2014_train, coco_2014_val, etc\n        transforms (callable): transforms to apply to each (image, target) sample\n        dataset_catalog (DatasetCatalog): contains the information on how to\n            construct a dataset.\n        is_train (bool): whether to setup the dataset for training or testing\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "dataset_list", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "\n", "\"dataset_list should be a list of strings, got {}\"", ".", "format", "(", "dataset_list", ")", "\n", ")", "\n", "", "datasets", "=", "[", "]", "\n", "for", "dataset_name", "in", "dataset_list", ":", "\n", "        ", "data", "=", "dataset_catalog", ".", "get", "(", "dataset_name", ")", "\n", "factory", "=", "getattr", "(", "D", ",", "data", "[", "\"factory\"", "]", ")", "\n", "args", "=", "data", "[", "\"args\"", "]", "\n", "args", "[", "'bbox_file_path'", "]", "=", "cfg", ".", "BOUNDINGBOX_FILE", "\n", "args", "[", "'num_threshold_object'", "]", "=", "cfg", ".", "NUM_THRESHOLD_OBJECT", "\n", "\n", "# for COCODataset, we want to remove images without annotations", "\n", "# during training", "\n", "if", "data", "[", "\"factory\"", "]", "==", "\"COCODataset\"", ":", "\n", "            ", "args", "[", "\"remove_images_without_annotations\"", "]", "=", "is_train", "\n", "", "if", "data", "[", "\"factory\"", "]", "==", "\"PascalVOCDataset\"", ":", "\n", "            ", "args", "[", "\"use_difficult\"", "]", "=", "not", "is_train", "\n", "", "args", "[", "\"transforms\"", "]", "=", "transforms", "\n", "# make dataset from factory", "\n", "dataset", "=", "factory", "(", "**", "args", ")", "\n", "datasets", ".", "append", "(", "dataset", ")", "\n", "\n", "# for testing, return a list of datasets", "\n", "", "if", "not", "is_train", ":", "\n", "        ", "return", "datasets", "\n", "\n", "# for training, concatenate all datasets into a single one", "\n", "", "dataset", "=", "datasets", "[", "0", "]", "\n", "if", "len", "(", "datasets", ")", ">", "1", ":", "\n", "        ", "dataset", "=", "D", ".", "ConcatDataset", "(", "datasets", ")", "\n", "\n", "", "return", "[", "dataset", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.make_data_sampler": [[63, 71], ["samplers.DistributedSampler", "torch.utils.data.sampler.RandomSampler", "torch.utils.data.sampler.SequentialSampler"], "function", ["None"], ["", "def", "make_data_sampler", "(", "dataset", ",", "shuffle", ",", "distributed", ")", ":", "\n", "    ", "if", "distributed", ":", "\n", "        ", "return", "samplers", ".", "DistributedSampler", "(", "dataset", ",", "shuffle", "=", "shuffle", ")", "\n", "", "if", "shuffle", ":", "\n", "        ", "sampler", "=", "torch", ".", "utils", ".", "data", ".", "sampler", ".", "RandomSampler", "(", "dataset", ")", "\n", "", "else", ":", "\n", "        ", "sampler", "=", "torch", ".", "utils", ".", "data", ".", "sampler", ".", "SequentialSampler", "(", "dataset", ")", "\n", "", "return", "sampler", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build._quantize": [[73, 78], ["copy.copy", "sorted", "list", "map", "bisect.bisect_right"], "function", ["None"], ["", "def", "_quantize", "(", "x", ",", "bins", ")", ":", "\n", "    ", "bins", "=", "copy", ".", "copy", "(", "bins", ")", "\n", "bins", "=", "sorted", "(", "bins", ")", "\n", "quantized", "=", "list", "(", "map", "(", "lambda", "y", ":", "bisect", ".", "bisect_right", "(", "bins", ",", "y", ")", ",", "x", ")", ")", "\n", "return", "quantized", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build._compute_aspect_ratios": [[80, 87], ["range", "len", "dataset.get_img_info", "aspect_ratios.append", "float", "float"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info"], ["", "def", "_compute_aspect_ratios", "(", "dataset", ")", ":", "\n", "    ", "aspect_ratios", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dataset", ")", ")", ":", "\n", "        ", "img_info", "=", "dataset", ".", "get_img_info", "(", "i", ")", "\n", "aspect_ratio", "=", "float", "(", "img_info", "[", "\"height\"", "]", ")", "/", "float", "(", "img_info", "[", "\"width\"", "]", ")", "\n", "aspect_ratios", ".", "append", "(", "aspect_ratio", ")", "\n", "", "return", "aspect_ratios", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.make_batch_data_sampler": [[89, 109], ["build._compute_aspect_ratios", "build._quantize", "samplers.GroupedBatchSampler", "torch.utils.data.sampler.BatchSampler", "samplers.IterationBasedBatchSampler", "isinstance"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build._compute_aspect_ratios", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build._quantize"], ["", "def", "make_batch_data_sampler", "(", "\n", "dataset", ",", "sampler", ",", "aspect_grouping", ",", "images_per_batch", ",", "num_iters", "=", "None", ",", "start_iter", "=", "0", "\n", ")", ":", "\n", "    ", "if", "aspect_grouping", ":", "\n", "        ", "if", "not", "isinstance", "(", "aspect_grouping", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "aspect_grouping", "=", "[", "aspect_grouping", "]", "\n", "", "aspect_ratios", "=", "_compute_aspect_ratios", "(", "dataset", ")", "\n", "group_ids", "=", "_quantize", "(", "aspect_ratios", ",", "aspect_grouping", ")", "\n", "batch_sampler", "=", "samplers", ".", "GroupedBatchSampler", "(", "\n", "sampler", ",", "group_ids", ",", "images_per_batch", ",", "drop_uneven", "=", "False", "\n", ")", "\n", "", "else", ":", "\n", "        ", "batch_sampler", "=", "torch", ".", "utils", ".", "data", ".", "sampler", ".", "BatchSampler", "(", "\n", "sampler", ",", "images_per_batch", ",", "drop_last", "=", "False", "\n", ")", "\n", "", "if", "num_iters", "is", "not", "None", ":", "\n", "        ", "batch_sampler", "=", "samplers", ".", "IterationBasedBatchSampler", "(", "\n", "batch_sampler", ",", "num_iters", ",", "start_iter", "\n", ")", "\n", "", "return", "batch_sampler", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.make_data_loader": [[111, 186], ["vc_rcnn.utils.comm.get_world_size", "vc_rcnn.utils.imports.import_file", "build.build_dataset", "logging.getLogger", "logging.getLogger.warning", "transforms.build_transforms", "vc_rcnn.utils.miscellaneous.save_labels", "build.make_data_sampler", "build.make_batch_data_sampler", "torch.utils.data.DataLoader", "data_loaders.append", "collate_batch.BBoxAugCollator", "collate_batch.BatchCollator", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.build_dataset", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.build.build_transforms", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.save_labels", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.make_data_sampler", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.make_batch_data_sampler"], ["", "def", "make_data_loader", "(", "cfg", ",", "is_train", "=", "True", ",", "is_distributed", "=", "False", ",", "start_iter", "=", "0", ")", ":", "\n", "    ", "num_gpus", "=", "get_world_size", "(", ")", "\n", "if", "is_train", ":", "\n", "        ", "images_per_batch", "=", "cfg", ".", "SOLVER", ".", "IMS_PER_BATCH", "\n", "assert", "(", "\n", "images_per_batch", "%", "num_gpus", "==", "0", "\n", ")", ",", "\"SOLVER.IMS_PER_BATCH ({}) must be divisible by the number of GPUs ({}) used.\"", ".", "format", "(", "\n", "images_per_batch", ",", "num_gpus", ")", "\n", "images_per_gpu", "=", "images_per_batch", "//", "num_gpus", "\n", "shuffle", "=", "True", "\n", "num_iters", "=", "cfg", ".", "SOLVER", ".", "MAX_ITER", "\n", "", "else", ":", "\n", "        ", "images_per_batch", "=", "cfg", ".", "TEST", ".", "IMS_PER_BATCH", "\n", "assert", "(", "\n", "images_per_batch", "%", "num_gpus", "==", "0", "\n", ")", ",", "\"TEST.IMS_PER_BATCH ({}) must be divisible by the number of GPUs ({}) used.\"", ".", "format", "(", "\n", "images_per_batch", ",", "num_gpus", ")", "\n", "images_per_gpu", "=", "images_per_batch", "//", "num_gpus", "\n", "shuffle", "=", "False", "if", "not", "is_distributed", "else", "True", "\n", "num_iters", "=", "None", "\n", "start_iter", "=", "0", "\n", "\n", "", "if", "images_per_gpu", ">", "1", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"When using more than one image per GPU you may encounter \"", "\n", "\"an out-of-memory (OOM) error if your GPU does not have \"", "\n", "\"sufficient memory. If this happens, you can reduce \"", "\n", "\"SOLVER.IMS_PER_BATCH (for training) or \"", "\n", "\"TEST.IMS_PER_BATCH (for inference). For training, you must \"", "\n", "\"also adjust the learning rate and schedule length according \"", "\n", "\"to the linear scaling rule. See for example: \"", "\n", "\"https://github.com/facebookresearch/Detectron/blob/master/configs/getting_started/tutorial_1gpu_e2e_faster_rcnn_R-50-FPN.yaml#L14\"", "\n", ")", "\n", "\n", "# group images which have similar aspect ratio. In this case, we only", "\n", "# group in two cases: those with width / height > 1, and the other way around,", "\n", "# but the code supports more general grouping strategy", "\n", "", "aspect_grouping", "=", "[", "1", "]", "if", "cfg", ".", "DATALOADER", ".", "ASPECT_RATIO_GROUPING", "else", "[", "]", "\n", "\n", "paths_catalog", "=", "import_file", "(", "\n", "\"vc_rcnn.config.paths_catalog\"", ",", "cfg", ".", "PATHS_CATALOG", ",", "True", "\n", ")", "\n", "DatasetCatalog", "=", "paths_catalog", ".", "DatasetCatalog", "\n", "dataset_list", "=", "cfg", ".", "DATASETS", ".", "TRAIN", "if", "is_train", "else", "cfg", ".", "DATASETS", ".", "TEST", "\n", "\n", "# If bbox aug is enabled in testing, simply set transforms to None and we will apply transforms later", "\n", "transforms", "=", "None", "if", "not", "is_train", "and", "cfg", ".", "TEST", ".", "BBOX_AUG", ".", "ENABLED", "else", "build_transforms", "(", "cfg", ",", "is_train", ")", "\n", "datasets", "=", "build_dataset", "(", "dataset_list", ",", "transforms", ",", "DatasetCatalog", ",", "cfg", ",", "is_train", ")", "\n", "\n", "if", "is_train", ":", "\n", "# save category_id to label name mapping", "\n", "        ", "save_labels", "(", "datasets", ",", "cfg", ".", "OUTPUT_DIR", ")", "\n", "\n", "", "data_loaders", "=", "[", "]", "\n", "for", "dataset", "in", "datasets", ":", "\n", "        ", "sampler", "=", "make_data_sampler", "(", "dataset", ",", "shuffle", ",", "is_distributed", ")", "\n", "batch_sampler", "=", "make_batch_data_sampler", "(", "\n", "dataset", ",", "sampler", ",", "aspect_grouping", ",", "images_per_gpu", ",", "num_iters", ",", "start_iter", "\n", ")", "\n", "collator", "=", "BBoxAugCollator", "(", ")", "if", "not", "is_train", "and", "cfg", ".", "TEST", ".", "BBOX_AUG", ".", "ENABLED", "else", "BatchCollator", "(", "cfg", ".", "DATALOADER", ".", "SIZE_DIVISIBILITY", ")", "\n", "num_workers", "=", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "\n", "data_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "batch_sampler", "=", "batch_sampler", ",", "\n", "collate_fn", "=", "collator", ",", "\n", ")", "\n", "data_loaders", ".", "append", "(", "data_loader", ")", "\n", "", "if", "is_train", ":", "\n", "# during training, a single (possibly concatenated) data_loader is returned", "\n", "        ", "assert", "len", "(", "data_loaders", ")", "==", "1", "\n", "return", "data_loaders", "[", "0", "]", "\n", "", "return", "data_loaders", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.collate_batch.BatchCollator.__init__": [[12, 14], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size_divisible", "=", "0", ")", ":", "\n", "        ", "self", ".", "size_divisible", "=", "size_divisible", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.collate_batch.BatchCollator.__call__": [[15, 21], ["list", "vc_rcnn.structures.image_list.to_image_list", "zip"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.image_list.to_image_list"], ["", "def", "__call__", "(", "self", ",", "batch", ")", ":", "\n", "        ", "transposed_batch", "=", "list", "(", "zip", "(", "*", "batch", ")", ")", "\n", "images", "=", "to_image_list", "(", "transposed_batch", "[", "0", "]", ",", "self", ".", "size_divisible", ")", "\n", "targets", "=", "transposed_batch", "[", "1", "]", "\n", "img_ids", "=", "transposed_batch", "[", "2", "]", "\n", "return", "images", ",", "targets", ",", "img_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.collate_batch.BBoxAugCollator.__call__": [[30, 32], ["list", "zip"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "batch", ")", ":", "\n", "        ", "return", "list", "(", "zip", "(", "*", "batch", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.load_data.DataSet.__init__": [[16, 110], ["__C.SPLIT[].split", "__C.SPLIT[].split", "print", "core.data.data_utils.ques_load", "core.data.data_utils.tokenize", "load_data.DataSet.token_to_ix.__len__", "print", "core.data.data_utils.ans_stat", "load_data.DataSet.ans_to_ix.__len__", "print", "print", "print", "load_data.DataSet.ans_list.__len__", "load_data.DataSet.ques_list.__len__", "print", "time.time", "core.data.data_utils.img_feat_load", "time.time", "print", "core.data.data_utils.img_feat_path_load", "glob.glob", "json.load", "json.load", "json.load", "open", "open", "json.load", "int", "json.load", "json.load", "open", "open", "open", "open"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.ques_load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.tokenize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.ans_stat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.img_feat_load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.img_feat_path_load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["    ", "def", "__init__", "(", "self", ",", "__C", ")", ":", "\n", "        ", "self", ".", "__C", "=", "__C", "\n", "self", ".", "feature_path_vc", "=", "__C", ".", "FEATURE_PATH_VC", "\n", "self", ".", "feature_path_bu", "=", "__C", ".", "FEATURE_PATH_BU", "\n", "\n", "# --------------------------", "\n", "# ---- Raw data loading ----", "\n", "# --------------------------", "\n", "\n", "# Loading all image paths", "\n", "# if self.__C.PRELOAD:", "\n", "self", ".", "img_feat_path_list", "=", "[", "]", "\n", "split_list", "=", "__C", ".", "SPLIT", "[", "__C", ".", "RUN_MODE", "]", ".", "split", "(", "'+'", ")", "\n", "for", "split", "in", "split_list", ":", "\n", "            ", "if", "split", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "                ", "self", ".", "img_feat_path_list", "+=", "glob", ".", "glob", "(", "__C", ".", "IMG_FEAT_PATH", "[", "split", "]", "+", "'*.npz'", ")", "\n", "\n", "# if __C.EVAL_EVERY_EPOCH and __C.RUN_MODE in ['train']:", "\n", "#     self.img_feat_path_list += glob.glob(__C.IMG_FEAT_PATH['val'] + '*.npz')", "\n", "\n", "# else:", "\n", "#     self.img_feat_path_list = \\", "\n", "#         glob.glob(__C.IMG_FEAT_PATH['train'] + '*.npz') + \\", "\n", "#         glob.glob(__C.IMG_FEAT_PATH['val'] + '*.npz') + \\", "\n", "#         glob.glob(__C.IMG_FEAT_PATH['test'] + '*.npz')", "\n", "\n", "# Loading question word list", "\n", "", "", "self", ".", "stat_ques_list", "=", "json", ".", "load", "(", "open", "(", "__C", ".", "QUESTION_PATH", "[", "'train'", "]", ",", "'r'", ")", ")", "[", "'questions'", "]", "+", "json", ".", "load", "(", "open", "(", "__C", ".", "QUESTION_PATH", "[", "'val'", "]", ",", "'r'", ")", ")", "[", "'questions'", "]", "+", "json", ".", "load", "(", "open", "(", "__C", ".", "QUESTION_PATH", "[", "'test'", "]", ",", "'r'", ")", ")", "[", "'questions'", "]", "+", "json", ".", "load", "(", "open", "(", "__C", ".", "QUESTION_PATH", "[", "'vg'", "]", ",", "'r'", ")", ")", "[", "'questions'", "]", "\n", "\n", "# Loading answer word list", "\n", "# self.stat_ans_list = \\", "\n", "#     json.load(open(__C.ANSWER_PATH['train'], 'r'))['annotations'] + \\", "\n", "#     json.load(open(__C.ANSWER_PATH['val'], 'r'))['annotations']", "\n", "\n", "# Loading question and answer list", "\n", "self", ".", "ques_list", "=", "[", "]", "\n", "self", ".", "ans_list", "=", "[", "]", "\n", "\n", "split_list", "=", "__C", ".", "SPLIT", "[", "__C", ".", "RUN_MODE", "]", ".", "split", "(", "'+'", ")", "\n", "for", "split", "in", "split_list", ":", "\n", "            ", "self", ".", "ques_list", "+=", "json", ".", "load", "(", "open", "(", "__C", ".", "QUESTION_PATH", "[", "split", "]", ",", "'r'", ")", ")", "[", "'questions'", "]", "\n", "if", "__C", ".", "RUN_MODE", "in", "[", "'train'", "]", ":", "\n", "                ", "self", ".", "ans_list", "+=", "json", ".", "load", "(", "open", "(", "__C", ".", "ANSWER_PATH", "[", "split", "]", ",", "'r'", ")", ")", "[", "'annotations'", "]", "\n", "\n", "# Define run data size", "\n", "", "", "if", "__C", ".", "RUN_MODE", "in", "[", "'train'", "]", ":", "\n", "            ", "self", ".", "data_size", "=", "self", ".", "ans_list", ".", "__len__", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "data_size", "=", "self", ".", "ques_list", ".", "__len__", "(", ")", "\n", "\n", "", "print", "(", "'== Dataset size:'", ",", "self", ".", "data_size", ")", "\n", "\n", "\n", "# ------------------------", "\n", "# ---- Data statistic ----", "\n", "# ------------------------", "\n", "\n", "# {image id} -> {image feature absolutely path}", "\n", "if", "self", ".", "__C", ".", "PRELOAD", ":", "\n", "            ", "print", "(", "'==== Pre-Loading features ...'", ")", "\n", "time_start", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "iid_to_img_feat", "=", "img_feat_load", "(", "self", ".", "img_feat_path_list", ")", "\n", "time_end", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'==== Finished in {}s'", ".", "format", "(", "int", "(", "time_end", "-", "time_start", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "iid_to_img_feat_path", "=", "img_feat_path_load", "(", "self", ".", "img_feat_path_list", ")", "\n", "\n", "# {question id} -> {question}", "\n", "", "self", ".", "qid_to_ques", "=", "ques_load", "(", "self", ".", "ques_list", ")", "\n", "\n", "# Tokenize", "\n", "self", ".", "token_to_ix", ",", "self", ".", "pretrained_emb", "=", "tokenize", "(", "self", ".", "stat_ques_list", ",", "__C", ".", "USE_GLOVE", ")", "\n", "self", ".", "token_size", "=", "self", ".", "token_to_ix", ".", "__len__", "(", ")", "\n", "print", "(", "'== Question token vocab size:'", ",", "self", ".", "token_size", ")", "\n", "\n", "# Answers statistic", "\n", "# Make answer dict during training does not guarantee", "\n", "# the same order of {ans_to_ix}, so we published our", "\n", "# answer dict to ensure that our pre-trained model", "\n", "# can be adapted on each machine.", "\n", "\n", "# Thanks to Licheng Yu (https://github.com/lichengunc)", "\n", "# for finding this bug and providing the solutions.", "\n", "\n", "# self.ans_to_ix, self.ix_to_ans = ans_stat(self.stat_ans_list, __C.ANS_FREQ)", "\n", "self", ".", "ans_to_ix", ",", "self", ".", "ix_to_ans", "=", "ans_stat", "(", "'core/data/answer_dict.json'", ")", "\n", "self", ".", "ans_size", "=", "self", ".", "ans_to_ix", ".", "__len__", "(", ")", "\n", "print", "(", "'== Answer vocab size (occurr more than {} times):'", ".", "format", "(", "8", ")", ",", "self", ".", "ans_size", ")", "\n", "print", "(", "'Finished!'", ")", "\n", "print", "(", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.load_data.DataSet.__getitem__": [[112, 181], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "core.data.data_utils.proc_img_feat", "core.data.data_utils.proc_ques", "core.data.data_utils.proc_ans", "core.data.data_utils.proc_img_feat", "core.data.data_utils.proc_ques", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.load", "img_feat[].transpose", "numpy.load", "numpy.hstack", "numpy.load", "img_feat[].transpose", "numpy.load", "numpy.hstack", "str", "str", "print", "numpy.load", "str", "print", "numpy.load", "str", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.proc_img_feat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.proc_ques", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.proc_ans", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.proc_img_feat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.proc_ques", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "\n", "# For code safety", "\n", "        ", "img_feat_iter", "=", "np", ".", "zeros", "(", "1", ")", "\n", "ques_ix_iter", "=", "np", ".", "zeros", "(", "1", ")", "\n", "ans_iter", "=", "np", ".", "zeros", "(", "1", ")", "\n", "\n", "# Process ['train'] and ['val', 'test'] respectively", "\n", "if", "self", ".", "__C", ".", "RUN_MODE", "in", "[", "'train'", "]", ":", "\n", "# Load the run data from list", "\n", "            ", "ans", "=", "self", ".", "ans_list", "[", "idx", "]", "\n", "ques", "=", "self", ".", "qid_to_ques", "[", "str", "(", "ans", "[", "'question_id'", "]", ")", "]", "\n", "\n", "# Process image feature from (.npz) file", "\n", "if", "self", ".", "__C", ".", "PRELOAD", ":", "\n", "                ", "img_feat_x", "=", "self", ".", "iid_to_img_feat", "[", "str", "(", "ans", "[", "'image_id'", "]", ")", "]", "\n", "", "else", ":", "\n", "# modified by Tan Wang", "\n", "                ", "img_feat", "=", "np", ".", "load", "(", "self", ".", "iid_to_img_feat_path", "[", "str", "(", "ans", "[", "'image_id'", "]", ")", "]", ")", "\n", "img_feat_x", "=", "img_feat", "[", "'x'", "]", ".", "transpose", "(", "(", "1", ",", "0", ")", ")", "\n", "img_feat_vc", "=", "np", ".", "load", "(", "self", ".", "feature_path_vc", "+", "'/'", "+", "str", "(", "ans", "[", "'image_id'", "]", ")", "+", "'.npy'", ")", "\n", "try", ":", "\n", "                    ", "assert", "img_feat_x", ".", "shape", "[", "0", "]", "==", "img_feat_vc", ".", "shape", "[", "0", "]", "\n", "", "except", ":", "\n", "                    ", "print", "(", "ans", "[", "'image_id'", "]", ")", "\n", "img_feat", "=", "np", ".", "load", "(", "self", ".", "feature_path_bu", "+", "'/'", "+", "str", "(", "ans", "[", "'image_id'", "]", ")", "+", "'.npy'", ")", "\n", "img_feat_x", "=", "img_feat", "[", ":", "img_feat_vc", ".", "shape", "[", "0", "]", ",", ":", "]", "\n", "assert", "img_feat_x", ".", "shape", "[", "0", "]", "==", "img_feat_vc", ".", "shape", "[", "0", "]", "\n", "", "img_feat_x", "=", "np", ".", "hstack", "(", "(", "img_feat_x", ",", "img_feat_vc", ")", ")", "\n", "", "img_feat_iter", "=", "proc_img_feat", "(", "img_feat_x", ",", "self", ".", "__C", ".", "IMG_FEAT_PAD_SIZE", ")", "\n", "\n", "# Process question", "\n", "ques_ix_iter", "=", "proc_ques", "(", "ques", ",", "self", ".", "token_to_ix", ",", "self", ".", "__C", ".", "MAX_TOKEN", ")", "\n", "\n", "# Process answer", "\n", "ans_iter", "=", "proc_ans", "(", "ans", ",", "self", ".", "ans_to_ix", ")", "\n", "\n", "", "else", ":", "\n", "# Load the run data from list", "\n", "            ", "ques", "=", "self", ".", "ques_list", "[", "idx", "]", "\n", "\n", "# # Process image feature from (.npz) file", "\n", "# img_feat = np.load(self.iid_to_img_feat_path[str(ques['image_id'])])", "\n", "# img_feat_x = img_feat['x'].transpose((1, 0))", "\n", "# Process image feature from (.npz) file", "\n", "if", "self", ".", "__C", ".", "PRELOAD", ":", "\n", "                ", "img_feat_x", "=", "self", ".", "iid_to_img_feat", "[", "str", "(", "ques", "[", "'image_id'", "]", ")", "]", "\n", "", "else", ":", "\n", "# modified by Tan Wang", "\n", "                ", "img_feat", "=", "np", ".", "load", "(", "self", ".", "iid_to_img_feat_path", "[", "str", "(", "ques", "[", "'image_id'", "]", ")", "]", ")", "\n", "img_feat_x", "=", "img_feat", "[", "'x'", "]", ".", "transpose", "(", "(", "1", ",", "0", ")", ")", "\n", "img_feat_vc", "=", "np", ".", "load", "(", "self", ".", "feature_path_vc", "+", "'/'", "+", "str", "(", "ques", "[", "'image_id'", "]", ")", "+", "'.npy'", ")", "\n", "try", ":", "\n", "                    ", "assert", "img_feat_x", ".", "shape", "[", "0", "]", "==", "img_feat_vc", ".", "shape", "[", "0", "]", "\n", "", "except", ":", "\n", "                    ", "print", "(", "ques", "[", "'image_id'", "]", ")", "\n", "img_feat", "=", "np", ".", "load", "(", "self", ".", "feature_path_bu", "+", "'/'", "+", "str", "(", "ques", "[", "'image_id'", "]", ")", "+", "'.npy'", ")", "\n", "img_feat_x", "=", "img_feat", "[", ":", "img_feat_vc", ".", "shape", "[", "0", "]", ",", ":", "]", "\n", "assert", "img_feat_x", ".", "shape", "[", "0", "]", "==", "img_feat_vc", ".", "shape", "[", "0", "]", "\n", "", "img_feat_x", "=", "np", ".", "hstack", "(", "(", "img_feat_x", ",", "img_feat_vc", ")", ")", "\n", "", "img_feat_iter", "=", "proc_img_feat", "(", "img_feat_x", ",", "self", ".", "__C", ".", "IMG_FEAT_PAD_SIZE", ")", "\n", "\n", "# Process question", "\n", "ques_ix_iter", "=", "proc_ques", "(", "ques", ",", "self", ".", "token_to_ix", ",", "self", ".", "__C", ".", "MAX_TOKEN", ")", "\n", "\n", "\n", "", "return", "torch", ".", "from_numpy", "(", "img_feat_iter", ")", ",", "torch", ".", "from_numpy", "(", "ques_ix_iter", ")", ",", "torch", ".", "from_numpy", "(", "ans_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.load_data.DataSet.__len__": [[183, 185], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.shuffle_list": [[12, 14], ["random.shuffle"], "function", ["None"], ["def", "shuffle_list", "(", "ans_list", ")", ":", "\n", "    ", "random", ".", "shuffle", "(", "ans_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.img_feat_path_load": [[20, 28], ["enumerate", "str", "int", "[].split", "[].split", "path.split"], "function", ["None"], ["", "def", "img_feat_path_load", "(", "path_list", ")", ":", "\n", "    ", "iid_to_path", "=", "{", "}", "\n", "\n", "for", "ix", ",", "path", "in", "enumerate", "(", "path_list", ")", ":", "\n", "        ", "iid", "=", "str", "(", "int", "(", "path", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", ")", "\n", "iid_to_path", "[", "iid", "]", "=", "path", "\n", "\n", "", "return", "iid_to_path", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.img_feat_load": [[30, 41], ["enumerate", "str", "numpy.load", "img_feat[].transpose", "print", "int", "path_list.__len__", "[].split", "[].split", "path.split"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__"], ["", "def", "img_feat_load", "(", "path_list", ")", ":", "\n", "    ", "iid_to_feat", "=", "{", "}", "\n", "\n", "for", "ix", ",", "path", "in", "enumerate", "(", "path_list", ")", ":", "\n", "        ", "iid", "=", "str", "(", "int", "(", "path", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", ")", "\n", "img_feat", "=", "np", ".", "load", "(", "path", ")", "\n", "img_feat_x", "=", "img_feat", "[", "'x'", "]", ".", "transpose", "(", "(", "1", ",", "0", ")", ")", "\n", "iid_to_feat", "[", "iid", "]", "=", "img_feat_x", "\n", "print", "(", "'\\rPre-Loading: [{} | {}] '", ".", "format", "(", "ix", ",", "path_list", ".", "__len__", "(", ")", ")", ",", "end", "=", "'          '", ")", "\n", "\n", "", "return", "iid_to_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.ques_load": [[43, 51], ["str"], "function", ["None"], ["", "def", "ques_load", "(", "ques_list", ")", ":", "\n", "    ", "qid_to_ques", "=", "{", "}", "\n", "\n", "for", "ques", "in", "ques_list", ":", "\n", "        ", "qid", "=", "str", "(", "ques", "[", "'question_id'", "]", ")", "\n", "qid_to_ques", "[", "qid", "]", "=", "ques", "\n", "\n", "", "return", "qid_to_ques", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.tokenize": [[53, 82], ["numpy.array", "en_vectors_web_lg.load", "np.array.append", "np.array.append", "re.sub().replace().replace().split", "en_vectors_web_lg.load.", "en_vectors_web_lg.load.", "re.sub().replace().replace", "len", "np.array.append", "re.sub().replace", "en_vectors_web_lg.load.", "re.sub", "ques[].lower"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["", "def", "tokenize", "(", "stat_ques_list", ",", "use_glove", ")", ":", "\n", "    ", "token_to_ix", "=", "{", "\n", "'PAD'", ":", "0", ",", "\n", "'UNK'", ":", "1", ",", "\n", "}", "\n", "\n", "spacy_tool", "=", "None", "\n", "pretrained_emb", "=", "[", "]", "\n", "if", "use_glove", ":", "\n", "        ", "spacy_tool", "=", "en_vectors_web_lg", ".", "load", "(", ")", "\n", "pretrained_emb", ".", "append", "(", "spacy_tool", "(", "'PAD'", ")", ".", "vector", ")", "\n", "pretrained_emb", ".", "append", "(", "spacy_tool", "(", "'UNK'", ")", ".", "vector", ")", "\n", "\n", "", "for", "ques", "in", "stat_ques_list", ":", "\n", "        ", "words", "=", "re", ".", "sub", "(", "\n", "r\"([.,'!?\\\"()*#:;])\"", ",", "\n", "''", ",", "\n", "ques", "[", "'question'", "]", ".", "lower", "(", ")", "\n", ")", ".", "replace", "(", "'-'", ",", "' '", ")", ".", "replace", "(", "'/'", ",", "' '", ")", ".", "split", "(", ")", "\n", "\n", "for", "word", "in", "words", ":", "\n", "            ", "if", "word", "not", "in", "token_to_ix", ":", "\n", "                ", "token_to_ix", "[", "word", "]", "=", "len", "(", "token_to_ix", ")", "\n", "if", "use_glove", ":", "\n", "                    ", "pretrained_emb", ".", "append", "(", "spacy_tool", "(", "word", ")", ".", "vector", ")", "\n", "\n", "", "", "", "", "pretrained_emb", "=", "np", ".", "array", "(", "pretrained_emb", ")", "\n", "\n", "return", "token_to_ix", ",", "pretrained_emb", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.ans_stat": [[108, 112], ["json.load", "open"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["", "def", "ans_stat", "(", "json_file", ")", ":", "\n", "    ", "ans_to_ix", ",", "ix_to_ans", "=", "json", ".", "load", "(", "open", "(", "json_file", ",", "'r'", ")", ")", "\n", "\n", "return", "ans_to_ix", ",", "ix_to_ans", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.proc_img_feat": [[118, 130], ["numpy.pad"], "function", ["None"], ["", "def", "proc_img_feat", "(", "img_feat", ",", "img_feat_pad_size", ")", ":", "\n", "    ", "if", "img_feat", ".", "shape", "[", "0", "]", ">", "img_feat_pad_size", ":", "\n", "        ", "img_feat", "=", "img_feat", "[", ":", "img_feat_pad_size", "]", "\n", "\n", "", "img_feat", "=", "np", ".", "pad", "(", "\n", "img_feat", ",", "\n", "(", "(", "0", ",", "img_feat_pad_size", "-", "img_feat", ".", "shape", "[", "0", "]", ")", ",", "(", "0", ",", "0", ")", ")", ",", "\n", "mode", "=", "'constant'", ",", "\n", "constant_values", "=", "0", "\n", ")", "\n", "\n", "return", "img_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.proc_ques": [[132, 151], ["numpy.zeros", "re.sub().replace().replace().split", "enumerate", "re.sub().replace().replace", "re.sub().replace", "re.sub", "ques[].lower"], "function", ["None"], ["", "def", "proc_ques", "(", "ques", ",", "token_to_ix", ",", "max_token", ")", ":", "\n", "    ", "ques_ix", "=", "np", ".", "zeros", "(", "max_token", ",", "np", ".", "int64", ")", "\n", "\n", "words", "=", "re", ".", "sub", "(", "\n", "r\"([.,'!?\\\"()*#:;])\"", ",", "\n", "''", ",", "\n", "ques", "[", "'question'", "]", ".", "lower", "(", ")", "\n", ")", ".", "replace", "(", "'-'", ",", "' '", ")", ".", "replace", "(", "'/'", ",", "' '", ")", ".", "split", "(", ")", "\n", "\n", "for", "ix", ",", "word", "in", "enumerate", "(", "words", ")", ":", "\n", "        ", "if", "word", "in", "token_to_ix", ":", "\n", "            ", "ques_ix", "[", "ix", "]", "=", "token_to_ix", "[", "word", "]", "\n", "", "else", ":", "\n", "            ", "ques_ix", "[", "ix", "]", "=", "token_to_ix", "[", "'UNK'", "]", "\n", "\n", "", "if", "ix", "+", "1", "==", "max_token", ":", "\n", "            ", "break", "\n", "\n", "", "", "return", "ques_ix", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.get_score": [[153, 164], ["None"], "function", ["None"], ["", "def", "get_score", "(", "occur", ")", ":", "\n", "    ", "if", "occur", "==", "0", ":", "\n", "        ", "return", ".0", "\n", "", "elif", "occur", "==", "1", ":", "\n", "        ", "return", ".3", "\n", "", "elif", "occur", "==", "2", ":", "\n", "        ", "return", ".6", "\n", "", "elif", "occur", "==", "3", ":", "\n", "        ", "return", ".9", "\n", "", "else", ":", "\n", "        ", "return", "1.", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.proc_ans": [[166, 182], ["numpy.zeros", "ans_to_ix.__len__", "core.data.ans_punct.prep_ans", "data_utils.get_score"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.ans_punct.prep_ans", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.get_score"], ["", "", "def", "proc_ans", "(", "ans", ",", "ans_to_ix", ")", ":", "\n", "    ", "ans_score", "=", "np", ".", "zeros", "(", "ans_to_ix", ".", "__len__", "(", ")", ",", "np", ".", "float32", ")", "\n", "ans_prob_dict", "=", "{", "}", "\n", "\n", "for", "ans_", "in", "ans", "[", "'answers'", "]", ":", "\n", "        ", "ans_proc", "=", "prep_ans", "(", "ans_", "[", "'answer'", "]", ")", "\n", "if", "ans_proc", "not", "in", "ans_prob_dict", ":", "\n", "            ", "ans_prob_dict", "[", "ans_proc", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "ans_prob_dict", "[", "ans_proc", "]", "+=", "1", "\n", "\n", "", "", "for", "ans_", "in", "ans_prob_dict", ":", "\n", "        ", "if", "ans_", "in", "ans_to_ix", ":", "\n", "            ", "ans_score", "[", "ans_to_ix", "[", "ans_", "]", "]", "=", "get_score", "(", "ans_prob_dict", "[", "ans_", "]", ")", "\n", "\n", "", "", "return", "ans_score", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.ans_punct.process_punctuation": [[75, 85], ["period_strip.sub", "outText.replace.replace", "outText.replace.replace", "re.search"], "function", ["None"], ["def", "process_punctuation", "(", "inText", ")", ":", "\n", "    ", "outText", "=", "inText", "\n", "for", "p", "in", "punct", ":", "\n", "        ", "if", "(", "p", "+", "' '", "in", "inText", "or", "' '", "+", "p", "in", "inText", ")", "or", "(", "re", ".", "search", "(", "comma_strip", ",", "inText", ")", "!=", "None", ")", ":", "\n", "            ", "outText", "=", "outText", ".", "replace", "(", "p", ",", "''", ")", "\n", "", "else", ":", "\n", "            ", "outText", "=", "outText", ".", "replace", "(", "p", ",", "' '", ")", "\n", "", "", "outText", "=", "period_strip", ".", "sub", "(", "\"\"", ",", "outText", ",", "re", ".", "UNICODE", ")", "\n", "return", "outText", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.ans_punct.process_digit_article": [[87, 101], ["inText.lower().split", "enumerate", "manual_map.setdefault", "inText.lower", "outText.append"], "function", ["None"], ["", "def", "process_digit_article", "(", "inText", ")", ":", "\n", "    ", "outText", "=", "[", "]", "\n", "tempText", "=", "inText", ".", "lower", "(", ")", ".", "split", "(", ")", "\n", "for", "word", "in", "tempText", ":", "\n", "        ", "word", "=", "manual_map", ".", "setdefault", "(", "word", ",", "word", ")", "\n", "if", "word", "not", "in", "articles", ":", "\n", "            ", "outText", ".", "append", "(", "word", ")", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "", "", "for", "wordId", ",", "word", "in", "enumerate", "(", "outText", ")", ":", "\n", "        ", "if", "word", "in", "contractions", ":", "\n", "            ", "outText", "[", "wordId", "]", "=", "contractions", "[", "word", "]", "\n", "", "", "outText", "=", "' '", ".", "join", "(", "outText", ")", "\n", "return", "outText", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.ans_punct.prep_ans": [[103, 107], ["ans_punct.process_digit_article", "answer.replace.replace", "ans_punct.process_punctuation"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.ans_punct.process_digit_article", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.ans_punct.process_punctuation"], ["", "def", "prep_ans", "(", "answer", ")", ":", "\n", "    ", "answer", "=", "process_digit_article", "(", "process_punctuation", "(", "answer", ")", ")", "\n", "answer", "=", "answer", ".", "replace", "(", "','", ",", "''", ")", "\n", "return", "answer", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.coco.COCODataset.__init__": [[42, 74], ["super().__init__", "sorted", "coco.COCODataset.coco.getAnnIds", "coco.COCODataset.coco.loadAnns", "coco.COCODataset.coco.cats.values", "enumerate", "coco.COCODataset.json_category_id_to_contiguous_id.items", "enumerate", "coco.has_valid_annotation", "ids.append", "coco.COCODataset.coco.getCatIds", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr.has_valid_annotation"], ["    ", "def", "__init__", "(", "\n", "self", ",", "ann_file", ",", "root", ",", "remove_images_without_annotations", ",", "bbox_file_path", ",", "num_threshold_object", ",", "transforms", "=", "None", "\n", ")", ":", "\n", "        ", "super", "(", "COCODataset", ",", "self", ")", ".", "__init__", "(", "root", ",", "ann_file", ")", "\n", "# sort indices for reproducible results", "\n", "self", ".", "ids", "=", "sorted", "(", "self", ".", "ids", ")", "\n", "\n", "# filter images without detection annotations", "\n", "if", "remove_images_without_annotations", ":", "\n", "            ", "ids", "=", "[", "]", "\n", "for", "img_id", "in", "self", ".", "ids", ":", "\n", "                ", "ann_ids", "=", "self", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "img_id", ",", "iscrowd", "=", "None", ")", "\n", "anno", "=", "self", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "if", "has_valid_annotation", "(", "anno", ")", "and", "len", "(", "anno", ")", ">=", "num_threshold_object", ":", "\n", "                    ", "ids", ".", "append", "(", "img_id", ")", "\n", "", "", "self", ".", "ids", "=", "ids", "\n", "\n", "", "self", ".", "categories", "=", "{", "cat", "[", "'id'", "]", ":", "cat", "[", "'name'", "]", "for", "cat", "in", "self", ".", "coco", ".", "cats", ".", "values", "(", ")", "}", "\n", "\n", "self", ".", "json_category_id_to_contiguous_id", "=", "{", "\n", "v", ":", "i", "+", "1", "for", "i", ",", "v", "in", "enumerate", "(", "self", ".", "coco", ".", "getCatIds", "(", ")", ")", "\n", "}", "\n", "self", ".", "contiguous_category_id_to_json_id", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "json_category_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "self", ".", "id_to_img_map", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "enumerate", "(", "self", ".", "ids", ")", "}", "\n", "self", ".", "_transforms", "=", "transforms", "\n", "\n", "# bounding box file (numpy format), used for feature extraction during test", "\n", "self", ".", "box_dir", "=", "bbox_file_path", "\n", "\n", "self", ".", "is_train", "=", "remove_images_without_annotations", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.coco.COCODataset.__getitem__": [[75, 128], ["super().__getitem__", "vc_rcnn.structures.bounding_box.BoxList.add_field", "vc_rcnn.structures.bounding_box.BoxList.add_field", "vc_rcnn.structures.bounding_box.BoxList.add_field", "vc_rcnn.structures.bounding_box.BoxList.clip_to_image", "torch.as_tensor().reshape", "torch.tensor", "torch.tensor", "vc_rcnn.structures.bounding_box.BoxList().convert", "str", "numpy.load", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "vc_rcnn.structures.bounding_box.BoxList", "vc_rcnn.structures.bounding_box.BoxList.add_field", "coco.COCODataset._transforms", "torch.tensor", "int", "torch.as_tensor", "vc_rcnn.structures.bounding_box.BoxList", "os.path.join", "range", "range", "range", "range", "torch.tensor.size", "torch.tensor.size", "torch.tensor.size", "torch.tensor.size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR.__getitem__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.clip_to_image", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", ",", "anno", "=", "super", "(", "COCODataset", ",", "self", ")", ".", "__getitem__", "(", "idx", ")", "\n", "anno", "=", "[", "obj", "for", "obj", "in", "anno", "if", "obj", "[", "\"iscrowd\"", "]", "==", "0", "]", "\n", "w", ",", "h", "=", "img", ".", "size", "[", "0", "]", ",", "img", ".", "size", "[", "1", "]", "\n", "\n", "if", "self", ".", "is_train", ":", "\n", "# assert len(anno) >= 3", "\n", "            ", "boxes", "=", "[", "obj", "[", "\"bbox\"", "]", "for", "obj", "in", "anno", "]", "\n", "boxes", "=", "torch", ".", "as_tensor", "(", "boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "# guard against no boxes", "\n", "classes", "=", "[", "obj", "[", "\"category_id\"", "]", "for", "obj", "in", "anno", "]", "\n", "classes", "=", "[", "self", ".", "json_category_id_to_contiguous_id", "[", "c", "]", "for", "c", "in", "classes", "]", "\n", "classes", "=", "torch", ".", "tensor", "(", "classes", ")", "-", "1", "\n", "\n", "image_id", "=", "[", "obj", "[", "'image_id'", "]", "for", "obj", "in", "anno", "]", "\n", "image_id", "=", "torch", ".", "tensor", "(", "image_id", ")", "\n", "sizes", "=", "[", "[", "w", ",", "h", "]", "for", "obj", "in", "anno", "]", "\n", "sizes", "=", "torch", ".", "tensor", "(", "sizes", ")", "\n", "\n", "target", "=", "BoxList", "(", "boxes", ",", "img", ".", "size", ",", "mode", "=", "\"xywh\"", ")", ".", "convert", "(", "\"xyxy\"", ")", "\n", "\n", "# for feature extraction during testing (bottom up bbox here)", "\n", "", "else", ":", "\n", "            ", "image_id_bu", "=", "str", "(", "self", ".", "id_to_img_map", "[", "idx", "]", ")", "\n", "boxes", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "box_dir", ",", "image_id_bu", ")", "+", "'.npy'", ")", "\n", "num_box", "=", "boxes", ".", "shape", "[", "0", "]", "\n", "boxes", "=", "torch", ".", "tensor", "(", "boxes", ")", "\n", "\n", "# record the num of boxes in image to make sure the preprocess is right", "\n", "num_box", "=", "[", "num_box", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "num_box", "=", "torch", ".", "tensor", "(", "num_box", ")", "\n", "sizes", "=", "[", "[", "w", ",", "h", "]", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "sizes", "=", "torch", ".", "tensor", "(", "sizes", ")", "\n", "image_id", "=", "[", "int", "(", "image_id_bu", ")", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "image_id", "=", "torch", ".", "tensor", "(", "image_id", ")", "\n", "classes", "=", "[", "0", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "classes", "=", "torch", ".", "tensor", "(", "classes", ")", "\n", "\n", "# NOTE that the bounding box format of bottom-up feature is different with COCO", "\n", "target", "=", "BoxList", "(", "boxes", ",", "img", ".", "size", ",", "mode", "=", "\"xyxy\"", ")", "\n", "target", ".", "add_field", "(", "\"num_box\"", ",", "num_box", ")", "\n", "\n", "\n", "", "target", ".", "add_field", "(", "\"labels\"", ",", "classes", ")", "\n", "target", ".", "add_field", "(", "\"image_id\"", ",", "image_id", ")", "\n", "target", ".", "add_field", "(", "\"orignal_size\"", ",", "sizes", ")", "\n", "\n", "\n", "target", "=", "target", ".", "clip_to_image", "(", "remove_empty", "=", "False", ")", "\n", "\n", "if", "self", ".", "_transforms", "is", "not", "None", ":", "\n", "            ", "img", ",", "target", "=", "self", ".", "_transforms", "(", "img", ",", "target", ")", "\n", "\n", "", "return", "img", ",", "target", ",", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.coco.COCODataset.get_img_info": [[129, 133], ["None"], "methods", ["None"], ["", "def", "get_img_info", "(", "self", ",", "index", ")", ":", "\n", "        ", "img_id", "=", "self", ".", "id_to_img_map", "[", "index", "]", "\n", "img_data", "=", "self", ".", "coco", ".", "imgs", "[", "img_id", "]", "\n", "return", "img_data", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.coco._count_visible_keypoints": [[15, 17], ["sum", "sum"], "function", ["None"], ["def", "_count_visible_keypoints", "(", "anno", ")", ":", "\n", "    ", "return", "sum", "(", "sum", "(", "1", "for", "v", "in", "ann", "[", "\"keypoints\"", "]", "[", "2", ":", ":", "3", "]", "if", "v", ">", "0", ")", "for", "ann", "in", "anno", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.coco._has_only_empty_bbox": [[19, 21], ["all", "any"], "function", ["None"], ["", "def", "_has_only_empty_bbox", "(", "anno", ")", ":", "\n", "    ", "return", "all", "(", "any", "(", "o", "<=", "1", "for", "o", "in", "obj", "[", "\"bbox\"", "]", "[", "2", ":", "]", ")", "for", "obj", "in", "anno", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.coco.has_valid_annotation": [[23, 39], ["coco._has_only_empty_bbox", "len", "coco._count_visible_keypoints"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr._has_only_empty_bbox", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr._count_visible_keypoints"], ["", "def", "has_valid_annotation", "(", "anno", ")", ":", "\n", "# if it's empty, there is no annotation", "\n", "    ", "if", "len", "(", "anno", ")", "==", "0", ":", "\n", "        ", "return", "False", "\n", "# if all boxes have close to zero area, there is no annotation", "\n", "", "if", "_has_only_empty_bbox", "(", "anno", ")", ":", "\n", "        ", "return", "False", "\n", "# keypoints task have a slight different critera for considering", "\n", "# if an annotation is valid", "\n", "", "if", "\"keypoints\"", "not", "in", "anno", "[", "0", "]", ":", "\n", "        ", "return", "True", "\n", "# for keypoint detection tasks, only consider valid images those", "\n", "# containing at least min_keypoints_per_image", "\n", "", "if", "_count_visible_keypoints", "(", "anno", ")", ">=", "min_keypoints_per_image", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset.__init__": [[20, 88], ["os.path.abspath", "os.path.abspath", "os.path.exists", "os.path.exists", "cityscapes.CityScapesDataset.initMaps", "int", "os.path.join", "sorted", "sorted", "os.path.join", "os.path.join", "glob.glob", "os.path.join", "glob.glob", "len", "len", "os.path.join", "NotImplementedError", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.abstract.AbstractDataset.initMaps"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "img_dir", ",", "\n", "ann_dir", ",", "\n", "split", ",", "\n", "mode", "=", "\"mask\"", ",", "\n", "transforms", "=", "None", ",", "\n", "min_area", "=", "0", ",", "\n", "mini", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            img_dir: /path/to/leftImg8bit/      has to contain {train,val,test}\n            ann_dir: /path/to/gtFine/           has to contain {train,val,test}\n            split: \"train\" or \"val\" or \"test\"\n            mode: \"poly\" or \"mask\", which annotation format to use\n            transforms: apply transformations to input/annotation\n            min_area: exclude intances below a specific area (bbox area)\n            mini: limit the size of the dataset, so len(dataset) == mini for\n                debugging purposes\n        \"\"\"", "\n", "assert", "split", "in", "[", "\"train\"", ",", "\"val\"", ",", "\"test\"", "]", "\n", "\n", "img_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "img_dir", ",", "split", ")", ")", "\n", "ann_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "ann_dir", ",", "split", ")", ")", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "img_dir", ")", ",", "img_dir", "\n", "assert", "os", ".", "path", ".", "exists", "(", "ann_dir", ")", ",", "ann_dr", "\n", "\n", "self", ".", "ann_dir", "=", "ann_dir", "\n", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "CLASSES", "=", "[", "\"__background__\"", "]", "\n", "self", ".", "CLASSES", "+=", "[", "l", ".", "name", "for", "l", "in", "csHelpers", ".", "labels", "if", "l", ".", "hasInstances", "]", "\n", "\n", "# Adds name_to_id and id_to_name mapping", "\n", "self", ".", "initMaps", "(", ")", "\n", "\n", "# This is required for parsing binary masks", "\n", "self", ".", "cityscapesID_to_ind", "=", "{", "\n", "l", ".", "id", ":", "self", ".", "name_to_id", "[", "l", ".", "name", "]", "for", "l", "in", "csHelpers", ".", "labels", "if", "l", ".", "hasInstances", "\n", "}", "\n", "\n", "self", ".", "transforms", "=", "transforms", "\n", "self", ".", "min_area", "=", "int", "(", "min_area", ")", "\n", "\n", "img_pattern", "=", "os", ".", "path", ".", "join", "(", "img_dir", ",", "\"*\"", ",", "\"*_leftImg8bit.png\"", ")", "\n", "img_paths", "=", "sorted", "(", "glob", ".", "glob", "(", "img_pattern", ")", ")", "\n", "\n", "if", "mode", "==", "\"mask\"", ":", "\n", "            ", "ann_pattern", "=", "os", ".", "path", ".", "join", "(", "ann_dir", ",", "\"*\"", ",", "\"*_instanceIds.png\"", ")", "\n", "", "elif", "mode", "==", "\"poly\"", ":", "\n", "            ", "ann_pattern", "=", "os", ".", "path", ".", "join", "(", "ann_dir", ",", "\"*\"", ",", "\"*_polygons.json\"", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Mode is not implemented yet: %s\"", "%", "mode", ")", "\n", "\n", "", "self", ".", "mode", "=", "mode", "\n", "ann_paths", "=", "sorted", "(", "glob", ".", "glob", "(", "ann_pattern", ")", ")", "\n", "\n", "if", "mini", "is", "not", "None", ":", "\n", "# Keep the mini dataset diverse by setting the stride", "\n", "            ", "img_paths", "=", "img_paths", "[", ":", ":", "len", "(", "img_paths", ")", "//", "mini", "+", "1", "]", "\n", "ann_paths", "=", "ann_paths", "[", ":", ":", "len", "(", "ann_paths", ")", "//", "mini", "+", "1", "]", "\n", "\n", "", "assert", "len", "(", "img_paths", ")", "==", "len", "(", "ann_paths", ")", "\n", "\n", "self", ".", "img_paths", "=", "img_paths", "\n", "self", ".", "ann_paths", "=", "ann_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset.__getitem__": [[89, 125], ["cityscapes.CityScapesDataset._filterGT", "PIL.Image.open", "vc_rcnn.structures.bounding_box.BoxList", "vc_rcnn.structures.bounding_box.BoxList.add_field", "vc_rcnn.structures.segmentation_mask.SegmentationMask", "vc_rcnn.structures.bounding_box.BoxList.add_field", "torch.from_numpy", "cityscapes.CityScapesDataset._processBinayMasks", "cityscapes.CityScapesDataset._processPolygons", "len", "print", "torch.tensor", "cityscapes.CityScapesDataset.transforms", "numpy.asarray", "open", "json.load", "cityscapes.CityScapesDataset.get_img_info", "PIL.Image.open", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset._filterGT", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset._processBinayMasks", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset._processPolygons", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img_path", "=", "self", ".", "img_paths", "[", "idx", "]", "\n", "ann_path", "=", "self", ".", "ann_paths", "[", "idx", "]", "\n", "\n", "if", "self", ".", "mode", "==", "\"mask\"", ":", "\n", "            ", "ann", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "Image", ".", "open", "(", "ann_path", ")", ")", ")", "\n", "# masks are represented with tensors", "\n", "boxes", ",", "segmentations", ",", "labels", "=", "self", ".", "_processBinayMasks", "(", "ann", ")", "\n", "", "else", ":", "\n", "            ", "with", "open", "(", "ann_path", ",", "\"r\"", ")", "as", "ann_file", ":", "\n", "                ", "ann", "=", "json", ".", "load", "(", "ann_file", ")", "\n", "# masks are represented with polygons", "\n", "", "boxes", ",", "segmentations", ",", "labels", "=", "self", ".", "_processPolygons", "(", "ann", ")", "\n", "\n", "", "boxes", ",", "segmentations", ",", "labels", "=", "self", ".", "_filterGT", "(", "boxes", ",", "segmentations", ",", "labels", ")", "\n", "\n", "if", "len", "(", "segmentations", ")", "==", "0", ":", "\n", "            ", "empty_ann_path", "=", "self", ".", "get_img_info", "(", "idx", ")", "[", "\"ann_path\"", "]", "\n", "print", "(", "\"EMPTY ENTRY:\"", ",", "empty_ann_path", ")", "\n", "# self.img_paths.pop(idx)", "\n", "# self.ann_paths.pop(idx)", "\n", "img", ",", "target", ",", "_", "=", "self", "[", "(", "idx", "+", "1", ")", "%", "len", "(", "self", ")", "]", "\n", "\n", "# just override this image with the next", "\n", "return", "img", ",", "target", ",", "idx", "\n", "\n", "", "img", "=", "Image", ".", "open", "(", "img_path", ")", "\n", "# Compose all into a BoxList instance", "\n", "target", "=", "BoxList", "(", "boxes", ",", "img", ".", "size", ",", "mode", "=", "\"xyxy\"", ")", "\n", "target", ".", "add_field", "(", "\"labels\"", ",", "torch", ".", "tensor", "(", "labels", ")", ")", "\n", "masks", "=", "SegmentationMask", "(", "segmentations", ",", "img", ".", "size", ",", "mode", "=", "self", ".", "mode", ")", "\n", "target", ".", "add_field", "(", "\"masks\"", ",", "masks", ")", "\n", "if", "self", ".", "transforms", "is", "not", "None", ":", "\n", "            ", "img", ",", "target", "=", "self", ".", "transforms", "(", "img", ",", "target", ")", "\n", "\n", "", "return", "img", ",", "target", ",", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset._filterGT": [[126, 146], ["zip", "len", "len", "len", "torch.empty.append", "filtered_segmentations.append", "filtered_labels.append", "len", "torch.empty"], "methods", ["None"], ["", "def", "_filterGT", "(", "self", ",", "boxes", ",", "segmentations", ",", "labels", ")", ":", "\n", "        ", "filtered_boxes", "=", "[", "]", "\n", "filtered_segmentations", "=", "[", "]", "\n", "filtered_labels", "=", "[", "]", "\n", "assert", "len", "(", "segmentations", ")", "==", "len", "(", "labels", ")", "==", "len", "(", "boxes", ")", "\n", "\n", "for", "box", ",", "segmentation", ",", "label", "in", "zip", "(", "boxes", ",", "segmentations", ",", "labels", ")", ":", "\n", "            ", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "box", "\n", "area", "=", "(", "xmax", "-", "xmin", ")", "*", "(", "ymax", "-", "ymin", ")", "\n", "if", "area", "<", "self", ".", "min_area", ":", "\n", "                ", "continue", "\n", "\n", "", "filtered_boxes", ".", "append", "(", "box", ")", "\n", "filtered_segmentations", ".", "append", "(", "segmentation", ")", "\n", "filtered_labels", ".", "append", "(", "label", ")", "\n", "\n", "", "if", "len", "(", "filtered_boxes", ")", "<", "1", ":", "\n", "            ", "filtered_boxes", "=", "torch", ".", "empty", "(", "0", ",", "4", ")", "\n", "\n", "", "return", "filtered_boxes", ",", "filtered_segmentations", ",", "filtered_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset._processPolygons": [[147, 190], ["int", "int", "int", "int", "cityscapes.CityScapesDataset._processPolygons.poly_to_tight_box"], "methods", ["None"], ["", "def", "_processPolygons", "(", "self", ",", "ann", ")", ":", "\n", "# For a single object polygon annotations are stored in CityScapes like", "\n", "# [[x1, y1], [x2, y2]...] and we need them in the following format:", "\n", "# [x1, y1, x2, y2, x3, y3 ...]", "\n", "        ", "polys", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "boxes", "=", "[", "]", "\n", "\n", "def", "poly_to_tight_box", "(", "poly", ")", ":", "\n", "            ", "xmin", "=", "int", "(", "min", "(", "poly", "[", ":", ":", "2", "]", ")", ")", "\n", "ymin", "=", "int", "(", "min", "(", "poly", "[", "1", ":", ":", "2", "]", ")", ")", "\n", "xmax", "=", "int", "(", "max", "(", "poly", "[", ":", ":", "2", "]", ")", ")", "\n", "ymax", "=", "int", "(", "max", "(", "poly", "[", "1", ":", ":", "2", "]", ")", ")", "\n", "bbox", "=", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "\n", "return", "bbox", "\n", "\n", "", "for", "inst", "in", "ann", "[", "\"objects\"", "]", ":", "\n", "            ", "label", "=", "inst", "[", "\"label\"", "]", "\n", "if", "label", "not", "in", "self", ".", "CLASSES", ":", "\n", "                ", "continue", "\n", "\n", "", "label", "=", "self", ".", "name_to_id", "[", "label", "]", "\n", "\n", "cityscapes_poly", "=", "inst", "[", "\"polygon\"", "]", "\n", "poly", "=", "[", "]", "\n", "for", "xy", "in", "cityscapes_poly", ":", "\n", "# Equivalent with `poly += xy` but this is more verbose", "\n", "                ", "x", "=", "xy", "[", "0", "]", "\n", "y", "=", "xy", "[", "1", "]", "\n", "poly", ".", "append", "(", "x", ")", "\n", "poly", ".", "append", "(", "y", ")", "\n", "\n", "# In CityScapes instances are described with single polygons only", "\n", "", "box", "=", "poly_to_tight_box", "(", "poly", ")", "\n", "\n", "boxes", ".", "append", "(", "box", ")", "\n", "polys", ".", "append", "(", "[", "poly", "]", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "\n", "", "if", "len", "(", "boxes", ")", "<", "1", ":", "\n", "            ", "boxes", "=", "torch", ".", "empty", "(", "0", ",", "4", ")", "\n", "\n", "", "return", "boxes", ",", "polys", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset._processBinayMasks": [[191, 223], ["mask.nonzero", "list", "torch.sort", "int", "cityscapes.CityScapesDataset._processBinayMasks.mask_to_tight_box"], "methods", ["None"], ["", "def", "_processBinayMasks", "(", "self", ",", "ann", ")", ":", "\n", "        ", "boxes", "=", "[", "]", "\n", "masks", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "\n", "def", "mask_to_tight_box", "(", "mask", ")", ":", "\n", "            ", "a", "=", "mask", ".", "nonzero", "(", ")", "\n", "bbox", "=", "[", "\n", "torch", ".", "min", "(", "a", "[", ":", ",", "1", "]", ")", ",", "\n", "torch", ".", "min", "(", "a", "[", ":", ",", "0", "]", ")", ",", "\n", "torch", ".", "max", "(", "a", "[", ":", ",", "1", "]", ")", ",", "\n", "torch", ".", "max", "(", "a", "[", ":", ",", "0", "]", ")", ",", "\n", "]", "\n", "bbox", "=", "list", "(", "map", "(", "int", ",", "bbox", ")", ")", "\n", "return", "bbox", "# xmin, ymin, xmax, ymax", "\n", "\n", "# Sort for consistent order between instances as the polygon annotation", "\n", "", "instIds", "=", "torch", ".", "sort", "(", "torch", ".", "unique", "(", "ann", ")", ")", "[", "0", "]", "\n", "for", "instId", "in", "instIds", ":", "\n", "            ", "if", "instId", "<", "1000", ":", "# group labels", "\n", "                ", "continue", "\n", "\n", "", "mask", "=", "ann", "==", "instId", "\n", "label", "=", "int", "(", "instId", "/", "1000", ")", "\n", "label", "=", "self", ".", "cityscapesID_to_ind", "[", "label", "]", "\n", "box", "=", "mask_to_tight_box", "(", "mask", ")", "\n", "\n", "boxes", ".", "append", "(", "box", ")", "\n", "masks", ".", "append", "(", "mask", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "\n", "", "return", "boxes", ",", "masks", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset.__len__": [[224, 226], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "img_paths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.cityscapes.CityScapesDataset.get_img_info": [[227, 236], ["None"], "methods", ["None"], ["", "def", "get_img_info", "(", "self", ",", "index", ")", ":", "\n", "# Reverse engineered from voc.py", "\n", "# All the images have the same size", "\n", "        ", "return", "{", "\n", "\"height\"", ":", "1024", ",", "\n", "\"width\"", ":", "2048", ",", "\n", "\"idx\"", ":", "index", ",", "\n", "\"img_path\"", ":", "self", ".", "img_paths", "[", "index", "]", ",", "\n", "\"ann_path\"", ":", "self", ".", "ann_paths", "[", "index", "]", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.abstract.AbstractDataset.__init__": [[30, 33], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "name_to_id", "=", "None", "\n", "self", ".", "id_to_name", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.abstract.AbstractDataset.__getitem__": [[35, 37], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.abstract.AbstractDataset.initMaps": [[39, 61], ["isinstance", "dict", "dict", "zip", "zip", "range", "range", "len", "len"], "methods", ["None"], ["", "def", "initMaps", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Can be called optionally to initialize the id<->category name mapping\n\n\n        Initialize default mapping between:\n            class <==> index\n        class: this is a string that represents the class\n        index: positive int, used directly by the ROI heads.\n\n\n        NOTE:\n            make sure that the background is always indexed by 0.\n            \"__background__\" <==> 0\n\n            if initialized by hand, double check that the indexing is correct.\n        \"\"\"", "\n", "assert", "isinstance", "(", "self", ".", "CLASSES", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "self", ".", "CLASSES", "[", "0", "]", "==", "\"__background__\"", "\n", "cls", "=", "self", ".", "CLASSES", "\n", "self", ".", "name_to_id", "=", "dict", "(", "zip", "(", "cls", ",", "range", "(", "len", "(", "cls", ")", ")", ")", ")", "\n", "self", ".", "id_to_name", "=", "dict", "(", "zip", "(", "range", "(", "len", "(", "cls", ")", ")", ",", "cls", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.abstract.AbstractDataset.get_img_info": [[63, 65], ["None"], "methods", ["None"], ["", "def", "get_img_info", "(", "self", ",", "index", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.abstract.AbstractDataset.__len__": [[67, 69], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.list_dataset.ListDataset.__init__": [[12, 15], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "image_lists", ",", "transforms", "=", "None", ")", ":", "\n", "        ", "self", ".", "image_lists", "=", "image_lists", "\n", "self", ".", "transforms", "=", "transforms", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.list_dataset.ListDataset.__getitem__": [[16, 27], ["PIL.Image.open().convert", "vc_rcnn.structures.bounding_box.BoxList", "list_dataset.ListDataset.transforms", "PIL.Image.open"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "img", "=", "Image", ".", "open", "(", "self", ".", "image_lists", "[", "item", "]", ")", ".", "convert", "(", "\"RGB\"", ")", "\n", "\n", "# dummy target", "\n", "w", ",", "h", "=", "img", ".", "size", "\n", "target", "=", "BoxList", "(", "[", "[", "0", ",", "0", ",", "w", ",", "h", "]", "]", ",", "img", ".", "size", ",", "mode", "=", "\"xyxy\"", ")", "\n", "\n", "if", "self", ".", "transforms", "is", "not", "None", ":", "\n", "            ", "img", ",", "target", "=", "self", ".", "transforms", "(", "img", ",", "target", ")", "\n", "\n", "", "return", "img", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.list_dataset.ListDataset.__len__": [[28, 30], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "image_lists", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.list_dataset.ListDataset.get_img_info": [[31, 37], ["None"], "methods", ["None"], ["", "def", "get_img_info", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"\n        Return the image dimensions for the image, without\n        loading and pre-processing it\n        \"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.openimages.OpenDataset.__init__": [[42, 58], ["json.load", "json.load", "json.load", "json.load", "open", "open", "open", "os.path.basename", "open"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["    ", "def", "__init__", "(", "self", ",", "datadir", ",", "ann_path", ",", "causal_path", ",", "transforms", "=", "None", ")", ":", "\n", "\n", "        ", "self", ".", "img_root", "=", "datadir", "\n", "self", ".", "transforms", "=", "transforms", "\n", "\n", "\n", "self", ".", "img_info", "=", "json", ".", "load", "(", "open", "(", "'/gruntdata3/wangtan/openimage/annotations/instances_tran2017_image.json'", ",", "'r'", ")", ")", "\n", "# self.anno_info = [anno for anno in im_data['annotations']]", "\n", "self", ".", "anno_box", "=", "json", ".", "load", "(", "open", "(", "'/gruntdata3/wangtan/openimage/annotations/instances_train2017_box.json'", ",", "'r'", ")", ")", "\n", "self", ".", "anno_cat", "=", "json", ".", "load", "(", "open", "(", "'/gruntdata3/wangtan/openimage/annotations/instances_train2017_cat.json'", ",", "'r'", ")", ")", "\n", "self", ".", "filenames", "=", "[", "os", ".", "path", ".", "basename", "(", "image", "[", "'file_name'", "]", ")", "for", "image", "in", "self", ".", "img_info", "]", "\n", "self", ".", "id2cat", "=", "json", ".", "load", "(", "open", "(", "'/gruntdata3/wangtan/openimage/annotations/instances_train2017_catlist.json'", ",", "'r'", ")", ")", "\n", "self", ".", "categories", "=", "{", "cat", "[", "'id'", "]", ":", "cat", "[", "'name'", "]", "for", "cat", "in", "self", ".", "id2cat", "}", "\n", "# self.ann_file = [ann for ann in im_data['annotations']]", "\n", "\n", "self", ".", "_transforms", "=", "transforms", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.openimages.OpenDataset.__getitem__": [[60, 94], ["os.path.join", "PIL.Image.open().convert", "torch.as_tensor().reshape", "vc_rcnn.structures.bounding_box.BoxList", "target.clip_to_image.clip_to_image.add_field", "torch.tensor", "target.clip_to_image.clip_to_image.add_field", "torch.tensor", "target.clip_to_image.clip_to_image.add_field", "target.clip_to_image.clip_to_image.clip_to_image", "torch.tensor", "openimages.OpenDataset.transforms", "PIL.Image.open", "str", "torch.as_tensor", "str", "print", "range", "range", "torch.as_tensor().reshape.size", "torch.as_tensor().reshape.size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.clip_to_image", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "\n", "        ", "img_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "img_root", ",", "self", ".", "filenames", "[", "idx", "]", ")", "\n", "img", "=", "Image", ".", "open", "(", "img_path", ")", ".", "convert", "(", "\"RGB\"", ")", "\n", "\n", "boxes", "=", "self", ".", "anno_box", "[", "str", "(", "idx", ")", "]", "\n", "boxes", "=", "torch", ".", "as_tensor", "(", "boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "# guard against no boxes", "\n", "target", "=", "BoxList", "(", "boxes", ",", "img", ".", "size", ",", "mode", "=", "\"xyxy\"", ")", "\n", "\n", "classes", "=", "self", ".", "anno_cat", "[", "str", "(", "idx", ")", "]", "\n", "# classes = [self.json_category_id_to_contiguous_id[c] for c in classes]", "\n", "classes", "=", "torch", ".", "tensor", "(", "classes", ")", "-", "1", "\n", "target", ".", "add_field", "(", "\"labels\"", ",", "classes", ")", "\n", "\n", "try", ":", "\n", "            ", "assert", "img", ".", "size", "[", "1", "]", "==", "self", ".", "img_info", "[", "idx", "]", "[", "'height'", "]", "and", "img", ".", "size", "[", "0", "]", "==", "self", ".", "img_info", "[", "idx", "]", "[", "'width'", "]", "\n", "", "except", "AssertionError", ":", "\n", "            ", "print", "(", "self", ".", "filenames", "[", "idx", "]", ")", "\n", "\n", "", "w", ",", "h", "=", "img", ".", "size", "[", "0", "]", ",", "img", ".", "size", "[", "1", "]", "\n", "sizes", "=", "[", "[", "w", ",", "h", "]", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "sizes", "=", "torch", ".", "tensor", "(", "sizes", ")", "\n", "target", ".", "add_field", "(", "\"orignal_size\"", ",", "sizes", ")", "\n", "\n", "idxx", "=", "[", "idx", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "idxx", "=", "torch", ".", "tensor", "(", "idxx", ")", "\n", "target", ".", "add_field", "(", "\"idx\"", ",", "idxx", ")", "\n", "\n", "target", "=", "target", ".", "clip_to_image", "(", "remove_empty", "=", "True", ")", "\n", "\n", "if", "self", ".", "transforms", "is", "not", "None", ":", "\n", "            ", "img", ",", "target", "=", "self", ".", "transforms", "(", "img", ",", "target", ")", "\n", "\n", "", "return", "img", ",", "target", ",", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.openimages.OpenDataset.__len__": [[96, 98], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "filenames", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.openimages.OpenDataset.get_img_info": [[100, 103], ["None"], "methods", ["None"], ["", "def", "get_img_info", "(", "self", ",", "index", ")", ":", "\n", "\n", "        ", "return", "self", ".", "img_info", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.openimages.OpenDataset.get_img_ann": [[105, 112], ["image_ann.append"], "methods", ["None"], ["", "def", "get_img_ann", "(", "self", ",", "index", ")", ":", "\n", "# find the annotations for a given image", "\n", "        ", "image_ann", "=", "[", "]", "\n", "for", "ann", "in", "self", ".", "ann_file", ":", "\n", "            ", "if", "ann", "[", "'image_id'", "]", "==", "index", ":", "\n", "                ", "image_ann", ".", "append", "(", "ann", ")", "\n", "", "", "return", "image_ann", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.openimages._count_visible_keypoints": [[14, 16], ["sum", "sum"], "function", ["None"], ["def", "_count_visible_keypoints", "(", "anno", ")", ":", "\n", "    ", "return", "sum", "(", "sum", "(", "1", "for", "v", "in", "ann", "[", "\"keypoints\"", "]", "[", "2", ":", ":", "3", "]", "if", "v", ">", "0", ")", "for", "ann", "in", "anno", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.openimages._has_only_empty_bbox": [[18, 20], ["all", "any"], "function", ["None"], ["", "def", "_has_only_empty_bbox", "(", "anno", ")", ":", "\n", "    ", "return", "all", "(", "any", "(", "o", "<=", "1", "for", "o", "in", "obj", "[", "\"bbox\"", "]", "[", "2", ":", "]", ")", "for", "obj", "in", "anno", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.openimages.has_valid_annotation": [[22, 38], ["openimages._has_only_empty_bbox", "len", "openimages._count_visible_keypoints"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr._has_only_empty_bbox", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr._count_visible_keypoints"], ["", "def", "has_valid_annotation", "(", "anno", ")", ":", "\n", "# if it's empty, there is no annotation", "\n", "    ", "if", "len", "(", "anno", ")", "==", "0", ":", "\n", "        ", "return", "False", "\n", "# if all boxes have close to zero area, there is no annotation", "\n", "", "if", "_has_only_empty_bbox", "(", "anno", ")", ":", "\n", "        ", "return", "False", "\n", "# keypoints task have a slight different critera for considering", "\n", "# if an annotation is valid", "\n", "", "if", "\"keypoints\"", "not", "in", "anno", "[", "0", "]", ":", "\n", "        ", "return", "True", "\n", "# for keypoint detection tasks, only consider valid images those", "\n", "# containing at least min_keypoints_per_image", "\n", "", "if", "_count_visible_keypoints", "(", "anno", ")", ">=", "min_keypoints_per_image", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.concat_dataset.ConcatDataset.get_idxs": [[13, 20], ["bisect.bisect_right"], "methods", ["None"], ["def", "get_idxs", "(", "self", ",", "idx", ")", ":", "\n", "        ", "dataset_idx", "=", "bisect", ".", "bisect_right", "(", "self", ".", "cumulative_sizes", ",", "idx", ")", "\n", "if", "dataset_idx", "==", "0", ":", "\n", "            ", "sample_idx", "=", "idx", "\n", "", "else", ":", "\n", "            ", "sample_idx", "=", "idx", "-", "self", ".", "cumulative_sizes", "[", "dataset_idx", "-", "1", "]", "\n", "", "return", "dataset_idx", ",", "sample_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.concat_dataset.ConcatDataset.get_img_info": [[21, 24], ["concat_dataset.ConcatDataset.get_idxs", "concat_dataset.ConcatDataset.datasets[].get_img_info"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.concat_dataset.ConcatDataset.get_idxs", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info"], ["", "def", "get_img_info", "(", "self", ",", "idx", ")", ":", "\n", "        ", "dataset_idx", ",", "sample_idx", "=", "self", ".", "get_idxs", "(", "idx", ")", "\n", "return", "self", ".", "datasets", "[", "dataset_idx", "]", ".", "get_img_info", "(", "sample_idx", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr.vcrDataset.__init__": [[44, 68], ["lmdb.open", "vcr.vcrDataset.env.begin", "pickle.loads", "txn.get", "vcr.vcrDataset.img_info.append", "pickle.loads", "pickle.loads", "pickle.loads", "txn.get", "txn.get", "txn.get"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["    ", "def", "__init__", "(", "self", ",", "datadir", ",", "ann_file", ",", "transforms", "=", "None", ")", ":", "\n", "\n", "        ", "self", ".", "img_root", "=", "datadir", "\n", "self", ".", "transforms", "=", "transforms", "\n", "#self.image_pth = '/data3/wangtan/openimage/target_dir/coco_debug/images/train2017'", "\n", "\n", "\n", "\n", "# self.id_to_img_map = {k: v for k, v in enumerate(self.ids)}", "\n", "self", ".", "_transforms", "=", "transforms", "\n", "\n", "features_path", "=", "'/data3/wangtan/vc/vilbert_beta/data/VCR/VCR_gt_resnet101_faster_rcnn_genome.lmdb'", "\n", "self", ".", "env", "=", "lmdb", ".", "open", "(", "features_path", ",", "max_readers", "=", "1", ",", "readonly", "=", "True", ",", "\n", "lock", "=", "False", ",", "readahead", "=", "False", ",", "meminit", "=", "False", ")", "\n", "\n", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "self", ".", "_image_ids", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "'keys'", ".", "encode", "(", ")", ")", ")", "\n", "self", ".", "img_info", "=", "[", "]", "\n", "for", "i", "in", "self", ".", "_image_ids", ":", "\n", "# a = pickle.loads(txn.get(i))", "\n", "                ", "h", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "i", ")", ")", "[", "'image_h'", "]", "\n", "w", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "i", ")", ")", "[", "'image_w'", "]", "\n", "path", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "i", ")", ")", "[", "'image_id'", "]", "\n", "self", ".", "img_info", ".", "append", "(", "{", "\"width\"", ":", "w", ",", "\"height\"", ":", "h", ",", "\"path\"", ":", "path", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr.vcrDataset.__getitem__": [[71, 114], ["os.path.join", "PIL.Image.open().convert", "torch.as_tensor().reshape", "vc_rcnn.structures.bounding_box.BoxList", "torch.tensor", "target.clip_to_image.clip_to_image.add_field", "torch.tensor", "target.clip_to_image.clip_to_image.add_field", "torch.tensor", "target.clip_to_image.clip_to_image.add_field", "target.clip_to_image.clip_to_image.clip_to_image", "vcr.vcrDataset.env.begin", "pickle.loads", "int", "int", "int", "numpy.frombuffer().reshape", "int", "vcr.vcrDataset.transforms", "PIL.Image.open", "txn.get", "torch.as_tensor", "print", "range", "range", "range", "numpy.frombuffer", "numpy.frombuffer().reshape.size", "numpy.frombuffer().reshape.size", "numpy.frombuffer().reshape.size", "base64.b64decode"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.clip_to_image", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["", "", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "\n", "        ", "image_id", "=", "self", ".", "_image_ids", "[", "idx", "]", "\n", "img_name", "=", "self", ".", "img_info", "[", "idx", "]", "[", "'path'", "]", "\n", "img_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "img_root", ",", "img_name", ")", "\n", "img", "=", "Image", ".", "open", "(", "img_path", ")", ".", "convert", "(", "\"RGB\"", ")", "\n", "\n", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "item", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "image_id", ")", ")", "\n", "image_id_", "=", "item", "[", "'image_id'", "]", "\n", "image_h", "=", "int", "(", "item", "[", "'image_h'", "]", ")", "\n", "image_w", "=", "int", "(", "item", "[", "'image_w'", "]", ")", "\n", "num_boxes", "=", "int", "(", "item", "[", "'num_boxes'", "]", ")", "\n", "boxes", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "'boxes'", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "4", ")", "\n", "\n", "\n", "", "boxes", "=", "torch", ".", "as_tensor", "(", "boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "# guard against no boxes", "\n", "target", "=", "BoxList", "(", "boxes", ",", "img", ".", "size", ",", "mode", "=", "\"xyxy\"", ")", "\n", "\n", "try", ":", "\n", "            ", "assert", "img", ".", "size", "[", "1", "]", "==", "image_h", "and", "img", ".", "size", "[", "0", "]", "==", "image_w", "\n", "", "except", "AssertionError", ":", "\n", "            ", "print", "(", "image_id", ")", "\n", "\n", "", "w", ",", "h", "=", "img", ".", "size", "[", "0", "]", ",", "img", ".", "size", "[", "1", "]", "\n", "sizes", "=", "[", "[", "w", ",", "h", "]", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "sizes", "=", "torch", ".", "tensor", "(", "sizes", ")", "\n", "target", ".", "add_field", "(", "\"orignal_size\"", ",", "sizes", ")", "\n", "\n", "image_id_all", "=", "[", "int", "(", "image_id", ")", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "image_id_all", "=", "torch", ".", "tensor", "(", "image_id_all", ")", "\n", "target", ".", "add_field", "(", "\"image_id\"", ",", "image_id_all", ")", "\n", "\n", "numm", "=", "[", "num_boxes", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "numm", "=", "torch", ".", "tensor", "(", "numm", ")", "\n", "target", ".", "add_field", "(", "\"num_box\"", ",", "numm", ")", "\n", "\n", "target", "=", "target", ".", "clip_to_image", "(", "remove_empty", "=", "False", ")", "\n", "\n", "if", "self", ".", "transforms", "is", "not", "None", ":", "\n", "            ", "img", ",", "target", "=", "self", ".", "transforms", "(", "img", ",", "target", ")", "\n", "\n", "", "return", "img", ",", "target", ",", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr.vcrDataset.__len__": [[116, 118], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_image_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr.vcrDataset.get_img_info": [[120, 123], ["None"], "methods", ["None"], ["", "def", "get_img_info", "(", "self", ",", "index", ")", ":", "\n", "\n", "        ", "return", "self", ".", "img_info", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr.vcrDataset.get_img_ann": [[125, 132], ["image_ann.append"], "methods", ["None"], ["", "def", "get_img_ann", "(", "self", ",", "index", ")", ":", "\n", "# find the annotations for a given image", "\n", "        ", "image_ann", "=", "[", "]", "\n", "for", "ann", "in", "self", ".", "ann_file", ":", "\n", "            ", "if", "ann", "[", "'image_id'", "]", "==", "index", ":", "\n", "                ", "image_ann", ".", "append", "(", "ann", ")", "\n", "", "", "return", "image_ann", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr._count_visible_keypoints": [[16, 18], ["sum", "sum"], "function", ["None"], ["def", "_count_visible_keypoints", "(", "anno", ")", ":", "\n", "    ", "return", "sum", "(", "sum", "(", "1", "for", "v", "in", "ann", "[", "\"keypoints\"", "]", "[", "2", ":", ":", "3", "]", "if", "v", ">", "0", ")", "for", "ann", "in", "anno", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr._has_only_empty_bbox": [[20, 22], ["all", "any"], "function", ["None"], ["", "def", "_has_only_empty_bbox", "(", "anno", ")", ":", "\n", "    ", "return", "all", "(", "any", "(", "o", "<=", "1", "for", "o", "in", "obj", "[", "\"bbox\"", "]", "[", "2", ":", "]", ")", "for", "obj", "in", "anno", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr.has_valid_annotation": [[24, 40], ["vcr._has_only_empty_bbox", "len", "vcr._count_visible_keypoints"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr._has_only_empty_bbox", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.vcr._count_visible_keypoints"], ["", "def", "has_valid_annotation", "(", "anno", ")", ":", "\n", "# if it's empty, there is no annotation", "\n", "    ", "if", "len", "(", "anno", ")", "==", "0", ":", "\n", "        ", "return", "False", "\n", "# if all boxes have close to zero area, there is no annotation", "\n", "", "if", "_has_only_empty_bbox", "(", "anno", ")", ":", "\n", "        ", "return", "False", "\n", "# keypoints task have a slight different critera for considering", "\n", "# if an annotation is valid", "\n", "", "if", "\"keypoints\"", "not", "in", "anno", "[", "0", "]", ":", "\n", "        ", "return", "True", "\n", "# for keypoint detection tasks, only consider valid images those", "\n", "# containing at least min_keypoints_per_image", "\n", "", "if", "_count_visible_keypoints", "(", "anno", ")", ">=", "min_keypoints_per_image", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.__init__": [[43, 61], ["os.path.join", "os.path.join", "os.path.join", "dict", "dict", "open", "f.readlines", "x.strip", "zip", "zip", "enumerate", "range", "range", "len", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data_dir", ",", "split", ",", "use_difficult", "=", "False", ",", "transforms", "=", "None", ")", ":", "\n", "        ", "self", ".", "root", "=", "data_dir", "\n", "self", ".", "image_set", "=", "split", "\n", "self", ".", "keep_difficult", "=", "use_difficult", "\n", "self", ".", "transforms", "=", "transforms", "\n", "\n", "self", ".", "_annopath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "\"Annotations\"", ",", "\"%s.xml\"", ")", "\n", "self", ".", "_imgpath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "\"JPEGImages\"", ",", "\"%s.jpg\"", ")", "\n", "self", ".", "_imgsetpath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "\"ImageSets\"", ",", "\"Main\"", ",", "\"%s.txt\"", ")", "\n", "\n", "with", "open", "(", "self", ".", "_imgsetpath", "%", "self", ".", "image_set", ")", "as", "f", ":", "\n", "            ", "self", ".", "ids", "=", "f", ".", "readlines", "(", ")", "\n", "", "self", ".", "ids", "=", "[", "x", ".", "strip", "(", "\"\\n\"", ")", "for", "x", "in", "self", ".", "ids", "]", "\n", "self", ".", "id_to_img_map", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "enumerate", "(", "self", ".", "ids", ")", "}", "\n", "\n", "cls", "=", "PascalVOCDataset", ".", "CLASSES", "\n", "self", ".", "class_to_ind", "=", "dict", "(", "zip", "(", "cls", ",", "range", "(", "len", "(", "cls", ")", ")", ")", ")", "\n", "self", ".", "categories", "=", "dict", "(", "zip", "(", "range", "(", "len", "(", "cls", ")", ")", ",", "cls", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.__getitem__": [[62, 73], ["PIL.Image.open().convert", "voc.PascalVOCDataset.get_groundtruth", "target.clip_to_image.clip_to_image.clip_to_image", "voc.PascalVOCDataset.transforms", "PIL.Image.open"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_groundtruth", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.clip_to_image"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "img", "=", "Image", ".", "open", "(", "self", ".", "_imgpath", "%", "img_id", ")", ".", "convert", "(", "\"RGB\"", ")", "\n", "\n", "target", "=", "self", ".", "get_groundtruth", "(", "index", ")", "\n", "target", "=", "target", ".", "clip_to_image", "(", "remove_empty", "=", "True", ")", "\n", "\n", "if", "self", ".", "transforms", "is", "not", "None", ":", "\n", "            ", "img", ",", "target", "=", "self", ".", "transforms", "(", "img", ",", "target", ")", "\n", "\n", "", "return", "img", ",", "target", ",", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.__len__": [[74, 76], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_groundtruth": [[77, 87], ["ET.parse().getroot", "voc.PascalVOCDataset._preprocess_annotation", "vc_rcnn.structures.bounding_box.BoxList", "vc_rcnn.structures.bounding_box.BoxList.add_field", "vc_rcnn.structures.bounding_box.BoxList.add_field", "ET.parse"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset._preprocess_annotation", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.add_field"], ["", "def", "get_groundtruth", "(", "self", ",", "index", ")", ":", "\n", "        ", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "anno", "=", "ET", ".", "parse", "(", "self", ".", "_annopath", "%", "img_id", ")", ".", "getroot", "(", ")", "\n", "anno", "=", "self", ".", "_preprocess_annotation", "(", "anno", ")", "\n", "\n", "height", ",", "width", "=", "anno", "[", "\"im_info\"", "]", "\n", "target", "=", "BoxList", "(", "anno", "[", "\"boxes\"", "]", ",", "(", "width", ",", "height", ")", ",", "mode", "=", "\"xyxy\"", ")", "\n", "target", ".", "add_field", "(", "\"labels\"", ",", "anno", "[", "\"labels\"", "]", ")", "\n", "target", ".", "add_field", "(", "\"difficult\"", ",", "anno", "[", "\"difficult\"", "]", ")", "\n", "return", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset._preprocess_annotation": [[88, 126], ["target.iter", "target.find", "tuple", "obj.find().text.lower().strip", "obj.find", "tuple", "boxes.append", "gt_classes.append", "difficult_boxes.append", "map", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "int", "map", "obj.find().text.lower", "obj.find.find", "obj.find.find", "obj.find.find", "obj.find.find", "list", "obj.find", "map", "target.find.find", "target.find.find", "obj.find"], "methods", ["None"], ["", "def", "_preprocess_annotation", "(", "self", ",", "target", ")", ":", "\n", "        ", "boxes", "=", "[", "]", "\n", "gt_classes", "=", "[", "]", "\n", "difficult_boxes", "=", "[", "]", "\n", "TO_REMOVE", "=", "1", "\n", "\n", "for", "obj", "in", "target", ".", "iter", "(", "\"object\"", ")", ":", "\n", "            ", "difficult", "=", "int", "(", "obj", ".", "find", "(", "\"difficult\"", ")", ".", "text", ")", "==", "1", "\n", "if", "not", "self", ".", "keep_difficult", "and", "difficult", ":", "\n", "                ", "continue", "\n", "", "name", "=", "obj", ".", "find", "(", "\"name\"", ")", ".", "text", ".", "lower", "(", ")", ".", "strip", "(", ")", "\n", "bb", "=", "obj", ".", "find", "(", "\"bndbox\"", ")", "\n", "# Make pixel indexes 0-based", "\n", "# Refer to \"https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/datasets/pascal_voc.py#L208-L211\"", "\n", "box", "=", "[", "\n", "bb", ".", "find", "(", "\"xmin\"", ")", ".", "text", ",", "\n", "bb", ".", "find", "(", "\"ymin\"", ")", ".", "text", ",", "\n", "bb", ".", "find", "(", "\"xmax\"", ")", ".", "text", ",", "\n", "bb", ".", "find", "(", "\"ymax\"", ")", ".", "text", ",", "\n", "]", "\n", "bndbox", "=", "tuple", "(", "\n", "map", "(", "lambda", "x", ":", "x", "-", "TO_REMOVE", ",", "list", "(", "map", "(", "int", ",", "box", ")", ")", ")", "\n", ")", "\n", "\n", "boxes", ".", "append", "(", "bndbox", ")", "\n", "gt_classes", ".", "append", "(", "self", ".", "class_to_ind", "[", "name", "]", ")", "\n", "difficult_boxes", ".", "append", "(", "difficult", ")", "\n", "\n", "", "size", "=", "target", ".", "find", "(", "\"size\"", ")", "\n", "im_info", "=", "tuple", "(", "map", "(", "int", ",", "(", "size", ".", "find", "(", "\"height\"", ")", ".", "text", ",", "size", ".", "find", "(", "\"width\"", ")", ".", "text", ")", ")", ")", "\n", "\n", "res", "=", "{", "\n", "\"boxes\"", ":", "torch", ".", "tensor", "(", "boxes", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "\"labels\"", ":", "torch", ".", "tensor", "(", "gt_classes", ")", ",", "\n", "\"difficult\"", ":", "torch", ".", "tensor", "(", "difficult_boxes", ")", ",", "\n", "\"im_info\"", ":", "im_info", ",", "\n", "}", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info": [[127, 133], ["ET.parse().getroot", "ET.parse().getroot.find", "tuple", "map", "ET.parse", "ET.parse().getroot.find.find", "ET.parse().getroot.find.find"], "methods", ["None"], ["", "def", "get_img_info", "(", "self", ",", "index", ")", ":", "\n", "        ", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "anno", "=", "ET", ".", "parse", "(", "self", ".", "_annopath", "%", "img_id", ")", ".", "getroot", "(", ")", "\n", "size", "=", "anno", ".", "find", "(", "\"size\"", ")", "\n", "im_info", "=", "tuple", "(", "map", "(", "int", ",", "(", "size", ".", "find", "(", "\"height\"", ")", ".", "text", ",", "size", ".", "find", "(", "\"width\"", ")", ".", "text", ")", ")", ")", "\n", "return", "{", "\"height\"", ":", "im_info", "[", "0", "]", ",", "\"width\"", ":", "im_info", "[", "1", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.map_class_id_to_class_name": [[134, 136], ["None"], "methods", ["None"], ["", "def", "map_class_id_to_class_name", "(", "self", ",", "class_id", ")", ":", "\n", "        ", "return", "PascalVOCDataset", ".", "CLASSES", "[", "class_id", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.evaluation.__init__.evaluate": [[7, 28], ["dict", "isinstance", "coco.coco_evaluation", "isinstance", "voc.voc_evaluation", "NotImplementedError"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.__init__.coco_evaluation", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.__init__.voc_evaluation"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.cityscapes_eval.do_cityscapes_evaluation": [[22, 104], ["logging.getLogger", "logging.getLogger.info", "copy.deepcopy", "os.path.join", "cityscapesscripts.helpers.csHelpers.ensurePath", "os.path.join", "os.path.join", "os.path.join", "list", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.matchGtsWithPreds", "cityscapesscripts.helpers.csHelpers.writeDict2JSON", "NotImplementedError", "logging.getLogger.info", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.evaluateBoxMatches", "logging.getLogger.info", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.computeAverages", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.prepareJSONDataForResults", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.printResults", "logging.getLogger.info", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.evaluateMaskMatches", "logging.getLogger.info", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.computeAverages", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.prepareJSONDataForResults", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.printResults", "os.path.dirname", "cityscapesscripts.helpers.csHelpers.ensurePath", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.writeDict2JSON", "os.path.dirname", "cityscapesscripts.helpers.csHelpers.ensurePath", "vc_rcnn.data.datasets.evaluation.cityscapes.eval_instances.writeDict2JSON"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.matchGtsWithPreds", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.evaluateBoxMatches", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.computeAverages", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.prepareJSONDataForResults", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.printResults", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.evaluateMaskMatches", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.computeAverages", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.prepareJSONDataForResults", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.printResults"], ["def", "do_cityscapes_evaluation", "(", "\n", "dataset", ",", "\n", "predictions", ",", "\n", "box_only", ",", "\n", "output_folder", ",", "\n", "iou_types", ",", "\n", "expected_results", ",", "\n", "expected_results_sigma_tol", ",", "\n", ")", ":", "\n", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "\"vc_rcnn.inference\"", ")", "\n", "logger", ".", "info", "(", "f\"CityScapes evaluation on [{dataset}]:\"", ")", "\n", "# Set default args for evaluation", "\n", "args", "=", "deepcopy", "(", "eval_instances", ".", "defaultArgs", ")", "\n", "\n", "# Set output folder", "\n", "output_folder", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "\"evaluationResults\"", ")", "\n", "ensurePath", "(", "output_folder", ")", "\n", "\n", "# Set custom fields", "\n", "args", ".", "exportMatchFile", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "\"matches.json\"", ")", "\n", "args", ".", "exportBoxFile", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "\"boxResult.json\"", ")", "\n", "args", ".", "exportMaskFile", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "\"maskResult.json\"", ")", "\n", "args", ".", "instLabels", "=", "list", "(", "dataset", ".", "CLASSES", ")", "\n", "\n", "logger", ".", "info", "(", "\"Evaluation arguments\"", ")", "\n", "logger", ".", "info", "(", "\"%s\"", "%", "args", ")", "\n", "logger", ".", "info", "(", "\"Matching GT instances with Predictions\"", ")", "\n", "if", "\"bbox\"", "in", "iou_types", "or", "\"segm\"", "in", "iou_types", ":", "\n", "# Match and compute IoU of mask and box in one iteration:", "\n", "        ", "matches", "=", "eval_instances", ".", "matchGtsWithPreds", "(", "dataset", ",", "predictions", ")", "\n", "writeDict2JSON", "(", "matches", ",", "args", ".", "exportMatchFile", ")", "\n", "", "else", ":", "\n", "        ", "NotImplementedError", "(", "f\"IoU type not implemented {iou_types}\"", ")", "\n", "\n", "# printing", "\n", "", "strResults", "=", "\"\"", "\n", "if", "\"bbox\"", "in", "iou_types", ":", "\n", "# evaluate matches", "\n", "        ", "logger", ".", "info", "(", "\"Evaluating BBox matches\"", ")", "\n", "boxApScores", "=", "eval_instances", ".", "evaluateBoxMatches", "(", "matches", ",", "args", ")", "\n", "\n", "# averages", "\n", "logger", ".", "info", "(", "\"Average Box scores\"", ")", "\n", "boxAvgDict", "=", "eval_instances", ".", "computeAverages", "(", "boxApScores", ",", "args", ")", "\n", "\n", "# logging", "\n", "boxResDict", "=", "eval_instances", ".", "prepareJSONDataForResults", "(", "\n", "boxAvgDict", ",", "boxApScores", ",", "args", "\n", ")", "\n", "if", "args", ".", "JSONOutput", ":", "\n", "# create output folder if necessary", "\n", "            ", "path", "=", "os", ".", "path", ".", "dirname", "(", "args", ".", "exportBoxFile", ")", "\n", "ensurePath", "(", "path", ")", "\n", "# Write APs to JSON", "\n", "eval_instances", ".", "writeDict2JSON", "(", "boxResDict", ",", "args", ".", "exportBoxFile", ")", "\n", "", "strBoxResults", "=", "eval_instances", ".", "printResults", "(", "boxAvgDict", ",", "args", ")", "\n", "strResults", "+=", "\"\\nBBox\\n\"", "+", "strBoxResults", "\n", "\n", "", "if", "\"segm\"", "in", "iou_types", ":", "\n", "# evaluate matches", "\n", "        ", "logger", ".", "info", "(", "\"Evaluating Mask matches\"", ")", "\n", "maskApScores", "=", "eval_instances", ".", "evaluateMaskMatches", "(", "matches", ",", "args", ")", "\n", "\n", "# averages", "\n", "logger", ".", "info", "(", "\"Average Mask scores\"", ")", "\n", "maskAvgDict", "=", "eval_instances", ".", "computeAverages", "(", "maskApScores", ",", "args", ")", "\n", "\n", "# logging", "\n", "maskResDict", "=", "eval_instances", ".", "prepareJSONDataForResults", "(", "\n", "maskAvgDict", ",", "maskApScores", ",", "args", "\n", ")", "\n", "if", "args", ".", "JSONOutput", ":", "\n", "# create output folder if necessary", "\n", "            ", "path", "=", "os", ".", "path", ".", "dirname", "(", "args", ".", "exportMaskFile", ")", "\n", "ensurePath", "(", "path", ")", "\n", "# Write APs to JSON", "\n", "eval_instances", ".", "writeDict2JSON", "(", "maskResDict", ",", "args", ".", "exportMaskFile", ")", "\n", "", "strMaskResults", "=", "eval_instances", ".", "printResults", "(", "maskAvgDict", ",", "args", ")", "\n", "strResults", "+=", "\"\\nMask\\n\"", "+", "strMaskResults", "\n", "\n", "", "logger", ".", "info", "(", "strResults", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.CArgs.__repr__": [[66, 77], ["max", "max", "eval_instances.CArgs.__dict__.items", "len", "len", "max", "str", "eval_instances.CArgs.__dict__.keys", "str", "eval_instances.CArgs.__dict__.values", "max"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys"], ["    ", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        A weird looking pretty print for Evaluation Arguments\n        \"\"\"", "\n", "longest_key", "=", "max", "(", "[", "len", "(", "str", "(", "k", ")", ")", "for", "k", "in", "self", ".", "__dict__", ".", "keys", "(", ")", "]", ")", "\n", "longest_val", "=", "max", "(", "[", "len", "(", "str", "(", "v", ")", ")", "for", "v", "in", "self", ".", "__dict__", ".", "values", "(", ")", "]", ")", "\n", "s", "=", "\"\\n\"", "+", "\"#\"", "*", "max", "(", "79", ",", "(", "longest_key", "+", "longest_val", "+", "3", ")", ")", "+", "\"\\n\"", "\n", "for", "k", ",", "v", "in", "self", ".", "__dict__", ".", "items", "(", ")", ":", "\n", "            ", "s", "+=", "\"%{}s : %s\\n\"", ".", "format", "(", "longest_key", ")", "%", "(", "k", ",", "v", ")", "\n", "", "s", "+=", "\"#\"", "*", "max", "(", "79", ",", "(", "longest_key", "+", "longest_val", "+", "3", ")", ")", "+", "\"\\n\"", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.matchGtsWithPreds": [[99, 157], ["tqdm.tqdm", "len", "len", "range", "matches.append", "len", "len", "len", "eval_instances.matchGtWithPred"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.matchGtWithPred"], ["def", "matchGtsWithPreds", "(", "dataset", ",", "predictions", ")", ":", "\n", "    ", "\"\"\"\n    Go through the `dataset` and `predictions` one-by-one, and list all\n    instances with any non-zero intersection.\n\n    This function handles matching when only BBoxes are used, and when\n    instnace segmentation is available it computes the pixel-wise overlap as\n    well\n\n    The implementation is heavily based on the original CityScapes eval script:\n    https://github.com/mcordts/cityscapesScripts/blob/master/cityscapesscripts/evaluation/evalInstanceLevelSemanticLabeling.py\n\n\n    Original match structure looks like:\n    {\"filename1\":\n        \"groundTruth\":gtInstances\n        \"prediction\":predInstances\n    }\n    # Filenames are not necessary, replace them with idx\n\n\n    <gt/pred>Instances=\n    {\n        \"category_name1\":[<gt/pred>Instance1, <gt/pred>Instance2, ...]\n        \"category_name2\":[<gt/pred>Instance3, <gt/pred>Instance4, ...]\n    ...\n    }\n\n    gtInstance=\n    {\n        \"labelID\":int(labelID)\n        \"instID\":int(instID)\n        \"boxArea\":np.count_nonzero(npArray binary mask)\n        \"intersection\": pixel count (ONLY IF the dict is in the inner list of a predInstance[\"matchedGt\"])\n        \"voidIntersection\":REMOVE THIS!!!\n        \"matchedPred\":list(predInstance) which has nonzero intersection\n    }\n\n    predInstance=\n    {\n        \"imgName\":\"path/to/input/img\"\n        \"predID\":<a counter's current state>\n        \"labelID\":int(labelID)\n        \"boxArea\":pixel count (ONLY IF the dict is in the inner list of a predInstance[\"matchedGt\"])\n        \"confidence\":float(confidence)\n        \"intersection\":np.count_nonzero( np.logical_and( gtNp == gtInstance[\"instID\"] , boolPredInst) )\n        \"voidIntersection\":REMOVE THIS!!!\n        \"matchedGt\":list(gtInstance) which has nonzero intersection\n    }\n    \"\"\"", "\n", "\n", "assert", "len", "(", "dataset", ")", "==", "len", "(", "predictions", ")", ",", "f\"{len(dataset)} != {len(predictions)}\"", "\n", "\n", "matches", "=", "[", "]", "\n", "for", "idx", "in", "tqdm", "(", "range", "(", "len", "(", "predictions", ")", ")", ",", "desc", "=", "\"Matching Preds with GT\"", ")", ":", "\n", "        ", "matches", ".", "append", "(", "matchGtWithPred", "(", "dataset", ",", "predictions", ",", "idx", ")", ")", "\n", "\n", "", "return", "matches", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.isOverlapping": [[159, 164], ["None"], "function", ["None"], ["", "def", "isOverlapping", "(", "box1", ",", "box2", ")", ":", "\n", "    ", "x1min", ",", "y1min", ",", "x1max", ",", "y1max", "=", "box1", "\n", "x2min", ",", "y2min", ",", "x2max", ",", "y2max", "=", "box2", "\n", "ret", "=", "x1min", "<", "x2max", "and", "x2min", "<", "x1max", "and", "y1min", "<", "y2max", "and", "y2min", "<", "y1max", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.getUnionBox": [[166, 177], ["map", "map", "min", "min", "max", "max"], "function", ["None"], ["", "def", "getUnionBox", "(", "box1", ",", "box2", ")", ":", "\n", "    ", "x1min", ",", "y1min", ",", "x1max", ",", "y1max", "=", "map", "(", "int", ",", "box1", ")", "\n", "x2min", ",", "y2min", ",", "x2max", ",", "y2max", "=", "map", "(", "int", ",", "box2", ")", "\n", "\n", "xmin", "=", "min", "(", "x1min", ",", "x2min", ")", "\n", "ymin", "=", "min", "(", "y1min", ",", "y2min", ")", "\n", "xmax", "=", "max", "(", "x1max", ",", "x2max", ")", "\n", "ymax", "=", "max", "(", "y1max", ",", "y2max", ")", "\n", "\n", "unionBox", "=", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "\n", "return", "unionBox", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.getIntersectionBox": [[179, 190], ["map", "map", "max", "max", "min", "min"], "function", ["None"], ["", "def", "getIntersectionBox", "(", "box1", ",", "box2", ")", ":", "\n", "    ", "x1min", ",", "y1min", ",", "x1max", ",", "y1max", "=", "map", "(", "int", ",", "box1", ")", "\n", "x2min", ",", "y2min", ",", "x2max", ",", "y2max", "=", "map", "(", "int", ",", "box2", ")", "\n", "\n", "xmin", "=", "max", "(", "x1min", ",", "x2min", ")", "\n", "ymin", "=", "max", "(", "y1min", ",", "y2min", ")", "\n", "xmax", "=", "min", "(", "x1max", ",", "x2max", ")", "\n", "ymax", "=", "min", "(", "y1max", ",", "y2max", ")", "\n", "\n", "intersectionBox", "=", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "\n", "return", "intersectionBox", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.computeBoxIntersection": [[192, 199], ["eval_instances.getIntersectionBox"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.getIntersectionBox"], ["", "def", "computeBoxIntersection", "(", "gt", ",", "pred", ")", ":", "\n", "    ", "\"\"\"\n    Compute intersection between GT instance and prediction.\n    \"\"\"", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "getIntersectionBox", "(", "gt", "[", "\"box\"", "]", ",", "pred", "[", "\"box\"", "]", ")", "\n", "intersection", "=", "(", "xmax", "-", "xmin", ")", "*", "(", "ymax", "-", "ymin", ")", "\n", "return", "intersection", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.computeMaskIntersection": [[201, 221], ["eval_instances.getUnionBox", "torch.sum().item", "len", "len", "torch.sum", "torch.mul"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.getUnionBox"], ["", "def", "computeMaskIntersection", "(", "gt", ",", "gtMask", ",", "pred", ",", "predMask", ")", ":", "\n", "    ", "\"\"\"\n    Compute intersection between GT instance and prediction.\n    Increase efficiency by computing elementwise product between masks\n    only inside the tight bounding box of the union of the prediction and\n    target masks.\n    \"\"\"", "\n", "if", "gtMask", "is", "None", "or", "predMask", "is", "None", ":", "\n", "        ", "return", "0", "\n", "\n", "", "assert", "gtMask", ".", "shape", "==", "predMask", ".", "shape", "\n", "assert", "len", "(", "gtMask", ".", "shape", ")", "==", "len", "(", "predMask", ".", "shape", ")", "==", "2", "\n", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "getUnionBox", "(", "gt", "[", "\"box\"", "]", ",", "pred", "[", "\"box\"", "]", ")", "\n", "gtMask_crop", "=", "gtMask", "[", "ymin", ":", "ymax", ",", "xmin", ":", "xmax", "]", "\n", "predMask_crop", "=", "predMask", "[", "ymin", ":", "ymax", ",", "xmin", ":", "xmax", "]", "\n", "\n", "# elementwise AND", "\n", "intersection", "=", "torch", ".", "sum", "(", "torch", ".", "mul", "(", "gtMask_crop", ",", "predMask_crop", ")", ")", ".", "item", "(", ")", "\n", "return", "intersection", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.matchGtWithPred": [[223, 272], ["eval_instances.prepareGtImage", "eval_instances.preparePredImage", "zip", "zip", "groupedGtInstances[].append", "groupedPredInstances[].append", "eval_instances.computeBoxIntersection", "eval_instances.computeMaskIntersection", "eval_instances.isOverlapping", "gt.copy", "pred.copy", "gt.copy.pop", "pred.copy.pop", "gt[].append", "pred[].append"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.prepareGtImage", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.preparePredImage", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.computeBoxIntersection", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.computeMaskIntersection", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.isOverlapping"], ["", "def", "matchGtWithPred", "(", "dataset", ",", "predictions", ",", "idx", ")", ":", "\n", "# Collect instances from gt and pred separately per image", "\n", "# TODO: not parallel! parallelize this process safely", "\n", "    ", "perImgGtInstances", ",", "gtMasks", "=", "prepareGtImage", "(", "dataset", ",", "idx", ")", "\n", "perImgPredInstances", ",", "predMasks", "=", "preparePredImage", "(", "dataset", ",", "predictions", ",", "idx", ")", "\n", "\n", "# If no masks are provided, the segmentation score will be 0", "\n", "for", "gt", ",", "gtMask", "in", "zip", "(", "perImgGtInstances", ",", "gtMasks", ")", ":", "\n", "        ", "for", "pred", ",", "predMask", "in", "zip", "(", "perImgPredInstances", ",", "predMasks", ")", ":", "\n", "            ", "if", "not", "isOverlapping", "(", "gt", "[", "\"box\"", "]", ",", "pred", "[", "\"box\"", "]", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "boxIntersection", "=", "computeBoxIntersection", "(", "gt", ",", "pred", ")", "\n", "maskIntersection", "=", "computeMaskIntersection", "(", "gt", ",", "gtMask", ",", "pred", ",", "predMask", ")", "\n", "\n", "if", "boxIntersection", ">", "0", ":", "\n", "# Copy metadata only, and register the matched pairs", "\n", "# this step is redundant but informative", "\n", "# intersection score would be enough", "\n", "                ", "gtCopy", "=", "gt", ".", "copy", "(", ")", "\n", "predCopy", "=", "pred", ".", "copy", "(", ")", "\n", "\n", "# remove linking field (an empty list) to avoid confusion", "\n", "gtCopy", ".", "pop", "(", "\"matchedPred\"", ")", "\n", "predCopy", ".", "pop", "(", "\"matchedGt\"", ")", "\n", "\n", "gtCopy", "[", "\"boxIntersection\"", "]", "=", "boxIntersection", "\n", "gtCopy", "[", "\"maskIntersection\"", "]", "=", "maskIntersection", "\n", "predCopy", "[", "\"boxIntersection\"", "]", "=", "boxIntersection", "\n", "predCopy", "[", "\"maskIntersection\"", "]", "=", "maskIntersection", "\n", "\n", "gt", "[", "\"matchedPred\"", "]", ".", "append", "(", "predCopy", ")", "\n", "pred", "[", "\"matchedGt\"", "]", ".", "append", "(", "gtCopy", ")", "\n", "\n", "# Group by classes", "\n", "", "", "", "groupedGtInstances", "=", "{", "labelName", ":", "[", "]", "for", "labelName", "in", "dataset", ".", "CLASSES", "}", "\n", "groupedPredInstances", "=", "{", "labelName", ":", "[", "]", "for", "labelName", "in", "dataset", ".", "CLASSES", "}", "\n", "\n", "for", "gt", "in", "perImgGtInstances", ":", "\n", "        ", "gtLabelName", "=", "dataset", ".", "id_to_name", "[", "gt", "[", "\"labelID\"", "]", "]", "\n", "groupedGtInstances", "[", "gtLabelName", "]", ".", "append", "(", "gt", ")", "\n", "\n", "", "for", "pred", "in", "perImgPredInstances", ":", "\n", "        ", "predLabelName", "=", "dataset", ".", "id_to_name", "[", "pred", "[", "\"labelID\"", "]", "]", "\n", "groupedPredInstances", "[", "predLabelName", "]", ".", "append", "(", "pred", ")", "\n", "\n", "", "match", "=", "{", "\"groundTruth\"", ":", "groupedGtInstances", ",", "\"prediction\"", ":", "groupedPredInstances", "}", "\n", "\n", "return", "match", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.prepareGtImage": [[274, 325], ["dataset.get_img_info", "perImageGts.resize.convert", "perImageGts.resize.bbox.long", "bbs.tolist.tolist", "perImageGts.resize.get_field().tolist", "range", "len", "len", "perImageGts.resize.resize", "perImageGts.resize.fields", "perImageGts.resize.get_field().get_mask_tensor", "zip", "len", "perImageInstances.append", "perImageGts.resize.get_field", "len", "pixelCounts.append", "perImageGts.resize.get_field", "instanceMask[].sum().item", "instanceMask[].sum"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.get_mask_tensor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "prepareGtImage", "(", "dataset", ",", "idx", ")", ":", "\n", "    ", "_", ",", "perImageGts", ",", "_", "=", "dataset", "[", "idx", "]", "\n", "perImageInstances", "=", "[", "]", "\n", "maskTensor", "=", "[", "None", "]", "*", "len", "(", "perImageGts", ")", "\n", "if", "len", "(", "perImageGts", ")", "==", "0", ":", "\n", "        ", "return", "perImageInstances", ",", "maskTensor", "\n", "\n", "# Resize to original image size", "\n", "", "imgInfo", "=", "dataset", ".", "get_img_info", "(", "idx", ")", "\n", "origSize", "=", "imgInfo", "[", "\"width\"", "]", ",", "imgInfo", "[", "\"height\"", "]", "\n", "if", "perImageGts", ".", "size", "!=", "origSize", ":", "\n", "        ", "perImageGts", "=", "perImageGts", ".", "resize", "(", "size", "=", "origSize", ")", "\n", "\n", "# Compute box areas", "\n", "", "perImageGts", "=", "perImageGts", ".", "convert", "(", "\"xyxy\"", ")", "\n", "bbs", "=", "perImageGts", ".", "bbox", ".", "long", "(", ")", "\n", "xmins", ",", "ymins", ",", "xmaxs", ",", "ymaxs", "=", "bbs", "[", ":", ",", "0", "]", ",", "bbs", "[", ":", ",", "1", "]", ",", "bbs", "[", ":", ",", "2", "]", ",", "bbs", "[", ":", ",", "3", "]", "\n", "boxAreas", "=", "(", "(", "xmaxs", "-", "xmins", ")", "*", "(", "ymaxs", "-", "ymins", ")", ")", ".", "tolist", "(", ")", "\n", "bbs", "=", "bbs", ".", "tolist", "(", ")", "\n", "\n", "# object label for each prediction", "\n", "labels", "=", "perImageGts", ".", "get_field", "(", "\"labels\"", ")", ".", "tolist", "(", ")", "\n", "if", "\"masks\"", "in", "perImageGts", ".", "fields", "(", ")", ":", "\n", "# Get the binary mask for each instance in a contiguous array", "\n", "        ", "maskTensor", "=", "perImageGts", ".", "get_field", "(", "\"masks\"", ")", ".", "get_mask_tensor", "(", ")", "\n", "\n", "# In case of single mask then add a new axis", "\n", "if", "len", "(", "maskTensor", ".", "shape", ")", "==", "2", ":", "\n", "            ", "maskTensor", "=", "maskTensor", "[", "None", "]", "\n", "\n", "# unique_values = set(torch.unique(maskTensor).tolist())", "\n", "# assert len(unique_values) == 2, \"Not binary mask: %s\" % unique_values", "\n", "# pixelCounts = maskTensor.clamp_(0, 1).sum(dim=[1, 2])", "\n", "", "pixelCounts", "=", "[", "]", "\n", "for", "(", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", ")", ",", "instanceMask", "in", "zip", "(", "bbs", ",", "maskTensor", ")", ":", "\n", "            ", "pixelCounts", ".", "append", "(", "instanceMask", "[", "ymin", ":", "ymax", ",", "xmin", ":", "xmax", "]", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "", "for", "instID", "in", "range", "(", "len", "(", "perImageGts", ")", ")", ":", "\n", "        ", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "bbs", "[", "instID", "]", "\n", "pixelCount", "=", "pixelCounts", "[", "instID", "]", "if", "maskTensor", "[", "0", "]", "is", "not", "None", "else", "0", "\n", "gtInstance", "=", "{", "\n", "\"labelID\"", ":", "labels", "[", "instID", "]", ",", "\n", "\"instID\"", ":", "instID", ",", "\n", "\"boxArea\"", ":", "boxAreas", "[", "instID", "]", ",", "\n", "\"pixelCount\"", ":", "pixelCount", ",", "\n", "\"box\"", ":", "(", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", ")", ",", "\n", "\"matchedPred\"", ":", "[", "]", ",", "\n", "}", "\n", "perImageInstances", ".", "append", "(", "gtInstance", ")", "\n", "\n", "", "return", "perImageInstances", ",", "maskTensor", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.preparePredImage": [[327, 416], ["dataset.get_img_info", "perImagePredictions.resize.convert", "perImagePredictions.resize.bbox.long", "bbs.tolist.tolist", "perImagePredictions.resize.get_field().tolist", "perImagePredictions.resize.get_field().tolist", "range", "len", "len", "perImagePredictions.resize.resize", "perImagePredictions.resize.fields", "perImagePredictions.resize.get_field", "maskTensor.float.float", "zip", "len", "perImageInstances.append", "perImagePredictions.resize.get_field", "perImagePredictions.resize.get_field", "len", "len", "vc_rcnn.modeling.roi_heads.mask_head.inference.Masker().forward_single_image", "pixelCounts.append", "len", "len", "instanceMask[].sum().item", "vc_rcnn.modeling.roi_heads.mask_head.inference.Masker", "instanceMask[].sum"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.mask_head.inference.Masker.forward_single_image"], ["", "def", "preparePredImage", "(", "dataset", ",", "predictions", ",", "idx", ")", ":", "\n", "    ", "perImagePredictions", "=", "predictions", "[", "idx", "]", "\n", "\n", "# A list will hold statistics and meta-data about the image", "\n", "perImageInstances", "=", "[", "]", "\n", "\n", "# maskTensor represents binary masks of all predicted instance segmentations", "\n", "# if present", "\n", "maskTensor", "=", "[", "None", "]", "*", "len", "(", "perImagePredictions", ")", "\n", "\n", "# No predictions for this image", "\n", "if", "len", "(", "perImagePredictions", ")", "==", "0", ":", "\n", "        ", "return", "perImageInstances", ",", "maskTensor", "\n", "\n", "# Resize to original image size", "\n", "", "imgInfo", "=", "dataset", ".", "get_img_info", "(", "idx", ")", "\n", "origSize", "=", "imgInfo", "[", "\"width\"", "]", ",", "imgInfo", "[", "\"height\"", "]", "\n", "if", "perImagePredictions", ".", "size", "!=", "origSize", ":", "\n", "        ", "perImagePredictions", "=", "perImagePredictions", ".", "resize", "(", "size", "=", "origSize", ")", "\n", "\n", "# Bounding boxes and areas", "\n", "", "perImagePredictions", "=", "perImagePredictions", ".", "convert", "(", "\"xyxy\"", ")", "\n", "bbs", "=", "perImagePredictions", ".", "bbox", ".", "long", "(", ")", "\n", "xmins", ",", "ymins", ",", "xmaxs", ",", "ymaxs", "=", "bbs", "[", ":", ",", "0", "]", ",", "bbs", "[", ":", ",", "1", "]", ",", "bbs", "[", ":", ",", "2", "]", ",", "bbs", "[", ":", ",", "3", "]", "\n", "boxAreas", "=", "(", "(", "xmaxs", "-", "xmins", ")", "*", "(", "ymaxs", "-", "ymins", ")", ")", ".", "tolist", "(", ")", "\n", "bbs", "=", "bbs", ".", "tolist", "(", ")", "\n", "\n", "# object label and \"Objectness\" score for each prediction", "\n", "labels", "=", "perImagePredictions", ".", "get_field", "(", "\"labels\"", ")", ".", "tolist", "(", ")", "\n", "scores", "=", "perImagePredictions", ".", "get_field", "(", "\"scores\"", ")", ".", "tolist", "(", ")", "\n", "\n", "# Get the mask for each instance in a contiguous array", "\n", "if", "\"mask\"", "in", "perImagePredictions", ".", "fields", "(", ")", ":", "\n", "        ", "maskTensor", "=", "perImagePredictions", ".", "get_field", "(", "\"mask\"", ")", "\n", "\n", "# sanity checks", "\n", "assert", "len", "(", "perImagePredictions", ")", "==", "len", "(", "maskTensor", ")", ",", "(", "\n", "\"number of masks (%d) do not match the number of boxes (%d)\"", "\n", "%", "(", "len", "(", "perImagePredictions", ")", ",", "len", "(", "maskTensor", ")", ")", "\n", ")", "\n", "\n", "maskTensor", "=", "maskTensor", ".", "float", "(", ")", "\n", "# We assume that the maskTensors are coming right out of the maskRCNN", "\n", "# having values between [0, 1] inclusive", "\n", "#", "\n", "# assert maskTensor.min() >= 0.0 and maskTensor.max() <= 1.0, [", "\n", "#     maskTensor.max(),", "\n", "#     maskTensor.min(),", "\n", "# ]", "\n", "\n", "# Project masks to the boxes", "\n", "# TODO: Issue #527 - bad Masker interface", "\n", "#", "\n", "# The predicted masks are in the shape of i.e. [N, 1, 28, 28] where N is", "\n", "# the number of instances predicted, and they represent the interior", "\n", "# of the bounding boxes.", "\n", "#", "\n", "# Masker projects these predictions on an empty canvas with the full", "\n", "# size of the input image using the predicted bounding boxes", "\n", "maskTensor", "=", "Masker", "(", "threshold", "=", "0.5", ")", ".", "forward_single_image", "(", "\n", "maskTensor", ",", "perImagePredictions", "\n", ")", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "\n", "pixelCounts", "=", "[", "]", "\n", "for", "(", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", ")", ",", "instanceMask", "in", "zip", "(", "bbs", ",", "maskTensor", ")", ":", "\n", "            ", "pixelCounts", ".", "append", "(", "instanceMask", "[", "ymin", ":", "ymax", ",", "xmin", ":", "xmax", "]", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "", "for", "predID", "in", "range", "(", "len", "(", "perImagePredictions", ")", ")", ":", "\n", "        ", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "bbs", "[", "predID", "]", "\n", "# if we have instance segmentation prediction then we update pixelCount", "\n", "pixelCount", "=", "0", "\n", "if", "maskTensor", "[", "0", "]", "is", "not", "None", ":", "\n", "            ", "pixelCount", "=", "pixelCounts", "[", "predID", "]", "\n", "if", "pixelCount", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "", "predInstance", "=", "{", "\n", "\"imgName\"", ":", "idx", ",", "\n", "\"predID\"", ":", "predID", ",", "\n", "\"labelID\"", ":", "labels", "[", "predID", "]", ",", "\n", "\"boxArea\"", ":", "boxAreas", "[", "predID", "]", ",", "\n", "\"pixelCount\"", ":", "pixelCount", ",", "\n", "\"confidence\"", ":", "scores", "[", "predID", "]", ",", "\n", "\"box\"", ":", "(", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", ")", ",", "\n", "\"matchedGt\"", ":", "[", "]", ",", "\n", "}", "\n", "perImageInstances", ".", "append", "(", "predInstance", ")", "\n", "\n", "", "return", "perImageInstances", ",", "maskTensor", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.evaluateBoxMatches": [[418, 617], ["numpy.zeros", "enumerate", "enumerate", "len", "len", "len", "enumerate", "numpy.empty", "numpy.empty", "numpy.ones", "numpy.zeros", "enumerate", "numpy.append", "numpy.append", "numpy.argsort", "numpy.cumsum", "numpy.unique", "len", "numpy.zeros", "numpy.zeros", "numpy.append", "enumerate", "numpy.copy", "numpy.append", "numpy.append", "numpy.convolve", "numpy.dot", "len", "numpy.ones", "len", "len", "float", "len", "float", "float", "float", "float", "float", "numpy.append", "numpy.append", "max", "min", "numpy.append", "numpy.append", "numpy.append", "float"], "function", ["None"], ["", "def", "evaluateBoxMatches", "(", "matches", ",", "args", ")", ":", "\n", "# In the end, we need two vectors for each class and for each overlap", "\n", "# The first vector (y_true) is binary and is 1, where the ground truth says true,", "\n", "# and is 0 otherwise.", "\n", "# The second vector (y_score) is float [0...1] and represents the confidence of", "\n", "# the prediction.", "\n", "#", "\n", "# We represent the following cases as:", "\n", "#                                       | y_true |   y_score", "\n", "#   gt instance with matched prediction |    1   | confidence", "\n", "#   gt instance w/o  matched prediction |    1   |     0.0", "\n", "#          false positive prediction    |    0   | confidence", "\n", "#", "\n", "# The current implementation makes only sense for an overlap threshold >= 0.5,", "\n", "# since only then, a single prediction can either be ignored or matched, but", "\n", "# never both. Further, it can never match to two gt instances.", "\n", "# For matching, we vary the overlap and do the following steps:", "\n", "#   1.) remove all predictions that satisfy the overlap criterion with an ignore region (either void or *group)", "\n", "#   2.) remove matches that do not satisfy the overlap", "\n", "#   3.) mark non-matched predictions as false positive", "\n", "\n", "# AP", "\n", "    ", "overlaps", "=", "args", ".", "overlaps", "\n", "# region size", "\n", "minRegionSizes", "=", "args", ".", "minRegionSizes", "\n", "\n", "# only keep the first, if distances are not available", "\n", "# if not args.distanceAvailable:", "\n", "#     minRegionSizes = [ minRegionSizes[0] ]", "\n", "#     distThs        = [ distThs       [0] ]", "\n", "#     distConfs      = [ distConfs     [0] ]", "\n", "\n", "# Here we hold the results", "\n", "# First dimension is class, second overlap", "\n", "ap", "=", "np", ".", "zeros", "(", "(", "len", "(", "minRegionSizes", ")", ",", "len", "(", "args", ".", "instLabels", ")", ",", "len", "(", "overlaps", ")", ")", ",", "np", ".", "float", ")", "\n", "\n", "for", "dI", ",", "minRegionSize", "in", "enumerate", "(", "minRegionSizes", ")", ":", "\n", "        ", "for", "(", "oI", ",", "overlapTh", ")", "in", "enumerate", "(", "overlaps", ")", ":", "\n", "            ", "for", "(", "lI", ",", "labelName", ")", "in", "enumerate", "(", "args", ".", "instLabels", ")", ":", "\n", "                ", "y_true", "=", "np", ".", "empty", "(", "0", ")", "\n", "y_score", "=", "np", ".", "empty", "(", "0", ")", "\n", "# count hard false negatives", "\n", "hardFns", "=", "0", "\n", "# found at least one gt and predicted instance?", "\n", "haveGt", "=", "False", "\n", "havePred", "=", "False", "\n", "\n", "for", "img", "in", "matches", ":", "\n", "                    ", "predInstances", "=", "img", "[", "\"prediction\"", "]", "[", "labelName", "]", "\n", "gtInstances", "=", "img", "[", "\"groundTruth\"", "]", "[", "labelName", "]", "\n", "# filter groups in ground truth", "\n", "gtInstances", "=", "[", "\n", "gt", "for", "gt", "in", "gtInstances", "if", "gt", "[", "\"boxArea\"", "]", ">=", "minRegionSize", "\n", "]", "\n", "\n", "if", "gtInstances", ":", "\n", "                        ", "haveGt", "=", "True", "\n", "", "if", "predInstances", ":", "\n", "                        ", "havePred", "=", "True", "\n", "\n", "", "curTrue", "=", "np", ".", "ones", "(", "len", "(", "gtInstances", ")", ")", "\n", "curScore", "=", "np", ".", "ones", "(", "len", "(", "gtInstances", ")", ")", "*", "(", "-", "float", "(", "\"inf\"", ")", ")", "\n", "curMatch", "=", "np", ".", "zeros", "(", "len", "(", "gtInstances", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "\n", "# collect matches", "\n", "for", "(", "gtI", ",", "gt", ")", "in", "enumerate", "(", "gtInstances", ")", ":", "\n", "                        ", "foundMatch", "=", "False", "\n", "for", "pred", "in", "gt", "[", "\"matchedPred\"", "]", ":", "\n", "                            ", "overlap", "=", "float", "(", "pred", "[", "\"boxIntersection\"", "]", ")", "/", "(", "\n", "gt", "[", "\"boxArea\"", "]", "\n", "+", "pred", "[", "\"boxArea\"", "]", "\n", "-", "pred", "[", "\"boxIntersection\"", "]", "\n", ")", "\n", "if", "overlap", ">", "overlapTh", ":", "\n", "# the score", "\n", "                                ", "confidence", "=", "pred", "[", "\"confidence\"", "]", "\n", "\n", "# if we already hat a prediction for this groundtruth", "\n", "# the prediction with the lower score is automatically a false positive", "\n", "if", "curMatch", "[", "gtI", "]", ":", "\n", "                                    ", "maxScore", "=", "max", "(", "curScore", "[", "gtI", "]", ",", "confidence", ")", "\n", "minScore", "=", "min", "(", "curScore", "[", "gtI", "]", ",", "confidence", ")", "\n", "curScore", "[", "gtI", "]", "=", "maxScore", "\n", "# append false positive", "\n", "curTrue", "=", "np", ".", "append", "(", "curTrue", ",", "0", ")", "\n", "curScore", "=", "np", ".", "append", "(", "curScore", ",", "minScore", ")", "\n", "curMatch", "=", "np", ".", "append", "(", "curMatch", ",", "True", ")", "\n", "# otherwise set score", "\n", "", "else", ":", "\n", "                                    ", "foundMatch", "=", "True", "\n", "curMatch", "[", "gtI", "]", "=", "True", "\n", "curScore", "[", "gtI", "]", "=", "confidence", "\n", "\n", "", "", "", "if", "not", "foundMatch", ":", "\n", "                            ", "hardFns", "+=", "1", "\n", "\n", "# remove non-matched ground truth instances", "\n", "", "", "curTrue", "=", "curTrue", "[", "curMatch", "==", "True", "]", "\n", "curScore", "=", "curScore", "[", "curMatch", "==", "True", "]", "\n", "\n", "# collect non-matched predictions as false positive", "\n", "for", "pred", "in", "predInstances", ":", "\n", "                        ", "foundGt", "=", "False", "\n", "for", "gt", "in", "pred", "[", "\"matchedGt\"", "]", ":", "\n", "                            ", "overlap", "=", "float", "(", "gt", "[", "\"boxIntersection\"", "]", ")", "/", "(", "\n", "gt", "[", "\"boxArea\"", "]", "+", "pred", "[", "\"boxArea\"", "]", "-", "gt", "[", "\"boxIntersection\"", "]", "\n", ")", "\n", "if", "overlap", ">", "overlapTh", ":", "\n", "                                ", "foundGt", "=", "True", "\n", "break", "\n", "", "", "if", "not", "foundGt", ":", "\n", "# collect number of void and *group pixels", "\n", "                            ", "nbIgnorePixels", "=", "0", "\n", "for", "gt", "in", "pred", "[", "\"matchedGt\"", "]", ":", "\n", "# small ground truth instances", "\n", "                                ", "if", "gt", "[", "\"boxArea\"", "]", "<", "minRegionSize", ":", "\n", "                                    ", "nbIgnorePixels", "+=", "gt", "[", "\"boxIntersection\"", "]", "\n", "", "", "if", "pred", "[", "\"boxArea\"", "]", ">", "0", ":", "\n", "                                ", "proportionIgnore", "=", "(", "\n", "float", "(", "nbIgnorePixels", ")", "/", "pred", "[", "\"boxArea\"", "]", "\n", ")", "\n", "", "else", ":", "\n", "                                ", "proportionIgnore", "=", "0", "\n", "# if not ignored", "\n", "# append false positive", "\n", "", "if", "proportionIgnore", "<=", "overlapTh", ":", "\n", "                                ", "curTrue", "=", "np", ".", "append", "(", "curTrue", ",", "0", ")", "\n", "confidence", "=", "pred", "[", "\"confidence\"", "]", "\n", "curScore", "=", "np", ".", "append", "(", "curScore", ",", "confidence", ")", "\n", "\n", "# append to overall results", "\n", "", "", "", "y_true", "=", "np", ".", "append", "(", "y_true", ",", "curTrue", ")", "\n", "y_score", "=", "np", ".", "append", "(", "y_score", ",", "curScore", ")", "\n", "\n", "# compute the average precision", "\n", "", "if", "haveGt", "and", "havePred", ":", "\n", "# compute precision recall curve first", "\n", "\n", "# sorting and cumsum", "\n", "                    ", "scoreArgSort", "=", "np", ".", "argsort", "(", "y_score", ")", "\n", "yScoreSorted", "=", "y_score", "[", "scoreArgSort", "]", "\n", "yTrueSorted", "=", "y_true", "[", "scoreArgSort", "]", "\n", "yTrueSortedCumsum", "=", "np", ".", "cumsum", "(", "yTrueSorted", ")", "\n", "\n", "# unique thresholds", "\n", "(", "thresholds", ",", "uniqueIndices", ")", "=", "np", ".", "unique", "(", "\n", "yScoreSorted", ",", "return_index", "=", "True", "\n", ")", "\n", "\n", "# since we need to add an artificial point to the precision-recall curve", "\n", "# increase its length by 1", "\n", "nbPrecRecall", "=", "len", "(", "uniqueIndices", ")", "+", "1", "\n", "\n", "# prepare precision recall", "\n", "nbExamples", "=", "len", "(", "yScoreSorted", ")", "\n", "nbTrueExamples", "=", "yTrueSortedCumsum", "[", "-", "1", "]", "\n", "precision", "=", "np", ".", "zeros", "(", "nbPrecRecall", ")", "\n", "recall", "=", "np", ".", "zeros", "(", "nbPrecRecall", ")", "\n", "\n", "# deal with the first point", "\n", "# only thing we need to do, is to append a zero to the cumsum at the end.", "\n", "# an index of -1 uses that zero then", "\n", "yTrueSortedCumsum", "=", "np", ".", "append", "(", "yTrueSortedCumsum", ",", "0", ")", "\n", "\n", "# deal with remaining", "\n", "for", "idxRes", ",", "idxScores", "in", "enumerate", "(", "uniqueIndices", ")", ":", "\n", "                        ", "cumSum", "=", "yTrueSortedCumsum", "[", "idxScores", "-", "1", "]", "\n", "tp", "=", "nbTrueExamples", "-", "cumSum", "\n", "fp", "=", "nbExamples", "-", "idxScores", "-", "tp", "\n", "fn", "=", "cumSum", "+", "hardFns", "\n", "p", "=", "float", "(", "tp", ")", "/", "(", "tp", "+", "fp", ")", "\n", "r", "=", "float", "(", "tp", ")", "/", "(", "tp", "+", "fn", ")", "\n", "precision", "[", "idxRes", "]", "=", "p", "\n", "recall", "[", "idxRes", "]", "=", "r", "\n", "\n", "# first point in curve is artificial", "\n", "", "precision", "[", "-", "1", "]", "=", "1.0", "\n", "recall", "[", "-", "1", "]", "=", "0.0", "\n", "\n", "# compute average of precision-recall curve", "\n", "# integration is performed via zero order, or equivalently step-wise integration", "\n", "# first compute the widths of each step:", "\n", "# use a convolution with appropriate kernel, manually deal with the boundaries first", "\n", "recallForConv", "=", "np", ".", "copy", "(", "recall", ")", "\n", "recallForConv", "=", "np", ".", "append", "(", "recallForConv", "[", "0", "]", ",", "recallForConv", ")", "\n", "recallForConv", "=", "np", ".", "append", "(", "recallForConv", ",", "0.0", ")", "\n", "\n", "stepWidths", "=", "np", ".", "convolve", "(", "recallForConv", ",", "[", "-", "0.5", ",", "0", ",", "0.5", "]", ",", "\"valid\"", ")", "\n", "\n", "# integrate is now simply a dot product", "\n", "apCurrent", "=", "np", ".", "dot", "(", "precision", ",", "stepWidths", ")", "\n", "\n", "", "elif", "haveGt", ":", "\n", "                    ", "apCurrent", "=", "0.0", "\n", "", "else", ":", "\n", "                    ", "apCurrent", "=", "float", "(", "\"nan\"", ")", "\n", "", "ap", "[", "dI", ",", "lI", ",", "oI", "]", "=", "apCurrent", "\n", "\n", "", "", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.evaluateMaskMatches": [[619, 821], ["numpy.zeros", "enumerate", "enumerate", "len", "len", "len", "enumerate", "numpy.empty", "numpy.empty", "numpy.ones", "numpy.zeros", "enumerate", "numpy.append", "numpy.append", "numpy.argsort", "numpy.cumsum", "numpy.unique", "len", "numpy.zeros", "numpy.zeros", "numpy.append", "enumerate", "numpy.copy", "numpy.append", "numpy.append", "numpy.convolve", "numpy.dot", "len", "numpy.ones", "len", "len", "float", "len", "float", "float", "float", "float", "float", "numpy.append", "numpy.append", "max", "min", "numpy.append", "numpy.append", "numpy.append", "float"], "function", ["None"], ["", "def", "evaluateMaskMatches", "(", "matches", ",", "args", ")", ":", "\n", "# In the end, we need two vectors for each class and for each overlap", "\n", "# The first vector (y_true) is binary and is 1, where the ground truth says true,", "\n", "# and is 0 otherwise.", "\n", "# The second vector (y_score) is float [0...1] and represents the confidence of", "\n", "# the prediction.", "\n", "#", "\n", "# We represent the following cases as:", "\n", "#                                       | y_true |   y_score", "\n", "#   gt instance with matched prediction |    1   | confidence", "\n", "#   gt instance w/o  matched prediction |    1   |     0.0", "\n", "#          false positive prediction    |    0   | confidence", "\n", "#", "\n", "# The current implementation makes only sense for an overlap threshold >= 0.5,", "\n", "# since only then, a single prediction can either be ignored or matched, but", "\n", "# never both. Further, it can never match to two gt instances.", "\n", "# For matching, we vary the overlap and do the following steps:", "\n", "#   1.) remove all predictions that satisfy the overlap criterion with an ignore region (either void or *group)", "\n", "#   2.) remove matches that do not satisfy the overlap", "\n", "#   3.) mark non-matched predictions as false positive", "\n", "\n", "# AP", "\n", "    ", "overlaps", "=", "args", ".", "overlaps", "\n", "# region size", "\n", "minRegionSizes", "=", "args", ".", "minRegionSizes", "\n", "\n", "# only keep the first, if distances are not available", "\n", "# if not args.distanceAvailable:", "\n", "#     minRegionSizes = [ minRegionSizes[0] ]", "\n", "#     distThs        = [ distThs       [0] ]", "\n", "#     distConfs      = [ distConfs     [0] ]", "\n", "\n", "# Here we hold the results", "\n", "# First dimension is class, second overlap", "\n", "ap", "=", "np", ".", "zeros", "(", "(", "len", "(", "minRegionSizes", ")", ",", "len", "(", "args", ".", "instLabels", ")", ",", "len", "(", "overlaps", ")", ")", ",", "np", ".", "float", ")", "\n", "\n", "for", "dI", ",", "minRegionSize", "in", "enumerate", "(", "minRegionSizes", ")", ":", "\n", "        ", "for", "(", "oI", ",", "overlapTh", ")", "in", "enumerate", "(", "overlaps", ")", ":", "\n", "            ", "for", "(", "lI", ",", "labelName", ")", "in", "enumerate", "(", "args", ".", "instLabels", ")", ":", "\n", "                ", "y_true", "=", "np", ".", "empty", "(", "0", ")", "\n", "y_score", "=", "np", ".", "empty", "(", "0", ")", "\n", "# count hard false negatives", "\n", "hardFns", "=", "0", "\n", "# found at least one gt and predicted instance?", "\n", "haveGt", "=", "False", "\n", "havePred", "=", "False", "\n", "\n", "for", "img", "in", "matches", ":", "\n", "                    ", "predInstances", "=", "img", "[", "\"prediction\"", "]", "[", "labelName", "]", "\n", "gtInstances", "=", "img", "[", "\"groundTruth\"", "]", "[", "labelName", "]", "\n", "# filter groups in ground truth", "\n", "gtInstances", "=", "[", "\n", "gt", "for", "gt", "in", "gtInstances", "if", "gt", "[", "\"pixelCount\"", "]", ">=", "minRegionSize", "\n", "]", "\n", "\n", "if", "gtInstances", ":", "\n", "                        ", "haveGt", "=", "True", "\n", "", "if", "predInstances", ":", "\n", "                        ", "havePred", "=", "True", "\n", "\n", "", "curTrue", "=", "np", ".", "ones", "(", "len", "(", "gtInstances", ")", ")", "\n", "curScore", "=", "np", ".", "ones", "(", "len", "(", "gtInstances", ")", ")", "*", "(", "-", "float", "(", "\"inf\"", ")", ")", "\n", "curMatch", "=", "np", ".", "zeros", "(", "len", "(", "gtInstances", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "\n", "# collect matches", "\n", "for", "(", "gtI", ",", "gt", ")", "in", "enumerate", "(", "gtInstances", ")", ":", "\n", "                        ", "foundMatch", "=", "False", "\n", "for", "pred", "in", "gt", "[", "\"matchedPred\"", "]", ":", "\n", "                            ", "overlap", "=", "float", "(", "pred", "[", "\"maskIntersection\"", "]", ")", "/", "(", "\n", "gt", "[", "\"pixelCount\"", "]", "\n", "+", "pred", "[", "\"pixelCount\"", "]", "\n", "-", "pred", "[", "\"maskIntersection\"", "]", "\n", ")", "\n", "if", "overlap", ">", "overlapTh", ":", "\n", "# the score", "\n", "                                ", "confidence", "=", "pred", "[", "\"confidence\"", "]", "\n", "\n", "# if we already hat a prediction for this groundtruth", "\n", "# the prediction with the lower score is automatically a false positive", "\n", "if", "curMatch", "[", "gtI", "]", ":", "\n", "                                    ", "maxScore", "=", "max", "(", "curScore", "[", "gtI", "]", ",", "confidence", ")", "\n", "minScore", "=", "min", "(", "curScore", "[", "gtI", "]", ",", "confidence", ")", "\n", "curScore", "[", "gtI", "]", "=", "maxScore", "\n", "# append false positive", "\n", "curTrue", "=", "np", ".", "append", "(", "curTrue", ",", "0", ")", "\n", "curScore", "=", "np", ".", "append", "(", "curScore", ",", "minScore", ")", "\n", "curMatch", "=", "np", ".", "append", "(", "curMatch", ",", "True", ")", "\n", "# otherwise set score", "\n", "", "else", ":", "\n", "                                    ", "foundMatch", "=", "True", "\n", "curMatch", "[", "gtI", "]", "=", "True", "\n", "curScore", "[", "gtI", "]", "=", "confidence", "\n", "\n", "", "", "", "if", "not", "foundMatch", ":", "\n", "                            ", "hardFns", "+=", "1", "\n", "\n", "# remove non-matched ground truth instances", "\n", "", "", "curTrue", "=", "curTrue", "[", "curMatch", "==", "True", "]", "\n", "curScore", "=", "curScore", "[", "curMatch", "==", "True", "]", "\n", "\n", "# collect non-matched predictions as false positive", "\n", "for", "pred", "in", "predInstances", ":", "\n", "                        ", "foundGt", "=", "False", "\n", "for", "gt", "in", "pred", "[", "\"matchedGt\"", "]", ":", "\n", "                            ", "overlap", "=", "float", "(", "gt", "[", "\"maskIntersection\"", "]", ")", "/", "(", "\n", "gt", "[", "\"pixelCount\"", "]", "\n", "+", "pred", "[", "\"pixelCount\"", "]", "\n", "-", "gt", "[", "\"maskIntersection\"", "]", "\n", ")", "\n", "if", "overlap", ">", "overlapTh", ":", "\n", "                                ", "foundGt", "=", "True", "\n", "break", "\n", "", "", "if", "not", "foundGt", ":", "\n", "# collect number of void and *group pixels", "\n", "                            ", "nbIgnorePixels", "=", "0", "\n", "for", "gt", "in", "pred", "[", "\"matchedGt\"", "]", ":", "\n", "# small ground truth instances", "\n", "                                ", "if", "gt", "[", "\"pixelCount\"", "]", "<", "minRegionSize", ":", "\n", "                                    ", "nbIgnorePixels", "+=", "gt", "[", "\"maskIntersection\"", "]", "\n", "\n", "", "", "if", "pred", "[", "\"pixelCount\"", "]", "<=", "0", ":", "\n", "                                ", "proportionIgnore", "=", "0", "\n", "", "else", ":", "\n", "                                ", "proportionIgnore", "=", "(", "\n", "float", "(", "nbIgnorePixels", ")", "/", "pred", "[", "\"pixelCount\"", "]", "\n", ")", "\n", "# if not ignored", "\n", "# append false positive", "\n", "", "if", "proportionIgnore", "<=", "overlapTh", ":", "\n", "                                ", "curTrue", "=", "np", ".", "append", "(", "curTrue", ",", "0", ")", "\n", "confidence", "=", "pred", "[", "\"confidence\"", "]", "\n", "curScore", "=", "np", ".", "append", "(", "curScore", ",", "confidence", ")", "\n", "\n", "# append to overall results", "\n", "", "", "", "y_true", "=", "np", ".", "append", "(", "y_true", ",", "curTrue", ")", "\n", "y_score", "=", "np", ".", "append", "(", "y_score", ",", "curScore", ")", "\n", "\n", "# compute the average precision", "\n", "", "if", "haveGt", "and", "havePred", ":", "\n", "# compute precision recall curve first", "\n", "\n", "# sorting and cumsum", "\n", "                    ", "scoreArgSort", "=", "np", ".", "argsort", "(", "y_score", ")", "\n", "yScoreSorted", "=", "y_score", "[", "scoreArgSort", "]", "\n", "yTrueSorted", "=", "y_true", "[", "scoreArgSort", "]", "\n", "yTrueSortedCumsum", "=", "np", ".", "cumsum", "(", "yTrueSorted", ")", "\n", "\n", "# unique thresholds", "\n", "(", "thresholds", ",", "uniqueIndices", ")", "=", "np", ".", "unique", "(", "\n", "yScoreSorted", ",", "return_index", "=", "True", "\n", ")", "\n", "\n", "# since we need to add an artificial point to the precision-recall curve", "\n", "# increase its length by 1", "\n", "nbPrecRecall", "=", "len", "(", "uniqueIndices", ")", "+", "1", "\n", "\n", "# prepare precision recall", "\n", "nbExamples", "=", "len", "(", "yScoreSorted", ")", "\n", "nbTrueExamples", "=", "yTrueSortedCumsum", "[", "-", "1", "]", "\n", "precision", "=", "np", ".", "zeros", "(", "nbPrecRecall", ")", "\n", "recall", "=", "np", ".", "zeros", "(", "nbPrecRecall", ")", "\n", "\n", "# deal with the first point", "\n", "# only thing we need to do, is to append a zero to the cumsum at the end.", "\n", "# an index of -1 uses that zero then", "\n", "yTrueSortedCumsum", "=", "np", ".", "append", "(", "yTrueSortedCumsum", ",", "0", ")", "\n", "\n", "# deal with remaining", "\n", "for", "idxRes", ",", "idxScores", "in", "enumerate", "(", "uniqueIndices", ")", ":", "\n", "                        ", "cumSum", "=", "yTrueSortedCumsum", "[", "idxScores", "-", "1", "]", "\n", "tp", "=", "nbTrueExamples", "-", "cumSum", "\n", "fp", "=", "nbExamples", "-", "idxScores", "-", "tp", "\n", "fn", "=", "cumSum", "+", "hardFns", "\n", "p", "=", "float", "(", "tp", ")", "/", "(", "tp", "+", "fp", ")", "\n", "r", "=", "float", "(", "tp", ")", "/", "(", "tp", "+", "fn", ")", "\n", "precision", "[", "idxRes", "]", "=", "p", "\n", "recall", "[", "idxRes", "]", "=", "r", "\n", "\n", "# first point in curve is artificial", "\n", "", "precision", "[", "-", "1", "]", "=", "1.0", "\n", "recall", "[", "-", "1", "]", "=", "0.0", "\n", "\n", "# compute average of precision-recall curve", "\n", "# integration is performed via zero order, or equivalently step-wise integration", "\n", "# first compute the widths of each step:", "\n", "# use a convolution with appropriate kernel, manually deal with the boundaries first", "\n", "recallForConv", "=", "np", ".", "copy", "(", "recall", ")", "\n", "recallForConv", "=", "np", ".", "append", "(", "recallForConv", "[", "0", "]", ",", "recallForConv", ")", "\n", "recallForConv", "=", "np", ".", "append", "(", "recallForConv", ",", "0.0", ")", "\n", "\n", "stepWidths", "=", "np", ".", "convolve", "(", "recallForConv", ",", "[", "-", "0.5", ",", "0", ",", "0.5", "]", ",", "\"valid\"", ")", "\n", "\n", "# integrate is now simply a dot product", "\n", "apCurrent", "=", "np", ".", "dot", "(", "precision", ",", "stepWidths", ")", "\n", "\n", "", "elif", "haveGt", ":", "\n", "                    ", "apCurrent", "=", "0.0", "\n", "", "else", ":", "\n", "                    ", "apCurrent", "=", "float", "(", "\"nan\"", ")", "\n", "", "ap", "[", "dI", ",", "lI", ",", "oI", "]", "=", "apCurrent", "\n", "\n", "", "", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.computeAverages": [[823, 845], ["numpy.argmin", "numpy.where", "numpy.where", "numpy.nanmean", "numpy.nanmean", "numpy.nanmean", "enumerate", "numpy.isclose", "numpy.isclose", "numpy.average", "numpy.average", "numpy.average"], "function", ["None"], ["", "def", "computeAverages", "(", "aps", ",", "args", ")", ":", "\n", "# max distance index", "\n", "# dInf  = np.argmax( args.distanceThs )", "\n", "# d50m  = np.where( np.isclose( args.distanceThs ,  50. ) )", "\n", "# d100m = np.where( np.isclose( args.distanceThs , 100. ) )", "\n", "    ", "dInf", "=", "np", ".", "argmin", "(", "args", ".", "minRegionSizes", ")", "\n", "o50", "=", "np", ".", "where", "(", "np", ".", "isclose", "(", "args", ".", "overlaps", ",", "0.5", ")", ")", "\n", "o75", "=", "np", ".", "where", "(", "np", ".", "isclose", "(", "args", ".", "overlaps", ",", "0.75", ")", ")", "\n", "\n", "avgDict", "=", "{", "}", "\n", "avgDict", "[", "\"allAp\"", "]", "=", "np", ".", "nanmean", "(", "aps", "[", "dInf", ",", ":", ",", ":", "]", ")", "\n", "avgDict", "[", "\"allAp50%\"", "]", "=", "np", ".", "nanmean", "(", "aps", "[", "dInf", ",", ":", ",", "o50", "]", ")", "\n", "avgDict", "[", "\"allAp75%\"", "]", "=", "np", ".", "nanmean", "(", "aps", "[", "dInf", ",", ":", ",", "o75", "]", ")", "\n", "\n", "avgDict", "[", "\"classes\"", "]", "=", "{", "}", "\n", "for", "(", "lI", ",", "labelName", ")", "in", "enumerate", "(", "args", ".", "instLabels", ")", ":", "\n", "        ", "avgDict", "[", "\"classes\"", "]", "[", "labelName", "]", "=", "{", "}", "\n", "avgDict", "[", "\"classes\"", "]", "[", "labelName", "]", "[", "\"ap\"", "]", "=", "np", ".", "average", "(", "aps", "[", "dInf", ",", "lI", ",", ":", "]", ")", "\n", "avgDict", "[", "\"classes\"", "]", "[", "labelName", "]", "[", "\"ap50%\"", "]", "=", "np", ".", "average", "(", "aps", "[", "dInf", ",", "lI", ",", "o50", "]", ")", "\n", "avgDict", "[", "\"classes\"", "]", "[", "labelName", "]", "[", "\"ap75%\"", "]", "=", "np", ".", "average", "(", "aps", "[", "dInf", ",", "lI", ",", "o75", "]", ")", "\n", "\n", "", "return", "avgDict", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.printResults": [[847, 898], ["io.StringIO", "contextlib.redirect_stdout", "print", "print", "enumerate", "print", "print", "io.StringIO.getvalue", "print", "print", "print", "print", "cityscapesscripts.helpers.csHelpers.getColorEntry", "cityscapesscripts.helpers.csHelpers.getColorEntry", "cityscapesscripts.helpers.csHelpers.getColorEntry", "cityscapesscripts.helpers.csHelpers.getColorEntry", "cityscapesscripts.helpers.csHelpers.getColorEntry", "cityscapesscripts.helpers.csHelpers.getColorEntry"], "function", ["None"], ["", "def", "printResults", "(", "avgDict", ",", "args", ")", ":", "\n", "    ", "strbuffer", "=", "io", ".", "StringIO", "(", ")", "\n", "# redirect all the print functions to a string buffer", "\n", "with", "redirect_stdout", "(", "strbuffer", ")", ":", "\n", "\n", "        ", "sep", "=", "\",\"", "if", "args", ".", "csv", "else", "\"\"", "\n", "col1", "=", "\":\"", "if", "not", "args", ".", "csv", "else", "\"\"", "\n", "noCol", "=", "colors", ".", "ENDC", "if", "args", ".", "colorized", "else", "\"\"", "\n", "bold", "=", "colors", ".", "BOLD", "if", "args", ".", "colorized", "else", "\"\"", "\n", "lineLen", "=", "65", "\n", "\n", "print", "(", "\"\"", ")", "\n", "if", "not", "args", ".", "csv", ":", "\n", "            ", "print", "(", "\"#\"", "*", "lineLen", ")", "\n", "", "line", "=", "bold", "\n", "line", "+=", "\"{:<15}\"", ".", "format", "(", "\"what\"", ")", "+", "sep", "+", "col1", "\n", "line", "+=", "\"{:>15}\"", ".", "format", "(", "\"AP\"", ")", "+", "sep", "\n", "line", "+=", "\"{:>15}\"", ".", "format", "(", "\"AP_50%\"", ")", "+", "sep", "\n", "line", "+=", "\"{:>15}\"", ".", "format", "(", "\"AP_75%\"", ")", "+", "sep", "\n", "line", "+=", "noCol", "\n", "print", "(", "line", ")", "\n", "if", "not", "args", ".", "csv", ":", "\n", "            ", "print", "(", "\"#\"", "*", "lineLen", ")", "\n", "\n", "", "for", "(", "lI", ",", "labelName", ")", "in", "enumerate", "(", "args", ".", "instLabels", ")", ":", "\n", "            ", "apAvg", "=", "avgDict", "[", "\"classes\"", "]", "[", "labelName", "]", "[", "\"ap\"", "]", "\n", "ap50o", "=", "avgDict", "[", "\"classes\"", "]", "[", "labelName", "]", "[", "\"ap50%\"", "]", "\n", "ap75o", "=", "avgDict", "[", "\"classes\"", "]", "[", "labelName", "]", "[", "\"ap75%\"", "]", "\n", "\n", "line", "=", "\"{:<15}\"", ".", "format", "(", "labelName", ")", "+", "sep", "+", "col1", "\n", "line", "+=", "getColorEntry", "(", "apAvg", ",", "args", ")", "+", "sep", "+", "\"{:>15.3f}\"", ".", "format", "(", "apAvg", ")", "+", "sep", "\n", "line", "+=", "getColorEntry", "(", "ap50o", ",", "args", ")", "+", "sep", "+", "\"{:>15.3f}\"", ".", "format", "(", "ap50o", ")", "+", "sep", "\n", "line", "+=", "getColorEntry", "(", "ap75o", ",", "args", ")", "+", "sep", "+", "\"{:>15.3f}\"", ".", "format", "(", "ap75o", ")", "+", "sep", "\n", "line", "+=", "noCol", "\n", "print", "(", "line", ")", "\n", "\n", "", "allApAvg", "=", "avgDict", "[", "\"allAp\"", "]", "\n", "allAp50o", "=", "avgDict", "[", "\"allAp50%\"", "]", "\n", "allAp75o", "=", "avgDict", "[", "\"allAp75%\"", "]", "\n", "\n", "if", "not", "args", ".", "csv", ":", "\n", "            ", "print", "(", "\"-\"", "*", "lineLen", ")", "\n", "", "line", "=", "\"{:<15}\"", ".", "format", "(", "\"average\"", ")", "+", "sep", "+", "col1", "\n", "line", "+=", "getColorEntry", "(", "allApAvg", ",", "args", ")", "+", "sep", "+", "\"{:>15.3f}\"", ".", "format", "(", "allApAvg", ")", "+", "sep", "\n", "line", "+=", "getColorEntry", "(", "allAp50o", ",", "args", ")", "+", "sep", "+", "\"{:>15.3f}\"", ".", "format", "(", "allAp50o", ")", "+", "sep", "\n", "line", "+=", "getColorEntry", "(", "allAp75o", ",", "args", ")", "+", "sep", "+", "\"{:>15.3f}\"", ".", "format", "(", "allAp75o", ")", "+", "sep", "\n", "line", "+=", "noCol", "\n", "print", "(", "line", ")", "\n", "print", "(", "\"\"", ")", "\n", "\n", "return", "strbuffer", ".", "getvalue", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.eval_instances.prepareJSONDataForResults": [[900, 909], ["args.overlaps.tolist", "args.minRegionSizes.tolist", "aps.tolist"], "function", ["None"], ["", "", "def", "prepareJSONDataForResults", "(", "avgDict", ",", "aps", ",", "args", ")", ":", "\n", "    ", "JSONData", "=", "{", "}", "\n", "JSONData", "[", "\"averages\"", "]", "=", "avgDict", "\n", "JSONData", "[", "\"overlaps\"", "]", "=", "args", ".", "overlaps", ".", "tolist", "(", ")", "\n", "JSONData", "[", "\"minRegionSizes\"", "]", "=", "args", ".", "minRegionSizes", ".", "tolist", "(", ")", "\n", "JSONData", "[", "\"instLabels\"", "]", "=", "args", ".", "instLabels", "\n", "JSONData", "[", "\"resultApMatrix\"", "]", "=", "aps", ".", "tolist", "(", ")", "\n", "\n", "return", "JSONData", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.__init__.abs_cityscapes_evaluation": [[4, 21], ["cityscapes_eval.do_cityscapes_evaluation"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.cityscapes_eval.do_cityscapes_evaluation"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.instances2dict_with_polygons.instances2dict_with_polygons": [[19, 71], ["isinstance", "print", "Image.open", "np.array", "np.unique", "os.path.abspath", "print", "Instance", "Instance.toDict", "instances[].append", "print", "sys.stdout.flush", "len", "vc_rcnn.utils.cv2_util.findContours", "mask.copy", "c.reshape().tolist", "c.reshape"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.cv2_util.findContours"], ["def", "instances2dict_with_polygons", "(", "imageFileList", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "imgCount", "=", "0", "\n", "instanceDict", "=", "{", "}", "\n", "\n", "if", "not", "isinstance", "(", "imageFileList", ",", "list", ")", ":", "\n", "        ", "imageFileList", "=", "[", "imageFileList", "]", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Processing {} images...\"", ".", "format", "(", "len", "(", "imageFileList", ")", ")", ")", "\n", "\n", "", "for", "imageFileName", "in", "imageFileList", ":", "\n", "# Load image", "\n", "        ", "img", "=", "Image", ".", "open", "(", "imageFileName", ")", "\n", "\n", "# Image as numpy array", "\n", "imgNp", "=", "np", ".", "array", "(", "img", ")", "\n", "\n", "# Initialize label categories", "\n", "instances", "=", "{", "}", "\n", "for", "label", "in", "labels", ":", "\n", "            ", "instances", "[", "label", ".", "name", "]", "=", "[", "]", "\n", "\n", "# Loop through all instance ids in instance image", "\n", "", "for", "instanceId", "in", "np", ".", "unique", "(", "imgNp", ")", ":", "\n", "            ", "if", "instanceId", "<", "1000", ":", "\n", "                ", "continue", "\n", "", "instanceObj", "=", "Instance", "(", "imgNp", ",", "instanceId", ")", "\n", "instanceObj_dict", "=", "instanceObj", ".", "toDict", "(", ")", "\n", "\n", "#instances[id2label[instanceObj.labelID].name].append(instanceObj.toDict())", "\n", "if", "id2label", "[", "instanceObj", ".", "labelID", "]", ".", "hasInstances", ":", "\n", "                ", "mask", "=", "(", "imgNp", "==", "instanceId", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "contour", ",", "hier", "=", "cv2_util", ".", "findContours", "(", "\n", "mask", ".", "copy", "(", ")", ",", "cv2", ".", "RETR_EXTERNAL", ",", "cv2", ".", "CHAIN_APPROX_NONE", ")", "\n", "\n", "polygons", "=", "[", "c", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", "for", "c", "in", "contour", "]", "\n", "instanceObj_dict", "[", "'contours'", "]", "=", "polygons", "\n", "\n", "", "instances", "[", "id2label", "[", "instanceObj", ".", "labelID", "]", ".", "name", "]", ".", "append", "(", "instanceObj_dict", ")", "\n", "\n", "", "imgKey", "=", "os", ".", "path", ".", "abspath", "(", "imageFileName", ")", "\n", "instanceDict", "[", "imgKey", "]", "=", "instances", "\n", "imgCount", "+=", "1", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"\\rImages Processed: {}\"", ".", "format", "(", "imgCount", ")", ",", "end", "=", "' '", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "        ", "print", "(", "\"\"", ")", "\n", "\n", "", "return", "instanceDict", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.instances2dict_with_polygons.main": [[72, 79], ["instances2dict_with_polygons.instances2dict_with_polygons", "len", "fileList.append"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.instances2dict_with_polygons.instances2dict_with_polygons"], ["", "def", "main", "(", "argv", ")", ":", "\n", "    ", "fileList", "=", "[", "]", "\n", "if", "(", "len", "(", "argv", ")", ">", "2", ")", ":", "\n", "        ", "for", "arg", "in", "argv", ":", "\n", "            ", "if", "(", "\"png\"", "in", "arg", ")", ":", "\n", "                ", "fileList", ".", "append", "(", "arg", ")", "\n", "", "", "", "instances2dict_with_polygons", "(", "fileList", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.convert_cityscapes_to_coco.parse_args": [[35, 48], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.MCAN_VC.run.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Convert dataset'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "help", "=", "\"cocostuff, cityscapes\"", ",", "default", "=", "None", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--outdir'", ",", "help", "=", "\"output dir for json files\"", ",", "default", "=", "None", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--datadir'", ",", "help", "=", "\"data dir for annotations to be converted\"", ",", "\n", "default", "=", "None", ",", "type", "=", "str", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.convert_cityscapes_to_coco.poly_to_box": [[50, 59], ["min", "max", "min", "max", "min", "max", "min", "max"], "function", ["None"], ["", "def", "poly_to_box", "(", "poly", ")", ":", "\n", "    ", "\"\"\"Convert a polygon into a tight bounding box.\"\"\"", "\n", "x0", "=", "min", "(", "min", "(", "p", "[", ":", ":", "2", "]", ")", "for", "p", "in", "poly", ")", "\n", "x1", "=", "max", "(", "max", "(", "p", "[", ":", ":", "2", "]", ")", "for", "p", "in", "poly", ")", "\n", "y0", "=", "min", "(", "min", "(", "p", "[", "1", ":", ":", "2", "]", ")", "for", "p", "in", "poly", ")", "\n", "y1", "=", "max", "(", "max", "(", "p", "[", "1", ":", ":", "2", "]", ")", "for", "p", "in", "poly", ")", "\n", "box_from_poly", "=", "[", "x0", ",", "y0", ",", "x1", ",", "y1", "]", "\n", "\n", "return", "box_from_poly", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.convert_cityscapes_to_coco.xyxy_to_xywh": [[60, 65], ["None"], "function", ["None"], ["", "def", "xyxy_to_xywh", "(", "xyxy_box", ")", ":", "\n", "    ", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "xyxy_box", "\n", "TO_REMOVE", "=", "1", "\n", "xywh_box", "=", "(", "xmin", ",", "ymin", ",", "xmax", "-", "xmin", "+", "TO_REMOVE", ",", "ymax", "-", "ymin", "+", "TO_REMOVE", ")", "\n", "return", "xywh_box", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.convert_cityscapes_to_coco.convert_coco_stuff_mat": [[67, 105], ["os.path.join", "print", "open", "enumerate", "open", "outfile.write", "img_name.replace().strip.replace().strip", "os.path.join", "h5py.File", "h5py.File.get", "scipy.misc.imsave", "images.append", "len", "os.path.join", "json.dumps", "len", "h5py.File.get", "enumerate", "os.path.join", "img_name.replace().strip.replace", "categories.append", "chr"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["", "def", "convert_coco_stuff_mat", "(", "data_dir", ",", "out_dir", ")", ":", "\n", "    ", "\"\"\"Convert to png and save json with path. This currently only contains\n    the segmentation labels for objects+stuff in cocostuff - if we need to\n    combine with other labels from original COCO that will be a TODO.\"\"\"", "\n", "sets", "=", "[", "'train'", ",", "'val'", "]", "\n", "categories", "=", "[", "]", "\n", "json_name", "=", "'coco_stuff_%s.json'", "\n", "ann_dict", "=", "{", "}", "\n", "for", "data_set", "in", "sets", ":", "\n", "        ", "file_list", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "'%s.txt'", ")", "\n", "images", "=", "[", "]", "\n", "with", "open", "(", "file_list", "%", "data_set", ")", "as", "f", ":", "\n", "            ", "for", "img_id", ",", "img_name", "in", "enumerate", "(", "f", ")", ":", "\n", "                ", "img_name", "=", "img_name", ".", "replace", "(", "'coco'", ",", "'COCO'", ")", ".", "strip", "(", "'\\n'", ")", "\n", "image", "=", "{", "}", "\n", "mat_file", "=", "os", ".", "path", ".", "join", "(", "\n", "data_dir", ",", "'annotations/%s.mat'", "%", "img_name", ")", "\n", "data", "=", "h5py", ".", "File", "(", "mat_file", ",", "'r'", ")", "\n", "labelMap", "=", "data", ".", "get", "(", "'S'", ")", "\n", "if", "len", "(", "categories", ")", "==", "0", ":", "\n", "                    ", "labelNames", "=", "data", ".", "get", "(", "'names'", ")", "\n", "for", "idx", ",", "n", "in", "enumerate", "(", "labelNames", ")", ":", "\n", "                        ", "categories", ".", "append", "(", "\n", "{", "\"id\"", ":", "idx", ",", "\"name\"", ":", "''", ".", "join", "(", "chr", "(", "i", ")", "for", "i", "in", "data", "[", "\n", "n", "[", "0", "]", "]", ")", "}", ")", "\n", "", "ann_dict", "[", "'categories'", "]", "=", "categories", "\n", "", "scipy", ".", "misc", ".", "imsave", "(", "\n", "os", ".", "path", ".", "join", "(", "data_dir", ",", "img_name", "+", "'.png'", ")", ",", "labelMap", ")", "\n", "image", "[", "'width'", "]", "=", "labelMap", ".", "shape", "[", "0", "]", "\n", "image", "[", "'height'", "]", "=", "labelMap", ".", "shape", "[", "1", "]", "\n", "image", "[", "'file_name'", "]", "=", "img_name", "\n", "image", "[", "'seg_file_name'", "]", "=", "img_name", "\n", "image", "[", "'id'", "]", "=", "img_id", "\n", "images", ".", "append", "(", "image", ")", "\n", "", "", "ann_dict", "[", "'images'", "]", "=", "images", "\n", "print", "(", "\"Num images: %s\"", "%", "len", "(", "images", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "out_dir", ",", "json_name", "%", "data_set", ")", ",", "'wb'", ")", "as", "outfile", ":", "\n", "            ", "outfile", ".", "write", "(", "json", ".", "dumps", "(", "ann_dict", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.convert_cityscapes_to_coco.getLabelID": [[108, 113], ["int"], "function", ["None"], ["", "", "", "def", "getLabelID", "(", "self", ",", "instID", ")", ":", "\n", "    ", "if", "(", "instID", "<", "1000", ")", ":", "\n", "        ", "return", "instID", "\n", "", "else", ":", "\n", "        ", "return", "int", "(", "instID", "/", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.convert_cityscapes_to_coco.convert_cityscapes_instance_only": [[115, 228], ["zip", "print", "os.path.join", "os.walk", "print", "print", "print", "open", "outfile.write", "filename.endswith", "len", "len", "len", "os.path.join", "json.dumps", "json.load", "images.append", "os.path.join", "print", "open", "cityscapesscripts.instances2dict_with_polygons", "data_set.split", "len", "os.path.join", "convert_cityscapes_to_coco.poly_to_box", "convert_cityscapes_to_coco.xyxy_to_xywh", "annotations.append", "data_set.split", "print", "len", "min", "print", "len", "len", "len", "len", "data_set.split", "data_set.split"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.instances2dict_with_polygons.instances2dict_with_polygons", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.convert_cityscapes_to_coco.poly_to_box", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cityscapes.convert_cityscapes_to_coco.xyxy_to_xywh"], ["", "", "def", "convert_cityscapes_instance_only", "(", "\n", "data_dir", ",", "out_dir", ")", ":", "\n", "    ", "\"\"\"Convert from cityscapes format to COCO instance seg format - polygons\"\"\"", "\n", "sets", "=", "[", "\n", "'gtFine_val'", ",", "\n", "'gtFine_train'", ",", "\n", "'gtFine_test'", ",", "\n", "\n", "# 'gtCoarse_train',", "\n", "# 'gtCoarse_val',", "\n", "# 'gtCoarse_train_extra'", "\n", "]", "\n", "ann_dirs", "=", "[", "\n", "'gtFine_trainvaltest/gtFine/val'", ",", "\n", "'gtFine_trainvaltest/gtFine/train'", ",", "\n", "'gtFine_trainvaltest/gtFine/test'", ",", "\n", "\n", "# 'gtCoarse/train',", "\n", "# 'gtCoarse/train_extra',", "\n", "# 'gtCoarse/val'", "\n", "]", "\n", "json_name", "=", "'instancesonly_filtered_%s.json'", "\n", "ends_in", "=", "'%s_polygons.json'", "\n", "img_id", "=", "0", "\n", "ann_id", "=", "0", "\n", "cat_id", "=", "1", "\n", "category_dict", "=", "{", "}", "\n", "\n", "category_instancesonly", "=", "[", "\n", "'person'", ",", "\n", "'rider'", ",", "\n", "'car'", ",", "\n", "'truck'", ",", "\n", "'bus'", ",", "\n", "'train'", ",", "\n", "'motorcycle'", ",", "\n", "'bicycle'", ",", "\n", "]", "\n", "\n", "for", "data_set", ",", "ann_dir", "in", "zip", "(", "sets", ",", "ann_dirs", ")", ":", "\n", "        ", "print", "(", "'Starting %s'", "%", "data_set", ")", "\n", "ann_dict", "=", "{", "}", "\n", "images", "=", "[", "]", "\n", "annotations", "=", "[", "]", "\n", "ann_dir", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "ann_dir", ")", "\n", "\n", "for", "root", ",", "_", ",", "files", "in", "os", ".", "walk", "(", "ann_dir", ")", ":", "\n", "            ", "for", "filename", "in", "files", ":", "\n", "                ", "if", "filename", ".", "endswith", "(", "ends_in", "%", "data_set", ".", "split", "(", "'_'", ")", "[", "0", "]", ")", ":", "\n", "                    ", "if", "len", "(", "images", ")", "%", "50", "==", "0", ":", "\n", "                        ", "print", "(", "\"Processed %s images, %s annotations\"", "%", "(", "\n", "len", "(", "images", ")", ",", "len", "(", "annotations", ")", ")", ")", "\n", "", "json_ann", "=", "json", ".", "load", "(", "open", "(", "os", ".", "path", ".", "join", "(", "root", ",", "filename", ")", ")", ")", "\n", "image", "=", "{", "}", "\n", "image", "[", "'id'", "]", "=", "img_id", "\n", "img_id", "+=", "1", "\n", "\n", "image", "[", "'width'", "]", "=", "json_ann", "[", "'imgWidth'", "]", "\n", "image", "[", "'height'", "]", "=", "json_ann", "[", "'imgHeight'", "]", "\n", "image", "[", "'file_name'", "]", "=", "filename", "[", ":", "-", "len", "(", "\n", "ends_in", "%", "data_set", ".", "split", "(", "'_'", ")", "[", "0", "]", ")", "]", "+", "'leftImg8bit.png'", "\n", "image", "[", "'seg_file_name'", "]", "=", "filename", "[", ":", "-", "len", "(", "\n", "ends_in", "%", "data_set", ".", "split", "(", "'_'", ")", "[", "0", "]", ")", "]", "+", "'%s_instanceIds.png'", "%", "data_set", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "images", ".", "append", "(", "image", ")", "\n", "\n", "fullname", "=", "os", ".", "path", ".", "join", "(", "root", ",", "image", "[", "'seg_file_name'", "]", ")", "\n", "objects", "=", "cs", ".", "instances2dict_with_polygons", "(", "\n", "[", "fullname", "]", ",", "verbose", "=", "False", ")", "[", "fullname", "]", "\n", "\n", "for", "object_cls", "in", "objects", ":", "\n", "                        ", "if", "object_cls", "not", "in", "category_instancesonly", ":", "\n", "                            ", "continue", "# skip non-instance categories", "\n", "\n", "", "for", "obj", "in", "objects", "[", "object_cls", "]", ":", "\n", "                            ", "if", "obj", "[", "'contours'", "]", "==", "[", "]", ":", "\n", "                                ", "print", "(", "'Warning: empty contours.'", ")", "\n", "continue", "# skip non-instance categories", "\n", "\n", "", "len_p", "=", "[", "len", "(", "p", ")", "for", "p", "in", "obj", "[", "'contours'", "]", "]", "\n", "if", "min", "(", "len_p", ")", "<=", "4", ":", "\n", "                                ", "print", "(", "'Warning: invalid contours.'", ")", "\n", "continue", "# skip non-instance categories", "\n", "\n", "", "ann", "=", "{", "}", "\n", "ann", "[", "'id'", "]", "=", "ann_id", "\n", "ann_id", "+=", "1", "\n", "ann", "[", "'image_id'", "]", "=", "image", "[", "'id'", "]", "\n", "ann", "[", "'segmentation'", "]", "=", "obj", "[", "'contours'", "]", "\n", "\n", "if", "object_cls", "not", "in", "category_dict", ":", "\n", "                                ", "category_dict", "[", "object_cls", "]", "=", "cat_id", "\n", "cat_id", "+=", "1", "\n", "", "ann", "[", "'category_id'", "]", "=", "category_dict", "[", "object_cls", "]", "\n", "ann", "[", "'iscrowd'", "]", "=", "0", "\n", "ann", "[", "'area'", "]", "=", "obj", "[", "'pixelCount'", "]", "\n", "\n", "xyxy_box", "=", "poly_to_box", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "xywh_box", "=", "xyxy_to_xywh", "(", "xyxy_box", ")", "\n", "ann", "[", "'bbox'", "]", "=", "xywh_box", "\n", "\n", "annotations", ".", "append", "(", "ann", ")", "\n", "\n", "", "", "", "", "", "ann_dict", "[", "'images'", "]", "=", "images", "\n", "categories", "=", "[", "{", "\"id\"", ":", "category_dict", "[", "name", "]", ",", "\"name\"", ":", "name", "}", "for", "name", "in", "\n", "category_dict", "]", "\n", "ann_dict", "[", "'categories'", "]", "=", "categories", "\n", "ann_dict", "[", "'annotations'", "]", "=", "annotations", "\n", "print", "(", "\"Num categories: %s\"", "%", "len", "(", "categories", ")", ")", "\n", "print", "(", "\"Num images: %s\"", "%", "len", "(", "images", ")", ")", "\n", "print", "(", "\"Num annotations: %s\"", "%", "len", "(", "annotations", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "out_dir", ",", "json_name", "%", "data_set", ")", ",", "'w'", ")", "as", "outfile", ":", "\n", "            ", "outfile", ".", "write", "(", "json", ".", "dumps", "(", "ann_dict", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.__init__": [[343, 352], ["all", "collections.OrderedDict", "collections.OrderedDict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "*", "iou_types", ")", ":", "\n", "        ", "allowed_types", "=", "(", "\"box_proposal\"", ",", "\"bbox\"", ",", "\"segm\"", ",", "\"keypoints\"", ")", "\n", "assert", "all", "(", "iou_type", "in", "allowed_types", "for", "iou_type", "in", "iou_types", ")", "\n", "results", "=", "OrderedDict", "(", ")", "\n", "for", "iou_type", "in", "iou_types", ":", "\n", "            ", "results", "[", "iou_type", "]", "=", "OrderedDict", "(", "\n", "[", "(", "metric", ",", "-", "1", ")", "for", "metric", "in", "COCOResults", ".", "METRICS", "[", "iou_type", "]", "]", "\n", ")", "\n", "", "self", ".", "results", "=", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update": [[353, 365], ["isinstance", "enumerate"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "coco_eval", ")", ":", "\n", "        ", "if", "coco_eval", "is", "None", ":", "\n", "            ", "return", "\n", "", "from", "pycocotools", ".", "cocoeval", "import", "COCOeval", "\n", "\n", "assert", "isinstance", "(", "coco_eval", ",", "COCOeval", ")", "\n", "s", "=", "coco_eval", ".", "stats", "\n", "iou_type", "=", "coco_eval", ".", "params", ".", "iouType", "\n", "res", "=", "self", ".", "results", "[", "iou_type", "]", "\n", "metrics", "=", "COCOResults", ".", "METRICS", "[", "iou_type", "]", "\n", "for", "idx", ",", "metric", "in", "enumerate", "(", "metrics", ")", ":", "\n", "            ", "res", "[", "metric", "]", "=", "s", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.__repr__": [[366, 375], ["coco_eval.COCOResults.results.items", "metrics.keys", "metrics.values"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "results", "=", "'\\n'", "\n", "for", "task", ",", "metrics", "in", "self", ".", "results", ".", "items", "(", ")", ":", "\n", "            ", "results", "+=", "'Task: {}\\n'", ".", "format", "(", "task", ")", "\n", "metric_names", "=", "metrics", ".", "keys", "(", ")", "\n", "metric_vals", "=", "[", "'{:.4f}'", ".", "format", "(", "v", ")", "for", "v", "in", "metrics", ".", "values", "(", ")", "]", "\n", "results", "+=", "(", "', '", ".", "join", "(", "metric_names", ")", "+", "'\\n'", ")", "\n", "results", "+=", "(", "', '", ".", "join", "(", "metric_vals", ")", "+", "'\\n'", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.do_coco_evaluation": [[13, 68], ["logging.getLogger", "logging.getLogger.info", "coco_eval.COCOResults", "logging.getLogger.info", "logging.getLogger.info", "coco_eval.check_expected_results", "logging.getLogger.info", "coco_eval.COCOResults", "logging.getLogger.info", "coco_eval.check_expected_results", "logging.getLogger.info", "coco_eval.prepare_for_coco_detection", "logging.getLogger.info", "coco_eval.prepare_for_coco_segmentation", "logging.getLogger.info", "coco_eval.prepare_for_coco_keypoint", "torch.save", "areas.items", "torch.save", "tempfile.NamedTemporaryFile", "coco_eval.evaluate_predictions_on_coco", "coco_eval.COCOResults.update", "os.path.join", "coco_eval.evaluate_box_proposals", "stats[].item", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.check_expected_results", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.check_expected_results", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.prepare_for_coco_detection", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.prepare_for_coco_segmentation", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.prepare_for_coco_keypoint", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.evaluate_predictions_on_coco", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.evaluate_box_proposals"], ["def", "do_coco_evaluation", "(", "\n", "dataset", ",", "\n", "predictions", ",", "\n", "box_only", ",", "\n", "output_folder", ",", "\n", "iou_types", ",", "\n", "expected_results", ",", "\n", "expected_results_sigma_tol", ",", "\n", ")", ":", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "\"vc_rcnn.inference\"", ")", "\n", "\n", "if", "box_only", ":", "\n", "        ", "logger", ".", "info", "(", "\"Evaluating bbox proposals\"", ")", "\n", "areas", "=", "{", "\"all\"", ":", "\"\"", ",", "\"small\"", ":", "\"s\"", ",", "\"medium\"", ":", "\"m\"", ",", "\"large\"", ":", "\"l\"", "}", "\n", "res", "=", "COCOResults", "(", "\"box_proposal\"", ")", "\n", "for", "limit", "in", "[", "100", ",", "1000", "]", ":", "\n", "            ", "for", "area", ",", "suffix", "in", "areas", ".", "items", "(", ")", ":", "\n", "                ", "stats", "=", "evaluate_box_proposals", "(", "\n", "predictions", ",", "dataset", ",", "area", "=", "area", ",", "limit", "=", "limit", "\n", ")", "\n", "key", "=", "\"AR{}@{:d}\"", ".", "format", "(", "suffix", ",", "limit", ")", "\n", "res", ".", "results", "[", "\"box_proposal\"", "]", "[", "key", "]", "=", "stats", "[", "\"ar\"", "]", ".", "item", "(", ")", "\n", "", "", "logger", ".", "info", "(", "res", ")", "\n", "check_expected_results", "(", "res", ",", "expected_results", ",", "expected_results_sigma_tol", ")", "\n", "if", "output_folder", ":", "\n", "            ", "torch", ".", "save", "(", "res", ",", "os", ".", "path", ".", "join", "(", "output_folder", ",", "\"box_proposals.pth\"", ")", ")", "\n", "", "return", "\n", "", "logger", ".", "info", "(", "\"Preparing results for COCO format\"", ")", "\n", "coco_results", "=", "{", "}", "\n", "if", "\"bbox\"", "in", "iou_types", ":", "\n", "        ", "logger", ".", "info", "(", "\"Preparing bbox results\"", ")", "\n", "coco_results", "[", "\"bbox\"", "]", "=", "prepare_for_coco_detection", "(", "predictions", ",", "dataset", ")", "\n", "", "if", "\"segm\"", "in", "iou_types", ":", "\n", "        ", "logger", ".", "info", "(", "\"Preparing segm results\"", ")", "\n", "coco_results", "[", "\"segm\"", "]", "=", "prepare_for_coco_segmentation", "(", "predictions", ",", "dataset", ")", "\n", "", "if", "'keypoints'", "in", "iou_types", ":", "\n", "        ", "logger", ".", "info", "(", "'Preparing keypoints results'", ")", "\n", "coco_results", "[", "'keypoints'", "]", "=", "prepare_for_coco_keypoint", "(", "predictions", ",", "dataset", ")", "\n", "\n", "", "results", "=", "COCOResults", "(", "*", "iou_types", ")", "\n", "logger", ".", "info", "(", "\"Evaluating predictions\"", ")", "\n", "for", "iou_type", "in", "iou_types", ":", "\n", "        ", "with", "tempfile", ".", "NamedTemporaryFile", "(", ")", "as", "f", ":", "\n", "            ", "file_path", "=", "f", ".", "name", "\n", "if", "output_folder", ":", "\n", "                ", "file_path", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "iou_type", "+", "\".json\"", ")", "\n", "", "res", "=", "evaluate_predictions_on_coco", "(", "\n", "dataset", ".", "coco", ",", "coco_results", "[", "iou_type", "]", ",", "file_path", ",", "iou_type", "\n", ")", "\n", "results", ".", "update", "(", "res", ")", "\n", "", "", "logger", ".", "info", "(", "results", ")", "\n", "check_expected_results", "(", "results", ",", "expected_results", ",", "expected_results_sigma_tol", ")", "\n", "if", "output_folder", ":", "\n", "        ", "torch", ".", "save", "(", "results", ",", "os", ".", "path", ".", "join", "(", "output_folder", ",", "\"coco_results.pth\"", ")", ")", "\n", "", "return", "results", ",", "coco_results", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.prepare_for_coco_detection": [[70, 102], ["enumerate", "dataset.get_img_info", "prediction.convert.resize", "prediction.convert.convert", "prediction.convert.bbox.tolist", "prediction.convert.get_field().tolist", "prediction.convert.get_field().tolist", "coco_results.extend", "len", "prediction.convert.get_field", "prediction.convert.get_field", "enumerate"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "prepare_for_coco_detection", "(", "predictions", ",", "dataset", ")", ":", "\n", "# assert isinstance(dataset, COCODataset)", "\n", "    ", "coco_results", "=", "[", "]", "\n", "for", "image_id", ",", "prediction", "in", "enumerate", "(", "predictions", ")", ":", "\n", "        ", "original_id", "=", "dataset", ".", "id_to_img_map", "[", "image_id", "]", "\n", "if", "len", "(", "prediction", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "img_info", "=", "dataset", ".", "get_img_info", "(", "image_id", ")", "\n", "image_width", "=", "img_info", "[", "\"width\"", "]", "\n", "image_height", "=", "img_info", "[", "\"height\"", "]", "\n", "prediction", "=", "prediction", ".", "resize", "(", "(", "image_width", ",", "image_height", ")", ")", "\n", "prediction", "=", "prediction", ".", "convert", "(", "\"xywh\"", ")", "\n", "\n", "boxes", "=", "prediction", ".", "bbox", ".", "tolist", "(", ")", "\n", "scores", "=", "prediction", ".", "get_field", "(", "\"scores\"", ")", ".", "tolist", "(", ")", "\n", "labels", "=", "prediction", ".", "get_field", "(", "\"labels\"", ")", ".", "tolist", "(", ")", "\n", "\n", "mapped_labels", "=", "[", "dataset", ".", "contiguous_category_id_to_json_id", "[", "i", "]", "for", "i", "in", "labels", "]", "\n", "\n", "coco_results", ".", "extend", "(", "\n", "[", "\n", "{", "\n", "\"image_id\"", ":", "original_id", ",", "\n", "\"category_id\"", ":", "mapped_labels", "[", "k", "]", ",", "\n", "\"bbox\"", ":", "box", ",", "\n", "\"score\"", ":", "scores", "[", "k", "]", ",", "\n", "}", "\n", "for", "k", ",", "box", "in", "enumerate", "(", "boxes", ")", "\n", "]", "\n", ")", "\n", "", "return", "coco_results", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.prepare_for_coco_segmentation": [[104, 156], ["vc_rcnn.modeling.roi_heads.mask_head.inference.Masker", "tqdm.tqdm", "enumerate", "dataset.get_img_info", "prediction.resize.resize", "prediction.resize.get_field", "prediction.resize.get_field().tolist", "prediction.resize.get_field().tolist", "coco_results.extend", "len", "list", "vc_rcnn.modeling.roi_heads.mask_head.inference.Masker.", "rle[].decode", "masker.expand", "prediction.resize.get_field", "prediction.resize.get_field", "mask_util.encode", "np.array", "enumerate"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode"], ["", "def", "prepare_for_coco_segmentation", "(", "predictions", ",", "dataset", ")", ":", "\n", "    ", "import", "pycocotools", ".", "mask", "as", "mask_util", "\n", "import", "numpy", "as", "np", "\n", "\n", "masker", "=", "Masker", "(", "threshold", "=", "0.5", ",", "padding", "=", "1", ")", "\n", "# assert isinstance(dataset, COCODataset)", "\n", "coco_results", "=", "[", "]", "\n", "for", "image_id", ",", "prediction", "in", "tqdm", "(", "enumerate", "(", "predictions", ")", ")", ":", "\n", "        ", "original_id", "=", "dataset", ".", "id_to_img_map", "[", "image_id", "]", "\n", "if", "len", "(", "prediction", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "img_info", "=", "dataset", ".", "get_img_info", "(", "image_id", ")", "\n", "image_width", "=", "img_info", "[", "\"width\"", "]", "\n", "image_height", "=", "img_info", "[", "\"height\"", "]", "\n", "prediction", "=", "prediction", ".", "resize", "(", "(", "image_width", ",", "image_height", ")", ")", "\n", "masks", "=", "prediction", ".", "get_field", "(", "\"mask\"", ")", "\n", "# t = time.time()", "\n", "# Masker is necessary only if masks haven't been already resized.", "\n", "if", "list", "(", "masks", ".", "shape", "[", "-", "2", ":", "]", ")", "!=", "[", "image_height", ",", "image_width", "]", ":", "\n", "            ", "masks", "=", "masker", "(", "masks", ".", "expand", "(", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ")", ",", "prediction", ")", "\n", "masks", "=", "masks", "[", "0", "]", "\n", "# logger.info('Time mask: {}'.format(time.time() - t))", "\n", "# prediction = prediction.convert('xywh')", "\n", "\n", "# boxes = prediction.bbox.tolist()", "\n", "", "scores", "=", "prediction", ".", "get_field", "(", "\"scores\"", ")", ".", "tolist", "(", ")", "\n", "labels", "=", "prediction", ".", "get_field", "(", "\"labels\"", ")", ".", "tolist", "(", ")", "\n", "\n", "# rles = prediction.get_field('mask')", "\n", "\n", "rles", "=", "[", "\n", "mask_util", ".", "encode", "(", "np", ".", "array", "(", "mask", "[", "0", ",", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "order", "=", "\"F\"", ")", ")", "[", "0", "]", "\n", "for", "mask", "in", "masks", "\n", "]", "\n", "for", "rle", "in", "rles", ":", "\n", "            ", "rle", "[", "\"counts\"", "]", "=", "rle", "[", "\"counts\"", "]", ".", "decode", "(", "\"utf-8\"", ")", "\n", "\n", "", "mapped_labels", "=", "[", "dataset", ".", "contiguous_category_id_to_json_id", "[", "i", "]", "for", "i", "in", "labels", "]", "\n", "\n", "coco_results", ".", "extend", "(", "\n", "[", "\n", "{", "\n", "\"image_id\"", ":", "original_id", ",", "\n", "\"category_id\"", ":", "mapped_labels", "[", "k", "]", ",", "\n", "\"segmentation\"", ":", "rle", ",", "\n", "\"score\"", ":", "scores", "[", "k", "]", ",", "\n", "}", "\n", "for", "k", ",", "rle", "in", "enumerate", "(", "rles", ")", "\n", "]", "\n", ")", "\n", "", "return", "coco_results", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.prepare_for_coco_keypoint": [[158, 187], ["enumerate", "prediction.convert.resize", "prediction.convert.convert", "prediction.convert.bbox.tolist", "prediction.convert.get_field().tolist", "prediction.convert.get_field().tolist", "prediction.convert.get_field", "keypoints.keypoints.view().tolist.resize", "keypoints.keypoints.view().tolist.keypoints.view().tolist", "coco_results.extend", "len", "prediction.convert.get_field", "prediction.convert.get_field", "keypoints.keypoints.view().tolist.keypoints.view", "enumerate"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "prepare_for_coco_keypoint", "(", "predictions", ",", "dataset", ")", ":", "\n", "# assert isinstance(dataset, COCODataset)", "\n", "    ", "coco_results", "=", "[", "]", "\n", "for", "image_id", ",", "prediction", "in", "enumerate", "(", "predictions", ")", ":", "\n", "        ", "original_id", "=", "dataset", ".", "id_to_img_map", "[", "image_id", "]", "\n", "if", "len", "(", "prediction", ".", "bbox", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "# TODO replace with get_img_info?", "\n", "", "image_width", "=", "dataset", ".", "coco", ".", "imgs", "[", "original_id", "]", "[", "'width'", "]", "\n", "image_height", "=", "dataset", ".", "coco", ".", "imgs", "[", "original_id", "]", "[", "'height'", "]", "\n", "prediction", "=", "prediction", ".", "resize", "(", "(", "image_width", ",", "image_height", ")", ")", "\n", "prediction", "=", "prediction", ".", "convert", "(", "'xywh'", ")", "\n", "\n", "boxes", "=", "prediction", ".", "bbox", ".", "tolist", "(", ")", "\n", "scores", "=", "prediction", ".", "get_field", "(", "'scores'", ")", ".", "tolist", "(", ")", "\n", "labels", "=", "prediction", ".", "get_field", "(", "'labels'", ")", ".", "tolist", "(", ")", "\n", "keypoints", "=", "prediction", ".", "get_field", "(", "'keypoints'", ")", "\n", "keypoints", "=", "keypoints", ".", "resize", "(", "(", "image_width", ",", "image_height", ")", ")", "\n", "keypoints", "=", "keypoints", ".", "keypoints", ".", "view", "(", "keypoints", ".", "keypoints", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ".", "tolist", "(", ")", "\n", "\n", "mapped_labels", "=", "[", "dataset", ".", "contiguous_category_id_to_json_id", "[", "i", "]", "for", "i", "in", "labels", "]", "\n", "\n", "coco_results", ".", "extend", "(", "[", "{", "\n", "'image_id'", ":", "original_id", ",", "\n", "'category_id'", ":", "mapped_labels", "[", "k", "]", ",", "\n", "'keypoints'", ":", "keypoint", ",", "\n", "'score'", ":", "scores", "[", "k", "]", "}", "for", "k", ",", "keypoint", "in", "enumerate", "(", "keypoints", ")", "]", ")", "\n", "", "return", "coco_results", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.evaluate_box_proposals": [[189, 302], ["enumerate", "torch.cat", "torch.sort", "torch.zeros_like", "enumerate", "torch.zeros_like.mean", "dataset.get_img_info", "prediction.resize.resize", "dataset.coco.getAnnIds", "dataset.coco.loadAnns", "torch.as_tensor().reshape", "vc_rcnn.structures.bounding_box.BoxList().convert", "torch.as_tensor", "len", "vc_rcnn.structures.boxlist_ops.boxlist_iou", "torch.zeros", "range", "torch.cat.append", "torch.arange", "prediction.resize.get_field().sort", "len", "len", "len", "len", "min", "vc_rcnn.structures.boxlist_ops.boxlist_iou.max", "max_overlaps.max", "float", "torch.as_tensor", "vc_rcnn.structures.bounding_box.BoxList", "len", "len", "len", "prediction.resize.get_field"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_iou", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "evaluate_box_proposals", "(", "\n", "predictions", ",", "dataset", ",", "thresholds", "=", "None", ",", "area", "=", "\"all\"", ",", "limit", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"Evaluate detection proposal recall metrics. This function is a much\n    faster alternative to the official COCO API recall evaluation code. However,\n    it produces slightly different results.\n    \"\"\"", "\n", "# Record max overlap value for each gt box", "\n", "# Return vector of overlap values", "\n", "areas", "=", "{", "\n", "\"all\"", ":", "0", ",", "\n", "\"small\"", ":", "1", ",", "\n", "\"medium\"", ":", "2", ",", "\n", "\"large\"", ":", "3", ",", "\n", "\"96-128\"", ":", "4", ",", "\n", "\"128-256\"", ":", "5", ",", "\n", "\"256-512\"", ":", "6", ",", "\n", "\"512-inf\"", ":", "7", ",", "\n", "}", "\n", "area_ranges", "=", "[", "\n", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "# all", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "# small", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "# medium", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "# large", "\n", "[", "96", "**", "2", ",", "128", "**", "2", "]", ",", "# 96-128", "\n", "[", "128", "**", "2", ",", "256", "**", "2", "]", ",", "# 128-256", "\n", "[", "256", "**", "2", ",", "512", "**", "2", "]", ",", "# 256-512", "\n", "[", "512", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "]", "# 512-inf", "\n", "assert", "area", "in", "areas", ",", "\"Unknown area range: {}\"", ".", "format", "(", "area", ")", "\n", "area_range", "=", "area_ranges", "[", "areas", "[", "area", "]", "]", "\n", "gt_overlaps", "=", "[", "]", "\n", "num_pos", "=", "0", "\n", "\n", "for", "image_id", ",", "prediction", "in", "enumerate", "(", "predictions", ")", ":", "\n", "        ", "original_id", "=", "dataset", ".", "id_to_img_map", "[", "image_id", "]", "\n", "\n", "img_info", "=", "dataset", ".", "get_img_info", "(", "image_id", ")", "\n", "image_width", "=", "img_info", "[", "\"width\"", "]", "\n", "image_height", "=", "img_info", "[", "\"height\"", "]", "\n", "prediction", "=", "prediction", ".", "resize", "(", "(", "image_width", ",", "image_height", ")", ")", "\n", "\n", "# sort predictions in descending order", "\n", "# TODO maybe remove this and make it explicit in the documentation", "\n", "inds", "=", "prediction", ".", "get_field", "(", "\"objectness\"", ")", ".", "sort", "(", "descending", "=", "True", ")", "[", "1", "]", "\n", "prediction", "=", "prediction", "[", "inds", "]", "\n", "\n", "ann_ids", "=", "dataset", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "original_id", ")", "\n", "anno", "=", "dataset", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "gt_boxes", "=", "[", "obj", "[", "\"bbox\"", "]", "for", "obj", "in", "anno", "if", "obj", "[", "\"iscrowd\"", "]", "==", "0", "]", "\n", "gt_boxes", "=", "torch", ".", "as_tensor", "(", "gt_boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "# guard against no boxes", "\n", "gt_boxes", "=", "BoxList", "(", "gt_boxes", ",", "(", "image_width", ",", "image_height", ")", ",", "mode", "=", "\"xywh\"", ")", ".", "convert", "(", "\n", "\"xyxy\"", "\n", ")", "\n", "gt_areas", "=", "torch", ".", "as_tensor", "(", "[", "obj", "[", "\"area\"", "]", "for", "obj", "in", "anno", "if", "obj", "[", "\"iscrowd\"", "]", "==", "0", "]", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "valid_gt_inds", "=", "(", "gt_areas", ">=", "area_range", "[", "0", "]", ")", "&", "(", "gt_areas", "<=", "area_range", "[", "1", "]", ")", "\n", "gt_boxes", "=", "gt_boxes", "[", "valid_gt_inds", "]", "\n", "\n", "num_pos", "+=", "len", "(", "gt_boxes", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "len", "(", "prediction", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "limit", "is", "not", "None", "and", "len", "(", "prediction", ")", ">", "limit", ":", "\n", "            ", "prediction", "=", "prediction", "[", ":", "limit", "]", "\n", "\n", "", "overlaps", "=", "boxlist_iou", "(", "prediction", ",", "gt_boxes", ")", "\n", "\n", "_gt_overlaps", "=", "torch", ".", "zeros", "(", "len", "(", "gt_boxes", ")", ")", "\n", "for", "j", "in", "range", "(", "min", "(", "len", "(", "prediction", ")", ",", "len", "(", "gt_boxes", ")", ")", ")", ":", "\n", "# find which proposal box maximally covers each gt box", "\n", "# and get the iou amount of coverage for each gt box", "\n", "            ", "max_overlaps", ",", "argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "# find which gt box is 'best' covered (i.e. 'best' = most iou)", "\n", "gt_ovr", ",", "gt_ind", "=", "max_overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "assert", "gt_ovr", ">=", "0", "\n", "# find the proposal box that covers the best covered gt box", "\n", "box_ind", "=", "argmax_overlaps", "[", "gt_ind", "]", "\n", "# record the iou coverage of this gt box", "\n", "_gt_overlaps", "[", "j", "]", "=", "overlaps", "[", "box_ind", ",", "gt_ind", "]", "\n", "assert", "_gt_overlaps", "[", "j", "]", "==", "gt_ovr", "\n", "# mark the proposal box and the gt box as used", "\n", "overlaps", "[", "box_ind", ",", ":", "]", "=", "-", "1", "\n", "overlaps", "[", ":", ",", "gt_ind", "]", "=", "-", "1", "\n", "\n", "# append recorded iou coverage level", "\n", "", "gt_overlaps", ".", "append", "(", "_gt_overlaps", ")", "\n", "", "gt_overlaps", "=", "torch", ".", "cat", "(", "gt_overlaps", ",", "dim", "=", "0", ")", "\n", "gt_overlaps", ",", "_", "=", "torch", ".", "sort", "(", "gt_overlaps", ")", "\n", "\n", "if", "thresholds", "is", "None", ":", "\n", "        ", "step", "=", "0.05", "\n", "thresholds", "=", "torch", ".", "arange", "(", "0.5", ",", "0.95", "+", "1e-5", ",", "step", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "recalls", "=", "torch", ".", "zeros_like", "(", "thresholds", ")", "\n", "# compute recall for each iou threshold", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "        ", "recalls", "[", "i", "]", "=", "(", "gt_overlaps", ">=", "t", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "/", "float", "(", "num_pos", ")", "\n", "# ar = 2 * np.trapz(recalls, thresholds)", "\n", "", "ar", "=", "recalls", ".", "mean", "(", ")", "\n", "return", "{", "\n", "\"ar\"", ":", "ar", ",", "\n", "\"recalls\"", ":", "recalls", ",", "\n", "\"thresholds\"", ":", "thresholds", ",", "\n", "\"gt_overlaps\"", ":", "gt_overlaps", ",", "\n", "\"num_pos\"", ":", "num_pos", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.evaluate_predictions_on_coco": [[305, 324], ["COCOeval", "COCOeval.evaluate", "COCOeval.accumulate", "COCOeval.summarize", "open", "json.dump", "coco_gt.loadRes", "COCO", "str"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.evaluation.__init__.evaluate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.loadRes"], ["", "def", "evaluate_predictions_on_coco", "(", "\n", "coco_gt", ",", "coco_results", ",", "json_result_file", ",", "iou_type", "=", "\"bbox\"", "\n", ")", ":", "\n", "    ", "import", "json", "\n", "\n", "with", "open", "(", "json_result_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "coco_results", ",", "f", ")", "\n", "\n", "", "from", "pycocotools", ".", "coco", "import", "COCO", "\n", "from", "pycocotools", ".", "cocoeval", "import", "COCOeval", "\n", "\n", "coco_dt", "=", "coco_gt", ".", "loadRes", "(", "str", "(", "json_result_file", ")", ")", "if", "coco_results", "else", "COCO", "(", ")", "\n", "\n", "# coco_dt = coco_gt.loadRes(coco_results)", "\n", "coco_eval", "=", "COCOeval", "(", "coco_gt", ",", "coco_dt", ",", "iou_type", ")", "\n", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "coco_eval", ".", "summarize", "(", ")", "\n", "return", "coco_eval", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.check_expected_results": [[377, 397], ["logging.getLogger", "logging.getLogger.error", "logging.getLogger.info"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info"], ["", "", "def", "check_expected_results", "(", "results", ",", "expected_results", ",", "sigma_tol", ")", ":", "\n", "    ", "if", "not", "expected_results", ":", "\n", "        ", "return", "\n", "\n", "", "logger", "=", "logging", ".", "getLogger", "(", "\"vc_rcnn.inference\"", ")", "\n", "for", "task", ",", "metric", ",", "(", "mean", ",", "std", ")", "in", "expected_results", ":", "\n", "        ", "actual_val", "=", "results", ".", "results", "[", "task", "]", "[", "metric", "]", "\n", "lo", "=", "mean", "-", "sigma_tol", "*", "std", "\n", "hi", "=", "mean", "+", "sigma_tol", "*", "std", "\n", "ok", "=", "(", "lo", "<", "actual_val", ")", "and", "(", "actual_val", "<", "hi", ")", "\n", "msg", "=", "(", "\n", "\"{} > {} sanity check (actual vs. expected): \"", "\n", "\"{:.3f} vs. mean={:.4f}, std={:.4}, range=({:.4f}, {:.4f})\"", "\n", ")", ".", "format", "(", "task", ",", "metric", ",", "actual_val", ",", "mean", ",", "std", ",", "lo", ",", "hi", ")", "\n", "if", "not", "ok", ":", "\n", "            ", "msg", "=", "\"FAIL: \"", "+", "msg", "\n", "logger", ".", "error", "(", "msg", ")", "\n", "", "else", ":", "\n", "            ", "msg", "=", "\"PASS: \"", "+", "msg", "\n", "logger", ".", "info", "(", "msg", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval_wrapper.do_coco_evaluation": [[13, 49], ["logging.getLogger", "logging.getLogger.info", "abs_to_coco.convert_abstract_to_coco", "os.path.join", "logging.getLogger.info", "logging.getLogger.info", "vc_rcnn.data.datasets.coco.COCODataset", "coco_eval.do_coco_evaluation", "open", "json.dump"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.abs_to_coco.convert_abstract_to_coco", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval_wrapper.do_coco_evaluation"], ["def", "do_coco_evaluation", "(", "\n", "dataset", ",", "\n", "predictions", ",", "\n", "box_only", ",", "\n", "output_folder", ",", "\n", "iou_types", ",", "\n", "expected_results", ",", "\n", "expected_results_sigma_tol", ",", "\n", ")", ":", "\n", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "\"vc_rcnn.inference\"", ")", "\n", "logger", ".", "info", "(", "\"Converting annotations to COCO format...\"", ")", "\n", "coco_annotation_dict", "=", "convert_abstract_to_coco", "(", "dataset", ")", "\n", "\n", "dataset_name", "=", "dataset", ".", "__class__", ".", "__name__", "\n", "coco_annotation_path", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "dataset_name", "+", "\".json\"", ")", "\n", "logger", ".", "info", "(", "\"Saving annotations to %s\"", "%", "coco_annotation_path", ")", "\n", "with", "open", "(", "coco_annotation_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "coco_annotation_dict", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "", "logger", ".", "info", "(", "\"Loading annotations as COCODataset\"", ")", "\n", "coco_dataset", "=", "COCODataset", "(", "\n", "ann_file", "=", "coco_annotation_path", ",", "\n", "root", "=", "\"\"", ",", "\n", "remove_images_without_annotations", "=", "False", ",", "\n", "transforms", "=", "None", ",", "# transformations should be already saved to the json", "\n", ")", "\n", "\n", "return", "orig_evaluation", "(", "\n", "dataset", "=", "coco_dataset", ",", "\n", "predictions", "=", "predictions", ",", "\n", "box_only", "=", "box_only", ",", "\n", "output_folder", "=", "output_folder", ",", "\n", "iou_types", "=", "iou_types", ",", "\n", "expected_results", "=", "expected_results", ",", "\n", "expected_results_sigma_tol", "=", "expected_results", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.__init__.coco_evaluation": [[4, 21], ["coco_eval.do_coco_evaluation"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval_wrapper.do_coco_evaluation"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.abs_to_coco.convert_abstract_to_coco": [[18, 102], ["logging.getLogger", "isinstance", "len", "logging.getLogger.info", "enumerate", "logging.getLogger.info", "torch.multiprocessing.cpu_count", "min", "torch.multiprocessing.Pool", "logging.getLogger.info", "datetime.datetime.now", "torch.multiprocessing.cpu_count", "tqdm.tqdm", "pool.imap", "dataset.id_to_name.items", "str", "images.append", "annotations.extend", "progress_bar.update", "range"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update"], ["def", "convert_abstract_to_coco", "(", "dataset", ",", "num_workers", "=", "None", ",", "chunksize", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Convert any dataset derived from AbstractDataset to COCO style\n    for evaluating with the pycocotools lib\n\n    Conversion imitates required fields of COCO instance segmentation\n    ground truth files like: \".../annotations/instances_train2014.json\"\n\n    After th conversion is done a dict is returned that follows the same\n    format as COCO json files.\n\n    By default .coco_eval_wrapper.py saves it to the hard-drive in json format\n    and loads it with the vc_rcnn's default COCODataset\n\n    Args:\n        dataset: any dataset derived from AbstractDataset\n        num_workers (optional): number of worker threads to parallelize the\n            conversion (default is to use all cores for conversion)\n        chunk_size (optional): how many entries one thread processes before\n            requesting new task. The larger the less overhead there is.\n    \"\"\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "\"vc_rcnn.inference\"", ")", "\n", "assert", "isinstance", "(", "dataset", ",", "AbstractDataset", ")", "\n", "# Official COCO annotations have these fields", "\n", "# 'info', 'licenses', 'images', 'type', 'annotations', 'categories'", "\n", "coco_dict", "=", "{", "}", "\n", "coco_dict", "[", "\"info\"", "]", "=", "{", "\n", "\"description\"", ":", "(", "\n", "\"This is an automatically generated COCO annotation\"", "\n", "\" file using vc_rcnn\"", "\n", ")", ",", "\n", "\"date_created\"", ":", "\"%s\"", "%", "datetime", ".", "now", "(", ")", ",", "\n", "}", "\n", "coco_dict", "[", "\"type\"", "]", "=", "\"instances\"", "\n", "\n", "images", "=", "[", "]", "\n", "annotations", "=", "[", "]", "\n", "\n", "if", "num_workers", "is", "None", ":", "\n", "        ", "num_workers", "=", "torch", ".", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "", "else", ":", "\n", "        ", "num_workers", "=", "min", "(", "num_workers", ",", "torch", ".", "multiprocessing", ".", "cpu_count", "(", ")", ")", "\n", "\n", "", "dataset_name", "=", "dataset", ".", "__class__", ".", "__name__", "\n", "num_images", "=", "len", "(", "dataset", ")", "\n", "logger", ".", "info", "(", "\n", "(", "\n", "\"Parsing each entry in \"", "\n", "\"%s, total=%d. \"", "\n", "\"Using N=%d workers and chunksize=%d\"", "\n", ")", "\n", "%", "(", "dataset_name", ",", "num_images", ",", "num_workers", ",", "chunksize", ")", "\n", ")", "\n", "\n", "with", "torch", ".", "multiprocessing", ".", "Pool", "(", "num_workers", ")", "as", "pool", ":", "\n", "        ", "with", "tqdm", "(", "total", "=", "num_images", ")", "as", "progress_bar", ":", "\n", "            ", "args", "=", "[", "(", "dataset", ",", "idx", ")", "for", "idx", "in", "range", "(", "num_images", ")", "]", "\n", "iterator", "=", "pool", ".", "imap", "(", "process_single_image", ",", "args", ",", "chunksize", "=", "100", ")", "\n", "for", "img_annots_pair", "in", "iterator", ":", "\n", "                ", "image", ",", "per_img_annotations", "=", "img_annots_pair", "\n", "\n", "images", ".", "append", "(", "image", ")", "\n", "annotations", ".", "extend", "(", "per_img_annotations", ")", "\n", "progress_bar", ".", "update", "(", ")", "\n", "\n", "", "", "", "for", "ann_id", ",", "ann", "in", "enumerate", "(", "annotations", ",", "1", ")", ":", "\n", "        ", "ann", "[", "\"id\"", "]", "=", "ann_id", "\n", "\n", "", "logger", ".", "info", "(", "\"Parsing categories:\"", ")", "\n", "# CATEGORY DATA", "\n", "categories", "=", "[", "\n", "{", "\"id\"", ":", "category_id", ",", "\"name\"", ":", "name", "}", "\n", "for", "category_id", ",", "name", "in", "dataset", ".", "id_to_name", ".", "items", "(", ")", "\n", "if", "name", "!=", "\"__background__\"", "\n", "]", "\n", "# Logging categories", "\n", "for", "cat", "in", "categories", ":", "\n", "        ", "logger", ".", "info", "(", "str", "(", "cat", ")", ")", "\n", "\n", "", "coco_dict", "[", "\"images\"", "]", "=", "images", "\n", "coco_dict", "[", "\"annotations\"", "]", "=", "annotations", "\n", "coco_dict", "[", "\"categories\"", "]", "=", "categories", "\n", "return", "coco_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.abs_to_coco.process_single_image": [[104, 187], ["dataset.get_img_info", "isinstance", "image.update", "isinstance", "target.convert().bbox.tolist", "target.get_field().long().tolist", "len", "range", "image.keys", "target.fields", "target.get_field().get_mask_tensor", "abs_to_coco.masks_to_rles", "target.area().tolist", "len", "len", "len", "per_img_annotations.append", "masks.unsqueeze.dim", "masks.unsqueeze.unsqueeze", "target.get_field().long", "target.convert", "target.get_field", "target.area", "target.get_field"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.fields", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.get_mask_tensor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.abs_to_coco.masks_to_rles", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.area", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field"], ["", "def", "process_single_image", "(", "args", ")", ":", "\n", "    ", "dataset", ",", "idx", "=", "args", "\n", "# IMAGE DATA", "\n", "img_id", "=", "idx", "+", "1", "\n", "image", "=", "{", "}", "\n", "# Official COCO \"images\" entries have these fields", "\n", "# 'license', 'url', 'file_name', 'height', 'width', 'date_captured', 'id'", "\n", "\n", "img", ",", "target", ",", "ret_idx", "=", "dataset", "[", "idx", "]", "\n", "img_info", "=", "dataset", ".", "get_img_info", "(", "idx", ")", "\n", "assert", "isinstance", "(", "img_info", ",", "dict", ")", "\n", "image", ".", "update", "(", "img_info", ")", "\n", "image", "[", "\"width\"", "]", ",", "image", "[", "\"height\"", "]", "=", "target", ".", "size", "\n", "\n", "if", "\"id\"", "not", "in", "image", ".", "keys", "(", ")", ":", "\n", "# Start indexing from 1 if \"id\" field is not present", "\n", "        ", "image", "[", "\"id\"", "]", "=", "img_id", "\n", "", "else", ":", "\n", "        ", "img_id", "=", "image", "[", "\"id\"", "]", "\n", "\n", "# ANNOTATION DATA", "\n", "", "per_img_annotations", "=", "[", "]", "\n", "# Official COCO \"annotations\" entries have these fields", "\n", "# 'segmentation', 'area', 'iscrowd', 'image_id', 'bbox', 'category_id', 'id'", "\n", "\n", "#", "\n", "\n", "assert", "ret_idx", "==", "idx", ",", "(", "ret_idx", ",", "idx", ")", "\n", "assert", "isinstance", "(", "target", ",", "BoxList", ")", "\n", "\n", "bboxes", "=", "target", ".", "convert", "(", "\"xywh\"", ")", ".", "bbox", ".", "tolist", "(", ")", "\n", "segm_available", "=", "\"masks\"", "in", "target", ".", "fields", "(", ")", "\n", "if", "segm_available", ":", "\n", "        ", "masks", "=", "target", ".", "get_field", "(", "\"masks\"", ")", ".", "get_mask_tensor", "(", ")", "# [N, H, W]", "\n", "if", "masks", ".", "dim", "(", ")", "==", "2", ":", "\n", "            ", "masks", "=", "masks", ".", "unsqueeze", "(", "0", ")", "\n", "", "rles", "=", "masks_to_rles", "(", "masks", ")", "\n", "\"\"\"\n        !!!WARNING!!!\n        At this point the area value differs from the precomputed\n        original COCO area values, because we compute the area\n        by counting the nonzero entries of the binary mask\n        while COCO areas are computed directly from the polygons\n\n        Example:\n        Reference image data\n        {'license': 2,\n         'url': 'http://farm9.staticflickr.com/8035/8024364858_9c41dc1666_z.jpg',\n         'file_name': 'COCO_val2014_000000000139.jpg',\n         'height': 426,\n         'width': 640,\n         'date_captured': '2013-11-21 01:34:01',\n         'id': 139}\n\n        Original COCO area values\n        [  531.8071, 13244.6572,  5833.1182,  2245.3435,  1833.7841,  1289.3734,\n           210.1482,  2913.1104,   435.1450,   217.7192,  2089.9749,   338.6089,\n           322.5936,   225.6642,  2171.6189,   178.1851,    90.9873,   189.5601,\n           120.2320,  2362.4897]\n\n        Area values using the binary masks\n        [  531, 13247,  5846,  2251,  1850,  1292,   212,  2922,   439,   224,\n           2060,   342,   324,   226,  2171,   178,    90,   187,   120,  2372]\n        \"\"\"", "\n", "areas", "=", "(", "masks", "!=", "0", ")", ".", "sum", "(", "[", "1", ",", "2", "]", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "        ", "areas", "=", "target", ".", "area", "(", ")", ".", "tolist", "(", ")", "\n", "\n", "", "cat_ids", "=", "target", ".", "get_field", "(", "\"labels\"", ")", ".", "long", "(", ")", ".", "tolist", "(", ")", "\n", "assert", "len", "(", "bboxes", ")", "==", "len", "(", "areas", ")", "==", "len", "(", "cat_ids", ")", "\n", "num_instances", "=", "len", "(", "target", ")", "\n", "for", "ann_idx", "in", "range", "(", "num_instances", ")", ":", "\n", "        ", "annotation", "=", "{", "}", "\n", "if", "segm_available", ":", "\n", "            ", "annotation", "[", "\"segmentation\"", "]", "=", "rles", "[", "ann_idx", "]", "\n", "", "annotation", "[", "\"area\"", "]", "=", "areas", "[", "ann_idx", "]", "\n", "annotation", "[", "\"iscrowd\"", "]", "=", "0", "\n", "annotation", "[", "\"image_id\"", "]", "=", "img_id", "\n", "annotation", "[", "\"bbox\"", "]", "=", "bboxes", "[", "ann_idx", "]", "\n", "annotation", "[", "\"category_id\"", "]", "=", "cat_ids", "[", "ann_idx", "]", "\n", "per_img_annotations", ".", "append", "(", "annotation", ")", "\n", "\n", "", "return", "image", ",", "per_img_annotations", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.abs_to_coco.masks_to_rles": [[189, 199], ["numpy.array", "rle[].decode", "rles.append", "pycocotools.encode"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode"], ["", "def", "masks_to_rles", "(", "masks_tensor", ")", ":", "\n", "# TODO: parallelize", "\n", "    ", "rles", "=", "[", "]", "\n", "for", "instance_mask", "in", "masks_tensor", ":", "\n", "        ", "np_mask", "=", "np", ".", "array", "(", "instance_mask", "[", ":", ",", ":", ",", "None", "]", ",", "order", "=", "\"F\"", ")", "\n", "rle", "=", "mask_util", ".", "encode", "(", "np_mask", ")", "[", "0", "]", "\n", "rle", "[", "\"counts\"", "]", "=", "rle", "[", "\"counts\"", "]", ".", "decode", "(", "\"utf-8\"", ")", "\n", "rles", ".", "append", "(", "rle", ")", "\n", "\n", "", "return", "rles", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.voc_eval.do_voc_evaluation": [[12, 44], ["enumerate", "voc_eval.eval_detection_voc", "enumerate", "logger.info", "dataset.get_img_info", "prediction.resize.resize", "pred_boxlists.append", "dataset.get_groundtruth", "gt_boxlists.append", "dataset.map_class_id_to_class_name", "open", "fid.write", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.voc_eval.eval_detection_voc", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_img_info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.get_groundtruth", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.datasets.voc.PascalVOCDataset.map_class_id_to_class_name"], ["def", "do_voc_evaluation", "(", "dataset", ",", "predictions", ",", "output_folder", ",", "logger", ")", ":", "\n", "# TODO need to make the use_07_metric format available", "\n", "# for the user to choose", "\n", "    ", "pred_boxlists", "=", "[", "]", "\n", "gt_boxlists", "=", "[", "]", "\n", "for", "image_id", ",", "prediction", "in", "enumerate", "(", "predictions", ")", ":", "\n", "        ", "img_info", "=", "dataset", ".", "get_img_info", "(", "image_id", ")", "\n", "image_width", "=", "img_info", "[", "\"width\"", "]", "\n", "image_height", "=", "img_info", "[", "\"height\"", "]", "\n", "prediction", "=", "prediction", ".", "resize", "(", "(", "image_width", ",", "image_height", ")", ")", "\n", "pred_boxlists", ".", "append", "(", "prediction", ")", "\n", "\n", "gt_boxlist", "=", "dataset", ".", "get_groundtruth", "(", "image_id", ")", "\n", "gt_boxlists", ".", "append", "(", "gt_boxlist", ")", "\n", "", "result", "=", "eval_detection_voc", "(", "\n", "pred_boxlists", "=", "pred_boxlists", ",", "\n", "gt_boxlists", "=", "gt_boxlists", ",", "\n", "iou_thresh", "=", "0.5", ",", "\n", "use_07_metric", "=", "True", ",", "\n", ")", "\n", "result_str", "=", "\"mAP: {:.4f}\\n\"", ".", "format", "(", "result", "[", "\"map\"", "]", ")", "\n", "for", "i", ",", "ap", "in", "enumerate", "(", "result", "[", "\"ap\"", "]", ")", ":", "\n", "        ", "if", "i", "==", "0", ":", "# skip background", "\n", "            ", "continue", "\n", "", "result_str", "+=", "\"{:<16}: {:.4f}\\n\"", ".", "format", "(", "\n", "dataset", ".", "map_class_id_to_class_name", "(", "i", ")", ",", "ap", "\n", ")", "\n", "", "logger", ".", "info", "(", "result_str", ")", "\n", "if", "output_folder", ":", "\n", "        ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "output_folder", ",", "\"result.txt\"", ")", ",", "\"w\"", ")", "as", "fid", ":", "\n", "            ", "fid", ".", "write", "(", "result_str", ")", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.voc_eval.eval_detection_voc": [[46, 64], ["voc_eval.calc_detection_voc_prec_rec", "voc_eval.calc_detection_voc_ap", "len", "len", "numpy.nanmean"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.voc_eval.calc_detection_voc_prec_rec", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.voc_eval.calc_detection_voc_ap"], ["", "def", "eval_detection_voc", "(", "pred_boxlists", ",", "gt_boxlists", ",", "iou_thresh", "=", "0.5", ",", "use_07_metric", "=", "False", ")", ":", "\n", "    ", "\"\"\"Evaluate on voc dataset.\n    Args:\n        pred_boxlists(list[BoxList]): pred boxlist, has labels and scores fields.\n        gt_boxlists(list[BoxList]): ground truth boxlist, has labels field.\n        iou_thresh: iou thresh\n        use_07_metric: boolean\n    Returns:\n        dict represents the results\n    \"\"\"", "\n", "assert", "len", "(", "gt_boxlists", ")", "==", "len", "(", "\n", "pred_boxlists", "\n", ")", ",", "\"Length of gt and pred lists need to be same.\"", "\n", "prec", ",", "rec", "=", "calc_detection_voc_prec_rec", "(", "\n", "pred_boxlists", "=", "pred_boxlists", ",", "gt_boxlists", "=", "gt_boxlists", ",", "iou_thresh", "=", "iou_thresh", "\n", ")", "\n", "ap", "=", "calc_detection_voc_ap", "(", "prec", ",", "rec", ",", "use_07_metric", "=", "use_07_metric", ")", "\n", "return", "{", "\"ap\"", ":", "ap", ",", "\"map\"", ":", "np", ".", "nanmean", "(", "ap", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.voc_eval.calc_detection_voc_prec_rec": [[66, 156], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "zip", "collections.defaultdict.keys", "pred_boxlist.bbox.numpy", "pred_boxlist.get_field().numpy", "pred_boxlist.get_field().numpy", "gt_boxlist.bbox.numpy", "gt_boxlist.get_field().numpy", "gt_boxlist.get_field().numpy", "numpy.unique", "max", "numpy.array", "numpy.array", "numpy.cumsum", "numpy.cumsum", "numpy.concatenate().astype", "numpy.logical_not().sum", "score[].extend", "pred_bbox_l.copy.copy", "gt_bbox_l.copy.copy", "vc_rcnn.structures.boxlist_ops.boxlist_iou().numpy", "boxlist_iou().numpy.argmax", "numpy.zeros", "collections.defaultdict.keys", "np.array.argsort", "pred_boxlist.get_field", "pred_boxlist.get_field", "gt_boxlist.get_field", "gt_boxlist.get_field", "pred_score_l.argsort", "len", "len", "match[].extend", "numpy.concatenate", "numpy.logical_not", "vc_rcnn.structures.boxlist_ops.boxlist_iou", "match[].append", "vc_rcnn.structures.bounding_box.BoxList", "vc_rcnn.structures.bounding_box.BoxList", "boxlist_iou().numpy.max", "match[].append", "match[].append", "match[].append"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.get_field", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.rpn.anchor_generator.BufferList.extend", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.boxlist_ops.boxlist_iou"], ["", "def", "calc_detection_voc_prec_rec", "(", "gt_boxlists", ",", "pred_boxlists", ",", "iou_thresh", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"Calculate precision and recall based on evaluation code of PASCAL VOC.\n    This function calculates precision and recall of\n    predicted bounding boxes obtained from a dataset which has :math:`N`\n    images.\n    The code is based on the evaluation code used in PASCAL VOC Challenge.\n   \"\"\"", "\n", "n_pos", "=", "defaultdict", "(", "int", ")", "\n", "score", "=", "defaultdict", "(", "list", ")", "\n", "match", "=", "defaultdict", "(", "list", ")", "\n", "for", "gt_boxlist", ",", "pred_boxlist", "in", "zip", "(", "gt_boxlists", ",", "pred_boxlists", ")", ":", "\n", "        ", "pred_bbox", "=", "pred_boxlist", ".", "bbox", ".", "numpy", "(", ")", "\n", "pred_label", "=", "pred_boxlist", ".", "get_field", "(", "\"labels\"", ")", ".", "numpy", "(", ")", "\n", "pred_score", "=", "pred_boxlist", ".", "get_field", "(", "\"scores\"", ")", ".", "numpy", "(", ")", "\n", "gt_bbox", "=", "gt_boxlist", ".", "bbox", ".", "numpy", "(", ")", "\n", "gt_label", "=", "gt_boxlist", ".", "get_field", "(", "\"labels\"", ")", ".", "numpy", "(", ")", "\n", "gt_difficult", "=", "gt_boxlist", ".", "get_field", "(", "\"difficult\"", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "l", "in", "np", ".", "unique", "(", "np", ".", "concatenate", "(", "(", "pred_label", ",", "gt_label", ")", ")", ".", "astype", "(", "int", ")", ")", ":", "\n", "            ", "pred_mask_l", "=", "pred_label", "==", "l", "\n", "pred_bbox_l", "=", "pred_bbox", "[", "pred_mask_l", "]", "\n", "pred_score_l", "=", "pred_score", "[", "pred_mask_l", "]", "\n", "# sort by score", "\n", "order", "=", "pred_score_l", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "pred_bbox_l", "=", "pred_bbox_l", "[", "order", "]", "\n", "pred_score_l", "=", "pred_score_l", "[", "order", "]", "\n", "\n", "gt_mask_l", "=", "gt_label", "==", "l", "\n", "gt_bbox_l", "=", "gt_bbox", "[", "gt_mask_l", "]", "\n", "gt_difficult_l", "=", "gt_difficult", "[", "gt_mask_l", "]", "\n", "\n", "n_pos", "[", "l", "]", "+=", "np", ".", "logical_not", "(", "gt_difficult_l", ")", ".", "sum", "(", ")", "\n", "score", "[", "l", "]", ".", "extend", "(", "pred_score_l", ")", "\n", "\n", "if", "len", "(", "pred_bbox_l", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "if", "len", "(", "gt_bbox_l", ")", "==", "0", ":", "\n", "                ", "match", "[", "l", "]", ".", "extend", "(", "(", "0", ",", ")", "*", "pred_bbox_l", ".", "shape", "[", "0", "]", ")", "\n", "continue", "\n", "\n", "# VOC evaluation follows integer typed bounding boxes.", "\n", "", "pred_bbox_l", "=", "pred_bbox_l", ".", "copy", "(", ")", "\n", "pred_bbox_l", "[", ":", ",", "2", ":", "]", "+=", "1", "\n", "gt_bbox_l", "=", "gt_bbox_l", ".", "copy", "(", ")", "\n", "gt_bbox_l", "[", ":", ",", "2", ":", "]", "+=", "1", "\n", "iou", "=", "boxlist_iou", "(", "\n", "BoxList", "(", "pred_bbox_l", ",", "gt_boxlist", ".", "size", ")", ",", "\n", "BoxList", "(", "gt_bbox_l", ",", "gt_boxlist", ".", "size", ")", ",", "\n", ")", ".", "numpy", "(", ")", "\n", "gt_index", "=", "iou", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "# set -1 if there is no matching ground truth", "\n", "gt_index", "[", "iou", ".", "max", "(", "axis", "=", "1", ")", "<", "iou_thresh", "]", "=", "-", "1", "\n", "del", "iou", "\n", "\n", "selec", "=", "np", ".", "zeros", "(", "gt_bbox_l", ".", "shape", "[", "0", "]", ",", "dtype", "=", "bool", ")", "\n", "for", "gt_idx", "in", "gt_index", ":", "\n", "                ", "if", "gt_idx", ">=", "0", ":", "\n", "                    ", "if", "gt_difficult_l", "[", "gt_idx", "]", ":", "\n", "                        ", "match", "[", "l", "]", ".", "append", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "                        ", "if", "not", "selec", "[", "gt_idx", "]", ":", "\n", "                            ", "match", "[", "l", "]", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "                            ", "match", "[", "l", "]", ".", "append", "(", "0", ")", "\n", "", "", "selec", "[", "gt_idx", "]", "=", "True", "\n", "", "else", ":", "\n", "                    ", "match", "[", "l", "]", ".", "append", "(", "0", ")", "\n", "\n", "", "", "", "", "n_fg_class", "=", "max", "(", "n_pos", ".", "keys", "(", ")", ")", "+", "1", "\n", "prec", "=", "[", "None", "]", "*", "n_fg_class", "\n", "rec", "=", "[", "None", "]", "*", "n_fg_class", "\n", "\n", "for", "l", "in", "n_pos", ".", "keys", "(", ")", ":", "\n", "        ", "score_l", "=", "np", ".", "array", "(", "score", "[", "l", "]", ")", "\n", "match_l", "=", "np", ".", "array", "(", "match", "[", "l", "]", ",", "dtype", "=", "np", ".", "int8", ")", "\n", "\n", "order", "=", "score_l", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "match_l", "=", "match_l", "[", "order", "]", "\n", "\n", "tp", "=", "np", ".", "cumsum", "(", "match_l", "==", "1", ")", "\n", "fp", "=", "np", ".", "cumsum", "(", "match_l", "==", "0", ")", "\n", "\n", "# If an element of fp + tp is 0,", "\n", "# the corresponding element of prec[l] is nan.", "\n", "prec", "[", "l", "]", "=", "tp", "/", "(", "fp", "+", "tp", ")", "\n", "# If n_pos[l] is 0, rec[l] is None.", "\n", "if", "n_pos", "[", "l", "]", ">", "0", ":", "\n", "            ", "rec", "[", "l", "]", "=", "tp", "/", "n_pos", "[", "l", "]", "\n", "\n", "", "", "return", "prec", ",", "rec", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.voc_eval.calc_detection_voc_ap": [[158, 215], ["len", "numpy.empty", "range", "numpy.arange", "numpy.concatenate", "numpy.concatenate", "numpy.sum", "numpy.maximum.accumulate", "numpy.where", "numpy.sum", "numpy.max", "numpy.nan_to_num", "numpy.nan_to_num"], "function", ["None"], ["", "def", "calc_detection_voc_ap", "(", "prec", ",", "rec", ",", "use_07_metric", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculate average precisions based on evaluation code of PASCAL VOC.\n    This function calculates average precisions\n    from given precisions and recalls.\n    The code is based on the evaluation code used in PASCAL VOC Challenge.\n    Args:\n        prec (list of numpy.array): A list of arrays.\n            :obj:`prec[l]` indicates precision for class :math:`l`.\n            If :obj:`prec[l]` is :obj:`None`, this function returns\n            :obj:`numpy.nan` for class :math:`l`.\n        rec (list of numpy.array): A list of arrays.\n            :obj:`rec[l]` indicates recall for class :math:`l`.\n            If :obj:`rec[l]` is :obj:`None`, this function returns\n            :obj:`numpy.nan` for class :math:`l`.\n        use_07_metric (bool): Whether to use PASCAL VOC 2007 evaluation metric\n            for calculating average precision. The default value is\n            :obj:`False`.\n    Returns:\n        ~numpy.ndarray:\n        This function returns an array of average precisions.\n        The :math:`l`-th value corresponds to the average precision\n        for class :math:`l`. If :obj:`prec[l]` or :obj:`rec[l]` is\n        :obj:`None`, the corresponding value is set to :obj:`numpy.nan`.\n    \"\"\"", "\n", "\n", "n_fg_class", "=", "len", "(", "prec", ")", "\n", "ap", "=", "np", ".", "empty", "(", "n_fg_class", ")", "\n", "for", "l", "in", "range", "(", "n_fg_class", ")", ":", "\n", "        ", "if", "prec", "[", "l", "]", "is", "None", "or", "rec", "[", "l", "]", "is", "None", ":", "\n", "            ", "ap", "[", "l", "]", "=", "np", ".", "nan", "\n", "continue", "\n", "\n", "", "if", "use_07_metric", ":", "\n", "# 11 point metric", "\n", "            ", "ap", "[", "l", "]", "=", "0", "\n", "for", "t", "in", "np", ".", "arange", "(", "0.0", ",", "1.1", ",", "0.1", ")", ":", "\n", "                ", "if", "np", ".", "sum", "(", "rec", "[", "l", "]", ">=", "t", ")", "==", "0", ":", "\n", "                    ", "p", "=", "0", "\n", "", "else", ":", "\n", "                    ", "p", "=", "np", ".", "max", "(", "np", ".", "nan_to_num", "(", "prec", "[", "l", "]", ")", "[", "rec", "[", "l", "]", ">=", "t", "]", ")", "\n", "", "ap", "[", "l", "]", "+=", "p", "/", "11", "\n", "", "", "else", ":", "\n", "# correct AP calculation", "\n", "# first append sentinel values at the end", "\n", "            ", "mpre", "=", "np", ".", "concatenate", "(", "(", "[", "0", "]", ",", "np", ".", "nan_to_num", "(", "prec", "[", "l", "]", ")", ",", "[", "0", "]", ")", ")", "\n", "mrec", "=", "np", ".", "concatenate", "(", "(", "[", "0", "]", ",", "rec", "[", "l", "]", ",", "[", "1", "]", ")", ")", "\n", "\n", "mpre", "=", "np", ".", "maximum", ".", "accumulate", "(", "mpre", "[", ":", ":", "-", "1", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "# to calculate area under PR curve, look for points", "\n", "# where X axis (recall) changes value", "\n", "i", "=", "np", ".", "where", "(", "mrec", "[", "1", ":", "]", "!=", "mrec", "[", ":", "-", "1", "]", ")", "[", "0", "]", "\n", "\n", "# and sum (\\Delta recall) * prec", "\n", "ap", "[", "l", "]", "=", "np", ".", "sum", "(", "(", "mrec", "[", "i", "+", "1", "]", "-", "mrec", "[", "i", "]", ")", "*", "mpre", "[", "i", "+", "1", "]", ")", "\n", "\n", "", "", "return", "ap", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.__init__.voc_evaluation": [[6, 16], ["logging.getLogger", "logging.getLogger.info", "voc_eval.do_voc_evaluation", "logging.getLogger.warning"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.voc.voc_eval.do_voc_evaluation"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.distributed.DistributedSampler.__init__": [[25, 41], ["int", "torch.get_world_size", "torch.get_world_size", "torch.get_rank", "torch.get_rank", "math.ceil", "torch.is_available", "torch.is_available", "RuntimeError", "torch.is_available", "torch.is_available", "RuntimeError", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_world_size", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank"], ["def", "__init__", "(", "self", ",", "dataset", ",", "num_replicas", "=", "None", ",", "rank", "=", "None", ",", "shuffle", "=", "True", ")", ":", "\n", "        ", "if", "num_replicas", "is", "None", ":", "\n", "            ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "                ", "raise", "RuntimeError", "(", "\"Requires distributed package to be available\"", ")", "\n", "", "num_replicas", "=", "dist", ".", "get_world_size", "(", ")", "\n", "", "if", "rank", "is", "None", ":", "\n", "            ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "                ", "raise", "RuntimeError", "(", "\"Requires distributed package to be available\"", ")", "\n", "", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "num_replicas", "=", "num_replicas", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "epoch", "=", "0", "\n", "self", ".", "num_samples", "=", "int", "(", "math", ".", "ceil", "(", "len", "(", "self", ".", "dataset", ")", "*", "1.0", "/", "self", ".", "num_replicas", ")", ")", "\n", "self", ".", "total_size", "=", "self", ".", "num_samples", "*", "self", ".", "num_replicas", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.distributed.DistributedSampler.__iter__": [[42, 61], ["iter", "torch.Generator", "torch.Generator", "torch.Generator", "torch.Generator", "torch.Generator.manual_seed", "torch.Generator.manual_seed", "torch.randperm().tolist", "torch.randperm().tolist", "torch.randperm().tolist", "torch.randperm().tolist", "torch.arange().tolist", "torch.arange().tolist", "torch.arange().tolist", "torch.arange().tolist", "len", "len", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "len", "len", "len"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "shuffle", ":", "\n", "# deterministically shuffle based on epoch", "\n", "            ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", ")", "\n", "indices", "=", "torch", ".", "randperm", "(", "len", "(", "self", ".", "dataset", ")", ",", "generator", "=", "g", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "            ", "indices", "=", "torch", ".", "arange", "(", "len", "(", "self", ".", "dataset", ")", ")", ".", "tolist", "(", ")", "\n", "\n", "# add extra samples to make it evenly divisible", "\n", "", "indices", "+=", "indices", "[", ":", "(", "self", ".", "total_size", "-", "len", "(", "indices", ")", ")", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "\n", "# subsample", "\n", "offset", "=", "self", ".", "num_samples", "*", "self", ".", "rank", "\n", "indices", "=", "indices", "[", "offset", ":", "offset", "+", "self", ".", "num_samples", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.distributed.DistributedSampler.__len__": [[62, 64], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.distributed.DistributedSampler.set_epoch": [[65, 67], ["None"], "methods", ["None"], ["", "def", "set_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "epoch", "=", "epoch", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.grouped_batch_sampler.GroupedBatchSampler.__init__": [[24, 39], ["torch.as_tensor", "isinstance", "ValueError", "grouped_batch_sampler.GroupedBatchSampler.group_ids.dim", "torch.unique().sort", "torch.unique"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["def", "__init__", "(", "self", ",", "sampler", ",", "group_ids", ",", "batch_size", ",", "drop_uneven", "=", "False", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "sampler", ",", "Sampler", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"sampler should be an instance of \"", "\n", "\"torch.utils.data.Sampler, but got sampler={}\"", ".", "format", "(", "sampler", ")", "\n", ")", "\n", "", "self", ".", "sampler", "=", "sampler", "\n", "self", ".", "group_ids", "=", "torch", ".", "as_tensor", "(", "group_ids", ")", "\n", "assert", "self", ".", "group_ids", ".", "dim", "(", ")", "==", "1", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "drop_uneven", "=", "drop_uneven", "\n", "\n", "self", ".", "groups", "=", "torch", ".", "unique", "(", "self", ".", "group_ids", ")", ".", "sort", "(", "0", ")", "[", "0", "]", "\n", "\n", "self", ".", "_can_reuse_batches", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.grouped_batch_sampler.GroupedBatchSampler._prepare_batches": [[40, 101], ["len", "torch.as_tensor", "torch.full", "torch.arange", "tuple", "torch.as_tensor", "[].tolist", "list", "len", "c.split", "itertools.chain.from_iterable", "t[].item", "merged[].tolist", "enumerate", "torch.as_tensor.tolist", "torch.as_tensor.sort", "len", "kept.append", "s.sort"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor"], ["", "def", "_prepare_batches", "(", "self", ")", ":", "\n", "        ", "dataset_size", "=", "len", "(", "self", ".", "group_ids", ")", "\n", "# get the sampled indices from the sampler", "\n", "sampled_ids", "=", "torch", ".", "as_tensor", "(", "list", "(", "self", ".", "sampler", ")", ")", "\n", "# potentially not all elements of the dataset were sampled", "\n", "# by the sampler (e.g., DistributedSampler).", "\n", "# construct a tensor which contains -1 if the element was", "\n", "# not sampled, and a non-negative number indicating the", "\n", "# order where the element was sampled.", "\n", "# for example. if sampled_ids = [3, 1] and dataset_size = 5,", "\n", "# the order is [-1, 1, -1, 0, -1]", "\n", "order", "=", "torch", ".", "full", "(", "(", "dataset_size", ",", ")", ",", "-", "1", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "order", "[", "sampled_ids", "]", "=", "torch", ".", "arange", "(", "len", "(", "sampled_ids", ")", ")", "\n", "\n", "# get a mask with the elements that were sampled", "\n", "mask", "=", "order", ">=", "0", "\n", "\n", "# find the elements that belong to each individual cluster", "\n", "clusters", "=", "[", "(", "self", ".", "group_ids", "==", "i", ")", "&", "mask", "for", "i", "in", "self", ".", "groups", "]", "\n", "# get relative order of the elements inside each cluster", "\n", "# that follows the order from the sampler", "\n", "relative_order", "=", "[", "order", "[", "cluster", "]", "for", "cluster", "in", "clusters", "]", "\n", "# with the relative order, find the absolute order in the", "\n", "# sampled space", "\n", "permutation_ids", "=", "[", "s", "[", "s", ".", "sort", "(", ")", "[", "1", "]", "]", "for", "s", "in", "relative_order", "]", "\n", "# permute each cluster so that they follow the order from", "\n", "# the sampler", "\n", "permuted_clusters", "=", "[", "sampled_ids", "[", "idx", "]", "for", "idx", "in", "permutation_ids", "]", "\n", "\n", "# splits each cluster in batch_size, and merge as a list of tensors", "\n", "splits", "=", "[", "c", ".", "split", "(", "self", ".", "batch_size", ")", "for", "c", "in", "permuted_clusters", "]", "\n", "merged", "=", "tuple", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "splits", ")", ")", "\n", "\n", "# now each batch internally has the right order, but", "\n", "# they are grouped by clusters. Find the permutation between", "\n", "# different batches that brings them as close as possible to", "\n", "# the order that we have in the sampler. For that, we will consider the", "\n", "# ordering as coming from the first element of each batch, and sort", "\n", "# correspondingly", "\n", "first_element_of_batch", "=", "[", "t", "[", "0", "]", ".", "item", "(", ")", "for", "t", "in", "merged", "]", "\n", "# get and inverse mapping from sampled indices and the position where", "\n", "# they occur (as returned by the sampler)", "\n", "inv_sampled_ids_map", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "enumerate", "(", "sampled_ids", ".", "tolist", "(", ")", ")", "}", "\n", "# from the first element in each batch, get a relative ordering", "\n", "first_index_of_batch", "=", "torch", ".", "as_tensor", "(", "\n", "[", "inv_sampled_ids_map", "[", "s", "]", "for", "s", "in", "first_element_of_batch", "]", "\n", ")", "\n", "\n", "# permute the batches so that they approximately follow the order", "\n", "# from the sampler", "\n", "permutation_order", "=", "first_index_of_batch", ".", "sort", "(", "0", ")", "[", "1", "]", ".", "tolist", "(", ")", "\n", "# finally, permute the batches", "\n", "batches", "=", "[", "merged", "[", "i", "]", ".", "tolist", "(", ")", "for", "i", "in", "permutation_order", "]", "\n", "\n", "if", "self", ".", "drop_uneven", ":", "\n", "            ", "kept", "=", "[", "]", "\n", "for", "batch", "in", "batches", ":", "\n", "                ", "if", "len", "(", "batch", ")", "==", "self", ".", "batch_size", ":", "\n", "                    ", "kept", ".", "append", "(", "batch", ")", "\n", "", "", "batches", "=", "kept", "\n", "", "return", "batches", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.grouped_batch_sampler.GroupedBatchSampler.__iter__": [[102, 110], ["iter", "grouped_batch_sampler.GroupedBatchSampler._prepare_batches"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.grouped_batch_sampler.GroupedBatchSampler._prepare_batches"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_can_reuse_batches", ":", "\n", "            ", "batches", "=", "self", ".", "_batches", "\n", "self", ".", "_can_reuse_batches", "=", "False", "\n", "", "else", ":", "\n", "            ", "batches", "=", "self", ".", "_prepare_batches", "(", ")", "\n", "", "self", ".", "_batches", "=", "batches", "\n", "return", "iter", "(", "batches", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.grouped_batch_sampler.GroupedBatchSampler.__len__": [[111, 116], ["len", "hasattr", "grouped_batch_sampler.GroupedBatchSampler._prepare_batches"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.grouped_batch_sampler.GroupedBatchSampler._prepare_batches"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "\"_batches\"", ")", ":", "\n", "            ", "self", ".", "_batches", "=", "self", ".", "_prepare_batches", "(", ")", "\n", "self", ".", "_can_reuse_batches", "=", "True", "\n", "", "return", "len", "(", "self", ".", "_batches", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.iteration_based_batch_sampler.IterationBasedBatchSampler.__init__": [[11, 15], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "batch_sampler", ",", "num_iterations", ",", "start_iter", "=", "0", ")", ":", "\n", "        ", "self", ".", "batch_sampler", "=", "batch_sampler", "\n", "self", ".", "num_iterations", "=", "num_iterations", "\n", "self", ".", "start_iter", "=", "start_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.iteration_based_batch_sampler.IterationBasedBatchSampler.__iter__": [[16, 29], ["hasattr", "iteration_based_batch_sampler.IterationBasedBatchSampler.batch_sampler.sampler.set_epoch"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.distributed.DistributedSampler.set_epoch"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "iteration", "=", "self", ".", "start_iter", "\n", "while", "iteration", "<=", "self", ".", "num_iterations", ":", "\n", "# if the underlying sampler has a set_epoch method, like", "\n", "# DistributedSampler, used for making each process see", "\n", "# a different split of the dataset, then set it", "\n", "            ", "if", "hasattr", "(", "self", ".", "batch_sampler", ".", "sampler", ",", "\"set_epoch\"", ")", ":", "\n", "                ", "self", ".", "batch_sampler", ".", "sampler", ".", "set_epoch", "(", "iteration", ")", "\n", "", "for", "batch", "in", "self", ".", "batch_sampler", ":", "\n", "                ", "iteration", "+=", "1", "\n", "if", "iteration", ">", "self", ".", "num_iterations", ":", "\n", "                    ", "break", "\n", "", "yield", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.samplers.iteration_based_batch_sampler.IterationBasedBatchSampler.__len__": [[30, 32], ["None"], "methods", ["None"], ["", "", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_iterations", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.Compose.__init__": [[10, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "transforms", ")", ":", "\n", "        ", "self", ".", "transforms", "=", "transforms", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.Compose.__call__": [[13, 17], ["t"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "target", ")", ":", "\n", "        ", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "image", ",", "target", "=", "t", "(", "image", ",", "target", ")", "\n", "", "return", "image", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.Compose.__repr__": [[18, 25], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "format_string", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "format_string", "+=", "\"\\n\"", "\n", "format_string", "+=", "\"    {0}\"", ".", "format", "(", "t", ")", "\n", "", "format_string", "+=", "\"\\n)\"", "\n", "return", "format_string", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.Resize.__init__": [[28, 33], ["isinstance"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "min_size", ",", "max_size", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "min_size", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "min_size", "=", "(", "min_size", ",", ")", "\n", "", "self", ".", "min_size", "=", "min_size", "\n", "self", ".", "max_size", "=", "max_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.Resize.get_size": [[35, 56], ["random.choice", "float", "float", "int", "int", "min", "max", "int", "round"], "methods", ["None"], ["", "def", "get_size", "(", "self", ",", "image_size", ")", ":", "\n", "        ", "w", ",", "h", "=", "image_size", "\n", "size", "=", "random", ".", "choice", "(", "self", ".", "min_size", ")", "\n", "max_size", "=", "self", ".", "max_size", "\n", "if", "max_size", "is", "not", "None", ":", "\n", "            ", "min_original_size", "=", "float", "(", "min", "(", "(", "w", ",", "h", ")", ")", ")", "\n", "max_original_size", "=", "float", "(", "max", "(", "(", "w", ",", "h", ")", ")", ")", "\n", "if", "max_original_size", "/", "min_original_size", "*", "size", ">", "max_size", ":", "\n", "                ", "size", "=", "int", "(", "round", "(", "max_size", "*", "min_original_size", "/", "max_original_size", ")", ")", "\n", "\n", "", "", "if", "(", "w", "<=", "h", "and", "w", "==", "size", ")", "or", "(", "h", "<=", "w", "and", "h", "==", "size", ")", ":", "\n", "            ", "return", "(", "h", ",", "w", ")", "\n", "\n", "", "if", "w", "<", "h", ":", "\n", "            ", "ow", "=", "size", "\n", "oh", "=", "int", "(", "size", "*", "h", "/", "w", ")", "\n", "", "else", ":", "\n", "            ", "oh", "=", "size", "\n", "ow", "=", "int", "(", "size", "*", "w", "/", "h", ")", "\n", "\n", "", "return", "(", "oh", ",", "ow", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.Resize.__call__": [[57, 64], ["transforms.Resize.get_size", "torchvision.transforms.functional.resize", "target.resize.resize.resize"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.Resize.get_size", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize"], ["", "def", "__call__", "(", "self", ",", "image", ",", "target", "=", "None", ")", ":", "\n", "        ", "size", "=", "self", ".", "get_size", "(", "image", ".", "size", ")", "\n", "image", "=", "F", ".", "resize", "(", "image", ",", "size", ")", "\n", "if", "target", "is", "None", ":", "\n", "            ", "return", "image", "\n", "", "target", "=", "target", ".", "resize", "(", "image", ".", "size", ")", "\n", "return", "image", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.RandomHorizontalFlip.__init__": [[67, 69], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "prob", "=", "0.5", ")", ":", "\n", "        ", "self", ".", "prob", "=", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.RandomHorizontalFlip.__call__": [[70, 75], ["random.random", "torchvision.transforms.functional.hflip", "target.transpose.transpose.transpose"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "__call__", "(", "self", ",", "image", ",", "target", ")", ":", "\n", "        ", "if", "random", ".", "random", "(", ")", "<", "self", ".", "prob", ":", "\n", "            ", "image", "=", "F", ".", "hflip", "(", "image", ")", "\n", "target", "=", "target", ".", "transpose", "(", "0", ")", "\n", "", "return", "image", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.RandomVerticalFlip.__init__": [[77, 79], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "prob", "=", "0.5", ")", ":", "\n", "        ", "self", ".", "prob", "=", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.RandomVerticalFlip.__call__": [[80, 85], ["random.random", "torchvision.transforms.functional.vflip", "target.transpose.transpose.transpose"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "__call__", "(", "self", ",", "image", ",", "target", ")", ":", "\n", "        ", "if", "random", ".", "random", "(", ")", "<", "self", ".", "prob", ":", "\n", "            ", "image", "=", "F", ".", "vflip", "(", "image", ")", "\n", "target", "=", "target", ".", "transpose", "(", "1", ")", "\n", "", "return", "image", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.ColorJitter.__init__": [[87, 98], ["torchvision.transforms.ColorJitter"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "brightness", "=", "None", ",", "\n", "contrast", "=", "None", ",", "\n", "saturation", "=", "None", ",", "\n", "hue", "=", "None", ",", "\n", ")", ":", "\n", "        ", "self", ".", "color_jitter", "=", "torchvision", ".", "transforms", ".", "ColorJitter", "(", "\n", "brightness", "=", "brightness", ",", "\n", "contrast", "=", "contrast", ",", "\n", "saturation", "=", "saturation", ",", "\n", "hue", "=", "hue", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.ColorJitter.__call__": [[99, 102], ["transforms.ColorJitter.color_jitter"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "target", ")", ":", "\n", "        ", "image", "=", "self", ".", "color_jitter", "(", "image", ")", "\n", "return", "image", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.ToTensor.__call__": [[105, 107], ["torchvision.transforms.functional.to_tensor"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "target", ")", ":", "\n", "        ", "return", "F", ".", "to_tensor", "(", "image", ")", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.Normalize.__init__": [[110, 114], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mean", ",", "std", ",", "to_bgr255", "=", "True", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "self", ".", "std", "=", "std", "\n", "self", ".", "to_bgr255", "=", "to_bgr255", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.transforms.Normalize.__call__": [[115, 122], ["torchvision.transforms.functional.normalize"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "target", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "to_bgr255", ":", "\n", "            ", "image", "=", "image", "[", "[", "2", ",", "1", ",", "0", "]", "]", "*", "255", "\n", "", "image", "=", "F", ".", "normalize", "(", "image", ",", "mean", "=", "self", ".", "mean", ",", "std", "=", "self", ".", "std", ")", "\n", "if", "target", "is", "None", ":", "\n", "            ", "return", "image", "\n", "", "return", "image", ",", "target", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.transforms.build.build_transforms": [[5, 47], ["transforms.Normalize", "transforms.ColorJitter", "transforms.Compose", "transforms.Resize", "transforms.RandomHorizontalFlip", "transforms.RandomVerticalFlip", "transforms.ToTensor"], "function", ["None"], ["\n", "import", "torch", ".", "utils", ".", "data", "\n", "from", "vc_rcnn", ".", "utils", ".", "comm", "import", "get_world_size", "\n", "from", "vc_rcnn", ".", "utils", ".", "imports", "import", "import_file", "\n", "from", "vc_rcnn", ".", "utils", ".", "miscellaneous", "import", "save_labels", "\n", "\n", "from", ".", "import", "datasets", "as", "D", "\n", "from", ".", "import", "samplers", "\n", "\n", "from", ".", "collate_batch", "import", "BatchCollator", ",", "BBoxAugCollator", "\n", "from", ".", "transforms", "import", "build_transforms", "\n", "\n", "\n", "def", "build_dataset", "(", "dataset_list", ",", "transforms", ",", "dataset_catalog", ",", "cfg", ",", "is_train", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Arguments:\n        dataset_list (list[str]): Contains the names of the datasets, i.e.,\n            coco_2014_train, coco_2014_val, etc\n        transforms (callable): transforms to apply to each (image, target) sample\n        dataset_catalog (DatasetCatalog): contains the information on how to\n            construct a dataset.\n        is_train (bool): whether to setup the dataset for training or testing\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "dataset_list", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "\n", "\"dataset_list should be a list of strings, got {}\"", ".", "format", "(", "dataset_list", ")", "\n", ")", "\n", "", "datasets", "=", "[", "]", "\n", "for", "dataset_name", "in", "dataset_list", ":", "\n", "        ", "data", "=", "dataset_catalog", ".", "get", "(", "dataset_name", ")", "\n", "factory", "=", "getattr", "(", "D", ",", "data", "[", "\"factory\"", "]", ")", "\n", "args", "=", "data", "[", "\"args\"", "]", "\n", "args", "[", "'bbox_file_path'", "]", "=", "cfg", ".", "BOUNDINGBOX_FILE", "\n", "args", "[", "'num_threshold_object'", "]", "=", "cfg", ".", "NUM_THRESHOLD_OBJECT", "\n", "\n", "# for COCODataset, we want to remove images without annotations", "\n", "# during training", "\n", "if", "data", "[", "\"factory\"", "]", "==", "\"COCODataset\"", ":", "\n", "            ", "args", "[", "\"remove_images_without_annotations\"", "]", "=", "is_train", "\n", "", "if", "data", "[", "\"factory\"", "]", "==", "\"PascalVOCDataset\"", ":", "\n", "            ", "args", "[", "\"use_difficult\"", "]", "=", "not", "is_train", "\n", "", "args", "[", "\"transforms\"", "]", "=", "transforms", "\n", "# make dataset from factory", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.solver.build.make_optimizer": [[7, 21], ["model.named_parameters", "torch.optim.SGD"], "function", ["None"], ["from", "vc_rcnn", ".", "utils", ".", "comm", "import", "get_world_size", "\n", "from", "vc_rcnn", ".", "utils", ".", "imports", "import", "import_file", "\n", "from", "vc_rcnn", ".", "utils", ".", "miscellaneous", "import", "save_labels", "\n", "\n", "from", ".", "import", "datasets", "as", "D", "\n", "from", ".", "import", "samplers", "\n", "\n", "from", ".", "collate_batch", "import", "BatchCollator", ",", "BBoxAugCollator", "\n", "from", ".", "transforms", "import", "build_transforms", "\n", "\n", "\n", "def", "build_dataset", "(", "dataset_list", ",", "transforms", ",", "dataset_catalog", ",", "cfg", ",", "is_train", "=", "True", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.solver.build.make_lr_scheduler": [[23, 31], ["lr_scheduler.WarmupMultiStepLR"], "function", ["None"], ["\n", "if", "not", "isinstance", "(", "dataset_list", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "\n", "\"dataset_list should be a list of strings, got {}\"", ".", "format", "(", "dataset_list", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.solver.lr_scheduler.WarmupMultiStepLR.__init__": [[11, 38], ["super().__init__", "ValueError", "ValueError", "list", "sorted"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ",", "\n", "milestones", ",", "\n", "gamma", "=", "0.1", ",", "\n", "warmup_factor", "=", "1.0", "/", "3", ",", "\n", "warmup_iters", "=", "500", ",", "\n", "warmup_method", "=", "\"linear\"", ",", "\n", "last_epoch", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "if", "not", "list", "(", "milestones", ")", "==", "sorted", "(", "milestones", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Milestones should be a list of\"", "\" increasing integers. Got {}\"", ",", "\n", "milestones", ",", "\n", ")", "\n", "\n", "", "if", "warmup_method", "not", "in", "(", "\"constant\"", ",", "\"linear\"", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Only 'constant' or 'linear' warmup_method accepted\"", "\n", "\"got {}\"", ".", "format", "(", "warmup_method", ")", "\n", ")", "\n", "", "self", ".", "milestones", "=", "milestones", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", "WarmupMultiStepLR", ",", "self", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.solver.lr_scheduler.WarmupMultiStepLR.get_lr": [[39, 52], ["bisect.bisect_right", "float"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ")", ":", "\n", "        ", "warmup_factor", "=", "1", "\n", "if", "self", ".", "last_epoch", "<", "self", ".", "warmup_iters", ":", "\n", "            ", "if", "self", ".", "warmup_method", "==", "\"constant\"", ":", "\n", "                ", "warmup_factor", "=", "self", ".", "warmup_factor", "\n", "", "elif", "self", ".", "warmup_method", "==", "\"linear\"", ":", "\n", "                ", "alpha", "=", "float", "(", "self", ".", "last_epoch", ")", "/", "self", ".", "warmup_iters", "\n", "warmup_factor", "=", "self", ".", "warmup_factor", "*", "(", "1", "-", "alpha", ")", "+", "alpha", "\n", "", "", "return", "[", "\n", "base_lr", "\n", "*", "warmup_factor", "\n", "*", "self", ".", "gamma", "**", "bisect_right", "(", "self", ".", "milestones", ",", "self", ".", "last_epoch", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tools.knn_feature.cosine_sim": [[10, 19], ["torch.tensor", "torch.tensor", "torch.sum", "torch.norm", "torch.norm"], "function", ["None"], ["def", "cosine_sim", "(", "x1", ",", "x2", ",", "dim", "=", "1", ",", "eps", "=", "1e-8", ")", ":", "\n", "    ", "\"\"\"Returns cosine similarity between x1 and x2, computed along dim.\"\"\"", "\n", "x1", "=", "torch", ".", "tensor", "(", "x1", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "x2", ")", "\n", "\n", "w12", "=", "torch", ".", "sum", "(", "x1", "*", "x2", ",", "dim", ")", "\n", "w1", "=", "torch", ".", "norm", "(", "x1", ",", "2", ",", "dim", ")", "\n", "w2", "=", "torch", ".", "norm", "(", "x2", ",", "2", ",", "dim", ")", "\n", "return", "(", "w12", "/", "(", "w1", "*", "w2", ")", ".", "clamp", "(", "min", "=", "eps", ")", ")", ".", "squeeze", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tools.knn_feature.l2_sim": [[21, 26], ["torch.tensor", "torch.tensor", "torch.pow", "torch.sum"], "function", ["None"], ["", "def", "l2_sim", "(", "x1", ",", "x2", ",", "dim", "=", "1", ")", ":", "\n", "    ", "x1", "=", "torch", ".", "tensor", "(", "x1", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "x2", ")", "\n", "\n", "return", "torch", ".", "pow", "(", "torch", ".", "sum", "(", "(", "x1", "-", "x2", ")", ".", "pow", "(", "2", ")", ",", "dim", ")", ",", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tools.test_net.main": [[27, 110], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "vc_rcnn.config.cfg.merge_from_file", "vc_rcnn.config.cfg.merge_from_list", "vc_rcnn.config.cfg.freeze", "vc_rcnn.utils.logger.setup_logger", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.modeling.detector.build_detection_model", "vc_rcnn.modeling.detector.build_detection_model.to", "amp.init", "vc_rcnn.utils.checkpoint.DetectronCheckpointer", "vc_rcnn.utils.checkpoint.DetectronCheckpointer.load", "vc_rcnn.data.make_data_loader", "zip", "int", "torch.cuda.set_device", "torch.distributed.init_process_group", "vc_rcnn.utils.comm.synchronize", "vc_rcnn.utils.comm.get_rank", "len", "enumerate", "vc_rcnn.engine.inference.inference", "vc_rcnn.utils.comm.synchronize", "vc_rcnn.utils.collect_env.collect_env_info", "os.path.join", "vc_rcnn.utils.miscellaneous.mkdir"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.MCAN_VC.run.parse_args", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.logger.setup_logger", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.detector.detectors.build_detection_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.make_data_loader", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.inference.inference", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.collect_env.collect_env_info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"PyTorch Object Detection Inference\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config-file\"", ",", "\n", "default", "=", "\"/private/home/fmassa/github/detectron.pytorch_v2/configs/e2e_faster_rcnn_R_50_C4_1x_caffe2.yaml\"", ",", "\n", "metavar", "=", "\"FILE\"", ",", "\n", "help", "=", "\"path to config file\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--local_rank\"", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--ckpt\"", ",", "\n", "help", "=", "\"The path to the checkpoint for test, default is the latest checkpoint.\"", ",", "\n", "default", "=", "None", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line\"", ",", "\n", "default", "=", "None", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "num_gpus", "=", "int", "(", "os", ".", "environ", "[", "\"WORLD_SIZE\"", "]", ")", "if", "\"WORLD_SIZE\"", "in", "os", ".", "environ", "else", "1", "\n", "distributed", "=", "num_gpus", ">", "1", "\n", "\n", "if", "distributed", ":", "\n", "        ", "torch", ".", "cuda", ".", "set_device", "(", "args", ".", "local_rank", ")", "\n", "torch", ".", "distributed", ".", "init_process_group", "(", "\n", "backend", "=", "\"nccl\"", ",", "init_method", "=", "\"env://\"", "\n", ")", "\n", "synchronize", "(", ")", "\n", "\n", "", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "\n", "save_dir", "=", "\"\"", "\n", "logger", "=", "setup_logger", "(", "\"vc_rcnn\"", ",", "save_dir", ",", "get_rank", "(", ")", ")", "\n", "logger", ".", "info", "(", "\"Using {} GPUs\"", ".", "format", "(", "num_gpus", ")", ")", "\n", "logger", ".", "info", "(", "cfg", ")", "\n", "\n", "logger", ".", "info", "(", "\"Collecting env info (might take some time)\"", ")", "\n", "logger", ".", "info", "(", "\"\\n\"", "+", "collect_env_info", "(", ")", ")", "\n", "\n", "model", "=", "build_detection_model", "(", "cfg", ")", "\n", "model", ".", "to", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", "\n", "\n", "# Initialize mixed-precision if necessary", "\n", "use_mixed_precision", "=", "cfg", ".", "DTYPE", "==", "'float16'", "\n", "amp_handle", "=", "amp", ".", "init", "(", "enabled", "=", "use_mixed_precision", ",", "verbose", "=", "cfg", ".", "AMP_VERBOSE", ")", "\n", "\n", "output_dir", "=", "cfg", ".", "OUTPUT_DIR", "\n", "checkpointer", "=", "DetectronCheckpointer", "(", "cfg", ",", "model", ",", "save_dir", "=", "output_dir", ")", "\n", "ckpt", "=", "cfg", ".", "MODEL", ".", "WEIGHT", "if", "args", ".", "ckpt", "is", "None", "else", "args", ".", "ckpt", "\n", "_", "=", "checkpointer", ".", "load", "(", "ckpt", ",", "use_latest", "=", "args", ".", "ckpt", "is", "None", ")", "\n", "\n", "iou_types", "=", "(", "\"bbox\"", ",", ")", "\n", "if", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "        ", "iou_types", "=", "iou_types", "+", "(", "\"segm\"", ",", ")", "\n", "", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "        ", "iou_types", "=", "iou_types", "+", "(", "\"keypoints\"", ",", ")", "\n", "", "output_folders", "=", "[", "None", "]", "*", "len", "(", "cfg", ".", "DATASETS", ".", "TEST", ")", "\n", "dataset_names", "=", "cfg", ".", "DATASETS", ".", "TEST", "\n", "if", "cfg", ".", "OUTPUT_DIR", ":", "\n", "        ", "for", "idx", ",", "dataset_name", "in", "enumerate", "(", "dataset_names", ")", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ",", "dataset_name", ")", "\n", "mkdir", "(", "output_folder", ")", "\n", "output_folders", "[", "idx", "]", "=", "output_folder", "\n", "", "", "data_loaders_val", "=", "make_data_loader", "(", "cfg", ",", "is_train", "=", "False", ",", "is_distributed", "=", "distributed", ")", "\n", "for", "output_folder", ",", "dataset_name", ",", "data_loader_val", "in", "zip", "(", "output_folders", ",", "dataset_names", ",", "data_loaders_val", ")", ":", "\n", "        ", "inference", "(", "\n", "model", ",", "\n", "data_loader_val", ",", "\n", "dataset_name", "=", "dataset_name", ",", "\n", "iou_types", "=", "iou_types", ",", "\n", "box_only", "=", "False", "if", "cfg", ".", "MODEL", ".", "RETINANET_ON", "else", "cfg", ".", "MODEL", ".", "RPN_ONLY", ",", "\n", "device", "=", "cfg", ".", "MODEL", ".", "DEVICE", ",", "\n", "expected_results", "=", "cfg", ".", "TEST", ".", "EXPECTED_RESULTS", ",", "\n", "expected_results_sigma_tol", "=", "cfg", ".", "TEST", ".", "EXPECTED_RESULTS_SIGMA_TOL", ",", "\n", "output_folder", "=", "output_folder", ",", "\n", ")", "\n", "synchronize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tools.train_net.train": [[37, 98], ["vc_rcnn.modeling.detector.build_detection_model", "torch.device", "torch.nn.parallel.DistributedDataParallel.to", "vc_rcnn.solver.make_optimizer", "vc_rcnn.solver.make_lr_scheduler", "amp.initialize", "vc_rcnn.utils.checkpoint.DetectronCheckpointer", "vc_rcnn.utils.checkpoint.DetectronCheckpointer.load", "arguments.update", "vc_rcnn.data.make_data_loader", "vc_rcnn.engine.trainer.do_train", "torch.nn.parallel.DistributedDataParallel", "vc_rcnn.utils.comm.get_rank", "vc_rcnn.utils.metric_logger.TensorboardLogger", "vc_rcnn.utils.metric_logger.MetricLogger"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.detector.detectors.build_detection_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.solver.build.make_optimizer", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.solver.build.make_lr_scheduler", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.make_data_loader", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.trainer.do_train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank"], ["", "def", "train", "(", "cfg", ",", "local_rank", ",", "distributed", ",", "use_tensorboard", "=", "False", ")", ":", "\n", "    ", "model", "=", "build_detection_model", "(", "cfg", ")", "\n", "device", "=", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", "\n", "model", ".", "to", "(", "device", ")", "\n", "\n", "optimizer", "=", "make_optimizer", "(", "cfg", ",", "model", ")", "\n", "scheduler", "=", "make_lr_scheduler", "(", "cfg", ",", "optimizer", ")", "\n", "\n", "# Initialize mixed-precision training", "\n", "use_mixed_precision", "=", "cfg", ".", "DTYPE", "==", "\"float16\"", "\n", "amp_opt_level", "=", "'O1'", "if", "use_mixed_precision", "else", "'O0'", "\n", "model", ",", "optimizer", "=", "amp", ".", "initialize", "(", "model", ",", "optimizer", ",", "opt_level", "=", "amp_opt_level", ")", "\n", "\n", "if", "distributed", ":", "\n", "        ", "model", "=", "torch", ".", "nn", ".", "parallel", ".", "DistributedDataParallel", "(", "\n", "model", ",", "device_ids", "=", "[", "local_rank", "]", ",", "output_device", "=", "local_rank", ",", "\n", "# this should be removed if we update BatchNorm stats", "\n", "broadcast_buffers", "=", "False", ",", "\n", ")", "\n", "\n", "", "arguments", "=", "{", "}", "\n", "arguments", "[", "\"iteration\"", "]", "=", "0", "\n", "\n", "output_dir", "=", "cfg", ".", "OUTPUT_DIR", "\n", "\n", "save_to_disk", "=", "get_rank", "(", ")", "==", "0", "\n", "checkpointer", "=", "DetectronCheckpointer", "(", "\n", "cfg", ",", "model", ",", "optimizer", ",", "scheduler", ",", "output_dir", ",", "save_to_disk", "\n", ")", "\n", "extra_checkpoint_data", "=", "checkpointer", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHT", ")", "\n", "arguments", ".", "update", "(", "extra_checkpoint_data", ")", "\n", "\n", "data_loader", "=", "make_data_loader", "(", "\n", "cfg", ",", "\n", "is_train", "=", "True", ",", "\n", "is_distributed", "=", "distributed", ",", "\n", "start_iter", "=", "arguments", "[", "\"iteration\"", "]", ",", "\n", ")", "\n", "\n", "checkpoint_period", "=", "cfg", ".", "SOLVER", ".", "CHECKPOINT_PERIOD", "\n", "if", "use_tensorboard", ":", "\n", "        ", "meters", "=", "TensorboardLogger", "(", "\n", "log_dir", "=", "cfg", ".", "TENSORBOARD_EXPERIMENT", ",", "\n", "start_iter", "=", "arguments", "[", "'iteration'", "]", ",", "\n", "delimiter", "=", "\"  \"", ")", "\n", "", "else", ":", "\n", "        ", "meters", "=", "MetricLogger", "(", "delimiter", "=", "\"  \"", ")", "\n", "", "do_train", "(", "\n", "model", ",", "\n", "data_loader", ",", "\n", "optimizer", ",", "\n", "scheduler", ",", "\n", "checkpointer", ",", "\n", "device", ",", "\n", "checkpoint_period", ",", "\n", "arguments", ",", "\n", "meters", ",", "\n", "cfg", "\n", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tools.train_net.run_test": [[100, 130], ["torch.cuda.empty_cache", "vc_rcnn.data.make_data_loader", "zip", "len", "enumerate", "vc_rcnn.engine.inference.inference", "vc_rcnn.utils.comm.synchronize", "os.path.join", "vc_rcnn.utils.miscellaneous.mkdir", "vc_rcnn.config.cfg"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.build.make_data_loader", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.engine.inference.inference", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir"], ["", "def", "run_test", "(", "cfg", ",", "model", ",", "distributed", ")", ":", "\n", "    ", "if", "distributed", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "# TODO check if it helps", "\n", "iou_types", "=", "(", "\"bbox\"", ",", ")", "\n", "if", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "        ", "iou_types", "=", "iou_types", "+", "(", "\"segm\"", ",", ")", "\n", "", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "        ", "iou_types", "=", "iou_types", "+", "(", "\"keypoints\"", ",", ")", "\n", "", "output_folders", "=", "[", "None", "]", "*", "len", "(", "cfg", ".", "DATASETS", ".", "TEST", ")", "\n", "dataset_names", "=", "cfg", ".", "DATASETS", ".", "TEST", "\n", "if", "cfg", ".", "OUTPUT_DIR", ":", "\n", "        ", "for", "idx", ",", "dataset_name", "in", "enumerate", "(", "dataset_names", ")", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ",", "dataset_name", ")", "\n", "mkdir", "(", "output_folder", ")", "\n", "output_folders", "[", "idx", "]", "=", "output_folder", "\n", "", "", "data_loaders_val", "=", "make_data_loader", "(", "cfg", ",", "is_train", "=", "False", ",", "is_distributed", "=", "distributed", ")", "\n", "for", "output_folder", ",", "dataset_name", ",", "data_loader_val", "in", "zip", "(", "output_folders", ",", "dataset_names", ",", "data_loaders_val", ")", ":", "\n", "        ", "inference", "(", "\n", "model", ",", "\n", "data_loader_val", ",", "\n", "dataset_name", "=", "dataset_name", ",", "\n", "iou_types", "=", "iou_types", ",", "\n", "box_only", "=", "False", "if", "cfg", ".", "MODEL", ".", "RETINANET_ON", "else", "cfg", ".", "MODEL", ".", "RPN_ONLY", ",", "\n", "device", "=", "cfg", ".", "MODEL", ".", "DEVICE", ",", "\n", "expected_results", "=", "cfg", ".", "TEST", ".", "EXPECTED_RESULTS", ",", "\n", "expected_results_sigma_tol", "=", "cfg", ".", "TEST", ".", "EXPECTED_RESULTS_SIGMA_TOL", ",", "\n", "output_folder", "=", "output_folder", ",", "\n", ")", "\n", "synchronize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tools.train_net.main": [[132, 210], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "vc_rcnn.config.cfg.merge_from_file", "vc_rcnn.config.cfg.merge_from_list", "vc_rcnn.config.cfg.freeze", "vc_rcnn.utils.logger.setup_logger", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.utils.logger.setup_logger.info", "os.path.join", "vc_rcnn.utils.logger.setup_logger.info", "vc_rcnn.utils.miscellaneous.save_config", "train_net.train", "int", "torch.cuda.set_device", "torch.distributed.init_process_group", "vc_rcnn.utils.comm.synchronize", "vc_rcnn.utils.miscellaneous.mkdir", "vc_rcnn.utils.comm.get_rank", "open", "vc_rcnn.utils.logger.setup_logger.info", "train_net.run_test", "vc_rcnn.utils.collect_env.collect_env_info", "cf.read"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.MCAN_VC.run.parse_args", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.logger.setup_logger", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.save_config", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.get_rank", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.info", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tools.train_net.run_test", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.collect_env.collect_env_info"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"PyTorch Object Detection Training\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config-file\"", ",", "\n", "default", "=", "\"\"", ",", "\n", "metavar", "=", "\"FILE\"", ",", "\n", "help", "=", "\"path to config file\"", ",", "\n", "type", "=", "str", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--local_rank\"", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--skip-test\"", ",", "\n", "dest", "=", "\"skip_test\"", ",", "\n", "help", "=", "\"Do not test the final model\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--use-tensorboard\"", ",", "\n", "dest", "=", "\"use_tensorboard\"", ",", "\n", "help", "=", "\"Use tensorboardX logger (Requires tensorboardX installed)\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "default", "=", "False", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line\"", ",", "\n", "default", "=", "None", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "num_gpus", "=", "int", "(", "os", ".", "environ", "[", "\"WORLD_SIZE\"", "]", ")", "if", "\"WORLD_SIZE\"", "in", "os", ".", "environ", "else", "1", "\n", "args", ".", "distributed", "=", "num_gpus", ">", "1", "\n", "\n", "if", "args", ".", "distributed", ":", "\n", "        ", "torch", ".", "cuda", ".", "set_device", "(", "args", ".", "local_rank", ")", "\n", "torch", ".", "distributed", ".", "init_process_group", "(", "\n", "backend", "=", "\"nccl\"", ",", "init_method", "=", "\"env://\"", "\n", ")", "\n", "synchronize", "(", ")", "\n", "\n", "", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "\n", "output_dir", "=", "cfg", ".", "OUTPUT_DIR", "\n", "if", "output_dir", ":", "\n", "        ", "mkdir", "(", "output_dir", ")", "\n", "\n", "", "logger", "=", "setup_logger", "(", "\"vc_rcnn\"", ",", "output_dir", ",", "get_rank", "(", ")", ")", "\n", "logger", ".", "info", "(", "\"Using {} GPUs\"", ".", "format", "(", "num_gpus", ")", ")", "\n", "logger", ".", "info", "(", "args", ")", "\n", "\n", "logger", ".", "info", "(", "\"Collecting env info (might take some time)\"", ")", "\n", "logger", ".", "info", "(", "\"\\n\"", "+", "collect_env_info", "(", ")", ")", "\n", "\n", "logger", ".", "info", "(", "\"Loaded configuration file {}\"", ".", "format", "(", "args", ".", "config_file", ")", ")", "\n", "with", "open", "(", "args", ".", "config_file", ",", "\"r\"", ")", "as", "cf", ":", "\n", "        ", "config_str", "=", "\"\\n\"", "+", "cf", ".", "read", "(", ")", "\n", "logger", ".", "info", "(", "config_str", ")", "\n", "", "logger", ".", "info", "(", "\"Running with config:\\n{}\"", ".", "format", "(", "cfg", ")", ")", "\n", "\n", "output_config_path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "'config.yml'", ")", "\n", "logger", ".", "info", "(", "\"Saving config into: {}\"", ".", "format", "(", "output_config_path", ")", ")", "\n", "# save overloaded model config in the output directory", "\n", "save_config", "(", "cfg", ",", "output_config_path", ")", "\n", "\n", "# model = train(cfg, args.local_rank, args.distributed)", "\n", "model", "=", "train", "(", "\n", "cfg", "=", "cfg", ",", "\n", "local_rank", "=", "args", ".", "local_rank", ",", "\n", "distributed", "=", "args", ".", "distributed", ",", "\n", "use_tensorboard", "=", "args", ".", "use_tensorboard", "\n", ")", "\n", "\n", "if", "not", "args", ".", "skip_test", ":", "\n", "        ", "run_test", "(", "cfg", ",", "model", ",", "args", ".", "distributed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloaderraw.DataLoaderRaw.__init__": [[26, 83], ["opt.get", "opt.get", "opt.get", "opt.get", "dataloaderraw.DataLoaderRaw.my_resnet.load_state_dict", "misc.resnet_utils.myResnet", "dataloaderraw.DataLoaderRaw.my_resnet.cuda", "dataloaderraw.DataLoaderRaw.my_resnet.eval", "print", "print", "len", "print", "getattr", "torch.load", "len", "len", "print", "json.load", "enumerate", "print", "os.walk", "open", "os.path.join", "dataloaderraw.DataLoaderRaw.files.append", "dataloaderraw.DataLoaderRaw.ids.append", "f.rfind", "os.path.join", "dataloaderraw.DataLoaderRaw.__init__.isImage"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "opt", "=", "opt", "\n", "self", ".", "coco_json", "=", "opt", ".", "get", "(", "'coco_json'", ",", "''", ")", "\n", "self", ".", "folder_path", "=", "opt", ".", "get", "(", "'folder_path'", ",", "''", ")", "\n", "\n", "self", ".", "batch_size", "=", "opt", ".", "get", "(", "'batch_size'", ",", "1", ")", "\n", "self", ".", "seq_per_img", "=", "1", "\n", "\n", "# Load resnet", "\n", "self", ".", "cnn_model", "=", "opt", ".", "get", "(", "'cnn_model'", ",", "'resnet101'", ")", "\n", "self", ".", "my_resnet", "=", "getattr", "(", "misc", ".", "resnet", ",", "self", ".", "cnn_model", ")", "(", ")", "\n", "self", ".", "my_resnet", ".", "load_state_dict", "(", "torch", ".", "load", "(", "'./data/imagenet_weights/'", "+", "self", ".", "cnn_model", "+", "'.pth'", ")", ")", "\n", "self", ".", "my_resnet", "=", "myResnet", "(", "self", ".", "my_resnet", ")", "\n", "self", ".", "my_resnet", ".", "cuda", "(", ")", "\n", "self", ".", "my_resnet", ".", "eval", "(", ")", "\n", "\n", "\n", "\n", "# load the json file which contains additional information about the dataset", "\n", "print", "(", "'DataLoaderRaw loading images from folder: '", ",", "self", ".", "folder_path", ")", "\n", "\n", "self", ".", "files", "=", "[", "]", "\n", "self", ".", "ids", "=", "[", "]", "\n", "\n", "print", "(", "len", "(", "self", ".", "coco_json", ")", ")", "\n", "if", "len", "(", "self", ".", "coco_json", ")", ">", "0", ":", "\n", "            ", "print", "(", "'reading from '", "+", "opt", ".", "coco_json", ")", "\n", "# read in filenames from the coco-style json file", "\n", "self", ".", "coco_annotation", "=", "json", ".", "load", "(", "open", "(", "self", ".", "coco_json", ")", ")", "\n", "for", "k", ",", "v", "in", "enumerate", "(", "self", ".", "coco_annotation", "[", "'images'", "]", ")", ":", "\n", "                ", "fullpath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "folder_path", ",", "v", "[", "'file_name'", "]", ")", "\n", "self", ".", "files", ".", "append", "(", "fullpath", ")", "\n", "self", ".", "ids", ".", "append", "(", "v", "[", "'id'", "]", ")", "\n", "", "", "else", ":", "\n", "# read in all the filenames from the folder", "\n", "            ", "print", "(", "'listing all images in directory '", "+", "self", ".", "folder_path", ")", "\n", "def", "isImage", "(", "f", ")", ":", "\n", "                ", "supportedExt", "=", "[", "'.jpg'", ",", "'.JPG'", ",", "'.jpeg'", ",", "'.JPEG'", ",", "'.png'", ",", "'.PNG'", ",", "'.ppm'", ",", "'.PPM'", "]", "\n", "for", "ext", "in", "supportedExt", ":", "\n", "                    ", "start_idx", "=", "f", ".", "rfind", "(", "ext", ")", "\n", "if", "start_idx", ">=", "0", "and", "start_idx", "+", "len", "(", "ext", ")", "==", "len", "(", "f", ")", ":", "\n", "                        ", "return", "True", "\n", "", "", "return", "False", "\n", "\n", "", "n", "=", "1", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "self", ".", "folder_path", ",", "topdown", "=", "False", ")", ":", "\n", "                ", "for", "file", "in", "files", ":", "\n", "                    ", "fullpath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "folder_path", ",", "file", ")", "\n", "if", "isImage", "(", "fullpath", ")", ":", "\n", "                        ", "self", ".", "files", ".", "append", "(", "fullpath", ")", "\n", "self", ".", "ids", ".", "append", "(", "str", "(", "n", ")", ")", "# just order them sequentially", "\n", "n", "=", "n", "+", "1", "\n", "\n", "", "", "", "", "self", ".", "N", "=", "len", "(", "self", ".", "files", ")", "\n", "print", "(", "'DataLoaderRaw found '", ",", "self", ".", "N", ",", "' images'", ")", "\n", "\n", "self", ".", "iterator", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloaderraw.DataLoaderRaw.get_batch": [[84, 131], ["numpy.ndarray", "numpy.ndarray", "range", "numpy.ndarray.reshape", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "torch.from_numpy().cuda", "preprocess", "tmp_fc.data.cpu().float().numpy", "tmp_att.data.cpu().float().numpy", "infos.append", "len", "numpy.concatenate", "img[].astype", "torch.no_grad", "dataloaderraw.DataLoaderRaw.my_resnet", "torch.from_numpy", "tmp_fc.data.cpu().float", "tmp_att.data.cpu().float", "numpy.concatenate.transpose", "tmp_fc.data.cpu", "tmp_att.data.cpu"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "get_batch", "(", "self", ",", "split", ",", "batch_size", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "batch_size", "or", "self", ".", "batch_size", "\n", "\n", "# pick an index of the datapoint to load next", "\n", "fc_batch", "=", "np", ".", "ndarray", "(", "(", "batch_size", ",", "2048", ")", ",", "dtype", "=", "'float32'", ")", "\n", "att_batch", "=", "np", ".", "ndarray", "(", "(", "batch_size", ",", "14", ",", "14", ",", "2048", ")", ",", "dtype", "=", "'float32'", ")", "\n", "max_index", "=", "self", ".", "N", "\n", "wrapped", "=", "False", "\n", "infos", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "ri", "=", "self", ".", "iterator", "\n", "ri_next", "=", "ri", "+", "1", "\n", "if", "ri_next", ">=", "max_index", ":", "\n", "                ", "ri_next", "=", "0", "\n", "wrapped", "=", "True", "\n", "# wrap back around", "\n", "", "self", ".", "iterator", "=", "ri_next", "\n", "\n", "img", "=", "skimage", ".", "io", ".", "imread", "(", "self", ".", "files", "[", "ri", "]", ")", "\n", "\n", "if", "len", "(", "img", ".", "shape", ")", "==", "2", ":", "\n", "                ", "img", "=", "img", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "img", "=", "np", ".", "concatenate", "(", "(", "img", ",", "img", ",", "img", ")", ",", "axis", "=", "2", ")", "\n", "\n", "", "img", "=", "img", "[", ":", ",", ":", ",", ":", "3", "]", ".", "astype", "(", "'float32'", ")", "/", "255.0", "\n", "img", "=", "torch", ".", "from_numpy", "(", "img", ".", "transpose", "(", "[", "2", ",", "0", ",", "1", "]", ")", ")", ".", "cuda", "(", ")", "\n", "img", "=", "preprocess", "(", "img", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "tmp_fc", ",", "tmp_att", "=", "self", ".", "my_resnet", "(", "img", ")", "\n", "\n", "", "fc_batch", "[", "i", "]", "=", "tmp_fc", ".", "data", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", "\n", "att_batch", "[", "i", "]", "=", "tmp_att", ".", "data", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "info_struct", "=", "{", "}", "\n", "info_struct", "[", "'id'", "]", "=", "self", ".", "ids", "[", "ri", "]", "\n", "info_struct", "[", "'file_path'", "]", "=", "self", ".", "files", "[", "ri", "]", "\n", "infos", ".", "append", "(", "info_struct", ")", "\n", "\n", "", "data", "=", "{", "}", "\n", "data", "[", "'fc_feats'", "]", "=", "fc_batch", "\n", "data", "[", "'att_feats'", "]", "=", "att_batch", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "2048", ")", "\n", "data", "[", "'att_masks'", "]", "=", "None", "\n", "data", "[", "'bounds'", "]", "=", "{", "'it_pos_now'", ":", "self", ".", "iterator", ",", "'it_max'", ":", "self", ".", "N", ",", "'wrapped'", ":", "wrapped", "}", "\n", "data", "[", "'infos'", "]", "=", "infos", "\n", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloaderraw.DataLoaderRaw.reset_iterator": [[132, 134], ["None"], "methods", ["None"], ["", "def", "reset_iterator", "(", "self", ",", "split", ")", ":", "\n", "        ", "self", ".", "iterator", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloaderraw.DataLoaderRaw.get_vocab_size": [[135, 137], ["len"], "methods", ["None"], ["", "def", "get_vocab_size", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "ix_to_word", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloaderraw.DataLoaderRaw.get_vocab": [[138, 140], ["None"], "methods", ["None"], ["", "def", "get_vocab", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "ix_to_word", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.opts.parse_opt": [[3, 174], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.MCAN_VC.run.parse_args"], ["def", "parse_opt", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "# Data input settings", "\n", "# Parameter about VC Feature, added by Tan Wang", "\n", "parser", ".", "add_argument", "(", "'--input_att_dir_vc'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the document containing VC Feature'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_json'", ",", "type", "=", "str", ",", "default", "=", "'data/coco.json'", ",", "\n", "help", "=", "'path to the json file containing additional info and vocab'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_fc_dir'", ",", "type", "=", "str", ",", "default", "=", "'data/cocotalk_fc'", ",", "\n", "help", "=", "'path to the directory containing the preprocessed fc feats'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_att_dir'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the directory containing the preprocessed att feats'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_box_dir'", ",", "type", "=", "str", ",", "default", "=", "'data/cocotalk_box'", ",", "\n", "help", "=", "'path to the directory containing the boxes of att feats'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_label_h5'", ",", "type", "=", "str", ",", "default", "=", "'data/coco_label.h5'", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--start_from'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"\"\"continue training from saved model at this path. Path must contain files saved by previous training process: \n                        'infos.pkl'         : configuration;\n                        'checkpoint'        : paths to model file(s) (created by tf).\n                                              Note: this file contains absolute paths, be careful when moving files around;\n                        'model.ckpt-*'      : file(s) with model definition (created by tf)\n                    \"\"\"", ")", "\n", "parser", ".", "add_argument", "(", "'--cached_tokens'", ",", "type", "=", "str", ",", "default", "=", "'coco-train-idxs'", ",", "\n", "help", "=", "'Cached token file for calculating cider score during self critical training.'", ")", "\n", "\n", "# Model settings", "\n", "parser", ".", "add_argument", "(", "'--caption_model'", ",", "type", "=", "str", ",", "default", "=", "\"show_tell\"", ",", "\n", "help", "=", "'show_tell, show_attend_tell, all_img, fc, att2in, att2in2, att2all2, adaatt, adaattmo, topdown, stackatt, denseatt, transformer'", ")", "\n", "parser", ".", "add_argument", "(", "'--rnn_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "'size of the rnn in number of hidden nodes in each layer'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_layers'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'number of layers in the RNN'", ")", "\n", "parser", ".", "add_argument", "(", "'--rnn_type'", ",", "type", "=", "str", ",", "default", "=", "'lstm'", ",", "\n", "help", "=", "'rnn, gru, or lstm'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_encoding_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "'the encoding size of each token in the vocabulary, and the image.'", ")", "\n", "parser", ".", "add_argument", "(", "'--att_hid_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "'the hidden size of the attention MLP; only useful in show_attend_tell; 0 if not using hidden layer'", ")", "\n", "parser", ".", "add_argument", "(", "'--fc_feat_size'", ",", "type", "=", "int", ",", "default", "=", "3072", ",", "\n", "help", "=", "'2048 for resnet, 4096 for vgg'", ")", "\n", "parser", ".", "add_argument", "(", "'--att_feat_size'", ",", "type", "=", "int", ",", "default", "=", "3072", ",", "\n", "help", "=", "'2048 for resnet, 512 for vgg'", ")", "\n", "parser", ".", "add_argument", "(", "'--logit_layers'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'number of layers in the RNN'", ")", "\n", "\n", "\n", "parser", ".", "add_argument", "(", "'--use_bn'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If 1, then do batch_normalization first in att_embed, if 2 then do bn both in the beginning and the end of att_embed'", ")", "\n", "\n", "# feature manipulation", "\n", "parser", ".", "add_argument", "(", "'--norm_att_feat'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If normalize attention features'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_box'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If use box features'", ")", "\n", "parser", ".", "add_argument", "(", "'--norm_box_feat'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If use box, do we normalize box feature'", ")", "\n", "\n", "# Optimization: General", "\n", "parser", ".", "add_argument", "(", "'--max_epochs'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'number of epochs'", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "type", "=", "int", ",", "default", "=", "16", ",", "\n", "help", "=", "'minibatch size'", ")", "\n", "parser", ".", "add_argument", "(", "'--grad_clip'", ",", "type", "=", "float", ",", "default", "=", "0.1", ",", "#5.,", "\n", "help", "=", "'clip gradients at this value'", ")", "\n", "parser", ".", "add_argument", "(", "'--drop_prob_lm'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "\n", "help", "=", "'strength of dropout in the Language Model RNN'", ")", "\n", "parser", ".", "add_argument", "(", "'--self_critical_after'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'After what epoch do we start finetuning the CNN? (-1 = disable; never finetune, 0 = finetune from start)'", ")", "\n", "parser", ".", "add_argument", "(", "'--seq_per_img'", ",", "type", "=", "int", ",", "default", "=", "5", ",", "\n", "help", "=", "'number of captions to sample for each image during training. Done for efficiency since CNN forward pass is expensive. E.g. coco has 5 sents/image'", ")", "\n", "\n", "# Sample related", "\n", "parser", ".", "add_argument", "(", "'--beam_size'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'used when sample_method = greedy, indicates number of beams in beam search. Usually 2 or 3 works well. More is not better. Set this to 1 for faster runtime but a bit worse performance.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_length'", ",", "type", "=", "int", ",", "default", "=", "20", ",", "\n", "help", "=", "'Maximum length during sampling'", ")", "\n", "parser", ".", "add_argument", "(", "'--length_penalty'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'wu_X or avg_X, X is the alpha'", ")", "\n", "parser", ".", "add_argument", "(", "'--block_trigrams'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'block repeated trigram.'", ")", "\n", "parser", ".", "add_argument", "(", "'--remove_bad_endings'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Remove bad endings'", ")", "\n", "\n", "#Optimization: for the Language Model", "\n", "parser", ".", "add_argument", "(", "'--optim'", ",", "type", "=", "str", ",", "default", "=", "'adam'", ",", "\n", "help", "=", "'what update to use? rmsprop|sgd|sgdmom|adagrad|adam'", ")", "\n", "parser", ".", "add_argument", "(", "'--learning_rate'", ",", "type", "=", "float", ",", "default", "=", "4e-4", ",", "\n", "help", "=", "'learning rate'", ")", "\n", "parser", ".", "add_argument", "(", "'--learning_rate_decay_start'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'at what iteration to start decaying learning rate? (-1 = dont) (in epoch)'", ")", "\n", "parser", ".", "add_argument", "(", "'--learning_rate_decay_every'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "\n", "help", "=", "'every how many iterations thereafter to drop LR?(in epoch)'", ")", "\n", "parser", ".", "add_argument", "(", "'--learning_rate_decay_rate'", ",", "type", "=", "float", ",", "default", "=", "0.8", ",", "\n", "help", "=", "'every how many iterations thereafter to drop LR?(in epoch)'", ")", "\n", "parser", ".", "add_argument", "(", "'--optim_alpha'", ",", "type", "=", "float", ",", "default", "=", "0.9", ",", "\n", "help", "=", "'alpha for adam'", ")", "\n", "parser", ".", "add_argument", "(", "'--optim_beta'", ",", "type", "=", "float", ",", "default", "=", "0.999", ",", "\n", "help", "=", "'beta used for adam'", ")", "\n", "parser", ".", "add_argument", "(", "'--optim_epsilon'", ",", "type", "=", "float", ",", "default", "=", "1e-8", ",", "\n", "help", "=", "'epsilon that goes into denominator for smoothing'", ")", "\n", "parser", ".", "add_argument", "(", "'--weight_decay'", ",", "type", "=", "float", ",", "default", "=", "0", ",", "\n", "help", "=", "'weight_decay'", ")", "\n", "# Transformer", "\n", "parser", ".", "add_argument", "(", "'--label_smoothing'", ",", "type", "=", "float", ",", "default", "=", "0", ",", "\n", "help", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--noamopt'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--noamopt_warmup'", ",", "type", "=", "int", ",", "default", "=", "2000", ",", "\n", "help", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--noamopt_factor'", ",", "type", "=", "float", ",", "default", "=", "1", ",", "\n", "help", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--reduce_on_plateau'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "''", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--scheduled_sampling_start'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'at what iteration to start decay gt probability'", ")", "\n", "parser", ".", "add_argument", "(", "'--scheduled_sampling_increase_every'", ",", "type", "=", "int", ",", "default", "=", "5", ",", "\n", "help", "=", "'every how many iterations thereafter to gt probability'", ")", "\n", "parser", ".", "add_argument", "(", "'--scheduled_sampling_increase_prob'", ",", "type", "=", "float", ",", "default", "=", "0.05", ",", "\n", "help", "=", "'How much to update the prob'", ")", "\n", "parser", ".", "add_argument", "(", "'--scheduled_sampling_max_prob'", ",", "type", "=", "float", ",", "default", "=", "0.25", ",", "\n", "help", "=", "'Maximum scheduled sampling prob.'", ")", "\n", "\n", "\n", "# Evaluation/Checkpointing", "\n", "parser", ".", "add_argument", "(", "'--val_images_use'", ",", "type", "=", "int", ",", "default", "=", "3200", ",", "\n", "help", "=", "'how many images to use when periodically evaluating the validation loss? (-1 = all)'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_checkpoint_every'", ",", "type", "=", "int", ",", "default", "=", "2500", ",", "\n", "help", "=", "'how often to save a model checkpoint (in iterations)?'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_history_ckpt'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'If save checkpoints at every save point'", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint_path'", ",", "type", "=", "str", ",", "default", "=", "'save'", ",", "\n", "help", "=", "'directory to store checkpointed models'", ")", "\n", "parser", ".", "add_argument", "(", "'--language_eval'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Evaluate language as well (1 = yes, 0 = no)? BLEU/CIDEr/METEOR/ROUGE_L? requires coco-caption code from Github.'", ")", "\n", "parser", ".", "add_argument", "(", "'--losses_log_every'", ",", "type", "=", "int", ",", "default", "=", "25", ",", "\n", "help", "=", "'How often do we snapshot losses, for inclusion in the progress dump? (0 = disable)'", ")", "\n", "parser", ".", "add_argument", "(", "'--load_best_score'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Do we load previous best score when resuming training.'", ")", "\n", "\n", "# misc", "\n", "parser", ".", "add_argument", "(", "'--id'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'an id identifying this run/job. used in cross-val and appended when writing progress files'", ")", "\n", "parser", ".", "add_argument", "(", "'--train_only'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'if true then use 80k, else use 110k'", ")", "\n", "\n", "\n", "# Reward", "\n", "parser", ".", "add_argument", "(", "'--cider_reward_weight'", ",", "type", "=", "float", ",", "default", "=", "1", ",", "\n", "help", "=", "'The reward weight from cider'", ")", "\n", "parser", ".", "add_argument", "(", "'--bleu_reward_weight'", ",", "type", "=", "float", ",", "default", "=", "0", ",", "\n", "help", "=", "'The reward weight from bleu4'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# Check if args are valid", "\n", "assert", "args", ".", "rnn_size", ">", "0", ",", "\"rnn_size should be greater than 0\"", "\n", "assert", "args", ".", "num_layers", ">", "0", ",", "\"num_layers should be greater than 0\"", "\n", "assert", "args", ".", "input_encoding_size", ">", "0", ",", "\"input_encoding_size should be greater than 0\"", "\n", "assert", "args", ".", "batch_size", ">", "0", ",", "\"batch_size should be greater than 0\"", "\n", "assert", "args", ".", "drop_prob_lm", ">=", "0", "and", "args", ".", "drop_prob_lm", "<", "1", ",", "\"drop_prob_lm should be between 0 and 1\"", "\n", "assert", "args", ".", "seq_per_img", ">", "0", ",", "\"seq_per_img should be greater than 0\"", "\n", "assert", "args", ".", "beam_size", ">", "0", ",", "\"beam_size should be greater than 0\"", "\n", "assert", "args", ".", "save_checkpoint_every", ">", "0", ",", "\"save_checkpoint_every should be greater than 0\"", "\n", "assert", "args", ".", "losses_log_every", ">", "0", ",", "\"losses_log_every should be greater than 0\"", "\n", "assert", "args", ".", "language_eval", "==", "0", "or", "args", ".", "language_eval", "==", "1", ",", "\"language_eval should be 0 or 1\"", "\n", "assert", "args", ".", "load_best_score", "==", "0", "or", "args", ".", "load_best_score", "==", "1", ",", "\"language_eval should be 0 or 1\"", "\n", "assert", "args", ".", "train_only", "==", "0", "or", "args", ".", "train_only", "==", "1", ",", "\"language_eval should be 0 or 1\"", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.opts.add_eval_options": [[175, 238], ["parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "function", ["None"], ["", "def", "add_eval_options", "(", "parser", ")", ":", "\n", "# Basic options", "\n", "    ", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'if > 0 then overrule, otherwise load from checkpoint.'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_images'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'how many images to use when periodically evaluating the loss? (-1 = all)'", ")", "\n", "parser", ".", "add_argument", "(", "'--language_eval'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Evaluate language as well (1 = yes, 0 = no)? BLEU/CIDEr/METEOR/ROUGE_L? requires coco-caption code from Github.'", ")", "\n", "parser", ".", "add_argument", "(", "'--dump_images'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Dump images into vis/imgs folder for vis? (1=yes,0=no)'", ")", "\n", "parser", ".", "add_argument", "(", "'--dump_json'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Dump json with predictions into vis folder? (1=yes,0=no)'", ")", "\n", "parser", ".", "add_argument", "(", "'--dump_path'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Write image paths along with predictions into vis json? (1=yes,0=no)'", ")", "\n", "\n", "# Sampling options", "\n", "parser", ".", "add_argument", "(", "'--sample_method'", ",", "type", "=", "str", ",", "default", "=", "'greedy'", ",", "\n", "help", "=", "'greedy; sample; gumbel; top<int>, top<0-1>'", ")", "\n", "parser", ".", "add_argument", "(", "'--beam_size'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "\n", "help", "=", "'indicates number of beams in beam search. Usually 2 or 3 works well. More is not better. Set this to 1 for faster runtime but a bit worse performance.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_length'", ",", "type", "=", "int", ",", "default", "=", "20", ",", "\n", "help", "=", "'Maximum length during sampling'", ")", "\n", "parser", ".", "add_argument", "(", "'--length_penalty'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'wu_X or avg_X, X is the alpha'", ")", "\n", "parser", ".", "add_argument", "(", "'--group_size'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'used for diverse beam search. if group_size is 1, then it\\'s normal beam search'", ")", "\n", "parser", ".", "add_argument", "(", "'--diversity_lambda'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "\n", "help", "=", "'used for diverse beam search. Usually from 0.2 to 0.8. Higher value of lambda produces a more diverse list'", ")", "\n", "parser", ".", "add_argument", "(", "'--temperature'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "'temperature when sampling from distributions (i.e. when sample_method = sample). Lower = \"safer\" predictions.'", ")", "\n", "parser", ".", "add_argument", "(", "'--decoding_constraint'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If 1, not allowing same word in a row'", ")", "\n", "parser", ".", "add_argument", "(", "'--block_trigrams'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'block repeated trigram.'", ")", "\n", "parser", ".", "add_argument", "(", "'--remove_bad_endings'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Remove bad endings'", ")", "\n", "# For evaluation on a folder of images:", "\n", "parser", ".", "add_argument", "(", "'--image_folder'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'If this is nonempty then will predict on the images in this folder path'", ")", "\n", "parser", ".", "add_argument", "(", "'--image_root'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'In case the image paths have to be preprended with a root path to an image folder'", ")", "\n", "# For evaluation on MSCOCO images from some split:", "\n", "parser", ".", "add_argument", "(", "'--input_fc_dir'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_att_dir'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_box_dir'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_label_h5'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_json'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the json file containing additional info and vocab. empty = fetch from model checkpoint.'", ")", "\n", "parser", ".", "add_argument", "(", "'--split'", ",", "type", "=", "str", ",", "default", "=", "'test'", ",", "\n", "help", "=", "'if running on MSCOCO images, which split to use: val|test|train'", ")", "\n", "parser", ".", "add_argument", "(", "'--coco_json'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'if nonempty then use this file in DataLoaderRaw (see docs there). Used only in MSCOCO test evaluation, where we have a specific json file of only test set images.'", ")", "\n", "# misc", "\n", "parser", ".", "add_argument", "(", "'--id'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'an id identifying this run/job. used only if language_eval = 1 for appending to intermediate files'", ")", "\n", "parser", ".", "add_argument", "(", "'--verbose_beam'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'if we need to print out all beam search beams.'", ")", "\n", "parser", ".", "add_argument", "(", "'--verbose_loss'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If calculate loss using ground truth during evaluation'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.train.add_summary_value": [[38, 41], ["writer.add_scalar"], "function", ["None"], ["def", "add_summary_value", "(", "writer", ",", "key", ",", "value", ",", "iteration", ")", ":", "\n", "    ", "if", "writer", ":", "\n", "        ", "writer", ".", "add_scalar", "(", "key", ",", "value", ",", "iteration", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.train.train": [[42, 271], ["misc.if_use_feat", "dataloader.DataLoader", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "dataloader.DataLoader.get_vocab", "models.setup().cuda", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "misc.loss_wrapper.LossWrapper", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel.train", "tb.SummaryWriter", "os.path.isfile", "dataloader.DataLoader.get_vocab", "utils.pickle_load.get", "misc.get_std_opt", "os.path.isfile", "utils.build_optimizer.load_state_dict", "os.path.join", "torch.save", "torch.save", "torch.save", "print", "os.path.join", "torch.save", "torch.save", "torch.save", "open", "misc.pickle_load", "os.path.join", "models.setup", "misc.build_optimizer", "misc.ReduceLROnPlateau", "misc.build_optimizer", "vars().get", "os.path.join", "torch.load", "torch.load", "torch.load", "len", "os.path.isdir", "os.makedirs", "models.setup().cuda.state_dict", "utils.build_optimizer.state_dict", "open", "misc.pickle_dump", "time.time", "dataloader.DataLoader.get_batch", "print", "torch.cuda.synchronize", "torch.cuda.synchronize", "torch.cuda.synchronize", "time.time", "utils.build_optimizer.zero_grad", "torch.nn.DataParallel.", "model_out[].mean", "model_out[].mean.backward", "misc.clip_gradient", "utils.build_optimizer.step", "model_out[].mean.item", "torch.cuda.synchronize", "torch.cuda.synchronize", "torch.cuda.synchronize", "time.time", "print", "train.train.save_checkpoint"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.if_use_feat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.get_std_opt", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.pickle_load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.__init__.setup", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.build_optimizer", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.build_optimizer", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.pickle_dump", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_batch", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.zero_grad", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_func.DeformRoIPoolingFunction.backward", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.clip_gradient", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.step", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.save_checkpoint"], ["", "", "def", "train", "(", "opt", ")", ":", "\n", "# Deal with feature things before anything", "\n", "    ", "opt", ".", "use_fc", ",", "opt", ".", "use_att", "=", "utils", ".", "if_use_feat", "(", "opt", ".", "caption_model", ")", "\n", "if", "opt", ".", "use_box", ":", "opt", ".", "att_feat_size", "=", "opt", ".", "att_feat_size", "+", "5", "\n", "\n", "loader", "=", "DataLoader", "(", "opt", ")", "\n", "opt", ".", "vocab_size", "=", "loader", ".", "vocab_size", "\n", "opt", ".", "seq_length", "=", "loader", ".", "seq_length", "\n", "\n", "tb_summary_writer", "=", "tb", "and", "tb", ".", "SummaryWriter", "(", "opt", ".", "checkpoint_path", ")", "\n", "\n", "infos", "=", "{", "}", "\n", "histories", "=", "{", "}", "\n", "if", "opt", ".", "start_from", "is", "not", "None", ":", "\n", "# open old infos and check if models are compatible", "\n", "        ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "'infos_'", "+", "opt", ".", "id", "+", "'.pkl'", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "infos", "=", "utils", ".", "pickle_load", "(", "f", ")", "\n", "saved_model_opt", "=", "infos", "[", "'opt'", "]", "\n", "need_be_same", "=", "[", "\"caption_model\"", ",", "\"rnn_type\"", ",", "\"rnn_size\"", ",", "\"num_layers\"", "]", "\n", "for", "checkme", "in", "need_be_same", ":", "\n", "                ", "assert", "vars", "(", "saved_model_opt", ")", "[", "checkme", "]", "==", "vars", "(", "opt", ")", "[", "checkme", "]", ",", "\"Command line argument and saved model disagree on '%s' \"", "%", "checkme", "\n", "\n", "", "", "if", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "'histories_'", "+", "opt", ".", "id", "+", "'.pkl'", ")", ")", ":", "\n", "            ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "'histories_'", "+", "opt", ".", "id", "+", "'.pkl'", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "histories", "=", "utils", ".", "pickle_load", "(", "f", ")", "\n", "", "", "", "else", ":", "\n", "        ", "infos", "[", "'iter'", "]", "=", "0", "\n", "infos", "[", "'epoch'", "]", "=", "0", "\n", "infos", "[", "'iterators'", "]", "=", "loader", ".", "iterators", "\n", "infos", "[", "'split_ix'", "]", "=", "loader", ".", "split_ix", "\n", "infos", "[", "'vocab'", "]", "=", "loader", ".", "get_vocab", "(", ")", "\n", "", "infos", "[", "'opt'", "]", "=", "opt", "\n", "\n", "iteration", "=", "infos", ".", "get", "(", "'iter'", ",", "0", ")", "\n", "epoch", "=", "infos", ".", "get", "(", "'epoch'", ",", "0", ")", "\n", "\n", "val_result_history", "=", "histories", ".", "get", "(", "'val_result_history'", ",", "{", "}", ")", "\n", "loss_history", "=", "histories", ".", "get", "(", "'loss_history'", ",", "{", "}", ")", "\n", "lr_history", "=", "histories", ".", "get", "(", "'lr_history'", ",", "{", "}", ")", "\n", "ss_prob_history", "=", "histories", ".", "get", "(", "'ss_prob_history'", ",", "{", "}", ")", "\n", "\n", "loader", ".", "iterators", "=", "infos", ".", "get", "(", "'iterators'", ",", "loader", ".", "iterators", ")", "\n", "loader", ".", "split_ix", "=", "infos", ".", "get", "(", "'split_ix'", ",", "loader", ".", "split_ix", ")", "\n", "if", "opt", ".", "load_best_score", "==", "1", ":", "\n", "        ", "best_val_score", "=", "infos", ".", "get", "(", "'best_val_score'", ",", "None", ")", "\n", "\n", "", "opt", ".", "vocab", "=", "loader", ".", "get_vocab", "(", ")", "\n", "model", "=", "models", ".", "setup", "(", "opt", ")", ".", "cuda", "(", ")", "\n", "del", "opt", ".", "vocab", "\n", "dp_model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "model", ")", "\n", "lw_model", "=", "LossWrapper", "(", "model", ",", "opt", ")", "\n", "dp_lw_model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "lw_model", ")", "\n", "\n", "epoch_done", "=", "True", "\n", "# Assure in training mode", "\n", "dp_lw_model", ".", "train", "(", ")", "\n", "\n", "if", "opt", ".", "noamopt", ":", "\n", "        ", "assert", "opt", ".", "caption_model", "==", "'transformer'", ",", "'noamopt can only work with transformer'", "\n", "optimizer", "=", "utils", ".", "get_std_opt", "(", "model", ",", "factor", "=", "opt", ".", "noamopt_factor", ",", "warmup", "=", "opt", ".", "noamopt_warmup", ")", "\n", "optimizer", ".", "_step", "=", "iteration", "\n", "", "elif", "opt", ".", "reduce_on_plateau", ":", "\n", "        ", "optimizer", "=", "utils", ".", "build_optimizer", "(", "model", ".", "parameters", "(", ")", ",", "opt", ")", "\n", "optimizer", "=", "utils", ".", "ReduceLROnPlateau", "(", "optimizer", ",", "factor", "=", "0.5", ",", "patience", "=", "3", ")", "\n", "", "else", ":", "\n", "        ", "optimizer", "=", "utils", ".", "build_optimizer", "(", "model", ".", "parameters", "(", ")", ",", "opt", ")", "\n", "# Load the optimizer", "\n", "", "if", "vars", "(", "opt", ")", ".", "get", "(", "'start_from'", ",", "None", ")", "is", "not", "None", "and", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "\"optimizer.pth\"", ")", ")", ":", "\n", "        ", "optimizer", ".", "load_state_dict", "(", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "'optimizer.pth'", ")", ")", ")", "\n", "\n", "\n", "", "def", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ",", "histories", "=", "None", ",", "append", "=", "''", ")", ":", "\n", "        ", "if", "len", "(", "append", ")", ">", "0", ":", "\n", "            ", "append", "=", "'-'", "+", "append", "\n", "# if checkpoint_path doesn't exist", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "opt", ".", "checkpoint_path", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "opt", ".", "checkpoint_path", ")", "\n", "", "checkpoint_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoint_path", ",", "'model%s.pth'", "%", "(", "append", ")", ")", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "checkpoint_path", ")", "\n", "print", "(", "\"model saved to {}\"", ".", "format", "(", "checkpoint_path", ")", ")", "\n", "optimizer_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoint_path", ",", "'optimizer%s.pth'", "%", "(", "append", ")", ")", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "optimizer_path", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoint_path", ",", "'infos_'", "+", "opt", ".", "id", "+", "'%s.pkl'", "%", "(", "append", ")", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "utils", ".", "pickle_dump", "(", "infos", ",", "f", ")", "\n", "", "if", "histories", ":", "\n", "            ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoint_path", ",", "'histories_'", "+", "opt", ".", "id", "+", "'%s.pkl'", "%", "(", "append", ")", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "                ", "utils", ".", "pickle_dump", "(", "histories", ",", "f", ")", "\n", "\n", "", "", "", "try", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "if", "epoch_done", ":", "\n", "                ", "if", "not", "opt", ".", "noamopt", "and", "not", "opt", ".", "reduce_on_plateau", ":", "\n", "# Assign the learning rate", "\n", "                    ", "if", "epoch", ">", "opt", ".", "learning_rate_decay_start", "and", "opt", ".", "learning_rate_decay_start", ">=", "0", ":", "\n", "                        ", "frac", "=", "(", "epoch", "-", "opt", ".", "learning_rate_decay_start", ")", "//", "opt", ".", "learning_rate_decay_every", "\n", "decay_factor", "=", "opt", ".", "learning_rate_decay_rate", "**", "frac", "\n", "opt", ".", "current_lr", "=", "opt", ".", "learning_rate", "*", "decay_factor", "\n", "", "else", ":", "\n", "                        ", "opt", ".", "current_lr", "=", "opt", ".", "learning_rate", "\n", "", "utils", ".", "set_lr", "(", "optimizer", ",", "opt", ".", "current_lr", ")", "# set the decayed rate", "\n", "# Assign the scheduled sampling prob", "\n", "", "if", "epoch", ">", "opt", ".", "scheduled_sampling_start", "and", "opt", ".", "scheduled_sampling_start", ">=", "0", ":", "\n", "                    ", "frac", "=", "(", "epoch", "-", "opt", ".", "scheduled_sampling_start", ")", "//", "opt", ".", "scheduled_sampling_increase_every", "\n", "opt", ".", "ss_prob", "=", "min", "(", "opt", ".", "scheduled_sampling_increase_prob", "*", "frac", ",", "opt", ".", "scheduled_sampling_max_prob", ")", "\n", "model", ".", "ss_prob", "=", "opt", ".", "ss_prob", "\n", "\n", "# If start self critical training", "\n", "", "if", "opt", ".", "self_critical_after", "!=", "-", "1", "and", "epoch", ">=", "opt", ".", "self_critical_after", ":", "\n", "                    ", "sc_flag", "=", "True", "\n", "init_scorer", "(", "opt", ".", "cached_tokens", ")", "\n", "", "else", ":", "\n", "                    ", "sc_flag", "=", "False", "\n", "\n", "", "epoch_done", "=", "False", "\n", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "# Load data from train split (0)", "\n", "data", "=", "loader", ".", "get_batch", "(", "'train'", ")", "\n", "print", "(", "'Read data:'", ",", "time", ".", "time", "(", ")", "-", "start", ")", "\n", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "tmp", "=", "[", "data", "[", "'fc_feats'", "]", ",", "data", "[", "'att_feats'", "]", ",", "data", "[", "'labels'", "]", ",", "data", "[", "'masks'", "]", ",", "data", "[", "'att_masks'", "]", "]", "\n", "tmp", "=", "[", "_", "if", "_", "is", "None", "else", "_", ".", "cuda", "(", ")", "for", "_", "in", "tmp", "]", "\n", "fc_feats", ",", "att_feats", ",", "labels", ",", "masks", ",", "att_masks", "=", "tmp", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "model_out", "=", "dp_lw_model", "(", "fc_feats", ",", "att_feats", ",", "labels", ",", "masks", ",", "att_masks", ",", "data", "[", "'gts'", "]", ",", "torch", ".", "arange", "(", "0", ",", "len", "(", "data", "[", "'gts'", "]", ")", ")", ",", "sc_flag", ")", "\n", "\n", "loss", "=", "model_out", "[", "'loss'", "]", ".", "mean", "(", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "utils", ".", "clip_gradient", "(", "optimizer", ",", "opt", ".", "grad_clip", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "train_loss", "=", "loss", ".", "item", "(", ")", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "sc_flag", ":", "\n", "                ", "print", "(", "\"iter {} (epoch {}), train_loss = {:.3f}, time/batch = {:.3f}\"", ".", "format", "(", "iteration", ",", "epoch", ",", "train_loss", ",", "end", "-", "start", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"iter {} (epoch {}), avg_reward = {:.3f}, time/batch = {:.3f}\"", ".", "format", "(", "iteration", ",", "epoch", ",", "model_out", "[", "'reward'", "]", ".", "mean", "(", ")", ",", "end", "-", "start", ")", ")", "\n", "\n", "# Update the iteration and epoch", "\n", "", "iteration", "+=", "1", "\n", "if", "data", "[", "'bounds'", "]", "[", "'wrapped'", "]", ":", "\n", "                ", "epoch", "+=", "1", "\n", "epoch_done", "=", "True", "\n", "\n", "# Write the training loss summary", "\n", "", "if", "(", "iteration", "%", "opt", ".", "losses_log_every", "==", "0", ")", ":", "\n", "                ", "add_summary_value", "(", "tb_summary_writer", ",", "'train_loss'", ",", "train_loss", ",", "iteration", ")", "\n", "if", "opt", ".", "noamopt", ":", "\n", "                    ", "opt", ".", "current_lr", "=", "optimizer", ".", "rate", "(", ")", "\n", "", "elif", "opt", ".", "reduce_on_plateau", ":", "\n", "                    ", "opt", ".", "current_lr", "=", "optimizer", ".", "current_lr", "\n", "", "add_summary_value", "(", "tb_summary_writer", ",", "'learning_rate'", ",", "opt", ".", "current_lr", ",", "iteration", ")", "\n", "add_summary_value", "(", "tb_summary_writer", ",", "'scheduled_sampling_prob'", ",", "model", ".", "ss_prob", ",", "iteration", ")", "\n", "if", "sc_flag", ":", "\n", "                    ", "add_summary_value", "(", "tb_summary_writer", ",", "'avg_reward'", ",", "model_out", "[", "'reward'", "]", ".", "mean", "(", ")", ",", "iteration", ")", "\n", "\n", "", "loss_history", "[", "iteration", "]", "=", "train_loss", "if", "not", "sc_flag", "else", "model_out", "[", "'reward'", "]", ".", "mean", "(", ")", "\n", "lr_history", "[", "iteration", "]", "=", "opt", ".", "current_lr", "\n", "ss_prob_history", "[", "iteration", "]", "=", "model", ".", "ss_prob", "\n", "\n", "# update infos", "\n", "", "infos", "[", "'iter'", "]", "=", "iteration", "\n", "infos", "[", "'epoch'", "]", "=", "epoch", "\n", "infos", "[", "'iterators'", "]", "=", "loader", ".", "iterators", "\n", "infos", "[", "'split_ix'", "]", "=", "loader", ".", "split_ix", "\n", "\n", "# make evaluation on validation set, and save model", "\n", "if", "(", "iteration", "%", "opt", ".", "save_checkpoint_every", "==", "0", ")", ":", "\n", "# eval model", "\n", "                ", "eval_kwargs", "=", "{", "'split'", ":", "'val'", ",", "\n", "'dataset'", ":", "opt", ".", "input_json", "}", "\n", "eval_kwargs", ".", "update", "(", "vars", "(", "opt", ")", ")", "\n", "val_loss", ",", "predictions", ",", "lang_stats", "=", "eval_utils", ".", "eval_split", "(", "\n", "dp_model", ",", "lw_model", ".", "crit", ",", "loader", ",", "eval_kwargs", ")", "\n", "\n", "if", "opt", ".", "reduce_on_plateau", ":", "\n", "                    ", "if", "'CIDEr'", "in", "lang_stats", ":", "\n", "                        ", "optimizer", ".", "scheduler_step", "(", "-", "lang_stats", "[", "'CIDEr'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "optimizer", ".", "scheduler_step", "(", "val_loss", ")", "\n", "# Write validation result into summary", "\n", "", "", "add_summary_value", "(", "tb_summary_writer", ",", "'validation loss'", ",", "val_loss", ",", "iteration", ")", "\n", "if", "lang_stats", "is", "not", "None", ":", "\n", "                    ", "for", "k", ",", "v", "in", "lang_stats", ".", "items", "(", ")", ":", "\n", "                        ", "add_summary_value", "(", "tb_summary_writer", ",", "k", ",", "v", ",", "iteration", ")", "\n", "", "", "val_result_history", "[", "iteration", "]", "=", "{", "'loss'", ":", "val_loss", ",", "'lang_stats'", ":", "lang_stats", ",", "'predictions'", ":", "predictions", "}", "\n", "\n", "# Save model if is improving on validation result", "\n", "if", "opt", ".", "language_eval", "==", "1", ":", "\n", "                    ", "current_score", "=", "lang_stats", "[", "'CIDEr'", "]", "\n", "", "else", ":", "\n", "                    ", "current_score", "=", "-", "val_loss", "\n", "\n", "", "best_flag", "=", "False", "\n", "\n", "if", "best_val_score", "is", "None", "or", "current_score", ">", "best_val_score", ":", "\n", "                    ", "best_val_score", "=", "current_score", "\n", "best_flag", "=", "True", "\n", "\n", "# Dump miscalleous informations", "\n", "", "infos", "[", "'best_val_score'", "]", "=", "best_val_score", "\n", "histories", "[", "'val_result_history'", "]", "=", "val_result_history", "\n", "histories", "[", "'loss_history'", "]", "=", "loss_history", "\n", "histories", "[", "'lr_history'", "]", "=", "lr_history", "\n", "histories", "[", "'ss_prob_history'", "]", "=", "ss_prob_history", "\n", "\n", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ",", "histories", ")", "\n", "if", "opt", ".", "save_history_ckpt", ":", "\n", "                    ", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ",", "append", "=", "str", "(", "iteration", ")", ")", "\n", "\n", "", "if", "best_flag", ":", "\n", "                    ", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ",", "append", "=", "'best'", ")", "\n", "\n", "# Stop if reaching max epochs", "\n", "", "", "if", "epoch", ">=", "opt", ".", "max_epochs", "and", "opt", ".", "max_epochs", "!=", "-", "1", ":", "\n", "                ", "break", "\n", "", "", "", "except", "(", "RuntimeError", ",", "KeyboardInterrupt", ")", ":", "\n", "        ", "print", "(", "'Save ckpt on exception ...'", ")", "\n", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ")", "\n", "print", "(", "'Save ckpt done.'", ")", "\n", "stack_trace", "=", "traceback", ".", "format_exc", "(", ")", "\n", "print", "(", "stack_trace", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.eval_utils.count_bad": [[21, 27], ["sen.split.split"], "function", ["None"], ["def", "count_bad", "(", "sen", ")", ":", "\n", "    ", "sen", "=", "sen", ".", "split", "(", "' '", ")", "\n", "if", "sen", "[", "-", "1", "]", "in", "bad_endings", ":", "\n", "        ", "return", "1", "\n", "", "else", ":", "\n", "        ", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.eval_utils.language_eval": [[28, 73], ["sys.path.append", "os.path.join", "COCO", "COCO.getImgIds", "print", "json.dump", "COCO.loadRes", "COCOEvalCap", "coco.loadRes.getImgIds", "COCOEvalCap.evaluate", "COCOEvalCap.eval.items", "os.path.join", "os.path.isdir", "os.mkdir", "open", "sum", "float", "open", "json.dump", "len", "len", "len", "eval_utils.count_bad"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.getImgIds", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.loadRes", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.getImgIds", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.evaluation.__init__.evaluate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.eval_utils.count_bad"], ["", "", "def", "language_eval", "(", "dataset", ",", "preds", ",", "model_id", ",", "split", ")", ":", "\n", "    ", "import", "sys", "\n", "sys", ".", "path", ".", "append", "(", "\"coco-caption\"", ")", "\n", "if", "'coco'", "in", "dataset", ":", "\n", "        ", "annFile", "=", "'coco-caption/annotations/captions_val2014.json'", "\n", "", "elif", "'flickr30k'", "in", "dataset", "or", "'f30k'", "in", "dataset", ":", "\n", "        ", "annFile", "=", "'coco-caption/f30k_captions4eval.json'", "\n", "", "from", "pycocotools", ".", "coco", "import", "COCO", "\n", "from", "pycocoevalcap", ".", "eval", "import", "COCOEvalCap", "\n", "\n", "# encoder.FLOAT_REPR = lambda o: format(o, '.3f')", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "'eval_results'", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'eval_results'", ")", "\n", "", "cache_path", "=", "os", ".", "path", ".", "join", "(", "'eval_results/'", ",", "'.cache_'", "+", "model_id", "+", "'_'", "+", "split", "+", "'.json'", ")", "\n", "\n", "coco", "=", "COCO", "(", "annFile", ")", "\n", "valids", "=", "coco", ".", "getImgIds", "(", ")", "\n", "\n", "# filter results to only those in MSCOCO validation set (will be about a third)", "\n", "preds_filt", "=", "[", "p", "for", "p", "in", "preds", "if", "p", "[", "'image_id'", "]", "in", "valids", "]", "\n", "print", "(", "'using %d/%d predictions'", "%", "(", "len", "(", "preds_filt", ")", ",", "len", "(", "preds", ")", ")", ")", "\n", "json", ".", "dump", "(", "preds_filt", ",", "open", "(", "cache_path", ",", "'w'", ")", ")", "# serialize to temporary json file. Sigh, COCO API...", "\n", "\n", "cocoRes", "=", "coco", ".", "loadRes", "(", "cache_path", ")", "\n", "cocoEval", "=", "COCOEvalCap", "(", "coco", ",", "cocoRes", ")", "\n", "cocoEval", ".", "params", "[", "'image_id'", "]", "=", "cocoRes", ".", "getImgIds", "(", ")", "\n", "cocoEval", ".", "evaluate", "(", ")", "\n", "\n", "# create output dictionary", "\n", "out", "=", "{", "}", "\n", "for", "metric", ",", "score", "in", "cocoEval", ".", "eval", ".", "items", "(", ")", ":", "\n", "        ", "out", "[", "metric", "]", "=", "score", "\n", "\n", "", "imgToEval", "=", "cocoEval", ".", "imgToEval", "\n", "for", "p", "in", "preds_filt", ":", "\n", "        ", "image_id", ",", "caption", "=", "p", "[", "'image_id'", "]", ",", "p", "[", "'caption'", "]", "\n", "imgToEval", "[", "image_id", "]", "[", "'caption'", "]", "=", "caption", "\n", "\n", "", "out", "[", "'bad_count_rate'", "]", "=", "sum", "(", "[", "count_bad", "(", "_", "[", "'caption'", "]", ")", "for", "_", "in", "preds_filt", "]", ")", "/", "float", "(", "len", "(", "preds_filt", ")", ")", "\n", "outfile_path", "=", "os", ".", "path", ".", "join", "(", "'eval_results/'", ",", "model_id", "+", "'_'", "+", "split", "+", "'.json'", ")", "\n", "with", "open", "(", "outfile_path", ",", "'w'", ")", "as", "outfile", ":", "\n", "        ", "json", ".", "dump", "(", "{", "'overall'", ":", "out", ",", "'imgToEval'", ":", "imgToEval", "}", ",", "outfile", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.eval_utils.eval_split": [[74, 166], ["eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "str", "model.eval", "loader.reset_iterator", "model.train", "eval_kwargs.get", "loader.get_batch", "misc.decode_sequence", "enumerate", "range", "eval_utils.language_eval", "torch.no_grad", "torch.no_grad", "range", "loader.get_vocab", "predictions.append", "min", "predictions.pop", "print", "loader.get_batch.get", "torch.no_grad", "torch.no_grad", "crit().item", "_.cuda", "print", "print", "eval_kwargs.get", "eval_kwargs.get", "print", "os.system", "print", "_.cuda", "model", "crit", "numpy.arange", "numpy.arange", "str", "model", "numpy.arange", "len", "misc.decode_sequence", "os.path.join", "loader.get_vocab", "_[].unsqueeze"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.reset_iterator", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_batch", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.decode_sequence", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.eval_utils.language_eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.decode_sequence", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab"], ["", "def", "eval_split", "(", "model", ",", "crit", ",", "loader", ",", "eval_kwargs", "=", "{", "}", ")", ":", "\n", "    ", "verbose", "=", "eval_kwargs", ".", "get", "(", "'verbose'", ",", "True", ")", "\n", "verbose_beam", "=", "eval_kwargs", ".", "get", "(", "'verbose_beam'", ",", "1", ")", "\n", "verbose_loss", "=", "eval_kwargs", ".", "get", "(", "'verbose_loss'", ",", "1", ")", "\n", "num_images", "=", "eval_kwargs", ".", "get", "(", "'num_images'", ",", "eval_kwargs", ".", "get", "(", "'val_images_use'", ",", "-", "1", ")", ")", "\n", "split", "=", "eval_kwargs", ".", "get", "(", "'split'", ",", "'val'", ")", "\n", "lang_eval", "=", "eval_kwargs", ".", "get", "(", "'language_eval'", ",", "0", ")", "\n", "dataset", "=", "eval_kwargs", ".", "get", "(", "'dataset'", ",", "'coco'", ")", "\n", "beam_size", "=", "eval_kwargs", ".", "get", "(", "'beam_size'", ",", "1", ")", "\n", "remove_bad_endings", "=", "eval_kwargs", ".", "get", "(", "'remove_bad_endings'", ",", "0", ")", "\n", "os", ".", "environ", "[", "\"REMOVE_BAD_ENDINGS\"", "]", "=", "str", "(", "remove_bad_endings", ")", "# Use this nasty way to make other code clean since it's a global configuration", "\n", "\n", "# Make sure in the evaluation mode", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "loader", ".", "reset_iterator", "(", "split", ")", "\n", "\n", "n", "=", "0", "\n", "loss", "=", "0", "\n", "loss_sum", "=", "0", "\n", "loss_evals", "=", "1e-8", "\n", "predictions", "=", "[", "]", "\n", "while", "True", ":", "\n", "        ", "data", "=", "loader", ".", "get_batch", "(", "split", ")", "\n", "n", "=", "n", "+", "loader", ".", "batch_size", "\n", "\n", "if", "data", ".", "get", "(", "'labels'", ",", "None", ")", "is", "not", "None", "and", "verbose_loss", ":", "\n", "# forward the model to get loss", "\n", "            ", "tmp", "=", "[", "data", "[", "'fc_feats'", "]", ",", "data", "[", "'att_feats'", "]", ",", "data", "[", "'labels'", "]", ",", "data", "[", "'masks'", "]", ",", "data", "[", "'att_masks'", "]", "]", "\n", "tmp", "=", "[", "_", ".", "cuda", "(", ")", "if", "_", "is", "not", "None", "else", "_", "for", "_", "in", "tmp", "]", "\n", "fc_feats", ",", "att_feats", ",", "labels", ",", "masks", ",", "att_masks", "=", "tmp", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "loss", "=", "crit", "(", "model", "(", "fc_feats", ",", "att_feats", ",", "labels", ",", "att_masks", ")", ",", "labels", "[", ":", ",", "1", ":", "]", ",", "masks", "[", ":", ",", "1", ":", "]", ")", ".", "item", "(", ")", "\n", "", "loss_sum", "=", "loss_sum", "+", "loss", "\n", "loss_evals", "=", "loss_evals", "+", "1", "\n", "\n", "# forward the model to also get generated samples for each image", "\n", "# Only leave one feature for each image, in case duplicate sample", "\n", "", "tmp", "=", "[", "data", "[", "'fc_feats'", "]", "[", "np", ".", "arange", "(", "loader", ".", "batch_size", ")", "*", "loader", ".", "seq_per_img", "]", ",", "\n", "data", "[", "'att_feats'", "]", "[", "np", ".", "arange", "(", "loader", ".", "batch_size", ")", "*", "loader", ".", "seq_per_img", "]", ",", "\n", "data", "[", "'att_masks'", "]", "[", "np", ".", "arange", "(", "loader", ".", "batch_size", ")", "*", "loader", ".", "seq_per_img", "]", "if", "data", "[", "'att_masks'", "]", "is", "not", "None", "else", "None", "]", "\n", "tmp", "=", "[", "_", ".", "cuda", "(", ")", "if", "_", "is", "not", "None", "else", "_", "for", "_", "in", "tmp", "]", "\n", "fc_feats", ",", "att_feats", ",", "att_masks", "=", "tmp", "\n", "# forward the model to also get generated samples for each image", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "seq", "=", "model", "(", "fc_feats", ",", "att_feats", ",", "att_masks", ",", "opt", "=", "eval_kwargs", ",", "mode", "=", "'sample'", ")", "[", "0", "]", ".", "data", "\n", "\n", "# Print beam search", "\n", "", "if", "beam_size", ">", "1", "and", "verbose_beam", ":", "\n", "            ", "for", "i", "in", "range", "(", "loader", ".", "batch_size", ")", ":", "\n", "                ", "print", "(", "'\\n'", ".", "join", "(", "[", "utils", ".", "decode_sequence", "(", "loader", ".", "get_vocab", "(", ")", ",", "_", "[", "'seq'", "]", ".", "unsqueeze", "(", "0", ")", ")", "[", "0", "]", "for", "_", "in", "model", ".", "done_beams", "[", "i", "]", "]", ")", ")", "\n", "print", "(", "'--'", "*", "10", ")", "\n", "", "", "sents", "=", "utils", ".", "decode_sequence", "(", "loader", ".", "get_vocab", "(", ")", ",", "seq", ")", "\n", "\n", "for", "k", ",", "sent", "in", "enumerate", "(", "sents", ")", ":", "\n", "            ", "entry", "=", "{", "'image_id'", ":", "data", "[", "'infos'", "]", "[", "k", "]", "[", "'id'", "]", ",", "'caption'", ":", "sent", "}", "\n", "if", "eval_kwargs", ".", "get", "(", "'dump_path'", ",", "0", ")", "==", "1", ":", "\n", "                ", "entry", "[", "'file_name'", "]", "=", "data", "[", "'infos'", "]", "[", "k", "]", "[", "'file_path'", "]", "\n", "", "predictions", ".", "append", "(", "entry", ")", "\n", "if", "eval_kwargs", ".", "get", "(", "'dump_images'", ",", "0", ")", "==", "1", ":", "\n", "# dump the raw image to vis/ folder", "\n", "                ", "cmd", "=", "'cp \"'", "+", "os", ".", "path", ".", "join", "(", "eval_kwargs", "[", "'image_root'", "]", ",", "data", "[", "'infos'", "]", "[", "k", "]", "[", "'file_path'", "]", ")", "+", "'\" vis/imgs/img'", "+", "str", "(", "len", "(", "predictions", ")", ")", "+", "'.jpg'", "# bit gross", "\n", "print", "(", "cmd", ")", "\n", "os", ".", "system", "(", "cmd", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "                ", "print", "(", "'image %s: %s'", "%", "(", "entry", "[", "'image_id'", "]", ",", "entry", "[", "'caption'", "]", ")", ")", "\n", "\n", "# if we wrapped around the split or used up val imgs budget then bail", "\n", "", "", "ix0", "=", "data", "[", "'bounds'", "]", "[", "'it_pos_now'", "]", "\n", "ix1", "=", "data", "[", "'bounds'", "]", "[", "'it_max'", "]", "\n", "if", "num_images", "!=", "-", "1", ":", "\n", "            ", "ix1", "=", "min", "(", "ix1", ",", "num_images", ")", "\n", "", "for", "i", "in", "range", "(", "n", "-", "ix1", ")", ":", "\n", "            ", "predictions", ".", "pop", "(", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'evaluating validation preformance... %d/%d (%f)'", "%", "(", "ix0", "-", "1", ",", "ix1", ",", "loss", ")", ")", "\n", "\n", "", "if", "data", "[", "'bounds'", "]", "[", "'wrapped'", "]", ":", "\n", "            ", "break", "\n", "", "if", "num_images", ">=", "0", "and", "n", ">=", "num_images", ":", "\n", "            ", "break", "\n", "\n", "", "", "lang_stats", "=", "None", "\n", "if", "lang_eval", "==", "1", ":", "\n", "        ", "lang_stats", "=", "language_eval", "(", "dataset", ",", "predictions", ",", "eval_kwargs", "[", "'id'", "]", ",", "split", ")", "\n", "\n", "# Switch back to training mode", "\n", "", "model", ".", "train", "(", ")", "\n", "return", "loss_sum", "/", "loss_evals", ",", "predictions", ",", "lang_stats", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.HybridLoader.__init__": [[24, 43], ["db_path.endswith", "lmdb.open", "db_path.endswith", "numpy.load", "torch.load", "torch.load", "torch.load", "torch.load", "print", "numpy.load", "os.path.isdir"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["def", "__init__", "(", "self", ",", "db_path", ",", "ext", ")", ":", "\n", "        ", "self", ".", "db_path", "=", "db_path", "\n", "self", ".", "ext", "=", "ext", "\n", "if", "self", ".", "ext", "==", "'.npy'", ":", "\n", "            ", "self", ".", "loader", "=", "lambda", "x", ":", "np", ".", "load", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "loader", "=", "lambda", "x", ":", "np", ".", "load", "(", "x", ")", "[", "'feat'", "]", "\n", "", "if", "db_path", ".", "endswith", "(", "'.lmdb'", ")", ":", "\n", "            ", "self", ".", "db_type", "=", "'lmdb'", "\n", "self", ".", "env", "=", "lmdb", ".", "open", "(", "db_path", ",", "subdir", "=", "os", ".", "path", ".", "isdir", "(", "db_path", ")", ",", "\n", "readonly", "=", "True", ",", "lock", "=", "False", ",", "\n", "readahead", "=", "False", ",", "meminit", "=", "False", ")", "\n", "", "elif", "db_path", ".", "endswith", "(", "'.pth'", ")", ":", "# Assume a key,value dictionary", "\n", "            ", "self", ".", "db_type", "=", "'pth'", "\n", "self", ".", "feat_file", "=", "torch", ".", "load", "(", "db_path", ")", "\n", "self", ".", "loader", "=", "lambda", "x", ":", "x", "\n", "print", "(", "'HybridLoader: ext is ignored'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "db_type", "=", "'dir'", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.HybridLoader.get": [[44, 60], ["dataloader.HybridLoader.loader", "six.BytesIO", "env.begin", "txn.get", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["", "", "def", "get", "(", "self", ",", "key", ")", ":", "\n", "\n", "        ", "if", "self", ".", "db_type", "==", "'lmdb'", ":", "\n", "            ", "env", "=", "self", ".", "env", "\n", "with", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "                ", "byteflow", "=", "txn", ".", "get", "(", "key", ")", "\n", "", "f_input", "=", "six", ".", "BytesIO", "(", "byteflow", ")", "\n", "", "elif", "self", ".", "db_type", "==", "'pth'", ":", "\n", "            ", "f_input", "=", "self", ".", "feat_file", "[", "key", "]", "\n", "", "else", ":", "\n", "            ", "f_input", "=", "os", ".", "path", ".", "join", "(", "self", ".", "db_path", ",", "key", "+", "self", ".", "ext", ")", "\n", "\n", "# load image", "\n", "", "feat", "=", "self", ".", "loader", "(", "f_input", ")", "\n", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.DataLoader.reset_iterator": [[64, 68], ["dataloader.BlobFetcher"], "methods", ["None"], ["    ", "def", "reset_iterator", "(", "self", ",", "split", ")", ":", "\n", "        ", "del", "self", ".", "_prefetch_process", "[", "split", "]", "\n", "self", ".", "_prefetch_process", "[", "split", "]", "=", "BlobFetcher", "(", "split", ",", "self", ",", "split", "==", "'train'", ")", "\n", "self", ".", "iterators", "[", "split", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.DataLoader.get_vocab_size": [[69, 71], ["None"], "methods", ["None"], ["", "def", "get_vocab_size", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "vocab_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.DataLoader.get_vocab": [[72, 74], ["None"], "methods", ["None"], ["", "def", "get_vocab", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "ix_to_word", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.DataLoader.get_seq_length": [[75, 77], ["None"], "methods", ["None"], ["", "def", "get_seq_length", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "seq_length", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.DataLoader.__init__": [[78, 154], ["getattr", "getattr", "getattr", "getattr", "getattr", "print", "json.load", "print", "dataloader.HybridLoader", "dataloader.HybridLoader", "dataloader.HybridLoader", "dataloader.HybridLoader", "len", "print", "range", "print", "print", "print", "dataloader.DataLoader.iterators.keys", "atexit.register", "open", "len", "print", "h5py.File", "print", "len", "dataloader.BlobFetcher", "print", "dataloader.DataLoader.iterators.keys", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append", "len", "len", "len", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys"], ["", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "opt", "=", "opt", "\n", "self", ".", "batch_size", "=", "self", ".", "opt", ".", "batch_size", "\n", "self", ".", "seq_per_img", "=", "opt", ".", "seq_per_img", "\n", "\n", "# feature related options", "\n", "self", ".", "use_fc", "=", "getattr", "(", "opt", ",", "'use_fc'", ",", "True", ")", "\n", "self", ".", "use_att", "=", "getattr", "(", "opt", ",", "'use_att'", ",", "True", ")", "\n", "self", ".", "use_box", "=", "getattr", "(", "opt", ",", "'use_box'", ",", "0", ")", "\n", "self", ".", "norm_att_feat", "=", "getattr", "(", "opt", ",", "'norm_att_feat'", ",", "0", ")", "\n", "self", ".", "norm_box_feat", "=", "getattr", "(", "opt", ",", "'norm_box_feat'", ",", "0", ")", "\n", "\n", "# load the json file which contains additional information about the dataset", "\n", "print", "(", "'DataLoader loading json file: '", ",", "opt", ".", "input_json", ")", "\n", "self", ".", "info", "=", "json", ".", "load", "(", "open", "(", "self", ".", "opt", ".", "input_json", ")", ")", "\n", "if", "'ix_to_word'", "in", "self", ".", "info", ":", "\n", "            ", "self", ".", "ix_to_word", "=", "self", ".", "info", "[", "'ix_to_word'", "]", "\n", "self", ".", "vocab_size", "=", "len", "(", "self", ".", "ix_to_word", ")", "\n", "print", "(", "'vocab size is '", ",", "self", ".", "vocab_size", ")", "\n", "\n", "# open the hdf5 file", "\n", "", "print", "(", "'DataLoader loading h5 file: '", ",", "opt", ".", "input_fc_dir", ",", "opt", ".", "input_att_dir", ",", "opt", ".", "input_box_dir", ",", "opt", ".", "input_label_h5", ")", "\n", "if", "self", ".", "opt", ".", "input_label_h5", "!=", "'none'", ":", "\n", "            ", "self", ".", "h5_label_file", "=", "h5py", ".", "File", "(", "self", ".", "opt", ".", "input_label_h5", ",", "'r'", ",", "driver", "=", "'core'", ")", "\n", "# load in the sequence data", "\n", "seq_size", "=", "self", ".", "h5_label_file", "[", "'labels'", "]", ".", "shape", "\n", "self", ".", "label", "=", "self", ".", "h5_label_file", "[", "'labels'", "]", "[", ":", "]", "\n", "self", ".", "seq_length", "=", "seq_size", "[", "1", "]", "\n", "print", "(", "'max sequence length in data is'", ",", "self", ".", "seq_length", ")", "\n", "# load the pointers in full to RAM (should be small enough)", "\n", "self", ".", "label_start_ix", "=", "self", ".", "h5_label_file", "[", "'label_start_ix'", "]", "[", ":", "]", "\n", "self", ".", "label_end_ix", "=", "self", ".", "h5_label_file", "[", "'label_end_ix'", "]", "[", ":", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "seq_length", "=", "1", "\n", "\n", "", "self", ".", "fc_loader", "=", "HybridLoader", "(", "self", ".", "opt", ".", "input_fc_dir", ",", "'.npy'", ")", "\n", "self", ".", "att_loader", "=", "HybridLoader", "(", "self", ".", "opt", ".", "input_att_dir", ",", "'.npz'", ")", "\n", "self", ".", "att_loader_vc", "=", "HybridLoader", "(", "self", ".", "opt", ".", "input_att_dir_vc", ",", "'.npy'", ")", "\n", "self", ".", "box_loader", "=", "HybridLoader", "(", "self", ".", "opt", ".", "input_box_dir", ",", "'.npy'", ")", "\n", "\n", "self", ".", "num_images", "=", "len", "(", "self", ".", "info", "[", "'images'", "]", ")", "# self.label_start_ix.shape[0]", "\n", "print", "(", "'read %d image features'", "%", "(", "self", ".", "num_images", ")", ")", "\n", "\n", "# separate out indexes for each of the provided splits", "\n", "self", ".", "split_ix", "=", "{", "'train'", ":", "[", "]", ",", "'val'", ":", "[", "]", ",", "'test'", ":", "[", "]", "}", "\n", "for", "ix", "in", "range", "(", "len", "(", "self", ".", "info", "[", "'images'", "]", ")", ")", ":", "\n", "            ", "img", "=", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "\n", "if", "not", "'split'", "in", "img", ":", "\n", "                ", "self", ".", "split_ix", "[", "'train'", "]", ".", "append", "(", "ix", ")", "\n", "self", ".", "split_ix", "[", "'val'", "]", ".", "append", "(", "ix", ")", "\n", "self", ".", "split_ix", "[", "'test'", "]", ".", "append", "(", "ix", ")", "\n", "", "elif", "img", "[", "'split'", "]", "==", "'train'", ":", "\n", "                ", "self", ".", "split_ix", "[", "'train'", "]", ".", "append", "(", "ix", ")", "\n", "", "elif", "img", "[", "'split'", "]", "==", "'val'", ":", "\n", "                ", "self", ".", "split_ix", "[", "'val'", "]", ".", "append", "(", "ix", ")", "\n", "", "elif", "img", "[", "'split'", "]", "==", "'test'", ":", "\n", "                ", "self", ".", "split_ix", "[", "'test'", "]", ".", "append", "(", "ix", ")", "\n", "", "elif", "opt", ".", "train_only", "==", "0", ":", "# restval", "\n", "                ", "self", ".", "split_ix", "[", "'train'", "]", ".", "append", "(", "ix", ")", "\n", "\n", "", "", "print", "(", "'assigned %d images to split train'", "%", "len", "(", "self", ".", "split_ix", "[", "'train'", "]", ")", ")", "\n", "print", "(", "'assigned %d images to split val'", "%", "len", "(", "self", ".", "split_ix", "[", "'val'", "]", ")", ")", "\n", "print", "(", "'assigned %d images to split test'", "%", "len", "(", "self", ".", "split_ix", "[", "'test'", "]", ")", ")", "\n", "\n", "self", ".", "iterators", "=", "{", "'train'", ":", "0", ",", "'val'", ":", "0", ",", "'test'", ":", "0", "}", "\n", "\n", "self", ".", "_prefetch_process", "=", "{", "}", "# The three prefetch process", "\n", "for", "split", "in", "self", ".", "iterators", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "_prefetch_process", "[", "split", "]", "=", "BlobFetcher", "(", "split", ",", "self", ",", "split", "==", "'train'", ")", "\n", "# Terminate the child process when the parent exists", "\n", "", "def", "cleanup", "(", ")", ":", "\n", "            ", "print", "(", "'Terminating BlobFetcher'", ")", "\n", "for", "split", "in", "self", ".", "iterators", ".", "keys", "(", ")", ":", "\n", "                ", "del", "self", ".", "_prefetch_process", "[", "split", "]", "\n", "", "", "import", "atexit", "\n", "atexit", ".", "register", "(", "cleanup", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.DataLoader.get_captions": [[155, 173], ["numpy.zeros", "range", "random.randint", "random.randint"], "methods", ["None"], ["", "def", "get_captions", "(", "self", ",", "ix", ",", "seq_per_img", ")", ":", "\n", "# fetch the sequence labels", "\n", "        ", "ix1", "=", "self", ".", "label_start_ix", "[", "ix", "]", "-", "1", "#label_start_ix starts from 1", "\n", "ix2", "=", "self", ".", "label_end_ix", "[", "ix", "]", "-", "1", "\n", "ncap", "=", "ix2", "-", "ix1", "+", "1", "# number of captions available for this image", "\n", "assert", "ncap", ">", "0", ",", "'an image does not have any label. this can be handled but right now isn\\'t'", "\n", "\n", "if", "ncap", "<", "seq_per_img", ":", "\n", "# we need to subsample (with replacement)", "\n", "            ", "seq", "=", "np", ".", "zeros", "(", "[", "seq_per_img", ",", "self", ".", "seq_length", "]", ",", "dtype", "=", "'int'", ")", "\n", "for", "q", "in", "range", "(", "seq_per_img", ")", ":", "\n", "                ", "ixl", "=", "random", ".", "randint", "(", "ix1", ",", "ix2", ")", "\n", "seq", "[", "q", ",", ":", "]", "=", "self", ".", "label", "[", "ixl", ",", ":", "self", ".", "seq_length", "]", "\n", "", "", "else", ":", "\n", "            ", "ixl", "=", "random", ".", "randint", "(", "ix1", ",", "ix2", "-", "seq_per_img", "+", "1", ")", "\n", "seq", "=", "self", ".", "label", "[", "ixl", ":", "ixl", "+", "seq_per_img", ",", ":", "self", ".", "seq_length", "]", "\n", "\n", "", "return", "seq", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.DataLoader.get_batch": [[174, 249], ["range", "zip", "numpy.stack", "max", "numpy.zeros", "range", "numpy.zeros", "range", "numpy.vstack", "numpy.array", "numpy.zeros", "enumerate", "dataloader.DataLoader._prefetch_process[].get", "fc_batch.append", "att_batch.append", "numpy.zeros", "hasattr", "label_batch.append", "hasattr", "[].get", "infos.append", "sum", "len", "len", "data[].sum", "list", "len", "gts.append", "gts.append", "sorted", "map", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.items", "torch.items", "zip", "len", "type"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["", "def", "get_batch", "(", "self", ",", "split", ",", "batch_size", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "batch_size", "or", "self", ".", "batch_size", "\n", "seq_per_img", "=", "self", ".", "seq_per_img", "\n", "\n", "fc_batch", "=", "[", "]", "# np.ndarray((batch_size * seq_per_img, self.opt.fc_feat_size), dtype = 'float32')", "\n", "att_batch", "=", "[", "]", "# np.ndarray((batch_size * seq_per_img, 14, 14, self.opt.att_feat_size), dtype = 'float32')", "\n", "label_batch", "=", "[", "]", "#np.zeros([batch_size * seq_per_img, self.seq_length + 2], dtype = 'int')", "\n", "\n", "wrapped", "=", "False", "\n", "\n", "infos", "=", "[", "]", "\n", "gts", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "# fetch image", "\n", "            ", "tmp_fc", ",", "tmp_att", ",", "tmp_seq", ",", "ix", ",", "tmp_wrapped", "=", "self", ".", "_prefetch_process", "[", "split", "]", ".", "get", "(", ")", "\n", "if", "tmp_wrapped", ":", "\n", "                ", "wrapped", "=", "True", "\n", "\n", "", "fc_batch", ".", "append", "(", "tmp_fc", ")", "\n", "att_batch", ".", "append", "(", "tmp_att", ")", "\n", "\n", "tmp_label", "=", "np", ".", "zeros", "(", "[", "seq_per_img", ",", "self", ".", "seq_length", "+", "2", "]", ",", "dtype", "=", "'int'", ")", "\n", "if", "hasattr", "(", "self", ",", "'h5_label_file'", ")", ":", "\n", "                ", "tmp_label", "[", ":", ",", "1", ":", "self", ".", "seq_length", "+", "1", "]", "=", "tmp_seq", "\n", "", "label_batch", ".", "append", "(", "tmp_label", ")", "\n", "\n", "# Used for reward evaluation", "\n", "if", "hasattr", "(", "self", ",", "'h5_label_file'", ")", ":", "\n", "                ", "gts", ".", "append", "(", "self", ".", "label", "[", "self", ".", "label_start_ix", "[", "ix", "]", "-", "1", ":", "self", ".", "label_end_ix", "[", "ix", "]", "]", ")", "\n", "", "else", ":", "\n", "                ", "gts", ".", "append", "(", "[", "]", ")", "\n", "\n", "# record associated info as well", "\n", "", "info_dict", "=", "{", "}", "\n", "info_dict", "[", "'ix'", "]", "=", "ix", "\n", "info_dict", "[", "'id'", "]", "=", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'id'", "]", "\n", "info_dict", "[", "'file_path'", "]", "=", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", ".", "get", "(", "'file_path'", ",", "''", ")", "\n", "infos", ".", "append", "(", "info_dict", ")", "\n", "\n", "# #sort by att_feat length", "\n", "# fc_batch, att_batch, label_batch, gts, infos = \\", "\n", "#     zip(*sorted(zip(fc_batch, att_batch, np.vsplit(label_batch, batch_size), gts, infos), key=lambda x: len(x[1]), reverse=True))", "\n", "", "fc_batch", ",", "att_batch", ",", "label_batch", ",", "gts", ",", "infos", "=", "zip", "(", "*", "sorted", "(", "zip", "(", "fc_batch", ",", "att_batch", ",", "label_batch", ",", "gts", ",", "infos", ")", ",", "key", "=", "lambda", "x", ":", "0", ",", "reverse", "=", "True", ")", ")", "\n", "data", "=", "{", "}", "\n", "data", "[", "'fc_feats'", "]", "=", "np", ".", "stack", "(", "sum", "(", "[", "[", "_", "]", "*", "seq_per_img", "for", "_", "in", "fc_batch", "]", ",", "[", "]", ")", ")", "\n", "# merge att_feats", "\n", "max_att_len", "=", "max", "(", "[", "_", ".", "shape", "[", "0", "]", "for", "_", "in", "att_batch", "]", ")", "\n", "data", "[", "'att_feats'", "]", "=", "np", ".", "zeros", "(", "[", "len", "(", "att_batch", ")", "*", "seq_per_img", ",", "max_att_len", ",", "att_batch", "[", "0", "]", ".", "shape", "[", "1", "]", "]", ",", "dtype", "=", "'float32'", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "att_batch", ")", ")", ":", "\n", "            ", "data", "[", "'att_feats'", "]", "[", "i", "*", "seq_per_img", ":", "(", "i", "+", "1", ")", "*", "seq_per_img", ",", ":", "att_batch", "[", "i", "]", ".", "shape", "[", "0", "]", "]", "=", "att_batch", "[", "i", "]", "\n", "", "data", "[", "'att_masks'", "]", "=", "np", ".", "zeros", "(", "data", "[", "'att_feats'", "]", ".", "shape", "[", ":", "2", "]", ",", "dtype", "=", "'float32'", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "att_batch", ")", ")", ":", "\n", "            ", "data", "[", "'att_masks'", "]", "[", "i", "*", "seq_per_img", ":", "(", "i", "+", "1", ")", "*", "seq_per_img", ",", ":", "att_batch", "[", "i", "]", ".", "shape", "[", "0", "]", "]", "=", "1", "\n", "# set att_masks to None if attention features have same length", "\n", "", "if", "data", "[", "'att_masks'", "]", ".", "sum", "(", ")", "==", "data", "[", "'att_masks'", "]", ".", "size", ":", "\n", "            ", "data", "[", "'att_masks'", "]", "=", "None", "\n", "\n", "", "data", "[", "'labels'", "]", "=", "np", ".", "vstack", "(", "label_batch", ")", "\n", "# generate mask", "\n", "nonzeros", "=", "np", ".", "array", "(", "list", "(", "map", "(", "lambda", "x", ":", "(", "x", "!=", "0", ")", ".", "sum", "(", ")", "+", "2", ",", "data", "[", "'labels'", "]", ")", ")", ")", "\n", "mask_batch", "=", "np", ".", "zeros", "(", "[", "data", "[", "'labels'", "]", ".", "shape", "[", "0", "]", ",", "self", ".", "seq_length", "+", "2", "]", ",", "dtype", "=", "'float32'", ")", "\n", "for", "ix", ",", "row", "in", "enumerate", "(", "mask_batch", ")", ":", "\n", "            ", "row", "[", ":", "nonzeros", "[", "ix", "]", "]", "=", "1", "\n", "", "data", "[", "'masks'", "]", "=", "mask_batch", "\n", "\n", "data", "[", "'gts'", "]", "=", "gts", "# all ground truth captions of each images", "\n", "data", "[", "'bounds'", "]", "=", "{", "'it_pos_now'", ":", "self", ".", "iterators", "[", "split", "]", ",", "'it_max'", ":", "len", "(", "self", ".", "split_ix", "[", "split", "]", ")", ",", "'wrapped'", ":", "wrapped", "}", "\n", "data", "[", "'infos'", "]", "=", "infos", "\n", "\n", "data", "=", "{", "k", ":", "torch", ".", "from_numpy", "(", "v", ")", "if", "type", "(", "v", ")", "is", "np", ".", "ndarray", "else", "v", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", "}", "# Turn all ndarray to torch tensor", "\n", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.DataLoader.__getitem__": [[253, 291], ["hasattr", "dataloader.DataLoader.att_loader.get", "dataloader.DataLoader.att_loader_vc.get", "numpy.hstack", "numpy.stack.reshape", "numpy.zeros", "numpy.mean", "numpy.zeros", "dataloader.DataLoader.get_captions", "str", "str", "dataloader.DataLoader.box_loader.get", "numpy.hsplit", "numpy.hstack", "numpy.hstack", "numpy.stack", "numpy.linalg.norm", "str", "sorted", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_captions", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"This function returns a tuple that is further passed to collate_fn\n        \"\"\"", "\n", "ix", "=", "index", "#self.split_ix[index]", "\n", "if", "self", ".", "use_att", ":", "\n", "            ", "att_feat", "=", "self", ".", "att_loader", ".", "get", "(", "str", "(", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'id'", "]", ")", ")", "\n", "att_feat_vc", "=", "self", ".", "att_loader_vc", ".", "get", "(", "str", "(", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'id'", "]", ")", ")", "\n", "assert", "att_feat", ".", "shape", "[", "0", "]", "==", "att_feat_vc", ".", "shape", "[", "0", "]", "\n", "att_feat", "=", "np", ".", "hstack", "(", "(", "att_feat", ",", "att_feat_vc", ")", ")", "\n", "# Reshape to K x C", "\n", "att_feat", "=", "att_feat", ".", "reshape", "(", "-", "1", ",", "att_feat", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "self", ".", "norm_att_feat", ":", "\n", "                ", "att_feat", "=", "att_feat", "/", "np", ".", "linalg", ".", "norm", "(", "att_feat", ",", "2", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "", "if", "self", ".", "use_box", ":", "\n", "                ", "box_feat", "=", "self", ".", "box_loader", ".", "get", "(", "str", "(", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'id'", "]", ")", ")", "\n", "# devided by image width and height", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "np", ".", "hsplit", "(", "box_feat", ",", "4", ")", "\n", "h", ",", "w", "=", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'height'", "]", ",", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'width'", "]", "\n", "box_feat", "=", "np", ".", "hstack", "(", "(", "x1", "/", "w", ",", "y1", "/", "h", ",", "x2", "/", "w", ",", "y2", "/", "h", ",", "(", "x2", "-", "x1", ")", "*", "(", "y2", "-", "y1", ")", "/", "(", "w", "*", "h", ")", ")", ")", "# question? x2-x1+1??", "\n", "if", "self", ".", "norm_box_feat", ":", "\n", "                    ", "box_feat", "=", "box_feat", "/", "np", ".", "linalg", ".", "norm", "(", "box_feat", ",", "2", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "", "att_feat", "=", "np", ".", "hstack", "(", "[", "att_feat", ",", "box_feat", "]", ")", "\n", "# sort the features by the size of boxes", "\n", "att_feat", "=", "np", ".", "stack", "(", "sorted", "(", "att_feat", ",", "key", "=", "lambda", "x", ":", "x", "[", "-", "1", "]", ",", "reverse", "=", "True", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "att_feat", "=", "np", ".", "zeros", "(", "(", "1", ",", "1", ",", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", "", "if", "self", ".", "use_fc", ":", "\n", "# fc_feat = self.fc_loader.get(str(self.info['images'][ix]['id']))", "\n", "            ", "fc_feat", "=", "np", ".", "mean", "(", "att_feat", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "fc_feat", "=", "np", ".", "zeros", "(", "(", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", "", "if", "hasattr", "(", "self", ",", "'h5_label_file'", ")", ":", "\n", "            ", "seq", "=", "self", ".", "get_captions", "(", "ix", ",", "self", ".", "seq_per_img", ")", "\n", "", "else", ":", "\n", "            ", "seq", "=", "None", "\n", "", "return", "(", "fc_feat", ",", "\n", "att_feat", ",", "seq", ",", "\n", "ix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.DataLoader.__len__": [[292, 294], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "info", "[", "'images'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.SubsetSampler.__init__": [[301, 303], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "indices", ")", ":", "\n", "        ", "self", ".", "indices", "=", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.SubsetSampler.__iter__": [[304, 306], ["range", "len"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "indices", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "self", ".", "indices", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.SubsetSampler.__len__": [[307, 309], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.BlobFetcher.__init__": [[312, 319], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "split", ",", "dataloader", ",", "if_shuffle", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        db is a list of tuples containing: imcrop_name, caption, bbox_feat of gt box, imname\n        \"\"\"", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "dataloader", "=", "dataloader", "\n", "self", ".", "if_shuffle", "=", "if_shuffle", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.BlobFetcher.reset": [[321, 335], ["iter", "torch.DataLoader", "torch.DataLoader", "dataloader.SubsetSampler"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Two cases for this function to be triggered:\n        1. not hasattr(self, 'split_loader'): Resume from previous training. Create the dataset given the saved split_ix and iterator\n        2. wrapped: a new epoch, the split_ix and iterator have been updated in the get_minibatch_inds already.\n        \"\"\"", "\n", "# batch_size is 1, the merge is done in DataLoader class", "\n", "self", ".", "split_loader", "=", "iter", "(", "data", ".", "DataLoader", "(", "dataset", "=", "self", ".", "dataloader", ",", "\n", "batch_size", "=", "1", ",", "\n", "sampler", "=", "SubsetSampler", "(", "self", ".", "dataloader", ".", "split_ix", "[", "self", ".", "split", "]", "[", "self", ".", "dataloader", ".", "iterators", "[", "self", ".", "split", "]", ":", "]", ")", ",", "\n", "shuffle", "=", "False", ",", "\n", "pin_memory", "=", "True", ",", "\n", "num_workers", "=", "4", ",", "# 4 is usually enough", "\n", "collate_fn", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.BlobFetcher._get_next_minibatch_inds": [[336, 352], ["len", "random.shuffle"], "methods", ["None"], ["", "def", "_get_next_minibatch_inds", "(", "self", ")", ":", "\n", "        ", "max_index", "=", "len", "(", "self", ".", "dataloader", ".", "split_ix", "[", "self", ".", "split", "]", ")", "\n", "wrapped", "=", "False", "\n", "\n", "ri", "=", "self", ".", "dataloader", ".", "iterators", "[", "self", ".", "split", "]", "\n", "ix", "=", "self", ".", "dataloader", ".", "split_ix", "[", "self", ".", "split", "]", "[", "ri", "]", "\n", "\n", "ri_next", "=", "ri", "+", "1", "\n", "if", "ri_next", ">=", "max_index", ":", "\n", "            ", "ri_next", "=", "0", "\n", "if", "self", ".", "if_shuffle", ":", "\n", "                ", "random", ".", "shuffle", "(", "self", ".", "dataloader", ".", "split_ix", "[", "self", ".", "split", "]", ")", "\n", "", "wrapped", "=", "True", "\n", "", "self", ".", "dataloader", ".", "iterators", "[", "self", ".", "split", "]", "=", "ri_next", "\n", "\n", "return", "ix", ",", "wrapped", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.Up-Down_VC.dataloader.BlobFetcher.get": [[353, 365], ["dataloader.BlobFetcher._get_next_minibatch_inds", "dataloader.BlobFetcher.split_loader.next", "hasattr", "dataloader.BlobFetcher.reset", "dataloader.BlobFetcher.reset"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher._get_next_minibatch_inds", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.reset", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.reset"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "'split_loader'", ")", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "ix", ",", "wrapped", "=", "self", ".", "_get_next_minibatch_inds", "(", ")", "\n", "tmp", "=", "self", ".", "split_loader", ".", "next", "(", ")", "\n", "if", "wrapped", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "assert", "tmp", "[", "-", "1", "]", "==", "ix", ",", "\"ix not equal\"", "\n", "\n", "return", "tmp", "+", "[", "wrapped", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.precook": [[35, 51], ["s.split", "collections.defaultdict", "xrange", "xrange", "tuple", "len"], "function", ["None"], ["\n", "words", "=", "s", ".", "split", "(", ")", "\n", "counts", "=", "defaultdict", "(", "int", ")", "\n", "for", "k", "in", "xrange", "(", "1", ",", "n", "+", "1", ")", ":", "\n", "    ", "for", "i", "in", "xrange", "(", "len", "(", "words", ")", "-", "k", "+", "1", ")", ":", "\n", "      ", "ngram", "=", "tuple", "(", "words", "[", "i", ":", "i", "+", "k", "]", ")", "\n", "counts", "[", "ngram", "]", "+=", "1", "\n", "", "", "return", "counts", "\n", "\n", "", "def", "cook_refs", "(", "refs", ",", "n", "=", "4", ")", ":", "## lhuang: oracle will call with \"average\"", "\n", "    "]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.cook_refs": [[52, 61], ["prepro_ngrams.precook"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.precook"], ["\n", "return", "[", "precook", "(", "ref", ",", "n", ")", "for", "ref", "in", "refs", "]", "\n", "\n", "", "def", "create_crefs", "(", "refs", ")", ":", "\n", "  ", "crefs", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.create_crefs": [[62, 68], ["crefs.append", "prepro_ngrams.cook_refs"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.cook_refs"], ["for", "ref", "in", "refs", ":", "\n", "# ref is a list of 5 captions", "\n", "    ", "crefs", ".", "append", "(", "cook_refs", "(", "ref", ")", ")", "\n", "", "return", "crefs", "\n", "\n", "", "def", "compute_doc_freq", "(", "crefs", ")", ":", "\n", "  "]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.compute_doc_freq": [[69, 83], ["collections.defaultdict", "set", "ref.iteritems"], "function", ["None"], ["\n", "document_frequency", "=", "defaultdict", "(", "float", ")", "\n", "for", "refs", "in", "crefs", ":", "\n", "# refs, k ref captions of one image", "\n", "    ", "for", "ngram", "in", "set", "(", "[", "ngram", "for", "ref", "in", "refs", "for", "(", "ngram", ",", "count", ")", "in", "ref", ".", "iteritems", "(", ")", "]", ")", ":", "\n", "      ", "document_frequency", "[", "ngram", "]", "+=", "1", "\n", "# maxcounts[ngram] = max(maxcounts.get(ngram,0), count)", "\n", "", "", "return", "document_frequency", "\n", "\n", "", "def", "build_dict", "(", "imgs", ",", "wtoi", ",", "params", ")", ":", "\n", "  ", "wtoi", "[", "'<eos>'", "]", "=", "0", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.build_dict": [[84, 113], ["print", "prepro_ngrams.compute_doc_freq", "prepro_ngrams.compute_doc_freq", "prepro_ngrams.create_crefs", "prepro_ngrams.create_crefs", "refs_words.append", "refs_idxs.append", "hasattr", "ref_words.append", "ref_idxs.append", "params.bpe.segment().strip().split", "params.bpe.segment().strip", "str", "params.bpe.segment"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.compute_doc_freq", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.compute_doc_freq", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.create_crefs", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.create_crefs"], ["\n", "count_imgs", "=", "0", "\n", "\n", "refs_words", "=", "[", "]", "\n", "refs_idxs", "=", "[", "]", "\n", "for", "img", "in", "imgs", ":", "\n", "    ", "if", "(", "params", "[", "'split'", "]", "==", "img", "[", "'split'", "]", ")", "or", "(", "params", "[", "'split'", "]", "==", "'train'", "and", "img", "[", "'split'", "]", "==", "'restval'", ")", "or", "(", "params", "[", "'split'", "]", "==", "'all'", ")", ":", "\n", "#(params['split'] == 'val' and img['split'] == 'restval') or \\", "\n", "      ", "ref_words", "=", "[", "]", "\n", "ref_idxs", "=", "[", "]", "\n", "for", "sent", "in", "img", "[", "'sentences'", "]", ":", "\n", "        ", "if", "hasattr", "(", "params", ",", "'bpe'", ")", ":", "\n", "          ", "sent", "[", "'tokens'", "]", "=", "params", ".", "bpe", ".", "segment", "(", "' '", ".", "join", "(", "sent", "[", "'tokens'", "]", ")", ")", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "", "tmp_tokens", "=", "sent", "[", "'tokens'", "]", "+", "[", "'<eos>'", "]", "\n", "tmp_tokens", "=", "[", "_", "if", "_", "in", "wtoi", "else", "'UNK'", "for", "_", "in", "tmp_tokens", "]", "\n", "ref_words", ".", "append", "(", "' '", ".", "join", "(", "tmp_tokens", ")", ")", "\n", "ref_idxs", ".", "append", "(", "' '", ".", "join", "(", "[", "str", "(", "wtoi", "[", "_", "]", ")", "for", "_", "in", "tmp_tokens", "]", ")", ")", "\n", "", "refs_words", ".", "append", "(", "ref_words", ")", "\n", "refs_idxs", ".", "append", "(", "ref_idxs", ")", "\n", "count_imgs", "+=", "1", "\n", "", "", "print", "(", "'total imgs:'", ",", "count_imgs", ")", "\n", "\n", "ngram_words", "=", "compute_doc_freq", "(", "create_crefs", "(", "refs_words", ")", ")", "\n", "ngram_idxs", "=", "compute_doc_freq", "(", "create_crefs", "(", "refs_idxs", ")", ")", "\n", "return", "ngram_words", ",", "ngram_idxs", ",", "count_imgs", "\n", "\n", "", "def", "main", "(", "params", ")", ":", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.main": [[114, 139], ["json.load", "json.load", "prepro_ngrams.build_dict", "misc.pickle_dump", "misc.pickle_dump", "open", "open", "tempfile.NamedTemporaryFile", "tempfile.NamedTemporaryFile.close", "open", "open", "itow.items", "open", "f.write", "codecs.open", "apply_bpe.BPE"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_ngrams.build_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.pickle_dump", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.pickle_dump"], ["  ", "imgs", "=", "json", ".", "load", "(", "open", "(", "params", "[", "'input_json'", "]", ",", "'r'", ")", ")", "\n", "dict_json", "=", "json", ".", "load", "(", "open", "(", "params", "[", "'dict_json'", "]", ",", "'r'", ")", ")", "\n", "itow", "=", "dict_json", "[", "'ix_to_word'", "]", "\n", "wtoi", "=", "{", "w", ":", "i", "for", "i", ",", "w", "in", "itow", ".", "items", "(", ")", "}", "\n", "\n", "# Load bpe", "\n", "if", "'bpe'", "in", "dict_json", ":", "\n", "    ", "import", "tempfile", "\n", "import", "codecs", "\n", "codes_f", "=", "tempfile", ".", "NamedTemporaryFile", "(", "delete", "=", "False", ")", "\n", "codes_f", ".", "close", "(", ")", "\n", "with", "open", "(", "codes_f", ".", "name", ",", "'w'", ")", "as", "f", ":", "\n", "      ", "f", ".", "write", "(", "dict_json", "[", "'bpe'", "]", ")", "\n", "", "with", "codecs", ".", "open", "(", "codes_f", ".", "name", ",", "encoding", "=", "'UTF-8'", ")", "as", "codes", ":", "\n", "      ", "bpe", "=", "apply_bpe", ".", "BPE", "(", "codes", ")", "\n", "", "params", ".", "bpe", "=", "bpe", "\n", "\n", "", "imgs", "=", "imgs", "[", "'images'", "]", "\n", "\n", "ngram_words", ",", "ngram_idxs", ",", "ref_len", "=", "build_dict", "(", "imgs", ",", "wtoi", ",", "params", ")", "\n", "\n", "utils", ".", "pickle_dump", "(", "{", "'document_frequency'", ":", "ngram_words", ",", "'ref_len'", ":", "ref_len", "}", ",", "open", "(", "params", "[", "'output_pkl'", "]", "+", "'-words.p'", ",", "'w'", ")", ")", "\n", "utils", ".", "pickle_dump", "(", "{", "'document_frequency'", ":", "ngram_idxs", ",", "'ref_len'", ":", "ref_len", "}", ",", "open", "(", "params", "[", "'output_pkl'", "]", "+", "'-idxs.p'", ",", "'w'", ")", ")", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_reference_json.main": [[39, 72], ["out.update", "enumerate", "json.dump", "print", "json.load", "out[].append", "enumerate", "open", "open", "out[].append", "img.get", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["def", "main", "(", "params", ")", ":", "\n", "\n", "    ", "imgs", "=", "json", ".", "load", "(", "open", "(", "params", "[", "'input_json'", "]", "[", "0", "]", ",", "'r'", ")", ")", "[", "'images'", "]", "\n", "# tmp = []", "\n", "# for k in imgs.keys():", "\n", "#     for img in imgs[k]:", "\n", "#         img['filename'] = img['image_id']  # k+'/'+img['image_id']", "\n", "#         img['image_id'] = int(", "\n", "#             int(hashlib.sha256(img['image_id']).hexdigest(), 16) % sys.maxint)", "\n", "#         tmp.append(img)", "\n", "# imgs = tmp", "\n", "\n", "# create output json file", "\n", "out", "=", "{", "u'info'", ":", "{", "u'description'", ":", "u'This is stable 1.0 version of the 2014 MS COCO dataset.'", ",", "u'url'", ":", "u'http://mscoco.org'", ",", "u'version'", ":", "u'1.0'", ",", "u'year'", ":", "2014", ",", "u'contributor'", ":", "u'Microsoft COCO group'", ",", "u'date_created'", ":", "u'2015-01-27 09:11:52.357475'", "}", ",", "u'licenses'", ":", "[", "{", "u'url'", ":", "u'http://creativecommons.org/licenses/by-nc-sa/2.0/'", ",", "u'id'", ":", "1", ",", "u'name'", ":", "u'Attribution-NonCommercial-ShareAlike License'", "}", ",", "{", "u'url'", ":", "u'http://creativecommons.org/licenses/by-nc/2.0/'", ",", "u'id'", ":", "2", ",", "u'name'", ":", "u'Attribution-NonCommercial License'", "}", ",", "{", "u'url'", ":", "u'http://creativecommons.org/licenses/by-nc-nd/2.0/'", ",", "u'id'", ":", "3", ",", "u'name'", ":", "u'Attribution-NonCommercial-NoDerivs License'", "}", ",", "{", "u'url'", ":", "u'http://creativecommons.org/licenses/by/2.0/'", ",", "u'id'", ":", "4", ",", "u'name'", ":", "u'Attribution License'", "}", ",", "{", "u'url'", ":", "u'http://creativecommons.org/licenses/by-sa/2.0/'", ",", "u'id'", ":", "5", ",", "u'name'", ":", "u'Attribution-ShareAlike License'", "}", ",", "{", "u'url'", ":", "u'http://creativecommons.org/licenses/by-nd/2.0/'", ",", "u'id'", ":", "6", ",", "u'name'", ":", "u'Attribution-NoDerivs License'", "}", ",", "{", "u'url'", ":", "u'http://flickr.com/commons/usage/'", ",", "u'id'", ":", "7", ",", "u'name'", ":", "u'No known copyright restrictions'", "}", ",", "{", "u'url'", ":", "u'http://www.usa.gov/copyright.shtml'", ",", "u'id'", ":", "8", ",", "u'name'", ":", "u'United States Government Work'", "}", "]", ",", "u'type'", ":", "u'captions'", "}", "\n", "out", ".", "update", "(", "{", "'images'", ":", "[", "]", ",", "'annotations'", ":", "[", "]", "}", ")", "\n", "\n", "cnt", "=", "0", "\n", "empty_cnt", "=", "0", "\n", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "        ", "if", "img", "[", "'split'", "]", "==", "'train'", ":", "\n", "            ", "continue", "\n", "", "out", "[", "'images'", "]", ".", "append", "(", "\n", "{", "u'id'", ":", "img", ".", "get", "(", "'cocoid'", ",", "img", "[", "'imgid'", "]", ")", "}", ")", "\n", "for", "j", ",", "s", "in", "enumerate", "(", "img", "[", "'sentences'", "]", ")", ":", "\n", "            ", "if", "len", "(", "s", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "s", "=", "' '", ".", "join", "(", "s", "[", "'tokens'", "]", ")", "\n", "out", "[", "'annotations'", "]", ".", "append", "(", "\n", "{", "'image_id'", ":", "out", "[", "'images'", "]", "[", "-", "1", "]", "[", "'id'", "]", ",", "'caption'", ":", "s", ",", "'id'", ":", "cnt", "}", ")", "\n", "cnt", "+=", "1", "\n", "\n", "", "", "json", ".", "dump", "(", "out", ",", "open", "(", "params", "[", "'output_json'", "]", ",", "'w'", ")", ")", "\n", "print", "(", "'wrote '", ",", "params", "[", "'output_json'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.build_bpe_subword_nmt.build_vocab": [[49, 105], ["tempfile.NamedTemporaryFile", "tempfile.NamedTemporaryFile.close", "tempfile.NamedTemporaryFile", "tempfile.NamedTemporaryFile.close", "tempfile.NamedTemporaryFile", "tempfile.NamedTemporaryFile.close", "codecs.open", "enumerate", "codecs.open.close", "codecs.open", "subword_nmt.learn_bpe.get_vocabulary", "sorted", "print", "sorted.append", "print", "os.remove", "os.remove", "os.remove", "open", "txt_file.write", "codecs.open", "subword_nmt.learn_bpe.learn_bpe", "codecs.open", "subword_nmt.apply_bpe.BPE", "sorted.keys", "len", "open", "codes.read", "captions.append", "codecs.open", "codes.read.segment().strip", "img[].append", "codecs.open.write", "codecs.open.write", "bpe.segment().strip.split", "print", "codes.read.segment"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys"], ["def", "build_vocab", "(", "imgs", ",", "params", ")", ":", "\n", "# count up the number of words", "\n", "  ", "captions", "=", "[", "]", "\n", "for", "img", "in", "imgs", ":", "\n", "    ", "for", "sent", "in", "img", "[", "'sentences'", "]", ":", "\n", "      ", "captions", ".", "append", "(", "' '", ".", "join", "(", "sent", "[", "'tokens'", "]", ")", ")", "\n", "", "", "captions", "=", "'\\n'", ".", "join", "(", "captions", ")", "\n", "all_captions", "=", "tempfile", ".", "NamedTemporaryFile", "(", "delete", "=", "False", ")", "\n", "all_captions", ".", "close", "(", ")", "\n", "with", "open", "(", "all_captions", ".", "name", ",", "'w'", ")", "as", "txt_file", ":", "\n", "    ", "txt_file", ".", "write", "(", "captions", ")", "\n", "\n", "#", "\n", "", "codecs_output", "=", "tempfile", ".", "NamedTemporaryFile", "(", "delete", "=", "False", ")", "\n", "codecs_output", ".", "close", "(", ")", "\n", "with", "codecs", ".", "open", "(", "codecs_output", ".", "name", ",", "'w'", ",", "encoding", "=", "'UTF-8'", ")", "as", "output", ":", "\n", "    ", "learn_bpe", ".", "learn_bpe", "(", "codecs", ".", "open", "(", "all_captions", ".", "name", ",", "encoding", "=", "'UTF-8'", ")", ",", "output", ",", "params", "[", "'symbol_count'", "]", ")", "\n", "\n", "", "with", "codecs", ".", "open", "(", "codecs_output", ".", "name", ",", "encoding", "=", "'UTF-8'", ")", "as", "codes", ":", "\n", "    ", "bpe", "=", "apply_bpe", ".", "BPE", "(", "codes", ")", "\n", "\n", "", "tmp", "=", "tempfile", ".", "NamedTemporaryFile", "(", "delete", "=", "False", ")", "\n", "tmp", ".", "close", "(", ")", "\n", "\n", "tmpout", "=", "codecs", ".", "open", "(", "tmp", ".", "name", ",", "'w'", ",", "encoding", "=", "'UTF-8'", ")", "\n", "\n", "for", "_", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "    ", "img", "[", "'final_captions'", "]", "=", "[", "]", "\n", "for", "sent", "in", "img", "[", "'sentences'", "]", ":", "\n", "      ", "txt", "=", "' '", ".", "join", "(", "sent", "[", "'tokens'", "]", ")", "\n", "txt", "=", "bpe", ".", "segment", "(", "txt", ")", ".", "strip", "(", ")", "\n", "img", "[", "'final_captions'", "]", ".", "append", "(", "txt", ".", "split", "(", "' '", ")", ")", "\n", "tmpout", ".", "write", "(", "txt", ")", "\n", "tmpout", ".", "write", "(", "'\\n'", ")", "\n", "if", "_", "<", "20", ":", "\n", "        ", "print", "(", "txt", ")", "\n", "\n", "", "", "", "tmpout", ".", "close", "(", ")", "\n", "tmpin", "=", "codecs", ".", "open", "(", "tmp", ".", "name", ",", "encoding", "=", "'UTF-8'", ")", "\n", "\n", "vocab", "=", "learn_bpe", ".", "get_vocabulary", "(", "tmpin", ")", "\n", "vocab", "=", "sorted", "(", "vocab", ".", "keys", "(", ")", ",", "key", "=", "lambda", "x", ":", "vocab", "[", "x", "]", ",", "reverse", "=", "True", ")", "\n", "\n", "# Always insert UNK", "\n", "print", "(", "'inserting the special UNK token'", ")", "\n", "vocab", ".", "append", "(", "'UNK'", ")", "\n", "\n", "print", "(", "'Vocab size:'", ",", "len", "(", "vocab", ")", ")", "\n", "\n", "os", ".", "remove", "(", "all_captions", ".", "name", ")", "\n", "with", "open", "(", "codecs_output", ".", "name", ",", "'r'", ")", "as", "codes", ":", "\n", "    ", "bpe", "=", "codes", ".", "read", "(", ")", "\n", "", "os", ".", "remove", "(", "codecs_output", ".", "name", ")", "\n", "os", ".", "remove", "(", "tmp", ".", "name", ")", "\n", "\n", "return", "vocab", ",", "bpe", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.build_bpe_subword_nmt.encode_captions": [[106, 149], ["len", "sum", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "numpy.concatenate", "numpy.all", "print", "len", "numpy.zeros", "enumerate", "label_arrays.append", "len", "min", "enumerate", "len"], "function", ["None"], ["", "def", "encode_captions", "(", "imgs", ",", "params", ",", "wtoi", ")", ":", "\n", "  ", "\"\"\" \n  encode all captions into one large array, which will be 1-indexed.\n  also produces label_start_ix and label_end_ix which store 1-indexed \n  and inclusive (Lua-style) pointers to the first and last caption for\n  each image in the dataset.\n  \"\"\"", "\n", "\n", "max_length", "=", "params", "[", "'max_length'", "]", "\n", "N", "=", "len", "(", "imgs", ")", "\n", "M", "=", "sum", "(", "len", "(", "img", "[", "'final_captions'", "]", ")", "for", "img", "in", "imgs", ")", "# total number of captions", "\n", "\n", "label_arrays", "=", "[", "]", "\n", "label_start_ix", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "'uint32'", ")", "# note: these will be one-indexed", "\n", "label_end_ix", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "'uint32'", ")", "\n", "label_length", "=", "np", ".", "zeros", "(", "M", ",", "dtype", "=", "'uint32'", ")", "\n", "caption_counter", "=", "0", "\n", "counter", "=", "1", "\n", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "    ", "n", "=", "len", "(", "img", "[", "'final_captions'", "]", ")", "\n", "assert", "n", ">", "0", ",", "'error: some image has no captions'", "\n", "\n", "Li", "=", "np", ".", "zeros", "(", "(", "n", ",", "max_length", ")", ",", "dtype", "=", "'uint32'", ")", "\n", "for", "j", ",", "s", "in", "enumerate", "(", "img", "[", "'final_captions'", "]", ")", ":", "\n", "      ", "label_length", "[", "caption_counter", "]", "=", "min", "(", "max_length", ",", "len", "(", "s", ")", ")", "# record the length of this sequence", "\n", "caption_counter", "+=", "1", "\n", "for", "k", ",", "w", "in", "enumerate", "(", "s", ")", ":", "\n", "        ", "if", "k", "<", "max_length", ":", "\n", "          ", "Li", "[", "j", ",", "k", "]", "=", "wtoi", "[", "w", "]", "\n", "\n", "# note: word indices are 1-indexed, and captions are padded with zeros", "\n", "", "", "", "label_arrays", ".", "append", "(", "Li", ")", "\n", "label_start_ix", "[", "i", "]", "=", "counter", "\n", "label_end_ix", "[", "i", "]", "=", "counter", "+", "n", "-", "1", "\n", "\n", "counter", "+=", "n", "\n", "\n", "", "L", "=", "np", ".", "concatenate", "(", "label_arrays", ",", "axis", "=", "0", ")", "# put all the labels together", "\n", "assert", "L", ".", "shape", "[", "0", "]", "==", "M", ",", "'lengths don\\'t match? that\\'s weird'", "\n", "assert", "np", ".", "all", "(", "label_length", ">", "0", ")", ",", "'error: some caption had no words?'", "\n", "\n", "print", "(", "'encoded captions to array of size '", ",", "L", ".", "shape", ")", "\n", "return", "L", ",", "label_start_ix", ",", "label_end_ix", ",", "label_length", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.build_bpe_subword_nmt.main": [[150, 194], ["json.load", "random.seed", "build_bpe_subword_nmt.build_vocab", "build_bpe_subword_nmt.encode_captions", "len", "h5py.File", "h5py.File.create_dataset", "h5py.File.create_dataset", "h5py.File.create_dataset", "h5py.File.create_dataset", "h5py.File.close", "enumerate", "json.dump", "print", "open", "out[].append", "open", "enumerate", "enumerate", "os.path.join", "PIL.Image.open", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_labels.build_vocab", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_labels.encode_captions"], ["", "def", "main", "(", "params", ")", ":", "\n", "\n", "  ", "imgs", "=", "json", ".", "load", "(", "open", "(", "params", "[", "'input_json'", "]", ",", "'r'", ")", ")", "\n", "imgs", "=", "imgs", "[", "'images'", "]", "\n", "\n", "seed", "(", "123", ")", "# make reproducible", "\n", "\n", "# create the vocab", "\n", "vocab", ",", "bpe", "=", "build_vocab", "(", "imgs", ",", "params", ")", "\n", "itow", "=", "{", "i", "+", "1", ":", "w", "for", "i", ",", "w", "in", "enumerate", "(", "vocab", ")", "}", "# a 1-indexed vocab translation table", "\n", "wtoi", "=", "{", "w", ":", "i", "+", "1", "for", "i", ",", "w", "in", "enumerate", "(", "vocab", ")", "}", "# inverse table", "\n", "\n", "# encode captions in large arrays, ready to ship to hdf5 file", "\n", "L", ",", "label_start_ix", ",", "label_end_ix", ",", "label_length", "=", "encode_captions", "(", "imgs", ",", "params", ",", "wtoi", ")", "\n", "\n", "# create output h5 file", "\n", "N", "=", "len", "(", "imgs", ")", "\n", "f_lb", "=", "h5py", ".", "File", "(", "params", "[", "'output_h5'", "]", "+", "'_label.h5'", ",", "\"w\"", ")", "\n", "f_lb", ".", "create_dataset", "(", "\"labels\"", ",", "dtype", "=", "'uint32'", ",", "data", "=", "L", ")", "\n", "f_lb", ".", "create_dataset", "(", "\"label_start_ix\"", ",", "dtype", "=", "'uint32'", ",", "data", "=", "label_start_ix", ")", "\n", "f_lb", ".", "create_dataset", "(", "\"label_end_ix\"", ",", "dtype", "=", "'uint32'", ",", "data", "=", "label_end_ix", ")", "\n", "f_lb", ".", "create_dataset", "(", "\"label_length\"", ",", "dtype", "=", "'uint32'", ",", "data", "=", "label_length", ")", "\n", "f_lb", ".", "close", "(", ")", "\n", "\n", "# create output json file", "\n", "out", "=", "{", "}", "\n", "out", "[", "'ix_to_word'", "]", "=", "itow", "# encode the (1-indexed) vocab", "\n", "out", "[", "'images'", "]", "=", "[", "]", "\n", "out", "[", "'bpe'", "]", "=", "bpe", "\n", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "\n", "    ", "jimg", "=", "{", "}", "\n", "jimg", "[", "'split'", "]", "=", "img", "[", "'split'", "]", "\n", "if", "'filename'", "in", "img", ":", "jimg", "[", "'file_path'", "]", "=", "os", ".", "path", ".", "join", "(", "img", "[", "'filepath'", "]", ",", "img", "[", "'filename'", "]", ")", "# copy it over, might need", "\n", "if", "'cocoid'", "in", "img", ":", "jimg", "[", "'id'", "]", "=", "img", "[", "'cocoid'", "]", "# copy over & mantain an id, if present (e.g. coco ids, useful)", "\n", "\n", "if", "params", "[", "'images_root'", "]", "!=", "''", ":", "\n", "      ", "with", "Image", ".", "open", "(", "os", ".", "path", ".", "join", "(", "params", "[", "'images_root'", "]", ",", "img", "[", "'filepath'", "]", ",", "img", "[", "'filename'", "]", ")", ")", "as", "_img", ":", "\n", "        ", "jimg", "[", "'width'", "]", ",", "jimg", "[", "'height'", "]", "=", "_img", ".", "size", "\n", "\n", "", "", "out", "[", "'images'", "]", ".", "append", "(", "jimg", ")", "\n", "\n", "", "json", ".", "dump", "(", "out", ",", "open", "(", "params", "[", "'output_json'", "]", ",", "'w'", ")", ")", "\n", "print", "(", "'wrote '", ",", "params", "[", "'output_json'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_labels.build_vocab": [[43, 94], ["sorted", "print", "print", "sum", "print", "sum", "print", "print", "print", "max", "print", "print", "sum", "range", "counts.values", "sent_lengths.keys", "sent_lengths.values", "print", "print", "vocab.append", "map", "counts.items", "counts.items", "len", "img[].append", "counts.items", "len", "len", "len", "sent_lengths.get", "counts.get", "len", "sent_lengths.get", "len", "counts.get", "sent_lengths.get"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["def", "build_vocab", "(", "imgs", ",", "params", ")", ":", "\n", "  ", "count_thr", "=", "params", "[", "'word_count_threshold'", "]", "\n", "\n", "# count up the number of words", "\n", "counts", "=", "{", "}", "\n", "for", "img", "in", "imgs", ":", "\n", "    ", "for", "sent", "in", "img", "[", "'sentences'", "]", ":", "\n", "      ", "for", "w", "in", "sent", "[", "'tokens'", "]", ":", "\n", "        ", "counts", "[", "w", "]", "=", "counts", ".", "get", "(", "w", ",", "0", ")", "+", "1", "\n", "", "", "", "cw", "=", "sorted", "(", "[", "(", "count", ",", "w", ")", "for", "w", ",", "count", "in", "counts", ".", "items", "(", ")", "]", ",", "reverse", "=", "True", ")", "\n", "print", "(", "'top words and their counts:'", ")", "\n", "print", "(", "'\\n'", ".", "join", "(", "map", "(", "str", ",", "cw", "[", ":", "20", "]", ")", ")", ")", "\n", "\n", "# print some stats", "\n", "total_words", "=", "sum", "(", "counts", ".", "values", "(", ")", ")", "\n", "print", "(", "'total words:'", ",", "total_words", ")", "\n", "bad_words", "=", "[", "w", "for", "w", ",", "n", "in", "counts", ".", "items", "(", ")", "if", "n", "<=", "count_thr", "]", "\n", "vocab", "=", "[", "w", "for", "w", ",", "n", "in", "counts", ".", "items", "(", ")", "if", "n", ">", "count_thr", "]", "\n", "bad_count", "=", "sum", "(", "counts", "[", "w", "]", "for", "w", "in", "bad_words", ")", "\n", "print", "(", "'number of bad words: %d/%d = %.2f%%'", "%", "(", "len", "(", "bad_words", ")", ",", "len", "(", "counts", ")", ",", "len", "(", "bad_words", ")", "*", "100.0", "/", "len", "(", "counts", ")", ")", ")", "\n", "print", "(", "'number of words in vocab would be %d'", "%", "(", "len", "(", "vocab", ")", ",", ")", ")", "\n", "print", "(", "'number of UNKs: %d/%d = %.2f%%'", "%", "(", "bad_count", ",", "total_words", ",", "bad_count", "*", "100.0", "/", "total_words", ")", ")", "\n", "\n", "# lets look at the distribution of lengths as well", "\n", "sent_lengths", "=", "{", "}", "\n", "for", "img", "in", "imgs", ":", "\n", "    ", "for", "sent", "in", "img", "[", "'sentences'", "]", ":", "\n", "      ", "txt", "=", "sent", "[", "'tokens'", "]", "\n", "nw", "=", "len", "(", "txt", ")", "\n", "sent_lengths", "[", "nw", "]", "=", "sent_lengths", ".", "get", "(", "nw", ",", "0", ")", "+", "1", "\n", "", "", "max_len", "=", "max", "(", "sent_lengths", ".", "keys", "(", ")", ")", "\n", "print", "(", "'max length sentence in raw data: '", ",", "max_len", ")", "\n", "print", "(", "'sentence length distribution (count, number of words):'", ")", "\n", "sum_len", "=", "sum", "(", "sent_lengths", ".", "values", "(", ")", ")", "\n", "for", "i", "in", "range", "(", "max_len", "+", "1", ")", ":", "\n", "    ", "print", "(", "'%2d: %10d   %f%%'", "%", "(", "i", ",", "sent_lengths", ".", "get", "(", "i", ",", "0", ")", ",", "sent_lengths", ".", "get", "(", "i", ",", "0", ")", "*", "100.0", "/", "sum_len", ")", ")", "\n", "\n", "# lets now produce the final annotations", "\n", "", "if", "bad_count", ">", "0", ":", "\n", "# additional special UNK token we will use below to map infrequent words to", "\n", "    ", "print", "(", "'inserting the special UNK token'", ")", "\n", "vocab", ".", "append", "(", "'UNK'", ")", "\n", "\n", "", "for", "img", "in", "imgs", ":", "\n", "    ", "img", "[", "'final_captions'", "]", "=", "[", "]", "\n", "for", "sent", "in", "img", "[", "'sentences'", "]", ":", "\n", "      ", "txt", "=", "sent", "[", "'tokens'", "]", "\n", "caption", "=", "[", "w", "if", "counts", ".", "get", "(", "w", ",", "0", ")", ">", "count_thr", "else", "'UNK'", "for", "w", "in", "txt", "]", "\n", "img", "[", "'final_captions'", "]", ".", "append", "(", "caption", ")", "\n", "\n", "", "", "return", "vocab", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_labels.encode_captions": [[95, 138], ["len", "sum", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "numpy.concatenate", "numpy.all", "print", "len", "numpy.zeros", "enumerate", "label_arrays.append", "len", "min", "enumerate", "len"], "function", ["None"], ["", "def", "encode_captions", "(", "imgs", ",", "params", ",", "wtoi", ")", ":", "\n", "  ", "\"\"\" \n  encode all captions into one large array, which will be 1-indexed.\n  also produces label_start_ix and label_end_ix which store 1-indexed \n  and inclusive (Lua-style) pointers to the first and last caption for\n  each image in the dataset.\n  \"\"\"", "\n", "\n", "max_length", "=", "params", "[", "'max_length'", "]", "\n", "N", "=", "len", "(", "imgs", ")", "\n", "M", "=", "sum", "(", "len", "(", "img", "[", "'final_captions'", "]", ")", "for", "img", "in", "imgs", ")", "# total number of captions", "\n", "\n", "label_arrays", "=", "[", "]", "\n", "label_start_ix", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "'uint32'", ")", "# note: these will be one-indexed", "\n", "label_end_ix", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "'uint32'", ")", "\n", "label_length", "=", "np", ".", "zeros", "(", "M", ",", "dtype", "=", "'uint32'", ")", "\n", "caption_counter", "=", "0", "\n", "counter", "=", "1", "\n", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "    ", "n", "=", "len", "(", "img", "[", "'final_captions'", "]", ")", "\n", "assert", "n", ">", "0", ",", "'error: some image has no captions'", "\n", "\n", "Li", "=", "np", ".", "zeros", "(", "(", "n", ",", "max_length", ")", ",", "dtype", "=", "'uint32'", ")", "\n", "for", "j", ",", "s", "in", "enumerate", "(", "img", "[", "'final_captions'", "]", ")", ":", "\n", "      ", "label_length", "[", "caption_counter", "]", "=", "min", "(", "max_length", ",", "len", "(", "s", ")", ")", "# record the length of this sequence", "\n", "caption_counter", "+=", "1", "\n", "for", "k", ",", "w", "in", "enumerate", "(", "s", ")", ":", "\n", "        ", "if", "k", "<", "max_length", ":", "\n", "          ", "Li", "[", "j", ",", "k", "]", "=", "wtoi", "[", "w", "]", "\n", "\n", "# note: word indices are 1-indexed, and captions are padded with zeros", "\n", "", "", "", "label_arrays", ".", "append", "(", "Li", ")", "\n", "label_start_ix", "[", "i", "]", "=", "counter", "\n", "label_end_ix", "[", "i", "]", "=", "counter", "+", "n", "-", "1", "\n", "\n", "counter", "+=", "n", "\n", "\n", "", "L", "=", "np", ".", "concatenate", "(", "label_arrays", ",", "axis", "=", "0", ")", "# put all the labels together", "\n", "assert", "L", ".", "shape", "[", "0", "]", "==", "M", ",", "'lengths don\\'t match? that\\'s weird'", "\n", "assert", "np", ".", "all", "(", "label_length", ">", "0", ")", ",", "'error: some caption had no words?'", "\n", "\n", "print", "(", "'encoded captions to array of size '", ",", "L", ".", "shape", ")", "\n", "return", "L", ",", "label_start_ix", ",", "label_end_ix", ",", "label_length", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_labels.main": [[139, 185], ["json.load", "random.seed", "prepro_labels.build_vocab", "prepro_labels.encode_captions", "len", "h5py.File", "h5py.File.create_dataset", "h5py.File.create_dataset", "h5py.File.create_dataset", "h5py.File.create_dataset", "h5py.File.close", "enumerate", "json.dump", "print", "open", "out[].append", "open", "enumerate", "enumerate", "os.path.join", "img.get", "PIL.Image.open", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_labels.build_vocab", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_labels.encode_captions", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["", "def", "main", "(", "params", ")", ":", "\n", "\n", "  ", "imgs", "=", "json", ".", "load", "(", "open", "(", "params", "[", "'input_json'", "]", ",", "'r'", ")", ")", "\n", "imgs", "=", "imgs", "[", "'images'", "]", "\n", "\n", "seed", "(", "123", ")", "# make reproducible", "\n", "\n", "# create the vocab", "\n", "vocab", "=", "build_vocab", "(", "imgs", ",", "params", ")", "\n", "itow", "=", "{", "i", "+", "1", ":", "w", "for", "i", ",", "w", "in", "enumerate", "(", "vocab", ")", "}", "# a 1-indexed vocab translation table", "\n", "wtoi", "=", "{", "w", ":", "i", "+", "1", "for", "i", ",", "w", "in", "enumerate", "(", "vocab", ")", "}", "# inverse table", "\n", "\n", "# encode captions in large arrays, ready to ship to hdf5 file", "\n", "L", ",", "label_start_ix", ",", "label_end_ix", ",", "label_length", "=", "encode_captions", "(", "imgs", ",", "params", ",", "wtoi", ")", "\n", "\n", "# create output h5 file", "\n", "N", "=", "len", "(", "imgs", ")", "\n", "f_lb", "=", "h5py", ".", "File", "(", "params", "[", "'output_h5'", "]", "+", "'_label.h5'", ",", "\"w\"", ")", "\n", "f_lb", ".", "create_dataset", "(", "\"labels\"", ",", "dtype", "=", "'uint32'", ",", "data", "=", "L", ")", "\n", "f_lb", ".", "create_dataset", "(", "\"label_start_ix\"", ",", "dtype", "=", "'uint32'", ",", "data", "=", "label_start_ix", ")", "\n", "f_lb", ".", "create_dataset", "(", "\"label_end_ix\"", ",", "dtype", "=", "'uint32'", ",", "data", "=", "label_end_ix", ")", "\n", "f_lb", ".", "create_dataset", "(", "\"label_length\"", ",", "dtype", "=", "'uint32'", ",", "data", "=", "label_length", ")", "\n", "f_lb", ".", "close", "(", ")", "\n", "\n", "# create output json file", "\n", "out", "=", "{", "}", "\n", "out", "[", "'ix_to_word'", "]", "=", "itow", "# encode the (1-indexed) vocab", "\n", "out", "[", "'images'", "]", "=", "[", "]", "\n", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "\n", "    ", "jimg", "=", "{", "}", "\n", "jimg", "[", "'split'", "]", "=", "img", "[", "'split'", "]", "\n", "if", "'filename'", "in", "img", ":", "jimg", "[", "'file_path'", "]", "=", "os", ".", "path", ".", "join", "(", "img", ".", "get", "(", "'filepath'", ",", "''", ")", ",", "img", "[", "'filename'", "]", ")", "# copy it over, might need", "\n", "if", "'cocoid'", "in", "img", ":", "\n", "      ", "jimg", "[", "'id'", "]", "=", "img", "[", "'cocoid'", "]", "# copy over & mantain an id, if present (e.g. coco ids, useful)", "\n", "", "elif", "'imgid'", "in", "img", ":", "\n", "      ", "jimg", "[", "'id'", "]", "=", "img", "[", "'imgid'", "]", "\n", "\n", "", "if", "params", "[", "'images_root'", "]", "!=", "''", ":", "\n", "      ", "with", "Image", ".", "open", "(", "os", ".", "path", ".", "join", "(", "params", "[", "'images_root'", "]", ",", "img", "[", "'filepath'", "]", ",", "img", "[", "'filename'", "]", ")", ")", "as", "_img", ":", "\n", "        ", "jimg", "[", "'width'", "]", ",", "jimg", "[", "'height'", "]", "=", "_img", ".", "size", "\n", "\n", "", "", "out", "[", "'images'", "]", ".", "append", "(", "jimg", ")", "\n", "\n", "", "json", ".", "dump", "(", "out", ",", "open", "(", "params", "[", "'output_json'", "]", ",", "'w'", ")", ")", "\n", "print", "(", "'wrote '", ",", "params", "[", "'output_json'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.scripts.prepro_feats.main": [[52, 92], ["net.load_state_dict", "misc.resnet_utils.myResnet", "misc.resnet_utils.myResnet.cuda", "misc.resnet_utils.myResnet.eval", "json.load", "len", "random.seed", "enumerate", "print", "getattr", "torch.load", "open", "os.path.isdir", "os.mkdir", "os.path.isdir", "os.mkdir", "skimage.io.imread", "torch.from_numpy().cuda", "preprocess", "numpy.save", "numpy.savez_compressed", "os.path.join", "os.path.join", "len", "numpy.concatenate", "np.concatenate.astype", "torch.no_grad", "misc.resnet_utils.myResnet.", "os.path.join", "tmp_fc.data.cpu().float().numpy", "os.path.join", "print", "torch.from_numpy", "str", "str", "tmp_att.data.cpu().float().numpy", "np.concatenate.transpose", "tmp_fc.data.cpu().float", "tmp_att.data.cpu().float", "tmp_fc.data.cpu", "tmp_att.data.cpu"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["def", "main", "(", "params", ")", ":", "\n", "  ", "net", "=", "getattr", "(", "resnet", ",", "params", "[", "'model'", "]", ")", "(", ")", "\n", "net", ".", "load_state_dict", "(", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "params", "[", "'model_root'", "]", ",", "params", "[", "'model'", "]", "+", "'.pth'", ")", ")", ")", "\n", "my_resnet", "=", "myResnet", "(", "net", ")", "\n", "my_resnet", ".", "cuda", "(", ")", "\n", "my_resnet", ".", "eval", "(", ")", "\n", "\n", "imgs", "=", "json", ".", "load", "(", "open", "(", "params", "[", "'input_json'", "]", ",", "'r'", ")", ")", "\n", "imgs", "=", "imgs", "[", "'images'", "]", "\n", "N", "=", "len", "(", "imgs", ")", "\n", "\n", "seed", "(", "123", ")", "# make reproducible", "\n", "\n", "dir_fc", "=", "params", "[", "'output_dir'", "]", "+", "'_fc'", "\n", "dir_att", "=", "params", "[", "'output_dir'", "]", "+", "'_att'", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "dir_fc", ")", ":", "\n", "    ", "os", ".", "mkdir", "(", "dir_fc", ")", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "dir_att", ")", ":", "\n", "    ", "os", ".", "mkdir", "(", "dir_att", ")", "\n", "\n", "", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "# load the image", "\n", "    ", "I", "=", "skimage", ".", "io", ".", "imread", "(", "os", ".", "path", ".", "join", "(", "params", "[", "'images_root'", "]", ",", "img", "[", "'filepath'", "]", ",", "img", "[", "'filename'", "]", ")", ")", "\n", "# handle grayscale input images", "\n", "if", "len", "(", "I", ".", "shape", ")", "==", "2", ":", "\n", "      ", "I", "=", "I", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "I", "=", "np", ".", "concatenate", "(", "(", "I", ",", "I", ",", "I", ")", ",", "axis", "=", "2", ")", "\n", "\n", "", "I", "=", "I", ".", "astype", "(", "'float32'", ")", "/", "255.0", "\n", "I", "=", "torch", ".", "from_numpy", "(", "I", ".", "transpose", "(", "[", "2", ",", "0", ",", "1", "]", ")", ")", ".", "cuda", "(", ")", "\n", "I", "=", "preprocess", "(", "I", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "      ", "tmp_fc", ",", "tmp_att", "=", "my_resnet", "(", "I", ",", "params", "[", "'att_size'", "]", ")", "\n", "# write to pkl", "\n", "", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "dir_fc", ",", "str", "(", "img", "[", "'cocoid'", "]", ")", ")", ",", "tmp_fc", ".", "data", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", ")", "\n", "np", ".", "savez_compressed", "(", "os", ".", "path", ".", "join", "(", "dir_att", ",", "str", "(", "img", "[", "'cocoid'", "]", ")", ")", ",", "feat", "=", "tmp_att", ".", "data", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "if", "i", "%", "1000", "==", "0", ":", "\n", "      ", "print", "(", "'processing %d/%d (%.2f%% done)'", "%", "(", "i", ",", "N", ",", "i", "*", "100.0", "/", "N", ")", ")", "\n", "", "", "print", "(", "'wrote '", ",", "params", "[", "'output_dir'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel.__init__": [[52, 93], ["CaptionModel.CaptionModel.__init__", "getattr", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "getattr", "torch.Linear", "torch.Linear", "torch.Linear", "getattr", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "int", "AttModel.AttModel.vocab.items", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "range", "reduce", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "AttModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "vocab_size", "=", "opt", ".", "vocab_size", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "#self.rnn_type = opt.rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "num_layers", "=", "opt", ".", "num_layers", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "seq_length", "=", "getattr", "(", "opt", ",", "'max_length'", ",", "20", ")", "or", "opt", ".", "seq_length", "# maximum sample length", "\n", "self", ".", "fc_feat_size", "=", "opt", ".", "fc_feat_size", "\n", "self", ".", "att_feat_size", "=", "opt", ".", "att_feat_size", "\n", "self", ".", "att_hid_size", "=", "opt", ".", "att_hid_size", "\n", "\n", "self", ".", "use_bn", "=", "getattr", "(", "opt", ",", "'use_bn'", ",", "0", ")", "\n", "\n", "self", ".", "ss_prob", "=", "0.0", "# Schedule sampling probability", "\n", "\n", "self", ".", "embed", "=", "nn", ".", "Sequential", "(", "nn", ".", "Embedding", "(", "self", ".", "vocab_size", "+", "1", ",", "self", ".", "input_encoding_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", ")", "\n", "self", ".", "fc_embed", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "self", ".", "fc_feat_size", ",", "self", ".", "rnn_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", ")", "\n", "self", ".", "att_embed", "=", "nn", ".", "Sequential", "(", "*", "(", "\n", "(", "(", "nn", ".", "BatchNorm1d", "(", "self", ".", "att_feat_size", ")", ",", ")", "if", "self", ".", "use_bn", "else", "(", ")", ")", "+", "\n", "(", "nn", ".", "Linear", "(", "self", ".", "att_feat_size", ",", "self", ".", "rnn_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", ")", "+", "\n", "(", "(", "nn", ".", "BatchNorm1d", "(", "self", ".", "rnn_size", ")", ",", ")", "if", "self", ".", "use_bn", "==", "2", "else", "(", ")", ")", ")", ")", "\n", "\n", "self", ".", "logit_layers", "=", "getattr", "(", "opt", ",", "'logit_layers'", ",", "1", ")", "\n", "if", "self", ".", "logit_layers", "==", "1", ":", "\n", "            ", "self", ".", "logit", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "vocab_size", "+", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "logit", "=", "[", "[", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", ",", "nn", ".", "ReLU", "(", ")", ",", "nn", ".", "Dropout", "(", "0.5", ")", "]", "for", "_", "in", "range", "(", "opt", ".", "logit_layers", "-", "1", ")", "]", "\n", "self", ".", "logit", "=", "nn", ".", "Sequential", "(", "*", "(", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ",", "self", ".", "logit", ")", "+", "[", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "vocab_size", "+", "1", ")", "]", ")", ")", "\n", "", "self", ".", "ctx2att", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "att_hid_size", ")", "\n", "\n", "# For remove bad endding", "\n", "self", ".", "vocab", "=", "opt", ".", "vocab", "\n", "self", ".", "bad_endings_ix", "=", "[", "int", "(", "k", ")", "for", "k", ",", "v", "in", "self", ".", "vocab", ".", "items", "(", ")", "if", "v", "in", "bad_endings", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel.init_hidden": [[94, 98], ["next", "AttModel.AttModel.parameters", "next.new_zeros", "next.new_zeros"], "methods", ["None"], ["", "def", "init_hidden", "(", "self", ",", "bsz", ")", ":", "\n", "        ", "weight", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", "\n", "return", "(", "weight", ".", "new_zeros", "(", "self", ".", "num_layers", ",", "bsz", ",", "self", ".", "rnn_size", ")", ",", "\n", "weight", ".", "new_zeros", "(", "self", ".", "num_layers", ",", "bsz", ",", "self", ".", "rnn_size", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel.clip_att": [[99, 106], ["att_masks[].contiguous.data.long().sum().max", "att_feats[].contiguous", "att_masks[].contiguous", "att_masks[].contiguous.data.long().sum", "att_masks[].contiguous.data.long"], "methods", ["None"], ["", "def", "clip_att", "(", "self", ",", "att_feats", ",", "att_masks", ")", ":", "\n", "# Clip the length of att_masks and att_feats to the maximum length", "\n", "        ", "if", "att_masks", "is", "not", "None", ":", "\n", "            ", "max_len", "=", "att_masks", ".", "data", ".", "long", "(", ")", ".", "sum", "(", "1", ")", ".", "max", "(", ")", "\n", "att_feats", "=", "att_feats", "[", ":", ",", ":", "max_len", "]", ".", "contiguous", "(", ")", "\n", "att_masks", "=", "att_masks", "[", ":", ",", ":", "max_len", "]", ".", "contiguous", "(", ")", "\n", "", "return", "att_feats", ",", "att_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel._prepare_feature": [[107, 118], ["AttModel.AttModel.clip_att", "AttModel.AttModel.fc_embed", "AttModel.pack_wrapper", "AttModel.AttModel.ctx2att"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel.clip_att", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.pack_wrapper"], ["", "def", "_prepare_feature", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", ")", ":", "\n", "        ", "att_feats", ",", "att_masks", "=", "self", ".", "clip_att", "(", "att_feats", ",", "att_masks", ")", "\n", "\n", "# embed fc and att feats", "\n", "fc_feats", "=", "self", ".", "fc_embed", "(", "fc_feats", ")", "\n", "att_feats", "=", "pack_wrapper", "(", "self", ".", "att_embed", ",", "att_feats", ",", "att_masks", ")", "\n", "\n", "# Project the attention feats first to reduce memory and computation comsumptions.", "\n", "p_att_feats", "=", "self", ".", "ctx2att", "(", "att_feats", ")", "\n", "\n", "return", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel._forward": [[119, 153], ["fc_feats.size", "AttModel.AttModel.init_hidden", "fc_feats.new_zeros", "AttModel.AttModel._prepare_feature", "range", "AttModel.AttModel.get_logprobs_state", "seq.size", "seq.size", "fc_feats.new().uniform_", "seq[].clone", "sample_mask.sum", "seq[].clone", "sample_mask.nonzero().view", "seq[].data.clone", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "seq[].data.clone.index_copy_", "seq[].sum", "fc_feats.new", "outputs[].detach", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "sample_mask.nonzero", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoAModel._prepare_feature", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.get_logprobs_state"], ["", "def", "_forward", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "seq", ",", "att_masks", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "state", "=", "self", ".", "init_hidden", "(", "batch_size", ")", "\n", "\n", "outputs", "=", "fc_feats", ".", "new_zeros", "(", "batch_size", ",", "seq", ".", "size", "(", "1", ")", "-", "1", ",", "self", ".", "vocab_size", "+", "1", ")", "\n", "\n", "# Prepare the features", "\n", "p_fc_feats", ",", "p_att_feats", ",", "pp_att_feats", ",", "p_att_masks", "=", "self", ".", "_prepare_feature", "(", "fc_feats", ",", "att_feats", ",", "att_masks", ")", "\n", "# pp_att_feats is used for attention, we cache it in advance to reduce computation cost", "\n", "\n", "for", "i", "in", "range", "(", "seq", ".", "size", "(", "1", ")", "-", "1", ")", ":", "\n", "            ", "if", "self", ".", "training", "and", "i", ">=", "1", "and", "self", ".", "ss_prob", ">", "0.0", ":", "# otherwiste no need to sample", "\n", "                ", "sample_prob", "=", "fc_feats", ".", "new", "(", "batch_size", ")", ".", "uniform_", "(", "0", ",", "1", ")", "\n", "sample_mask", "=", "sample_prob", "<", "self", ".", "ss_prob", "\n", "if", "sample_mask", ".", "sum", "(", ")", "==", "0", ":", "\n", "                    ", "it", "=", "seq", "[", ":", ",", "i", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                    ", "sample_ind", "=", "sample_mask", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "it", "=", "seq", "[", ":", ",", "i", "]", ".", "data", ".", "clone", "(", ")", "\n", "#prob_prev = torch.exp(outputs[-1].data.index_select(0, sample_ind)) # fetch prev distribution: shape Nx(M+1)", "\n", "#it.index_copy_(0, sample_ind, torch.multinomial(prob_prev, 1).view(-1))", "\n", "# prob_prev = torch.exp(outputs[-1].data) # fetch prev distribution: shape Nx(M+1)", "\n", "prob_prev", "=", "torch", ".", "exp", "(", "outputs", "[", ":", ",", "i", "-", "1", "]", ".", "detach", "(", ")", ")", "# fetch prev distribution: shape Nx(M+1)", "\n", "it", ".", "index_copy_", "(", "0", ",", "sample_ind", ",", "torch", ".", "multinomial", "(", "prob_prev", ",", "1", ")", ".", "view", "(", "-", "1", ")", ".", "index_select", "(", "0", ",", "sample_ind", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "it", "=", "seq", "[", ":", ",", "i", "]", ".", "clone", "(", ")", "\n", "# break if all the sequences end", "\n", "", "if", "i", ">=", "1", "and", "seq", "[", ":", ",", "i", "]", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "break", "\n", "\n", "", "output", ",", "state", "=", "self", ".", "get_logprobs_state", "(", "it", ",", "p_fc_feats", ",", "p_att_feats", ",", "pp_att_feats", ",", "p_att_masks", ",", "state", ")", "\n", "outputs", "[", ":", ",", "i", "]", "=", "output", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel.get_logprobs_state": [[154, 162], ["AttModel.AttModel.embed", "AttModel.AttModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "AttModel.AttModel.logit"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "def", "get_logprobs_state", "(", "self", ",", "it", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ",", "state", ")", ":", "\n", "# 'it' contains a word index", "\n", "        ", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "output", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "logprobs", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel._sample_beam": [[163, 193], ["opt.get", "fc_feats.size", "AttModel.AttModel._prepare_feature", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "range", "AttModel.AttModel.init_hidden", "p_fc_feats[].expand", "p_att_feats[].expand().contiguous", "pp_att_feats[].expand().contiguous", "range", "AttModel.AttModel.beam_search", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "range", "p_fc_feats.size", "p_att_masks[].expand().contiguous", "AttModel.AttModel.get_logprobs_state", "p_att_feats[].expand", "pp_att_feats[].expand", "fc_feats.new_zeros", "p_att_masks[].expand", "p_att_feats.size", "pp_att_feats.size", "p_att_masks.size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoAModel._prepare_feature", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.beam_search", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.get_logprobs_state"], ["", "def", "_sample_beam", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", "=", "None", ",", "opt", "=", "{", "}", ")", ":", "\n", "        ", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "10", ")", "\n", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "\n", "p_fc_feats", ",", "p_att_feats", ",", "pp_att_feats", ",", "p_att_masks", "=", "self", ".", "_prepare_feature", "(", "fc_feats", ",", "att_feats", ",", "att_masks", ")", "\n", "\n", "assert", "beam_size", "<=", "self", ".", "vocab_size", "+", "1", ",", "'lets assume this for now, otherwise this corner case causes a few headaches down the road. can be dealt with in future if needed'", "\n", "seq", "=", "torch", ".", "LongTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", ".", "zero_", "(", ")", "\n", "seqLogprobs", "=", "torch", ".", "FloatTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", "\n", "# lets process every image independently for now, for simplicity", "\n", "\n", "self", ".", "done_beams", "=", "[", "[", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "state", "=", "self", ".", "init_hidden", "(", "beam_size", ")", "\n", "tmp_fc_feats", "=", "p_fc_feats", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "beam_size", ",", "p_fc_feats", ".", "size", "(", "1", ")", ")", "\n", "tmp_att_feats", "=", "p_att_feats", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "*", "(", "(", "beam_size", ",", ")", "+", "p_att_feats", ".", "size", "(", ")", "[", "1", ":", "]", ")", ")", ".", "contiguous", "(", ")", "\n", "tmp_p_att_feats", "=", "pp_att_feats", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "*", "(", "(", "beam_size", ",", ")", "+", "pp_att_feats", ".", "size", "(", ")", "[", "1", ":", "]", ")", ")", ".", "contiguous", "(", ")", "\n", "tmp_att_masks", "=", "p_att_masks", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "*", "(", "(", "beam_size", ",", ")", "+", "p_att_masks", ".", "size", "(", ")", "[", "1", ":", "]", ")", ")", ".", "contiguous", "(", ")", "if", "att_masks", "is", "not", "None", "else", "None", "\n", "\n", "for", "t", "in", "range", "(", "1", ")", ":", "\n", "                ", "if", "t", "==", "0", ":", "# input <bos>", "\n", "                    ", "it", "=", "fc_feats", ".", "new_zeros", "(", "[", "beam_size", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "", "logprobs", ",", "state", "=", "self", ".", "get_logprobs_state", "(", "it", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "tmp_p_att_feats", ",", "tmp_att_masks", ",", "state", ")", "\n", "\n", "", "self", ".", "done_beams", "[", "k", "]", "=", "self", ".", "beam_search", "(", "state", ",", "logprobs", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "tmp_p_att_feats", ",", "tmp_att_masks", ",", "opt", "=", "opt", ")", "\n", "seq", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'seq'", "]", "# the first beam has highest cumulative score", "\n", "seqLogprobs", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'logps'", "]", "\n", "# return the samples and their log likelihoods", "\n", "", "return", "seq", ".", "transpose", "(", "0", ",", "1", ")", ",", "seqLogprobs", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel._sample": [[194, 277], ["opt.get", "opt.get", "opt.get", "opt.get", "opt.get", "opt.get", "fc_feats.size", "AttModel.AttModel.init_hidden", "AttModel.AttModel._prepare_feature", "fc_feats.new_zeros", "fc_feats.new_zeros", "range", "AttModel.AttModel._sample_beam", "AttModel.AttModel.get_logprobs_state", "AttModel.AttModel.sample_next_word", "sampleLogprobs.view", "fc_feats.new_zeros", "logprobs.new_zeros", "logprobs.new_zeros.scatter_", "logprobs.new_zeros", "numpy.isin", "float", "range", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "range", "unfinished.type_as", "unfinished.sum", "logprobs.size", "seq[].data.unsqueeze", "float", "logprobs.size", "seq[].data.cpu().numpy", "[].item", "[].item", "trigrams.append", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "[].item", "[].item", "seq[].data.cpu", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "logprobs.size", "numpy.isin.astype", "[].append"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoAModel._prepare_feature", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel._sample_beam", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.get_logprobs_state", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.sample_next_word"], ["", "def", "_sample", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", "=", "None", ",", "opt", "=", "{", "}", ")", ":", "\n", "\n", "        ", "sample_method", "=", "opt", ".", "get", "(", "'sample_method'", ",", "'greedy'", ")", "\n", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "1", ")", "\n", "temperature", "=", "opt", ".", "get", "(", "'temperature'", ",", "1.0", ")", "\n", "decoding_constraint", "=", "opt", ".", "get", "(", "'decoding_constraint'", ",", "0", ")", "\n", "block_trigrams", "=", "opt", ".", "get", "(", "'block_trigrams'", ",", "0", ")", "\n", "remove_bad_endings", "=", "opt", ".", "get", "(", "'remove_bad_endings'", ",", "0", ")", "\n", "if", "beam_size", ">", "1", ":", "\n", "            ", "return", "self", ".", "_sample_beam", "(", "fc_feats", ",", "att_feats", ",", "att_masks", ",", "opt", ")", "\n", "\n", "", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "state", "=", "self", ".", "init_hidden", "(", "batch_size", ")", "\n", "\n", "p_fc_feats", ",", "p_att_feats", ",", "pp_att_feats", ",", "p_att_masks", "=", "self", ".", "_prepare_feature", "(", "fc_feats", ",", "att_feats", ",", "att_masks", ")", "\n", "\n", "trigrams", "=", "[", "]", "# will be a list of batch_size dictionaries", "\n", "\n", "seq", "=", "fc_feats", ".", "new_zeros", "(", "(", "batch_size", ",", "self", ".", "seq_length", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "seqLogprobs", "=", "fc_feats", ".", "new_zeros", "(", "batch_size", ",", "self", ".", "seq_length", ")", "\n", "for", "t", "in", "range", "(", "self", ".", "seq_length", "+", "1", ")", ":", "\n", "            ", "if", "t", "==", "0", ":", "# input <bos>", "\n", "                ", "it", "=", "fc_feats", ".", "new_zeros", "(", "batch_size", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "", "logprobs", ",", "state", "=", "self", ".", "get_logprobs_state", "(", "it", ",", "p_fc_feats", ",", "p_att_feats", ",", "pp_att_feats", ",", "p_att_masks", ",", "state", ")", "\n", "\n", "if", "decoding_constraint", "and", "t", ">", "0", ":", "\n", "                ", "tmp", "=", "logprobs", ".", "new_zeros", "(", "logprobs", ".", "size", "(", ")", ")", "\n", "tmp", ".", "scatter_", "(", "1", ",", "seq", "[", ":", ",", "t", "-", "1", "]", ".", "data", ".", "unsqueeze", "(", "1", ")", ",", "float", "(", "'-inf'", ")", ")", "\n", "logprobs", "=", "logprobs", "+", "tmp", "\n", "\n", "", "if", "remove_bad_endings", "and", "t", ">", "0", ":", "\n", "                ", "tmp", "=", "logprobs", ".", "new_zeros", "(", "logprobs", ".", "size", "(", ")", ")", "\n", "prev_bad", "=", "np", ".", "isin", "(", "seq", "[", ":", ",", "t", "-", "1", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "self", ".", "bad_endings_ix", ")", "\n", "# Impossible to generate remove_bad_endings", "\n", "tmp", "[", "torch", ".", "from_numpy", "(", "prev_bad", ".", "astype", "(", "'uint8'", ")", ")", ",", "0", "]", "=", "float", "(", "'-inf'", ")", "\n", "logprobs", "=", "logprobs", "+", "tmp", "\n", "\n", "# Mess with trigrams", "\n", "", "if", "block_trigrams", "and", "t", ">=", "3", ":", "\n", "# Store trigram generated at last step", "\n", "                ", "prev_two_batch", "=", "seq", "[", ":", ",", "t", "-", "3", ":", "t", "-", "1", "]", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "# = seq.size(0)", "\n", "                    ", "prev_two", "=", "(", "prev_two_batch", "[", "i", "]", "[", "0", "]", ".", "item", "(", ")", ",", "prev_two_batch", "[", "i", "]", "[", "1", "]", ".", "item", "(", ")", ")", "\n", "current", "=", "seq", "[", "i", "]", "[", "t", "-", "1", "]", "\n", "if", "t", "==", "3", ":", "# initialize", "\n", "                        ", "trigrams", ".", "append", "(", "{", "prev_two", ":", "[", "current", "]", "}", ")", "# {LongTensor: list containing 1 int}", "\n", "", "elif", "t", ">", "3", ":", "\n", "                        ", "if", "prev_two", "in", "trigrams", "[", "i", "]", ":", "# add to list", "\n", "                            ", "trigrams", "[", "i", "]", "[", "prev_two", "]", ".", "append", "(", "current", ")", "\n", "", "else", ":", "# create list", "\n", "                            ", "trigrams", "[", "i", "]", "[", "prev_two", "]", "=", "[", "current", "]", "\n", "# Block used trigrams at next step", "\n", "", "", "", "prev_two_batch", "=", "seq", "[", ":", ",", "t", "-", "2", ":", "t", "]", "\n", "mask", "=", "torch", ".", "zeros", "(", "logprobs", ".", "size", "(", ")", ",", "requires_grad", "=", "False", ")", ".", "cuda", "(", ")", "# batch_size x vocab_size", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "prev_two", "=", "(", "prev_two_batch", "[", "i", "]", "[", "0", "]", ".", "item", "(", ")", ",", "prev_two_batch", "[", "i", "]", "[", "1", "]", ".", "item", "(", ")", ")", "\n", "if", "prev_two", "in", "trigrams", "[", "i", "]", ":", "\n", "                        ", "for", "j", "in", "trigrams", "[", "i", "]", "[", "prev_two", "]", ":", "\n", "                            ", "mask", "[", "i", ",", "j", "]", "+=", "1", "\n", "# Apply mask to log probs", "\n", "#logprobs = logprobs - (mask * 1e9)", "\n", "", "", "", "alpha", "=", "2.0", "# = 4", "\n", "logprobs", "=", "logprobs", "+", "(", "mask", "*", "-", "0.693", "*", "alpha", ")", "# ln(1/2) * alpha (alpha -> infty works best)", "\n", "\n", "# sample the next word", "\n", "", "if", "t", "==", "self", ".", "seq_length", ":", "# skip if we achieve maximum length", "\n", "                ", "break", "\n", "", "it", ",", "sampleLogprobs", "=", "self", ".", "sample_next_word", "(", "logprobs", ",", "sample_method", ",", "temperature", ")", "\n", "\n", "# stop when all finished", "\n", "if", "t", "==", "0", ":", "\n", "                ", "unfinished", "=", "it", ">", "0", "\n", "", "else", ":", "\n", "                ", "unfinished", "=", "unfinished", "*", "(", "it", ">", "0", ")", "\n", "", "it", "=", "it", "*", "unfinished", ".", "type_as", "(", "it", ")", "\n", "seq", "[", ":", ",", "t", "]", "=", "it", "\n", "seqLogprobs", "[", ":", ",", "t", "]", "=", "sampleLogprobs", ".", "view", "(", "-", "1", ")", "\n", "# quit loop if all sequences have finished", "\n", "if", "unfinished", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "break", "\n", "\n", "", "", "return", "seq", ",", "seqLogprobs", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AdaAtt_lstm.__init__": [[279, 306], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "range", "range"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "use_maxout", "=", "True", ")", ":", "\n", "        ", "super", "(", "AdaAtt_lstm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "#self.rnn_type = opt.rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "num_layers", "=", "opt", ".", "num_layers", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "fc_feat_size", "=", "opt", ".", "fc_feat_size", "\n", "self", ".", "att_feat_size", "=", "opt", ".", "att_feat_size", "\n", "self", ".", "att_hid_size", "=", "opt", ".", "att_hid_size", "\n", "\n", "self", ".", "use_maxout", "=", "use_maxout", "\n", "\n", "# Build a LSTM", "\n", "self", ".", "w2h", "=", "nn", ".", "Linear", "(", "self", ".", "input_encoding_size", ",", "(", "4", "+", "(", "use_maxout", "==", "True", ")", ")", "*", "self", ".", "rnn_size", ")", "\n", "self", ".", "v2h", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "(", "4", "+", "(", "use_maxout", "==", "True", ")", ")", "*", "self", ".", "rnn_size", ")", "\n", "\n", "self", ".", "i2h", "=", "nn", ".", "ModuleList", "(", "[", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "(", "4", "+", "(", "use_maxout", "==", "True", ")", ")", "*", "self", ".", "rnn_size", ")", "for", "_", "in", "range", "(", "self", ".", "num_layers", "-", "1", ")", "]", ")", "\n", "self", ".", "h2h", "=", "nn", ".", "ModuleList", "(", "[", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "(", "4", "+", "(", "use_maxout", "==", "True", ")", ")", "*", "self", ".", "rnn_size", ")", "for", "_", "in", "range", "(", "self", ".", "num_layers", ")", "]", ")", "\n", "\n", "# Layers for getting the fake region", "\n", "if", "self", ".", "num_layers", "==", "1", ":", "\n", "            ", "self", ".", "r_w2h", "=", "nn", ".", "Linear", "(", "self", ".", "input_encoding_size", ",", "self", ".", "rnn_size", ")", "\n", "self", ".", "r_v2h", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "r_i2h", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", "\n", "", "self", ".", "r_h2h", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AdaAtt_lstm.forward": [[308, 365], ["range", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "all_input_sums.narrow", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "cs.append", "hs.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.dropout", "torch.dropout", "torch.dropout", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "all_input_sums.narrow", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "AttModel.AdaAtt_lstm.w2h", "AttModel.AdaAtt_lstm.v2h", "all_input_sums.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "AttModel.AdaAtt_lstm.r_i2h", "AttModel.AdaAtt_lstm.r_h2h", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "_.unsqueeze", "_.unsqueeze", "AttModel.AdaAtt_lstm.r_w2h", "AttModel.AdaAtt_lstm.r_v2h"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "xt", ",", "img_fc", ",", "state", ")", ":", "\n", "\n", "        ", "hs", "=", "[", "]", "\n", "cs", "=", "[", "]", "\n", "for", "L", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "# c,h from previous timesteps", "\n", "            ", "prev_h", "=", "state", "[", "0", "]", "[", "L", "]", "\n", "prev_c", "=", "state", "[", "1", "]", "[", "L", "]", "\n", "# the input to this layer", "\n", "if", "L", "==", "0", ":", "\n", "                ", "x", "=", "xt", "\n", "i2h", "=", "self", ".", "w2h", "(", "x", ")", "+", "self", ".", "v2h", "(", "img_fc", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "hs", "[", "-", "1", "]", "\n", "x", "=", "F", ".", "dropout", "(", "x", ",", "self", ".", "drop_prob_lm", ",", "self", ".", "training", ")", "\n", "i2h", "=", "self", ".", "i2h", "[", "L", "-", "1", "]", "(", "x", ")", "\n", "\n", "", "all_input_sums", "=", "i2h", "+", "self", ".", "h2h", "[", "L", "]", "(", "prev_h", ")", "\n", "\n", "sigmoid_chunk", "=", "all_input_sums", ".", "narrow", "(", "1", ",", "0", ",", "3", "*", "self", ".", "rnn_size", ")", "\n", "sigmoid_chunk", "=", "torch", ".", "sigmoid", "(", "sigmoid_chunk", ")", "\n", "# decode the gates", "\n", "in_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "0", ",", "self", ".", "rnn_size", ")", "\n", "forget_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", "\n", "out_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", "*", "2", ",", "self", ".", "rnn_size", ")", "\n", "# decode the write inputs", "\n", "if", "not", "self", ".", "use_maxout", ":", "\n", "                ", "in_transform", "=", "torch", ".", "tanh", "(", "all_input_sums", ".", "narrow", "(", "1", ",", "3", "*", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", ")", "\n", "", "else", ":", "\n", "                ", "in_transform", "=", "all_input_sums", ".", "narrow", "(", "1", ",", "3", "*", "self", ".", "rnn_size", ",", "2", "*", "self", ".", "rnn_size", ")", "\n", "in_transform", "=", "torch", ".", "max", "(", "in_transform", ".", "narrow", "(", "1", ",", "0", ",", "self", ".", "rnn_size", ")", ",", "\n", "in_transform", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", ")", "\n", "# perform the LSTM update", "\n", "", "next_c", "=", "forget_gate", "*", "prev_c", "+", "in_gate", "*", "in_transform", "\n", "# gated cells form the output", "\n", "tanh_nex_c", "=", "torch", ".", "tanh", "(", "next_c", ")", "\n", "next_h", "=", "out_gate", "*", "tanh_nex_c", "\n", "if", "L", "==", "self", ".", "num_layers", "-", "1", ":", "\n", "                ", "if", "L", "==", "0", ":", "\n", "                    ", "i2h", "=", "self", ".", "r_w2h", "(", "x", ")", "+", "self", ".", "r_v2h", "(", "img_fc", ")", "\n", "", "else", ":", "\n", "                    ", "i2h", "=", "self", ".", "r_i2h", "(", "x", ")", "\n", "", "n5", "=", "i2h", "+", "self", ".", "r_h2h", "(", "prev_h", ")", "\n", "fake_region", "=", "torch", ".", "sigmoid", "(", "n5", ")", "*", "tanh_nex_c", "\n", "\n", "", "cs", ".", "append", "(", "next_c", ")", "\n", "hs", ".", "append", "(", "next_h", ")", "\n", "\n", "# set up the decoder", "\n", "", "top_h", "=", "hs", "[", "-", "1", "]", "\n", "top_h", "=", "F", ".", "dropout", "(", "top_h", ",", "self", ".", "drop_prob_lm", ",", "self", ".", "training", ")", "\n", "fake_region", "=", "F", ".", "dropout", "(", "fake_region", ",", "self", ".", "drop_prob_lm", ",", "self", ".", "training", ")", "\n", "\n", "state", "=", "(", "torch", ".", "cat", "(", "[", "_", ".", "unsqueeze", "(", "0", ")", "for", "_", "in", "hs", "]", ",", "0", ")", ",", "\n", "torch", ".", "cat", "(", "[", "_", ".", "unsqueeze", "(", "0", ")", "for", "_", "in", "cs", "]", ",", "0", ")", ")", "\n", "return", "top_h", ",", "fake_region", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AdaAtt_attention.__init__": [[367, 391], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "AdaAtt_attention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "#self.rnn_type = opt.rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "att_hid_size", "=", "opt", ".", "att_hid_size", "\n", "\n", "# fake region embed", "\n", "self", ".", "fr_linear", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "input_encoding_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", ")", "\n", "self", ".", "fr_embed", "=", "nn", ".", "Linear", "(", "self", ".", "input_encoding_size", ",", "self", ".", "att_hid_size", ")", "\n", "\n", "# h out embed", "\n", "self", ".", "ho_linear", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "input_encoding_size", ")", ",", "\n", "nn", ".", "Tanh", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", ")", "\n", "self", ".", "ho_embed", "=", "nn", ".", "Linear", "(", "self", ".", "input_encoding_size", ",", "self", ".", "att_hid_size", ")", "\n", "\n", "self", ".", "alpha_net", "=", "nn", ".", "Linear", "(", "self", ".", "att_hid_size", ",", "1", ")", "\n", "self", ".", "att2h", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AdaAtt_attention.forward": [[392, 430], ["conv_feat.view.view.view", "conv_feat_embed.view.view.view", "AttModel.AdaAtt_attention.fr_linear", "AttModel.AdaAtt_attention.fr_embed", "AttModel.AdaAtt_attention.ho_linear", "AttModel.AdaAtt_attention.ho_embed", "AttModel.AdaAtt_attention.unsqueeze().expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.dropout", "torch.dropout", "torch.dropout", "AttModel.AdaAtt_attention.alpha_net", "torch.softmax", "torch.softmax", "torch.softmax", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm.squeeze", "torch.bmm.squeeze", "torch.bmm.squeeze", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.dropout", "torch.dropout", "torch.dropout", "AttModel.AdaAtt_attention.size", "AttModel.AdaAtt_attention.size", "torch.dropout.view", "AttModel.AdaAtt_attention.view", "att_masks.view.view.view", "torch.softmax.unsqueeze", "AttModel.AdaAtt_attention.att2h", "conv_feat.view.view.numel", "conv_feat.view.view.size", "AttModel.AdaAtt_attention.unsqueeze", "AttModel.AdaAtt_attention.view", "AttModel.AdaAtt_attention.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax.sum"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "h_out", ",", "fake_region", ",", "conv_feat", ",", "conv_feat_embed", ",", "att_masks", "=", "None", ")", ":", "\n", "\n", "# View into three dimensions", "\n", "        ", "att_size", "=", "conv_feat", ".", "numel", "(", ")", "//", "conv_feat", ".", "size", "(", "0", ")", "//", "self", ".", "rnn_size", "\n", "conv_feat", "=", "conv_feat", ".", "view", "(", "-", "1", ",", "att_size", ",", "self", ".", "rnn_size", ")", "\n", "conv_feat_embed", "=", "conv_feat_embed", ".", "view", "(", "-", "1", ",", "att_size", ",", "self", ".", "att_hid_size", ")", "\n", "\n", "# view neighbor from bach_size * neighbor_num x rnn_size to bach_size x rnn_size * neighbor_num", "\n", "fake_region", "=", "self", ".", "fr_linear", "(", "fake_region", ")", "\n", "fake_region_embed", "=", "self", ".", "fr_embed", "(", "fake_region", ")", "\n", "\n", "h_out_linear", "=", "self", ".", "ho_linear", "(", "h_out", ")", "\n", "h_out_embed", "=", "self", ".", "ho_embed", "(", "h_out_linear", ")", "\n", "\n", "txt_replicate", "=", "h_out_embed", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "h_out_embed", ".", "size", "(", "0", ")", ",", "att_size", "+", "1", ",", "h_out_embed", ".", "size", "(", "1", ")", ")", "\n", "\n", "img_all", "=", "torch", ".", "cat", "(", "[", "fake_region", ".", "view", "(", "-", "1", ",", "1", ",", "self", ".", "input_encoding_size", ")", ",", "conv_feat", "]", ",", "1", ")", "\n", "img_all_embed", "=", "torch", ".", "cat", "(", "[", "fake_region_embed", ".", "view", "(", "-", "1", ",", "1", ",", "self", ".", "input_encoding_size", ")", ",", "conv_feat_embed", "]", ",", "1", ")", "\n", "\n", "hA", "=", "torch", ".", "tanh", "(", "img_all_embed", "+", "txt_replicate", ")", "\n", "hA", "=", "F", ".", "dropout", "(", "hA", ",", "self", ".", "drop_prob_lm", ",", "self", ".", "training", ")", "\n", "\n", "hAflat", "=", "self", ".", "alpha_net", "(", "hA", ".", "view", "(", "-", "1", ",", "self", ".", "att_hid_size", ")", ")", "\n", "PI", "=", "F", ".", "softmax", "(", "hAflat", ".", "view", "(", "-", "1", ",", "att_size", "+", "1", ")", ",", "dim", "=", "1", ")", "\n", "\n", "if", "att_masks", "is", "not", "None", ":", "\n", "            ", "att_masks", "=", "att_masks", ".", "view", "(", "-", "1", ",", "att_size", ")", "\n", "PI", "=", "PI", "*", "torch", ".", "cat", "(", "[", "att_masks", "[", ":", ",", ":", "1", "]", ",", "att_masks", "]", ",", "1", ")", "# assume one one at the first time step.", "\n", "PI", "=", "PI", "/", "PI", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "", "visAtt", "=", "torch", ".", "bmm", "(", "PI", ".", "unsqueeze", "(", "1", ")", ",", "img_all", ")", "\n", "visAttdim", "=", "visAtt", ".", "squeeze", "(", "1", ")", "\n", "\n", "atten_out", "=", "visAttdim", "+", "h_out_linear", "\n", "\n", "h", "=", "torch", ".", "tanh", "(", "self", ".", "att2h", "(", "atten_out", ")", ")", "\n", "h", "=", "F", ".", "dropout", "(", "h", ",", "self", ".", "drop_prob_lm", ",", "self", ".", "training", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AdaAttCore.__init__": [[432, 436], ["torch.Module.__init__", "AttModel.AdaAtt_lstm", "AttModel.AdaAtt_attention"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "use_maxout", "=", "False", ")", ":", "\n", "        ", "super", "(", "AdaAttCore", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lstm", "=", "AdaAtt_lstm", "(", "opt", ",", "use_maxout", ")", "\n", "self", ".", "attention", "=", "AdaAtt_attention", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AdaAttCore.forward": [[437, 441], ["AttModel.AdaAttCore.lstm", "AttModel.AdaAttCore.attention"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.attention"], ["", "def", "forward", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", "=", "None", ")", ":", "\n", "        ", "h_out", ",", "p_out", ",", "state", "=", "self", ".", "lstm", "(", "xt", ",", "fc_feats", ",", "state", ")", "\n", "atten_out", "=", "self", ".", "attention", "(", "h_out", ",", "p_out", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ")", "\n", "return", "atten_out", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.TopDownCore.__init__": [[443, 450], ["torch.Module.__init__", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "AttModel.Attention"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "use_maxout", "=", "False", ")", ":", "\n", "        ", "super", "(", "TopDownCore", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "\n", "self", ".", "att_lstm", "=", "nn", ".", "LSTMCell", "(", "opt", ".", "input_encoding_size", "+", "opt", ".", "rnn_size", "*", "2", ",", "opt", ".", "rnn_size", ")", "# we, fc, h^2_t-1", "\n", "self", ".", "lang_lstm", "=", "nn", ".", "LSTMCell", "(", "opt", ".", "rnn_size", "*", "2", ",", "opt", ".", "rnn_size", ")", "# h^1_t, \\hat v", "\n", "self", ".", "attention", "=", "Attention", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.TopDownCore.forward": [[451, 468], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "AttModel.TopDownCore.att_lstm", "AttModel.TopDownCore.attention", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "AttModel.TopDownCore.lang_lstm", "torch.dropout", "torch.dropout", "torch.dropout", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.attention", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", "=", "None", ")", ":", "\n", "        ", "prev_h", "=", "state", "[", "0", "]", "[", "-", "1", "]", "\n", "att_lstm_input", "=", "torch", ".", "cat", "(", "[", "prev_h", ",", "fc_feats", ",", "xt", "]", ",", "1", ")", "\n", "\n", "h_att", ",", "c_att", "=", "self", ".", "att_lstm", "(", "att_lstm_input", ",", "(", "state", "[", "0", "]", "[", "0", "]", ",", "state", "[", "1", "]", "[", "0", "]", ")", ")", "\n", "\n", "att", "=", "self", ".", "attention", "(", "h_att", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ")", "\n", "\n", "lang_lstm_input", "=", "torch", ".", "cat", "(", "[", "att", ",", "h_att", "]", ",", "1", ")", "\n", "# lang_lstm_input = torch.cat([att, F.dropout(h_att, self.drop_prob_lm, self.training)], 1) ?????", "\n", "\n", "h_lang", ",", "c_lang", "=", "self", ".", "lang_lstm", "(", "lang_lstm_input", ",", "(", "state", "[", "0", "]", "[", "1", "]", ",", "state", "[", "1", "]", "[", "1", "]", ")", ")", "\n", "\n", "output", "=", "F", ".", "dropout", "(", "h_lang", ",", "self", ".", "drop_prob_lm", ",", "self", ".", "training", ")", "\n", "state", "=", "(", "torch", ".", "stack", "(", "[", "h_att", ",", "h_lang", "]", ")", ",", "torch", ".", "stack", "(", "[", "c_att", ",", "c_lang", "]", ")", ")", "\n", "\n", "return", "output", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.StackAttCore.__init__": [[478, 496], ["torch.Module.__init__", "AttModel.Attention", "AttModel.Attention", "FCModel.LSTMCore", "FCModel.LSTMCore", "FCModel.LSTMCore", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "use_maxout", "=", "False", ")", ":", "\n", "        ", "super", "(", "StackAttCore", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "\n", "# self.att0 = Attention(opt)", "\n", "self", ".", "att1", "=", "Attention", "(", "opt", ")", "\n", "self", ".", "att2", "=", "Attention", "(", "opt", ")", "\n", "\n", "opt_input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "opt", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "+", "opt", ".", "rnn_size", "\n", "self", ".", "lstm0", "=", "LSTMCore", "(", "opt", ")", "# att_feat + word_embedding", "\n", "opt", ".", "input_encoding_size", "=", "opt", ".", "rnn_size", "*", "2", "\n", "self", ".", "lstm1", "=", "LSTMCore", "(", "opt", ")", "\n", "self", ".", "lstm2", "=", "LSTMCore", "(", "opt", ")", "\n", "opt", ".", "input_encoding_size", "=", "opt_input_encoding_size", "\n", "\n", "# self.emb1 = nn.Linear(opt.rnn_size, opt.rnn_size)", "\n", "self", ".", "emb2", "=", "nn", ".", "Linear", "(", "opt", ".", "rnn_size", ",", "opt", ".", "rnn_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.StackAttCore.forward": [[497, 506], ["AttModel.StackAttCore.lstm0", "AttModel.StackAttCore.att1", "AttModel.StackAttCore.lstm1", "AttModel.StackAttCore.att2", "AttModel.StackAttCore.lstm2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "AttModel.StackAttCore.emb2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "zip"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", "=", "None", ")", ":", "\n", "# att_res_0 = self.att0(state[0][-1], att_feats, p_att_feats, att_masks)", "\n", "        ", "h_0", ",", "state_0", "=", "self", ".", "lstm0", "(", "torch", ".", "cat", "(", "[", "xt", ",", "fc_feats", "]", ",", "1", ")", ",", "[", "state", "[", "0", "]", "[", "0", ":", "1", "]", ",", "state", "[", "1", "]", "[", "0", ":", "1", "]", "]", ")", "\n", "att_res_1", "=", "self", ".", "att1", "(", "h_0", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ")", "\n", "h_1", ",", "state_1", "=", "self", ".", "lstm1", "(", "torch", ".", "cat", "(", "[", "h_0", ",", "att_res_1", "]", ",", "1", ")", ",", "[", "state", "[", "0", "]", "[", "1", ":", "2", "]", ",", "state", "[", "1", "]", "[", "1", ":", "2", "]", "]", ")", "\n", "att_res_2", "=", "self", ".", "att2", "(", "h_1", "+", "self", ".", "emb2", "(", "att_res_1", ")", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ")", "\n", "h_2", ",", "state_2", "=", "self", ".", "lstm2", "(", "torch", ".", "cat", "(", "[", "h_1", ",", "att_res_2", "]", ",", "1", ")", ",", "[", "state", "[", "0", "]", "[", "2", ":", "3", "]", ",", "state", "[", "1", "]", "[", "2", ":", "3", "]", "]", ")", "\n", "\n", "return", "h_2", ",", "[", "torch", ".", "cat", "(", "_", ",", "0", ")", "for", "_", "in", "zip", "(", "state_0", ",", "state_1", ",", "state_2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.DenseAttCore.__init__": [[508, 535], ["torch.Module.__init__", "AttModel.Attention", "AttModel.Attention", "FCModel.LSTMCore", "FCModel.LSTMCore", "FCModel.LSTMCore", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "use_maxout", "=", "False", ")", ":", "\n", "        ", "super", "(", "DenseAttCore", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "\n", "# self.att0 = Attention(opt)", "\n", "self", ".", "att1", "=", "Attention", "(", "opt", ")", "\n", "self", ".", "att2", "=", "Attention", "(", "opt", ")", "\n", "\n", "opt_input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "opt", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "+", "opt", ".", "rnn_size", "\n", "self", ".", "lstm0", "=", "LSTMCore", "(", "opt", ")", "# att_feat + word_embedding", "\n", "opt", ".", "input_encoding_size", "=", "opt", ".", "rnn_size", "*", "2", "\n", "self", ".", "lstm1", "=", "LSTMCore", "(", "opt", ")", "\n", "self", ".", "lstm2", "=", "LSTMCore", "(", "opt", ")", "\n", "opt", ".", "input_encoding_size", "=", "opt_input_encoding_size", "\n", "\n", "# self.emb1 = nn.Linear(opt.rnn_size, opt.rnn_size)", "\n", "self", ".", "emb2", "=", "nn", ".", "Linear", "(", "opt", ".", "rnn_size", ",", "opt", ".", "rnn_size", ")", "\n", "\n", "# fuse h_0 and h_1", "\n", "self", ".", "fusion1", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "opt", ".", "rnn_size", "*", "2", ",", "opt", ".", "rnn_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "opt", ".", "drop_prob_lm", ")", ")", "\n", "# fuse h_0, h_1 and h_2", "\n", "self", ".", "fusion2", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "opt", ".", "rnn_size", "*", "3", ",", "opt", ".", "rnn_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "opt", ".", "drop_prob_lm", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.DenseAttCore.forward": [[536, 545], ["AttModel.DenseAttCore.lstm0", "AttModel.DenseAttCore.att1", "AttModel.DenseAttCore.lstm1", "AttModel.DenseAttCore.att2", "AttModel.DenseAttCore.lstm2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "AttModel.DenseAttCore.fusion2", "AttModel.DenseAttCore.emb2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "AttModel.DenseAttCore.fusion1", "zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", "=", "None", ")", ":", "\n", "# att_res_0 = self.att0(state[0][-1], att_feats, p_att_feats, att_masks)", "\n", "        ", "h_0", ",", "state_0", "=", "self", ".", "lstm0", "(", "torch", ".", "cat", "(", "[", "xt", ",", "fc_feats", "]", ",", "1", ")", ",", "[", "state", "[", "0", "]", "[", "0", ":", "1", "]", ",", "state", "[", "1", "]", "[", "0", ":", "1", "]", "]", ")", "\n", "att_res_1", "=", "self", ".", "att1", "(", "h_0", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ")", "\n", "h_1", ",", "state_1", "=", "self", ".", "lstm1", "(", "torch", ".", "cat", "(", "[", "h_0", ",", "att_res_1", "]", ",", "1", ")", ",", "[", "state", "[", "0", "]", "[", "1", ":", "2", "]", ",", "state", "[", "1", "]", "[", "1", ":", "2", "]", "]", ")", "\n", "att_res_2", "=", "self", ".", "att2", "(", "h_1", "+", "self", ".", "emb2", "(", "att_res_1", ")", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ")", "\n", "h_2", ",", "state_2", "=", "self", ".", "lstm2", "(", "torch", ".", "cat", "(", "[", "self", ".", "fusion1", "(", "torch", ".", "cat", "(", "[", "h_0", ",", "h_1", "]", ",", "1", ")", ")", ",", "att_res_2", "]", ",", "1", ")", ",", "[", "state", "[", "0", "]", "[", "2", ":", "3", "]", ",", "state", "[", "1", "]", "[", "2", ":", "3", "]", "]", ")", "\n", "\n", "return", "self", ".", "fusion2", "(", "torch", ".", "cat", "(", "[", "h_0", ",", "h_1", ",", "h_2", "]", ",", "1", ")", ")", ",", "[", "torch", ".", "cat", "(", "_", ",", "0", ")", "for", "_", "in", "zip", "(", "state_0", ",", "state_1", ",", "state_2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Attention.__init__": [[547, 554], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Attention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "att_hid_size", "=", "opt", ".", "att_hid_size", "\n", "\n", "self", ".", "h2att", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "att_hid_size", ")", "\n", "self", ".", "alpha_net", "=", "nn", ".", "Linear", "(", "self", ".", "att_hid_size", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Attention.forward": [[555, 576], ["p_att_feats.view", "AttModel.Attention.h2att", "att_h.unsqueeze().expand_as.unsqueeze().expand_as.unsqueeze().expand_as", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "dot.view.view.view", "AttModel.Attention.alpha_net", "dot.view.view.view", "torch.softmax", "torch.softmax", "torch.softmax", "att_feats.view", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "att_feats.size", "att_feats.size", "att_feats.numel", "att_feats.size", "att_h.unsqueeze().expand_as.unsqueeze().expand_as.unsqueeze", "att_masks.view().float", "torch.softmax.sum", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.softmax.unsqueeze", "att_masks.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "h", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", "=", "None", ")", ":", "\n", "# The p_att_feats here is already projected", "\n", "        ", "att_size", "=", "att_feats", ".", "numel", "(", ")", "//", "att_feats", ".", "size", "(", "0", ")", "//", "att_feats", ".", "size", "(", "-", "1", ")", "\n", "att", "=", "p_att_feats", ".", "view", "(", "-", "1", ",", "att_size", ",", "self", ".", "att_hid_size", ")", "\n", "\n", "att_h", "=", "self", ".", "h2att", "(", "h", ")", "# batch * att_hid_size", "\n", "att_h", "=", "att_h", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "att", ")", "# batch * att_size * att_hid_size", "\n", "dot", "=", "att", "+", "att_h", "# batch * att_size * att_hid_size", "\n", "dot", "=", "torch", ".", "tanh", "(", "dot", ")", "# batch * att_size * att_hid_size", "\n", "dot", "=", "dot", ".", "view", "(", "-", "1", ",", "self", ".", "att_hid_size", ")", "# (batch * att_size) * att_hid_size", "\n", "dot", "=", "self", ".", "alpha_net", "(", "dot", ")", "# (batch * att_size) * 1", "\n", "dot", "=", "dot", ".", "view", "(", "-", "1", ",", "att_size", ")", "# batch * att_size", "\n", "\n", "weight", "=", "F", ".", "softmax", "(", "dot", ",", "dim", "=", "1", ")", "# batch * att_size", "\n", "if", "att_masks", "is", "not", "None", ":", "\n", "            ", "weight", "=", "weight", "*", "att_masks", ".", "view", "(", "-", "1", ",", "att_size", ")", ".", "float", "(", ")", "\n", "weight", "=", "weight", "/", "weight", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "# normalize to 1", "\n", "", "att_feats_", "=", "att_feats", ".", "view", "(", "-", "1", ",", "att_size", ",", "att_feats", ".", "size", "(", "-", "1", ")", ")", "# batch * att_size * att_feat_size", "\n", "att_res", "=", "torch", ".", "bmm", "(", "weight", ".", "unsqueeze", "(", "1", ")", ",", "att_feats_", ")", ".", "squeeze", "(", "1", ")", "# batch * att_feat_size", "\n", "\n", "return", "att_res", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Att2in2Core.__init__": [[578, 596], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "AttModel.Attention"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Att2in2Core", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "#self.rnn_type = opt.rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "#self.num_layers = opt.num_layers", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "fc_feat_size", "=", "opt", ".", "fc_feat_size", "\n", "self", ".", "att_feat_size", "=", "opt", ".", "att_feat_size", "\n", "self", ".", "att_hid_size", "=", "opt", ".", "att_hid_size", "\n", "\n", "# Build a LSTM", "\n", "self", ".", "a2c", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "2", "*", "self", ".", "rnn_size", ")", "\n", "self", ".", "i2h", "=", "nn", ".", "Linear", "(", "self", ".", "input_encoding_size", ",", "5", "*", "self", ".", "rnn_size", ")", "\n", "self", ".", "h2h", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "5", "*", "self", ".", "rnn_size", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", "\n", "\n", "self", ".", "attention", "=", "Attention", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Att2in2Core.forward": [[597, 618], ["AttModel.Att2in2Core.attention", "all_input_sums.narrow", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "AttModel.Att2in2Core.dropout", "AttModel.Att2in2Core.i2h", "AttModel.Att2in2Core.h2h", "all_input_sums.narrow", "AttModel.Att2in2Core.a2c", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "next_h.unsqueeze", "next_c.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.attention"], ["", "def", "forward", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", "=", "None", ")", ":", "\n", "        ", "att_res", "=", "self", ".", "attention", "(", "state", "[", "0", "]", "[", "-", "1", "]", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ")", "\n", "\n", "all_input_sums", "=", "self", ".", "i2h", "(", "xt", ")", "+", "self", ".", "h2h", "(", "state", "[", "0", "]", "[", "-", "1", "]", ")", "\n", "sigmoid_chunk", "=", "all_input_sums", ".", "narrow", "(", "1", ",", "0", ",", "3", "*", "self", ".", "rnn_size", ")", "\n", "sigmoid_chunk", "=", "torch", ".", "sigmoid", "(", "sigmoid_chunk", ")", "\n", "in_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "0", ",", "self", ".", "rnn_size", ")", "\n", "forget_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", "\n", "out_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", "*", "2", ",", "self", ".", "rnn_size", ")", "\n", "\n", "in_transform", "=", "all_input_sums", ".", "narrow", "(", "1", ",", "3", "*", "self", ".", "rnn_size", ",", "2", "*", "self", ".", "rnn_size", ")", "+", "self", ".", "a2c", "(", "att_res", ")", "\n", "in_transform", "=", "torch", ".", "max", "(", "in_transform", ".", "narrow", "(", "1", ",", "0", ",", "self", ".", "rnn_size", ")", ",", "\n", "in_transform", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", ")", "\n", "next_c", "=", "forget_gate", "*", "state", "[", "1", "]", "[", "-", "1", "]", "+", "in_gate", "*", "in_transform", "\n", "next_h", "=", "out_gate", "*", "torch", ".", "tanh", "(", "next_c", ")", "\n", "\n", "output", "=", "self", ".", "dropout", "(", "next_h", ")", "\n", "state", "=", "(", "next_h", ".", "unsqueeze", "(", "0", ")", ",", "next_c", ".", "unsqueeze", "(", "0", ")", ")", "\n", "return", "output", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Att2inCore.__init__": [[620, 624], ["AttModel.Att2in2Core.__init__", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Att2inCore", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "del", "self", ".", "a2c", "\n", "self", ".", "a2c", "=", "nn", ".", "Linear", "(", "self", ".", "att_feat_size", ",", "2", "*", "self", ".", "rnn_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Att2all2Core.__init__": [[630, 648], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "AttModel.Attention"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Att2all2Core", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "#self.rnn_type = opt.rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "#self.num_layers = opt.num_layers", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "fc_feat_size", "=", "opt", ".", "fc_feat_size", "\n", "self", ".", "att_feat_size", "=", "opt", ".", "att_feat_size", "\n", "self", ".", "att_hid_size", "=", "opt", ".", "att_hid_size", "\n", "\n", "# Build a LSTM", "\n", "self", ".", "a2h", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "5", "*", "self", ".", "rnn_size", ")", "\n", "self", ".", "i2h", "=", "nn", ".", "Linear", "(", "self", ".", "input_encoding_size", ",", "5", "*", "self", ".", "rnn_size", ")", "\n", "self", ".", "h2h", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "5", "*", "self", ".", "rnn_size", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", "\n", "\n", "self", ".", "attention", "=", "Attention", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Att2all2Core.forward": [[649, 669], ["AttModel.Att2all2Core.attention", "all_input_sums.narrow", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "all_input_sums.narrow", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "AttModel.Att2all2Core.dropout", "AttModel.Att2all2Core.a2h", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.max.narrow", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "next_h.unsqueeze", "next_c.unsqueeze", "AttModel.Att2all2Core.i2h", "AttModel.Att2all2Core.h2h"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.attention"], ["", "def", "forward", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", "=", "None", ")", ":", "\n", "        ", "att_res", "=", "self", ".", "attention", "(", "state", "[", "0", "]", "[", "-", "1", "]", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ")", "\n", "\n", "all_input_sums", "=", "self", ".", "i2h", "(", "xt", ")", "+", "self", ".", "h2h", "(", "state", "[", "0", "]", "[", "-", "1", "]", ")", "+", "self", ".", "a2h", "(", "att_res", ")", "\n", "sigmoid_chunk", "=", "all_input_sums", ".", "narrow", "(", "1", ",", "0", ",", "3", "*", "self", ".", "rnn_size", ")", "\n", "sigmoid_chunk", "=", "torch", ".", "sigmoid", "(", "sigmoid_chunk", ")", "\n", "in_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "0", ",", "self", ".", "rnn_size", ")", "\n", "forget_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", "\n", "out_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", "*", "2", ",", "self", ".", "rnn_size", ")", "\n", "\n", "in_transform", "=", "all_input_sums", ".", "narrow", "(", "1", ",", "3", "*", "self", ".", "rnn_size", ",", "2", "*", "self", ".", "rnn_size", ")", "\n", "in_transform", "=", "torch", ".", "max", "(", "in_transform", ".", "narrow", "(", "1", ",", "0", ",", "self", ".", "rnn_size", ")", ",", "\n", "in_transform", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", ")", "\n", "next_c", "=", "forget_gate", "*", "state", "[", "1", "]", "[", "-", "1", "]", "+", "in_gate", "*", "in_transform", "\n", "next_h", "=", "out_gate", "*", "torch", ".", "tanh", "(", "next_c", ")", "\n", "\n", "output", "=", "self", ".", "dropout", "(", "next_h", ")", "\n", "state", "=", "(", "next_h", ".", "unsqueeze", "(", "0", ")", ",", "next_c", ".", "unsqueeze", "(", "0", ")", ")", "\n", "return", "output", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AdaAttModel.__init__": [[671, 674], ["AttModel.AttModel.__init__", "AttModel.AdaAttCore"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "AdaAttModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "core", "=", "AdaAttCore", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AdaAttMOModel.__init__": [[677, 680], ["AttModel.AttModel.__init__", "AttModel.AdaAttCore"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "AdaAttMOModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "core", "=", "AdaAttCore", "(", "opt", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Att2in2Model.__init__": [[682, 687], ["AttModel.AttModel.__init__", "AttModel.Att2in2Core", "delattr"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Att2in2Model", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "core", "=", "Att2in2Core", "(", "opt", ")", "\n", "delattr", "(", "self", ",", "'fc_embed'", ")", "\n", "self", ".", "fc_embed", "=", "lambda", "x", ":", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Att2all2Model.__init__": [[689, 694], ["AttModel.AttModel.__init__", "AttModel.Att2all2Core", "delattr"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Att2all2Model", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "core", "=", "Att2all2Core", "(", "opt", ")", "\n", "delattr", "(", "self", ",", "'fc_embed'", ")", "\n", "self", ".", "fc_embed", "=", "lambda", "x", ":", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.TopDownModel.__init__": [[696, 700], ["AttModel.AttModel.__init__", "AttModel.TopDownCore"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "TopDownModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "num_layers", "=", "2", "\n", "self", ".", "core", "=", "TopDownCore", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.StackAttModel.__init__": [[702, 706], ["AttModel.AttModel.__init__", "AttModel.StackAttCore"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "StackAttModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "num_layers", "=", "3", "\n", "self", ".", "core", "=", "StackAttCore", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.DenseAttModel.__init__": [[708, 712], ["AttModel.AttModel.__init__", "AttModel.DenseAttCore"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "DenseAttModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "num_layers", "=", "3", "\n", "self", ".", "core", "=", "DenseAttCore", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Att2inModel.__init__": [[714, 723], ["AttModel.AttModel.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Linear", "torch.Linear", "torch.Linear", "AttModel.Att2inCore", "AttModel.Att2inModel.init_weights"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_weights"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Att2inModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "del", "self", ".", "embed", ",", "self", ".", "fc_embed", ",", "self", ".", "att_embed", "\n", "self", ".", "embed", "=", "nn", ".", "Embedding", "(", "self", ".", "vocab_size", "+", "1", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "fc_embed", "=", "self", ".", "att_embed", "=", "lambda", "x", ":", "x", "\n", "del", "self", ".", "ctx2att", "\n", "self", ".", "ctx2att", "=", "nn", ".", "Linear", "(", "self", ".", "att_feat_size", ",", "self", ".", "att_hid_size", ")", "\n", "self", ".", "core", "=", "Att2inCore", "(", "opt", ")", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.Att2inModel.init_weights": [[724, 729], ["AttModel.Att2inModel.embed.weight.data.uniform_", "AttModel.Att2inModel.logit.bias.data.fill_", "AttModel.Att2inModel.logit.weight.data.uniform_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "initrange", "=", "0.1", "\n", "self", ".", "embed", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "initrange", ",", "initrange", ")", "\n", "self", ".", "logit", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "logit", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "initrange", ",", "initrange", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.NewFCModel.__init__": [[732, 741], ["AttModel.AttModel.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Embedding", "torch.Embedding", "torch.Embedding", "FCModel.LSTMCore", "delattr", "delattr"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "NewFCModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "fc_embed", "=", "nn", ".", "Linear", "(", "self", ".", "fc_feat_size", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "embed", "=", "nn", ".", "Embedding", "(", "self", ".", "vocab_size", "+", "1", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "_core", "=", "LSTMCore", "(", "opt", ")", "\n", "delattr", "(", "self", ",", "'att_embed'", ")", "\n", "self", ".", "att_embed", "=", "lambda", "x", ":", "x", "\n", "delattr", "(", "self", ",", "'ctx2att'", ")", "\n", "self", ".", "ctx2att", "=", "lambda", "x", ":", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.NewFCModel.core": [[742, 766], ["AttModel.NewFCModel._core", "AttModel.NewFCModel._core"], "methods", ["None"], ["", "def", "core", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", ")", ":", "\n", "# Step 0, feed the input image", "\n", "# if (self.training and state[0].is_leaf) or \\", "\n", "#     (not self.training and state[0].sum() == 0):", "\n", "#     _, state = self._core(fc_feats, state)", "\n", "# three cases", "\n", "# normal mle training", "\n", "# Sample", "\n", "# beam search (diverse beam search)", "\n", "# fixed captioning module.", "\n", "# is_first_step = (state[0]==0).all(2).all(0)", "\n", "# if is_first_step.all():", "\n", "#     _, state = self._core(fc_feats, state)", "\n", "# elif is_first_step.any():", "\n", "#     # This is mostly for diverse beam search I think", "\n", "#     new_state = torch.zeros_like(state)", "\n", "#     new_state[~is_first_step] = state[~is_first_step]", "\n", "#     _, state = self._core(fc_feats, state)", "\n", "#     new_state[is_first_step] = state[is_first_step]", "\n", "#     state = new_state", "\n", "        ", "if", "(", "state", "[", "0", "]", "==", "0", ")", ".", "all", "(", ")", ":", "\n", "# Let's forget about diverse beam search first", "\n", "            ", "_", ",", "state", "=", "self", ".", "_core", "(", "fc_feats", ",", "state", ")", "\n", "", "return", "self", ".", "_core", "(", "xt", ",", "state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.NewFCModel._prepare_feature": [[767, 771], ["AttModel.NewFCModel.fc_embed"], "methods", ["None"], ["", "def", "_prepare_feature", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", ")", ":", "\n", "        ", "fc_feats", "=", "self", ".", "fc_embed", "(", "fc_feats", ")", "\n", "\n", "return", "fc_feats", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.LMModel.__init__": [[774, 784], ["AttModel.AttModel.__init__", "delattr", "torch.Embedding", "torch.Embedding", "torch.Embedding", "FCModel.LSTMCore", "delattr", "delattr", "x.new_zeros"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "LMModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "delattr", "(", "self", ",", "'fc_embed'", ")", "\n", "self", ".", "fc_embed", "=", "lambda", "x", ":", "x", ".", "new_zeros", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "embed", "=", "nn", ".", "Embedding", "(", "self", ".", "vocab_size", "+", "1", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "_core", "=", "LSTMCore", "(", "opt", ")", "\n", "delattr", "(", "self", ",", "'att_embed'", ")", "\n", "self", ".", "att_embed", "=", "lambda", "x", ":", "x", "\n", "delattr", "(", "self", ",", "'ctx2att'", ")", "\n", "self", ".", "ctx2att", "=", "lambda", "x", ":", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.LMModel.core": [[785, 790], ["AttModel.LMModel._core", "AttModel.LMModel._core"], "methods", ["None"], ["", "def", "core", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", ")", ":", "\n", "        ", "if", "(", "state", "[", "0", "]", "==", "0", ")", ".", "all", "(", ")", ":", "\n", "# Let's forget about diverse beam search first", "\n", "            ", "_", ",", "state", "=", "self", ".", "_core", "(", "fc_feats", ",", "state", ")", "\n", "", "return", "self", ".", "_core", "(", "xt", ",", "state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.LMModel._prepare_feature": [[791, 795], ["AttModel.LMModel.fc_embed"], "methods", ["None"], ["", "def", "_prepare_feature", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", ")", ":", "\n", "        ", "fc_feats", "=", "self", ".", "fc_embed", "(", "fc_feats", ")", "\n", "\n", "return", "fc_feats", ",", "None", ",", "None", ",", "None", "", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.sort_pack_padded_sequence": [[32, 38], ["torch.sort", "torch.sort", "torch.sort", "torch.nn.utils.rnn.pack_padded_sequence", "indices.clone", "torch.arange().type_as", "torch.arange().type_as", "torch.arange().type_as", "torch.arange", "torch.arange", "torch.arange", "len"], "function", ["None"], ["def", "sort_pack_padded_sequence", "(", "input", ",", "lengths", ")", ":", "\n", "    ", "sorted_lengths", ",", "indices", "=", "torch", ".", "sort", "(", "lengths", ",", "descending", "=", "True", ")", "\n", "tmp", "=", "pack_padded_sequence", "(", "input", "[", "indices", "]", ",", "sorted_lengths", ",", "batch_first", "=", "True", ")", "\n", "inv_ix", "=", "indices", ".", "clone", "(", ")", "\n", "inv_ix", "[", "indices", "]", "=", "torch", ".", "arange", "(", "0", ",", "len", "(", "indices", ")", ")", ".", "type_as", "(", "inv_ix", ")", "\n", "return", "tmp", ",", "inv_ix", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.pad_unsort_packed_sequence": [[39, 43], ["torch.nn.utils.rnn.pad_packed_sequence"], "function", ["None"], ["", "def", "pad_unsort_packed_sequence", "(", "input", ",", "inv_ix", ")", ":", "\n", "    ", "tmp", ",", "_", "=", "pad_packed_sequence", "(", "input", ",", "batch_first", "=", "True", ")", "\n", "tmp", "=", "tmp", "[", "inv_ix", "]", "\n", "return", "tmp", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.pack_wrapper": [[44, 50], ["AttModel.sort_pack_padded_sequence", "AttModel.pad_unsort_packed_sequence", "module", "att_masks.data.long().sum", "torch.nn.utils.rnn.PackedSequence", "module", "att_masks.data.long"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.sort_pack_padded_sequence", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.pad_unsort_packed_sequence"], ["", "def", "pack_wrapper", "(", "module", ",", "att_feats", ",", "att_masks", ")", ":", "\n", "    ", "if", "att_masks", "is", "not", "None", ":", "\n", "        ", "packed", ",", "inv_ix", "=", "sort_pack_padded_sequence", "(", "att_feats", ",", "att_masks", ".", "data", ".", "long", "(", ")", ".", "sum", "(", "1", ")", ")", "\n", "return", "pad_unsort_packed_sequence", "(", "PackedSequence", "(", "module", "(", "packed", "[", "0", "]", ")", ",", "packed", "[", "1", "]", ")", ",", "inv_ix", ")", "\n", "", "else", ":", "\n", "        ", "return", "module", "(", "att_feats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.__init__": [[23, 25], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["\n", "# implements beam search", "\n", "# calls beam_step and returns the final set of beams", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.forward": [[30, 35], ["kwargs.get", "getattr"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["if", "'mode'", "in", "kwargs", ":", "\n", "            ", "del", "kwargs", "[", "'mode'", "]", "\n", "", "return", "getattr", "(", "self", ",", "'_'", "+", "mode", ")", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "def", "beam_search", "(", "self", ",", "init_state", ",", "init_logprobs", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.beam_search": [[36, 190], ["opt.get", "opt.get", "opt.get", "opt.get", "opt.get", "opt.get", "misc.penalty_builder", "list", "list", "list", "range", "functools.reduce", "logprobs_table[].data.float.clone", "range", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "min", "range", "sorted", "range", "opt.get", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zip", "init_logprobs.chunk", "range", "range", "ys.size", "range", "_.clone", "beam_seq[].clone", "beam_seq_logprobs[].clone", "range", "range", "range", "range", "range", "sorted", "range", "range", "ys[].item", "sorted.append", "len", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "range", "_.chunk", "range", "logprobs_table[].data.float", "CaptionModel.CaptionModel.beam_search.add_diversity"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.penalty_builder", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["# function computes the similarity score to be augmented", "\n", "        ", "def", "add_diversity", "(", "beam_seq_table", ",", "logprobsf", ",", "t", ",", "divm", ",", "diversity_lambda", ",", "bdash", ")", ":", "\n", "            ", "local_time", "=", "t", "-", "divm", "\n", "unaug_logprobsf", "=", "logprobsf", ".", "clone", "(", ")", "\n", "for", "prev_choice", "in", "range", "(", "divm", ")", ":", "\n", "                ", "prev_decisions", "=", "beam_seq_table", "[", "prev_choice", "]", "[", "local_time", "]", "\n", "for", "sub_beam", "in", "range", "(", "bdash", ")", ":", "\n", "                    ", "for", "prev_labels", "in", "range", "(", "bdash", ")", ":", "\n", "                        ", "logprobsf", "[", "sub_beam", "]", "[", "prev_decisions", "[", "prev_labels", "]", "]", "=", "logprobsf", "[", "sub_beam", "]", "[", "prev_decisions", "[", "prev_labels", "]", "]", "-", "diversity_lambda", "\n", "", "", "", "return", "unaug_logprobsf", "\n", "\n", "# does one step of classical beam search", "\n", "\n", "", "def", "beam_step", "(", "logprobsf", ",", "unaug_logprobsf", ",", "beam_size", ",", "t", ",", "beam_seq", ",", "beam_seq_logprobs", ",", "beam_logprobs_sum", ",", "state", ")", ":", "\n", "#INPUTS:", "\n", "#logprobsf: probabilities augmented after diversity", "\n", "#beam_size: obvious", "\n", "#t        : time instant", "\n", "#beam_seq : tensor contanining the beams", "\n", "#beam_seq_logprobs: tensor contanining the beam logprobs", "\n", "#beam_logprobs_sum: tensor contanining joint logprobs", "\n", "#OUPUTS:", "\n", "#beam_seq : tensor containing the word indices of the decoded captions", "\n", "#beam_seq_logprobs : log-probability of each decision made, same size as beam_seq", "\n", "#beam_logprobs_sum : joint log-probability of each beam", "\n", "\n", "            ", "ys", ",", "ix", "=", "torch", ".", "sort", "(", "logprobsf", ",", "1", ",", "True", ")", "\n", "candidates", "=", "[", "]", "\n", "cols", "=", "min", "(", "beam_size", ",", "ys", ".", "size", "(", "1", ")", ")", "\n", "rows", "=", "beam_size", "\n", "if", "t", "==", "0", ":", "\n", "                ", "rows", "=", "1", "\n", "", "for", "c", "in", "range", "(", "cols", ")", ":", "# for each column (word, essentially)", "\n", "                ", "for", "q", "in", "range", "(", "rows", ")", ":", "# for each beam expansion", "\n", "#compute logprob of expanding beam q with word in (sorted) position c", "\n", "                    ", "local_logprob", "=", "ys", "[", "q", ",", "c", "]", ".", "item", "(", ")", "\n", "candidate_logprob", "=", "beam_logprobs_sum", "[", "q", "]", "+", "local_logprob", "\n", "local_unaug_logprob", "=", "unaug_logprobsf", "[", "q", ",", "ix", "[", "q", ",", "c", "]", "]", "\n", "candidates", ".", "append", "(", "{", "'c'", ":", "ix", "[", "q", ",", "c", "]", ",", "'q'", ":", "q", ",", "'p'", ":", "candidate_logprob", ",", "'r'", ":", "local_unaug_logprob", "}", ")", "\n", "", "", "candidates", "=", "sorted", "(", "candidates", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "'p'", "]", ")", "\n", "\n", "new_state", "=", "[", "_", ".", "clone", "(", ")", "for", "_", "in", "state", "]", "\n", "#beam_seq_prev, beam_seq_logprobs_prev", "\n", "if", "t", ">=", "1", ":", "\n", "#we''ll need these as reference when we fork beams around", "\n", "                ", "beam_seq_prev", "=", "beam_seq", "[", ":", "t", "]", ".", "clone", "(", ")", "\n", "beam_seq_logprobs_prev", "=", "beam_seq_logprobs", "[", ":", "t", "]", ".", "clone", "(", ")", "\n", "", "for", "vix", "in", "range", "(", "beam_size", ")", ":", "\n", "                ", "v", "=", "candidates", "[", "vix", "]", "\n", "#fork beam index q into index vix", "\n", "if", "t", ">=", "1", ":", "\n", "                    ", "beam_seq", "[", ":", "t", ",", "vix", "]", "=", "beam_seq_prev", "[", ":", ",", "v", "[", "'q'", "]", "]", "\n", "beam_seq_logprobs", "[", ":", "t", ",", "vix", "]", "=", "beam_seq_logprobs_prev", "[", ":", ",", "v", "[", "'q'", "]", "]", "\n", "#rearrange recurrent states", "\n", "", "for", "state_ix", "in", "range", "(", "len", "(", "new_state", ")", ")", ":", "\n", "#  copy over state in previous beam q to new beam at vix", "\n", "                    ", "new_state", "[", "state_ix", "]", "[", ":", ",", "vix", "]", "=", "state", "[", "state_ix", "]", "[", ":", ",", "v", "[", "'q'", "]", "]", "# dimension one is time step", "\n", "#append new end terminal at the end of this beam", "\n", "", "beam_seq", "[", "t", ",", "vix", "]", "=", "v", "[", "'c'", "]", "# c'th word is the continuation", "\n", "beam_seq_logprobs", "[", "t", ",", "vix", "]", "=", "v", "[", "'r'", "]", "# the raw logprob here", "\n", "beam_logprobs_sum", "[", "vix", "]", "=", "v", "[", "'p'", "]", "# the new (sum) logprob along this beam", "\n", "", "state", "=", "new_state", "\n", "return", "beam_seq", ",", "beam_seq_logprobs", ",", "beam_logprobs_sum", ",", "state", ",", "candidates", "\n", "\n", "# Start diverse_beam_search", "\n", "", "opt", "=", "kwargs", "[", "'opt'", "]", "\n", "temperature", "=", "opt", ".", "get", "(", "'temperature'", ",", "1", ")", "# This should not affect beam search, but will affect dbs", "\n", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "10", ")", "\n", "group_size", "=", "opt", ".", "get", "(", "'group_size'", ",", "1", ")", "\n", "diversity_lambda", "=", "opt", ".", "get", "(", "'diversity_lambda'", ",", "0.5", ")", "\n", "decoding_constraint", "=", "opt", ".", "get", "(", "'decoding_constraint'", ",", "0", ")", "\n", "remove_bad_endings", "=", "opt", ".", "get", "(", "'remove_bad_endings'", ",", "0", ")", "\n", "length_penalty", "=", "utils", ".", "penalty_builder", "(", "opt", ".", "get", "(", "'length_penalty'", ",", "''", ")", ")", "\n", "bdash", "=", "beam_size", "//", "group_size", "# beam per group", "\n", "\n", "# INITIALIZATIONS", "\n", "beam_seq_table", "=", "[", "torch", ".", "LongTensor", "(", "self", ".", "seq_length", ",", "bdash", ")", ".", "zero_", "(", ")", "for", "_", "in", "range", "(", "group_size", ")", "]", "\n", "beam_seq_logprobs_table", "=", "[", "torch", ".", "FloatTensor", "(", "self", ".", "seq_length", ",", "bdash", ")", ".", "zero_", "(", ")", "for", "_", "in", "range", "(", "group_size", ")", "]", "\n", "beam_logprobs_sum_table", "=", "[", "torch", ".", "zeros", "(", "bdash", ")", "for", "_", "in", "range", "(", "group_size", ")", "]", "\n", "\n", "# logprobs # logprobs predicted in last time step, shape (beam_size, vocab_size+1)", "\n", "done_beams_table", "=", "[", "[", "]", "for", "_", "in", "range", "(", "group_size", ")", "]", "\n", "# state_table = [list(torch.unbind(_)) for _ in torch.stack(init_state).chunk(group_size, 2)]", "\n", "state_table", "=", "list", "(", "zip", "(", "*", "[", "_", ".", "chunk", "(", "group_size", ",", "1", ")", "for", "_", "in", "init_state", "]", ")", ")", "\n", "logprobs_table", "=", "list", "(", "init_logprobs", ".", "chunk", "(", "group_size", ",", "0", ")", ")", "\n", "# END INIT", "\n", "\n", "# Chunk elements in the args", "\n", "args", "=", "list", "(", "args", ")", "\n", "if", "self", ".", "__class__", ".", "__name__", "==", "'AttEnsemble'", ":", "\n", "            ", "args", "=", "[", "[", "_", ".", "chunk", "(", "group_size", ")", "if", "_", "is", "not", "None", "else", "[", "None", "]", "*", "group_size", "for", "_", "in", "args_", "]", "for", "args_", "in", "args", "]", "# arg_name, model_name, group_name", "\n", "args", "=", "[", "[", "[", "args", "[", "j", "]", "[", "i", "]", "[", "k", "]", "for", "i", "in", "range", "(", "len", "(", "self", ".", "models", ")", ")", "]", "for", "j", "in", "range", "(", "len", "(", "args", ")", ")", "]", "for", "k", "in", "range", "(", "group_size", ")", "]", "# group_name, arg_name, model_name", "\n", "", "else", ":", "\n", "            ", "args", "=", "[", "_", ".", "chunk", "(", "group_size", ")", "if", "_", "is", "not", "None", "else", "[", "None", "]", "*", "group_size", "for", "_", "in", "args", "]", "\n", "args", "=", "[", "[", "args", "[", "i", "]", "[", "j", "]", "for", "i", "in", "range", "(", "len", "(", "args", ")", ")", "]", "for", "j", "in", "range", "(", "group_size", ")", "]", "\n", "\n", "", "for", "t", "in", "range", "(", "self", ".", "seq_length", "+", "group_size", "-", "1", ")", ":", "\n", "            ", "for", "divm", "in", "range", "(", "group_size", ")", ":", "\n", "                ", "if", "t", ">=", "divm", "and", "t", "<=", "self", ".", "seq_length", "+", "divm", "-", "1", ":", "\n", "# add diversity", "\n", "                    ", "logprobsf", "=", "logprobs_table", "[", "divm", "]", ".", "data", ".", "float", "(", ")", "\n", "# suppress previous word", "\n", "if", "decoding_constraint", "and", "t", "-", "divm", ">", "0", ":", "\n", "                        ", "logprobsf", ".", "scatter_", "(", "1", ",", "beam_seq_table", "[", "divm", "]", "[", "t", "-", "divm", "-", "1", "]", ".", "unsqueeze", "(", "1", ")", ".", "cuda", "(", ")", ",", "float", "(", "'-inf'", ")", ")", "\n", "", "if", "remove_bad_endings", "and", "t", "-", "divm", ">", "0", ":", "\n", "                        ", "logprobsf", "[", "torch", ".", "from_numpy", "(", "np", ".", "isin", "(", "beam_seq_table", "[", "divm", "]", "[", "t", "-", "divm", "-", "1", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "self", ".", "bad_endings_ix", ")", ".", "astype", "(", "'uint8'", ")", ")", ",", "0", "]", "=", "float", "(", "'-inf'", ")", "\n", "# suppress UNK tokens in the decoding", "\n", "", "logprobsf", "[", ":", ",", "logprobsf", ".", "size", "(", "1", ")", "-", "1", "]", "=", "logprobsf", "[", ":", ",", "logprobsf", ".", "size", "(", "1", ")", "-", "1", "]", "-", "1000", "\n", "# diversity is added here", "\n", "# the function directly modifies the logprobsf values and hence, we need to return", "\n", "# the unaugmented ones for sorting the candidates in the end. # for historical", "\n", "# reasons :-)", "\n", "unaug_logprobsf", "=", "add_diversity", "(", "beam_seq_table", ",", "logprobsf", ",", "t", ",", "divm", ",", "diversity_lambda", ",", "bdash", ")", "\n", "\n", "# infer new beams", "\n", "beam_seq_table", "[", "divm", "]", ",", "beam_seq_logprobs_table", "[", "divm", "]", ",", "beam_logprobs_sum_table", "[", "divm", "]", ",", "state_table", "[", "divm", "]", ",", "candidates_divm", "=", "beam_step", "(", "logprobsf", ",", "\n", "unaug_logprobsf", ",", "\n", "bdash", ",", "\n", "t", "-", "divm", ",", "\n", "beam_seq_table", "[", "divm", "]", ",", "\n", "beam_seq_logprobs_table", "[", "divm", "]", ",", "\n", "beam_logprobs_sum_table", "[", "divm", "]", ",", "\n", "state_table", "[", "divm", "]", ")", "\n", "\n", "# if time's up... or if end token is reached then copy beams", "\n", "for", "vix", "in", "range", "(", "bdash", ")", ":", "\n", "                        ", "if", "beam_seq_table", "[", "divm", "]", "[", "t", "-", "divm", ",", "vix", "]", "==", "0", "or", "t", "==", "self", ".", "seq_length", "+", "divm", "-", "1", ":", "\n", "                            ", "final_beam", "=", "{", "\n", "'seq'", ":", "beam_seq_table", "[", "divm", "]", "[", ":", ",", "vix", "]", ".", "clone", "(", ")", ",", "\n", "'logps'", ":", "beam_seq_logprobs_table", "[", "divm", "]", "[", ":", ",", "vix", "]", ".", "clone", "(", ")", ",", "\n", "'unaug_p'", ":", "beam_seq_logprobs_table", "[", "divm", "]", "[", ":", ",", "vix", "]", ".", "sum", "(", ")", ".", "item", "(", ")", ",", "\n", "'p'", ":", "beam_logprobs_sum_table", "[", "divm", "]", "[", "vix", "]", ".", "item", "(", ")", "\n", "}", "\n", "final_beam", "[", "'p'", "]", "=", "length_penalty", "(", "t", "-", "divm", "+", "1", ",", "final_beam", "[", "'p'", "]", ")", "\n", "done_beams_table", "[", "divm", "]", ".", "append", "(", "final_beam", ")", "\n", "# don't continue beams from finished sequences", "\n", "beam_logprobs_sum_table", "[", "divm", "]", "[", "vix", "]", "=", "-", "1000", "\n", "\n", "# move the current group one step forward in time", "\n", "\n", "", "", "it", "=", "beam_seq_table", "[", "divm", "]", "[", "t", "-", "divm", "]", "\n", "logprobs_table", "[", "divm", "]", ",", "state_table", "[", "divm", "]", "=", "self", ".", "get_logprobs_state", "(", "it", ".", "cuda", "(", ")", ",", "*", "(", "args", "[", "divm", "]", "+", "[", "state_table", "[", "divm", "]", "]", ")", ")", "\n", "logprobs_table", "[", "divm", "]", "=", "F", ".", "log_softmax", "(", "logprobs_table", "[", "divm", "]", "/", "temperature", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# all beams are sorted by their log-probabilities", "\n", "", "", "", "done_beams_table", "=", "[", "sorted", "(", "done_beams_table", "[", "i", "]", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "'p'", "]", ")", "[", ":", "bdash", "]", "for", "i", "in", "range", "(", "group_size", ")", "]", "\n", "done_beams", "=", "reduce", "(", "lambda", "a", ",", "b", ":", "a", "+", "b", ",", "done_beams_table", ")", "\n", "return", "done_beams", "\n", "\n", "\n", "", "def", "sample_next_word", "(", "self", ",", "logprobs", ",", "sample_method", ",", "temperature", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.sample_next_word": [[192, 230], ["torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.distributions.Categorical().sample.view().long", "torch.distributions.Categorical().sample.view().long", "torch.distributions.Categorical().sample.view().long", "CaptionModel.CaptionModel.sample_next_word.gumbel_softmax_sample"], "methods", ["None"], ["            ", "sampleLogprobs", ",", "it", "=", "torch", ".", "max", "(", "logprobs", ".", "data", ",", "1", ")", "\n", "it", "=", "it", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", "\n", "", "elif", "sample_method", "==", "'gumbel'", ":", "# gumbel softmax", "\n", "# ref: https://gist.github.com/yzh119/fd2146d2aeb329d067568a493b20172f", "\n", "            ", "def", "sample_gumbel", "(", "shape", ",", "eps", "=", "1e-20", ")", ":", "\n", "                ", "U", "=", "torch", ".", "rand", "(", "shape", ")", ".", "cuda", "(", ")", "\n", "return", "-", "torch", ".", "log", "(", "-", "torch", ".", "log", "(", "U", "+", "eps", ")", "+", "eps", ")", "\n", "", "def", "gumbel_softmax_sample", "(", "logits", ",", "temperature", ")", ":", "\n", "                ", "y", "=", "logits", "+", "sample_gumbel", "(", "logits", ".", "size", "(", ")", ")", "\n", "return", "F", ".", "log_softmax", "(", "y", "/", "temperature", ",", "dim", "=", "-", "1", ")", "\n", "", "_logprobs", "=", "gumbel_softmax_sample", "(", "logprobs", ",", "temperature", ")", "\n", "_", ",", "it", "=", "torch", ".", "max", "(", "_logprobs", ".", "data", ",", "1", ")", "\n", "sampleLogprobs", "=", "logprobs", ".", "gather", "(", "1", ",", "it", ".", "unsqueeze", "(", "1", ")", ")", "# gather the logprobs at sampled positions", "\n", "", "else", ":", "\n", "            ", "logprobs", "=", "logprobs", "/", "temperature", "\n", "if", "sample_method", ".", "startswith", "(", "'top'", ")", ":", "# topk sampling", "\n", "                ", "top_num", "=", "float", "(", "sample_method", "[", "3", ":", "]", ")", "\n", "if", "0", "<", "top_num", "<", "1", ":", "\n", "# nucleus sampling from # The Curious Case of Neural Text Degeneration", "\n", "                    ", "probs", "=", "F", ".", "softmax", "(", "logprobs", ",", "dim", "=", "1", ")", "\n", "sorted_probs", ",", "sorted_indices", "=", "torch", ".", "sort", "(", "probs", ",", "descending", "=", "True", ",", "dim", "=", "1", ")", "\n", "_cumsum", "=", "sorted_probs", ".", "cumsum", "(", "1", ")", "\n", "mask", "=", "_cumsum", "<", "top_num", "\n", "mask", "=", "torch", ".", "cat", "(", "[", "torch", ".", "ones_like", "(", "mask", "[", ":", ",", ":", "1", "]", ")", ",", "mask", "[", ":", ",", ":", "-", "1", "]", "]", ",", "1", ")", "\n", "sorted_probs", "=", "sorted_probs", "*", "mask", ".", "float", "(", ")", "\n", "sorted_probs", "=", "sorted_probs", "/", "sorted_probs", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "logprobs", ".", "scatter_", "(", "1", ",", "sorted_indices", ",", "sorted_probs", ".", "log", "(", ")", ")", "\n", "", "else", ":", "\n", "                    ", "the_k", "=", "int", "(", "top_num", ")", "\n", "tmp", "=", "torch", ".", "empty_like", "(", "logprobs", ")", ".", "fill_", "(", "float", "(", "'-inf'", ")", ")", "\n", "topk", ",", "indices", "=", "torch", ".", "topk", "(", "logprobs", ",", "the_k", ",", "dim", "=", "1", ")", "\n", "tmp", "=", "tmp", ".", "scatter", "(", "1", ",", "indices", ",", "topk", ")", "\n", "logprobs", "=", "tmp", "\n", "", "", "it", "=", "torch", ".", "distributions", ".", "Categorical", "(", "logits", "=", "logprobs", ".", "detach", "(", ")", ")", ".", "sample", "(", ")", "\n", "sampleLogprobs", "=", "logprobs", ".", "gather", "(", "1", ",", "it", ".", "unsqueeze", "(", "1", ")", ")", "# gather the logprobs at sampled positions", "\n", "", "return", "it", ",", "sampleLogprobs", "", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.__init__": [[31, 38], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "encoder", ",", "decoder", ",", "src_embed", ",", "tgt_embed", ",", "generator", ")", ":", "\n", "        ", "super", "(", "EncoderDecoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "decoder", "=", "decoder", "\n", "self", ".", "src_embed", "=", "src_embed", "\n", "self", ".", "tgt_embed", "=", "tgt_embed", "\n", "self", ".", "generator", "=", "generator", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.forward": [[39, 43], ["TransformerModel.EncoderDecoder.decode", "TransformerModel.EncoderDecoder.encode"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode"], ["", "def", "forward", "(", "self", ",", "src", ",", "tgt", ",", "src_mask", ",", "tgt_mask", ")", ":", "\n", "        ", "\"Take in and process masked src and target sequences.\"", "\n", "return", "self", ".", "decode", "(", "self", ".", "encode", "(", "src", ",", "src_mask", ")", ",", "src_mask", ",", "\n", "tgt", ",", "tgt_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode": [[44, 46], ["TransformerModel.EncoderDecoder.encoder", "TransformerModel.EncoderDecoder.src_embed"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "src", ",", "src_mask", ")", ":", "\n", "        ", "return", "self", ".", "encoder", "(", "self", ".", "src_embed", "(", "src", ")", ",", "src_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode": [[47, 49], ["TransformerModel.EncoderDecoder.decoder", "TransformerModel.EncoderDecoder.tgt_embed"], "methods", ["None"], ["", "def", "decode", "(", "self", ",", "memory", ",", "src_mask", ",", "tgt", ",", "tgt_mask", ")", ":", "\n", "        ", "return", "self", ".", "decoder", "(", "self", ".", "tgt_embed", "(", "tgt", ")", ",", "memory", ",", "src_mask", ",", "tgt_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.Generator.__init__": [[52, 55], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "d_model", ",", "vocab", ")", ":", "\n", "        ", "super", "(", "Generator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "proj", "=", "nn", ".", "Linear", "(", "d_model", ",", "vocab", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.Generator.forward": [[56, 58], ["torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "TransformerModel.Generator.proj"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "F", ".", "log_softmax", "(", "self", ".", "proj", "(", "x", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.Encoder.__init__": [[65, 69], ["torch.Module.__init__", "TransformerModel.clones", "TransformerModel.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.clones"], ["def", "__init__", "(", "self", ",", "layer", ",", "N", ")", ":", "\n", "        ", "super", "(", "Encoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "clones", "(", "layer", ",", "N", ")", "\n", "self", ".", "norm", "=", "LayerNorm", "(", "layer", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.Encoder.forward": [[70, 75], ["TransformerModel.Encoder.norm", "layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ")", ":", "\n", "        ", "\"Pass the input (and mask) through each layer in turn.\"", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ",", "mask", ")", "\n", "", "return", "self", ".", "norm", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.LayerNorm.__init__": [[78, 83], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "features", ",", "eps", "=", "1e-6", ")", ":", "\n", "        ", "super", "(", "LayerNorm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "a_2", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "features", ")", ")", "\n", "self", ".", "b_2", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "features", ")", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.LayerNorm.forward": [[84, 88], ["x.mean", "x.std"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "mean", "=", "x", ".", "mean", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "std", "=", "x", ".", "std", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "return", "self", ".", "a_2", "*", "(", "x", "-", "mean", ")", "/", "(", "std", "+", "self", ".", "eps", ")", "+", "self", ".", "b_2", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.SublayerConnection.__init__": [[94, 98], ["torch.Module.__init__", "TransformerModel.LayerNorm", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "size", ",", "dropout", ")", ":", "\n", "        ", "super", "(", "SublayerConnection", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "norm", "=", "LayerNorm", "(", "size", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.SublayerConnection.forward": [[99, 102], ["TransformerModel.SublayerConnection.dropout", "sublayer", "TransformerModel.SublayerConnection.norm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "sublayer", ")", ":", "\n", "        ", "\"Apply residual connection to any sublayer with the same size.\"", "\n", "return", "x", "+", "self", ".", "dropout", "(", "sublayer", "(", "self", ".", "norm", "(", "x", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderLayer.__init__": [[105, 111], ["torch.Module.__init__", "TransformerModel.clones", "TransformerModel.SublayerConnection"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.clones"], ["def", "__init__", "(", "self", ",", "size", ",", "self_attn", ",", "feed_forward", ",", "dropout", ")", ":", "\n", "        ", "super", "(", "EncoderLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "self_attn", "\n", "self", ".", "feed_forward", "=", "feed_forward", "\n", "self", ".", "sublayer", "=", "clones", "(", "SublayerConnection", "(", "size", ",", "dropout", ")", ",", "2", ")", "\n", "self", ".", "size", "=", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderLayer.forward": [[112, 116], ["TransformerModel.EncoderLayer.self_attn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ")", ":", "\n", "        ", "\"Follow Figure 1 (left) for connections.\"", "\n", "x", "=", "self", ".", "sublayer", "[", "0", "]", "(", "x", ",", "lambda", "x", ":", "self", ".", "self_attn", "(", "x", ",", "x", ",", "x", ",", "mask", ")", ")", "\n", "return", "self", ".", "sublayer", "[", "1", "]", "(", "x", ",", "self", ".", "feed_forward", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.Decoder.__init__": [[119, 123], ["torch.Module.__init__", "TransformerModel.clones", "TransformerModel.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.clones"], ["def", "__init__", "(", "self", ",", "layer", ",", "N", ")", ":", "\n", "        ", "super", "(", "Decoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "clones", "(", "layer", ",", "N", ")", "\n", "self", ".", "norm", "=", "LayerNorm", "(", "layer", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.Decoder.forward": [[124, 128], ["TransformerModel.Decoder.norm", "layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "memory", ",", "src_mask", ",", "tgt_mask", ")", ":", "\n", "        ", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ",", "memory", ",", "src_mask", ",", "tgt_mask", ")", "\n", "", "return", "self", ".", "norm", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.DecoderLayer.__init__": [[131, 138], ["torch.Module.__init__", "TransformerModel.clones", "TransformerModel.SublayerConnection"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.clones"], ["def", "__init__", "(", "self", ",", "size", ",", "self_attn", ",", "src_attn", ",", "feed_forward", ",", "dropout", ")", ":", "\n", "        ", "super", "(", "DecoderLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "size", "=", "size", "\n", "self", ".", "self_attn", "=", "self_attn", "\n", "self", ".", "src_attn", "=", "src_attn", "\n", "self", ".", "feed_forward", "=", "feed_forward", "\n", "self", ".", "sublayer", "=", "clones", "(", "SublayerConnection", "(", "size", ",", "dropout", ")", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.DecoderLayer.forward": [[139, 145], ["TransformerModel.DecoderLayer.self_attn", "TransformerModel.DecoderLayer.src_attn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "memory", ",", "src_mask", ",", "tgt_mask", ")", ":", "\n", "        ", "\"Follow Figure 1 (right) for connections.\"", "\n", "m", "=", "memory", "\n", "x", "=", "self", ".", "sublayer", "[", "0", "]", "(", "x", ",", "lambda", "x", ":", "self", ".", "self_attn", "(", "x", ",", "x", ",", "x", ",", "tgt_mask", ")", ")", "\n", "x", "=", "self", ".", "sublayer", "[", "1", "]", "(", "x", ",", "lambda", "x", ":", "self", ".", "src_attn", "(", "x", ",", "m", ",", "m", ",", "src_mask", ")", ")", "\n", "return", "self", ".", "sublayer", "[", "2", "]", "(", "x", ",", "self", ".", "feed_forward", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.MultiHeadedAttention.__init__": [[165, 175], ["torch.Module.__init__", "TransformerModel.clones", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.clones"], ["    ", "def", "__init__", "(", "self", ",", "h", ",", "d_model", ",", "dropout", "=", "0.1", ")", ":", "\n", "        ", "\"Take in model size and number of heads.\"", "\n", "super", "(", "MultiHeadedAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "d_model", "%", "h", "==", "0", "\n", "# We assume d_v always equals d_k", "\n", "self", ".", "d_k", "=", "d_model", "//", "h", "\n", "self", ".", "h", "=", "h", "\n", "self", ".", "linears", "=", "clones", "(", "nn", ".", "Linear", "(", "d_model", ",", "d_model", ")", ",", "4", ")", "\n", "self", ".", "attn", "=", "None", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.MultiHeadedAttention.forward": [[176, 196], ["query.size", "TransformerModel.attention", "x.transpose().contiguous().view.transpose().contiguous().view.transpose().contiguous().view", "mask.unsqueeze.unsqueeze.unsqueeze", "l().view().transpose", "zip", "x.transpose().contiguous().view.transpose().contiguous().view.transpose().contiguous", "l().view", "x.transpose().contiguous().view.transpose().contiguous().view.transpose", "l"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.attention", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "forward", "(", "self", ",", "query", ",", "key", ",", "value", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"Implements Figure 2\"", "\n", "if", "mask", "is", "not", "None", ":", "\n", "# Same mask applied to all h heads.", "\n", "            ", "mask", "=", "mask", ".", "unsqueeze", "(", "1", ")", "\n", "", "nbatches", "=", "query", ".", "size", "(", "0", ")", "\n", "\n", "# 1) Do all the linear projections in batch from d_model => h x d_k ", "\n", "query", ",", "key", ",", "value", "=", "[", "l", "(", "x", ")", ".", "view", "(", "nbatches", ",", "-", "1", ",", "self", ".", "h", ",", "self", ".", "d_k", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "for", "l", ",", "x", "in", "zip", "(", "self", ".", "linears", ",", "(", "query", ",", "key", ",", "value", ")", ")", "]", "\n", "\n", "# 2) Apply attention on all the projected vectors in batch. ", "\n", "x", ",", "self", ".", "attn", "=", "attention", "(", "query", ",", "key", ",", "value", ",", "mask", "=", "mask", ",", "\n", "dropout", "=", "self", ".", "dropout", ")", "\n", "\n", "# 3) \"Concat\" using a view and apply a final linear. ", "\n", "x", "=", "x", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "nbatches", ",", "-", "1", ",", "self", ".", "h", "*", "self", ".", "d_k", ")", "\n", "return", "self", ".", "linears", "[", "-", "1", "]", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.PositionwiseFeedForward.__init__": [[199, 204], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "d_model", ",", "d_ff", ",", "dropout", "=", "0.1", ")", ":", "\n", "        ", "super", "(", "PositionwiseFeedForward", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "w_1", "=", "nn", ".", "Linear", "(", "d_model", ",", "d_ff", ")", "\n", "self", ".", "w_2", "=", "nn", ".", "Linear", "(", "d_ff", ",", "d_model", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.PositionwiseFeedForward.forward": [[205, 207], ["TransformerModel.PositionwiseFeedForward.w_2", "TransformerModel.PositionwiseFeedForward.dropout", "torch.relu", "torch.relu", "torch.relu", "TransformerModel.PositionwiseFeedForward.w_1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "w_2", "(", "self", ".", "dropout", "(", "F", ".", "relu", "(", "self", ".", "w_1", "(", "x", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.Embeddings.__init__": [[209, 213], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "vocab", ")", ":", "\n", "        ", "super", "(", "Embeddings", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lut", "=", "nn", ".", "Embedding", "(", "vocab", ",", "d_model", ")", "\n", "self", ".", "d_model", "=", "d_model", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.Embeddings.forward": [[214, 216], ["TransformerModel.Embeddings.lut", "math.sqrt"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "lut", "(", "x", ")", "*", "math", ".", "sqrt", "(", "self", ".", "d_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.PositionalEncoding.__init__": [[219, 232], ["torch.Module.__init__", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "pe.unsqueeze.unsqueeze.unsqueeze", "TransformerModel.PositionalEncoding.register_buffer", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "math.log"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["def", "__init__", "(", "self", ",", "d_model", ",", "dropout", ",", "max_len", "=", "5000", ")", ":", "\n", "        ", "super", "(", "PositionalEncoding", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "\n", "# Compute the positional encodings once in log space.", "\n", "pe", "=", "torch", ".", "zeros", "(", "max_len", ",", "d_model", ")", "\n", "position", "=", "torch", ".", "arange", "(", "0", ",", "max_len", ")", ".", "unsqueeze", "(", "1", ")", ".", "float", "(", ")", "\n", "div_term", "=", "torch", ".", "exp", "(", "torch", ".", "arange", "(", "0", ",", "d_model", ",", "2", ")", ".", "float", "(", ")", "*", "\n", "-", "(", "math", ".", "log", "(", "10000.0", ")", "/", "d_model", ")", ")", "\n", "pe", "[", ":", ",", "0", ":", ":", "2", "]", "=", "torch", ".", "sin", "(", "position", "*", "div_term", ")", "\n", "pe", "[", ":", ",", "1", ":", ":", "2", "]", "=", "torch", ".", "cos", "(", "position", "*", "div_term", ")", "\n", "pe", "=", "pe", ".", "unsqueeze", "(", "0", ")", "\n", "self", ".", "register_buffer", "(", "'pe'", ",", "pe", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.PositionalEncoding.forward": [[233, 236], ["TransformerModel.PositionalEncoding.dropout", "x.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", "+", "self", ".", "pe", "[", ":", ",", ":", "x", ".", "size", "(", "1", ")", "]", "\n", "return", "self", ".", "dropout", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.make_model": [[239, 260], ["TransformerModel.MultiHeadedAttention", "TransformerModel.PositionwiseFeedForward", "TransformerModel.PositionalEncoding", "TransformerModel.EncoderDecoder", "EncoderDecoder.parameters", "TransformerModel.Encoder", "TransformerModel.Decoder", "torch.Sequential", "torch.Sequential", "torch.Sequential", "TransformerModel.Generator", "TransformerModel.EncoderLayer", "TransformerModel.DecoderLayer", "TransformerModel.Embeddings", "c", "p.dim", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "c", "c", "c", "c", "c"], "methods", ["None"], ["    ", "def", "make_model", "(", "self", ",", "src_vocab", ",", "tgt_vocab", ",", "N", "=", "6", ",", "\n", "d_model", "=", "512", ",", "d_ff", "=", "2048", ",", "h", "=", "8", ",", "dropout", "=", "0.1", ")", ":", "\n", "        ", "\"Helper: Construct a model from hyperparameters.\"", "\n", "c", "=", "copy", ".", "deepcopy", "\n", "attn", "=", "MultiHeadedAttention", "(", "h", ",", "d_model", ")", "\n", "ff", "=", "PositionwiseFeedForward", "(", "d_model", ",", "d_ff", ",", "dropout", ")", "\n", "position", "=", "PositionalEncoding", "(", "d_model", ",", "dropout", ")", "\n", "model", "=", "EncoderDecoder", "(", "\n", "Encoder", "(", "EncoderLayer", "(", "d_model", ",", "c", "(", "attn", ")", ",", "c", "(", "ff", ")", ",", "dropout", ")", ",", "N", ")", ",", "\n", "Decoder", "(", "DecoderLayer", "(", "d_model", ",", "c", "(", "attn", ")", ",", "c", "(", "attn", ")", ",", "\n", "c", "(", "ff", ")", ",", "dropout", ")", ",", "N", ")", ",", "\n", "lambda", "x", ":", "x", ",", "# nn.Sequential(Embeddings(d_model, src_vocab), c(position)),", "\n", "nn", ".", "Sequential", "(", "Embeddings", "(", "d_model", ",", "tgt_vocab", ")", ",", "c", "(", "position", ")", ")", ",", "\n", "Generator", "(", "d_model", ",", "tgt_vocab", ")", ")", "\n", "\n", "# This was important from their code. ", "\n", "# Initialize parameters with Glorot / fan_avg.", "\n", "for", "p", "in", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "p", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.__init__": [[261, 287], ["AttModel.AttModel.__init__", "delattr", "torch.Sequential", "torch.Sequential", "torch.Sequential", "delattr", "delattr", "delattr", "TransformerModel.TransformerModel.make_model", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.make_model"], ["", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "TransformerModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "opt", "=", "opt", "\n", "# self.config = yaml.load(open(opt.config_file))", "\n", "# d_model = self.input_encoding_size # 512", "\n", "\n", "delattr", "(", "self", ",", "'att_embed'", ")", "\n", "self", ".", "att_embed", "=", "nn", ".", "Sequential", "(", "*", "(", "\n", "(", "(", "nn", ".", "BatchNorm1d", "(", "self", ".", "att_feat_size", ")", ",", ")", "if", "self", ".", "use_bn", "else", "(", ")", ")", "+", "\n", "(", "nn", ".", "Linear", "(", "self", ".", "att_feat_size", ",", "self", ".", "input_encoding_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", ")", "+", "\n", "(", "(", "nn", ".", "BatchNorm1d", "(", "self", ".", "input_encoding_size", ")", ",", ")", "if", "self", ".", "use_bn", "==", "2", "else", "(", ")", ")", ")", ")", "\n", "\n", "delattr", "(", "self", ",", "'embed'", ")", "\n", "self", ".", "embed", "=", "lambda", "x", ":", "x", "\n", "delattr", "(", "self", ",", "'fc_embed'", ")", "\n", "self", ".", "fc_embed", "=", "lambda", "x", ":", "x", "\n", "delattr", "(", "self", ",", "'logit'", ")", "\n", "del", "self", ".", "ctx2att", "\n", "\n", "tgt_vocab", "=", "self", ".", "vocab_size", "+", "1", "\n", "self", ".", "model", "=", "self", ".", "make_model", "(", "0", ",", "tgt_vocab", ",", "\n", "N", "=", "opt", ".", "num_layers", ",", "\n", "d_model", "=", "opt", ".", "input_encoding_size", ",", "\n", "d_ff", "=", "opt", ".", "rnn_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit": [[288, 290], ["TransformerModel.TransformerModel.model.generator.proj"], "methods", ["None"], ["", "def", "logit", "(", "self", ",", "x", ")", ":", "# unsafe way", "\n", "        ", "return", "self", ".", "model", ".", "generator", ".", "proj", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.init_hidden": [[291, 293], ["None"], "methods", ["None"], ["", "def", "init_hidden", "(", "self", ",", "bsz", ")", ":", "\n", "        ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel._prepare_feature": [[294, 300], ["TransformerModel.TransformerModel._prepare_feature_forward", "TransformerModel.TransformerModel.model.encode"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel._prepare_feature_forward", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode"], ["", "def", "_prepare_feature", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", ")", ":", "\n", "\n", "        ", "att_feats", ",", "seq", ",", "att_masks", ",", "seq_mask", "=", "self", ".", "_prepare_feature_forward", "(", "att_feats", ",", "att_masks", ")", "\n", "memory", "=", "self", ".", "model", ".", "encode", "(", "att_feats", ",", "att_masks", ")", "\n", "\n", "return", "fc_feats", "[", "...", ",", ":", "1", "]", ",", "att_feats", "[", "...", ",", ":", "1", "]", ",", "memory", ",", "att_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel._prepare_feature_forward": [[301, 322], ["TransformerModel.TransformerModel.clip_att", "AttModel.AttModel.pack_wrapper", "AttModel.pack_wrapper.new_ones.unsqueeze", "AttModel.AttModel.pack_wrapper.new_ones", "seq_mask.unsqueeze.unsqueeze.unsqueeze", "subsequent_mask().to", "TransformerModel.subsequent_mask", "seq.size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel.clip_att", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.pack_wrapper", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.subsequent_mask"], ["", "def", "_prepare_feature_forward", "(", "self", ",", "att_feats", ",", "att_masks", "=", "None", ",", "seq", "=", "None", ")", ":", "\n", "        ", "att_feats", ",", "att_masks", "=", "self", ".", "clip_att", "(", "att_feats", ",", "att_masks", ")", "\n", "\n", "att_feats", "=", "pack_wrapper", "(", "self", ".", "att_embed", ",", "att_feats", ",", "att_masks", ")", "\n", "\n", "if", "att_masks", "is", "None", ":", "\n", "            ", "att_masks", "=", "att_feats", ".", "new_ones", "(", "att_feats", ".", "shape", "[", ":", "2", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "", "att_masks", "=", "att_masks", ".", "unsqueeze", "(", "-", "2", ")", "\n", "\n", "if", "seq", "is", "not", "None", ":", "\n", "# crop the last one", "\n", "            ", "seq", "=", "seq", "[", ":", ",", ":", "-", "1", "]", "\n", "seq_mask", "=", "(", "seq", ".", "data", ">", "0", ")", "\n", "seq_mask", "[", ":", ",", "0", "]", "+=", "1", "\n", "\n", "seq_mask", "=", "seq_mask", ".", "unsqueeze", "(", "-", "2", ")", "\n", "seq_mask", "=", "seq_mask", "&", "subsequent_mask", "(", "seq", ".", "size", "(", "-", "1", ")", ")", ".", "to", "(", "seq_mask", ")", "\n", "", "else", ":", "\n", "            ", "seq_mask", "=", "None", "\n", "\n", "", "return", "att_feats", ",", "seq", ",", "att_masks", ",", "seq_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel._forward": [[323, 330], ["TransformerModel.TransformerModel._prepare_feature_forward", "TransformerModel.TransformerModel.model", "TransformerModel.TransformerModel.model.generator"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel._prepare_feature_forward"], ["", "def", "_forward", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "seq", ",", "att_masks", "=", "None", ")", ":", "\n", "        ", "att_feats", ",", "seq", ",", "att_masks", ",", "seq_mask", "=", "self", ".", "_prepare_feature_forward", "(", "att_feats", ",", "att_masks", ",", "seq", ")", "\n", "\n", "out", "=", "self", ".", "model", "(", "att_feats", ",", "seq", ",", "att_masks", ",", "seq_mask", ")", "\n", "\n", "outputs", "=", "self", ".", "model", ".", "generator", "(", "out", ")", "\n", "return", "outputs", "\n", "# return torch.cat([_.unsqueeze(1) for _ in outputs], 1)", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.core": [[332, 345], ["TransformerModel.TransformerModel.model.decode", "len", "it.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "subsequent_mask().to", "torch.cat.unsqueeze", "torch.cat.unsqueeze", "torch.cat.unsqueeze", "it.unsqueeze", "TransformerModel.subsequent_mask", "torch.cat.size", "torch.cat.size", "torch.cat.size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.subsequent_mask"], ["", "def", "core", "(", "self", ",", "it", ",", "fc_feats_ph", ",", "att_feats_ph", ",", "memory", ",", "state", ",", "mask", ")", ":", "\n", "        ", "\"\"\"\n        state = [ys.unsqueeze(0)]\n        \"\"\"", "\n", "if", "len", "(", "state", ")", "==", "0", ":", "\n", "            ", "ys", "=", "it", ".", "unsqueeze", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "ys", "=", "torch", ".", "cat", "(", "[", "state", "[", "0", "]", "[", "0", "]", ",", "it", ".", "unsqueeze", "(", "1", ")", "]", ",", "dim", "=", "1", ")", "\n", "", "out", "=", "self", ".", "model", ".", "decode", "(", "memory", ",", "mask", ",", "\n", "ys", ",", "\n", "subsequent_mask", "(", "ys", ".", "size", "(", "1", ")", ")", "\n", ".", "to", "(", "memory", ".", "device", ")", ")", "\n", "return", "out", "[", ":", ",", "-", "1", "]", ",", "[", "ys", ".", "unsqueeze", "(", "0", ")", "]", "", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.clones": [[59, 62], ["torch.ModuleList", "copy.deepcopy", "range"], "function", ["None"], ["", "", "def", "clones", "(", "module", ",", "N", ")", ":", "\n", "    ", "\"Produce N identical layers.\"", "\n", "return", "nn", ".", "ModuleList", "(", "[", "copy", ".", "deepcopy", "(", "module", ")", "for", "_", "in", "range", "(", "N", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.subsequent_mask": [[146, 151], ["numpy.triu().astype", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.triu", "numpy.ones"], "function", ["None"], ["", "", "def", "subsequent_mask", "(", "size", ")", ":", "\n", "    ", "\"Mask out subsequent positions.\"", "\n", "attn_shape", "=", "(", "1", ",", "size", ",", "size", ")", "\n", "subsequent_mask", "=", "np", ".", "triu", "(", "np", ".", "ones", "(", "attn_shape", ")", ",", "k", "=", "1", ")", ".", "astype", "(", "'uint8'", ")", "\n", "return", "torch", ".", "from_numpy", "(", "subsequent_mask", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.attention": [[152, 163], ["query.size", "torch.softmax", "torch.matmul", "torch.matmul", "torch.matmul", "math.sqrt", "scores.masked_fill.masked_fill", "dropout", "torch.matmul", "torch.matmul", "torch.matmul", "key.transpose"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "attention", "(", "query", ",", "key", ",", "value", ",", "mask", "=", "None", ",", "dropout", "=", "None", ")", ":", "\n", "    ", "\"Compute 'Scaled Dot Product Attention'\"", "\n", "d_k", "=", "query", ".", "size", "(", "-", "1", ")", "\n", "scores", "=", "torch", ".", "matmul", "(", "query", ",", "key", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ")", "/", "math", ".", "sqrt", "(", "d_k", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "        ", "scores", "=", "scores", ".", "masked_fill", "(", "mask", "==", "0", ",", "-", "1e9", ")", "\n", "", "p_attn", "=", "F", ".", "softmax", "(", "scores", ",", "dim", "=", "-", "1", ")", "\n", "if", "dropout", "is", "not", "None", ":", "\n", "        ", "p_attn", "=", "dropout", "(", "p_attn", ")", "\n", "", "return", "torch", ".", "matmul", "(", "p_attn", ",", "value", ")", ",", "p_attn", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.ShowTellModel.ShowTellModel.__init__": [[14, 34], ["CaptionModel.CaptionModel.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "ShowTellModel.ShowTellModel.init_weights", "getattr", "ShowTellModel.ShowTellModel.rnn_type.upper"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_weights"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "ShowTellModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "vocab_size", "=", "opt", ".", "vocab_size", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "self", ".", "rnn_type", "=", "opt", ".", "rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "num_layers", "=", "opt", ".", "num_layers", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "seq_length", "=", "opt", ".", "seq_length", "\n", "self", ".", "fc_feat_size", "=", "opt", ".", "fc_feat_size", "\n", "\n", "self", ".", "ss_prob", "=", "0.0", "# Schedule sampling probability", "\n", "\n", "self", ".", "img_embed", "=", "nn", ".", "Linear", "(", "self", ".", "fc_feat_size", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "core", "=", "getattr", "(", "nn", ",", "self", ".", "rnn_type", ".", "upper", "(", ")", ")", "(", "self", ".", "input_encoding_size", ",", "self", ".", "rnn_size", ",", "self", ".", "num_layers", ",", "bias", "=", "False", ",", "dropout", "=", "self", ".", "drop_prob_lm", ")", "\n", "self", ".", "embed", "=", "nn", ".", "Embedding", "(", "self", ".", "vocab_size", "+", "1", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "logit", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "vocab_size", "+", "1", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", "\n", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.ShowTellModel.ShowTellModel.init_weights": [[35, 40], ["ShowTellModel.ShowTellModel.embed.weight.data.uniform_", "ShowTellModel.ShowTellModel.logit.bias.data.fill_", "ShowTellModel.ShowTellModel.logit.weight.data.uniform_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "initrange", "=", "0.1", "\n", "self", ".", "embed", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "initrange", ",", "initrange", ")", "\n", "self", ".", "logit", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "logit", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "initrange", ",", "initrange", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.ShowTellModel.ShowTellModel.init_hidden": [[41, 48], ["next", "weight.new_zeros", "ShowTellModel.ShowTellModel.parameters", "weight.new_zeros", "weight.new_zeros"], "methods", ["None"], ["", "def", "init_hidden", "(", "self", ",", "bsz", ")", ":", "\n", "        ", "weight", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "data", "\n", "if", "self", ".", "rnn_type", "==", "'lstm'", ":", "\n", "            ", "return", "(", "weight", ".", "new_zeros", "(", "self", ".", "num_layers", ",", "bsz", ",", "self", ".", "rnn_size", ")", ",", "\n", "weight", ".", "new_zeros", "(", "self", ".", "num_layers", ",", "bsz", ",", "self", ".", "rnn_size", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "weight", ".", "new_zeros", "(", "self", ".", "num_layers", ",", "bsz", ",", "self", ".", "rnn_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.ShowTellModel.ShowTellModel._forward": [[49, 82], ["fc_feats.size", "ShowTellModel.ShowTellModel.init_hidden", "range", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "seq.size", "ShowTellModel.ShowTellModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "outputs.append", "ShowTellModel.ShowTellModel.img_embed", "ShowTellModel.ShowTellModel.embed", "ShowTellModel.ShowTellModel.unsqueeze", "ShowTellModel.ShowTellModel.logit", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "fc_feats.data.new().uniform_", "seq[].clone", "ShowTellModel.ShowTellModel.dropout", "sample_mask.sum", "seq[].clone", "sample_mask.nonzero().view", "seq[].data.clone", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "seq[].data.clone.index_copy_", "seq[].data.sum", "torch.log_softmax.squeeze", "_.unsqueeze", "fc_feats.data.new", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "sample_mask.nonzero", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "", "def", "_forward", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "seq", ",", "att_masks", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "state", "=", "self", ".", "init_hidden", "(", "batch_size", ")", "\n", "outputs", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "seq", ".", "size", "(", "1", ")", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "xt", "=", "self", ".", "img_embed", "(", "fc_feats", ")", "\n", "", "else", ":", "\n", "                ", "if", "self", ".", "training", "and", "i", ">=", "2", "and", "self", ".", "ss_prob", ">", "0.0", ":", "# otherwiste no need to sample", "\n", "                    ", "sample_prob", "=", "fc_feats", ".", "data", ".", "new", "(", "batch_size", ")", ".", "uniform_", "(", "0", ",", "1", ")", "\n", "sample_mask", "=", "sample_prob", "<", "self", ".", "ss_prob", "\n", "if", "sample_mask", ".", "sum", "(", ")", "==", "0", ":", "\n", "                        ", "it", "=", "seq", "[", ":", ",", "i", "-", "1", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                        ", "sample_ind", "=", "sample_mask", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "it", "=", "seq", "[", ":", ",", "i", "-", "1", "]", ".", "data", ".", "clone", "(", ")", "\n", "#prob_prev = torch.exp(outputs[-1].data.index_select(0, sample_ind)) # fetch prev distribution: shape Nx(M+1)", "\n", "#it.index_copy_(0, sample_ind, torch.multinomial(prob_prev, 1).view(-1))", "\n", "prob_prev", "=", "torch", ".", "exp", "(", "outputs", "[", "-", "1", "]", ".", "data", ")", "# fetch prev distribution: shape Nx(M+1)", "\n", "it", ".", "index_copy_", "(", "0", ",", "sample_ind", ",", "torch", ".", "multinomial", "(", "prob_prev", ",", "1", ")", ".", "view", "(", "-", "1", ")", ".", "index_select", "(", "0", ",", "sample_ind", ")", ")", "\n", "", "", "else", ":", "\n", "                    ", "it", "=", "seq", "[", ":", ",", "i", "-", "1", "]", ".", "clone", "(", ")", "\n", "# break if all the sequences end", "\n", "", "if", "i", ">=", "2", "and", "seq", "[", ":", ",", "i", "-", "1", "]", ".", "data", ".", "sum", "(", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ".", "unsqueeze", "(", "0", ")", ",", "state", ")", "\n", "output", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "self", ".", "dropout", "(", "output", ".", "squeeze", "(", "0", ")", ")", ")", ",", "dim", "=", "1", ")", "\n", "outputs", ".", "append", "(", "output", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "[", "_", ".", "unsqueeze", "(", "1", ")", "for", "_", "in", "outputs", "[", "1", ":", "]", "]", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.ShowTellModel.ShowTellModel.get_logprobs_state": [[83, 91], ["ShowTellModel.ShowTellModel.embed", "ShowTellModel.ShowTellModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "ShowTellModel.ShowTellModel.unsqueeze", "ShowTellModel.ShowTellModel.logit", "ShowTellModel.ShowTellModel.dropout", "output.squeeze"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "def", "get_logprobs_state", "(", "self", ",", "it", ",", "state", ")", ":", "\n", "# 'it' contains a word index", "\n", "        ", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ".", "unsqueeze", "(", "0", ")", ",", "state", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "self", ".", "dropout", "(", "output", ".", "squeeze", "(", "0", ")", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "logprobs", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.ShowTellModel.ShowTellModel._sample_beam": [[92, 119], ["opt.get", "fc_feats.size", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "range", "ShowTellModel.ShowTellModel.init_hidden", "range", "ShowTellModel.ShowTellModel.beam_search", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "range", "ShowTellModel.ShowTellModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "ShowTellModel.ShowTellModel.img_embed().expand", "ShowTellModel.ShowTellModel.unsqueeze", "ShowTellModel.ShowTellModel.logit", "fc_feats.data.new().long().zero_", "ShowTellModel.ShowTellModel.embed", "ShowTellModel.ShowTellModel.dropout", "ShowTellModel.ShowTellModel.img_embed", "output.squeeze", "fc_feats.data.new().long", "fc_feats.data.new"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.beam_search", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed"], ["", "def", "_sample_beam", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", "=", "None", ",", "opt", "=", "{", "}", ")", ":", "\n", "        ", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "10", ")", "\n", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "\n", "assert", "beam_size", "<=", "self", ".", "vocab_size", "+", "1", ",", "'lets assume this for now, otherwise this corner case causes a few headaches down the road. can be dealt with in future if needed'", "\n", "seq", "=", "torch", ".", "LongTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", ".", "zero_", "(", ")", "\n", "seqLogprobs", "=", "torch", ".", "FloatTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", "\n", "# lets process every image independently for now, for simplicity", "\n", "\n", "self", ".", "done_beams", "=", "[", "[", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "state", "=", "self", ".", "init_hidden", "(", "beam_size", ")", "\n", "for", "t", "in", "range", "(", "2", ")", ":", "\n", "                ", "if", "t", "==", "0", ":", "\n", "                    ", "xt", "=", "self", ".", "img_embed", "(", "fc_feats", "[", "k", ":", "k", "+", "1", "]", ")", ".", "expand", "(", "beam_size", ",", "self", ".", "input_encoding_size", ")", "\n", "", "elif", "t", "==", "1", ":", "# input <bos>", "\n", "                    ", "it", "=", "fc_feats", ".", "data", ".", "new", "(", "beam_size", ")", ".", "long", "(", ")", ".", "zero_", "(", ")", "\n", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ".", "unsqueeze", "(", "0", ")", ",", "state", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "self", ".", "dropout", "(", "output", ".", "squeeze", "(", "0", ")", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "self", ".", "done_beams", "[", "k", "]", "=", "self", ".", "beam_search", "(", "state", ",", "logprobs", ",", "opt", "=", "opt", ")", "\n", "seq", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'seq'", "]", "# the first beam has highest cumulative score", "\n", "seqLogprobs", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'logps'", "]", "\n", "# return the samples and their log likelihoods", "\n", "", "return", "seq", ".", "transpose", "(", "0", ",", "1", ")", ",", "seqLogprobs", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.ShowTellModel.ShowTellModel._sample": [[120, 171], ["opt.get", "opt.get", "opt.get", "fc_feats.size", "ShowTellModel.ShowTellModel.init_hidden", "fc_feats.new_zeros", "fc_feats.new_zeros", "range", "ShowTellModel.ShowTellModel.sample_beam", "ShowTellModel.ShowTellModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "ShowTellModel.ShowTellModel.img_embed", "ShowTellModel.ShowTellModel.embed", "ShowTellModel.ShowTellModel.unsqueeze", "ShowTellModel.ShowTellModel.logit", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "fc_feats.data.new().long().zero_.view().long", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.log_softmax.gather", "fc_feats.data.new().long().zero_.view().long", "F.log_softmax.gather.view", "fc_feats.data.new().long().zero_", "ShowTellModel.ShowTellModel.dropout", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "unfinished.type_as", "unfinished.sum", "output.squeeze", "fc_feats.data.new().long().zero_.view", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "fc_feats.data.new().long().zero_.view", "fc_feats.data.new().long", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "fc_feats.data.new"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.OldModel.sample_beam", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "def", "_sample", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", "=", "None", ",", "opt", "=", "{", "}", ")", ":", "\n", "        ", "sample_method", "=", "opt", ".", "get", "(", "'sample_method'", ",", "'greedy'", ")", "\n", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "1", ")", "\n", "temperature", "=", "opt", ".", "get", "(", "'temperature'", ",", "1.0", ")", "\n", "if", "beam_size", ">", "1", ":", "\n", "            ", "return", "self", ".", "sample_beam", "(", "fc_feats", ",", "att_feats", ",", "opt", ")", "\n", "\n", "", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "state", "=", "self", ".", "init_hidden", "(", "batch_size", ")", "\n", "seq", "=", "fc_feats", ".", "new_zeros", "(", "batch_size", ",", "self", ".", "seq_length", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "seqLogprobs", "=", "fc_feats", ".", "new_zeros", "(", "batch_size", ",", "self", ".", "seq_length", ")", "\n", "for", "t", "in", "range", "(", "self", ".", "seq_length", "+", "2", ")", ":", "\n", "            ", "if", "t", "==", "0", ":", "\n", "                ", "xt", "=", "self", ".", "img_embed", "(", "fc_feats", ")", "\n", "", "else", ":", "\n", "                ", "if", "t", "==", "1", ":", "# input <bos>", "\n", "                    ", "it", "=", "fc_feats", ".", "data", ".", "new", "(", "batch_size", ")", ".", "long", "(", ")", ".", "zero_", "(", ")", "\n", "", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ".", "unsqueeze", "(", "0", ")", ",", "state", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "self", ".", "dropout", "(", "output", ".", "squeeze", "(", "0", ")", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "# sample the next word", "\n", "if", "t", "==", "self", ".", "seq_length", "+", "1", ":", "# skip if we achieve maximum length", "\n", "                ", "break", "\n", "", "if", "sample_method", "==", "'greedy'", ":", "\n", "                ", "sampleLogprobs", ",", "it", "=", "torch", ".", "max", "(", "logprobs", ".", "data", ",", "1", ")", "\n", "it", "=", "it", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", "\n", "", "else", ":", "\n", "                ", "if", "temperature", "==", "1.0", ":", "\n", "                    ", "prob_prev", "=", "torch", ".", "exp", "(", "logprobs", ".", "data", ")", ".", "cpu", "(", ")", "# fetch prev distribution: shape Nx(M+1)", "\n", "", "else", ":", "\n", "# scale logprobs by temperature", "\n", "                    ", "prob_prev", "=", "torch", ".", "exp", "(", "torch", ".", "div", "(", "logprobs", ".", "data", ",", "temperature", ")", ")", ".", "cpu", "(", ")", "\n", "", "it", "=", "torch", ".", "multinomial", "(", "prob_prev", ",", "1", ")", ".", "cuda", "(", ")", "\n", "sampleLogprobs", "=", "logprobs", ".", "gather", "(", "1", ",", "it", ")", "# gather the logprobs at sampled positions", "\n", "it", "=", "it", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", "# and flatten indices for downstream processing", "\n", "\n", "", "if", "t", ">=", "1", ":", "\n", "# stop when all finished", "\n", "                ", "if", "t", "==", "1", ":", "\n", "                    ", "unfinished", "=", "it", ">", "0", "\n", "", "else", ":", "\n", "                    ", "unfinished", "=", "unfinished", "*", "(", "it", ">", "0", ")", "\n", "", "it", "=", "it", "*", "unfinished", ".", "type_as", "(", "it", ")", "\n", "seq", "[", ":", ",", "t", "-", "1", "]", "=", "it", "#seq[t] the input of t+2 time step", "\n", "seqLogprobs", "[", ":", ",", "t", "-", "1", "]", "=", "sampleLogprobs", ".", "view", "(", "-", "1", ")", "\n", "if", "unfinished", ".", "sum", "(", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "\n", "", "", "", "return", "seq", ",", "seqLogprobs", "", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.__init__": [[30, 41], ["CaptionModel.CaptionModel.CaptionModel.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "AttEnsemble.AttEnsemble.register_buffer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "models", ",", "weights", "=", "None", ")", ":", "\n", "        ", "CaptionModel", ".", "__init__", "(", "self", ")", "\n", "# super(AttEnsemble, self).__init__()", "\n", "\n", "self", ".", "models", "=", "nn", ".", "ModuleList", "(", "models", ")", "\n", "self", ".", "vocab_size", "=", "models", "[", "0", "]", ".", "vocab_size", "\n", "self", ".", "seq_length", "=", "models", "[", "0", "]", ".", "seq_length", "\n", "self", ".", "bad_endings_ix", "=", "models", "[", "0", "]", ".", "bad_endings_ix", "\n", "self", ".", "ss_prob", "=", "0", "\n", "weights", "=", "weights", "or", "[", "1.0", "]", "*", "len", "(", "self", ".", "models", ")", "\n", "self", ".", "register_buffer", "(", "'weights'", ",", "torch", ".", "tensor", "(", "weights", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.init_hidden": [[42, 45], ["AttEnsemble.AttEnsemble.pack_state", "m.init_hidden"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.pack_state", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden"], ["", "def", "init_hidden", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "state", "=", "[", "m", ".", "init_hidden", "(", "batch_size", ")", "for", "m", "in", "self", ".", "models", "]", "\n", "return", "self", ".", "pack_state", "(", "state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.pack_state": [[46, 49], ["sum", "len", "list"], "methods", ["None"], ["", "def", "pack_state", "(", "self", ",", "state", ")", ":", "\n", "        ", "self", ".", "state_lengths", "=", "[", "len", "(", "_", ")", "for", "_", "in", "state", "]", "\n", "return", "sum", "(", "[", "list", "(", "_", ")", "for", "_", "in", "state", "]", ",", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.unpack_state": [[50, 56], ["out.append"], "methods", ["None"], ["", "def", "unpack_state", "(", "self", ",", "state", ")", ":", "\n", "        ", "out", "=", "[", "]", "\n", "for", "l", "in", "self", ".", "state_lengths", ":", "\n", "            ", "out", ".", "append", "(", "state", "[", ":", "l", "]", ")", "\n", "state", "=", "state", "[", "l", ":", "]", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed": [[57, 59], ["m.embed"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed"], ["", "def", "embed", "(", "self", ",", "it", ")", ":", "\n", "        ", "return", "[", "m", ".", "embed", "(", "it", ")", "for", "m", "in", "self", ".", "models", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core": [[60, 62], ["zip", "m.core", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core"], ["", "def", "core", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "return", "zip", "(", "*", "[", "m", ".", "core", "(", "*", "_", ")", "for", "m", ",", "_", "in", "zip", "(", "self", ".", "models", ",", "zip", "(", "*", "args", ")", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.get_logprobs_state": [[63, 72], ["AttEnsemble.AttEnsemble.embed", "AttEnsemble.AttEnsemble.unpack_state", "AttEnsemble.AttEnsemble.core", "torch.stack().mul().div().sum().log", "torch.stack().mul().div().sum().log", "torch.stack().mul().div().sum().log", "torch.stack().mul().div().sum().log", "torch.stack().mul().div().sum().log", "torch.stack().mul().div().sum().log", "torch.stack().mul().div().sum().log", "torch.stack().mul().div().sum().log", "torch.stack().mul().div().sum().log", "AttEnsemble.AttEnsemble.pack_state", "torch.stack().mul().div().sum", "torch.stack().mul().div().sum", "torch.stack().mul().div().sum", "torch.stack().mul().div().sum", "torch.stack().mul().div().sum", "torch.stack().mul().div().sum", "torch.stack().mul().div().sum", "torch.stack().mul().div().sum", "torch.stack().mul().div().sum", "torch.stack().mul().div", "torch.stack().mul().div", "torch.stack().mul().div", "torch.stack().mul().div", "torch.stack().mul().div", "torch.stack().mul().div", "torch.stack().mul().div", "torch.stack().mul().div", "torch.stack().mul().div", "AttEnsemble.AttEnsemble.weights.sum", "torch.stack().mul", "torch.stack().mul", "torch.stack().mul", "torch.stack().mul", "torch.stack().mul", "torch.stack().mul", "torch.stack().mul", "torch.stack().mul", "torch.stack().mul", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.softmax", "torch.softmax", "torch.softmax", "m.logit", "enumerate"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.unpack_state", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.pack_state", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "def", "get_logprobs_state", "(", "self", ",", "it", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "tmp_p_att_feats", ",", "tmp_att_masks", ",", "state", ")", ":", "\n", "# 'it' contains a word index", "\n", "        ", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "state", "=", "self", ".", "unpack_state", "(", "state", ")", "\n", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "tmp_p_att_feats", ",", "state", ",", "tmp_att_masks", ")", "\n", "logprobs", "=", "torch", ".", "stack", "(", "[", "F", ".", "softmax", "(", "m", ".", "logit", "(", "output", "[", "i", "]", ")", ",", "dim", "=", "1", ")", "for", "i", ",", "m", "in", "enumerate", "(", "self", ".", "models", ")", "]", ",", "2", ")", ".", "mul", "(", "self", ".", "weights", ")", ".", "div", "(", "self", ".", "weights", ".", "sum", "(", ")", ")", ".", "sum", "(", "-", "1", ")", ".", "log", "(", ")", "\n", "\n", "return", "logprobs", ",", "self", ".", "pack_state", "(", "state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble._prepare_feature": [[73, 75], ["tuple", "zip", "m._prepare_feature"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoAModel._prepare_feature"], ["", "def", "_prepare_feature", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "return", "tuple", "(", "zip", "(", "*", "[", "m", ".", "_prepare_feature", "(", "*", "args", ")", "for", "m", "in", "self", ".", "models", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble._sample_beam": [[89, 116], ["opt.get", "fc_feats.size", "AttEnsemble.AttEnsemble._prepare_feature", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "range", "AttEnsemble.AttEnsemble.init_hidden", "fc_feats[].data.new().long().zero_", "AttEnsemble.AttEnsemble.get_logprobs_state", "AttEnsemble.AttEnsemble.beam_search", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "range", "[].expand", "[].expand().contiguous", "[].expand().contiguous", "fc_feats[].size", "enumerate", "enumerate", "enumerate", "[].expand().contiguous", "enumerate", "fc_feats[].data.new().long", "[].expand", "[].expand", "[].expand", "fc_feats[].data.new", "att_feats[].size", "p_att_feats[].size", "att_masks[].size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoAModel._prepare_feature", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.get_logprobs_state", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.beam_search", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "_sample_beam", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", "=", "None", ",", "opt", "=", "{", "}", ")", ":", "\n", "        ", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "10", ")", "\n", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "\n", "fc_feats", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", "=", "self", ".", "_prepare_feature", "(", "fc_feats", ",", "att_feats", ",", "att_masks", ")", "\n", "\n", "assert", "beam_size", "<=", "self", ".", "vocab_size", "+", "1", ",", "'lets assume this for now, otherwise this corner case causes a few headaches down the road. can be dealt with in future if needed'", "\n", "seq", "=", "torch", ".", "LongTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", ".", "zero_", "(", ")", "\n", "seqLogprobs", "=", "torch", ".", "FloatTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", "\n", "# lets process every image independently for now, for simplicity", "\n", "\n", "self", ".", "done_beams", "=", "[", "[", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "state", "=", "self", ".", "init_hidden", "(", "beam_size", ")", "\n", "tmp_fc_feats", "=", "[", "fc_feats", "[", "i", "]", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "beam_size", ",", "fc_feats", "[", "i", "]", ".", "size", "(", "1", ")", ")", "for", "i", ",", "m", "in", "enumerate", "(", "self", ".", "models", ")", "]", "\n", "tmp_att_feats", "=", "[", "att_feats", "[", "i", "]", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "*", "(", "(", "beam_size", ",", ")", "+", "att_feats", "[", "i", "]", ".", "size", "(", ")", "[", "1", ":", "]", ")", ")", ".", "contiguous", "(", ")", "for", "i", ",", "m", "in", "enumerate", "(", "self", ".", "models", ")", "]", "\n", "tmp_p_att_feats", "=", "[", "p_att_feats", "[", "i", "]", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "*", "(", "(", "beam_size", ",", ")", "+", "p_att_feats", "[", "i", "]", ".", "size", "(", ")", "[", "1", ":", "]", ")", ")", ".", "contiguous", "(", ")", "for", "i", ",", "m", "in", "enumerate", "(", "self", ".", "models", ")", "]", "\n", "tmp_att_masks", "=", "[", "att_masks", "[", "i", "]", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "*", "(", "(", "beam_size", ",", ")", "+", "att_masks", "[", "i", "]", ".", "size", "(", ")", "[", "1", ":", "]", ")", ")", ".", "contiguous", "(", ")", "if", "att_masks", "[", "i", "]", "is", "not", "None", "else", "att_masks", "[", "i", "]", "for", "i", ",", "m", "in", "enumerate", "(", "self", ".", "models", ")", "]", "\n", "\n", "it", "=", "fc_feats", "[", "0", "]", ".", "data", ".", "new", "(", "beam_size", ")", ".", "long", "(", ")", ".", "zero_", "(", ")", "\n", "logprobs", ",", "state", "=", "self", ".", "get_logprobs_state", "(", "it", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "tmp_p_att_feats", ",", "tmp_att_masks", ",", "state", ")", "\n", "\n", "self", ".", "done_beams", "[", "k", "]", "=", "self", ".", "beam_search", "(", "state", ",", "logprobs", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "tmp_p_att_feats", ",", "tmp_att_masks", ",", "opt", "=", "opt", ")", "\n", "seq", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'seq'", "]", "# the first beam has highest cumulative score", "\n", "seqLogprobs", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'logps'", "]", "\n", "# return the samples and their log likelihoods", "\n", "", "return", "seq", ".", "transpose", "(", "0", ",", "1", ")", ",", "seqLogprobs", ".", "transpose", "(", "0", ",", "1", ")", "\n", "# return the samples and their log likelihoods", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.OldModel.__init__": [[21, 41], ["CaptionModel.CaptionModel.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "OldModel.OldModel.init_weights"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_weights"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "OldModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "vocab_size", "=", "opt", ".", "vocab_size", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "self", ".", "rnn_type", "=", "opt", ".", "rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "num_layers", "=", "opt", ".", "num_layers", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "seq_length", "=", "opt", ".", "seq_length", "\n", "self", ".", "fc_feat_size", "=", "opt", ".", "fc_feat_size", "\n", "self", ".", "att_feat_size", "=", "opt", ".", "att_feat_size", "\n", "\n", "self", ".", "ss_prob", "=", "0.0", "# Schedule sampling probability", "\n", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "self", ".", "fc_feat_size", ",", "self", ".", "num_layers", "*", "self", ".", "rnn_size", ")", "# feature to rnn_size", "\n", "self", ".", "embed", "=", "nn", ".", "Embedding", "(", "self", ".", "vocab_size", "+", "1", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "logit", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "vocab_size", "+", "1", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", "\n", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.OldModel.init_weights": [[42, 47], ["OldModel.OldModel.embed.weight.data.uniform_", "OldModel.OldModel.logit.bias.data.fill_", "OldModel.OldModel.logit.weight.data.uniform_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "initrange", "=", "0.1", "\n", "self", ".", "embed", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "initrange", ",", "initrange", ")", "\n", "self", ".", "logit", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "logit", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "initrange", ",", "initrange", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.OldModel.init_hidden": [[48, 54], ["OldModel.OldModel.linear().view().transpose", "OldModel.OldModel.linear().view", "OldModel.OldModel.linear"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "init_hidden", "(", "self", ",", "fc_feats", ")", ":", "\n", "        ", "image_map", "=", "self", ".", "linear", "(", "fc_feats", ")", ".", "view", "(", "-", "1", ",", "self", ".", "num_layers", ",", "self", ".", "rnn_size", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "if", "self", ".", "rnn_type", "==", "'lstm'", ":", "\n", "            ", "return", "(", "image_map", ",", "image_map", ")", "\n", "", "else", ":", "\n", "            ", "return", "image_map", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.OldModel.forward": [[55, 87], ["fc_feats.size", "OldModel.OldModel.init_hidden", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "OldModel.OldModel.embed", "OldModel.OldModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "outputs.append", "seq.size", "fc_feats.data.new().uniform_", "seq[].clone", "OldModel.OldModel.logit", "_.unsqueeze", "sample_mask.sum", "seq[].clone", "sample_mask.nonzero().view", "seq[].data.clone", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "seq[].data.clone.index_copy_", "seq[].sum", "OldModel.OldModel.dropout", "fc_feats.data.new", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "sample_mask.nonzero", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "", "def", "forward", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "seq", ")", ":", "\n", "        ", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "state", "=", "self", ".", "init_hidden", "(", "fc_feats", ")", "\n", "\n", "outputs", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "seq", ".", "size", "(", "1", ")", "-", "1", ")", ":", "\n", "            ", "if", "self", ".", "training", "and", "i", ">=", "1", "and", "self", ".", "ss_prob", ">", "0.0", ":", "# otherwiste no need to sample", "\n", "                ", "sample_prob", "=", "fc_feats", ".", "data", ".", "new", "(", "batch_size", ")", ".", "uniform_", "(", "0", ",", "1", ")", "\n", "sample_mask", "=", "sample_prob", "<", "self", ".", "ss_prob", "\n", "if", "sample_mask", ".", "sum", "(", ")", "==", "0", ":", "\n", "                    ", "it", "=", "seq", "[", ":", ",", "i", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                    ", "sample_ind", "=", "sample_mask", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "it", "=", "seq", "[", ":", ",", "i", "]", ".", "data", ".", "clone", "(", ")", "\n", "#prob_prev = torch.exp(outputs[-1].data.index_select(0, sample_ind)) # fetch prev distribution: shape Nx(M+1)", "\n", "#it.index_copy_(0, sample_ind, torch.multinomial(prob_prev, 1).view(-1))", "\n", "prob_prev", "=", "torch", ".", "exp", "(", "outputs", "[", "-", "1", "]", ".", "data", ")", "# fetch prev distribution: shape Nx(M+1)", "\n", "it", ".", "index_copy_", "(", "0", ",", "sample_ind", ",", "torch", ".", "multinomial", "(", "prob_prev", ",", "1", ")", ".", "view", "(", "-", "1", ")", ".", "index_select", "(", "0", ",", "sample_ind", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "it", "=", "seq", "[", ":", ",", "i", "]", ".", "clone", "(", ")", "\n", "# break if all the sequences end", "\n", "", "if", "i", ">=", "1", "and", "seq", "[", ":", ",", "i", "]", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "break", "\n", "\n", "", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "fc_feats", ",", "att_feats", ",", "state", ")", "\n", "output", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "self", ".", "dropout", "(", "output", ")", ")", ",", "dim", "=", "1", ")", "\n", "outputs", ".", "append", "(", "output", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "[", "_", ".", "unsqueeze", "(", "1", ")", "for", "_", "in", "outputs", "]", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.OldModel.get_logprobs_state": [[88, 96], ["OldModel.OldModel.embed", "OldModel.OldModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "OldModel.OldModel.logit", "OldModel.OldModel.dropout"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "def", "get_logprobs_state", "(", "self", ",", "it", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "state", ")", ":", "\n", "# 'it' contains a word index", "\n", "        ", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "state", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "self", ".", "dropout", "(", "output", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "logprobs", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.OldModel.sample_beam": [[97, 130], ["opt.get", "fc_feats.size", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "range", "fc_feats[].expand", "att_feats[].expand().contiguous", "OldModel.OldModel.init_hidden", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "OldModel.OldModel.beam_search", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "range", "OldModel.OldModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "att_feats[].expand", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "fc_feats.data.new().long().zero_", "OldModel.OldModel.embed", "OldModel.OldModel.logit", "OldModel.OldModel.dropout", "fc_feats.data.new().long", "att_feats.size", "fc_feats.data.new"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.beam_search", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "def", "sample_beam", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "opt", "=", "{", "}", ")", ":", "\n", "        ", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "10", ")", "\n", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "\n", "assert", "beam_size", "<=", "self", ".", "vocab_size", "+", "1", ",", "'lets assume this for now, otherwise this corner case causes a few headaches down the road. can be dealt with in future if needed'", "\n", "seq", "=", "torch", ".", "LongTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", ".", "zero_", "(", ")", "\n", "seqLogprobs", "=", "torch", ".", "FloatTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", "\n", "# lets process every image independently for now, for simplicity", "\n", "\n", "self", ".", "done_beams", "=", "[", "[", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "tmp_fc_feats", "=", "fc_feats", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "beam_size", ",", "self", ".", "fc_feat_size", ")", "\n", "tmp_att_feats", "=", "att_feats", "[", "k", ":", "k", "+", "1", "]", ".", "expand", "(", "*", "(", "(", "beam_size", ",", ")", "+", "att_feats", ".", "size", "(", ")", "[", "1", ":", "]", ")", ")", ".", "contiguous", "(", ")", "\n", "\n", "state", "=", "self", ".", "init_hidden", "(", "tmp_fc_feats", ")", "\n", "\n", "beam_seq", "=", "torch", ".", "LongTensor", "(", "self", ".", "seq_length", ",", "beam_size", ")", ".", "zero_", "(", ")", "\n", "beam_seq_logprobs", "=", "torch", ".", "FloatTensor", "(", "self", ".", "seq_length", ",", "beam_size", ")", ".", "zero_", "(", ")", "\n", "beam_logprobs_sum", "=", "torch", ".", "zeros", "(", "beam_size", ")", "# running sum of logprobs for each beam", "\n", "done_beams", "=", "[", "]", "\n", "for", "t", "in", "range", "(", "1", ")", ":", "\n", "                ", "if", "t", "==", "0", ":", "# input <bos>", "\n", "                    ", "it", "=", "fc_feats", ".", "data", ".", "new", "(", "beam_size", ")", ".", "long", "(", ")", ".", "zero_", "(", ")", "\n", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "state", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "self", ".", "dropout", "(", "output", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "self", ".", "done_beams", "[", "k", "]", "=", "self", ".", "beam_search", "(", "state", ",", "logprobs", ",", "tmp_fc_feats", ",", "tmp_att_feats", ",", "opt", "=", "opt", ")", "\n", "seq", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'seq'", "]", "# the first beam has highest cumulative score", "\n", "seqLogprobs", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'logps'", "]", "\n", "# return the samples and their log likelihoods", "\n", "", "return", "seq", ".", "transpose", "(", "0", ",", "1", ")", ",", "seqLogprobs", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.OldModel.sample": [[131, 177], ["opt.get", "opt.get", "opt.get", "fc_feats.size", "OldModel.OldModel.init_hidden", "range", "OldModel.OldModel.sample_beam", "OldModel.OldModel.embed", "OldModel.OldModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "fc_feats.data.new().long().zero_", "seq.append", "seqLogprobs.append", "OldModel.OldModel.logit", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "it.view().long.view().long.view().long", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.log_softmax.gather", "it.view().long.view().long.view().long", "unfinished.sum", "unfinished.type_as", "F.log_softmax.gather.view", "OldModel.OldModel.dropout", "_.unsqueeze", "_.unsqueeze", "fc_feats.data.new().long", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "it.view().long.view().long.view", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "it.view().long.view().long.view", "fc_feats.data.new", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.OldModel.sample_beam", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "def", "sample", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "opt", "=", "{", "}", ")", ":", "\n", "        ", "sample_method", "=", "opt", ".", "get", "(", "'sample_method'", ",", "'greedy'", ")", "\n", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "1", ")", "\n", "temperature", "=", "opt", ".", "get", "(", "'temperature'", ",", "1.0", ")", "\n", "if", "beam_size", ">", "1", ":", "\n", "            ", "return", "self", ".", "sample_beam", "(", "fc_feats", ",", "att_feats", ",", "opt", ")", "\n", "\n", "", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "state", "=", "self", ".", "init_hidden", "(", "fc_feats", ")", "\n", "\n", "seq", "=", "[", "]", "\n", "seqLogprobs", "=", "[", "]", "\n", "for", "t", "in", "range", "(", "self", ".", "seq_length", "+", "1", ")", ":", "\n", "            ", "if", "t", "==", "0", ":", "# input <bos>", "\n", "                ", "it", "=", "fc_feats", ".", "data", ".", "new", "(", "batch_size", ")", ".", "long", "(", ")", ".", "zero_", "(", ")", "\n", "", "elif", "sample_method", "==", "'greedy'", ":", "\n", "                ", "sampleLogprobs", ",", "it", "=", "torch", ".", "max", "(", "logprobs", ".", "data", ",", "1", ")", "\n", "it", "=", "it", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", "\n", "", "else", ":", "\n", "                ", "if", "temperature", "==", "1.0", ":", "\n", "                    ", "prob_prev", "=", "torch", ".", "exp", "(", "logprobs", ".", "data", ")", ".", "cpu", "(", ")", "# fetch prev distribution: shape Nx(M+1)", "\n", "", "else", ":", "\n", "# scale logprobs by temperature", "\n", "                    ", "prob_prev", "=", "torch", ".", "exp", "(", "torch", ".", "div", "(", "logprobs", ".", "data", ",", "temperature", ")", ")", ".", "cpu", "(", ")", "\n", "", "it", "=", "torch", ".", "multinomial", "(", "prob_prev", ",", "1", ")", ".", "cuda", "(", ")", "\n", "sampleLogprobs", "=", "logprobs", ".", "gather", "(", "1", ",", "it", ")", "# gather the logprobs at sampled positions", "\n", "it", "=", "it", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", "# and flatten indices for downstream processing", "\n", "\n", "", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "if", "t", ">=", "1", ":", "\n", "# stop when all finished", "\n", "                ", "if", "t", "==", "1", ":", "\n", "                    ", "unfinished", "=", "it", ">", "0", "\n", "", "else", ":", "\n", "                    ", "unfinished", "=", "unfinished", "*", "(", "it", ">", "0", ")", "\n", "", "if", "unfinished", ".", "sum", "(", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "", "it", "=", "it", "*", "unfinished", ".", "type_as", "(", "it", ")", "\n", "seq", ".", "append", "(", "it", ")", "#seq[t] the input of t+2 time step", "\n", "seqLogprobs", ".", "append", "(", "sampleLogprobs", ".", "view", "(", "-", "1", ")", ")", "\n", "\n", "", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "fc_feats", ",", "att_feats", ",", "state", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "self", ".", "dropout", "(", "output", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "[", "_", ".", "unsqueeze", "(", "1", ")", "for", "_", "in", "seq", "]", ",", "1", ")", ",", "torch", ".", "cat", "(", "[", "_", ".", "unsqueeze", "(", "1", ")", "for", "_", "in", "seqLogprobs", "]", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.ShowAttendTellCore.__init__": [[180, 201], ["torch.Module.__init__", "getattr", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "OldModel.ShowAttendTellCore.rnn_type.upper"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "ShowAttendTellCore", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "self", ".", "rnn_type", "=", "opt", ".", "rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "num_layers", "=", "opt", ".", "num_layers", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "fc_feat_size", "=", "opt", ".", "fc_feat_size", "\n", "self", ".", "att_feat_size", "=", "opt", ".", "att_feat_size", "\n", "self", ".", "att_hid_size", "=", "opt", ".", "att_hid_size", "\n", "\n", "self", ".", "rnn", "=", "getattr", "(", "nn", ",", "self", ".", "rnn_type", ".", "upper", "(", ")", ")", "(", "self", ".", "input_encoding_size", "+", "self", ".", "att_feat_size", ",", "\n", "self", ".", "rnn_size", ",", "self", ".", "num_layers", ",", "bias", "=", "False", ",", "dropout", "=", "self", ".", "drop_prob_lm", ")", "\n", "\n", "if", "self", ".", "att_hid_size", ">", "0", ":", "\n", "            ", "self", ".", "ctx2att", "=", "nn", ".", "Linear", "(", "self", ".", "att_feat_size", ",", "self", ".", "att_hid_size", ")", "\n", "self", ".", "h2att", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "att_hid_size", ")", "\n", "self", ".", "alpha_net", "=", "nn", ".", "Linear", "(", "self", ".", "att_hid_size", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "ctx2att", "=", "nn", ".", "Linear", "(", "self", ".", "att_feat_size", ",", "1", ")", "\n", "self", ".", "h2att", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.ShowAttendTellCore.forward": [[202, 228], ["att_feats.view", "torch.softmax", "torch.softmax", "torch.softmax", "att_feats.view", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "OldModel.ShowAttendTellCore.rnn", "OldModel.ShowAttendTellCore.ctx2att", "att.view.view.view", "OldModel.ShowAttendTellCore.h2att", "att_h.expand_as.expand_as.unsqueeze().expand_as", "torch.tanh", "torch.tanh", "torch.tanh", "dot.view.view.view", "OldModel.ShowAttendTellCore.alpha_net", "dot.view.view.view", "att.view.view.view", "OldModel.ShowAttendTellCore.h2att", "att_h.expand_as.expand_as.expand_as", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "output.squeeze", "att_feats.numel", "att_feats.size", "OldModel.ShowAttendTellCore.ctx2att", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "att_h.expand_as.expand_as.unsqueeze", "torch.softmax.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "", "def", "forward", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "state", ")", ":", "\n", "        ", "att_size", "=", "att_feats", ".", "numel", "(", ")", "//", "att_feats", ".", "size", "(", "0", ")", "//", "self", ".", "att_feat_size", "\n", "att", "=", "att_feats", ".", "view", "(", "-", "1", ",", "self", ".", "att_feat_size", ")", "\n", "if", "self", ".", "att_hid_size", ">", "0", ":", "\n", "            ", "att", "=", "self", ".", "ctx2att", "(", "att", ")", "# (batch * att_size) * att_hid_size", "\n", "att", "=", "att", ".", "view", "(", "-", "1", ",", "att_size", ",", "self", ".", "att_hid_size", ")", "# batch * att_size * att_hid_size", "\n", "att_h", "=", "self", ".", "h2att", "(", "state", "[", "0", "]", "[", "-", "1", "]", ")", "# batch * att_hid_size", "\n", "att_h", "=", "att_h", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "att", ")", "# batch * att_size * att_hid_size", "\n", "dot", "=", "att", "+", "att_h", "# batch * att_size * att_hid_size", "\n", "dot", "=", "F", ".", "tanh", "(", "dot", ")", "# batch * att_size * att_hid_size", "\n", "dot", "=", "dot", ".", "view", "(", "-", "1", ",", "self", ".", "att_hid_size", ")", "# (batch * att_size) * att_hid_size", "\n", "dot", "=", "self", ".", "alpha_net", "(", "dot", ")", "# (batch * att_size) * 1", "\n", "dot", "=", "dot", ".", "view", "(", "-", "1", ",", "att_size", ")", "# batch * att_size", "\n", "", "else", ":", "\n", "            ", "att", "=", "self", ".", "ctx2att", "(", "att", ")", "(", "att", ")", "# (batch * att_size) * 1", "\n", "att", "=", "att", ".", "view", "(", "-", "1", ",", "att_size", ")", "# batch * att_size", "\n", "att_h", "=", "self", ".", "h2att", "(", "state", "[", "0", "]", "[", "-", "1", "]", ")", "# batch * 1", "\n", "att_h", "=", "att_h", ".", "expand_as", "(", "att", ")", "# batch * att_size", "\n", "dot", "=", "att_h", "+", "att", "# batch * att_size", "\n", "\n", "", "weight", "=", "F", ".", "softmax", "(", "dot", ",", "dim", "=", "1", ")", "\n", "att_feats_", "=", "att_feats", ".", "view", "(", "-", "1", ",", "att_size", ",", "self", ".", "att_feat_size", ")", "# batch * att_size * att_feat_size", "\n", "att_res", "=", "torch", ".", "bmm", "(", "weight", ".", "unsqueeze", "(", "1", ")", ",", "att_feats_", ")", ".", "squeeze", "(", "1", ")", "# batch * att_feat_size", "\n", "\n", "output", ",", "state", "=", "self", ".", "rnn", "(", "torch", ".", "cat", "(", "[", "xt", ",", "att_res", "]", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", ",", "state", ")", "\n", "return", "output", ".", "squeeze", "(", "0", ")", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.AllImgCore.__init__": [[230, 241], ["torch.Module.__init__", "getattr", "OldModel.AllImgCore.rnn_type.upper"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "AllImgCore", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "self", ".", "rnn_type", "=", "opt", ".", "rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "num_layers", "=", "opt", ".", "num_layers", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "fc_feat_size", "=", "opt", ".", "fc_feat_size", "\n", "\n", "self", ".", "rnn", "=", "getattr", "(", "nn", ",", "self", ".", "rnn_type", ".", "upper", "(", ")", ")", "(", "self", ".", "input_encoding_size", "+", "self", ".", "fc_feat_size", ",", "\n", "self", ".", "rnn_size", ",", "self", ".", "num_layers", ",", "bias", "=", "False", ",", "dropout", "=", "self", ".", "drop_prob_lm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.AllImgCore.forward": [[242, 245], ["OldModel.AllImgCore.rnn", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "output.squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "xt", ",", "fc_feats", ",", "att_feats", ",", "state", ")", ":", "\n", "        ", "output", ",", "state", "=", "self", ".", "rnn", "(", "torch", ".", "cat", "(", "[", "xt", ",", "fc_feats", "]", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", ",", "state", ")", "\n", "return", "output", ".", "squeeze", "(", "0", ")", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.ShowAttendTellModel.__init__": [[247, 250], ["OldModel.OldModel.__init__", "OldModel.ShowAttendTellCore"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "ShowAttendTellModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "core", "=", "ShowAttendTellCore", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.OldModel.AllImgModel.__init__": [[252, 255], ["OldModel.OldModel.__init__", "OldModel.AllImgCore"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "AllImgModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "core", "=", "AllImgCore", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.LSTMCore.__init__": [[14, 24], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "LSTMCore", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "\n", "# Build a LSTM", "\n", "self", ".", "i2h", "=", "nn", ".", "Linear", "(", "self", ".", "input_encoding_size", ",", "5", "*", "self", ".", "rnn_size", ")", "\n", "self", ".", "h2h", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "5", "*", "self", ".", "rnn_size", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.LSTMCore.forward": [[25, 43], ["all_input_sums.narrow", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.sigmoid.narrow", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "FCModel.LSTMCore.dropout", "FCModel.LSTMCore.i2h", "FCModel.LSTMCore.h2h", "all_input_sums.narrow", "all_input_sums.narrow", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "next_h.unsqueeze", "next_c.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "xt", ",", "state", ")", ":", "\n", "\n", "        ", "all_input_sums", "=", "self", ".", "i2h", "(", "xt", ")", "+", "self", ".", "h2h", "(", "state", "[", "0", "]", "[", "-", "1", "]", ")", "\n", "sigmoid_chunk", "=", "all_input_sums", ".", "narrow", "(", "1", ",", "0", ",", "3", "*", "self", ".", "rnn_size", ")", "\n", "sigmoid_chunk", "=", "torch", ".", "sigmoid", "(", "sigmoid_chunk", ")", "\n", "in_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "0", ",", "self", ".", "rnn_size", ")", "\n", "forget_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", "\n", "out_gate", "=", "sigmoid_chunk", ".", "narrow", "(", "1", ",", "self", ".", "rnn_size", "*", "2", ",", "self", ".", "rnn_size", ")", "\n", "\n", "in_transform", "=", "torch", ".", "max", "(", "all_input_sums", ".", "narrow", "(", "1", ",", "3", "*", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", ",", "\n", "all_input_sums", ".", "narrow", "(", "1", ",", "4", "*", "self", ".", "rnn_size", ",", "self", ".", "rnn_size", ")", ")", "\n", "next_c", "=", "forget_gate", "*", "state", "[", "1", "]", "[", "-", "1", "]", "+", "in_gate", "*", "in_transform", "\n", "next_h", "=", "out_gate", "*", "torch", ".", "tanh", "(", "next_c", ")", "\n", "\n", "output", "=", "self", ".", "dropout", "(", "next_h", ")", "\n", "state", "=", "(", "next_h", ".", "unsqueeze", "(", "0", ")", ",", "next_c", ".", "unsqueeze", "(", "0", ")", ")", "\n", "return", "output", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.__init__": [[45, 64], ["CaptionModel.CaptionModel.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "FCModel.LSTMCore", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Linear", "torch.Linear", "torch.Linear", "FCModel.FCModel.init_weights"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_weights"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "FCModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "vocab_size", "=", "opt", ".", "vocab_size", "\n", "self", ".", "input_encoding_size", "=", "opt", ".", "input_encoding_size", "\n", "self", ".", "rnn_type", "=", "opt", ".", "rnn_type", "\n", "self", ".", "rnn_size", "=", "opt", ".", "rnn_size", "\n", "self", ".", "num_layers", "=", "opt", ".", "num_layers", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "seq_length", "=", "opt", ".", "seq_length", "\n", "self", ".", "fc_feat_size", "=", "opt", ".", "fc_feat_size", "\n", "\n", "self", ".", "ss_prob", "=", "0.0", "# Schedule sampling probability", "\n", "\n", "self", ".", "img_embed", "=", "nn", ".", "Linear", "(", "self", ".", "fc_feat_size", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "core", "=", "LSTMCore", "(", "opt", ")", "\n", "self", ".", "embed", "=", "nn", ".", "Embedding", "(", "self", ".", "vocab_size", "+", "1", ",", "self", ".", "input_encoding_size", ")", "\n", "self", ".", "logit", "=", "nn", ".", "Linear", "(", "self", ".", "rnn_size", ",", "self", ".", "vocab_size", "+", "1", ")", "\n", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_weights": [[65, 70], ["FCModel.FCModel.embed.weight.data.uniform_", "FCModel.FCModel.logit.bias.data.fill_", "FCModel.FCModel.logit.weight.data.uniform_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "initrange", "=", "0.1", "\n", "self", ".", "embed", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "initrange", ",", "initrange", ")", "\n", "self", ".", "logit", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "logit", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "initrange", ",", "initrange", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden": [[71, 78], ["next", "FCModel.FCModel.parameters", "next.new_zeros", "next.new_zeros", "next.new_zeros"], "methods", ["None"], ["", "def", "init_hidden", "(", "self", ",", "bsz", ")", ":", "\n", "        ", "weight", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", "\n", "if", "self", ".", "rnn_type", "==", "'lstm'", ":", "\n", "            ", "return", "(", "weight", ".", "new_zeros", "(", "self", ".", "num_layers", ",", "bsz", ",", "self", ".", "rnn_size", ")", ",", "\n", "weight", ".", "new_zeros", "(", "self", ".", "num_layers", ",", "bsz", ",", "self", ".", "rnn_size", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "weight", ".", "new_zeros", "(", "self", ".", "num_layers", ",", "bsz", ",", "self", ".", "rnn_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel._forward": [[79, 112], ["fc_feats.size", "FCModel.FCModel.init_hidden", "range", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "torch.cat().contiguous", "seq.size", "FCModel.FCModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "outputs.append", "FCModel.FCModel.img_embed", "FCModel.FCModel.embed", "FCModel.FCModel.logit", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "fc_feats.data.new().uniform_", "seq[].clone", "sample_mask.sum", "seq[].clone", "sample_mask.nonzero().view", "seq[].data.clone", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "seq[].data.clone.index_copy_", "seq[].sum", "_.unsqueeze", "fc_feats.data.new", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "torch.multinomial().view().index_select", "sample_mask.nonzero", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial().view", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "", "def", "_forward", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "seq", ",", "att_masks", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "state", "=", "self", ".", "init_hidden", "(", "batch_size", ")", "\n", "outputs", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "seq", ".", "size", "(", "1", ")", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "xt", "=", "self", ".", "img_embed", "(", "fc_feats", ")", "\n", "", "else", ":", "\n", "                ", "if", "self", ".", "training", "and", "i", ">=", "2", "and", "self", ".", "ss_prob", ">", "0.0", ":", "# otherwiste no need to sample", "\n", "                    ", "sample_prob", "=", "fc_feats", ".", "data", ".", "new", "(", "batch_size", ")", ".", "uniform_", "(", "0", ",", "1", ")", "\n", "sample_mask", "=", "sample_prob", "<", "self", ".", "ss_prob", "\n", "if", "sample_mask", ".", "sum", "(", ")", "==", "0", ":", "\n", "                        ", "it", "=", "seq", "[", ":", ",", "i", "-", "1", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                        ", "sample_ind", "=", "sample_mask", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "it", "=", "seq", "[", ":", ",", "i", "-", "1", "]", ".", "data", ".", "clone", "(", ")", "\n", "#prob_prev = torch.exp(outputs[-1].data.index_select(0, sample_ind)) # fetch prev distribution: shape Nx(M+1)", "\n", "#it.index_copy_(0, sample_ind, torch.multinomial(prob_prev, 1).view(-1))", "\n", "prob_prev", "=", "torch", ".", "exp", "(", "outputs", "[", "-", "1", "]", ".", "data", ")", "# fetch prev distribution: shape Nx(M+1)", "\n", "it", ".", "index_copy_", "(", "0", ",", "sample_ind", ",", "torch", ".", "multinomial", "(", "prob_prev", ",", "1", ")", ".", "view", "(", "-", "1", ")", ".", "index_select", "(", "0", ",", "sample_ind", ")", ")", "\n", "", "", "else", ":", "\n", "                    ", "it", "=", "seq", "[", ":", ",", "i", "-", "1", "]", ".", "clone", "(", ")", "\n", "# break if all the sequences end", "\n", "", "if", "i", ">=", "2", "and", "seq", "[", ":", ",", "i", "-", "1", "]", ".", "sum", "(", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "state", ")", "\n", "output", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "output", ")", ",", "dim", "=", "1", ")", "\n", "outputs", ".", "append", "(", "output", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "[", "_", ".", "unsqueeze", "(", "1", ")", "for", "_", "in", "outputs", "[", "1", ":", "]", "]", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.get_logprobs_state": [[113, 121], ["FCModel.FCModel.embed", "FCModel.FCModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "FCModel.FCModel.logit"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "def", "get_logprobs_state", "(", "self", ",", "it", ",", "state", ")", ":", "\n", "# 'it' is contains a word index", "\n", "        ", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "state", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "output", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "logprobs", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel._sample_beam": [[122, 149], ["opt.get", "fc_feats.size", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.LongTensor().zero_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "range", "FCModel.FCModel.init_hidden", "range", "FCModel.FCModel.beam_search", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.LongTensor().zero_.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.FloatTensor.transpose", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "range", "FCModel.FCModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "FCModel.FCModel.img_embed().expand", "FCModel.FCModel.logit", "fc_feats.data.new().long().zero_", "FCModel.FCModel.embed", "FCModel.FCModel.img_embed", "fc_feats.data.new().long", "fc_feats.data.new"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.CaptionModel.CaptionModel.beam_search", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed"], ["", "def", "_sample_beam", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", "=", "None", ",", "opt", "=", "{", "}", ")", ":", "\n", "        ", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "10", ")", "\n", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "\n", "assert", "beam_size", "<=", "self", ".", "vocab_size", "+", "1", ",", "'lets assume this for now, otherwise this corner case causes a few headaches down the road. can be dealt with in future if needed'", "\n", "seq", "=", "torch", ".", "LongTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", ".", "zero_", "(", ")", "\n", "seqLogprobs", "=", "torch", ".", "FloatTensor", "(", "self", ".", "seq_length", ",", "batch_size", ")", "\n", "# lets process every image independently for now, for simplicity", "\n", "\n", "self", ".", "done_beams", "=", "[", "[", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "state", "=", "self", ".", "init_hidden", "(", "beam_size", ")", "\n", "for", "t", "in", "range", "(", "2", ")", ":", "\n", "                ", "if", "t", "==", "0", ":", "\n", "                    ", "xt", "=", "self", ".", "img_embed", "(", "fc_feats", "[", "k", ":", "k", "+", "1", "]", ")", ".", "expand", "(", "beam_size", ",", "self", ".", "input_encoding_size", ")", "\n", "", "elif", "t", "==", "1", ":", "# input <bos>", "\n", "                    ", "it", "=", "fc_feats", ".", "data", ".", "new", "(", "beam_size", ")", ".", "long", "(", ")", ".", "zero_", "(", ")", "\n", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "state", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "output", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "self", ".", "done_beams", "[", "k", "]", "=", "self", ".", "beam_search", "(", "state", ",", "logprobs", ",", "opt", "=", "opt", ")", "\n", "seq", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'seq'", "]", "# the first beam has highest cumulative score", "\n", "seqLogprobs", "[", ":", ",", "k", "]", "=", "self", ".", "done_beams", "[", "k", "]", "[", "0", "]", "[", "'logps'", "]", "\n", "# return the samples and their log likelihoods", "\n", "", "return", "seq", ".", "transpose", "(", "0", ",", "1", ")", ",", "seqLogprobs", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel._sample": [[150, 201], ["opt.get", "opt.get", "opt.get", "fc_feats.size", "FCModel.FCModel.init_hidden", "fc_feats.new_zeros", "fc_feats.new_zeros", "range", "FCModel.FCModel._sample_beam", "FCModel.FCModel.core", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "FCModel.FCModel.img_embed", "FCModel.FCModel.embed", "FCModel.FCModel.logit", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "fc_feats.data.new().long().zero_.view().long", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.multinomial().cuda", "torch.log_softmax.gather", "fc_feats.data.new().long().zero_.view().long", "F.log_softmax.gather.view", "fc_feats.data.new().long().zero_", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "torch.exp().cpu", "unfinished.type_as", "unfinished.sum", "fc_feats.data.new().long().zero_.view", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "fc_feats.data.new().long().zero_.view", "fc_feats.data.new().long", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "fc_feats.data.new"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel.init_hidden", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.FCModel.FCModel._sample_beam", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.core", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttEnsemble.AttEnsemble.embed", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.TransformerModel.logit"], ["", "def", "_sample", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", "=", "None", ",", "opt", "=", "{", "}", ")", ":", "\n", "        ", "sample_method", "=", "opt", ".", "get", "(", "'sample_method'", ",", "'greedy'", ")", "\n", "beam_size", "=", "opt", ".", "get", "(", "'beam_size'", ",", "1", ")", "\n", "temperature", "=", "opt", ".", "get", "(", "'temperature'", ",", "1.0", ")", "\n", "if", "beam_size", ">", "1", ":", "\n", "            ", "return", "self", ".", "_sample_beam", "(", "fc_feats", ",", "att_feats", ",", "opt", ")", "\n", "\n", "", "batch_size", "=", "fc_feats", ".", "size", "(", "0", ")", "\n", "state", "=", "self", ".", "init_hidden", "(", "batch_size", ")", "\n", "seq", "=", "fc_feats", ".", "new_zeros", "(", "batch_size", ",", "self", ".", "seq_length", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "seqLogprobs", "=", "fc_feats", ".", "new_zeros", "(", "batch_size", ",", "self", ".", "seq_length", ")", "\n", "for", "t", "in", "range", "(", "self", ".", "seq_length", "+", "2", ")", ":", "\n", "            ", "if", "t", "==", "0", ":", "\n", "                ", "xt", "=", "self", ".", "img_embed", "(", "fc_feats", ")", "\n", "", "else", ":", "\n", "                ", "if", "t", "==", "1", ":", "# input <bos>", "\n", "                    ", "it", "=", "fc_feats", ".", "data", ".", "new", "(", "batch_size", ")", ".", "long", "(", ")", ".", "zero_", "(", ")", "\n", "", "xt", "=", "self", ".", "embed", "(", "it", ")", "\n", "\n", "", "output", ",", "state", "=", "self", ".", "core", "(", "xt", ",", "state", ")", "\n", "logprobs", "=", "F", ".", "log_softmax", "(", "self", ".", "logit", "(", "output", ")", ",", "dim", "=", "1", ")", "\n", "\n", "# sample the next_word", "\n", "if", "t", "==", "self", ".", "seq_length", "+", "1", ":", "# skip if we achieve maximum length", "\n", "                ", "break", "\n", "", "if", "sample_method", "==", "'greedy'", ":", "\n", "                ", "sampleLogprobs", ",", "it", "=", "torch", ".", "max", "(", "logprobs", ".", "data", ",", "1", ")", "\n", "it", "=", "it", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", "\n", "", "else", ":", "\n", "                ", "if", "temperature", "==", "1.0", ":", "\n", "                    ", "prob_prev", "=", "torch", ".", "exp", "(", "logprobs", ".", "data", ")", ".", "cpu", "(", ")", "# fetch prev distribution: shape Nx(M+1)", "\n", "", "else", ":", "\n", "# scale logprobs by temperature", "\n", "                    ", "prob_prev", "=", "torch", ".", "exp", "(", "torch", ".", "div", "(", "logprobs", ".", "data", ",", "temperature", ")", ")", ".", "cpu", "(", ")", "\n", "", "it", "=", "torch", ".", "multinomial", "(", "prob_prev", ",", "1", ")", ".", "cuda", "(", ")", "\n", "sampleLogprobs", "=", "logprobs", ".", "gather", "(", "1", ",", "it", ")", "# gather the logprobs at sampled positions", "\n", "it", "=", "it", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", "# and flatten indices for downstream processing", "\n", "\n", "", "if", "t", ">=", "1", ":", "\n", "# stop when all finished", "\n", "                ", "if", "t", "==", "1", ":", "\n", "                    ", "unfinished", "=", "it", ">", "0", "\n", "", "else", ":", "\n", "                    ", "unfinished", "=", "unfinished", "*", "(", "it", ">", "0", ")", "\n", "", "it", "=", "it", "*", "unfinished", ".", "type_as", "(", "it", ")", "\n", "seq", "[", ":", ",", "t", "-", "1", "]", "=", "it", "#seq[t] the input of t+2 time step", "\n", "seqLogprobs", "[", ":", ",", "t", "-", "1", "]", "=", "sampleLogprobs", ".", "view", "(", "-", "1", ")", "\n", "if", "unfinished", ".", "sum", "(", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "\n", "", "", "", "return", "seq", ",", "seqLogprobs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.__init__.setup": [[19, 68], ["FCModel.FCModel", "vars().get", "os.path.isdir", "os.path.isfile", "AoAModel.AoAModel.load_state_dict", "AttModel.LMModel", "os.path.join", "torch.load", "AttModel.NewFCModel", "vars", "os.path.join", "ShowTellModel.ShowTellModel", "AttModel.Att2inModel", "AttModel.Att2in2Model", "AttModel.Att2all2Model", "AttModel.AdaAttModel", "AttModel.AdaAttMOModel", "AttModel.TopDownModel", "AttModel.StackAttModel", "AttModel.DenseAttModel", "TransformerModel.TransformerModel", "AoAModel.AoAModel", "Exception"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.MultiHeadedDotAttention.__init__": [[17, 54], ["torch.Module.__init__", "TransformerModel.clones", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "TransformerModel.LayerNorm", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.GLU", "torch.GLU", "torch.GLU", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.clones"], ["    ", "def", "__init__", "(", "self", ",", "h", ",", "d_model", ",", "dropout", "=", "0.1", ",", "scale", "=", "1", ",", "project_k_v", "=", "1", ",", "use_output_layer", "=", "1", ",", "do_aoa", "=", "0", ",", "norm_q", "=", "0", ",", "dropout_aoa", "=", "0.3", ")", ":", "\n", "        ", "super", "(", "MultiHeadedDotAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "d_model", "*", "scale", "%", "h", "==", "0", "\n", "# We assume d_v always equals d_k", "\n", "self", ".", "d_k", "=", "d_model", "*", "scale", "//", "h", "\n", "self", ".", "h", "=", "h", "\n", "\n", "# Do we need to do linear projections on K and V?", "\n", "self", ".", "project_k_v", "=", "project_k_v", "\n", "\n", "# normalize the query?", "\n", "if", "norm_q", ":", "\n", "            ", "self", ".", "norm", "=", "LayerNorm", "(", "d_model", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "norm", "=", "lambda", "x", ":", "x", "\n", "", "self", ".", "linears", "=", "clones", "(", "nn", ".", "Linear", "(", "d_model", ",", "d_model", "*", "scale", ")", ",", "1", "+", "2", "*", "project_k_v", ")", "\n", "\n", "# output linear layer after the multi-head attention?", "\n", "self", ".", "output_layer", "=", "nn", ".", "Linear", "(", "d_model", "*", "scale", ",", "d_model", ")", "\n", "\n", "# apply aoa after attention?", "\n", "self", ".", "use_aoa", "=", "do_aoa", "\n", "if", "self", ".", "use_aoa", ":", "\n", "            ", "self", ".", "aoa_layer", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "(", "1", "+", "scale", ")", "*", "d_model", ",", "2", "*", "d_model", ")", ",", "nn", ".", "GLU", "(", ")", ")", "\n", "# dropout to the input of AoA layer", "\n", "if", "dropout_aoa", ">", "0", ":", "\n", "                ", "self", ".", "dropout_aoa", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout_aoa", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "dropout_aoa", "=", "lambda", "x", ":", "x", "\n", "\n", "", "", "if", "self", ".", "use_aoa", "or", "not", "use_output_layer", ":", "\n", "# AoA doesn't need the output linear layer", "\n", "            ", "del", "self", ".", "output_layer", "\n", "self", ".", "output_layer", "=", "lambda", "x", ":", "x", "\n", "\n", "", "self", ".", "attn", "=", "None", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.MultiHeadedDotAttention.forward": [[55, 98], ["query.squeeze.squeeze.size", "AoAModel.MultiHeadedDotAttention.norm", "TransformerModel.attention", "x.squeeze.squeeze.transpose().contiguous().view", "AoAModel.MultiHeadedDotAttention.output_layer", "mask.unsqueeze.unsqueeze.unsqueeze", "len", "query.squeeze.squeeze.unsqueeze", "key.view().transpose", "value.view().transpose", "AoAModel.MultiHeadedDotAttention.aoa_layer", "query.squeeze.squeeze.squeeze", "x.squeeze.squeeze.squeeze", "len", "mask.unsqueeze.unsqueeze.unsqueeze", "query.squeeze.squeeze.size", "l().view().transpose", "x.squeeze.squeeze.transpose().contiguous", "AoAModel.MultiHeadedDotAttention.dropout_aoa", "mask.unsqueeze.unsqueeze.size", "key.view", "value.view", "zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "l().view", "x.squeeze.squeeze.transpose", "l"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.attention", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "forward", "(", "self", ",", "query", ",", "value", ",", "key", ",", "mask", "=", "None", ")", ":", "\n", "        ", "if", "mask", "is", "not", "None", ":", "\n", "            ", "if", "len", "(", "mask", ".", "size", "(", ")", ")", "==", "2", ":", "\n", "                ", "mask", "=", "mask", ".", "unsqueeze", "(", "-", "2", ")", "\n", "# Same mask applied to all h heads.", "\n", "", "mask", "=", "mask", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "single_query", "=", "0", "\n", "if", "len", "(", "query", ".", "size", "(", ")", ")", "==", "2", ":", "\n", "            ", "single_query", "=", "1", "\n", "query", "=", "query", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "nbatches", "=", "query", ".", "size", "(", "0", ")", "\n", "\n", "query", "=", "self", ".", "norm", "(", "query", ")", "\n", "\n", "# Do all the linear projections in batch from d_model => h x d_k ", "\n", "if", "self", ".", "project_k_v", "==", "0", ":", "\n", "            ", "query_", "=", "self", ".", "linears", "[", "0", "]", "(", "query", ")", ".", "view", "(", "nbatches", ",", "-", "1", ",", "self", ".", "h", ",", "self", ".", "d_k", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "key_", "=", "key", ".", "view", "(", "nbatches", ",", "-", "1", ",", "self", ".", "h", ",", "self", ".", "d_k", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "value_", "=", "value", ".", "view", "(", "nbatches", ",", "-", "1", ",", "self", ".", "h", ",", "self", ".", "d_k", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "else", ":", "\n", "            ", "query_", ",", "key_", ",", "value_", "=", "[", "l", "(", "x", ")", ".", "view", "(", "nbatches", ",", "-", "1", ",", "self", ".", "h", ",", "self", ".", "d_k", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "for", "l", ",", "x", "in", "zip", "(", "self", ".", "linears", ",", "(", "query", ",", "key", ",", "value", ")", ")", "]", "\n", "\n", "# Apply attention on all the projected vectors in batch. ", "\n", "", "x", ",", "self", ".", "attn", "=", "attention", "(", "query_", ",", "key_", ",", "value_", ",", "mask", "=", "mask", ",", "\n", "dropout", "=", "self", ".", "dropout", ")", "\n", "\n", "# \"Concat\" using a view", "\n", "x", "=", "x", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "nbatches", ",", "-", "1", ",", "self", ".", "h", "*", "self", ".", "d_k", ")", "\n", "\n", "if", "self", ".", "use_aoa", ":", "\n", "# Apply AoA", "\n", "            ", "x", "=", "self", ".", "aoa_layer", "(", "self", ".", "dropout_aoa", "(", "torch", ".", "cat", "(", "[", "x", ",", "query", "]", ",", "-", "1", ")", ")", ")", "\n", "", "x", "=", "self", ".", "output_layer", "(", "x", ")", "\n", "\n", "if", "single_query", ":", "\n", "            ", "query", "=", "query", ".", "squeeze", "(", "1", ")", "\n", "x", "=", "x", ".", "squeeze", "(", "1", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoA_Refiner_Layer.__init__": [[100, 109], ["torch.Module.__init__", "TransformerModel.clones", "TransformerModel.SublayerConnection"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.clones"], ["    ", "def", "__init__", "(", "self", ",", "size", ",", "self_attn", ",", "feed_forward", ",", "dropout", ")", ":", "\n", "        ", "super", "(", "AoA_Refiner_Layer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "self_attn", "\n", "self", ".", "feed_forward", "=", "feed_forward", "\n", "self", ".", "use_ff", "=", "0", "\n", "if", "self", ".", "feed_forward", "is", "not", "None", ":", "\n", "            ", "self", ".", "use_ff", "=", "1", "\n", "", "self", ".", "sublayer", "=", "clones", "(", "SublayerConnection", "(", "size", ",", "dropout", ")", ",", "1", "+", "self", ".", "use_ff", ")", "\n", "self", ".", "size", "=", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoA_Refiner_Layer.forward": [[110, 113], ["AoAModel.AoA_Refiner_Layer.self_attn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ")", ":", "\n", "        ", "x", "=", "self", ".", "sublayer", "[", "0", "]", "(", "x", ",", "lambda", "x", ":", "self", ".", "self_attn", "(", "x", ",", "x", ",", "x", ",", "mask", ")", ")", "\n", "return", "self", ".", "sublayer", "[", "-", "1", "]", "(", "x", ",", "self", ".", "feed_forward", ")", "if", "self", ".", "use_ff", "else", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoA_Refiner_Core.__init__": [[115, 121], ["torch.Module.__init__", "AoAModel.MultiHeadedDotAttention", "AoAModel.AoA_Refiner_Layer", "TransformerModel.clones", "TransformerModel.LayerNorm", "getattr", "TransformerModel.PositionwiseFeedForward"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.clones"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "AoA_Refiner_Core", ",", "self", ")", ".", "__init__", "(", ")", "\n", "attn", "=", "MultiHeadedDotAttention", "(", "opt", ".", "num_heads", ",", "opt", ".", "rnn_size", ",", "project_k_v", "=", "1", ",", "scale", "=", "opt", ".", "multi_head_scale", ",", "do_aoa", "=", "opt", ".", "refine_aoa", ",", "norm_q", "=", "0", ",", "dropout_aoa", "=", "getattr", "(", "opt", ",", "'dropout_aoa'", ",", "0.3", ")", ")", "\n", "layer", "=", "AoA_Refiner_Layer", "(", "opt", ".", "rnn_size", ",", "attn", ",", "PositionwiseFeedForward", "(", "opt", ".", "rnn_size", ",", "2048", ",", "0.1", ")", "if", "opt", ".", "use_ff", "else", "None", ",", "0.1", ")", "\n", "self", ".", "layers", "=", "clones", "(", "layer", ",", "6", ")", "\n", "self", ".", "norm", "=", "LayerNorm", "(", "layer", ".", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoA_Refiner_Core.forward": [[122, 126], ["AoAModel.AoA_Refiner_Core.norm", "layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ")", ":", "\n", "        ", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ",", "mask", ")", "\n", "", "return", "self", ".", "norm", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoA_Decoder_Core.__init__": [[128, 161], ["torch.Module.__init__", "getattr", "getattr", "getattr", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Sequential", "torch.Sequential", "torch.Sequential", "AoAModel.MultiHeadedDotAttention", "AttModel.AttModel.Attention", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.GLU", "torch.GLU", "torch.GLU", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "AoA_Decoder_Core", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "drop_prob_lm", "=", "opt", ".", "drop_prob_lm", "\n", "self", ".", "d_model", "=", "opt", ".", "rnn_size", "\n", "self", ".", "use_multi_head", "=", "opt", ".", "use_multi_head", "\n", "self", ".", "multi_head_scale", "=", "opt", ".", "multi_head_scale", "\n", "self", ".", "use_ctx_drop", "=", "getattr", "(", "opt", ",", "'ctx_drop'", ",", "0", ")", "\n", "self", ".", "out_res", "=", "getattr", "(", "opt", ",", "'out_res'", ",", "0", ")", "\n", "self", ".", "decoder_type", "=", "getattr", "(", "opt", ",", "'decoder_type'", ",", "'AoA'", ")", "\n", "self", ".", "att_lstm", "=", "nn", ".", "LSTMCell", "(", "opt", ".", "input_encoding_size", "+", "opt", ".", "rnn_size", ",", "opt", ".", "rnn_size", ")", "# we, fc, h^2_t-1", "\n", "self", ".", "out_drop", "=", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", "\n", "\n", "if", "self", ".", "decoder_type", "==", "'AoA'", ":", "\n", "# AoA layer", "\n", "            ", "self", ".", "att2ctx", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "self", ".", "d_model", "*", "opt", ".", "multi_head_scale", "+", "opt", ".", "rnn_size", ",", "2", "*", "opt", ".", "rnn_size", ")", ",", "nn", ".", "GLU", "(", ")", ")", "\n", "", "elif", "self", ".", "decoder_type", "==", "'LSTM'", ":", "\n", "# LSTM layer", "\n", "            ", "self", ".", "att2ctx", "=", "nn", ".", "LSTMCell", "(", "self", ".", "d_model", "*", "opt", ".", "multi_head_scale", "+", "opt", ".", "rnn_size", ",", "opt", ".", "rnn_size", ")", "\n", "", "else", ":", "\n", "# Base linear layer", "\n", "            ", "self", ".", "att2ctx", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "self", ".", "d_model", "*", "opt", ".", "multi_head_scale", "+", "opt", ".", "rnn_size", ",", "opt", ".", "rnn_size", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "# if opt.use_multi_head == 1: # TODO, not implemented for now           ", "\n", "#     self.attention = MultiHeadedAddAttention(opt.num_heads, opt.d_model, scale=opt.multi_head_scale)", "\n", "", "if", "opt", ".", "use_multi_head", "==", "2", ":", "\n", "            ", "self", ".", "attention", "=", "MultiHeadedDotAttention", "(", "opt", ".", "num_heads", ",", "opt", ".", "rnn_size", ",", "project_k_v", "=", "0", ",", "scale", "=", "opt", ".", "multi_head_scale", ",", "use_output_layer", "=", "0", ",", "do_aoa", "=", "0", ",", "norm_q", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "attention", "=", "Attention", "(", "opt", ")", "\n", "\n", "", "if", "self", ".", "use_ctx_drop", ":", "\n", "            ", "self", ".", "ctx_drop", "=", "nn", ".", "Dropout", "(", "self", ".", "drop_prob_lm", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "ctx_drop", "=", "lambda", "x", ":", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoA_Decoder_Core.forward": [[162, 186], ["AoAModel.AoA_Decoder_Core.att_lstm", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "AoAModel.AoA_Decoder_Core.out_drop", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "AoAModel.AoA_Decoder_Core.attention", "AoAModel.AoA_Decoder_Core.attention", "AoAModel.AoA_Decoder_Core.att2ctx", "AoAModel.AoA_Decoder_Core.att2ctx", "p_att_feats.narrow", "p_att_feats.narrow", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "AoAModel.AoA_Decoder_Core.ctx_drop"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.attention", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.attention"], ["", "", "def", "forward", "(", "self", ",", "xt", ",", "mean_feats", ",", "att_feats", ",", "p_att_feats", ",", "state", ",", "att_masks", "=", "None", ")", ":", "\n", "# state[0][1] is the context vector at the last step", "\n", "        ", "h_att", ",", "c_att", "=", "self", ".", "att_lstm", "(", "torch", ".", "cat", "(", "[", "xt", ",", "mean_feats", "+", "self", ".", "ctx_drop", "(", "state", "[", "0", "]", "[", "1", "]", ")", "]", ",", "1", ")", ",", "(", "state", "[", "0", "]", "[", "0", "]", ",", "state", "[", "1", "]", "[", "0", "]", ")", ")", "\n", "\n", "if", "self", ".", "use_multi_head", "==", "2", ":", "\n", "            ", "att", "=", "self", ".", "attention", "(", "h_att", ",", "p_att_feats", ".", "narrow", "(", "2", ",", "0", ",", "self", ".", "multi_head_scale", "*", "self", ".", "d_model", ")", ",", "p_att_feats", ".", "narrow", "(", "2", ",", "self", ".", "multi_head_scale", "*", "self", ".", "d_model", ",", "self", ".", "multi_head_scale", "*", "self", ".", "d_model", ")", ",", "att_masks", ")", "\n", "", "else", ":", "\n", "            ", "att", "=", "self", ".", "attention", "(", "h_att", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", ")", "\n", "\n", "", "ctx_input", "=", "torch", ".", "cat", "(", "[", "att", ",", "h_att", "]", ",", "1", ")", "\n", "if", "self", ".", "decoder_type", "==", "'LSTM'", ":", "\n", "            ", "output", ",", "c_logic", "=", "self", ".", "att2ctx", "(", "ctx_input", ",", "(", "state", "[", "0", "]", "[", "1", "]", ",", "state", "[", "1", "]", "[", "1", "]", ")", ")", "\n", "state", "=", "(", "torch", ".", "stack", "(", "(", "h_att", ",", "output", ")", ")", ",", "torch", ".", "stack", "(", "(", "c_att", ",", "c_logic", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "self", ".", "att2ctx", "(", "ctx_input", ")", "\n", "# save the context vector to state[0][1]", "\n", "state", "=", "(", "torch", ".", "stack", "(", "(", "h_att", ",", "output", ")", ")", ",", "torch", ".", "stack", "(", "(", "c_att", ",", "state", "[", "1", "]", "[", "1", "]", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "out_res", ":", "\n", "# add residual connection", "\n", "            ", "output", "=", "output", "+", "h_att", "\n", "\n", "", "output", "=", "self", ".", "out_drop", "(", "output", ")", "\n", "return", "output", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoAModel.__init__": [[188, 204], ["AttModel.AttModel.__init__", "getattr", "AoAModel.AoA_Decoder_Core", "torch.Linear", "torch.Linear", "torch.Linear", "AoAModel.AoA_Refiner_Core"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "AoAModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "num_layers", "=", "2", "\n", "# mean pooling", "\n", "self", ".", "use_mean_feats", "=", "getattr", "(", "opt", ",", "'mean_feats'", ",", "1", ")", "\n", "if", "opt", ".", "use_multi_head", "==", "2", ":", "\n", "            ", "del", "self", ".", "ctx2att", "\n", "self", ".", "ctx2att", "=", "nn", ".", "Linear", "(", "opt", ".", "rnn_size", ",", "2", "*", "opt", ".", "multi_head_scale", "*", "opt", ".", "rnn_size", ")", "\n", "\n", "", "if", "self", ".", "use_mean_feats", ":", "\n", "            ", "del", "self", ".", "fc_embed", "\n", "", "if", "opt", ".", "refine", ":", "\n", "            ", "self", ".", "refiner", "=", "AoA_Refiner_Core", "(", "opt", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "refiner", "=", "lambda", "x", ",", "y", ":", "x", "\n", "", "self", ".", "core", "=", "AoA_Decoder_Core", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AoAModel.AoAModel._prepare_feature": [[206, 226], ["AoAModel.AoAModel.clip_att", "AttModel.AttModel.pack_wrapper", "AoAModel.AoAModel.refiner", "AoAModel.AoAModel.ctx2att", "AoAModel.AoAModel.fc_embed", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "att_masks.unsqueeze", "att_masks.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.AttModel.clip_att", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.AttModel.pack_wrapper"], ["", "def", "_prepare_feature", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "att_masks", ")", ":", "\n", "        ", "att_feats", ",", "att_masks", "=", "self", ".", "clip_att", "(", "att_feats", ",", "att_masks", ")", "\n", "\n", "# embed att feats", "\n", "att_feats", "=", "pack_wrapper", "(", "self", ".", "att_embed", ",", "att_feats", ",", "att_masks", ")", "\n", "att_feats", "=", "self", ".", "refiner", "(", "att_feats", ",", "att_masks", ")", "\n", "\n", "if", "self", ".", "use_mean_feats", ":", "\n", "# meaning pooling", "\n", "            ", "if", "att_masks", "is", "None", ":", "\n", "                ", "mean_feats", "=", "torch", ".", "mean", "(", "att_feats", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "mean_feats", "=", "(", "torch", ".", "sum", "(", "att_feats", "*", "att_masks", ".", "unsqueeze", "(", "-", "1", ")", ",", "1", ")", "/", "torch", ".", "sum", "(", "att_masks", ".", "unsqueeze", "(", "-", "1", ")", ",", "1", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "mean_feats", "=", "self", ".", "fc_embed", "(", "fc_feats", ")", "\n", "\n", "# Project the attention feats first to reduce memory and computation.", "\n", "", "p_att_feats", "=", "self", ".", "ctx2att", "(", "att_feats", ")", "\n", "\n", "return", "mean_feats", ",", "att_feats", ",", "p_att_feats", ",", "att_masks", "", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.train._to_gpu": [[71, 79], ["isinstance", "td[].cuda", "v.cuda", "td[].items"], "function", ["None"], ["infos", "[", "'split_ix'", "]", "=", "loader", ".", "split_ix", "\n", "infos", "[", "'vocab'", "]", "=", "loader", ".", "get_vocab", "(", ")", "\n", "", "infos", "[", "'opt'", "]", "=", "opt", "\n", "\n", "iteration", "=", "infos", ".", "get", "(", "'iter'", ",", "0", ")", "\n", "epoch", "=", "infos", ".", "get", "(", "'epoch'", ",", "0", ")", "\n", "\n", "val_result_history", "=", "histories", ".", "get", "(", "'val_result_history'", ",", "{", "}", ")", "\n", "loss_history", "=", "histories", ".", "get", "(", "'loss_history'", ",", "{", "}", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.loss_wrapper.LossWrapper.__init__": [[6, 15], ["super().__init__", "misc.RewardCriterion", "misc.LabelSmoothing", "misc.LanguageModelCriterion"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "opt", ")", ":", "\n", "        ", "super", "(", "LossWrapper", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "opt", "=", "opt", "\n", "self", ".", "model", "=", "model", "\n", "if", "opt", ".", "label_smoothing", ">", "0", ":", "\n", "            ", "self", ".", "crit", "=", "utils", ".", "LabelSmoothing", "(", "smoothing", "=", "opt", ".", "label_smoothing", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "crit", "=", "utils", ".", "LanguageModelCriterion", "(", ")", "\n", "", "self", ".", "rl_crit", "=", "utils", ".", "RewardCriterion", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.loss_wrapper.LossWrapper.forward": [[16, 34], ["loss_wrapper.LossWrapper.crit", "loss_wrapper.LossWrapper.model.eval", "loss_wrapper.LossWrapper.model.train", "loss_wrapper.LossWrapper.model", "loss_wrapper.LossWrapper.", "torch.from_numpy().float().to", "loss_wrapper.LossWrapper.rl_crit", "reward[].mean", "loss_wrapper.LossWrapper.model", "torch.no_grad", "loss_wrapper.LossWrapper.model", "gt_indices.tolist", "torch.from_numpy().float", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "forward", "(", "self", ",", "fc_feats", ",", "att_feats", ",", "labels", ",", "masks", ",", "att_masks", ",", "gts", ",", "gt_indices", ",", "\n", "sc_flag", ")", ":", "\n", "        ", "out", "=", "{", "}", "\n", "if", "not", "sc_flag", ":", "\n", "            ", "loss", "=", "self", ".", "crit", "(", "self", ".", "model", "(", "fc_feats", ",", "att_feats", ",", "labels", ",", "att_masks", ")", ",", "labels", "[", ":", ",", "1", ":", "]", ",", "masks", "[", ":", ",", "1", ":", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "greedy_res", ",", "_", "=", "self", ".", "model", "(", "fc_feats", ",", "att_feats", ",", "att_masks", ",", "mode", "=", "'sample'", ")", "\n", "", "self", ".", "model", ".", "train", "(", ")", "\n", "gen_result", ",", "sample_logprobs", "=", "self", ".", "model", "(", "fc_feats", ",", "att_feats", ",", "att_masks", ",", "opt", "=", "{", "'sample_method'", ":", "'sample'", "}", ",", "mode", "=", "'sample'", ")", "\n", "gts", "=", "[", "gts", "[", "_", "]", "for", "_", "in", "gt_indices", ".", "tolist", "(", ")", "]", "\n", "reward", "=", "get_self_critical_reward", "(", "greedy_res", ",", "gts", ",", "gen_result", ",", "self", ".", "opt", ")", "\n", "reward", "=", "torch", ".", "from_numpy", "(", "reward", ")", ".", "float", "(", ")", ".", "to", "(", "gen_result", ".", "device", ")", "\n", "loss", "=", "self", ".", "rl_crit", "(", "sample_logprobs", ",", "gen_result", ".", "data", ",", "reward", ")", "\n", "out", "[", "'reward'", "]", "=", "reward", "[", ":", ",", "0", "]", ".", "mean", "(", ")", "\n", "", "out", "[", "'loss'", "]", "=", "loss", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet.ResNet.__init__": [[7, 13], ["super().__init__", "torch.MaxPool2d", "torch.MaxPool2d", "range", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet.resnet18": [[14, 24], ["resnet.ResNet", "ResNet.load_state_dict", "model_zoo.load_url"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["\n", "from", "collections", "import", "namedtuple", "\n", "\n", "import", "torch", "\n", "import", "torch", ".", "nn", ".", "functional", "as", "F", "\n", "from", "torch", "import", "nn", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet.resnet34": [[26, 36], ["resnet.ResNet", "ResNet.load_state_dict", "model_zoo.load_url"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["from", "vc_rcnn", ".", "layers", "import", "Conv2d", "\n", "from", "vc_rcnn", ".", "layers", "import", "DFConv2d", "\n", "from", "vc_rcnn", ".", "modeling", ".", "make_layers", "import", "group_norm", "\n", "from", "vc_rcnn", ".", "utils", ".", "registry", "import", "Registry", "\n", "\n", "\n", "# ResNet stage specification", "\n", "StageSpec", "=", "namedtuple", "(", "\n", "\"StageSpec\"", ",", "\n", "[", "\n", "\"index\"", ",", "# Index of the stage, eg 1, 2, ..,. 5", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet.resnet50": [[38, 48], ["resnet.ResNet", "ResNet.load_state_dict", "model_zoo.load_url"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["\"return_features\"", ",", "# True => return the last feature map from this stage", "\n", "]", ",", "\n", ")", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Standard ResNet models", "\n", "# -----------------------------------------------------------------------------", "\n", "# ResNet-50 (including all stages)", "\n", "ResNet50StagesTo5", "=", "tuple", "(", "\n", "StageSpec", "(", "index", "=", "i", ",", "block_count", "=", "c", ",", "return_features", "=", "r", ")", "\n", "for", "(", "i", ",", "c", ",", "r", ")", "in", "(", "(", "1", ",", "3", ",", "False", ")", ",", "(", "2", ",", "4", ",", "False", ")", ",", "(", "3", ",", "6", ",", "False", ")", ",", "(", "4", ",", "3", ",", "True", ")", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet.resnet101": [[50, 60], ["resnet.ResNet", "ResNet.load_state_dict", "model_zoo.load_url"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["# ResNet-50 up to stage 4 (excludes stage 5)", "\n", "ResNet50StagesTo4", "=", "tuple", "(", "\n", "StageSpec", "(", "index", "=", "i", ",", "block_count", "=", "c", ",", "return_features", "=", "r", ")", "\n", "for", "(", "i", ",", "c", ",", "r", ")", "in", "(", "(", "1", ",", "3", ",", "False", ")", ",", "(", "2", ",", "4", ",", "False", ")", ",", "(", "3", ",", "6", ",", "True", ")", ")", "\n", ")", "\n", "# ResNet-101 (including all stages)", "\n", "ResNet101StagesTo5", "=", "tuple", "(", "\n", "StageSpec", "(", "index", "=", "i", ",", "block_count", "=", "c", ",", "return_features", "=", "r", ")", "\n", "for", "(", "i", ",", "c", ",", "r", ")", "in", "(", "(", "1", ",", "3", ",", "False", ")", ",", "(", "2", ",", "4", ",", "False", ")", ",", "(", "3", ",", "23", ",", "False", ")", ",", "(", "4", ",", "3", ",", "True", ")", ")", "\n", ")", "\n", "# ResNet-101 up to stage 4 (excludes stage 5)", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet.resnet152": [[62, 72], ["resnet.ResNet", "ResNet.load_state_dict", "model_zoo.load_url"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], ["StageSpec", "(", "index", "=", "i", ",", "block_count", "=", "c", ",", "return_features", "=", "r", ")", "\n", "for", "(", "i", ",", "c", ",", "r", ")", "in", "(", "(", "1", ",", "3", ",", "False", ")", ",", "(", "2", ",", "4", ",", "False", ")", ",", "(", "3", ",", "23", ",", "True", ")", ")", "\n", ")", "\n", "# ResNet-50-FPN (including all stages)", "\n", "ResNet50FPNStagesTo5", "=", "tuple", "(", "\n", "StageSpec", "(", "index", "=", "i", ",", "block_count", "=", "c", ",", "return_features", "=", "r", ")", "\n", "for", "(", "i", ",", "c", ",", "r", ")", "in", "(", "(", "1", ",", "3", ",", "True", ")", ",", "(", "2", ",", "4", ",", "True", ")", ",", "(", "3", ",", "6", ",", "True", ")", ",", "(", "4", ",", "3", ",", "True", ")", ")", "\n", ")", "\n", "# ResNet-101-FPN (including all stages)", "\n", "ResNet101FPNStagesTo5", "=", "tuple", "(", "\n", "StageSpec", "(", "index", "=", "i", ",", "block_count", "=", "c", ",", "return_features", "=", "r", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.rewards.init_scorer": [[21, 26], ["pyciderevalcap.ciderD.ciderD.CiderD", "pycocoevalcap.bleu.bleu.Bleu"], "function", ["None"], ["def", "init_scorer", "(", "cached_tokens", ")", ":", "\n", "    ", "global", "CiderD_scorer", "\n", "CiderD_scorer", "=", "CiderD_scorer", "or", "CiderD", "(", "df", "=", "cached_tokens", ")", "\n", "global", "Bleu_scorer", "\n", "Bleu_scorer", "=", "Bleu_scorer", "or", "Bleu", "(", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.rewards.array_to_str": [[27, 34], ["range", "out.strip", "len", "str"], "function", ["None"], ["", "def", "array_to_str", "(", "arr", ")", ":", "\n", "    ", "out", "=", "''", "\n", "for", "i", "in", "range", "(", "len", "(", "arr", ")", ")", ":", "\n", "        ", "out", "+=", "str", "(", "arr", "[", "i", "]", ")", "+", "' '", "\n", "if", "arr", "[", "i", "]", "==", "0", ":", "\n", "            ", "break", "\n", "", "", "return", "out", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.rewards.get_self_critical_reward": [[35, 73], ["gen_result.data.cpu().numpy.size", "collections.OrderedDict", "gen_result.data.cpu().numpy.data.cpu().numpy", "greedy_res.data.cpu().numpy.data.cpu().numpy", "range", "range", "collections.OrderedDict", "range", "numpy.repeat", "len", "len", "CiderD_scorer.compute_score", "print", "Bleu_scorer.compute_score", "numpy.array", "print", "gen_result.data.cpu().numpy.data.cpu", "greedy_res.data.cpu().numpy.data.cpu", "rewards.array_to_str", "rewards.array_to_str", "rewards.array_to_str", "range", "range", "range", "range", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.rewards.array_to_str", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.rewards.array_to_str", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.rewards.array_to_str"], ["", "def", "get_self_critical_reward", "(", "greedy_res", ",", "data_gts", ",", "gen_result", ",", "opt", ")", ":", "\n", "    ", "batch_size", "=", "gen_result", ".", "size", "(", "0", ")", "# batch_size = sample_size * seq_per_img", "\n", "seq_per_img", "=", "batch_size", "//", "len", "(", "data_gts", ")", "\n", "\n", "res", "=", "OrderedDict", "(", ")", "\n", "\n", "gen_result", "=", "gen_result", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "greedy_res", "=", "greedy_res", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "res", "[", "i", "]", "=", "[", "array_to_str", "(", "gen_result", "[", "i", "]", ")", "]", "\n", "", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "res", "[", "batch_size", "+", "i", "]", "=", "[", "array_to_str", "(", "greedy_res", "[", "i", "]", ")", "]", "\n", "\n", "", "gts", "=", "OrderedDict", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "data_gts", ")", ")", ":", "\n", "        ", "gts", "[", "i", "]", "=", "[", "array_to_str", "(", "data_gts", "[", "i", "]", "[", "j", "]", ")", "for", "j", "in", "range", "(", "len", "(", "data_gts", "[", "i", "]", ")", ")", "]", "\n", "\n", "", "res_", "=", "[", "{", "'image_id'", ":", "i", ",", "'caption'", ":", "res", "[", "i", "]", "}", "for", "i", "in", "range", "(", "2", "*", "batch_size", ")", "]", "\n", "res__", "=", "{", "i", ":", "res", "[", "i", "]", "for", "i", "in", "range", "(", "2", "*", "batch_size", ")", "}", "\n", "gts", "=", "{", "i", ":", "gts", "[", "i", "%", "batch_size", "//", "seq_per_img", "]", "for", "i", "in", "range", "(", "2", "*", "batch_size", ")", "}", "\n", "if", "opt", ".", "cider_reward_weight", ">", "0", ":", "\n", "        ", "_", ",", "cider_scores", "=", "CiderD_scorer", ".", "compute_score", "(", "gts", ",", "res_", ")", "\n", "print", "(", "'Cider scores:'", ",", "_", ")", "\n", "", "else", ":", "\n", "        ", "cider_scores", "=", "0", "\n", "", "if", "opt", ".", "bleu_reward_weight", ">", "0", ":", "\n", "        ", "_", ",", "bleu_scores", "=", "Bleu_scorer", ".", "compute_score", "(", "gts", ",", "res__", ")", "\n", "bleu_scores", "=", "np", ".", "array", "(", "bleu_scores", "[", "3", "]", ")", "\n", "print", "(", "'Bleu scores:'", ",", "_", "[", "3", "]", ")", "\n", "", "else", ":", "\n", "        ", "bleu_scores", "=", "0", "\n", "", "scores", "=", "opt", ".", "cider_reward_weight", "*", "cider_scores", "+", "opt", ".", "bleu_reward_weight", "*", "bleu_scores", "\n", "\n", "scores", "=", "scores", "[", ":", "batch_size", "]", "-", "scores", "[", "batch_size", ":", "]", "\n", "\n", "rewards", "=", "np", ".", "repeat", "(", "scores", "[", ":", ",", "np", ".", "newaxis", "]", ",", "gen_result", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "\n", "return", "rewards", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.RewardCriterion.__init__": [[87, 89], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.RewardCriterion.forward": [[90, 99], ["to_contiguous().view", "to_contiguous().view", "to_contiguous().view", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "utils.to_contiguous", "utils.to_contiguous", "utils.to_contiguous", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "to_contiguous().view.new().fill_", "to_contiguous().view.new", "to_contiguous().view.size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.to_contiguous", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.to_contiguous", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.to_contiguous", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.LanguageModelCriterion.__init__": [[101, 103], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.LanguageModelCriterion.forward": [[104, 113], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "input.gather().squeeze", "input.size", "input.size", "input.gather", "target.unsqueeze"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.LabelSmoothing.__init__": [[116, 124], ["torch.Module.__init__", "torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.LabelSmoothing.forward": [[125, 145], ["to_contiguous().view", "to_contiguous().view", "to_contiguous().view", "to_contiguous().view.size", "to_contiguous().view.data.clone", "to_contiguous().view.data.clone.fill_", "to_contiguous().view.data.clone.scatter_", "to_contiguous().view.size", "to_contiguous().view.data.unsqueeze", "to_contiguous().view.sum", "utils.to_contiguous", "utils.to_contiguous", "utils.to_contiguous", "to_contiguous().view.size", "to_contiguous().view.size", "utils.LabelSmoothing.criterion().sum", "utils.LabelSmoothing.criterion"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.to_contiguous", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.to_contiguous", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.to_contiguous"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.NoamOpt.__init__": [[205, 212], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.NoamOpt.step": [[213, 221], ["utils.NoamOpt.rate", "utils.NoamOpt.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.rate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.step"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.NoamOpt.rate": [[222, 229], ["min"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.NoamOpt.__getattr__": [[230, 232], ["getattr"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.__init__": [[235, 239], ["torch.lr_scheduler.ReduceLROnPlateau", "torch.lr_scheduler.ReduceLROnPlateau", "torch.lr_scheduler.ReduceLROnPlateau", "utils.get_lr"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.get_lr"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.step": [[240, 243], ["utils.ReduceLROnPlateau.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.step"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.scheduler_step": [[244, 247], ["utils.ReduceLROnPlateau.scheduler.step", "utils.get_lr"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.step", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.get_lr"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict": [[248, 252], ["utils.ReduceLROnPlateau.scheduler.state_dict", "utils.ReduceLROnPlateau.optimizer.state_dict"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict": [[253, 263], ["utils.ReduceLROnPlateau.optimizer.load_state_dict", "utils.set_lr", "utils.ReduceLROnPlateau.scheduler.load_state_dict", "utils.ReduceLROnPlateau.optimizer.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.set_lr", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.rate": [[265, 272], ["min"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.__getattr__": [[273, 275], ["getattr"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.pickle_load": [[18, 28], ["six.moves.cPickle.load", "six.moves.cPickle.load"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.pickle_dump": [[30, 41], ["six.moves.cPickle.dump", "six.moves.cPickle.dump"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.if_use_feat": [[43, 54], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.decode_sequence": [[56, 79], ["seq.size", "range", "range", "int", "out.append", "os.getenv", "txt.split", "range", "txt.replace", "len", "str", "len", "ix.item"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.to_contiguous": [[80, 85], ["tensor.is_contiguous", "tensor.contiguous"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.set_lr": [[146, 149], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.get_lr": [[150, 153], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.clip_gradient": [[154, 158], ["param.grad.data.clamp_"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.build_optimizer": [[159, 174], ["torch.RMSprop", "torch.Adagrad", "torch.SGD", "torch.SGD", "torch.SGD", "torch.Adam", "Exception"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.penalty_builder": [[176, 185], ["penalty_config.split", "float", "utils.length_wu", "utils.length_average"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.length_wu", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.length_average"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.length_wu": [[186, 195], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.length_average": [[196, 201], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.get_std_opt": [[276, 281], ["utils.NoamOpt", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "model.parameters"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet_utils.myResnet.__init__": [[6, 9], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "resnet", ")", ":", "\n", "        ", "super", "(", "myResnet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "resnet", "=", "resnet", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.resnet_utils.myResnet.forward": [[10, 27], ["img.unsqueeze", "resnet_utils.myResnet.resnet.conv1", "resnet_utils.myResnet.resnet.bn1", "resnet_utils.myResnet.resnet.relu", "resnet_utils.myResnet.resnet.maxpool", "resnet_utils.myResnet.resnet.layer1", "resnet_utils.myResnet.resnet.layer2", "resnet_utils.myResnet.resnet.layer3", "resnet_utils.myResnet.resnet.layer4", "resnet_utils.myResnet.mean().mean().squeeze", "torch.adaptive_avg_pool2d().squeeze().permute", "torch.adaptive_avg_pool2d().squeeze().permute", "torch.adaptive_avg_pool2d().squeeze().permute", "resnet_utils.myResnet.mean().mean", "torch.adaptive_avg_pool2d().squeeze", "torch.adaptive_avg_pool2d().squeeze", "torch.adaptive_avg_pool2d().squeeze", "resnet_utils.myResnet.mean", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img", ",", "att_size", "=", "14", ")", ":", "\n", "        ", "x", "=", "img", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "x", "=", "self", ".", "resnet", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "resnet", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "resnet", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "resnet", ".", "maxpool", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "resnet", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "resnet", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "resnet", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "resnet", ".", "layer4", "(", "x", ")", "\n", "\n", "fc", "=", "x", ".", "mean", "(", "3", ")", ".", "mean", "(", "2", ")", ".", "squeeze", "(", ")", "\n", "att", "=", "F", ".", "adaptive_avg_pool2d", "(", "x", ",", "[", "att_size", ",", "att_size", "]", ")", ".", "squeeze", "(", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "\n", "return", "fc", ",", "att", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.MCAN_VC.run.parse_args": [[13, 120], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.MCAN_VC.run.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "'''\n    Parse input arguments\n    '''", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'MCAN Args'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--RUN'", ",", "dest", "=", "'RUN_MODE'", ",", "\n", "choices", "=", "[", "'train'", ",", "'val'", ",", "'test'", "]", ",", "\n", "help", "=", "'{train, val, test}'", ",", "\n", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--MODEL'", ",", "dest", "=", "'MODEL'", ",", "\n", "choices", "=", "[", "'small'", ",", "'large'", "]", ",", "\n", "help", "=", "'{small, large}'", ",", "\n", "default", "=", "'small'", ",", "type", "=", "str", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--SPLIT'", ",", "dest", "=", "'TRAIN_SPLIT'", ",", "\n", "choices", "=", "[", "'train'", ",", "'train+val'", ",", "'train+val+vg'", "]", ",", "\n", "help", "=", "\"set training split, \"", "\n", "\"eg.'train', 'train+val+vg'\"", "\n", "\"set 'train' can trigger the \"", "\n", "\"eval after every epoch\"", ",", "\n", "type", "=", "str", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--EVAL_EE'", ",", "dest", "=", "'EVAL_EVERY_EPOCH'", ",", "\n", "help", "=", "'set True to evaluate the '", "\n", "'val split when an epoch finished'", "\n", "\"(only work when train with \"", "\n", "\"'train' split)\"", ",", "\n", "type", "=", "bool", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--SAVE_PRED'", ",", "dest", "=", "'TEST_SAVE_PRED'", ",", "\n", "help", "=", "'set True to save the '", "\n", "'prediction vectors'", "\n", "'(only work in testing)'", ",", "\n", "type", "=", "bool", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--BS'", ",", "dest", "=", "'BATCH_SIZE'", ",", "\n", "help", "=", "'batch size during training'", ",", "\n", "type", "=", "int", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--MAX_EPOCH'", ",", "dest", "=", "'MAX_EPOCH'", ",", "\n", "help", "=", "'max training epoch'", ",", "\n", "type", "=", "int", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--PRELOAD'", ",", "dest", "=", "'PRELOAD'", ",", "\n", "help", "=", "'pre-load the features into memory'", "\n", "'to increase the I/O speed'", ",", "\n", "type", "=", "bool", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--GPU'", ",", "dest", "=", "'GPU'", ",", "\n", "help", "=", "\"gpu select, eg.'0, 1, 2'\"", ",", "\n", "type", "=", "str", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--SEED'", ",", "dest", "=", "'SEED'", ",", "\n", "help", "=", "'fix random seed'", ",", "\n", "type", "=", "int", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--VERSION'", ",", "dest", "=", "'VERSION'", ",", "\n", "help", "=", "'version control'", ",", "\n", "type", "=", "str", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--RESUME'", ",", "dest", "=", "'RESUME'", ",", "\n", "help", "=", "'resume training'", ",", "\n", "type", "=", "bool", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--CKPT_V'", ",", "dest", "=", "'CKPT_VERSION'", ",", "\n", "help", "=", "'checkpoint version'", ",", "\n", "type", "=", "str", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--CKPT_E'", ",", "dest", "=", "'CKPT_EPOCH'", ",", "\n", "help", "=", "'checkpoint epoch'", ",", "\n", "type", "=", "int", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--CKPT_PATH'", ",", "dest", "=", "'CKPT_PATH'", ",", "\n", "help", "=", "'load checkpoint path, we '", "\n", "'recommend that you use '", "\n", "'CKPT_VERSION and CKPT_EPOCH '", "\n", "'instead'", ",", "\n", "type", "=", "str", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--ACCU'", ",", "dest", "=", "'GRAD_ACCU_STEPS'", ",", "\n", "help", "=", "'reduce gpu memory usage'", ",", "\n", "type", "=", "int", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--NW'", ",", "dest", "=", "'NUM_WORKERS'", ",", "\n", "help", "=", "'multithreaded loading'", ",", "\n", "type", "=", "int", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--PINM'", ",", "dest", "=", "'PIN_MEM'", ",", "\n", "help", "=", "'use pin memory'", ",", "\n", "type", "=", "bool", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--VERB'", ",", "dest", "=", "'VERBOSE'", ",", "\n", "help", "=", "'verbose print'", ",", "\n", "type", "=", "bool", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--DATA_PATH'", ",", "dest", "=", "'DATASET_PATH'", ",", "\n", "help", "=", "'vqav2 dataset root path'", ",", "\n", "type", "=", "str", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--FEAT_PATH'", ",", "dest", "=", "'FEATURE_PATH'", ",", "\n", "help", "=", "'bottom up features root path'", ",", "\n", "type", "=", "str", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cfgs.path_cfgs.PATH.__init__": [[10, 22], ["path_cfgs.PATH.init_path"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cfgs.path_cfgs.PATH.init_path"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "\n", "# vqav2 dataset root path", "\n", "        ", "self", ".", "DATASET_PATH", "=", "'./datasets/vqa/'", "\n", "\n", "# bottom up features root path", "\n", "self", ".", "FEATURE_PATH", "=", "'./datasets/coco_extract/'", "\n", "# The Up-Down Feature and VC Feature Path, Added by Tan Wang", "\n", "self", ".", "FEATURE_PATH_BU", "=", "'/the/path/to/Updown/feature'", "\n", "self", ".", "FEATURE_PATH_VC", "=", "'/the/path/to/VC/feature'", "\n", "\n", "self", ".", "init_path", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cfgs.path_cfgs.PATH.init_path": [[24, 65], ["os.listdir", "os.mkdir", "os.listdir", "os.mkdir", "os.listdir", "os.mkdir", "os.listdir", "os.mkdir", "os.listdir", "os.mkdir"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir"], ["", "def", "init_path", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "IMG_FEAT_PATH", "=", "{", "\n", "'train'", ":", "self", ".", "FEATURE_PATH", "+", "'train2014/'", ",", "\n", "'val'", ":", "self", ".", "FEATURE_PATH", "+", "'val2014/'", ",", "\n", "'test'", ":", "self", ".", "FEATURE_PATH", "+", "'test2015/'", ",", "\n", "}", "\n", "\n", "self", ".", "QUESTION_PATH", "=", "{", "\n", "'train'", ":", "self", ".", "DATASET_PATH", "+", "'v2_OpenEnded_mscoco_train2014_questions.json'", ",", "\n", "'val'", ":", "self", ".", "DATASET_PATH", "+", "'v2_OpenEnded_mscoco_val2014_questions.json'", ",", "\n", "'test'", ":", "self", ".", "DATASET_PATH", "+", "'v2_OpenEnded_mscoco_test2015_questions.json'", ",", "\n", "'vg'", ":", "self", ".", "DATASET_PATH", "+", "'VG_questions.json'", ",", "\n", "}", "\n", "\n", "self", ".", "ANSWER_PATH", "=", "{", "\n", "'train'", ":", "self", ".", "DATASET_PATH", "+", "'v2_mscoco_train2014_annotations.json'", ",", "\n", "'val'", ":", "self", ".", "DATASET_PATH", "+", "'v2_mscoco_val2014_annotations.json'", ",", "\n", "'vg'", ":", "self", ".", "DATASET_PATH", "+", "'VG_annotations.json'", ",", "\n", "}", "\n", "\n", "self", ".", "RESULT_PATH", "=", "'./results/result_test/'", "\n", "self", ".", "PRED_PATH", "=", "'./results/pred/'", "\n", "self", ".", "CACHE_PATH", "=", "'./results/cache/'", "\n", "self", ".", "LOG_PATH", "=", "'./results/log/'", "\n", "self", ".", "CKPTS_PATH", "=", "'./ckpts/'", "\n", "\n", "if", "'result_test'", "not", "in", "os", ".", "listdir", "(", "'./results'", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "'./results/result_test'", ")", "\n", "\n", "", "if", "'pred'", "not", "in", "os", ".", "listdir", "(", "'./results'", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "'./results/pred'", ")", "\n", "\n", "", "if", "'cache'", "not", "in", "os", ".", "listdir", "(", "'./results'", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "'./results/cache'", ")", "\n", "\n", "", "if", "'log'", "not", "in", "os", ".", "listdir", "(", "'./results'", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "'./results/log'", ")", "\n", "\n", "", "if", "'ckpts'", "not", "in", "os", ".", "listdir", "(", "'./'", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "'./ckpts'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cfgs.path_cfgs.PATH.check_path": [[67, 87], ["print", "print", "print", "os.path.exists", "print", "exit", "os.path.exists", "print", "exit", "os.path.exists", "print", "exit"], "methods", ["None"], ["", "", "def", "check_path", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Checking dataset ...'", ")", "\n", "\n", "for", "mode", "in", "self", ".", "IMG_FEAT_PATH", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "IMG_FEAT_PATH", "[", "mode", "]", ")", ":", "\n", "                ", "print", "(", "self", ".", "IMG_FEAT_PATH", "[", "mode", "]", "+", "'NOT EXIST'", ")", "\n", "exit", "(", "-", "1", ")", "\n", "\n", "", "", "for", "mode", "in", "self", ".", "QUESTION_PATH", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "QUESTION_PATH", "[", "mode", "]", ")", ":", "\n", "                ", "print", "(", "self", ".", "QUESTION_PATH", "[", "mode", "]", "+", "'NOT EXIST'", ")", "\n", "exit", "(", "-", "1", ")", "\n", "\n", "", "", "for", "mode", "in", "self", ".", "ANSWER_PATH", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "ANSWER_PATH", "[", "mode", "]", ")", ":", "\n", "                ", "print", "(", "self", ".", "ANSWER_PATH", "[", "mode", "]", "+", "'NOT EXIST'", ")", "\n", "exit", "(", "-", "1", ")", "\n", "\n", "", "", "print", "(", "'Finished'", ")", "\n", "print", "(", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cfgs.base_cfgs.Cfgs.__init__": [[16, 168], ["cfgs.path_cfgs.PATH.__init__", "random.randint", "str"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Cfgs", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Set Devices", "\n", "# If use multi-gpu training, set e.g.'0, 1, 2' instead", "\n", "self", ".", "GPU", "=", "'0'", "\n", "\n", "# Set RNG For CPU And GPUs", "\n", "self", ".", "SEED", "=", "random", ".", "randint", "(", "0", ",", "99999999", ")", "\n", "\n", "# -------------------------", "\n", "# ---- Version Control ----", "\n", "# -------------------------", "\n", "\n", "# Define a specific name to start new training", "\n", "# self.VERSION = 'Anonymous_' + str(self.SEED)", "\n", "self", ".", "VERSION", "=", "str", "(", "self", ".", "SEED", ")", "\n", "\n", "# Resume training", "\n", "self", ".", "RESUME", "=", "False", "\n", "\n", "# Used in Resume training and testing", "\n", "self", ".", "CKPT_VERSION", "=", "self", ".", "VERSION", "\n", "self", ".", "CKPT_EPOCH", "=", "0", "\n", "\n", "# Absolutely checkpoint path, 'CKPT_VERSION' and 'CKPT_EPOCH' will be overridden", "\n", "self", ".", "CKPT_PATH", "=", "None", "\n", "\n", "# Print loss every step", "\n", "self", ".", "VERBOSE", "=", "True", "\n", "\n", "\n", "# ------------------------------", "\n", "# ---- Data Provider Params ----", "\n", "# ------------------------------", "\n", "\n", "# {'train', 'val', 'test'}", "\n", "self", ".", "RUN_MODE", "=", "'train'", "\n", "\n", "# Set True to evaluate offline", "\n", "self", ".", "EVAL_EVERY_EPOCH", "=", "True", "\n", "\n", "# Set True to save the prediction vector (Ensemble)", "\n", "self", ".", "TEST_SAVE_PRED", "=", "False", "\n", "\n", "# Pre-load the features into memory to increase the I/O speed", "\n", "self", ".", "PRELOAD", "=", "False", "\n", "\n", "# Define the 'train' 'val' 'test' data split", "\n", "# (EVAL_EVERY_EPOCH triggered when set {'train': 'train'})", "\n", "self", ".", "SPLIT", "=", "{", "\n", "'train'", ":", "''", ",", "\n", "'val'", ":", "'val'", ",", "\n", "'test'", ":", "'test'", ",", "\n", "}", "\n", "\n", "# A external method to set train split", "\n", "self", ".", "TRAIN_SPLIT", "=", "'train+val+vg'", "\n", "\n", "# Set True to use pretrained word embedding", "\n", "# (GloVe: spaCy https://spacy.io/)", "\n", "self", ".", "USE_GLOVE", "=", "True", "\n", "\n", "# Word embedding matrix size", "\n", "# (token size x WORD_EMBED_SIZE)", "\n", "self", ".", "WORD_EMBED_SIZE", "=", "300", "\n", "\n", "# Max length of question sentences", "\n", "self", ".", "MAX_TOKEN", "=", "14", "\n", "\n", "# Filter the answer by occurrence", "\n", "# self.ANS_FREQ = 8", "\n", "\n", "# Max length of extracted faster-rcnn 2048D features", "\n", "# (bottom-up and Top-down: https://github.com/peteanderson80/bottom-up-attention)", "\n", "self", ".", "IMG_FEAT_PAD_SIZE", "=", "100", "\n", "\n", "# Faster-rcnn 2048D features", "\n", "self", ".", "IMG_FEAT_SIZE", "=", "3072", "\n", "\n", "# Default training batch size: 64", "\n", "self", ".", "BATCH_SIZE", "=", "64", "\n", "\n", "# Multi-thread I/O", "\n", "self", ".", "NUM_WORKERS", "=", "6", "\n", "\n", "# Use pin memory", "\n", "# (Warning: pin memory can accelerate GPU loading but may", "\n", "# increase the CPU memory usage when NUM_WORKS is large)", "\n", "self", ".", "PIN_MEM", "=", "True", "\n", "\n", "# Large model can not training with batch size 64", "\n", "# Gradient accumulate can split batch to reduce gpu memory usage", "\n", "# (Warning: BATCH_SIZE should be divided by GRAD_ACCU_STEPS)", "\n", "self", ".", "GRAD_ACCU_STEPS", "=", "1", "\n", "\n", "# Set 'external': use external shuffle method to implement training shuffle", "\n", "# Set 'internal': use pytorch dataloader default shuffle method", "\n", "self", ".", "SHUFFLE_MODE", "=", "'external'", "\n", "\n", "\n", "# ------------------------", "\n", "# ---- Network Params ----", "\n", "# ------------------------", "\n", "\n", "# Model deeps", "\n", "# (Encoder and Decoder will be same deeps)", "\n", "self", ".", "LAYER", "=", "6", "\n", "\n", "# Model hidden size", "\n", "# (512 as default, bigger will be a sharp increase of gpu memory usage)", "\n", "self", ".", "HIDDEN_SIZE", "=", "512", "\n", "\n", "# Multi-head number in MCA layers", "\n", "# (Warning: HIDDEN_SIZE should be divided by MULTI_HEAD)", "\n", "self", ".", "MULTI_HEAD", "=", "8", "\n", "\n", "# Dropout rate for all dropout layers", "\n", "# (dropout can prevent overfitting\uff1a [Dropout: a simple way to prevent neural networks from overfitting])", "\n", "self", ".", "DROPOUT_R", "=", "0.1", "\n", "\n", "# MLP size in flatten layers", "\n", "self", ".", "FLAT_MLP_SIZE", "=", "512", "\n", "\n", "# Flatten the last hidden to vector with {n} attention glimpses", "\n", "self", ".", "FLAT_GLIMPSES", "=", "1", "\n", "self", ".", "FLAT_OUT_SIZE", "=", "1024", "\n", "\n", "\n", "# --------------------------", "\n", "# ---- Optimizer Params ----", "\n", "# --------------------------", "\n", "\n", "# The base learning rate", "\n", "self", ".", "LR_BASE", "=", "0.0001", "\n", "\n", "# Learning rate decay ratio", "\n", "self", ".", "LR_DECAY_R", "=", "0.2", "\n", "\n", "# Learning rate decay at {x, y, z...} epoch", "\n", "self", ".", "LR_DECAY_LIST", "=", "[", "10", ",", "12", "]", "\n", "\n", "# Max training epoch", "\n", "self", ".", "MAX_EPOCH", "=", "13", "\n", "\n", "# Gradient clip", "\n", "# (default: -1 means not using)", "\n", "self", ".", "GRAD_NORM_CLIP", "=", "-", "1", "\n", "\n", "# Adam optimizer betas and eps", "\n", "self", ".", "OPT_BETAS", "=", "(", "0.9", ",", "0.98", ")", "\n", "self", ".", "OPT_EPS", "=", "1e-9", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cfgs.base_cfgs.Cfgs.parse_to_dict": [[170, 178], ["dir", "arg.startswith", "isinstance", "getattr", "getattr", "getattr"], "methods", ["None"], ["", "def", "parse_to_dict", "(", "self", ",", "args", ")", ":", "\n", "        ", "args_dict", "=", "{", "}", "\n", "for", "arg", "in", "dir", "(", "args", ")", ":", "\n", "            ", "if", "not", "arg", ".", "startswith", "(", "'_'", ")", "and", "not", "isinstance", "(", "getattr", "(", "args", ",", "arg", ")", ",", "MethodType", ")", ":", "\n", "                ", "if", "getattr", "(", "args", ",", "arg", ")", "is", "not", "None", ":", "\n", "                    ", "args_dict", "[", "arg", "]", "=", "getattr", "(", "args", ",", "arg", ")", "\n", "\n", "", "", "", "return", "args_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cfgs.base_cfgs.Cfgs.add_args": [[180, 183], ["setattr"], "methods", ["None"], ["", "def", "add_args", "(", "self", ",", "args_dict", ")", ":", "\n", "        ", "for", "arg", "in", "args_dict", ":", "\n", "            ", "setattr", "(", "self", ",", "arg", ",", "args_dict", "[", "arg", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cfgs.base_cfgs.Cfgs.proc": [[185, 240], ["len", "torch.set_num_threads", "torch.manual_seed", "numpy.random.seed", "random.seed", "int", "int", "int", "int", "base_cfgs.Cfgs.GPU.split", "torch.cuda.manual_seed", "torch.cuda.manual_seed_all", "print", "range", "str", "base_cfgs.Cfgs.SPLIT[].split", "random.randint", "base_cfgs.Cfgs.CKPT_PATH.split"], "methods", ["None"], ["", "", "def", "proc", "(", "self", ")", ":", "\n", "        ", "assert", "self", ".", "RUN_MODE", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", "\n", "\n", "# ------------ Devices setup", "\n", "os", ".", "environ", "[", "'CUDA_VISIBLE_DEVICES'", "]", "=", "self", ".", "GPU", "\n", "self", ".", "N_GPU", "=", "len", "(", "self", ".", "GPU", ".", "split", "(", "','", ")", ")", "\n", "self", ".", "DEVICES", "=", "[", "_", "for", "_", "in", "range", "(", "self", ".", "N_GPU", ")", "]", "\n", "torch", ".", "set_num_threads", "(", "2", ")", "\n", "\n", "\n", "# ------------ Seed setup", "\n", "# fix pytorch seed", "\n", "torch", ".", "manual_seed", "(", "self", ".", "SEED", ")", "\n", "if", "self", ".", "N_GPU", "<", "2", ":", "\n", "            ", "torch", ".", "cuda", ".", "manual_seed", "(", "self", ".", "SEED", ")", "\n", "", "else", ":", "\n", "            ", "torch", ".", "cuda", ".", "manual_seed_all", "(", "self", ".", "SEED", ")", "\n", "", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "\n", "# fix numpy seed", "\n", "np", ".", "random", ".", "seed", "(", "self", ".", "SEED", ")", "\n", "\n", "# fix random seed", "\n", "random", ".", "seed", "(", "self", ".", "SEED", ")", "\n", "\n", "if", "self", ".", "CKPT_PATH", "is", "not", "None", ":", "\n", "            ", "print", "(", "'Warning: you are now using CKPT_PATH args, '", "\n", "'CKPT_VERSION and CKPT_EPOCH will not work'", ")", "\n", "self", ".", "CKPT_VERSION", "=", "self", ".", "CKPT_PATH", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "+", "'_'", "+", "str", "(", "random", ".", "randint", "(", "0", ",", "99999999", ")", ")", "\n", "\n", "\n", "# ------------ Split setup", "\n", "", "self", ".", "SPLIT", "[", "'train'", "]", "=", "self", ".", "TRAIN_SPLIT", "\n", "if", "'val'", "in", "self", ".", "SPLIT", "[", "'train'", "]", ".", "split", "(", "'+'", ")", "or", "self", ".", "RUN_MODE", "not", "in", "[", "'train'", "]", ":", "\n", "            ", "self", ".", "EVAL_EVERY_EPOCH", "=", "False", "\n", "\n", "", "if", "self", ".", "RUN_MODE", "not", "in", "[", "'test'", "]", ":", "\n", "            ", "self", ".", "TEST_SAVE_PRED", "=", "False", "\n", "\n", "\n", "# ------------ Gradient accumulate setup", "\n", "", "assert", "self", ".", "BATCH_SIZE", "%", "self", ".", "GRAD_ACCU_STEPS", "==", "0", "\n", "self", ".", "SUB_BATCH_SIZE", "=", "int", "(", "self", ".", "BATCH_SIZE", "/", "self", ".", "GRAD_ACCU_STEPS", ")", "\n", "\n", "# Use a small eval batch will reduce gpu memory usage", "\n", "self", ".", "EVAL_BATCH_SIZE", "=", "int", "(", "self", ".", "SUB_BATCH_SIZE", "/", "2", ")", "\n", "\n", "\n", "# ------------ Networks setup", "\n", "# FeedForwardNet size in every MCA layer", "\n", "self", ".", "FF_SIZE", "=", "int", "(", "self", ".", "HIDDEN_SIZE", "*", "4", ")", "\n", "\n", "# A pipe line hidden size in attention compute", "\n", "assert", "self", ".", "HIDDEN_SIZE", "%", "self", ".", "MULTI_HEAD", "==", "0", "\n", "self", ".", "HIDDEN_SIZE_HEAD", "=", "int", "(", "self", ".", "HIDDEN_SIZE", "/", "self", ".", "MULTI_HEAD", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.cfgs.base_cfgs.Cfgs.__str__": [[242, 248], ["dir", "print", "attr.startswith", "isinstance", "getattr", "getattr"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "for", "attr", "in", "dir", "(", "self", ")", ":", "\n", "            ", "if", "not", "attr", ".", "startswith", "(", "'__'", ")", "and", "not", "isinstance", "(", "getattr", "(", "self", ",", "attr", ")", ",", "MethodType", ")", ":", "\n", "                ", "print", "(", "'{ %-17s }->'", "%", "attr", ",", "getattr", "(", "self", ",", "attr", ")", ")", "\n", "\n", "", "", "return", "''", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.__init__": [[21, 34], ["print", "core.data.load_data.DataSet", "copy.deepcopy", "setattr", "print", "core.data.load_data.DataSet"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "__C", ")", ":", "\n", "        ", "self", ".", "__C", "=", "__C", "\n", "\n", "print", "(", "'Loading training set ........'", ")", "\n", "self", ".", "dataset", "=", "DataSet", "(", "__C", ")", "\n", "\n", "self", ".", "dataset_eval", "=", "None", "\n", "if", "__C", ".", "EVAL_EVERY_EPOCH", ":", "\n", "            ", "__C_eval", "=", "copy", ".", "deepcopy", "(", "__C", ")", "\n", "setattr", "(", "__C_eval", ",", "'RUN_MODE'", ",", "'val'", ")", "\n", "\n", "print", "(", "'Loading validation set for per-epoch evaluation ........'", ")", "\n", "self", ".", "dataset_eval", "=", "DataSet", "(", "__C_eval", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.train": [[36, 280], ["core.model.net.Net", "torch.DataParallel.cuda", "torch.DataParallel.train", "torch.nn.BCELoss().cuda", "torch.nn.BCELoss().cuda", "torch.nn.BCELoss().cuda", "torch.nn.BCELoss().cuda", "torch.nn.BCELoss().cuda", "torch.nn.BCELoss().cuda", "torch.nn.BCELoss().cuda", "torch.nn.BCELoss().cuda", "torch.nn.BCELoss().cuda", "list", "numpy.zeros", "range", "torch.DataParallel", "torch.DataParallel", "torch.DataParallel", "print", "print", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "print", "torch.DataParallel.load_state_dict", "core.model.optim.get_optim", "int", "core.model.optim.get_optim.optimizer.load_state_dict", "os.mkdir", "core.model.optim.get_optim", "torch.DataParallel.named_parameters", "len", "torch.DataLoader", "torch.DataLoader", "torch.DataLoader", "torch.DataLoader", "torch.DataLoader", "torch.DataLoader", "open", "open.write", "open.close", "time.time", "enumerate", "time.time", "print", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "open", "open.write", "open.close", "numpy.zeros", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "print", "os.listdir", "shutil.rmtree", "core.model.optim.adjust_lr", "core.data.data_utils.shuffle_list", "core.model.optim.get_optim.zero_grad", "img_feat_iter.cuda.cuda.cuda", "ques_ix_iter.cuda.cuda.cuda", "ans_iter.cuda.cuda.cuda", "range", "range", "core.model.optim.get_optim.step", "torch.DataParallel.state_dict", "core.model.optim.get_optim.optimizer.state_dict", "exec.Execution.eval", "len", "torch.DataParallel.", "torch.nn.BCELoss().cuda.", "torch.nn.BCELoss().cuda.", "torch.nn.BCELoss().cuda.", "torch.nn.BCELoss().cuda.backward", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "len", "int", "str", "datetime.datetime.now().strftime", "torch.nn.BCELoss().cuda.cpu().data.numpy", "print", "torch.DataParallel.parameters", "torch.norm().cpu().data.numpy", "torch.norm().cpu().data.numpy", "torch.norm().cpu().data.numpy", "torch.norm().cpu().data.numpy", "torch.norm().cpu().data.numpy", "torch.norm().cpu().data.numpy", "torch.norm().cpu().data.numpy", "torch.norm().cpu().data.numpy", "torch.norm().cpu().data.numpy", "str", "str", "torch.DataParallel.state_dict", "datetime.datetime.now", "torch.nn.BCELoss().cuda.cpu", "int", "torch.norm().cpu", "torch.norm().cpu", "torch.norm().cpu", "torch.norm().cpu", "torch.norm().cpu", "torch.norm().cpu", "torch.norm().cpu", "torch.norm().cpu", "torch.norm().cpu", "str", "torch.nn.BCELoss().cuda.cpu().data.numpy", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "str", "torch.nn.BCELoss().cuda.cpu"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.get_optim", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.get_optim", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.adjust_lr", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.data.data_utils.shuffle_list", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.zero_grad", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.step", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_func.DeformRoIPoolingFunction.backward", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict"], ["", "", "def", "train", "(", "self", ",", "dataset", ",", "dataset_eval", "=", "None", ")", ":", "\n", "\n", "# Obtain needed information", "\n", "        ", "data_size", "=", "dataset", ".", "data_size", "\n", "token_size", "=", "dataset", ".", "token_size", "\n", "ans_size", "=", "dataset", ".", "ans_size", "\n", "pretrained_emb", "=", "dataset", ".", "pretrained_emb", "\n", "\n", "# Define the MCAN model", "\n", "net", "=", "Net", "(", "\n", "self", ".", "__C", ",", "\n", "pretrained_emb", ",", "\n", "token_size", ",", "\n", "ans_size", "\n", ")", "\n", "net", ".", "cuda", "(", ")", "\n", "net", ".", "train", "(", ")", "\n", "\n", "# Define the multi-gpu training if needed", "\n", "if", "self", ".", "__C", ".", "N_GPU", ">", "1", ":", "\n", "            ", "net", "=", "nn", ".", "DataParallel", "(", "net", ",", "device_ids", "=", "self", ".", "__C", ".", "DEVICES", ")", "\n", "\n", "# Define the binary cross entropy loss", "\n", "# loss_fn = torch.nn.BCELoss(size_average=False).cuda()", "\n", "", "loss_fn", "=", "torch", ".", "nn", ".", "BCELoss", "(", "reduction", "=", "'sum'", ")", ".", "cuda", "(", ")", "\n", "\n", "# Load checkpoint if resume training", "\n", "if", "self", ".", "__C", ".", "RESUME", ":", "\n", "            ", "print", "(", "' ========== Resume training'", ")", "\n", "\n", "if", "self", ".", "__C", ".", "CKPT_PATH", "is", "not", "None", ":", "\n", "                ", "print", "(", "'Warning: you are now using CKPT_PATH args, '", "\n", "'CKPT_VERSION and CKPT_EPOCH will not work'", ")", "\n", "\n", "path", "=", "self", ".", "__C", ".", "CKPT_PATH", "\n", "", "else", ":", "\n", "                ", "path", "=", "self", ".", "__C", ".", "CKPTS_PATH", "+", "'ckpt_'", "+", "self", ".", "__C", ".", "CKPT_VERSION", "+", "'/epoch'", "+", "str", "(", "self", ".", "__C", ".", "CKPT_EPOCH", ")", "+", "'.pkl'", "\n", "\n", "# Load the network parameters", "\n", "", "print", "(", "'Loading ckpt {}'", ".", "format", "(", "path", ")", ")", "\n", "ckpt", "=", "torch", ".", "load", "(", "path", ")", "\n", "print", "(", "'Finish!'", ")", "\n", "net", ".", "load_state_dict", "(", "ckpt", "[", "'state_dict'", "]", ")", "\n", "\n", "# Load the optimizer paramters", "\n", "optim", "=", "get_optim", "(", "self", ".", "__C", ",", "net", ",", "data_size", ",", "ckpt", "[", "'lr_base'", "]", ")", "\n", "optim", ".", "_step", "=", "int", "(", "data_size", "/", "self", ".", "__C", ".", "BATCH_SIZE", "*", "self", ".", "__C", ".", "CKPT_EPOCH", ")", "\n", "optim", ".", "optimizer", ".", "load_state_dict", "(", "ckpt", "[", "'optimizer'", "]", ")", "\n", "\n", "start_epoch", "=", "self", ".", "__C", ".", "CKPT_EPOCH", "\n", "\n", "", "else", ":", "\n", "            ", "if", "(", "'ckpt_'", "+", "self", ".", "__C", ".", "VERSION", ")", "in", "os", ".", "listdir", "(", "self", ".", "__C", ".", "CKPTS_PATH", ")", ":", "\n", "                ", "shutil", ".", "rmtree", "(", "self", ".", "__C", ".", "CKPTS_PATH", "+", "'ckpt_'", "+", "self", ".", "__C", ".", "VERSION", ")", "\n", "\n", "", "os", ".", "mkdir", "(", "self", ".", "__C", ".", "CKPTS_PATH", "+", "'ckpt_'", "+", "self", ".", "__C", ".", "VERSION", ")", "\n", "\n", "optim", "=", "get_optim", "(", "self", ".", "__C", ",", "net", ",", "data_size", ")", "\n", "start_epoch", "=", "0", "\n", "\n", "", "loss_sum", "=", "0", "\n", "named_params", "=", "list", "(", "net", ".", "named_parameters", "(", ")", ")", "\n", "grad_norm", "=", "np", ".", "zeros", "(", "len", "(", "named_params", ")", ")", "\n", "\n", "# Define multi-thread dataloader", "\n", "if", "self", ".", "__C", ".", "SHUFFLE_MODE", "in", "[", "'external'", "]", ":", "\n", "            ", "dataloader", "=", "Data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "batch_size", "=", "self", ".", "__C", ".", "BATCH_SIZE", ",", "\n", "shuffle", "=", "False", ",", "\n", "num_workers", "=", "self", ".", "__C", ".", "NUM_WORKERS", ",", "\n", "pin_memory", "=", "self", ".", "__C", ".", "PIN_MEM", ",", "\n", "drop_last", "=", "True", "\n", ")", "\n", "", "else", ":", "\n", "            ", "dataloader", "=", "Data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "batch_size", "=", "self", ".", "__C", ".", "BATCH_SIZE", ",", "\n", "shuffle", "=", "True", ",", "\n", "num_workers", "=", "self", ".", "__C", ".", "NUM_WORKERS", ",", "\n", "pin_memory", "=", "self", ".", "__C", ".", "PIN_MEM", ",", "\n", "drop_last", "=", "True", "\n", ")", "\n", "\n", "# Training script", "\n", "", "for", "epoch", "in", "range", "(", "start_epoch", ",", "self", ".", "__C", ".", "MAX_EPOCH", ")", ":", "\n", "\n", "# Save log information", "\n", "            ", "logfile", "=", "open", "(", "\n", "self", ".", "__C", ".", "LOG_PATH", "+", "\n", "'log_run_'", "+", "self", ".", "__C", ".", "VERSION", "+", "'.txt'", ",", "\n", "'a+'", "\n", ")", "\n", "logfile", ".", "write", "(", "\n", "'nowTime: '", "+", "\n", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "'%Y-%m-%d %H:%M:%S'", ")", "+", "\n", "'\\n'", "\n", ")", "\n", "logfile", ".", "close", "(", ")", "\n", "\n", "# Learning Rate Decay", "\n", "if", "epoch", "in", "self", ".", "__C", ".", "LR_DECAY_LIST", ":", "\n", "                ", "adjust_lr", "(", "optim", ",", "self", ".", "__C", ".", "LR_DECAY_R", ")", "\n", "\n", "# Externally shuffle", "\n", "", "if", "self", ".", "__C", ".", "SHUFFLE_MODE", "==", "'external'", ":", "\n", "                ", "shuffle_list", "(", "dataset", ".", "ans_list", ")", "\n", "\n", "", "time_start", "=", "time", ".", "time", "(", ")", "\n", "# Iteration", "\n", "for", "step", ",", "(", "\n", "img_feat_iter", ",", "\n", "ques_ix_iter", ",", "\n", "ans_iter", "\n", ")", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "\n", "                ", "optim", ".", "zero_grad", "(", ")", "\n", "\n", "img_feat_iter", "=", "img_feat_iter", ".", "cuda", "(", ")", "\n", "ques_ix_iter", "=", "ques_ix_iter", ".", "cuda", "(", ")", "\n", "ans_iter", "=", "ans_iter", ".", "cuda", "(", ")", "\n", "\n", "for", "accu_step", "in", "range", "(", "self", ".", "__C", ".", "GRAD_ACCU_STEPS", ")", ":", "\n", "\n", "                    ", "sub_img_feat_iter", "=", "img_feat_iter", "[", "accu_step", "*", "self", ".", "__C", ".", "SUB_BATCH_SIZE", ":", "\n", "(", "accu_step", "+", "1", ")", "*", "self", ".", "__C", ".", "SUB_BATCH_SIZE", "]", "\n", "sub_ques_ix_iter", "=", "ques_ix_iter", "[", "accu_step", "*", "self", ".", "__C", ".", "SUB_BATCH_SIZE", ":", "\n", "(", "accu_step", "+", "1", ")", "*", "self", ".", "__C", ".", "SUB_BATCH_SIZE", "]", "\n", "sub_ans_iter", "=", "ans_iter", "[", "accu_step", "*", "self", ".", "__C", ".", "SUB_BATCH_SIZE", ":", "\n", "(", "accu_step", "+", "1", ")", "*", "self", ".", "__C", ".", "SUB_BATCH_SIZE", "]", "\n", "\n", "\n", "pred", "=", "net", "(", "\n", "sub_img_feat_iter", ",", "\n", "sub_ques_ix_iter", "\n", ")", "\n", "\n", "loss", "=", "loss_fn", "(", "pred", ",", "sub_ans_iter", ")", "\n", "loss", "/=", "self", ".", "__C", ".", "GRAD_ACCU_STEPS", "\n", "loss", ".", "backward", "(", ")", "\n", "loss_sum", "+=", "loss", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "*", "self", ".", "__C", ".", "GRAD_ACCU_STEPS", "\n", "\n", "if", "self", ".", "__C", ".", "VERBOSE", ":", "\n", "                        ", "if", "dataset_eval", "is", "not", "None", ":", "\n", "                            ", "mode_str", "=", "self", ".", "__C", ".", "SPLIT", "[", "'train'", "]", "+", "'->'", "+", "self", ".", "__C", ".", "SPLIT", "[", "'val'", "]", "\n", "", "else", ":", "\n", "                            ", "mode_str", "=", "self", ".", "__C", ".", "SPLIT", "[", "'train'", "]", "+", "'->'", "+", "self", ".", "__C", ".", "SPLIT", "[", "'test'", "]", "\n", "\n", "", "print", "(", "\"\\r[version %s][epoch %2d][step %4d/%4d][%s] loss: %.4f, lr: %.2e\"", "%", "(", "\n", "self", ".", "__C", ".", "VERSION", ",", "\n", "epoch", "+", "1", ",", "\n", "step", ",", "\n", "int", "(", "data_size", "/", "self", ".", "__C", ".", "BATCH_SIZE", ")", ",", "\n", "mode_str", ",", "\n", "loss", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "/", "self", ".", "__C", ".", "SUB_BATCH_SIZE", ",", "\n", "optim", ".", "_rate", "\n", ")", ",", "end", "=", "'          '", ")", "\n", "\n", "# Gradient norm clipping", "\n", "", "", "if", "self", ".", "__C", ".", "GRAD_NORM_CLIP", ">", "0", ":", "\n", "                    ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "\n", "net", ".", "parameters", "(", ")", ",", "\n", "self", ".", "__C", ".", "GRAD_NORM_CLIP", "\n", ")", "\n", "\n", "# Save the gradient information", "\n", "", "for", "name", "in", "range", "(", "len", "(", "named_params", ")", ")", ":", "\n", "                    ", "norm_v", "=", "torch", ".", "norm", "(", "named_params", "[", "name", "]", "[", "1", "]", ".", "grad", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "if", "named_params", "[", "name", "]", "[", "1", "]", ".", "grad", "is", "not", "None", "else", "0", "\n", "grad_norm", "[", "name", "]", "+=", "norm_v", "*", "self", ".", "__C", ".", "GRAD_ACCU_STEPS", "\n", "# print('Param %-3s Name %-80s Grad_Norm %-20s'%", "\n", "#       (str(grad_wt),", "\n", "#        params[grad_wt][0],", "\n", "#        str(norm_v)))", "\n", "\n", "", "optim", ".", "step", "(", ")", "\n", "\n", "", "time_end", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'Finished in {}s'", ".", "format", "(", "int", "(", "time_end", "-", "time_start", ")", ")", ")", "\n", "\n", "# print('')", "\n", "epoch_finish", "=", "epoch", "+", "1", "\n", "\n", "# Save checkpoint", "\n", "state", "=", "{", "\n", "'state_dict'", ":", "net", ".", "state_dict", "(", ")", ",", "\n", "'optimizer'", ":", "optim", ".", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'lr_base'", ":", "optim", ".", "lr_base", "\n", "}", "\n", "torch", ".", "save", "(", "\n", "state", ",", "\n", "self", ".", "__C", ".", "CKPTS_PATH", "+", "\n", "'ckpt_'", "+", "self", ".", "__C", ".", "VERSION", "+", "\n", "'/epoch'", "+", "str", "(", "epoch_finish", ")", "+", "\n", "'.pkl'", "\n", ")", "\n", "\n", "# Logging", "\n", "logfile", "=", "open", "(", "\n", "self", ".", "__C", ".", "LOG_PATH", "+", "\n", "'log_run_'", "+", "self", ".", "__C", ".", "VERSION", "+", "'.txt'", ",", "\n", "'a+'", "\n", ")", "\n", "logfile", ".", "write", "(", "\n", "'epoch = '", "+", "str", "(", "epoch_finish", ")", "+", "\n", "'  loss = '", "+", "str", "(", "loss_sum", "/", "data_size", ")", "+", "\n", "'\\n'", "+", "\n", "'lr = '", "+", "str", "(", "optim", ".", "_rate", ")", "+", "\n", "'\\n\\n'", "\n", ")", "\n", "logfile", ".", "close", "(", ")", "\n", "\n", "# Eval after every epoch", "\n", "if", "dataset_eval", "is", "not", "None", ":", "\n", "                ", "self", ".", "eval", "(", "\n", "dataset_eval", ",", "\n", "state_dict", "=", "net", ".", "state_dict", "(", ")", ",", "\n", "valid", "=", "True", "\n", ")", "\n", "\n", "# if self.__C.VERBOSE:", "\n", "#     logfile = open(", "\n", "#         self.__C.LOG_PATH +", "\n", "#         'log_run_' + self.__C.VERSION + '.txt',", "\n", "#         'a+'", "\n", "#     )", "\n", "#     for name in range(len(named_params)):", "\n", "#         logfile.write(", "\n", "#             'Param %-3s Name %-80s Grad_Norm %-25s\\n' % (", "\n", "#                 str(name),", "\n", "#                 named_params[name][0],", "\n", "#                 str(grad_norm[name] / data_size * self.__C.BATCH_SIZE)", "\n", "#             )", "\n", "#         )", "\n", "#     logfile.write('\\n')", "\n", "#     logfile.close()", "\n", "\n", "", "loss_sum", "=", "0", "\n", "grad_norm", "=", "np", ".", "zeros", "(", "len", "(", "named_params", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval": [[283, 504], ["core.model.net.Net", "torch.DataParallel.cuda", "torch.DataParallel.eval", "torch.DataParallel.load_state_dict", "torch.DataLoader", "torch.DataLoader", "torch.DataLoader", "enumerate", "print", "numpy.array().reshape", "json.dump", "print", "print", "print", "torch.DataParallel", "torch.DataParallel", "torch.DataParallel", "print", "img_feat_iter.cuda.cuda.cuda", "ques_ix_iter.cuda.cuda.cuda", "torch.DataParallel.", "nn.DataParallel.cpu().data.numpy", "numpy.argmax", "numpy.array().reshape.append", "print", "open", "print", "numpy.array().reshape", "pickle.dump", "utils.vqa.VQA", "utils.vqa.VQA.loadRes", "utils.vqaEval.VQAEval", "utils.vqaEval.VQAEval.evaluate", "print", "print", "print", "print", "open.write", "open.write", "open.close", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "numpy.pad", "numpy.array().reshape.append", "numpy.array", "int", "range", "open", "print", "print", "open", "print", "open", "open.write", "str", "numpy.pad", "qid_list.__len__", "numpy.array", "int", "range", "int", "nn.DataParallel.cpu", "str", "str", "str", "qid_list.__len__"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.loadRes", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.evaluation.__init__.evaluate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__"], ["", "", "def", "eval", "(", "self", ",", "dataset", ",", "state_dict", "=", "None", ",", "valid", "=", "False", ")", ":", "\n", "\n", "# Load parameters", "\n", "        ", "if", "self", ".", "__C", ".", "CKPT_PATH", "is", "not", "None", ":", "\n", "            ", "print", "(", "'Warning: you are now using CKPT_PATH args, '", "\n", "'CKPT_VERSION and CKPT_EPOCH will not work'", ")", "\n", "\n", "path", "=", "self", ".", "__C", ".", "CKPT_PATH", "\n", "", "else", ":", "\n", "            ", "path", "=", "self", ".", "__C", ".", "CKPTS_PATH", "+", "'ckpt_'", "+", "self", ".", "__C", ".", "CKPT_VERSION", "+", "'/epoch'", "+", "str", "(", "self", ".", "__C", ".", "CKPT_EPOCH", ")", "+", "'.pkl'", "\n", "\n", "", "val_ckpt_flag", "=", "False", "\n", "if", "state_dict", "is", "None", ":", "\n", "            ", "val_ckpt_flag", "=", "True", "\n", "print", "(", "'Loading ckpt {}'", ".", "format", "(", "path", ")", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ")", "[", "'state_dict'", "]", "\n", "print", "(", "'Finish!'", ")", "\n", "\n", "# Store the prediction list", "\n", "", "qid_list", "=", "[", "ques", "[", "'question_id'", "]", "for", "ques", "in", "dataset", ".", "ques_list", "]", "\n", "ans_ix_list", "=", "[", "]", "\n", "pred_list", "=", "[", "]", "\n", "\n", "data_size", "=", "dataset", ".", "data_size", "\n", "token_size", "=", "dataset", ".", "token_size", "\n", "ans_size", "=", "dataset", ".", "ans_size", "\n", "pretrained_emb", "=", "dataset", ".", "pretrained_emb", "\n", "\n", "net", "=", "Net", "(", "\n", "self", ".", "__C", ",", "\n", "pretrained_emb", ",", "\n", "token_size", ",", "\n", "ans_size", "\n", ")", "\n", "net", ".", "cuda", "(", ")", "\n", "net", ".", "eval", "(", ")", "\n", "\n", "if", "self", ".", "__C", ".", "N_GPU", ">", "1", ":", "\n", "            ", "net", "=", "nn", ".", "DataParallel", "(", "net", ",", "device_ids", "=", "self", ".", "__C", ".", "DEVICES", ")", "\n", "\n", "", "net", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n", "dataloader", "=", "Data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "batch_size", "=", "self", ".", "__C", ".", "EVAL_BATCH_SIZE", ",", "\n", "shuffle", "=", "False", ",", "\n", "num_workers", "=", "self", ".", "__C", ".", "NUM_WORKERS", ",", "\n", "pin_memory", "=", "True", "\n", ")", "\n", "\n", "for", "step", ",", "(", "\n", "img_feat_iter", ",", "\n", "ques_ix_iter", ",", "\n", "ans_iter", "\n", ")", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "print", "(", "\"\\rEvaluation: [step %4d/%4d]\"", "%", "(", "\n", "step", ",", "\n", "int", "(", "data_size", "/", "self", ".", "__C", ".", "EVAL_BATCH_SIZE", ")", ",", "\n", ")", ",", "end", "=", "'          '", ")", "\n", "\n", "img_feat_iter", "=", "img_feat_iter", ".", "cuda", "(", ")", "\n", "ques_ix_iter", "=", "ques_ix_iter", ".", "cuda", "(", ")", "\n", "\n", "pred", "=", "net", "(", "\n", "img_feat_iter", ",", "\n", "ques_ix_iter", "\n", ")", "\n", "pred_np", "=", "pred", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "pred_argmax", "=", "np", ".", "argmax", "(", "pred_np", ",", "axis", "=", "1", ")", "\n", "\n", "# Save the answer index", "\n", "if", "pred_argmax", ".", "shape", "[", "0", "]", "!=", "self", ".", "__C", ".", "EVAL_BATCH_SIZE", ":", "\n", "                ", "pred_argmax", "=", "np", ".", "pad", "(", "\n", "pred_argmax", ",", "\n", "(", "0", ",", "self", ".", "__C", ".", "EVAL_BATCH_SIZE", "-", "pred_argmax", ".", "shape", "[", "0", "]", ")", ",", "\n", "mode", "=", "'constant'", ",", "\n", "constant_values", "=", "-", "1", "\n", ")", "\n", "\n", "", "ans_ix_list", ".", "append", "(", "pred_argmax", ")", "\n", "\n", "# Save the whole prediction vector", "\n", "if", "self", ".", "__C", ".", "TEST_SAVE_PRED", ":", "\n", "                ", "if", "pred_np", ".", "shape", "[", "0", "]", "!=", "self", ".", "__C", ".", "EVAL_BATCH_SIZE", ":", "\n", "                    ", "pred_np", "=", "np", ".", "pad", "(", "\n", "pred_np", ",", "\n", "(", "(", "0", ",", "self", ".", "__C", ".", "EVAL_BATCH_SIZE", "-", "pred_np", ".", "shape", "[", "0", "]", ")", ",", "(", "0", ",", "0", ")", ")", ",", "\n", "mode", "=", "'constant'", ",", "\n", "constant_values", "=", "-", "1", "\n", ")", "\n", "\n", "", "pred_list", ".", "append", "(", "pred_np", ")", "\n", "\n", "", "", "print", "(", "''", ")", "\n", "ans_ix_list", "=", "np", ".", "array", "(", "ans_ix_list", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "result", "=", "[", "{", "\n", "'answer'", ":", "dataset", ".", "ix_to_ans", "[", "str", "(", "ans_ix_list", "[", "qix", "]", ")", "]", ",", "# ix_to_ans(load with json) keys are type of string", "\n", "'question_id'", ":", "int", "(", "qid_list", "[", "qix", "]", ")", "\n", "}", "for", "qix", "in", "range", "(", "qid_list", ".", "__len__", "(", ")", ")", "]", "\n", "\n", "# Write the results to result file", "\n", "if", "valid", ":", "\n", "            ", "if", "val_ckpt_flag", ":", "\n", "                ", "result_eval_file", "=", "self", ".", "__C", ".", "CACHE_PATH", "+", "'result_run_'", "+", "self", ".", "__C", ".", "CKPT_VERSION", "+", "'.json'", "\n", "", "else", ":", "\n", "                ", "result_eval_file", "=", "self", ".", "__C", ".", "CACHE_PATH", "+", "'result_run_'", "+", "self", ".", "__C", ".", "VERSION", "+", "'.json'", "\n", "\n", "", "", "else", ":", "\n", "            ", "if", "self", ".", "__C", ".", "CKPT_PATH", "is", "not", "None", ":", "\n", "                ", "result_eval_file", "=", "self", ".", "__C", ".", "RESULT_PATH", "+", "'result_run_'", "+", "self", ".", "__C", ".", "CKPT_VERSION", "+", "'.json'", "\n", "", "else", ":", "\n", "                ", "result_eval_file", "=", "self", ".", "__C", ".", "RESULT_PATH", "+", "'result_run_'", "+", "self", ".", "__C", ".", "CKPT_VERSION", "+", "'_epoch'", "+", "str", "(", "self", ".", "__C", ".", "CKPT_EPOCH", ")", "+", "'.json'", "\n", "\n", "", "print", "(", "'Save the result to file: {}'", ".", "format", "(", "result_eval_file", ")", ")", "\n", "\n", "", "json", ".", "dump", "(", "result", ",", "open", "(", "result_eval_file", ",", "'w'", ")", ")", "\n", "\n", "# Save the whole prediction vector", "\n", "if", "self", ".", "__C", ".", "TEST_SAVE_PRED", ":", "\n", "\n", "            ", "if", "self", ".", "__C", ".", "CKPT_PATH", "is", "not", "None", ":", "\n", "                ", "ensemble_file", "=", "self", ".", "__C", ".", "PRED_PATH", "+", "'result_run_'", "+", "self", ".", "__C", ".", "CKPT_VERSION", "+", "'.json'", "\n", "", "else", ":", "\n", "                ", "ensemble_file", "=", "self", ".", "__C", ".", "PRED_PATH", "+", "'result_run_'", "+", "self", ".", "__C", ".", "CKPT_VERSION", "+", "'_epoch'", "+", "str", "(", "self", ".", "__C", ".", "CKPT_EPOCH", ")", "+", "'.json'", "\n", "\n", "", "print", "(", "'Save the prediction vector to file: {}'", ".", "format", "(", "ensemble_file", ")", ")", "\n", "\n", "pred_list", "=", "np", ".", "array", "(", "pred_list", ")", ".", "reshape", "(", "-", "1", ",", "ans_size", ")", "\n", "result_pred", "=", "[", "{", "\n", "'pred'", ":", "pred_list", "[", "qix", "]", ",", "\n", "'question_id'", ":", "int", "(", "qid_list", "[", "qix", "]", ")", "\n", "}", "for", "qix", "in", "range", "(", "qid_list", ".", "__len__", "(", ")", ")", "]", "\n", "\n", "pickle", ".", "dump", "(", "result_pred", ",", "open", "(", "ensemble_file", ",", "'wb+'", ")", ",", "protocol", "=", "-", "1", ")", "\n", "\n", "\n", "# Run validation script", "\n", "", "if", "valid", ":", "\n", "# create vqa object and vqaRes object", "\n", "            ", "ques_file_path", "=", "self", ".", "__C", ".", "QUESTION_PATH", "[", "'val'", "]", "\n", "ans_file_path", "=", "self", ".", "__C", ".", "ANSWER_PATH", "[", "'val'", "]", "\n", "\n", "vqa", "=", "VQA", "(", "ans_file_path", ",", "ques_file_path", ")", "\n", "vqaRes", "=", "vqa", ".", "loadRes", "(", "result_eval_file", ",", "ques_file_path", ")", "\n", "\n", "# create vqaEval object by taking vqa and vqaRes", "\n", "vqaEval", "=", "VQAEval", "(", "vqa", ",", "vqaRes", ",", "n", "=", "2", ")", "# n is precision of accuracy (number of places after decimal), default is 2", "\n", "\n", "# evaluate results", "\n", "\"\"\"\n            If you have a list of question ids on which you would like to evaluate your results, pass it as a list to below function\n            By default it uses all the question ids in annotation file\n            \"\"\"", "\n", "vqaEval", ".", "evaluate", "(", ")", "\n", "\n", "# print accuracies", "\n", "print", "(", "\"\\n\"", ")", "\n", "print", "(", "\"Overall Accuracy is: %.02f\\n\"", "%", "(", "vqaEval", ".", "accuracy", "[", "'overall'", "]", ")", ")", "\n", "# print(\"Per Question Type Accuracy is the following:\")", "\n", "# for quesType in vqaEval.accuracy['perQuestionType']:", "\n", "#     print(\"%s : %.02f\" % (quesType, vqaEval.accuracy['perQuestionType'][quesType]))", "\n", "# print(\"\\n\")", "\n", "print", "(", "\"Per Answer Type Accuracy is the following:\"", ")", "\n", "for", "ansType", "in", "vqaEval", ".", "accuracy", "[", "'perAnswerType'", "]", ":", "\n", "                ", "print", "(", "\"%s : %.02f\"", "%", "(", "ansType", ",", "vqaEval", ".", "accuracy", "[", "'perAnswerType'", "]", "[", "ansType", "]", ")", ")", "\n", "", "print", "(", "\"\\n\"", ")", "\n", "\n", "if", "val_ckpt_flag", ":", "\n", "                ", "print", "(", "'Write to log file: {}'", ".", "format", "(", "\n", "self", ".", "__C", ".", "LOG_PATH", "+", "\n", "'log_run_'", "+", "self", ".", "__C", ".", "CKPT_VERSION", "+", "'.txt'", ",", "\n", "'a+'", ")", "\n", ")", "\n", "\n", "logfile", "=", "open", "(", "\n", "self", ".", "__C", ".", "LOG_PATH", "+", "\n", "'log_run_'", "+", "self", ".", "__C", ".", "CKPT_VERSION", "+", "'.txt'", ",", "\n", "'a+'", "\n", ")", "\n", "\n", "", "else", ":", "\n", "                ", "print", "(", "'Write to log file: {}'", ".", "format", "(", "\n", "self", ".", "__C", ".", "LOG_PATH", "+", "\n", "'log_run_'", "+", "self", ".", "__C", ".", "VERSION", "+", "'.txt'", ",", "\n", "'a+'", ")", "\n", ")", "\n", "\n", "logfile", "=", "open", "(", "\n", "self", ".", "__C", ".", "LOG_PATH", "+", "\n", "'log_run_'", "+", "self", ".", "__C", ".", "VERSION", "+", "'.txt'", ",", "\n", "'a+'", "\n", ")", "\n", "\n", "", "logfile", ".", "write", "(", "\"Overall Accuracy is: %.02f\\n\"", "%", "(", "vqaEval", ".", "accuracy", "[", "'overall'", "]", ")", ")", "\n", "for", "ansType", "in", "vqaEval", ".", "accuracy", "[", "'perAnswerType'", "]", ":", "\n", "                ", "logfile", ".", "write", "(", "\"%s : %.02f \"", "%", "(", "ansType", ",", "vqaEval", ".", "accuracy", "[", "'perAnswerType'", "]", "[", "ansType", "]", ")", ")", "\n", "", "logfile", ".", "write", "(", "\"\\n\\n\"", ")", "\n", "logfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.run": [[506, 519], ["exec.Execution.empty_log", "exec.Execution.train", "exec.Execution.eval", "exec.Execution.eval", "exit"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.empty_log", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval"], ["", "", "def", "run", "(", "self", ",", "run_mode", ")", ":", "\n", "        ", "if", "run_mode", "==", "'train'", ":", "\n", "            ", "self", ".", "empty_log", "(", "self", ".", "__C", ".", "VERSION", ")", "\n", "self", ".", "train", "(", "self", ".", "dataset", ",", "self", ".", "dataset_eval", ")", "\n", "\n", "", "elif", "run_mode", "==", "'val'", ":", "\n", "            ", "self", ".", "eval", "(", "self", ".", "dataset", ",", "valid", "=", "True", ")", "\n", "\n", "", "elif", "run_mode", "==", "'test'", ":", "\n", "            ", "self", ".", "eval", "(", "self", ".", "dataset", ")", "\n", "\n", "", "else", ":", "\n", "            ", "exit", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.empty_log": [[521, 527], ["print", "os.path.exists", "print", "print", "os.remove"], "methods", ["None"], ["", "", "def", "empty_log", "(", "self", ",", "version", ")", ":", "\n", "        ", "print", "(", "'Initializing log file ........'", ")", "\n", "if", "(", "os", ".", "path", ".", "exists", "(", "self", ".", "__C", ".", "LOG_PATH", "+", "'log_run_'", "+", "version", "+", "'.txt'", ")", ")", ":", "\n", "            ", "os", ".", "remove", "(", "self", ".", "__C", ".", "LOG_PATH", "+", "'log_run_'", "+", "version", "+", "'.txt'", ")", "\n", "", "print", "(", "'Finished!'", ")", "\n", "print", "(", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net.AttFlat.__init__": [[20, 35], ["torch.Module.__init__", "core.model.net_utils.MLP", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "__C", ")", ":", "\n", "        ", "super", "(", "AttFlat", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "__C", "=", "__C", "\n", "\n", "self", ".", "mlp", "=", "MLP", "(", "\n", "in_size", "=", "__C", ".", "HIDDEN_SIZE", ",", "\n", "mid_size", "=", "__C", ".", "FLAT_MLP_SIZE", ",", "\n", "out_size", "=", "__C", ".", "FLAT_GLIMPSES", ",", "\n", "dropout_r", "=", "__C", ".", "DROPOUT_R", ",", "\n", "use_relu", "=", "True", "\n", ")", "\n", "\n", "self", ".", "linear_merge", "=", "nn", ".", "Linear", "(", "\n", "__C", ".", "HIDDEN_SIZE", "*", "__C", ".", "FLAT_GLIMPSES", ",", "\n", "__C", ".", "FLAT_OUT_SIZE", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net.AttFlat.forward": [[37, 55], ["net.AttFlat.mlp", "torch.softmax.masked_fill", "torch.softmax", "torch.softmax", "torch.softmax", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "net.AttFlat.linear_merge", "x_mask.squeeze().squeeze().unsqueeze", "att_list.append", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "x_mask.squeeze().squeeze", "x_mask.squeeze"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "x", ",", "x_mask", ")", ":", "\n", "        ", "att", "=", "self", ".", "mlp", "(", "x", ")", "\n", "att", "=", "att", ".", "masked_fill", "(", "\n", "x_mask", ".", "squeeze", "(", "1", ")", ".", "squeeze", "(", "1", ")", ".", "unsqueeze", "(", "2", ")", ",", "\n", "-", "1e9", "\n", ")", "\n", "att", "=", "F", ".", "softmax", "(", "att", ",", "dim", "=", "1", ")", "\n", "\n", "att_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "__C", ".", "FLAT_GLIMPSES", ")", ":", "\n", "            ", "att_list", ".", "append", "(", "\n", "torch", ".", "sum", "(", "att", "[", ":", ",", ":", ",", "i", ":", "i", "+", "1", "]", "*", "x", ",", "dim", "=", "1", ")", "\n", ")", "\n", "\n", "", "x_atted", "=", "torch", ".", "cat", "(", "att_list", ",", "dim", "=", "1", ")", "\n", "x_atted", "=", "self", ".", "linear_merge", "(", "x_atted", ")", "\n", "\n", "return", "x_atted", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net.Net.__init__": [[62, 93], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.Linear", "torch.Linear", "torch.Linear", "core.model.mca.MCA_ED", "net.AttFlat", "net.AttFlat", "core.model.net_utils.LayerNorm", "torch.Linear", "torch.Linear", "torch.Linear", "net.Net.embedding.weight.data.copy_", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "__C", ",", "pretrained_emb", ",", "token_size", ",", "answer_size", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "\n", "num_embeddings", "=", "token_size", ",", "\n", "embedding_dim", "=", "__C", ".", "WORD_EMBED_SIZE", "\n", ")", "\n", "\n", "# Loading the GloVe embedding weights", "\n", "if", "__C", ".", "USE_GLOVE", ":", "\n", "            ", "self", ".", "embedding", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "pretrained_emb", ")", ")", "\n", "\n", "", "self", ".", "lstm", "=", "nn", ".", "LSTM", "(", "\n", "input_size", "=", "__C", ".", "WORD_EMBED_SIZE", ",", "\n", "hidden_size", "=", "__C", ".", "HIDDEN_SIZE", ",", "\n", "num_layers", "=", "1", ",", "\n", "batch_first", "=", "True", "\n", ")", "\n", "\n", "self", ".", "img_feat_linear", "=", "nn", ".", "Linear", "(", "\n", "__C", ".", "IMG_FEAT_SIZE", ",", "\n", "__C", ".", "HIDDEN_SIZE", "\n", ")", "\n", "\n", "self", ".", "backbone", "=", "MCA_ED", "(", "__C", ")", "\n", "\n", "self", ".", "attflat_img", "=", "AttFlat", "(", "__C", ")", "\n", "self", ".", "attflat_lang", "=", "AttFlat", "(", "__C", ")", "\n", "\n", "self", ".", "proj_norm", "=", "LayerNorm", "(", "__C", ".", "FLAT_OUT_SIZE", ")", "\n", "self", ".", "proj", "=", "nn", ".", "Linear", "(", "__C", ".", "FLAT_OUT_SIZE", ",", "answer_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net.Net.forward": [[95, 131], ["net.Net.make_mask", "net.Net.make_mask", "net.Net.embedding", "net.Net.lstm", "net.Net.img_feat_linear", "net.Net.backbone", "net.Net.attflat_lang", "net.Net.attflat_img", "net.Net.proj_norm", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "ques_ix.unsqueeze", "net.Net.proj"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.mask_utils.make_mask", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.mask_utils.make_mask"], ["", "def", "forward", "(", "self", ",", "img_feat", ",", "ques_ix", ")", ":", "\n", "\n", "# Make mask", "\n", "        ", "lang_feat_mask", "=", "self", ".", "make_mask", "(", "ques_ix", ".", "unsqueeze", "(", "2", ")", ")", "\n", "img_feat_mask", "=", "self", ".", "make_mask", "(", "img_feat", ")", "\n", "\n", "# Pre-process Language Feature", "\n", "lang_feat", "=", "self", ".", "embedding", "(", "ques_ix", ")", "\n", "lang_feat", ",", "_", "=", "self", ".", "lstm", "(", "lang_feat", ")", "\n", "\n", "# Pre-process Image Feature", "\n", "img_feat", "=", "self", ".", "img_feat_linear", "(", "img_feat", ")", "\n", "\n", "# Backbone Framework", "\n", "lang_feat", ",", "img_feat", "=", "self", ".", "backbone", "(", "\n", "lang_feat", ",", "\n", "img_feat", ",", "\n", "lang_feat_mask", ",", "\n", "img_feat_mask", "\n", ")", "\n", "\n", "lang_feat", "=", "self", ".", "attflat_lang", "(", "\n", "lang_feat", ",", "\n", "lang_feat_mask", "\n", ")", "\n", "\n", "img_feat", "=", "self", ".", "attflat_img", "(", "\n", "img_feat", ",", "\n", "img_feat_mask", "\n", ")", "\n", "\n", "proj_feat", "=", "lang_feat", "+", "img_feat", "\n", "proj_feat", "=", "self", ".", "proj_norm", "(", "proj_feat", ")", "\n", "proj_feat", "=", "torch", ".", "sigmoid", "(", "self", ".", "proj", "(", "proj_feat", ")", ")", "\n", "\n", "return", "proj_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net.Net.make_mask": [[134, 139], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["None"], ["", "def", "make_mask", "(", "self", ",", "feature", ")", ":", "\n", "        ", "return", "(", "torch", ".", "sum", "(", "\n", "torch", ".", "abs", "(", "feature", ")", ",", "\n", "dim", "=", "-", "1", "\n", ")", "==", "0", ")", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net_utils.FC.__init__": [[12, 24], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_size", ",", "out_size", ",", "dropout_r", "=", "0.", ",", "use_relu", "=", "True", ")", ":", "\n", "        ", "super", "(", "FC", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dropout_r", "=", "dropout_r", "\n", "self", ".", "use_relu", "=", "use_relu", "\n", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "in_size", ",", "out_size", ")", "\n", "\n", "if", "use_relu", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "", "if", "dropout_r", ">", "0", ":", "\n", "            ", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout_r", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net_utils.FC.forward": [[25, 35], ["net_utils.FC.linear", "net_utils.FC.relu", "net_utils.FC.dropout"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "\n", "if", "self", ".", "use_relu", ":", "\n", "            ", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "", "if", "self", ".", "dropout_r", ">", "0", ":", "\n", "            ", "x", "=", "self", ".", "dropout", "(", "x", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net_utils.MLP.__init__": [[38, 43], ["torch.Module.__init__", "net_utils.FC", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_size", ",", "mid_size", ",", "out_size", ",", "dropout_r", "=", "0.", ",", "use_relu", "=", "True", ")", ":", "\n", "        ", "super", "(", "MLP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "fc", "=", "FC", "(", "in_size", ",", "mid_size", ",", "dropout_r", "=", "dropout_r", ",", "use_relu", "=", "use_relu", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "mid_size", ",", "out_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net_utils.MLP.forward": [[44, 46], ["net_utils.MLP.linear", "net_utils.MLP.fc"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "linear", "(", "self", ".", "fc", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net_utils.LayerNorm.__init__": [[49, 55], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "size", ",", "eps", "=", "1e-6", ")", ":", "\n", "        ", "super", "(", "LayerNorm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "\n", "self", ".", "a_2", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "size", ")", ")", "\n", "self", ".", "b_2", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "size", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.net_utils.LayerNorm.forward": [[56, 61], ["x.mean", "x.std"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "mean", "=", "x", ".", "mean", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "std", "=", "x", ".", "std", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "return", "self", ".", "a_2", "*", "(", "x", "-", "mean", ")", "/", "(", "std", "+", "self", ".", "eps", ")", "+", "self", ".", "b_2", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.__init__": [[12, 19], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "lr_base", ",", "optimizer", ",", "data_size", ",", "batch_size", ")", ":", "\n", "        ", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "_step", "=", "0", "\n", "self", ".", "lr_base", "=", "lr_base", "\n", "self", ".", "_rate", "=", "0", "\n", "self", ".", "data_size", "=", "data_size", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.step": [[21, 30], ["optim.WarmupOptimizer.rate", "optim.WarmupOptimizer.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.rate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.step"], ["", "def", "step", "(", "self", ")", ":", "\n", "        ", "self", ".", "_step", "+=", "1", "\n", "\n", "rate", "=", "self", ".", "rate", "(", ")", "\n", "for", "p", "in", "self", ".", "optimizer", ".", "param_groups", ":", "\n", "            ", "p", "[", "'lr'", "]", "=", "rate", "\n", "", "self", ".", "_rate", "=", "rate", "\n", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.zero_grad": [[32, 34], ["optim.WarmupOptimizer.optimizer.zero_grad"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.zero_grad"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.WarmupOptimizer.rate": [[36, 50], ["int", "int", "int"], "methods", ["None"], ["", "def", "rate", "(", "self", ",", "step", "=", "None", ")", ":", "\n", "        ", "if", "step", "is", "None", ":", "\n", "            ", "step", "=", "self", ".", "_step", "\n", "\n", "", "if", "step", "<=", "int", "(", "self", ".", "data_size", "/", "self", ".", "batch_size", "*", "1", ")", ":", "\n", "            ", "r", "=", "self", ".", "lr_base", "*", "1", "/", "4.", "\n", "", "elif", "step", "<=", "int", "(", "self", ".", "data_size", "/", "self", ".", "batch_size", "*", "2", ")", ":", "\n", "            ", "r", "=", "self", ".", "lr_base", "*", "2", "/", "4.", "\n", "", "elif", "step", "<=", "int", "(", "self", ".", "data_size", "/", "self", ".", "batch_size", "*", "3", ")", ":", "\n", "            ", "r", "=", "self", ".", "lr_base", "*", "3", "/", "4.", "\n", "", "else", ":", "\n", "            ", "r", "=", "self", ".", "lr_base", "\n", "\n", "", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.get_optim": [[52, 66], ["optim.WarmupOptimizer", "torch.Adam", "filter", "model.parameters"], "function", ["None"], ["", "", "def", "get_optim", "(", "__C", ",", "model", ",", "data_size", ",", "lr_base", "=", "None", ")", ":", "\n", "    ", "if", "lr_base", "is", "None", ":", "\n", "        ", "lr_base", "=", "__C", ".", "LR_BASE", "\n", "\n", "", "return", "WarmupOptimizer", "(", "\n", "lr_base", ",", "\n", "Optim", ".", "Adam", "(", "\n", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "model", ".", "parameters", "(", ")", ")", ",", "\n", "lr", "=", "0", ",", "\n", "betas", "=", "__C", ".", "OPT_BETAS", ",", "\n", "eps", "=", "__C", ".", "OPT_EPS", "\n", ")", ",", "\n", "data_size", ",", "\n", "__C", ".", "BATCH_SIZE", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.optim.adjust_lr": [[69, 71], ["None"], "function", ["None"], ["", "def", "adjust_lr", "(", "optim", ",", "decay_r", ")", ":", "\n", "    ", "optim", ".", "lr_base", "*=", "decay_r", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.MHAtt.__init__": [[19, 29], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "__C", ")", ":", "\n", "        ", "super", "(", "MHAtt", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "__C", "=", "__C", "\n", "\n", "self", ".", "linear_v", "=", "nn", ".", "Linear", "(", "__C", ".", "HIDDEN_SIZE", ",", "__C", ".", "HIDDEN_SIZE", ")", "\n", "self", ".", "linear_k", "=", "nn", ".", "Linear", "(", "__C", ".", "HIDDEN_SIZE", ",", "__C", ".", "HIDDEN_SIZE", ")", "\n", "self", ".", "linear_q", "=", "nn", ".", "Linear", "(", "__C", ".", "HIDDEN_SIZE", ",", "__C", ".", "HIDDEN_SIZE", ")", "\n", "self", ".", "linear_merge", "=", "nn", ".", "Linear", "(", "__C", ".", "HIDDEN_SIZE", ",", "__C", ".", "HIDDEN_SIZE", ")", "\n", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "__C", ".", "DROPOUT_R", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.MHAtt.forward": [[30, 64], ["mca.MHAtt.size", "mca.MHAtt.linear_v().view().transpose", "mca.MHAtt.linear_k().view().transpose", "mca.MHAtt.linear_q().view().transpose", "mca.MHAtt.att", "mca.MHAtt.transpose().contiguous().view", "mca.MHAtt.linear_merge", "mca.MHAtt.linear_v().view", "mca.MHAtt.linear_k().view", "mca.MHAtt.linear_q().view", "mca.MHAtt.transpose().contiguous", "mca.MHAtt.linear_v", "mca.MHAtt.linear_k", "mca.MHAtt.linear_q", "mca.MHAtt.transpose"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.MHAtt.att", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "forward", "(", "self", ",", "v", ",", "k", ",", "q", ",", "mask", ")", ":", "\n", "        ", "n_batches", "=", "q", ".", "size", "(", "0", ")", "\n", "\n", "v", "=", "self", ".", "linear_v", "(", "v", ")", ".", "view", "(", "\n", "n_batches", ",", "\n", "-", "1", ",", "\n", "self", ".", "__C", ".", "MULTI_HEAD", ",", "\n", "self", ".", "__C", ".", "HIDDEN_SIZE_HEAD", "\n", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "k", "=", "self", ".", "linear_k", "(", "k", ")", ".", "view", "(", "\n", "n_batches", ",", "\n", "-", "1", ",", "\n", "self", ".", "__C", ".", "MULTI_HEAD", ",", "\n", "self", ".", "__C", ".", "HIDDEN_SIZE_HEAD", "\n", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "q", "=", "self", ".", "linear_q", "(", "q", ")", ".", "view", "(", "\n", "n_batches", ",", "\n", "-", "1", ",", "\n", "self", ".", "__C", ".", "MULTI_HEAD", ",", "\n", "self", ".", "__C", ".", "HIDDEN_SIZE_HEAD", "\n", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "atted", "=", "self", ".", "att", "(", "v", ",", "k", ",", "q", ",", "mask", ")", "\n", "atted", "=", "atted", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "\n", "n_batches", ",", "\n", "-", "1", ",", "\n", "self", ".", "__C", ".", "HIDDEN_SIZE", "\n", ")", "\n", "\n", "atted", "=", "self", ".", "linear_merge", "(", "atted", ")", "\n", "\n", "return", "atted", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.MHAtt.att": [[65, 79], ["query.size", "torch.softmax", "torch.softmax", "torch.softmax", "mca.MHAtt.dropout", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "math.sqrt", "scores.masked_fill.masked_fill.masked_fill", "key.transpose"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "att", "(", "self", ",", "value", ",", "key", ",", "query", ",", "mask", ")", ":", "\n", "        ", "d_k", "=", "query", ".", "size", "(", "-", "1", ")", "\n", "\n", "scores", "=", "torch", ".", "matmul", "(", "\n", "query", ",", "key", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", "\n", ")", "/", "math", ".", "sqrt", "(", "d_k", ")", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "scores", "=", "scores", ".", "masked_fill", "(", "mask", ",", "-", "1e9", ")", "\n", "\n", "", "att_map", "=", "F", ".", "softmax", "(", "scores", ",", "dim", "=", "-", "1", ")", "\n", "att_map", "=", "self", ".", "dropout", "(", "att_map", ")", "\n", "\n", "return", "torch", ".", "matmul", "(", "att_map", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.FFN.__init__": [[86, 95], ["torch.Module.__init__", "core.model.net_utils.MLP"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "__C", ")", ":", "\n", "        ", "super", "(", "FFN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "mlp", "=", "MLP", "(", "\n", "in_size", "=", "__C", ".", "HIDDEN_SIZE", ",", "\n", "mid_size", "=", "__C", ".", "FF_SIZE", ",", "\n", "out_size", "=", "__C", ".", "HIDDEN_SIZE", ",", "\n", "dropout_r", "=", "__C", ".", "DROPOUT_R", ",", "\n", "use_relu", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.FFN.forward": [[97, 99], ["mca.FFN.mlp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "mlp", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.SA.__init__": [[106, 117], ["torch.Module.__init__", "mca.MHAtt", "mca.FFN", "torch.Dropout", "torch.Dropout", "torch.Dropout", "core.model.net_utils.LayerNorm", "torch.Dropout", "torch.Dropout", "torch.Dropout", "core.model.net_utils.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "__C", ")", ":", "\n", "        ", "super", "(", "SA", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "mhatt", "=", "MHAtt", "(", "__C", ")", "\n", "self", ".", "ffn", "=", "FFN", "(", "__C", ")", "\n", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "__C", ".", "DROPOUT_R", ")", "\n", "self", ".", "norm1", "=", "LayerNorm", "(", "__C", ".", "HIDDEN_SIZE", ")", "\n", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "__C", ".", "DROPOUT_R", ")", "\n", "self", ".", "norm2", "=", "LayerNorm", "(", "__C", ".", "HIDDEN_SIZE", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.SA.forward": [[118, 128], ["mca.SA.norm1", "mca.SA.norm2", "mca.SA.dropout1", "mca.SA.dropout2", "mca.SA.mhatt", "mca.SA.ffn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "x_mask", ")", ":", "\n", "        ", "x", "=", "self", ".", "norm1", "(", "x", "+", "self", ".", "dropout1", "(", "\n", "self", ".", "mhatt", "(", "x", ",", "x", ",", "x", ",", "x_mask", ")", "\n", ")", ")", "\n", "\n", "x", "=", "self", ".", "norm2", "(", "x", "+", "self", ".", "dropout2", "(", "\n", "self", ".", "ffn", "(", "x", ")", "\n", ")", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.SGA.__init__": [[135, 150], ["torch.Module.__init__", "mca.MHAtt", "mca.MHAtt", "mca.FFN", "torch.Dropout", "torch.Dropout", "torch.Dropout", "core.model.net_utils.LayerNorm", "torch.Dropout", "torch.Dropout", "torch.Dropout", "core.model.net_utils.LayerNorm", "torch.Dropout", "torch.Dropout", "torch.Dropout", "core.model.net_utils.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "__C", ")", ":", "\n", "        ", "super", "(", "SGA", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "mhatt1", "=", "MHAtt", "(", "__C", ")", "\n", "self", ".", "mhatt2", "=", "MHAtt", "(", "__C", ")", "\n", "self", ".", "ffn", "=", "FFN", "(", "__C", ")", "\n", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "__C", ".", "DROPOUT_R", ")", "\n", "self", ".", "norm1", "=", "LayerNorm", "(", "__C", ".", "HIDDEN_SIZE", ")", "\n", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "__C", ".", "DROPOUT_R", ")", "\n", "self", ".", "norm2", "=", "LayerNorm", "(", "__C", ".", "HIDDEN_SIZE", ")", "\n", "\n", "self", ".", "dropout3", "=", "nn", ".", "Dropout", "(", "__C", ".", "DROPOUT_R", ")", "\n", "self", ".", "norm3", "=", "LayerNorm", "(", "__C", ".", "HIDDEN_SIZE", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.SGA.forward": [[151, 165], ["mca.SGA.norm1", "mca.SGA.norm2", "mca.SGA.norm3", "mca.SGA.dropout1", "mca.SGA.dropout2", "mca.SGA.dropout3", "mca.SGA.mhatt1", "mca.SGA.mhatt2", "mca.SGA.ffn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "x_mask", ",", "y_mask", ")", ":", "\n", "        ", "x", "=", "self", ".", "norm1", "(", "x", "+", "self", ".", "dropout1", "(", "\n", "self", ".", "mhatt1", "(", "x", ",", "x", ",", "x", ",", "x_mask", ")", "\n", ")", ")", "\n", "\n", "x", "=", "self", ".", "norm2", "(", "x", "+", "self", ".", "dropout2", "(", "\n", "self", ".", "mhatt2", "(", "y", ",", "y", ",", "x", ",", "y_mask", ")", "\n", ")", ")", "\n", "\n", "x", "=", "self", ".", "norm3", "(", "x", "+", "self", ".", "dropout3", "(", "\n", "self", ".", "ffn", "(", "x", ")", "\n", ")", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.MCA_ED.__init__": [[172, 177], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "mca.SA", "mca.SGA", "range", "range"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "__C", ")", ":", "\n", "        ", "super", "(", "MCA_ED", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "enc_list", "=", "nn", ".", "ModuleList", "(", "[", "SA", "(", "__C", ")", "for", "_", "in", "range", "(", "__C", ".", "LAYER", ")", "]", ")", "\n", "self", ".", "dec_list", "=", "nn", ".", "ModuleList", "(", "[", "SGA", "(", "__C", ")", "for", "_", "in", "range", "(", "__C", ".", "LAYER", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.model.mca.MCA_ED.forward": [[178, 187], ["enc", "dec"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "x_mask", ",", "y_mask", ")", ":", "\n", "# Get hidden vector", "\n", "        ", "for", "enc", "in", "self", ".", "enc_list", ":", "\n", "            ", "x", "=", "enc", "(", "x", ",", "x_mask", ")", "\n", "\n", "", "for", "dec", "in", "self", ".", "dec_list", ":", "\n", "            ", "y", "=", "dec", "(", "y", ",", "x", ",", "y_mask", ",", "x_mask", ")", "\n", "\n", "", "return", "x", ",", "y", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloaderraw.DataLoaderRaw.__init__": [[26, 83], ["opt.get", "opt.get", "opt.get", "opt.get", "dataloaderraw.DataLoaderRaw.my_resnet.load_state_dict", "misc.resnet_utils.myResnet", "dataloaderraw.DataLoaderRaw.my_resnet.cuda", "dataloaderraw.DataLoaderRaw.my_resnet.eval", "print", "print", "len", "print", "getattr", "torch.load", "len", "len", "print", "json.load", "enumerate", "print", "os.walk", "open", "os.path.join", "dataloaderraw.DataLoaderRaw.files.append", "dataloaderraw.DataLoaderRaw.ids.append", "f.rfind", "os.path.join", "dataloaderraw.DataLoaderRaw.__init__.isImage"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "opt", "=", "opt", "\n", "self", ".", "coco_json", "=", "opt", ".", "get", "(", "'coco_json'", ",", "''", ")", "\n", "self", ".", "folder_path", "=", "opt", ".", "get", "(", "'folder_path'", ",", "''", ")", "\n", "\n", "self", ".", "batch_size", "=", "opt", ".", "get", "(", "'batch_size'", ",", "1", ")", "\n", "self", ".", "seq_per_img", "=", "1", "\n", "\n", "# Load resnet", "\n", "self", ".", "cnn_model", "=", "opt", ".", "get", "(", "'cnn_model'", ",", "'resnet101'", ")", "\n", "self", ".", "my_resnet", "=", "getattr", "(", "misc", ".", "resnet", ",", "self", ".", "cnn_model", ")", "(", ")", "\n", "self", ".", "my_resnet", ".", "load_state_dict", "(", "torch", ".", "load", "(", "'./data/imagenet_weights/'", "+", "self", ".", "cnn_model", "+", "'.pth'", ")", ")", "\n", "self", ".", "my_resnet", "=", "myResnet", "(", "self", ".", "my_resnet", ")", "\n", "self", ".", "my_resnet", ".", "cuda", "(", ")", "\n", "self", ".", "my_resnet", ".", "eval", "(", ")", "\n", "\n", "\n", "\n", "# load the json file which contains additional information about the dataset", "\n", "print", "(", "'DataLoaderRaw loading images from folder: '", ",", "self", ".", "folder_path", ")", "\n", "\n", "self", ".", "files", "=", "[", "]", "\n", "self", ".", "ids", "=", "[", "]", "\n", "\n", "print", "(", "len", "(", "self", ".", "coco_json", ")", ")", "\n", "if", "len", "(", "self", ".", "coco_json", ")", ">", "0", ":", "\n", "            ", "print", "(", "'reading from '", "+", "opt", ".", "coco_json", ")", "\n", "# read in filenames from the coco-style json file", "\n", "self", ".", "coco_annotation", "=", "json", ".", "load", "(", "open", "(", "self", ".", "coco_json", ")", ")", "\n", "for", "k", ",", "v", "in", "enumerate", "(", "self", ".", "coco_annotation", "[", "'images'", "]", ")", ":", "\n", "                ", "fullpath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "folder_path", ",", "v", "[", "'file_name'", "]", ")", "\n", "self", ".", "files", ".", "append", "(", "fullpath", ")", "\n", "self", ".", "ids", ".", "append", "(", "v", "[", "'id'", "]", ")", "\n", "", "", "else", ":", "\n", "# read in all the filenames from the folder", "\n", "            ", "print", "(", "'listing all images in directory '", "+", "self", ".", "folder_path", ")", "\n", "def", "isImage", "(", "f", ")", ":", "\n", "                ", "supportedExt", "=", "[", "'.jpg'", ",", "'.JPG'", ",", "'.jpeg'", ",", "'.JPEG'", ",", "'.png'", ",", "'.PNG'", ",", "'.ppm'", ",", "'.PPM'", "]", "\n", "for", "ext", "in", "supportedExt", ":", "\n", "                    ", "start_idx", "=", "f", ".", "rfind", "(", "ext", ")", "\n", "if", "start_idx", ">=", "0", "and", "start_idx", "+", "len", "(", "ext", ")", "==", "len", "(", "f", ")", ":", "\n", "                        ", "return", "True", "\n", "", "", "return", "False", "\n", "\n", "", "n", "=", "1", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "self", ".", "folder_path", ",", "topdown", "=", "False", ")", ":", "\n", "                ", "for", "file", "in", "files", ":", "\n", "                    ", "fullpath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "folder_path", ",", "file", ")", "\n", "if", "isImage", "(", "fullpath", ")", ":", "\n", "                        ", "self", ".", "files", ".", "append", "(", "fullpath", ")", "\n", "self", ".", "ids", ".", "append", "(", "str", "(", "n", ")", ")", "# just order them sequentially", "\n", "n", "=", "n", "+", "1", "\n", "\n", "", "", "", "", "self", ".", "N", "=", "len", "(", "self", ".", "files", ")", "\n", "print", "(", "'DataLoaderRaw found '", ",", "self", ".", "N", ",", "' images'", ")", "\n", "\n", "self", ".", "iterator", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloaderraw.DataLoaderRaw.get_batch": [[84, 131], ["numpy.ndarray", "numpy.ndarray", "range", "numpy.ndarray.reshape", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "torch.from_numpy().cuda", "preprocess", "tmp_fc.data.cpu().float().numpy", "tmp_att.data.cpu().float().numpy", "infos.append", "len", "numpy.concatenate", "img[].astype", "torch.no_grad", "dataloaderraw.DataLoaderRaw.my_resnet", "torch.from_numpy", "tmp_fc.data.cpu().float", "tmp_att.data.cpu().float", "numpy.concatenate.transpose", "tmp_fc.data.cpu", "tmp_att.data.cpu"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "get_batch", "(", "self", ",", "split", ",", "batch_size", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "batch_size", "or", "self", ".", "batch_size", "\n", "\n", "# pick an index of the datapoint to load next", "\n", "fc_batch", "=", "np", ".", "ndarray", "(", "(", "batch_size", ",", "2048", ")", ",", "dtype", "=", "'float32'", ")", "\n", "att_batch", "=", "np", ".", "ndarray", "(", "(", "batch_size", ",", "14", ",", "14", ",", "2048", ")", ",", "dtype", "=", "'float32'", ")", "\n", "max_index", "=", "self", ".", "N", "\n", "wrapped", "=", "False", "\n", "infos", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "ri", "=", "self", ".", "iterator", "\n", "ri_next", "=", "ri", "+", "1", "\n", "if", "ri_next", ">=", "max_index", ":", "\n", "                ", "ri_next", "=", "0", "\n", "wrapped", "=", "True", "\n", "# wrap back around", "\n", "", "self", ".", "iterator", "=", "ri_next", "\n", "\n", "img", "=", "skimage", ".", "io", ".", "imread", "(", "self", ".", "files", "[", "ri", "]", ")", "\n", "\n", "if", "len", "(", "img", ".", "shape", ")", "==", "2", ":", "\n", "                ", "img", "=", "img", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "img", "=", "np", ".", "concatenate", "(", "(", "img", ",", "img", ",", "img", ")", ",", "axis", "=", "2", ")", "\n", "\n", "", "img", "=", "img", "[", ":", ",", ":", ",", ":", "3", "]", ".", "astype", "(", "'float32'", ")", "/", "255.0", "\n", "img", "=", "torch", ".", "from_numpy", "(", "img", ".", "transpose", "(", "[", "2", ",", "0", ",", "1", "]", ")", ")", ".", "cuda", "(", ")", "\n", "img", "=", "preprocess", "(", "img", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "tmp_fc", ",", "tmp_att", "=", "self", ".", "my_resnet", "(", "img", ")", "\n", "\n", "", "fc_batch", "[", "i", "]", "=", "tmp_fc", ".", "data", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", "\n", "att_batch", "[", "i", "]", "=", "tmp_att", ".", "data", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "info_struct", "=", "{", "}", "\n", "info_struct", "[", "'id'", "]", "=", "self", ".", "ids", "[", "ri", "]", "\n", "info_struct", "[", "'file_path'", "]", "=", "self", ".", "files", "[", "ri", "]", "\n", "infos", ".", "append", "(", "info_struct", ")", "\n", "\n", "", "data", "=", "{", "}", "\n", "data", "[", "'fc_feats'", "]", "=", "fc_batch", "\n", "data", "[", "'att_feats'", "]", "=", "att_batch", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "2048", ")", "\n", "data", "[", "'att_masks'", "]", "=", "None", "\n", "data", "[", "'bounds'", "]", "=", "{", "'it_pos_now'", ":", "self", ".", "iterator", ",", "'it_max'", ":", "self", ".", "N", ",", "'wrapped'", ":", "wrapped", "}", "\n", "data", "[", "'infos'", "]", "=", "infos", "\n", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloaderraw.DataLoaderRaw.reset_iterator": [[132, 134], ["None"], "methods", ["None"], ["", "def", "reset_iterator", "(", "self", ",", "split", ")", ":", "\n", "        ", "self", ".", "iterator", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloaderraw.DataLoaderRaw.get_vocab_size": [[135, 137], ["len"], "methods", ["None"], ["", "def", "get_vocab_size", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "ix_to_word", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloaderraw.DataLoaderRaw.get_vocab": [[138, 140], ["None"], "methods", ["None"], ["", "def", "get_vocab", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "ix_to_word", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.opts.parse_opt": [[3, 203], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.MCAN_VC.run.parse_args"], ["def", "parse_opt", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "# Data input settings", "\n", "# Parameter about VC Feature, added by Tan Wang", "\n", "parser", ".", "add_argument", "(", "'--input_att_dir_vc'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the document containing VC Feature'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_json'", ",", "type", "=", "str", ",", "default", "=", "'data/coco.json'", ",", "\n", "help", "=", "'path to the json file containing additional info and vocab'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_fc_dir'", ",", "type", "=", "str", ",", "default", "=", "'data/cocotalk_fc'", ",", "\n", "help", "=", "'path to the directory containing the preprocessed fc feats'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_att_dir'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the directory containing the preprocessed att feats'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_box_dir'", ",", "type", "=", "str", ",", "default", "=", "'data/cocotalk_box'", ",", "\n", "help", "=", "'path to the directory containing the boxes of att feats'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_label_h5'", ",", "type", "=", "str", ",", "default", "=", "'data/coco_label.h5'", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--start_from'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"\"\"continue training from saved model at this path. Path must contain files saved by previous training process: \n                        'infos.pkl'         : configuration;\n                        'checkpoint'        : paths to model file(s) (created by tf).\n                                              Note: this file contains absolute paths, be careful when moving files around;\n                        'model.ckpt-*'      : file(s) with model definition (created by tf)\n                    \"\"\"", ")", "\n", "parser", ".", "add_argument", "(", "'--cached_tokens'", ",", "type", "=", "str", ",", "default", "=", "'coco-train-idxs'", ",", "\n", "help", "=", "'Cached token file for calculating cider score during self critical training.'", ")", "\n", "\n", "# Model settings", "\n", "parser", ".", "add_argument", "(", "'--caption_model'", ",", "type", "=", "str", ",", "default", "=", "\"show_tell\"", ",", "\n", "help", "=", "'show_tell, show_attend_tell, all_img, fc, att2in, att2in2, att2all2, adaatt, adaattmo, topdown, stackatt, denseatt, transformer'", ")", "\n", "parser", ".", "add_argument", "(", "'--rnn_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "'size of the rnn in number of hidden nodes in each layer'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_layers'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'number of layers in the RNN'", ")", "\n", "parser", ".", "add_argument", "(", "'--rnn_type'", ",", "type", "=", "str", ",", "default", "=", "'lstm'", ",", "\n", "help", "=", "'rnn, gru, or lstm'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_encoding_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "'the encoding size of each token in the vocabulary, and the image.'", ")", "\n", "parser", ".", "add_argument", "(", "'--att_hid_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "\n", "help", "=", "'the hidden size of the attention MLP; only useful in show_attend_tell; 0 if not using hidden layer'", ")", "\n", "parser", ".", "add_argument", "(", "'--fc_feat_size'", ",", "type", "=", "int", ",", "default", "=", "3072", ",", "\n", "help", "=", "'2048 for resnet, 4096 for vgg'", ")", "\n", "parser", ".", "add_argument", "(", "'--att_feat_size'", ",", "type", "=", "int", ",", "default", "=", "3072", ",", "\n", "help", "=", "'2048 for resnet, 512 for vgg'", ")", "\n", "parser", ".", "add_argument", "(", "'--logit_layers'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'number of layers in the RNN'", ")", "\n", "\n", "\n", "parser", ".", "add_argument", "(", "'--use_bn'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If 1, then do batch_normalization first in att_embed, if 2 then do bn both in the beginning and the end of att_embed'", ")", "\n", "\n", "# feature manipulation", "\n", "parser", ".", "add_argument", "(", "'--norm_att_feat'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If normalize attention features'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_box'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If use box features'", ")", "\n", "parser", ".", "add_argument", "(", "'--norm_box_feat'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If use box, do we normalize box feature'", ")", "\n", "\n", "# Optimization: General", "\n", "parser", ".", "add_argument", "(", "'--max_epochs'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'number of epochs'", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "type", "=", "int", ",", "default", "=", "16", ",", "\n", "help", "=", "'minibatch size'", ")", "\n", "parser", ".", "add_argument", "(", "'--grad_clip'", ",", "type", "=", "float", ",", "default", "=", "0.1", ",", "#5.,", "\n", "help", "=", "'clip gradients at this value'", ")", "\n", "parser", ".", "add_argument", "(", "'--drop_prob_lm'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "\n", "help", "=", "'strength of dropout in the Language Model RNN'", ")", "\n", "parser", ".", "add_argument", "(", "'--self_critical_after'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'After what epoch do we start finetuning the CNN? (-1 = disable; never finetune, 0 = finetune from start)'", ")", "\n", "parser", ".", "add_argument", "(", "'--seq_per_img'", ",", "type", "=", "int", ",", "default", "=", "5", ",", "\n", "help", "=", "'number of captions to sample for each image during training. Done for efficiency since CNN forward pass is expensive. E.g. coco has 5 sents/image'", ")", "\n", "\n", "# Sample related", "\n", "parser", ".", "add_argument", "(", "'--beam_size'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'used when sample_method = greedy, indicates number of beams in beam search. Usually 2 or 3 works well. More is not better. Set this to 1 for faster runtime but a bit worse performance.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_length'", ",", "type", "=", "int", ",", "default", "=", "20", ",", "\n", "help", "=", "'Maximum length during sampling'", ")", "\n", "parser", ".", "add_argument", "(", "'--length_penalty'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'wu_X or avg_X, X is the alpha'", ")", "\n", "parser", ".", "add_argument", "(", "'--block_trigrams'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'block repeated trigram.'", ")", "\n", "parser", ".", "add_argument", "(", "'--remove_bad_endings'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Remove bad endings'", ")", "\n", "\n", "#Optimization: for the Language Model", "\n", "parser", ".", "add_argument", "(", "'--optim'", ",", "type", "=", "str", ",", "default", "=", "'adam'", ",", "\n", "help", "=", "'what update to use? rmsprop|sgd|sgdmom|adagrad|adam'", ")", "\n", "parser", ".", "add_argument", "(", "'--learning_rate'", ",", "type", "=", "float", ",", "default", "=", "4e-4", ",", "\n", "help", "=", "'learning rate'", ")", "\n", "parser", ".", "add_argument", "(", "'--learning_rate_decay_start'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'at what iteration to start decaying learning rate? (-1 = dont) (in epoch)'", ")", "\n", "parser", ".", "add_argument", "(", "'--learning_rate_decay_every'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "\n", "help", "=", "'every how many iterations thereafter to drop LR?(in epoch)'", ")", "\n", "parser", ".", "add_argument", "(", "'--learning_rate_decay_rate'", ",", "type", "=", "float", ",", "default", "=", "0.8", ",", "\n", "help", "=", "'every how many iterations thereafter to drop LR?(in epoch)'", ")", "\n", "parser", ".", "add_argument", "(", "'--optim_alpha'", ",", "type", "=", "float", ",", "default", "=", "0.9", ",", "\n", "help", "=", "'alpha for adam'", ")", "\n", "parser", ".", "add_argument", "(", "'--optim_beta'", ",", "type", "=", "float", ",", "default", "=", "0.999", ",", "\n", "help", "=", "'beta used for adam'", ")", "\n", "parser", ".", "add_argument", "(", "'--optim_epsilon'", ",", "type", "=", "float", ",", "default", "=", "1e-8", ",", "\n", "help", "=", "'epsilon that goes into denominator for smoothing'", ")", "\n", "parser", ".", "add_argument", "(", "'--weight_decay'", ",", "type", "=", "float", ",", "default", "=", "0", ",", "\n", "help", "=", "'weight_decay'", ")", "\n", "# Transformer", "\n", "parser", ".", "add_argument", "(", "'--label_smoothing'", ",", "type", "=", "float", ",", "default", "=", "0", ",", "\n", "help", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--noamopt'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--noamopt_warmup'", ",", "type", "=", "int", ",", "default", "=", "2000", ",", "\n", "help", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--noamopt_factor'", ",", "type", "=", "float", ",", "default", "=", "1", ",", "\n", "help", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--reduce_on_plateau'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "''", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--scheduled_sampling_start'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'at what iteration to start decay gt probability'", ")", "\n", "parser", ".", "add_argument", "(", "'--scheduled_sampling_increase_every'", ",", "type", "=", "int", ",", "default", "=", "5", ",", "\n", "help", "=", "'every how many iterations thereafter to gt probability'", ")", "\n", "parser", ".", "add_argument", "(", "'--scheduled_sampling_increase_prob'", ",", "type", "=", "float", ",", "default", "=", "0.05", ",", "\n", "help", "=", "'How much to update the prob'", ")", "\n", "parser", ".", "add_argument", "(", "'--scheduled_sampling_max_prob'", ",", "type", "=", "float", ",", "default", "=", "0.25", ",", "\n", "help", "=", "'Maximum scheduled sampling prob.'", ")", "\n", "\n", "\n", "# Evaluation/Checkpointing", "\n", "parser", ".", "add_argument", "(", "'--val_images_use'", ",", "type", "=", "int", ",", "default", "=", "3200", ",", "\n", "help", "=", "'how many images to use when periodically evaluating the validation loss? (-1 = all)'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_checkpoint_every'", ",", "type", "=", "int", ",", "default", "=", "2500", ",", "\n", "help", "=", "'how often to save a model checkpoint (in iterations)?'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_history_ckpt'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'If save checkpoints at every save point'", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint_path'", ",", "type", "=", "str", ",", "default", "=", "'save'", ",", "\n", "help", "=", "'directory to store checkpointed models'", ")", "\n", "parser", ".", "add_argument", "(", "'--language_eval'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Evaluate language as well (1 = yes, 0 = no)? BLEU/CIDEr/METEOR/ROUGE_L? requires coco-caption code from Github.'", ")", "\n", "parser", ".", "add_argument", "(", "'--losses_log_every'", ",", "type", "=", "int", ",", "default", "=", "25", ",", "\n", "help", "=", "'How often do we snapshot losses, for inclusion in the progress dump? (0 = disable)'", ")", "\n", "parser", ".", "add_argument", "(", "'--load_best_score'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Do we load previous best score when resuming training.'", ")", "\n", "\n", "# misc", "\n", "parser", ".", "add_argument", "(", "'--id'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'an id identifying this run/job. used in cross-val and appended when writing progress files'", ")", "\n", "parser", ".", "add_argument", "(", "'--train_only'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'if true then use 80k, else use 110k'", ")", "\n", "\n", "\n", "# Reward", "\n", "parser", ".", "add_argument", "(", "'--cider_reward_weight'", ",", "type", "=", "float", ",", "default", "=", "1", ",", "\n", "help", "=", "'The reward weight from cider'", ")", "\n", "parser", ".", "add_argument", "(", "'--bleu_reward_weight'", ",", "type", "=", "float", ",", "default", "=", "0", ",", "\n", "help", "=", "'The reward weight from bleu4'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# Check if args are valid", "\n", "assert", "args", ".", "rnn_size", ">", "0", ",", "\"rnn_size should be greater than 0\"", "\n", "assert", "args", ".", "num_layers", ">", "0", ",", "\"num_layers should be greater than 0\"", "\n", "assert", "args", ".", "input_encoding_size", ">", "0", ",", "\"input_encoding_size should be greater than 0\"", "\n", "assert", "args", ".", "batch_size", ">", "0", ",", "\"batch_size should be greater than 0\"", "\n", "assert", "args", ".", "drop_prob_lm", ">=", "0", "and", "args", ".", "drop_prob_lm", "<", "1", ",", "\"drop_prob_lm should be between 0 and 1\"", "\n", "assert", "args", ".", "seq_per_img", ">", "0", ",", "\"seq_per_img should be greater than 0\"", "\n", "assert", "args", ".", "beam_size", ">", "0", ",", "\"beam_size should be greater than 0\"", "\n", "assert", "args", ".", "save_checkpoint_every", ">", "0", ",", "\"save_checkpoint_every should be greater than 0\"", "\n", "assert", "args", ".", "losses_log_every", ">", "0", ",", "\"losses_log_every should be greater than 0\"", "\n", "assert", "args", ".", "language_eval", "==", "0", "or", "args", ".", "language_eval", "==", "1", ",", "\"language_eval should be 0 or 1\"", "\n", "assert", "args", ".", "load_best_score", "==", "0", "or", "args", ".", "load_best_score", "==", "1", ",", "\"language_eval should be 0 or 1\"", "\n", "assert", "args", ".", "train_only", "==", "0", "or", "args", ".", "train_only", "==", "1", ",", "\"language_eval should be 0 or 1\"", "\n", "\n", "return", "args", "\n", "\n", "", "def", "add_eval_options", "(", "parser", ")", ":", "\n", "# Basic options", "\n", "    ", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'if > 0 then overrule, otherwise load from checkpoint.'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_images'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'how many images to use when periodically evaluating the loss? (-1 = all)'", ")", "\n", "parser", ".", "add_argument", "(", "'--language_eval'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Evaluate language as well (1 = yes, 0 = no)? BLEU/CIDEr/METEOR/ROUGE_L? requires coco-caption code from Github.'", ")", "\n", "parser", ".", "add_argument", "(", "'--dump_images'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Dump images into vis/imgs folder for vis? (1=yes,0=no)'", ")", "\n", "parser", ".", "add_argument", "(", "'--dump_json'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Dump json with predictions into vis folder? (1=yes,0=no)'", ")", "\n", "parser", ".", "add_argument", "(", "'--dump_path'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Write image paths along with predictions into vis json? (1=yes,0=no)'", ")", "\n", "\n", "# Sampling options", "\n", "parser", ".", "add_argument", "(", "'--sample_method'", ",", "type", "=", "str", ",", "default", "=", "'greedy'", ",", "\n", "help", "=", "'greedy; sample; gumbel; top<int>, top<0-1>'", ")", "\n", "parser", ".", "add_argument", "(", "'--beam_size'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "\n", "help", "=", "'indicates number of beams in beam search. Usually 2 or 3 works well. More is not better. Set this to 1 for faster runtime but a bit worse performance.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_length'", ",", "type", "=", "int", ",", "default", "=", "20", ",", "\n", "help", "=", "'Maximum length during sampling'", ")", "\n", "parser", ".", "add_argument", "(", "'--length_penalty'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'wu_X or avg_X, X is the alpha'", ")", "\n", "parser", ".", "add_argument", "(", "'--group_size'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'used for diverse beam search. if group_size is 1, then it\\'s normal beam search'", ")", "\n", "parser", ".", "add_argument", "(", "'--diversity_lambda'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "\n", "help", "=", "'used for diverse beam search. Usually from 0.2 to 0.8. Higher value of lambda produces a more diverse list'", ")", "\n", "parser", ".", "add_argument", "(", "'--temperature'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.opts.add_eval_options": [[204, 267], ["parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "function", ["None"], ["help", "=", "'temperature when sampling from distributions (i.e. when sample_method = sample). Lower = \"safer\" predictions.'", ")", "\n", "parser", ".", "add_argument", "(", "'--decoding_constraint'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If 1, not allowing same word in a row'", ")", "\n", "parser", ".", "add_argument", "(", "'--block_trigrams'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'block repeated trigram.'", ")", "\n", "parser", ".", "add_argument", "(", "'--remove_bad_endings'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Remove bad endings'", ")", "\n", "# For evaluation on a folder of images:", "\n", "parser", ".", "add_argument", "(", "'--image_folder'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'If this is nonempty then will predict on the images in this folder path'", ")", "\n", "parser", ".", "add_argument", "(", "'--image_root'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'In case the image paths have to be preprended with a root path to an image folder'", ")", "\n", "# For evaluation on MSCOCO images from some split:", "\n", "parser", ".", "add_argument", "(", "'--input_fc_dir'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_att_dir'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_box_dir'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_label_h5'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the h5file containing the preprocessed dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--input_json'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'path to the json file containing additional info and vocab. empty = fetch from model checkpoint.'", ")", "\n", "parser", ".", "add_argument", "(", "'--split'", ",", "type", "=", "str", ",", "default", "=", "'test'", ",", "\n", "help", "=", "'if running on MSCOCO images, which split to use: val|test|train'", ")", "\n", "parser", ".", "add_argument", "(", "'--coco_json'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'if nonempty then use this file in DataLoaderRaw (see docs there). Used only in MSCOCO test evaluation, where we have a specific json file of only test set images.'", ")", "\n", "# misc", "\n", "parser", ".", "add_argument", "(", "'--id'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'an id identifying this run/job. used only if language_eval = 1 for appending to intermediate files'", ")", "\n", "parser", ".", "add_argument", "(", "'--verbose_beam'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'if we need to print out all beam search beams.'", ")", "\n", "parser", ".", "add_argument", "(", "'--verbose_loss'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If calculate loss using ground truth during evaluation'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.add_summary_value": [[31, 34], ["writer.add_scalar"], "function", ["None"], ["\n", "# The random seed set by Tan Wang", "\n", "", "torch", ".", "manual_seed", "(", "777", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "777", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train": [[35, 272], ["misc.if_use_feat", "getattr", "dataloader.DataLoader", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "utils.pickle_load.get", "dataloader.DataLoader.get_vocab", "models.setup().cuda", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "misc.loss_wrapper.LossWrapper", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel.train", "tb.SummaryWriter", "os.path.isfile", "dataloader.DataLoader.get_vocab", "utils.pickle_load.get", "misc.get_std_opt", "os.path.isfile", "utils.build_optimizer.load_state_dict", "os.path.join", "torch.save", "torch.save", "torch.save", "print", "os.path.join", "torch.save", "torch.save", "torch.save", "open", "misc.pickle_load", "os.path.join", "models.setup", "misc.build_optimizer", "misc.ReduceLROnPlateau", "misc.build_optimizer", "vars().get", "os.path.join", "torch.load", "torch.load", "torch.load", "len", "os.path.isdir", "os.makedirs", "models.setup().cuda.state_dict", "utils.build_optimizer.state_dict", "open", "misc.pickle_dump", "time.time", "dataloader.DataLoader.get_batch", "print", "torch.cuda.synchronize", "torch.cuda.synchronize", "torch.cuda.synchronize", "time.time", "torch.nn.DataParallel.", "model_out[].mean", "loss_sp.backward", "torch.cuda.synchronize", "torch.cuda.synchronize", "torch.cuda.synchronize", "model_out[].mean.item", "time.time", "print", "train.train.save_checkpoint"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.if_use_feat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.get_std_opt", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.pickle_load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.__init__.setup", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.build_optimizer", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.build_optimizer", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.pickle_dump", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_batch", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dcn.deform_pool_func.DeformRoIPoolingFunction.backward", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.comm.synchronize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.pytorch_misc.save_checkpoint"], ["np", ".", "random", ".", "seed", "(", "777", ")", "\n", "\n", "\n", "def", "add_summary_value", "(", "writer", ",", "key", ",", "value", ",", "iteration", ")", ":", "\n", "    ", "if", "writer", ":", "\n", "        ", "writer", ".", "add_scalar", "(", "key", ",", "value", ",", "iteration", ")", "\n", "\n", "", "", "def", "train", "(", "opt", ")", ":", "\n", "# Deal with feature things before anything", "\n", "    ", "opt", ".", "use_fc", ",", "opt", ".", "use_att", "=", "utils", ".", "if_use_feat", "(", "opt", ".", "caption_model", ")", "\n", "if", "opt", ".", "use_box", ":", "opt", ".", "att_feat_size", "=", "opt", ".", "att_feat_size", "+", "5", "\n", "\n", "loader", "=", "DataLoader", "(", "opt", ")", "\n", "opt", ".", "vocab_size", "=", "loader", ".", "vocab_size", "\n", "opt", ".", "seq_length", "=", "loader", ".", "seq_length", "\n", "\n", "tb_summary_writer", "=", "tb", "and", "tb", ".", "SummaryWriter", "(", "opt", ".", "checkpoint_path", ")", "\n", "\n", "infos", "=", "{", "}", "\n", "histories", "=", "{", "}", "\n", "if", "opt", ".", "start_from", "is", "not", "None", ":", "\n", "# open old infos and check if models are compatible", "\n", "        ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "'infos_'", "+", "opt", ".", "id", "+", "'.pkl'", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "infos", "=", "utils", ".", "pickle_load", "(", "f", ")", "\n", "saved_model_opt", "=", "infos", "[", "'opt'", "]", "\n", "need_be_same", "=", "[", "\"caption_model\"", ",", "\"rnn_type\"", ",", "\"rnn_size\"", ",", "\"num_layers\"", "]", "\n", "for", "checkme", "in", "need_be_same", ":", "\n", "                ", "assert", "vars", "(", "saved_model_opt", ")", "[", "checkme", "]", "==", "vars", "(", "opt", ")", "[", "checkme", "]", ",", "\"Command line argument and saved model disagree on '%s' \"", "%", "checkme", "\n", "\n", "", "", "if", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "'histories_'", "+", "opt", ".", "id", "+", "'.pkl'", ")", ")", ":", "\n", "            ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "'histories_'", "+", "opt", ".", "id", "+", "'.pkl'", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "histories", "=", "utils", ".", "pickle_load", "(", "f", ")", "\n", "", "", "", "else", ":", "\n", "        ", "infos", "[", "'iter'", "]", "=", "0", "\n", "infos", "[", "'epoch'", "]", "=", "0", "\n", "infos", "[", "'iterators'", "]", "=", "loader", ".", "iterators", "\n", "infos", "[", "'split_ix'", "]", "=", "loader", ".", "split_ix", "\n", "infos", "[", "'vocab'", "]", "=", "loader", ".", "get_vocab", "(", ")", "\n", "", "infos", "[", "'opt'", "]", "=", "opt", "\n", "\n", "iteration", "=", "infos", ".", "get", "(", "'iter'", ",", "0", ")", "\n", "epoch", "=", "infos", ".", "get", "(", "'epoch'", ",", "0", ")", "\n", "\n", "val_result_history", "=", "histories", ".", "get", "(", "'val_result_history'", ",", "{", "}", ")", "\n", "loss_history", "=", "histories", ".", "get", "(", "'loss_history'", ",", "{", "}", ")", "\n", "lr_history", "=", "histories", ".", "get", "(", "'lr_history'", ",", "{", "}", ")", "\n", "ss_prob_history", "=", "histories", ".", "get", "(", "'ss_prob_history'", ",", "{", "}", ")", "\n", "\n", "loader", ".", "iterators", "=", "infos", ".", "get", "(", "'iterators'", ",", "loader", ".", "iterators", ")", "\n", "loader", ".", "split_ix", "=", "infos", ".", "get", "(", "'split_ix'", ",", "loader", ".", "split_ix", ")", "\n", "if", "opt", ".", "load_best_score", "==", "1", ":", "\n", "        ", "best_val_score", "=", "infos", ".", "get", "(", "'best_val_score'", ",", "None", ")", "\n", "\n", "", "opt", ".", "vocab", "=", "loader", ".", "get_vocab", "(", ")", "\n", "model", "=", "models", ".", "setup", "(", "opt", ")", ".", "cuda", "(", ")", "\n", "del", "opt", ".", "vocab", "\n", "dp_model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "model", ")", "\n", "lw_model", "=", "LossWrapper", "(", "model", ",", "opt", ")", "\n", "dp_lw_model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "lw_model", ")", "\n", "\n", "epoch_done", "=", "True", "\n", "# Assure in training mode", "\n", "dp_lw_model", ".", "train", "(", ")", "\n", "\n", "if", "opt", ".", "noamopt", ":", "\n", "        ", "assert", "opt", ".", "caption_model", "==", "'transformer'", ",", "'noamopt can only work with transformer'", "\n", "optimizer", "=", "utils", ".", "get_std_opt", "(", "model", ",", "factor", "=", "opt", ".", "noamopt_factor", ",", "warmup", "=", "opt", ".", "noamopt_warmup", ")", "\n", "optimizer", ".", "_step", "=", "iteration", "\n", "", "elif", "opt", ".", "reduce_on_plateau", ":", "\n", "        ", "optimizer", "=", "utils", ".", "build_optimizer", "(", "model", ".", "parameters", "(", ")", ",", "opt", ")", "\n", "optimizer", "=", "utils", ".", "ReduceLROnPlateau", "(", "optimizer", ",", "factor", "=", "0.5", ",", "patience", "=", "3", ")", "\n", "", "else", ":", "\n", "        ", "optimizer", "=", "utils", ".", "build_optimizer", "(", "model", ".", "parameters", "(", ")", ",", "opt", ")", "\n", "# Load the optimizer", "\n", "", "if", "vars", "(", "opt", ")", ".", "get", "(", "'start_from'", ",", "None", ")", "is", "not", "None", "and", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "\"optimizer.pth\"", ")", ")", ":", "\n", "        ", "optimizer", ".", "load_state_dict", "(", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "start_from", ",", "'optimizer.pth'", ")", ")", ")", "\n", "\n", "\n", "", "def", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ",", "histories", "=", "None", ",", "append", "=", "''", ")", ":", "\n", "        ", "if", "len", "(", "append", ")", ">", "0", ":", "\n", "            ", "append", "=", "'-'", "+", "append", "\n", "# if checkpoint_path doesn't exist", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "opt", ".", "checkpoint_path", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "opt", ".", "checkpoint_path", ")", "\n", "", "checkpoint_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoint_path", ",", "'model%s.pth'", "%", "(", "append", ")", ")", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "checkpoint_path", ")", "\n", "print", "(", "\"model saved to {}\"", ".", "format", "(", "checkpoint_path", ")", ")", "\n", "optimizer_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoint_path", ",", "'optimizer%s.pth'", "%", "(", "append", ")", ")", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "optimizer_path", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoint_path", ",", "'infos_'", "+", "opt", ".", "id", "+", "'%s.pkl'", "%", "(", "append", ")", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "utils", ".", "pickle_dump", "(", "infos", ",", "f", ")", "\n", "", "if", "histories", ":", "\n", "            ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoint_path", ",", "'histories_'", "+", "opt", ".", "id", "+", "'%s.pkl'", "%", "(", "append", ")", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "                ", "utils", ".", "pickle_dump", "(", "histories", ",", "f", ")", "\n", "\n", "", "", "", "try", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "if", "epoch_done", ":", "\n", "                ", "if", "not", "opt", ".", "noamopt", "and", "not", "opt", ".", "reduce_on_plateau", ":", "\n", "# Assign the learning rate", "\n", "                    ", "if", "epoch", ">", "opt", ".", "learning_rate_decay_start", "and", "opt", ".", "learning_rate_decay_start", ">=", "0", ":", "\n", "                        ", "frac", "=", "(", "epoch", "-", "opt", ".", "learning_rate_decay_start", ")", "//", "opt", ".", "learning_rate_decay_every", "\n", "decay_factor", "=", "opt", ".", "learning_rate_decay_rate", "**", "frac", "\n", "opt", ".", "current_lr", "=", "opt", ".", "learning_rate", "*", "decay_factor", "\n", "", "else", ":", "\n", "                        ", "opt", ".", "current_lr", "=", "opt", ".", "learning_rate", "\n", "", "utils", ".", "set_lr", "(", "optimizer", ",", "opt", ".", "current_lr", ")", "# set the decayed rate", "\n", "# Assign the scheduled sampling prob", "\n", "", "if", "epoch", ">", "opt", ".", "scheduled_sampling_start", "and", "opt", ".", "scheduled_sampling_start", ">=", "0", ":", "\n", "                    ", "frac", "=", "(", "epoch", "-", "opt", ".", "scheduled_sampling_start", ")", "//", "opt", ".", "scheduled_sampling_increase_every", "\n", "opt", ".", "ss_prob", "=", "min", "(", "opt", ".", "scheduled_sampling_increase_prob", "*", "frac", ",", "opt", ".", "scheduled_sampling_max_prob", ")", "\n", "model", ".", "ss_prob", "=", "opt", ".", "ss_prob", "\n", "\n", "# If start self critical training", "\n", "", "if", "opt", ".", "self_critical_after", "!=", "-", "1", "and", "epoch", ">=", "opt", ".", "self_critical_after", ":", "\n", "                    ", "sc_flag", "=", "True", "\n", "init_scorer", "(", "opt", ".", "cached_tokens", ")", "\n", "", "else", ":", "\n", "                    ", "sc_flag", "=", "False", "\n", "\n", "", "epoch_done", "=", "False", "\n", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "# Load data from train split (0)", "\n", "data", "=", "loader", ".", "get_batch", "(", "'train'", ")", "\n", "print", "(", "'Read data:'", ",", "time", ".", "time", "(", ")", "-", "start", ")", "\n", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "tmp", "=", "[", "data", "[", "'fc_feats'", "]", ",", "data", "[", "'att_feats'", "]", ",", "data", "[", "'labels'", "]", ",", "data", "[", "'masks'", "]", ",", "data", "[", "'att_masks'", "]", "]", "\n", "tmp", "=", "[", "_", "if", "_", "is", "None", "else", "_", ".", "cuda", "(", ")", "for", "_", "in", "tmp", "]", "\n", "fc_feats", ",", "att_feats", ",", "labels", ",", "masks", ",", "att_masks", "=", "tmp", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "model_out", "=", "dp_lw_model", "(", "fc_feats", ",", "att_feats", ",", "labels", ",", "masks", ",", "att_masks", ",", "data", "[", "'gts'", "]", ",", "torch", ".", "arange", "(", "0", ",", "len", "(", "data", "[", "'gts'", "]", ")", ")", ",", "sc_flag", ")", "\n", "\n", "loss", "=", "model_out", "[", "'loss'", "]", ".", "mean", "(", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "utils", ".", "clip_gradient", "(", "optimizer", ",", "opt", ".", "grad_clip", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "train_loss", "=", "loss", ".", "item", "(", ")", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "sc_flag", ":", "\n", "                ", "print", "(", "\"iter {} (epoch {}), train_loss = {:.3f}, time/batch = {:.3f}\"", ".", "format", "(", "iteration", ",", "epoch", ",", "train_loss", ",", "end", "-", "start", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"iter {} (epoch {}), avg_reward = {:.3f}, time/batch = {:.3f}\"", ".", "format", "(", "iteration", ",", "epoch", ",", "model_out", "[", "'reward'", "]", ".", "mean", "(", ")", ",", "end", "-", "start", ")", ")", "\n", "\n", "# Update the iteration and epoch", "\n", "", "iteration", "+=", "1", "\n", "if", "data", "[", "'bounds'", "]", "[", "'wrapped'", "]", ":", "\n", "                ", "epoch", "+=", "1", "\n", "epoch_done", "=", "True", "\n", "\n", "# Write the training loss summary", "\n", "", "if", "(", "iteration", "%", "opt", ".", "losses_log_every", "==", "0", ")", ":", "\n", "                ", "add_summary_value", "(", "tb_summary_writer", ",", "'train_loss'", ",", "train_loss", ",", "iteration", ")", "\n", "if", "opt", ".", "noamopt", ":", "\n", "                    ", "opt", ".", "current_lr", "=", "optimizer", ".", "rate", "(", ")", "\n", "", "elif", "opt", ".", "reduce_on_plateau", ":", "\n", "                    ", "opt", ".", "current_lr", "=", "optimizer", ".", "current_lr", "\n", "", "add_summary_value", "(", "tb_summary_writer", ",", "'learning_rate'", ",", "opt", ".", "current_lr", ",", "iteration", ")", "\n", "add_summary_value", "(", "tb_summary_writer", ",", "'scheduled_sampling_prob'", ",", "model", ".", "ss_prob", ",", "iteration", ")", "\n", "if", "sc_flag", ":", "\n", "                    ", "add_summary_value", "(", "tb_summary_writer", ",", "'avg_reward'", ",", "model_out", "[", "'reward'", "]", ".", "mean", "(", ")", ",", "iteration", ")", "\n", "\n", "", "loss_history", "[", "iteration", "]", "=", "train_loss", "if", "not", "sc_flag", "else", "model_out", "[", "'reward'", "]", ".", "mean", "(", ")", "\n", "lr_history", "[", "iteration", "]", "=", "opt", ".", "current_lr", "\n", "ss_prob_history", "[", "iteration", "]", "=", "model", ".", "ss_prob", "\n", "\n", "# update infos", "\n", "", "infos", "[", "'iter'", "]", "=", "iteration", "\n", "infos", "[", "'epoch'", "]", "=", "epoch", "\n", "infos", "[", "'iterators'", "]", "=", "loader", ".", "iterators", "\n", "infos", "[", "'split_ix'", "]", "=", "loader", ".", "split_ix", "\n", "\n", "# make evaluation on validation set, and save model", "\n", "if", "(", "iteration", "%", "opt", ".", "save_checkpoint_every", "==", "0", ")", ":", "\n", "# eval model", "\n", "                ", "eval_kwargs", "=", "{", "'split'", ":", "'val'", ",", "\n", "'dataset'", ":", "opt", ".", "input_json", "}", "\n", "eval_kwargs", ".", "update", "(", "vars", "(", "opt", ")", ")", "\n", "val_loss", ",", "predictions", ",", "lang_stats", "=", "eval_utils", ".", "eval_split", "(", "\n", "dp_model", ",", "lw_model", ".", "crit", ",", "loader", ",", "eval_kwargs", ")", "\n", "\n", "if", "opt", ".", "reduce_on_plateau", ":", "\n", "                    ", "if", "'CIDEr'", "in", "lang_stats", ":", "\n", "                        ", "optimizer", ".", "scheduler_step", "(", "-", "lang_stats", "[", "'CIDEr'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "optimizer", ".", "scheduler_step", "(", "val_loss", ")", "\n", "# Write validation result into summary", "\n", "", "", "add_summary_value", "(", "tb_summary_writer", ",", "'validation loss'", ",", "val_loss", ",", "iteration", ")", "\n", "if", "lang_stats", "is", "not", "None", ":", "\n", "                    ", "for", "k", ",", "v", "in", "lang_stats", ".", "items", "(", ")", ":", "\n", "                        ", "add_summary_value", "(", "tb_summary_writer", ",", "k", ",", "v", ",", "iteration", ")", "\n", "", "", "val_result_history", "[", "iteration", "]", "=", "{", "'loss'", ":", "val_loss", ",", "'lang_stats'", ":", "lang_stats", ",", "'predictions'", ":", "predictions", "}", "\n", "\n", "# Save model if is improving on validation result", "\n", "if", "opt", ".", "language_eval", "==", "1", ":", "\n", "                    ", "current_score", "=", "lang_stats", "[", "'CIDEr'", "]", "\n", "", "else", ":", "\n", "                    ", "current_score", "=", "-", "val_loss", "\n", "\n", "", "best_flag", "=", "False", "\n", "\n", "if", "best_val_score", "is", "None", "or", "current_score", ">", "best_val_score", ":", "\n", "                    ", "best_val_score", "=", "current_score", "\n", "best_flag", "=", "True", "\n", "\n", "# Dump miscalleous informations", "\n", "", "infos", "[", "'best_val_score'", "]", "=", "best_val_score", "\n", "histories", "[", "'val_result_history'", "]", "=", "val_result_history", "\n", "histories", "[", "'loss_history'", "]", "=", "loss_history", "\n", "histories", "[", "'lr_history'", "]", "=", "lr_history", "\n", "histories", "[", "'ss_prob_history'", "]", "=", "ss_prob_history", "\n", "\n", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ",", "histories", ")", "\n", "if", "opt", ".", "save_history_ckpt", ":", "\n", "                    ", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ",", "append", "=", "str", "(", "iteration", ")", ")", "\n", "\n", "", "if", "best_flag", ":", "\n", "                    ", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ",", "append", "=", "'best'", ")", "\n", "\n", "# Stop if reaching max epochs", "\n", "", "", "if", "epoch", ">=", "opt", ".", "max_epochs", "and", "opt", ".", "max_epochs", "!=", "-", "1", ":", "\n", "                ", "break", "\n", "", "", "", "except", "(", "RuntimeError", ",", "KeyboardInterrupt", ")", ":", "\n", "        ", "print", "(", "'Save ckpt on exception ...'", ")", "\n", "save_checkpoint", "(", "model", ",", "infos", ",", "optimizer", ")", "\n", "print", "(", "'Save ckpt done.'", ")", "\n", "stack_trace", "=", "traceback", ".", "format_exc", "(", ")", "\n", "print", "(", "stack_trace", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.eval_utils.count_bad": [[21, 27], ["sen.split.split"], "function", ["None"], ["def", "count_bad", "(", "sen", ")", ":", "\n", "    ", "sen", "=", "sen", ".", "split", "(", "' '", ")", "\n", "if", "sen", "[", "-", "1", "]", "in", "bad_endings", ":", "\n", "        ", "return", "1", "\n", "", "else", ":", "\n", "        ", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.eval_utils.language_eval": [[28, 73], ["sys.path.append", "os.path.join", "COCO", "COCO.getImgIds", "print", "json.dump", "COCO.loadRes", "COCOEvalCap", "coco.loadRes.getImgIds", "COCOEvalCap.evaluate", "COCOEvalCap.eval.items", "os.path.join", "os.path.isdir", "os.mkdir", "open", "sum", "float", "open", "json.dump", "len", "len", "len", "eval_utils.count_bad"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.getImgIds", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.loadRes", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.vqa.VQA.getImgIds", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.evaluation.__init__.evaluate", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.miscellaneous.mkdir", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.eval_utils.count_bad"], ["", "", "def", "language_eval", "(", "dataset", ",", "preds", ",", "model_id", ",", "split", ")", ":", "\n", "    ", "import", "sys", "\n", "sys", ".", "path", ".", "append", "(", "\"coco-caption\"", ")", "\n", "if", "'coco'", "in", "dataset", ":", "\n", "        ", "annFile", "=", "'coco-caption/annotations/captions_val2014.json'", "\n", "", "elif", "'flickr30k'", "in", "dataset", "or", "'f30k'", "in", "dataset", ":", "\n", "        ", "annFile", "=", "'coco-caption/f30k_captions4eval.json'", "\n", "", "from", "pycocotools", ".", "coco", "import", "COCO", "\n", "from", "pycocoevalcap", ".", "eval", "import", "COCOEvalCap", "\n", "\n", "# encoder.FLOAT_REPR = lambda o: format(o, '.3f')", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "'eval_results'", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'eval_results'", ")", "\n", "", "cache_path", "=", "os", ".", "path", ".", "join", "(", "'eval_results/'", ",", "'.cache_'", "+", "model_id", "+", "'_'", "+", "split", "+", "'.json'", ")", "\n", "\n", "coco", "=", "COCO", "(", "annFile", ")", "\n", "valids", "=", "coco", ".", "getImgIds", "(", ")", "\n", "\n", "# filter results to only those in MSCOCO validation set (will be about a third)", "\n", "preds_filt", "=", "[", "p", "for", "p", "in", "preds", "if", "p", "[", "'image_id'", "]", "in", "valids", "]", "\n", "print", "(", "'using %d/%d predictions'", "%", "(", "len", "(", "preds_filt", ")", ",", "len", "(", "preds", ")", ")", ")", "\n", "json", ".", "dump", "(", "preds_filt", ",", "open", "(", "cache_path", ",", "'w'", ")", ")", "# serialize to temporary json file. Sigh, COCO API...", "\n", "\n", "cocoRes", "=", "coco", ".", "loadRes", "(", "cache_path", ")", "\n", "cocoEval", "=", "COCOEvalCap", "(", "coco", ",", "cocoRes", ")", "\n", "cocoEval", ".", "params", "[", "'image_id'", "]", "=", "cocoRes", ".", "getImgIds", "(", ")", "\n", "cocoEval", ".", "evaluate", "(", ")", "\n", "\n", "# create output dictionary", "\n", "out", "=", "{", "}", "\n", "for", "metric", ",", "score", "in", "cocoEval", ".", "eval", ".", "items", "(", ")", ":", "\n", "        ", "out", "[", "metric", "]", "=", "score", "\n", "\n", "", "imgToEval", "=", "cocoEval", ".", "imgToEval", "\n", "for", "p", "in", "preds_filt", ":", "\n", "        ", "image_id", ",", "caption", "=", "p", "[", "'image_id'", "]", ",", "p", "[", "'caption'", "]", "\n", "imgToEval", "[", "image_id", "]", "[", "'caption'", "]", "=", "caption", "\n", "\n", "", "out", "[", "'bad_count_rate'", "]", "=", "sum", "(", "[", "count_bad", "(", "_", "[", "'caption'", "]", ")", "for", "_", "in", "preds_filt", "]", ")", "/", "float", "(", "len", "(", "preds_filt", ")", ")", "\n", "outfile_path", "=", "os", ".", "path", ".", "join", "(", "'eval_results/'", ",", "model_id", "+", "'_'", "+", "split", "+", "'.json'", ")", "\n", "with", "open", "(", "outfile_path", ",", "'w'", ")", "as", "outfile", ":", "\n", "        ", "json", ".", "dump", "(", "{", "'overall'", ":", "out", ",", "'imgToEval'", ":", "imgToEval", "}", ",", "outfile", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.eval_utils.eval_split": [[74, 166], ["eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "eval_kwargs.get", "str", "model.eval", "loader.reset_iterator", "model.train", "eval_kwargs.get", "loader.get_batch", "misc.decode_sequence", "enumerate", "range", "eval_utils.language_eval", "torch.no_grad", "torch.no_grad", "range", "loader.get_vocab", "predictions.append", "min", "predictions.pop", "print", "loader.get_batch.get", "torch.no_grad", "torch.no_grad", "crit().item", "_.cuda", "print", "print", "eval_kwargs.get", "eval_kwargs.get", "print", "os.system", "print", "_.cuda", "model", "crit", "numpy.arange", "numpy.arange", "str", "model", "numpy.arange", "len", "misc.decode_sequence", "os.path.join", "loader.get_vocab", "_[].unsqueeze"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.reset_iterator", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.train.train", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_batch", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.decode_sequence", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.eval_utils.language_eval", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.decode_sequence", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab"], ["", "def", "eval_split", "(", "model", ",", "crit", ",", "loader", ",", "eval_kwargs", "=", "{", "}", ")", ":", "\n", "    ", "verbose", "=", "eval_kwargs", ".", "get", "(", "'verbose'", ",", "True", ")", "\n", "verbose_beam", "=", "eval_kwargs", ".", "get", "(", "'verbose_beam'", ",", "1", ")", "\n", "verbose_loss", "=", "eval_kwargs", ".", "get", "(", "'verbose_loss'", ",", "1", ")", "\n", "num_images", "=", "eval_kwargs", ".", "get", "(", "'num_images'", ",", "eval_kwargs", ".", "get", "(", "'val_images_use'", ",", "-", "1", ")", ")", "\n", "split", "=", "eval_kwargs", ".", "get", "(", "'split'", ",", "'val'", ")", "\n", "lang_eval", "=", "eval_kwargs", ".", "get", "(", "'language_eval'", ",", "0", ")", "\n", "dataset", "=", "eval_kwargs", ".", "get", "(", "'dataset'", ",", "'coco'", ")", "\n", "beam_size", "=", "eval_kwargs", ".", "get", "(", "'beam_size'", ",", "1", ")", "\n", "remove_bad_endings", "=", "eval_kwargs", ".", "get", "(", "'remove_bad_endings'", ",", "0", ")", "\n", "os", ".", "environ", "[", "\"REMOVE_BAD_ENDINGS\"", "]", "=", "str", "(", "remove_bad_endings", ")", "# Use this nasty way to make other code clean since it's a global configuration", "\n", "\n", "# Make sure in the evaluation mode", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "loader", ".", "reset_iterator", "(", "split", ")", "\n", "\n", "n", "=", "0", "\n", "loss", "=", "0", "\n", "loss_sum", "=", "0", "\n", "loss_evals", "=", "1e-8", "\n", "predictions", "=", "[", "]", "\n", "while", "True", ":", "\n", "        ", "data", "=", "loader", ".", "get_batch", "(", "split", ")", "\n", "n", "=", "n", "+", "loader", ".", "batch_size", "\n", "\n", "if", "data", ".", "get", "(", "'labels'", ",", "None", ")", "is", "not", "None", "and", "verbose_loss", ":", "\n", "# forward the model to get loss", "\n", "            ", "tmp", "=", "[", "data", "[", "'fc_feats'", "]", ",", "data", "[", "'att_feats'", "]", ",", "data", "[", "'labels'", "]", ",", "data", "[", "'masks'", "]", ",", "data", "[", "'att_masks'", "]", "]", "\n", "tmp", "=", "[", "_", ".", "cuda", "(", ")", "if", "_", "is", "not", "None", "else", "_", "for", "_", "in", "tmp", "]", "\n", "fc_feats", ",", "att_feats", ",", "labels", ",", "masks", ",", "att_masks", "=", "tmp", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "loss", "=", "crit", "(", "model", "(", "fc_feats", ",", "att_feats", ",", "labels", ",", "att_masks", ")", ",", "labels", "[", ":", ",", "1", ":", "]", ",", "masks", "[", ":", ",", "1", ":", "]", ")", ".", "item", "(", ")", "\n", "", "loss_sum", "=", "loss_sum", "+", "loss", "\n", "loss_evals", "=", "loss_evals", "+", "1", "\n", "\n", "# forward the model to also get generated samples for each image", "\n", "# Only leave one feature for each image, in case duplicate sample", "\n", "", "tmp", "=", "[", "data", "[", "'fc_feats'", "]", "[", "np", ".", "arange", "(", "loader", ".", "batch_size", ")", "*", "loader", ".", "seq_per_img", "]", ",", "\n", "data", "[", "'att_feats'", "]", "[", "np", ".", "arange", "(", "loader", ".", "batch_size", ")", "*", "loader", ".", "seq_per_img", "]", ",", "\n", "data", "[", "'att_masks'", "]", "[", "np", ".", "arange", "(", "loader", ".", "batch_size", ")", "*", "loader", ".", "seq_per_img", "]", "if", "data", "[", "'att_masks'", "]", "is", "not", "None", "else", "None", "]", "\n", "tmp", "=", "[", "_", ".", "cuda", "(", ")", "if", "_", "is", "not", "None", "else", "_", "for", "_", "in", "tmp", "]", "\n", "fc_feats", ",", "att_feats", ",", "att_masks", "=", "tmp", "\n", "# forward the model to also get generated samples for each image", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "seq", "=", "model", "(", "fc_feats", ",", "att_feats", ",", "att_masks", ",", "opt", "=", "eval_kwargs", ",", "mode", "=", "'sample'", ")", "[", "0", "]", ".", "data", "\n", "\n", "# Print beam search", "\n", "", "if", "beam_size", ">", "1", "and", "verbose_beam", ":", "\n", "            ", "for", "i", "in", "range", "(", "loader", ".", "batch_size", ")", ":", "\n", "                ", "print", "(", "'\\n'", ".", "join", "(", "[", "utils", ".", "decode_sequence", "(", "loader", ".", "get_vocab", "(", ")", ",", "_", "[", "'seq'", "]", ".", "unsqueeze", "(", "0", ")", ")", "[", "0", "]", "for", "_", "in", "model", ".", "done_beams", "[", "i", "]", "]", ")", ")", "\n", "print", "(", "'--'", "*", "10", ")", "\n", "", "", "sents", "=", "utils", ".", "decode_sequence", "(", "loader", ".", "get_vocab", "(", ")", ",", "seq", ")", "\n", "\n", "for", "k", ",", "sent", "in", "enumerate", "(", "sents", ")", ":", "\n", "            ", "entry", "=", "{", "'image_id'", ":", "data", "[", "'infos'", "]", "[", "k", "]", "[", "'id'", "]", ",", "'caption'", ":", "sent", "}", "\n", "if", "eval_kwargs", ".", "get", "(", "'dump_path'", ",", "0", ")", "==", "1", ":", "\n", "                ", "entry", "[", "'file_name'", "]", "=", "data", "[", "'infos'", "]", "[", "k", "]", "[", "'file_path'", "]", "\n", "", "predictions", ".", "append", "(", "entry", ")", "\n", "if", "eval_kwargs", ".", "get", "(", "'dump_images'", ",", "0", ")", "==", "1", ":", "\n", "# dump the raw image to vis/ folder", "\n", "                ", "cmd", "=", "'cp \"'", "+", "os", ".", "path", ".", "join", "(", "eval_kwargs", "[", "'image_root'", "]", ",", "data", "[", "'infos'", "]", "[", "k", "]", "[", "'file_path'", "]", ")", "+", "'\" vis/imgs/img'", "+", "str", "(", "len", "(", "predictions", ")", ")", "+", "'.jpg'", "# bit gross", "\n", "print", "(", "cmd", ")", "\n", "os", ".", "system", "(", "cmd", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "                ", "print", "(", "'image %s: %s'", "%", "(", "entry", "[", "'image_id'", "]", ",", "entry", "[", "'caption'", "]", ")", ")", "\n", "\n", "# if we wrapped around the split or used up val imgs budget then bail", "\n", "", "", "ix0", "=", "data", "[", "'bounds'", "]", "[", "'it_pos_now'", "]", "\n", "ix1", "=", "data", "[", "'bounds'", "]", "[", "'it_max'", "]", "\n", "if", "num_images", "!=", "-", "1", ":", "\n", "            ", "ix1", "=", "min", "(", "ix1", ",", "num_images", ")", "\n", "", "for", "i", "in", "range", "(", "n", "-", "ix1", ")", ":", "\n", "            ", "predictions", ".", "pop", "(", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'evaluating validation preformance... %d/%d (%f)'", "%", "(", "ix0", "-", "1", ",", "ix1", ",", "loss", ")", ")", "\n", "\n", "", "if", "data", "[", "'bounds'", "]", "[", "'wrapped'", "]", ":", "\n", "            ", "break", "\n", "", "if", "num_images", ">=", "0", "and", "n", ">=", "num_images", ":", "\n", "            ", "break", "\n", "\n", "", "", "lang_stats", "=", "None", "\n", "if", "lang_eval", "==", "1", ":", "\n", "        ", "lang_stats", "=", "language_eval", "(", "dataset", ",", "predictions", ",", "eval_kwargs", "[", "'id'", "]", ",", "split", ")", "\n", "\n", "# Switch back to training mode", "\n", "", "model", ".", "train", "(", ")", "\n", "return", "loss_sum", "/", "loss_evals", ",", "predictions", ",", "lang_stats", "\n", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.HybridLoader.__init__": [[24, 43], ["db_path.endswith", "lmdb.open", "db_path.endswith", "numpy.load", "torch.load", "torch.load", "torch.load", "torch.load", "print", "numpy.load", "os.path.isdir"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["def", "__init__", "(", "self", ",", "db_path", ",", "ext", ")", ":", "\n", "        ", "self", ".", "db_path", "=", "db_path", "\n", "self", ".", "ext", "=", "ext", "\n", "if", "self", ".", "ext", "==", "'.npy'", ":", "\n", "            ", "self", ".", "loader", "=", "lambda", "x", ":", "np", ".", "load", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "loader", "=", "lambda", "x", ":", "np", ".", "load", "(", "x", ")", "[", "'feat'", "]", "\n", "", "if", "db_path", ".", "endswith", "(", "'.lmdb'", ")", ":", "\n", "            ", "self", ".", "db_type", "=", "'lmdb'", "\n", "self", ".", "env", "=", "lmdb", ".", "open", "(", "db_path", ",", "subdir", "=", "os", ".", "path", ".", "isdir", "(", "db_path", ")", ",", "\n", "readonly", "=", "True", ",", "lock", "=", "False", ",", "\n", "readahead", "=", "False", ",", "meminit", "=", "False", ")", "\n", "", "elif", "db_path", ".", "endswith", "(", "'.pth'", ")", ":", "# Assume a key,value dictionary", "\n", "            ", "self", ".", "db_type", "=", "'pth'", "\n", "self", ".", "feat_file", "=", "torch", ".", "load", "(", "db_path", ")", "\n", "self", ".", "loader", "=", "lambda", "x", ":", "x", "\n", "print", "(", "'HybridLoader: ext is ignored'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "db_type", "=", "'dir'", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.HybridLoader.get": [[44, 60], ["dataloader.HybridLoader.loader", "six.BytesIO", "env.begin", "txn.get", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["", "", "def", "get", "(", "self", ",", "key", ")", ":", "\n", "\n", "        ", "if", "self", ".", "db_type", "==", "'lmdb'", ":", "\n", "            ", "env", "=", "self", ".", "env", "\n", "with", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "                ", "byteflow", "=", "txn", ".", "get", "(", "key", ")", "\n", "", "f_input", "=", "six", ".", "BytesIO", "(", "byteflow", ")", "\n", "", "elif", "self", ".", "db_type", "==", "'pth'", ":", "\n", "            ", "f_input", "=", "self", ".", "feat_file", "[", "key", "]", "\n", "", "else", ":", "\n", "            ", "f_input", "=", "os", ".", "path", ".", "join", "(", "self", ".", "db_path", ",", "key", "+", "self", ".", "ext", ")", "\n", "\n", "# load image", "\n", "", "feat", "=", "self", ".", "loader", "(", "f_input", ")", "\n", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.reset_iterator": [[64, 68], ["dataloader.BlobFetcher"], "methods", ["None"], ["    ", "def", "reset_iterator", "(", "self", ",", "split", ")", ":", "\n", "        ", "del", "self", ".", "_prefetch_process", "[", "split", "]", "\n", "self", ".", "_prefetch_process", "[", "split", "]", "=", "BlobFetcher", "(", "split", ",", "self", ",", "split", "==", "'train'", ")", "\n", "self", ".", "iterators", "[", "split", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab_size": [[69, 71], ["None"], "methods", ["None"], ["", "def", "get_vocab_size", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "vocab_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_vocab": [[72, 74], ["None"], "methods", ["None"], ["", "def", "get_vocab", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "ix_to_word", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_seq_length": [[75, 77], ["None"], "methods", ["None"], ["", "def", "get_seq_length", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "seq_length", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.__init__": [[78, 154], ["getattr", "getattr", "getattr", "getattr", "getattr", "print", "json.load", "print", "dataloader.HybridLoader", "dataloader.HybridLoader", "dataloader.HybridLoader", "dataloader.HybridLoader", "len", "print", "range", "print", "print", "print", "dataloader.DataLoader.iterators.keys", "atexit.register", "open", "len", "print", "h5py.File", "print", "len", "dataloader.BlobFetcher", "print", "dataloader.DataLoader.iterators.keys", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append", "len", "len", "len", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append", "dataloader.DataLoader.split_ix[].append"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.registry.Registry.register", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys"], ["", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "opt", "=", "opt", "\n", "self", ".", "batch_size", "=", "self", ".", "opt", ".", "batch_size", "\n", "self", ".", "seq_per_img", "=", "opt", ".", "seq_per_img", "\n", "\n", "# feature related options", "\n", "self", ".", "use_fc", "=", "getattr", "(", "opt", ",", "'use_fc'", ",", "True", ")", "\n", "self", ".", "use_att", "=", "getattr", "(", "opt", ",", "'use_att'", ",", "True", ")", "\n", "self", ".", "use_box", "=", "getattr", "(", "opt", ",", "'use_box'", ",", "0", ")", "\n", "self", ".", "norm_att_feat", "=", "getattr", "(", "opt", ",", "'norm_att_feat'", ",", "0", ")", "\n", "self", ".", "norm_box_feat", "=", "getattr", "(", "opt", ",", "'norm_box_feat'", ",", "0", ")", "\n", "\n", "# load the json file which contains additional information about the dataset", "\n", "print", "(", "'DataLoader loading json file: '", ",", "opt", ".", "input_json", ")", "\n", "self", ".", "info", "=", "json", ".", "load", "(", "open", "(", "self", ".", "opt", ".", "input_json", ")", ")", "\n", "if", "'ix_to_word'", "in", "self", ".", "info", ":", "\n", "            ", "self", ".", "ix_to_word", "=", "self", ".", "info", "[", "'ix_to_word'", "]", "\n", "self", ".", "vocab_size", "=", "len", "(", "self", ".", "ix_to_word", ")", "\n", "print", "(", "'vocab size is '", ",", "self", ".", "vocab_size", ")", "\n", "\n", "# open the hdf5 file", "\n", "", "print", "(", "'DataLoader loading h5 file: '", ",", "opt", ".", "input_fc_dir", ",", "opt", ".", "input_att_dir", ",", "opt", ".", "input_box_dir", ",", "opt", ".", "input_label_h5", ")", "\n", "if", "self", ".", "opt", ".", "input_label_h5", "!=", "'none'", ":", "\n", "            ", "self", ".", "h5_label_file", "=", "h5py", ".", "File", "(", "self", ".", "opt", ".", "input_label_h5", ",", "'r'", ",", "driver", "=", "'core'", ")", "\n", "# load in the sequence data", "\n", "seq_size", "=", "self", ".", "h5_label_file", "[", "'labels'", "]", ".", "shape", "\n", "self", ".", "label", "=", "self", ".", "h5_label_file", "[", "'labels'", "]", "[", ":", "]", "\n", "self", ".", "seq_length", "=", "seq_size", "[", "1", "]", "\n", "print", "(", "'max sequence length in data is'", ",", "self", ".", "seq_length", ")", "\n", "# load the pointers in full to RAM (should be small enough)", "\n", "self", ".", "label_start_ix", "=", "self", ".", "h5_label_file", "[", "'label_start_ix'", "]", "[", ":", "]", "\n", "self", ".", "label_end_ix", "=", "self", ".", "h5_label_file", "[", "'label_end_ix'", "]", "[", ":", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "seq_length", "=", "1", "\n", "\n", "", "self", ".", "fc_loader", "=", "HybridLoader", "(", "self", ".", "opt", ".", "input_fc_dir", ",", "'.npy'", ")", "\n", "self", ".", "att_loader", "=", "HybridLoader", "(", "self", ".", "opt", ".", "input_att_dir", ",", "'.npz'", ")", "\n", "self", ".", "att_loader_vc", "=", "HybridLoader", "(", "self", ".", "opt", ".", "input_att_dir_vc", ",", "'.npy'", ")", "\n", "self", ".", "box_loader", "=", "HybridLoader", "(", "self", ".", "opt", ".", "input_box_dir", ",", "'.npy'", ")", "\n", "\n", "self", ".", "num_images", "=", "len", "(", "self", ".", "info", "[", "'images'", "]", ")", "# self.label_start_ix.shape[0]", "\n", "print", "(", "'read %d image features'", "%", "(", "self", ".", "num_images", ")", ")", "\n", "\n", "# separate out indexes for each of the provided splits", "\n", "self", ".", "split_ix", "=", "{", "'train'", ":", "[", "]", ",", "'val'", ":", "[", "]", ",", "'test'", ":", "[", "]", "}", "\n", "for", "ix", "in", "range", "(", "len", "(", "self", ".", "info", "[", "'images'", "]", ")", ")", ":", "\n", "            ", "img", "=", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "\n", "if", "not", "'split'", "in", "img", ":", "\n", "                ", "self", ".", "split_ix", "[", "'train'", "]", ".", "append", "(", "ix", ")", "\n", "self", ".", "split_ix", "[", "'val'", "]", ".", "append", "(", "ix", ")", "\n", "self", ".", "split_ix", "[", "'test'", "]", ".", "append", "(", "ix", ")", "\n", "", "elif", "img", "[", "'split'", "]", "==", "'train'", ":", "\n", "                ", "self", ".", "split_ix", "[", "'train'", "]", ".", "append", "(", "ix", ")", "\n", "", "elif", "img", "[", "'split'", "]", "==", "'val'", ":", "\n", "                ", "self", ".", "split_ix", "[", "'val'", "]", ".", "append", "(", "ix", ")", "\n", "", "elif", "img", "[", "'split'", "]", "==", "'test'", ":", "\n", "                ", "self", ".", "split_ix", "[", "'test'", "]", ".", "append", "(", "ix", ")", "\n", "", "elif", "opt", ".", "train_only", "==", "0", ":", "# restval", "\n", "                ", "self", ".", "split_ix", "[", "'train'", "]", ".", "append", "(", "ix", ")", "\n", "\n", "", "", "print", "(", "'assigned %d images to split train'", "%", "len", "(", "self", ".", "split_ix", "[", "'train'", "]", ")", ")", "\n", "print", "(", "'assigned %d images to split val'", "%", "len", "(", "self", ".", "split_ix", "[", "'val'", "]", ")", ")", "\n", "print", "(", "'assigned %d images to split test'", "%", "len", "(", "self", ".", "split_ix", "[", "'test'", "]", ")", ")", "\n", "\n", "self", ".", "iterators", "=", "{", "'train'", ":", "0", ",", "'val'", ":", "0", ",", "'test'", ":", "0", "}", "\n", "\n", "self", ".", "_prefetch_process", "=", "{", "}", "# The three prefetch process", "\n", "for", "split", "in", "self", ".", "iterators", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "_prefetch_process", "[", "split", "]", "=", "BlobFetcher", "(", "split", ",", "self", ",", "split", "==", "'train'", ")", "\n", "# Terminate the child process when the parent exists", "\n", "", "def", "cleanup", "(", ")", ":", "\n", "            ", "print", "(", "'Terminating BlobFetcher'", ")", "\n", "for", "split", "in", "self", ".", "iterators", ".", "keys", "(", ")", ":", "\n", "                ", "del", "self", ".", "_prefetch_process", "[", "split", "]", "\n", "", "", "import", "atexit", "\n", "atexit", ".", "register", "(", "cleanup", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_captions": [[155, 173], ["numpy.zeros", "range", "random.randint", "random.randint"], "methods", ["None"], ["", "def", "get_captions", "(", "self", ",", "ix", ",", "seq_per_img", ")", ":", "\n", "# fetch the sequence labels", "\n", "        ", "ix1", "=", "self", ".", "label_start_ix", "[", "ix", "]", "-", "1", "#label_start_ix starts from 1", "\n", "ix2", "=", "self", ".", "label_end_ix", "[", "ix", "]", "-", "1", "\n", "ncap", "=", "ix2", "-", "ix1", "+", "1", "# number of captions available for this image", "\n", "assert", "ncap", ">", "0", ",", "'an image does not have any label. this can be handled but right now isn\\'t'", "\n", "\n", "if", "ncap", "<", "seq_per_img", ":", "\n", "# we need to subsample (with replacement)", "\n", "            ", "seq", "=", "np", ".", "zeros", "(", "[", "seq_per_img", ",", "self", ".", "seq_length", "]", ",", "dtype", "=", "'int'", ")", "\n", "for", "q", "in", "range", "(", "seq_per_img", ")", ":", "\n", "                ", "ixl", "=", "random", ".", "randint", "(", "ix1", ",", "ix2", ")", "\n", "seq", "[", "q", ",", ":", "]", "=", "self", ".", "label", "[", "ixl", ",", ":", "self", ".", "seq_length", "]", "\n", "", "", "else", ":", "\n", "            ", "ixl", "=", "random", ".", "randint", "(", "ix1", ",", "ix2", "-", "seq_per_img", "+", "1", ")", "\n", "seq", "=", "self", ".", "label", "[", "ixl", ":", "ixl", "+", "seq_per_img", ",", ":", "self", ".", "seq_length", "]", "\n", "\n", "", "return", "seq", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_batch": [[174, 249], ["range", "zip", "numpy.stack", "max", "numpy.zeros", "range", "numpy.zeros", "range", "numpy.vstack", "numpy.array", "numpy.zeros", "enumerate", "dataloader.DataLoader._prefetch_process[].get", "fc_batch.append", "att_batch.append", "numpy.zeros", "hasattr", "label_batch.append", "hasattr", "[].get", "infos.append", "sum", "len", "len", "data[].sum", "list", "len", "gts.append", "gts.append", "sorted", "map", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.items", "torch.items", "zip", "len", "type"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["", "def", "get_batch", "(", "self", ",", "split", ",", "batch_size", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "batch_size", "or", "self", ".", "batch_size", "\n", "seq_per_img", "=", "self", ".", "seq_per_img", "\n", "\n", "fc_batch", "=", "[", "]", "# np.ndarray((batch_size * seq_per_img, self.opt.fc_feat_size), dtype = 'float32')", "\n", "att_batch", "=", "[", "]", "# np.ndarray((batch_size * seq_per_img, 14, 14, self.opt.att_feat_size), dtype = 'float32')", "\n", "label_batch", "=", "[", "]", "#np.zeros([batch_size * seq_per_img, self.seq_length + 2], dtype = 'int')", "\n", "\n", "wrapped", "=", "False", "\n", "\n", "infos", "=", "[", "]", "\n", "gts", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "# fetch image", "\n", "            ", "tmp_fc", ",", "tmp_att", ",", "tmp_seq", ",", "ix", ",", "tmp_wrapped", "=", "self", ".", "_prefetch_process", "[", "split", "]", ".", "get", "(", ")", "\n", "if", "tmp_wrapped", ":", "\n", "                ", "wrapped", "=", "True", "\n", "\n", "", "fc_batch", ".", "append", "(", "tmp_fc", ")", "\n", "att_batch", ".", "append", "(", "tmp_att", ")", "\n", "\n", "tmp_label", "=", "np", ".", "zeros", "(", "[", "seq_per_img", ",", "self", ".", "seq_length", "+", "2", "]", ",", "dtype", "=", "'int'", ")", "\n", "if", "hasattr", "(", "self", ",", "'h5_label_file'", ")", ":", "\n", "                ", "tmp_label", "[", ":", ",", "1", ":", "self", ".", "seq_length", "+", "1", "]", "=", "tmp_seq", "\n", "", "label_batch", ".", "append", "(", "tmp_label", ")", "\n", "\n", "# Used for reward evaluation", "\n", "if", "hasattr", "(", "self", ",", "'h5_label_file'", ")", ":", "\n", "                ", "gts", ".", "append", "(", "self", ".", "label", "[", "self", ".", "label_start_ix", "[", "ix", "]", "-", "1", ":", "self", ".", "label_end_ix", "[", "ix", "]", "]", ")", "\n", "", "else", ":", "\n", "                ", "gts", ".", "append", "(", "[", "]", ")", "\n", "\n", "# record associated info as well", "\n", "", "info_dict", "=", "{", "}", "\n", "info_dict", "[", "'ix'", "]", "=", "ix", "\n", "info_dict", "[", "'id'", "]", "=", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'id'", "]", "\n", "info_dict", "[", "'file_path'", "]", "=", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", ".", "get", "(", "'file_path'", ",", "''", ")", "\n", "infos", ".", "append", "(", "info_dict", ")", "\n", "\n", "# #sort by att_feat length", "\n", "# fc_batch, att_batch, label_batch, gts, infos = \\", "\n", "#     zip(*sorted(zip(fc_batch, att_batch, np.vsplit(label_batch, batch_size), gts, infos), key=lambda x: len(x[1]), reverse=True))", "\n", "", "fc_batch", ",", "att_batch", ",", "label_batch", ",", "gts", ",", "infos", "=", "zip", "(", "*", "sorted", "(", "zip", "(", "fc_batch", ",", "att_batch", ",", "label_batch", ",", "gts", ",", "infos", ")", ",", "key", "=", "lambda", "x", ":", "0", ",", "reverse", "=", "True", ")", ")", "\n", "data", "=", "{", "}", "\n", "data", "[", "'fc_feats'", "]", "=", "np", ".", "stack", "(", "sum", "(", "[", "[", "_", "]", "*", "seq_per_img", "for", "_", "in", "fc_batch", "]", ",", "[", "]", ")", ")", "\n", "# merge att_feats", "\n", "max_att_len", "=", "max", "(", "[", "_", ".", "shape", "[", "0", "]", "for", "_", "in", "att_batch", "]", ")", "\n", "data", "[", "'att_feats'", "]", "=", "np", ".", "zeros", "(", "[", "len", "(", "att_batch", ")", "*", "seq_per_img", ",", "max_att_len", ",", "att_batch", "[", "0", "]", ".", "shape", "[", "1", "]", "]", ",", "dtype", "=", "'float32'", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "att_batch", ")", ")", ":", "\n", "            ", "data", "[", "'att_feats'", "]", "[", "i", "*", "seq_per_img", ":", "(", "i", "+", "1", ")", "*", "seq_per_img", ",", ":", "att_batch", "[", "i", "]", ".", "shape", "[", "0", "]", "]", "=", "att_batch", "[", "i", "]", "\n", "", "data", "[", "'att_masks'", "]", "=", "np", ".", "zeros", "(", "data", "[", "'att_feats'", "]", ".", "shape", "[", ":", "2", "]", ",", "dtype", "=", "'float32'", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "att_batch", ")", ")", ":", "\n", "            ", "data", "[", "'att_masks'", "]", "[", "i", "*", "seq_per_img", ":", "(", "i", "+", "1", ")", "*", "seq_per_img", ",", ":", "att_batch", "[", "i", "]", ".", "shape", "[", "0", "]", "]", "=", "1", "\n", "# set att_masks to None if attention features have same length", "\n", "", "if", "data", "[", "'att_masks'", "]", ".", "sum", "(", ")", "==", "data", "[", "'att_masks'", "]", ".", "size", ":", "\n", "            ", "data", "[", "'att_masks'", "]", "=", "None", "\n", "\n", "", "data", "[", "'labels'", "]", "=", "np", ".", "vstack", "(", "label_batch", ")", "\n", "# generate mask", "\n", "nonzeros", "=", "np", ".", "array", "(", "list", "(", "map", "(", "lambda", "x", ":", "(", "x", "!=", "0", ")", ".", "sum", "(", ")", "+", "2", ",", "data", "[", "'labels'", "]", ")", ")", ")", "\n", "mask_batch", "=", "np", ".", "zeros", "(", "[", "data", "[", "'labels'", "]", ".", "shape", "[", "0", "]", ",", "self", ".", "seq_length", "+", "2", "]", ",", "dtype", "=", "'float32'", ")", "\n", "for", "ix", ",", "row", "in", "enumerate", "(", "mask_batch", ")", ":", "\n", "            ", "row", "[", ":", "nonzeros", "[", "ix", "]", "]", "=", "1", "\n", "", "data", "[", "'masks'", "]", "=", "mask_batch", "\n", "\n", "data", "[", "'gts'", "]", "=", "gts", "# all ground truth captions of each images", "\n", "data", "[", "'bounds'", "]", "=", "{", "'it_pos_now'", ":", "self", ".", "iterators", "[", "split", "]", ",", "'it_max'", ":", "len", "(", "self", ".", "split_ix", "[", "split", "]", ")", ",", "'wrapped'", ":", "wrapped", "}", "\n", "data", "[", "'infos'", "]", "=", "infos", "\n", "\n", "data", "=", "{", "k", ":", "torch", ".", "from_numpy", "(", "v", ")", "if", "type", "(", "v", ")", "is", "np", ".", "ndarray", "else", "v", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", "}", "# Turn all ndarray to torch tensor", "\n", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.__getitem__": [[253, 291], ["hasattr", "dataloader.DataLoader.att_loader.get", "dataloader.DataLoader.att_loader_vc.get", "numpy.hstack", "numpy.stack.reshape", "numpy.zeros", "numpy.mean", "numpy.zeros", "dataloader.DataLoader.get_captions", "str", "str", "dataloader.DataLoader.box_loader.get", "numpy.hsplit", "numpy.hstack", "numpy.hstack", "numpy.stack", "numpy.linalg.norm", "str", "sorted", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.get_captions", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"This function returns a tuple that is further passed to collate_fn\n        \"\"\"", "\n", "ix", "=", "index", "#self.split_ix[index]", "\n", "if", "self", ".", "use_att", ":", "\n", "            ", "att_feat", "=", "self", ".", "att_loader", ".", "get", "(", "str", "(", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'id'", "]", ")", ")", "\n", "att_feat_vc", "=", "self", ".", "att_loader_vc", ".", "get", "(", "str", "(", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'id'", "]", ")", ")", "\n", "assert", "att_feat", ".", "shape", "[", "0", "]", "==", "att_feat_vc", ".", "shape", "[", "0", "]", "\n", "att_feat", "=", "np", ".", "hstack", "(", "(", "att_feat", ",", "att_feat_vc", ")", ")", "\n", "# Reshape to K x C", "\n", "att_feat", "=", "att_feat", ".", "reshape", "(", "-", "1", ",", "att_feat", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "self", ".", "norm_att_feat", ":", "\n", "                ", "att_feat", "=", "att_feat", "/", "np", ".", "linalg", ".", "norm", "(", "att_feat", ",", "2", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "", "if", "self", ".", "use_box", ":", "\n", "                ", "box_feat", "=", "self", ".", "box_loader", ".", "get", "(", "str", "(", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'id'", "]", ")", ")", "\n", "# devided by image width and height", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "np", ".", "hsplit", "(", "box_feat", ",", "4", ")", "\n", "h", ",", "w", "=", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'height'", "]", ",", "self", ".", "info", "[", "'images'", "]", "[", "ix", "]", "[", "'width'", "]", "\n", "box_feat", "=", "np", ".", "hstack", "(", "(", "x1", "/", "w", ",", "y1", "/", "h", ",", "x2", "/", "w", ",", "y2", "/", "h", ",", "(", "x2", "-", "x1", ")", "*", "(", "y2", "-", "y1", ")", "/", "(", "w", "*", "h", ")", ")", ")", "# question? x2-x1+1??", "\n", "if", "self", ".", "norm_box_feat", ":", "\n", "                    ", "box_feat", "=", "box_feat", "/", "np", ".", "linalg", ".", "norm", "(", "box_feat", ",", "2", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "", "att_feat", "=", "np", ".", "hstack", "(", "[", "att_feat", ",", "box_feat", "]", ")", "\n", "# sort the features by the size of boxes", "\n", "att_feat", "=", "np", ".", "stack", "(", "sorted", "(", "att_feat", ",", "key", "=", "lambda", "x", ":", "x", "[", "-", "1", "]", ",", "reverse", "=", "True", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "att_feat", "=", "np", ".", "zeros", "(", "(", "1", ",", "1", ",", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", "", "if", "self", ".", "use_fc", ":", "\n", "# fc_feat = self.fc_loader.get(str(self.info['images'][ix]['id']))", "\n", "            ", "fc_feat", "=", "np", ".", "mean", "(", "att_feat", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "fc_feat", "=", "np", ".", "zeros", "(", "(", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", "", "if", "hasattr", "(", "self", ",", "'h5_label_file'", ")", ":", "\n", "            ", "seq", "=", "self", ".", "get_captions", "(", "ix", ",", "self", ".", "seq_per_img", ")", "\n", "", "else", ":", "\n", "            ", "seq", "=", "None", "\n", "", "return", "(", "fc_feat", ",", "\n", "att_feat", ",", "seq", ",", "\n", "ix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.DataLoader.__len__": [[292, 294], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "info", "[", "'images'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.SubsetSampler.__init__": [[301, 303], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "indices", ")", ":", "\n", "        ", "self", ".", "indices", "=", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.SubsetSampler.__iter__": [[304, 306], ["range", "len"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "indices", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "self", ".", "indices", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.SubsetSampler.__len__": [[307, 309], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.__init__": [[312, 319], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "split", ",", "dataloader", ",", "if_shuffle", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        db is a list of tuples containing: imcrop_name, caption, bbox_feat of gt box, imname\n        \"\"\"", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "dataloader", "=", "dataloader", "\n", "self", ".", "if_shuffle", "=", "if_shuffle", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.reset": [[321, 335], ["iter", "torch.DataLoader", "torch.DataLoader", "dataloader.SubsetSampler"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Two cases for this function to be triggered:\n        1. not hasattr(self, 'split_loader'): Resume from previous training. Create the dataset given the saved split_ix and iterator\n        2. wrapped: a new epoch, the split_ix and iterator have been updated in the get_minibatch_inds already.\n        \"\"\"", "\n", "# batch_size is 1, the merge is done in DataLoader class", "\n", "self", ".", "split_loader", "=", "iter", "(", "data", ".", "DataLoader", "(", "dataset", "=", "self", ".", "dataloader", ",", "\n", "batch_size", "=", "1", ",", "\n", "sampler", "=", "SubsetSampler", "(", "self", ".", "dataloader", ".", "split_ix", "[", "self", ".", "split", "]", "[", "self", ".", "dataloader", ".", "iterators", "[", "self", ".", "split", "]", ":", "]", ")", ",", "\n", "shuffle", "=", "False", ",", "\n", "pin_memory", "=", "True", ",", "\n", "num_workers", "=", "4", ",", "# 4 is usually enough", "\n", "collate_fn", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher._get_next_minibatch_inds": [[336, 352], ["len", "random.shuffle"], "methods", ["None"], ["", "def", "_get_next_minibatch_inds", "(", "self", ")", ":", "\n", "        ", "max_index", "=", "len", "(", "self", ".", "dataloader", ".", "split_ix", "[", "self", ".", "split", "]", ")", "\n", "wrapped", "=", "False", "\n", "\n", "ri", "=", "self", ".", "dataloader", ".", "iterators", "[", "self", ".", "split", "]", "\n", "ix", "=", "self", ".", "dataloader", ".", "split_ix", "[", "self", ".", "split", "]", "[", "ri", "]", "\n", "\n", "ri_next", "=", "ri", "+", "1", "\n", "if", "ri_next", ">=", "max_index", ":", "\n", "            ", "ri_next", "=", "0", "\n", "if", "self", ".", "if_shuffle", ":", "\n", "                ", "random", ".", "shuffle", "(", "self", ".", "dataloader", ".", "split_ix", "[", "self", ".", "split", "]", ")", "\n", "", "wrapped", "=", "True", "\n", "", "self", ".", "dataloader", ".", "iterators", "[", "self", ".", "split", "]", "=", "ri_next", "\n", "\n", "return", "ix", ",", "wrapped", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get": [[353, 365], ["dataloader.BlobFetcher._get_next_minibatch_inds", "dataloader.BlobFetcher.split_loader.next", "hasattr", "dataloader.BlobFetcher.reset", "dataloader.BlobFetcher.reset"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher._get_next_minibatch_inds", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.reset", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.reset"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "'split_loader'", ")", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "ix", ",", "wrapped", "=", "self", ".", "_get_next_minibatch_inds", "(", ")", "\n", "tmp", "=", "self", ".", "split_loader", ".", "next", "(", ")", "\n", "if", "wrapped", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "assert", "tmp", "[", "-", "1", "]", "==", "ix", ",", "\"ix not equal\"", "\n", "\n", "return", "tmp", "+", "[", "wrapped", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.r2c_vc.train._to_gpu": [[72, 80], ["isinstance", "td[].cuda", "v.cuda", "td[].items"], "function", ["None"], ["infos", "[", "'vocab'", "]", "=", "loader", ".", "get_vocab", "(", ")", "\n", "", "infos", "[", "'opt'", "]", "=", "opt", "\n", "\n", "iteration", "=", "infos", ".", "get", "(", "'iter'", ",", "0", ")", "\n", "epoch", "=", "infos", ".", "get", "(", "'epoch'", ",", "0", ")", "\n", "\n", "val_result_history", "=", "histories", ".", "get", "(", "'val_result_history'", ",", "{", "}", ")", "\n", "loss_history", "=", "histories", ".", "get", "(", "'loss_history'", ",", "{", "}", ")", "\n", "lr_history", "=", "histories", ".", "get", "(", "'lr_history'", ",", "{", "}", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.__init__": [[22, 81], ["allennlp.nn.InitializerApplicator", "allennlp.models.model.Model.__init__", "allennlp.modules.TimeDistributed", "allennlp.modules.TimeDistributed", "allennlp.modules.matrix_attention.BilinearMatrixAttention", "allennlp.modules.matrix_attention.BilinearMatrixAttention", "sum", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "allennlp.training.metrics.CategoricalAccuracy", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "initializer", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "allennlp.modules.TimeDistributed", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "allennlp.modules.InputVariationalDropout", "span_encoder.get_output_dim", "span_encoder.get_output_dim", "span_encoder.get_output_dim", "reasoning_encoder.get_output_dim", "span_encoder.get_output_dim", "span_encoder.get_output_dim"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "vocab", ":", "Vocabulary", ",", "\n", "span_encoder", ":", "Seq2SeqEncoder", ",", "\n", "reasoning_encoder", ":", "Seq2SeqEncoder", ",", "\n", "input_dropout", ":", "float", "=", "0.3", ",", "\n", "hidden_dim_maxpool", ":", "int", "=", "1024", ",", "\n", "class_embs", ":", "bool", "=", "True", ",", "\n", "reasoning_use_obj", ":", "bool", "=", "True", ",", "\n", "reasoning_use_answer", ":", "bool", "=", "True", ",", "\n", "reasoning_use_question", ":", "bool", "=", "True", ",", "\n", "pool_reasoning", ":", "bool", "=", "True", ",", "\n", "pool_answer", ":", "bool", "=", "True", ",", "\n", "pool_question", ":", "bool", "=", "False", ",", "\n", "initializer", ":", "InitializerApplicator", "=", "InitializerApplicator", "(", ")", ",", "\n", ")", ":", "\n", "        ", "super", "(", "AttentionQA", ",", "self", ")", ".", "__init__", "(", "vocab", ")", "\n", "\n", "# self.detector = SimpleDetector(pretrained=True, average_pool=True, semantic=class_embs, final_dim=512)", "\n", "###################################################################################################", "\n", "\n", "self", ".", "rnn_input_dropout", "=", "TimeDistributed", "(", "InputVariationalDropout", "(", "input_dropout", ")", ")", "if", "input_dropout", ">", "0", "else", "None", "\n", "\n", "self", ".", "span_encoder", "=", "TimeDistributed", "(", "span_encoder", ")", "\n", "self", ".", "reasoning_encoder", "=", "TimeDistributed", "(", "reasoning_encoder", ")", "\n", "\n", "self", ".", "span_attention", "=", "BilinearMatrixAttention", "(", "\n", "matrix_1_dim", "=", "span_encoder", ".", "get_output_dim", "(", ")", ",", "\n", "matrix_2_dim", "=", "span_encoder", ".", "get_output_dim", "(", ")", ",", "\n", ")", "\n", "\n", "self", ".", "obj_attention", "=", "BilinearMatrixAttention", "(", "\n", "matrix_1_dim", "=", "span_encoder", ".", "get_output_dim", "(", ")", ",", "\n", "matrix_2_dim", "=", "1024", ",", "\n", ")", "\n", "\n", "self", ".", "reasoning_use_obj", "=", "reasoning_use_obj", "\n", "self", ".", "reasoning_use_answer", "=", "reasoning_use_answer", "\n", "self", ".", "reasoning_use_question", "=", "reasoning_use_question", "\n", "self", ".", "pool_reasoning", "=", "pool_reasoning", "\n", "self", ".", "pool_answer", "=", "pool_answer", "\n", "self", ".", "pool_question", "=", "pool_question", "\n", "dim", "=", "sum", "(", "[", "d", "for", "d", ",", "to_pool", "in", "[", "(", "reasoning_encoder", ".", "get_output_dim", "(", ")", ",", "self", ".", "pool_reasoning", ")", ",", "\n", "(", "span_encoder", ".", "get_output_dim", "(", ")", ",", "self", ".", "pool_answer", ")", ",", "\n", "(", "span_encoder", ".", "get_output_dim", "(", ")", ",", "self", ".", "pool_question", ")", "]", "if", "to_pool", "]", ")", "\n", "\n", "self", ".", "final_mlp", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Dropout", "(", "input_dropout", ",", "inplace", "=", "False", ")", ",", "\n", "torch", ".", "nn", ".", "Linear", "(", "dim", ",", "hidden_dim_maxpool", ")", ",", "\n", "torch", ".", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "torch", ".", "nn", ".", "Dropout", "(", "input_dropout", ",", "inplace", "=", "False", ")", ",", "\n", "torch", ".", "nn", ".", "Linear", "(", "hidden_dim_maxpool", ",", "1", ")", ",", "\n", ")", "\n", "self", ".", "_accuracy", "=", "CategoricalAccuracy", "(", ")", "\n", "self", ".", "_loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "initializer", "(", "self", ")", "\n", "self", ".", "image_feature_embedding", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Dropout", "(", "p", "=", "0.1", ")", ",", "\n", "torch", ".", "nn", ".", "Linear", "(", "3072", ",", "1024", ")", ",", "\n", "torch", ".", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA._collect_obj_reps": [[83, 100], ["torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp.new_zeros", "torch.clamp.new_zeros", "torch.clamp.new_zeros", "range", "object_reps[].view", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "len", "torch.clamp.new_zeros.view", "torch.clamp.view", "torch.clamp.view", "torch.clamp.view"], "methods", ["None"], ["", "def", "_collect_obj_reps", "(", "self", ",", "span_tags", ",", "object_reps", ")", ":", "\n", "        ", "\"\"\"\n        Collect span-level object representations\n        :param span_tags: [batch_size, ..leading_dims.., L]\n        :param object_reps: [batch_size, max_num_objs_per_batch, obj_dim]\n        :return:\n        \"\"\"", "\n", "span_tags_fixed", "=", "torch", ".", "clamp", "(", "span_tags", ",", "min", "=", "0", ")", "# In case there were masked values here", "\n", "row_id", "=", "span_tags_fixed", ".", "new_zeros", "(", "span_tags_fixed", ".", "shape", ")", "\n", "row_id_broadcaster", "=", "torch", ".", "arange", "(", "0", ",", "row_id", ".", "shape", "[", "0", "]", ",", "step", "=", "1", ",", "device", "=", "row_id", ".", "device", ")", "[", ":", ",", "None", "]", "\n", "\n", "# Add extra diminsions to the row broadcaster so it matches row_id", "\n", "leading_dims", "=", "len", "(", "span_tags", ".", "shape", ")", "-", "2", "\n", "for", "i", "in", "range", "(", "leading_dims", ")", ":", "\n", "            ", "row_id_broadcaster", "=", "row_id_broadcaster", "[", "...", ",", "None", "]", "\n", "", "row_id", "+=", "row_id_broadcaster", "\n", "return", "object_reps", "[", "row_id", ".", "view", "(", "-", "1", ")", ",", "span_tags_fixed", ".", "view", "(", "-", "1", ")", "]", ".", "view", "(", "*", "span_tags_fixed", ".", "shape", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.embed_span": [[101, 117], ["model.AttentionQA._collect_obj_reps", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.AttentionQA.rnn_input_dropout", "model.AttentionQA.span_encoder"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA._collect_obj_reps", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "embed_span", "(", "self", ",", "span", ",", "span_tags", ",", "span_mask", ",", "object_reps", ")", ":", "\n", "        ", "\"\"\"\n        :param span: Thing that will get embed and turned into [batch_size, ..leading_dims.., L, word_dim]\n        :param span_tags: [batch_size, ..leading_dims.., L]\n        :param object_reps: [batch_size, max_num_objs_per_batch, obj_dim]\n        :param span_mask: [batch_size, ..leading_dims.., span_mask\n        :return:\n        \"\"\"", "\n", "retrieved_feats", "=", "self", ".", "_collect_obj_reps", "(", "span_tags", ",", "object_reps", ")", "\n", "\n", "span_rep", "=", "torch", ".", "cat", "(", "(", "span", "[", "'bert'", "]", ",", "retrieved_feats", ")", ",", "-", "1", ")", "\n", "# add recurrent dropout here", "\n", "if", "self", ".", "rnn_input_dropout", ":", "\n", "            ", "span_rep", "=", "self", ".", "rnn_input_dropout", "(", "span_rep", ")", "\n", "\n", "", "return", "self", ".", "span_encoder", "(", "span_rep", ",", "span_mask", ")", ",", "retrieved_feats", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.forward": [[118, 223], ["int", "model.AttentionQA.image_feature_embedding", "model.AttentionQA.embed_span", "model.AttentionQA.embed_span", "model.AttentionQA.span_attention().view", "allennlp.nn.util.masked_softmax", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "model.AttentionQA.obj_attention().view", "allennlp.nn.util.masked_softmax", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.AttentionQA.reasoning_encoder", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.AttentionQA.final_mlp().squeeze", "torch.softmax", "torch.softmax", "torch.softmax", "box_mask.sum().max().item", "model.AttentionQA.rnn_input_dropout", "allennlp.nn.util.replace_masked_values().max", "model.AttentionQA._loss", "model.AttentionQA._accuracy", "int", "ValueError", "model.AttentionQA.span_attention", "model.AttentionQA.obj_attention", "model.AttentionQA.final_mlp", "label.long().view", "box_mask.sum().max", "the_tags.max", "q_rep.view", "a_rep.view", "a_rep.view", "allennlp.nn.util.replace_masked_values", "int", "label.long", "box_mask.sum", "the_tags.max"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.embed_span", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.embed_span", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.modeling.utils.cat"], ["", "def", "forward", "(", "self", ",", "\n", "images", ":", "torch", ".", "Tensor", ",", "\n", "objects", ":", "torch", ".", "LongTensor", ",", "\n", "segms", ":", "torch", ".", "Tensor", ",", "\n", "boxes", ":", "torch", ".", "Tensor", ",", "\n", "box_mask", ":", "torch", ".", "LongTensor", ",", "\n", "question", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "question_tags", ":", "torch", ".", "LongTensor", ",", "\n", "question_mask", ":", "torch", ".", "LongTensor", ",", "\n", "answers", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "answer_tags", ":", "torch", ".", "LongTensor", ",", "\n", "answer_mask", ":", "torch", ".", "LongTensor", ",", "\n", "metadata", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "label", ":", "torch", ".", "LongTensor", "=", "None", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        :param images: [batch_size, 3, im_height, im_width]\n        :param objects: [batch_size, max_num_objects] Padded objects\n        :param boxes:  [batch_size, max_num_objects, 4] Padded boxes\n        :param box_mask: [batch_size, max_num_objects] Mask for whether or not each box is OK\n        :param question: AllenNLP representation of the question. [batch_size, num_answers, seq_length]\n        :param question_tags: A detection label for each item in the Q [batch_size, num_answers, seq_length]\n        :param question_mask: Mask for the Q [batch_size, num_answers, seq_length]\n        :param answers: AllenNLP representation of the answer. [batch_size, num_answers, seq_length]\n        :param answer_tags: A detection label for each item in the A [batch_size, num_answers, seq_length]\n        :param answer_mask: Mask for the As [batch_size, num_answers, seq_length]\n        :param metadata: Ignore, this is about which dataset item we're on\n        :param label: Optional, which item is valid\n        :return: shit\n        \"\"\"", "\n", "# Trim off boxes that are too long. this is an issue b/c dataparallel, it'll pad more zeros that are", "\n", "# not needed", "\n", "max_len", "=", "int", "(", "box_mask", ".", "sum", "(", "1", ")", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "images", "=", "images", "[", ":", ",", ":", "max_len", ",", ":", "]", "\n", "objects", "=", "objects", "[", ":", ",", ":", "max_len", "]", "\n", "box_mask", "=", "box_mask", "[", ":", ",", ":", "max_len", "]", "\n", "boxes", "=", "boxes", "[", ":", ",", ":", "max_len", "]", "\n", "segms", "=", "segms", "[", ":", ",", ":", "max_len", "]", "\n", "\n", "for", "tag_type", ",", "the_tags", "in", "(", "(", "'question'", ",", "question_tags", ")", ",", "(", "'answer'", ",", "answer_tags", ")", ")", ":", "\n", "            ", "if", "int", "(", "the_tags", ".", "max", "(", ")", ")", ">", "max_len", ":", "\n", "                ", "raise", "ValueError", "(", "\"Oh no! {}_tags has maximum of {} but objects is of dim {}. Values are\\n{}\"", ".", "format", "(", "\n", "tag_type", ",", "int", "(", "the_tags", ".", "max", "(", ")", ")", ",", "objects", ".", "shape", ",", "the_tags", "\n", ")", ")", "\n", "\n", "# obj_reps = self.detector(images=images, boxes=boxes, box_mask=box_mask, classes=objects, segms=segms)", "\n", "", "", "img_feature", "=", "self", ".", "image_feature_embedding", "(", "images", ")", "\n", "# Now get the question representations", "\n", "q_rep", ",", "q_obj_reps", "=", "self", ".", "embed_span", "(", "question", ",", "question_tags", ",", "question_mask", ",", "img_feature", ")", "\n", "a_rep", ",", "a_obj_reps", "=", "self", ".", "embed_span", "(", "answers", ",", "answer_tags", ",", "answer_mask", ",", "img_feature", ")", "\n", "\n", "####################################", "\n", "# Perform Q by A attention", "\n", "# [batch_size, 4, question_length, answer_length]", "\n", "qa_similarity", "=", "self", ".", "span_attention", "(", "\n", "q_rep", ".", "view", "(", "q_rep", ".", "shape", "[", "0", "]", "*", "q_rep", ".", "shape", "[", "1", "]", ",", "q_rep", ".", "shape", "[", "2", "]", ",", "q_rep", ".", "shape", "[", "3", "]", ")", ",", "\n", "a_rep", ".", "view", "(", "a_rep", ".", "shape", "[", "0", "]", "*", "a_rep", ".", "shape", "[", "1", "]", ",", "a_rep", ".", "shape", "[", "2", "]", ",", "a_rep", ".", "shape", "[", "3", "]", ")", ",", "\n", ")", ".", "view", "(", "a_rep", ".", "shape", "[", "0", "]", ",", "a_rep", ".", "shape", "[", "1", "]", ",", "q_rep", ".", "shape", "[", "2", "]", ",", "a_rep", ".", "shape", "[", "2", "]", ")", "\n", "qa_attention_weights", "=", "masked_softmax", "(", "qa_similarity", ",", "question_mask", "[", "...", ",", "None", "]", ",", "dim", "=", "2", ")", "\n", "attended_q", "=", "torch", ".", "einsum", "(", "'bnqa,bnqd->bnad'", ",", "(", "qa_attention_weights", ",", "q_rep", ")", ")", "\n", "\n", "# Have a second attention over the objects, do A by Objs", "\n", "# [batch_size, 4, answer_length, num_objs]", "\n", "atoo_similarity", "=", "self", ".", "obj_attention", "(", "a_rep", ".", "view", "(", "a_rep", ".", "shape", "[", "0", "]", ",", "a_rep", ".", "shape", "[", "1", "]", "*", "a_rep", ".", "shape", "[", "2", "]", ",", "-", "1", ")", ",", "\n", "img_feature", ")", ".", "view", "(", "a_rep", ".", "shape", "[", "0", "]", ",", "a_rep", ".", "shape", "[", "1", "]", ",", "\n", "a_rep", ".", "shape", "[", "2", "]", ",", "img_feature", ".", "shape", "[", "1", "]", ")", "\n", "atoo_attention_weights", "=", "masked_softmax", "(", "atoo_similarity", ",", "box_mask", "[", ":", ",", "None", ",", "None", "]", ")", "\n", "attended_o", "=", "torch", ".", "einsum", "(", "'bnao,bod->bnad'", ",", "(", "atoo_attention_weights", ",", "img_feature", ")", ")", "\n", "\n", "\n", "reasoning_inp", "=", "torch", ".", "cat", "(", "[", "x", "for", "x", ",", "to_pool", "in", "[", "(", "a_rep", ",", "self", ".", "reasoning_use_answer", ")", ",", "\n", "(", "attended_o", ",", "self", ".", "reasoning_use_obj", ")", ",", "\n", "(", "attended_q", ",", "self", ".", "reasoning_use_question", ")", "]", "\n", "if", "to_pool", "]", ",", "-", "1", ")", "\n", "\n", "if", "self", ".", "rnn_input_dropout", "is", "not", "None", ":", "\n", "            ", "reasoning_inp", "=", "self", ".", "rnn_input_dropout", "(", "reasoning_inp", ")", "\n", "", "reasoning_output", "=", "self", ".", "reasoning_encoder", "(", "reasoning_inp", ",", "answer_mask", ")", "\n", "\n", "\n", "###########################################", "\n", "things_to_pool", "=", "torch", ".", "cat", "(", "[", "x", "for", "x", ",", "to_pool", "in", "[", "(", "reasoning_output", ",", "self", ".", "pool_reasoning", ")", ",", "\n", "(", "a_rep", ",", "self", ".", "pool_answer", ")", ",", "\n", "(", "attended_q", ",", "self", ".", "pool_question", ")", "]", "if", "to_pool", "]", ",", "-", "1", ")", "\n", "\n", "pooled_rep", "=", "replace_masked_values", "(", "things_to_pool", ",", "answer_mask", "[", "...", ",", "None", "]", ",", "-", "1e7", ")", ".", "max", "(", "2", ")", "[", "0", "]", "\n", "logits", "=", "self", ".", "final_mlp", "(", "pooled_rep", ")", ".", "squeeze", "(", "2", ")", "\n", "\n", "###########################################", "\n", "\n", "class_probabilities", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "-", "1", ")", "\n", "\n", "output_dict", "=", "{", "\"label_logits\"", ":", "logits", ",", "\"label_probs\"", ":", "class_probabilities", ",", "\n", "# 'cnn_regularization_loss': obj_reps['cnn_regularization_loss'],", "\n", "# Uncomment to visualize attention, if you want", "\n", "# 'qa_attention_weights': qa_attention_weights,", "\n", "# 'atoo_attention_weights': atoo_attention_weights,", "\n", "}", "\n", "\n", "\n", "if", "label", "is", "not", "None", ":", "\n", "            ", "loss", "=", "self", ".", "_loss", "(", "logits", ",", "label", ".", "long", "(", ")", ".", "view", "(", "-", "1", ")", ")", "\n", "self", ".", "_accuracy", "(", "logits", ",", "label", ")", "\n", "output_dict", "[", "\"loss\"", "]", "=", "loss", "[", "None", "]", "\n", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.multiatt.model.AttentionQA.get_metrics": [[224, 226], ["model.AttentionQA._accuracy.get_metric"], "methods", ["None"], ["", "def", "get_metrics", "(", "self", ",", "reset", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "        ", "return", "{", "'accuracy'", ":", "self", ".", "_accuracy", ".", "get_metric", "(", "reset", ")", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.box_utils.load_image": [[12, 16], ["torchvision.datasets.folder.default_loader"], "function", ["None"], ["def", "load_image", "(", "img_fn", ")", ":", "\n", "    ", "\"\"\"Load the specified image and return a [H,W,3] Numpy array.\n    \"\"\"", "\n", "return", "default_loader", "(", "img_fn", ")", "\n", "# # Load image", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.box_utils.resize_image": [[31, 65], ["min", "all", "torchvision.transforms.functional.pad", "torchvision.transforms.functional.resize", "random.randint", "random.randint", "round", "round"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize"], ["", "def", "resize_image", "(", "image", ",", "desired_width", "=", "768", ",", "desired_height", "=", "384", ",", "random_pad", "=", "False", ")", ":", "\n", "    ", "\"\"\"Resizes an image keeping the aspect ratio mostly unchanged.\n\n    Returns:\n    image: the resized image\n    window: (x1, y1, x2, y2). If max_dim is provided, padding might\n        be inserted in the returned image. If so, this window is the\n        coordinates of the image part of the full image (excluding\n        the padding). The x2, y2 pixels are not included.\n    scale: The scale factor used to resize the image\n    padding: Padding added to the image [left, top, right, bottom]\n    \"\"\"", "\n", "# Default window (x1, y1, x2, y2) and default scale == 1.", "\n", "w", ",", "h", "=", "image", ".", "size", "\n", "\n", "width_scale", "=", "desired_width", "/", "w", "\n", "height_scale", "=", "desired_height", "/", "h", "\n", "scale", "=", "min", "(", "width_scale", ",", "height_scale", ")", "\n", "\n", "# Resize image using bilinear interpolation", "\n", "if", "scale", "!=", "1", ":", "\n", "        ", "image", "=", "functional", ".", "resize", "(", "image", ",", "(", "round", "(", "h", "*", "scale", ")", ",", "round", "(", "w", "*", "scale", ")", ")", ")", "\n", "", "w", ",", "h", "=", "image", ".", "size", "\n", "y_pad", "=", "desired_height", "-", "h", "\n", "x_pad", "=", "desired_width", "-", "w", "\n", "top_pad", "=", "random", ".", "randint", "(", "0", ",", "y_pad", ")", "if", "random_pad", "else", "y_pad", "//", "2", "\n", "left_pad", "=", "random", ".", "randint", "(", "0", ",", "x_pad", ")", "if", "random_pad", "else", "x_pad", "//", "2", "\n", "\n", "padding", "=", "(", "left_pad", ",", "top_pad", ",", "x_pad", "-", "left_pad", ",", "y_pad", "-", "top_pad", ")", "\n", "assert", "all", "(", "[", "x", ">=", "0", "for", "x", "in", "padding", "]", ")", "\n", "image", "=", "functional", ".", "pad", "(", "image", ",", "padding", ")", "\n", "window", "=", "[", "left_pad", ",", "top_pad", ",", "w", "+", "left_pad", ",", "h", "+", "top_pad", "]", "\n", "\n", "return", "image", ",", "window", ",", "scale", ",", "padding", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.mask_utils._spaced_points": [[7, 11], ["numpy.linspace"], "function", ["None"], ["def", "_spaced_points", "(", "low", ",", "high", ",", "n", ")", ":", "\n", "    ", "\"\"\" We want n points between low and high, but we don't want them to touch either side\"\"\"", "\n", "padding", "=", "(", "high", "-", "low", ")", "/", "(", "n", "*", "2", ")", "\n", "return", "np", ".", "linspace", "(", "low", "+", "padding", ",", "high", "-", "padding", ",", "num", "=", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.mask_utils.make_mask": [[12, 28], ["numpy.zeros", "numpy.meshgrid", "numpy.stack().reshape", "np.zeros.astype", "mask_utils._spaced_points", "mask_utils._spaced_points", "matplotlib.path.Path", "path.Path.contains_points().reshape", "numpy.stack", "path.Path.contains_points"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.mask_utils._spaced_points", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.mask_utils._spaced_points"], ["", "def", "make_mask", "(", "mask_size", ",", "box", ",", "polygons_list", ")", ":", "\n", "    ", "\"\"\"\n    Mask size: int about how big mask will be\n    box: [x1, y1, x2, y2, conf.]\n    polygons_list: List of polygons that go inside the box\n    \"\"\"", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "mask_size", ",", "mask_size", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "\n", "xy", "=", "np", ".", "meshgrid", "(", "_spaced_points", "(", "box", "[", "0", "]", ",", "box", "[", "2", "]", ",", "n", "=", "mask_size", ")", ",", "\n", "_spaced_points", "(", "box", "[", "1", "]", ",", "box", "[", "3", "]", ",", "n", "=", "mask_size", ")", ")", "\n", "xy_flat", "=", "np", ".", "stack", "(", "xy", ",", "2", ")", ".", "reshape", "(", "(", "-", "1", ",", "2", ")", ")", "\n", "\n", "for", "polygon", "in", "polygons_list", ":", "\n", "        ", "polygon_path", "=", "path", ".", "Path", "(", "polygon", ")", "\n", "mask", "|=", "polygon_path", ".", "contains_points", "(", "xy_flat", ")", ".", "reshape", "(", "(", "mask_size", ",", "mask_size", ")", ")", "\n", "", "return", "mask", ".", "astype", "(", "np", ".", "float32", ")", "\n", "#", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.__init__": [[25, 35], ["len", "ValueError", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "tokens", ":", "List", "[", "Token", "]", ",", "embs", ":", "numpy", ".", "ndarray", ",", "padding_value", ":", "int", "=", "0", ",", "\n", "token_indexers", "=", "None", ")", "->", "None", ":", "\n", "        ", "self", ".", "tokens", "=", "tokens", "\n", "self", ".", "embs", "=", "embs", "\n", "self", ".", "padding_value", "=", "padding_value", "\n", "\n", "if", "len", "(", "self", ".", "tokens", ")", "!=", "self", ".", "embs", ".", "shape", "[", "0", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"The tokens you passed into the BERTField, {} \"", "\n", "\"aren't the same size as the embeddings of shape {}\"", ".", "format", "(", "self", ".", "tokens", ",", "self", ".", "embs", ".", "shape", ")", ")", "\n", "", "assert", "len", "(", "self", ".", "tokens", ")", "==", "self", ".", "embs", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.sequence_length": [[36, 39], ["len"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "sequence_length", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "len", "(", "self", ".", "tokens", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.get_padding_lengths": [[41, 44], ["bert_field.BertField.sequence_length"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.sequence_length"], ["", "@", "overrides", "\n", "def", "get_padding_lengths", "(", "self", ")", "->", "Dict", "[", "str", ",", "int", "]", ":", "\n", "        ", "return", "{", "'num_tokens'", ":", "self", ".", "sequence_length", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.as_tensor": [[45, 55], ["torch.from_numpy", "numpy.ones", "bert_field.BertField.sequence_length"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.sequence_length"], ["", "@", "overrides", "\n", "def", "as_tensor", "(", "self", ",", "padding_lengths", ":", "Dict", "[", "str", ",", "int", "]", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "num_tokens", "=", "padding_lengths", "[", "'num_tokens'", "]", "\n", "\n", "new_arr", "=", "numpy", ".", "ones", "(", "(", "num_tokens", ",", "self", ".", "embs", ".", "shape", "[", "1", "]", ")", ",", "\n", "dtype", "=", "numpy", ".", "float32", ")", "*", "self", ".", "padding_value", "\n", "new_arr", "[", ":", "self", ".", "sequence_length", "(", ")", "]", "=", "self", ".", "embs", "\n", "\n", "tensor", "=", "torch", ".", "from_numpy", "(", "new_arr", ")", "\n", "return", "{", "'bert'", ":", "tensor", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.empty_field": [[56, 59], ["bert_field.BertField", "numpy.array"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "empty_field", "(", "self", ")", ":", "\n", "        ", "return", "BertField", "(", "[", "]", ",", "numpy", ".", "array", "(", "[", "]", ",", "dtype", "=", "\"float32\"", ")", ",", "padding_value", "=", "self", ".", "padding_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.batch_tensors": [[60, 66], ["allennlp.nn.util.batch_tensor_dicts"], "methods", ["None"], ["", "@", "overrides", "\n", "def", "batch_tensors", "(", "self", ",", "tensor_list", ":", "List", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "# pylint: disable=no-self-use", "\n", "# This is creating a dict of {token_indexer_key: batch_tensor} for each token indexer used", "\n", "# to index this field.", "\n", "        ", "return", "util", ".", "batch_tensor_dicts", "(", "tensor_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.bert_field.BertField.__str__": [[68, 70], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "f\"BertField: {self.tokens} and  {self.embs.shape}.\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.__init__": [[35, 52], ["lmdb.open", "_image_features_reader.ImageFeaturesH5Reader.env.begin", "pickle.loads", "len", "len", "len", "len", "txn.get"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get"], ["def", "__init__", "(", "self", ",", "features_path", ":", "str", ",", "in_memory", ":", "bool", "=", "False", ")", ":", "\n", "        ", "self", ".", "features_path", "=", "features_path", "\n", "self", ".", "_in_memory", "=", "in_memory", "\n", "\n", "# with h5py.File(self.features_h5path, \"r\", libver='latest', swmr=True) as features_h5:", "\n", "# self._image_ids = list(features_h5[\"image_ids\"])", "\n", "# If not loaded in memory, then list of None.", "\n", "self", ".", "env", "=", "lmdb", ".", "open", "(", "self", ".", "features_path", ",", "max_readers", "=", "1", ",", "readonly", "=", "True", ",", "\n", "lock", "=", "False", ",", "readahead", "=", "False", ",", "meminit", "=", "False", ")", "\n", "\n", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "self", ".", "_image_ids", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "'keys'", ".", "encode", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "features", "=", "[", "None", "]", "*", "len", "(", "self", ".", "_image_ids", ")", "\n", "self", ".", "num_boxes", "=", "[", "None", "]", "*", "len", "(", "self", ".", "_image_ids", ")", "\n", "self", ".", "boxes", "=", "[", "None", "]", "*", "len", "(", "self", ".", "_image_ids", ")", "\n", "self", ".", "boxes_ori", "=", "[", "None", "]", "*", "len", "(", "self", ".", "_image_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.__len__": [[53, 55], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_image_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.__getitem__": [[56, 163], ["str().encode", "_image_features_reader.ImageFeaturesH5Reader._image_ids.index", "str", "_image_features_reader.ImageFeaturesH5Reader.env.begin", "pickle.loads", "int", "int", "int", "numpy.frombuffer().reshape", "numpy.frombuffer().reshape", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.zeros", "copy.deepcopy", "numpy.array", "numpy.concatenate", "numpy.array", "numpy.concatenate", "_image_features_reader.ImageFeaturesH5Reader.env.begin", "pickle.loads", "int", "int", "int", "numpy.frombuffer().reshape", "numpy.frombuffer().reshape", "numpy.concatenate", "numpy.zeros", "copy.deepcopy", "numpy.array", "numpy.concatenate", "numpy.array", "numpy.concatenate", "txn.get", "numpy.sum", "numpy.load", "numpy.load", "numpy.sum", "float", "float", "float", "float", "txn.get", "numpy.sum", "float", "float", "float", "float", "numpy.frombuffer", "numpy.frombuffer", "print", "numpy.expand_dims", "numpy.expand_dims", "float", "float", "numpy.expand_dims", "numpy.expand_dims", "numpy.frombuffer", "numpy.frombuffer", "numpy.expand_dims", "float", "float", "numpy.expand_dims", "numpy.expand_dims", "base64.b64decode", "base64.b64decode", "base64.b64decode", "base64.b64decode", "str().encode.decode", "str().encode.decode"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.encode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode"], ["", "def", "__getitem__", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "image_id", "=", "str", "(", "image_id", ")", ".", "encode", "(", ")", "\n", "index", "=", "self", ".", "_image_ids", ".", "index", "(", "image_id", ")", "\n", "if", "self", ".", "_in_memory", ":", "\n", "# Load features during first epoch, all not loaded together as it", "\n", "# has a slow start.", "\n", "            ", "if", "self", ".", "features", "[", "index", "]", "is", "not", "None", ":", "\n", "                ", "features", "=", "self", ".", "features", "[", "index", "]", "\n", "num_boxes", "=", "self", ".", "num_boxes", "[", "index", "]", "\n", "image_location", "=", "self", ".", "boxes", "[", "index", "]", "\n", "image_location_ori", "=", "self", ".", "boxes_ori", "[", "index", "]", "\n", "", "else", ":", "\n", "                ", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "                    ", "item", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "image_id", ")", ")", "\n", "image_id_", "=", "item", "[", "'image_id'", "]", "\n", "image_h", "=", "int", "(", "item", "[", "'image_h'", "]", ")", "\n", "image_w", "=", "int", "(", "item", "[", "'image_w'", "]", ")", "\n", "num_boxes", "=", "int", "(", "item", "[", "'num_boxes'", "]", ")", "\n", "\n", "features", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "\"features\"", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "2048", ")", "\n", "# if 'gt' not in self.features_path:", "\n", "#     features_vc = np.load('/data3/wangtan/vc/vilbert_beta/data/VCR/vcr_coco_xy/' + str(index) + '.npy')", "\n", "# else:", "\n", "#     features_vc = np.load('/data3/wangtan/vc/vilbert_beta/data/VCR/vcr_coco_xy_gt/' + str(index) + '.npy')", "\n", "# assert features_vc.shape[0] == features.shape[0]", "\n", "\n", "boxes", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "'boxes'", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "4", ")", "\n", "\n", "g_feat", "=", "np", ".", "sum", "(", "features", ",", "axis", "=", "0", ")", "/", "num_boxes", "\n", "# g_feat_vc = np.sum(features_vc, axis=0) / num_boxes", "\n", "\n", "num_boxes", "=", "num_boxes", "+", "1", "\n", "\n", "features", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_feat", ",", "axis", "=", "0", ")", ",", "features", "]", ",", "axis", "=", "0", ")", "\n", "# features_vc = np.concatenate([np.expand_dims(g_feat_vc, axis=0), features_vc], axis=0)", "\n", "# features = np.concatenate([features, features_vc], axis=1)", "\n", "\n", "self", ".", "features", "[", "index", "]", "=", "features", "\n", "\n", "image_location", "=", "np", ".", "zeros", "(", "(", "boxes", ".", "shape", "[", "0", "]", ",", "5", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "image_location", "[", ":", ",", ":", "4", "]", "=", "boxes", "\n", "image_location", "[", ":", ",", "4", "]", "=", "(", "image_location", "[", ":", ",", "3", "]", "-", "image_location", "[", ":", ",", "1", "]", ")", "*", "(", "image_location", "[", ":", ",", "2", "]", "-", "image_location", "[", ":", ",", "0", "]", ")", "/", "(", "float", "(", "image_w", ")", "*", "float", "(", "image_h", ")", ")", "\n", "\n", "image_location_ori", "=", "copy", ".", "deepcopy", "(", "image_location", ")", "\n", "\n", "image_location", "[", ":", ",", "0", "]", "=", "image_location", "[", ":", ",", "0", "]", "/", "float", "(", "image_w", ")", "\n", "image_location", "[", ":", ",", "1", "]", "=", "image_location", "[", ":", ",", "1", "]", "/", "float", "(", "image_h", ")", "\n", "image_location", "[", ":", ",", "2", "]", "=", "image_location", "[", ":", ",", "2", "]", "/", "float", "(", "image_w", ")", "\n", "image_location", "[", ":", ",", "3", "]", "=", "image_location", "[", ":", ",", "3", "]", "/", "float", "(", "image_h", ")", "\n", "\n", "g_location", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "image_location", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_location", ",", "axis", "=", "0", ")", ",", "image_location", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "boxes", "[", "index", "]", "=", "image_location", "\n", "\n", "g_location_ori", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "image_w", ",", "image_h", ",", "image_w", "*", "image_h", "]", ")", "\n", "image_location_ori", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_location_ori", ",", "axis", "=", "0", ")", ",", "image_location_ori", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "boxes_ori", "[", "index", "]", "=", "image_location_ori", "\n", "self", ".", "num_boxes", "[", "index", "]", "=", "num_boxes", "\n", "", "", "", "else", ":", "\n", "# Read chunk from file everytime if not loaded in memory.    ", "\n", "            ", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "                ", "item", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "image_id", ")", ")", "\n", "image_id_", "=", "item", "[", "'image_id'", "]", "\n", "image_h", "=", "int", "(", "item", "[", "'image_h'", "]", ")", "\n", "image_w", "=", "int", "(", "item", "[", "'image_w'", "]", ")", "\n", "num_boxes", "=", "int", "(", "item", "[", "'num_boxes'", "]", ")", "\n", "\n", "features", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "\"features\"", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "2048", ")", "\n", "boxes", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "'boxes'", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "4", ")", "\n", "g_feat", "=", "np", ".", "sum", "(", "features", ",", "axis", "=", "0", ")", "/", "num_boxes", "\n", "\n", "# if 'gt' not in self.features_path:", "\n", "#     features_vc = np.load('/data3/wangtan/vc/vilbert_beta/data/VCR/vcr_coco_xy/' + image_id.decode() + '.npy')", "\n", "# else:", "\n", "#     features_vc = np.load(", "\n", "#         '/data3/wangtan/vc/vilbert_beta/data/VCR/vcr_coco_xy_gt2/' + image_id.decode() + '.npy')", "\n", "# try:", "\n", "#     assert features_vc.shape[0] == features.shape[0]", "\n", "# except:", "\n", "#     print('error')", "\n", "# g_feat_vc = np.sum(features_vc, axis=0) / num_boxes", "\n", "\n", "\n", "num_boxes", "=", "num_boxes", "+", "1", "\n", "features", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_feat", ",", "axis", "=", "0", ")", ",", "features", "]", ",", "axis", "=", "0", ")", "\n", "# features_vc = np.concatenate([np.expand_dims(g_feat_vc, axis=0), features_vc], axis=0)", "\n", "# features = np.concatenate([features, features_vc], axis=1)", "\n", "\n", "\n", "image_location", "=", "np", ".", "zeros", "(", "(", "boxes", ".", "shape", "[", "0", "]", ",", "5", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "image_location", "[", ":", ",", ":", "4", "]", "=", "boxes", "\n", "image_location", "[", ":", ",", "4", "]", "=", "(", "image_location", "[", ":", ",", "3", "]", "-", "image_location", "[", ":", ",", "1", "]", ")", "*", "(", "image_location", "[", ":", ",", "2", "]", "-", "image_location", "[", ":", ",", "0", "]", ")", "/", "(", "float", "(", "image_w", ")", "*", "float", "(", "image_h", ")", ")", "\n", "\n", "image_location_ori", "=", "copy", ".", "deepcopy", "(", "image_location", ")", "\n", "image_location", "[", ":", ",", "0", "]", "=", "image_location", "[", ":", ",", "0", "]", "/", "float", "(", "image_w", ")", "\n", "image_location", "[", ":", ",", "1", "]", "=", "image_location", "[", ":", ",", "1", "]", "/", "float", "(", "image_h", ")", "\n", "image_location", "[", ":", ",", "2", "]", "=", "image_location", "[", ":", ",", "2", "]", "/", "float", "(", "image_w", ")", "\n", "image_location", "[", ":", ",", "3", "]", "=", "image_location", "[", ":", ",", "3", "]", "/", "float", "(", "image_h", ")", "\n", "\n", "g_location", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "image_location", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_location", ",", "axis", "=", "0", ")", ",", "image_location", "]", ",", "axis", "=", "0", ")", "\n", "\n", "g_location_ori", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "image_w", ",", "image_h", ",", "image_w", "*", "image_h", "]", ")", "\n", "image_location_ori", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "g_location_ori", ",", "axis", "=", "0", ")", ",", "image_location_ori", "]", ",", "axis", "=", "0", ")", "\n", "\n", "", "", "return", "features", ",", "num_boxes", ",", "image_location", ",", "image_location_ori", "\n", "\n", "", "def", "keys", "(", "self", ")", "->", "List", "[", "int", "]", ":", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders._image_features_reader.ImageFeaturesH5Reader.keys": [[164, 166], ["None"], "methods", ["None"], ["        ", "return", "self", ".", "_image_ids", "\n", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR.__init__": [[100, 151], ["print", "allennlp.data.vocabulary.Vocabulary", "os.path.join", "print", "dataloaders._image_features_reader.ImageFeaturesH5Reader", "dataloaders._image_features_reader.ImageFeaturesH5Reader", "json.load", "json.load", "open", "ValueError", "ValueError", "allennlp.data.token_indexers.ELMoTokenCharactersIndexer", "open", "json.load", "open", "open", "os.path.join", "json.loads", "os.path.join", "enumerate", "os.path.dirname", "sorted", "json.load.items", "int"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load"], ["image_id_all", "=", "[", "int", "(", "image_id", ")", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "image_id_all", "=", "torch", ".", "tensor", "(", "image_id_all", ")", "\n", "target", ".", "add_field", "(", "\"image_id\"", ",", "image_id_all", ")", "\n", "\n", "numm", "=", "[", "num_boxes", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "numm", "=", "torch", ".", "tensor", "(", "numm", ")", "\n", "target", ".", "add_field", "(", "\"num_box\"", ",", "numm", ")", "\n", "\n", "target", "=", "target", ".", "clip_to_image", "(", "remove_empty", "=", "False", ")", "\n", "\n", "if", "self", ".", "transforms", "is", "not", "None", ":", "\n", "            ", "img", ",", "target", "=", "self", ".", "transforms", "(", "img", ",", "target", ")", "\n", "\n", "", "return", "img", ",", "target", ",", "idx", "\n", "\n", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_image_ids", ")", "\n", "\n", "\n", "", "def", "get_img_info", "(", "self", ",", "index", ")", ":", "\n", "\n", "        ", "return", "self", ".", "img_info", "[", "index", "]", "\n", "\n", "\n", "", "def", "get_img_ann", "(", "self", ",", "index", ")", ":", "\n", "# find the annotations for a given image", "\n", "        ", "image_ann", "=", "[", "]", "\n", "for", "ann", "in", "self", ".", "ann_file", ":", "\n", "            ", "if", "ann", "[", "'image_id'", "]", "==", "index", ":", "\n", "                ", "image_ann", ".", "append", "(", "ann", ")", "\n", "", "", "return", "image_ann", "\n", "\n", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR.is_train": [[152, 155], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR.splits": [[156, 166], ["cls", "cls", "cls", "kwargs.items"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR.eval_splits": [[167, 178], ["tuple", "ValueError", "cls", "cls", "range"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR.__len__": [[179, 181], ["len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR._get_dets_to_use": [[182, 221], ["numpy.arange", "old_det_to_new_ind.tolist.tolist.tolist", "numpy.zeros", "numpy.array", "numpy.ones", "numpy.where", "numpy.zeros", "len", "numpy.ones.any", "len", "len", "isinstance", "possibly_det_list.lower", "len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR.__getitem__": [[222, 358], ["copy.deepcopy", "vcr.VCR._get_dets_to_use", "zip", "allennlp.data.fields.ListField", "allennlp.data.fields.ListField", "allennlp.data.fields.MetadataField", "min", "min", "numpy.concatenate", "numpy.concatenate", "numpy.zeros", "numpy.zeros", "torch.tensor().float", "torch.tensor().long", "numpy.stack", "allennlp.data.fields.ArrayField", "allennlp.data.fields.ListField", "allennlp.data.fields.ArrayField", "allennlp.data.fields.ArrayField", "allennlp.data.instance.Instance", "allennlp.data.instance.Instance.index_fields", "h5py.File", "zip", "allennlp.data.fields.ListField", "allennlp.data.fields.ListField", "allennlp.data.fields.LabelField", "int", "int", "len", "torch.tensor().long.append", "open", "json.load", "numpy.array", "int", "torch.tensor", "torch.tensor", "os.path.join", "dataloaders.mask_utils.make_mask", "dets2use.tolist", "allennlp.data.fields.LabelField", "h5[].items", "vcr._fix_tokenization", "vcr._fix_tokenization", "enumerate", "range", "str"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCR._get_dets_to_use", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.mask_utils.make_mask", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr._fix_tokenization", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr._fix_tokenization"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.VCRLoader.from_dataset": [[400, 413], ["cls", "vcr.collate_fn"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.collate_fn"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr._fix_tokenization": [[67, 97], ["dataloaders.bert_field.BertField", "allennlp.data.fields.SequenceLabelField", "isinstance", "new_tokenization_with_tags.append", "allennlp.data.tokenizers.Token", "new_tokenization_with_tags.append", "ValueError", "len"], "function", ["None"], ["self", ".", "img_info", ".", "append", "(", "{", "\"width\"", ":", "w", ",", "\"height\"", ":", "h", ",", "\"path\"", ":", "path", "}", ")", "\n", "\n", "\n", "\n", "", "", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "\n", "        ", "image_id", "=", "self", ".", "_image_ids", "[", "idx", "]", "\n", "img_name", "=", "self", ".", "img_info", "[", "idx", "]", "[", "'path'", "]", "\n", "img_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "img_root", ",", "img_name", ")", "\n", "img", "=", "Image", ".", "open", "(", "img_path", ")", ".", "convert", "(", "\"RGB\"", ")", "\n", "\n", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "item", "=", "pickle", ".", "loads", "(", "txn", ".", "get", "(", "image_id", ")", ")", "\n", "image_id_", "=", "item", "[", "'image_id'", "]", "\n", "image_h", "=", "int", "(", "item", "[", "'image_h'", "]", ")", "\n", "image_w", "=", "int", "(", "item", "[", "'image_w'", "]", ")", "\n", "num_boxes", "=", "int", "(", "item", "[", "'num_boxes'", "]", ")", "\n", "boxes", "=", "np", ".", "frombuffer", "(", "base64", ".", "b64decode", "(", "item", "[", "'boxes'", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "num_boxes", ",", "4", ")", "\n", "\n", "\n", "", "boxes", "=", "torch", ".", "as_tensor", "(", "boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "# guard against no boxes", "\n", "target", "=", "BoxList", "(", "boxes", ",", "img", ".", "size", ",", "mode", "=", "\"xyxy\"", ")", "\n", "\n", "try", ":", "\n", "            ", "assert", "img", ".", "size", "[", "1", "]", "==", "image_h", "and", "img", ".", "size", "[", "0", "]", "==", "image_w", "\n", "", "except", "AssertionError", ":", "\n", "            ", "print", "(", "image_id", ")", "\n", "\n", "", "w", ",", "h", "=", "img", ".", "size", "[", "0", "]", ",", "img", ".", "size", "[", "1", "]", "\n", "sizes", "=", "[", "[", "w", ",", "h", "]", "for", "i", "in", "range", "(", "boxes", ".", "size", "(", "0", ")", ")", "]", "\n", "sizes", "=", "torch", ".", "tensor", "(", "sizes", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.dataloaders.vcr.collate_fn": [[360, 392], ["zip", "torch.stack", "allennlp.data.dataset.Batch", "allennlp.data.dataset.Batch.as_tensor_dict", "allennlp.nn.util.get_text_field_mask", "allennlp.nn.util.get_text_field_mask"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_metric_logger.TestMetricLogger.test_update": [[8, 18], ["vc_rcnn.utils.metric_logger.MetricLogger", "range", "test_metric_logger.TestMetricLogger.assertEqual", "test_metric_logger.TestMetricLogger.assertEqual", "test_metric_logger.TestMetricLogger.assertEqual", "test_metric_logger.TestMetricLogger.assertEqual", "vc_rcnn.utils.metric_logger.MetricLogger.update", "float"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.coco.coco_eval.COCOResults.update"], ["    ", "def", "test_update", "(", "self", ")", ":", "\n", "        ", "meter", "=", "MetricLogger", "(", ")", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "            ", "meter", ".", "update", "(", "metric", "=", "float", "(", "i", ")", ")", "\n", "\n", "", "m", "=", "meter", ".", "meters", "[", "\"metric\"", "]", "\n", "self", ".", "assertEqual", "(", "m", ".", "count", ",", "10", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "total", ",", "45", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "median", ",", "4", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "avg", ",", "4.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_metric_logger.TestMetricLogger.test_no_attr": [[19, 26], ["vc_rcnn.utils.metric_logger.MetricLogger", "test_metric_logger.TestMetricLogger.assertRaises"], "methods", ["None"], ["", "def", "test_no_attr", "(", "self", ")", ":", "\n", "        ", "meter", "=", "MetricLogger", "(", ")", "\n", "_", "=", "meter", ".", "meters", "\n", "_", "=", "meter", ".", "delimiter", "\n", "def", "broken", "(", ")", ":", "\n", "            ", "_", "=", "meter", ".", "not_existent", "\n", "", "self", ".", "assertRaises", "(", "AttributeError", ",", "broken", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_predictors.TestPredictors.test_roi_box_predictors": [[53, 69], ["test_predictors._test_predictors", "test_predictors.TestPredictors.assertEqual", "test_predictors.TestPredictors.assertEqual", "test_predictors.TestPredictors.assertEqual", "test_predictors.TestPredictors.assertEqual", "test_predictors.TestPredictors.assertEqual", "len"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_predictors._test_predictors"], ["    ", "def", "test_roi_box_predictors", "(", "self", ")", ":", "\n", "        ", "''' Make sure roi box predictors run '''", "\n", "for", "cur_in", ",", "cur_out", ",", "cur_cfg", "in", "_test_predictors", "(", "\n", "self", ",", "\n", "registry", ".", "ROI_BOX_PREDICTOR", ",", "\n", "PREDICTOR_CFGS", ",", "\n", "PREDICTOR_INPUT_CHANNELS", ",", "\n", "hwsize", "=", "1", ",", "\n", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "len", "(", "cur_out", ")", ",", "2", ")", "\n", "scores", ",", "bbox_deltas", "=", "cur_out", "[", "0", "]", ",", "cur_out", "[", "1", "]", "\n", "self", ".", "assertEqual", "(", "\n", "scores", ".", "shape", "[", "1", "]", ",", "cur_cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CLASSES", ")", "\n", "self", ".", "assertEqual", "(", "scores", ".", "shape", "[", "0", "]", ",", "cur_in", ".", "shape", "[", "0", "]", ")", "\n", "self", ".", "assertEqual", "(", "scores", ".", "shape", "[", "0", "]", ",", "bbox_deltas", ".", "shape", "[", "0", "]", ")", "\n", "self", ".", "assertEqual", "(", "scores", ".", "shape", "[", "1", "]", "*", "4", ",", "bbox_deltas", ".", "shape", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_predictors.TestPredictors.test_roi_keypoints_predictors": [[70, 82], ["test_predictors._test_predictors", "test_predictors.TestPredictors.assertEqual", "test_predictors.TestPredictors.assertEqual"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_predictors._test_predictors"], ["", "", "def", "test_roi_keypoints_predictors", "(", "self", ")", ":", "\n", "        ", "''' Make sure roi keypoint predictors run '''", "\n", "for", "cur_in", ",", "cur_out", ",", "cur_cfg", "in", "_test_predictors", "(", "\n", "self", ",", "\n", "registry", ".", "ROI_KEYPOINT_PREDICTOR", ",", "\n", "PREDICTOR_CFGS", ",", "\n", "PREDICTOR_INPUT_CHANNELS", ",", "\n", "hwsize", "=", "14", ",", "\n", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "cur_out", ".", "shape", "[", "0", "]", ",", "cur_in", ".", "shape", "[", "0", "]", ")", "\n", "self", ".", "assertEqual", "(", "\n", "cur_out", ".", "shape", "[", "1", "]", ",", "cur_cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NUM_CLASSES", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_predictors.TestPredictors.test_roi_mask_predictors": [[83, 95], ["test_predictors._test_predictors", "test_predictors.TestPredictors.assertEqual", "test_predictors.TestPredictors.assertEqual"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_predictors._test_predictors"], ["", "", "def", "test_roi_mask_predictors", "(", "self", ")", ":", "\n", "        ", "''' Make sure roi mask predictors run '''", "\n", "for", "cur_in", ",", "cur_out", ",", "cur_cfg", "in", "_test_predictors", "(", "\n", "self", ",", "\n", "registry", ".", "ROI_MASK_PREDICTOR", ",", "\n", "PREDICTOR_CFGS", ",", "\n", "PREDICTOR_INPUT_CHANNELS", ",", "\n", "hwsize", "=", "14", ",", "\n", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "cur_out", ".", "shape", "[", "0", "]", ",", "cur_in", ".", "shape", "[", "0", "]", ")", "\n", "self", ".", "assertEqual", "(", "\n", "cur_out", ".", "shape", "[", "1", "]", ",", "cur_cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CLASSES", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_predictors._test_predictors": [[23, 50], ["test_predictors..assertGreater", "predictors.items", "len", "print", "overwrite_in_channels.get", "builder", "torch.rand", "builder.", "utils.load_config", "copy.deepcopy", "vc_rcnn.modeling.registry.ROI_BOX_PREDICTOR", "vc_rcnn.modeling.registry.ROI_KEYPOINT_PREDICTOR", "vc_rcnn.modeling.registry.ROI_MASK_PREDICTOR"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config"], ["def", "_test_predictors", "(", "\n", "self", ",", "predictors", ",", "overwrite_cfgs", ",", "overwrite_in_channels", ",", "\n", "hwsize", ",", "\n", ")", ":", "\n", "    ", "''' Make sure predictors run '''", "\n", "\n", "self", ".", "assertGreater", "(", "len", "(", "predictors", ")", ",", "0", ")", "\n", "\n", "in_channels_default", "=", "64", "\n", "\n", "for", "name", ",", "builder", "in", "predictors", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "'Testing {}...'", ".", "format", "(", "name", ")", ")", "\n", "if", "name", "in", "overwrite_cfgs", ":", "\n", "            ", "cfg", "=", "load_config", "(", "overwrite_cfgs", "[", "name", "]", ")", "\n", "", "else", ":", "\n", "# Use default config if config file is not specified", "\n", "            ", "cfg", "=", "copy", ".", "deepcopy", "(", "g_cfg", ")", "\n", "\n", "", "in_channels", "=", "overwrite_in_channels", ".", "get", "(", "\n", "name", ",", "in_channels_default", ")", "\n", "\n", "fe", "=", "builder", "(", "cfg", ",", "in_channels", ")", "\n", "\n", "N", ",", "C_in", ",", "H", ",", "W", "=", "2", ",", "in_channels", ",", "hwsize", ",", "hwsize", "\n", "input", "=", "torch", ".", "rand", "(", "[", "N", ",", "C_in", ",", "H", ",", "W", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "out", "=", "fe", "(", "input", ")", "\n", "yield", "input", ",", "out", ",", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_configs.TestConfigs.test_configs_load": [[10, 21], ["utils.get_config_root_path", "glob.glob", "test_configs.TestConfigs.assertGreater", "os.path.join", "len", "print", "utils.load_config_from_file"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.env_tests.env.get_config_root_path", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config_from_file"], ["    ", "def", "test_configs_load", "(", "self", ")", ":", "\n", "        ", "''' Make sure configs are loadable '''", "\n", "\n", "cfg_root_path", "=", "utils", ".", "get_config_root_path", "(", ")", "\n", "files", "=", "glob", ".", "glob", "(", "\n", "os", ".", "path", ".", "join", "(", "cfg_root_path", ",", "\"./**/*.yaml\"", ")", ",", "recursive", "=", "True", ")", "\n", "self", ".", "assertGreater", "(", "len", "(", "files", ")", ",", "0", ")", "\n", "\n", "for", "fn", "in", "files", ":", "\n", "            ", "print", "(", "'Loading {}...'", ".", "format", "(", "fn", ")", ")", "\n", "utils", ".", "load_config_from_file", "(", "fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__init__": [[16, 18], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "indices", ")", ":", "\n", "        ", "self", ".", "indices", "=", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__iter__": [[19, 21], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.SubsetSampler.__len__": [[22, 24], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.TestGroupedBatchSampler.test_respect_order_simple": [[27, 39], ["torch.utils.data.sampler.SequentialSampler", "vc_rcnn.data.samplers.GroupedBatchSampler", "list", "list", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "range", "itertools.chain.from_iterable"], "methods", ["None"], ["    ", "def", "test_respect_order_simple", "(", "self", ")", ":", "\n", "        ", "drop_uneven", "=", "False", "\n", "dataset", "=", "[", "i", "for", "i", "in", "range", "(", "40", ")", "]", "\n", "group_ids", "=", "[", "i", "//", "10", "for", "i", "in", "dataset", "]", "\n", "sampler", "=", "SequentialSampler", "(", "dataset", ")", "\n", "for", "batch_size", "in", "[", "1", ",", "3", ",", "5", ",", "6", "]", ":", "\n", "            ", "batch_sampler", "=", "GroupedBatchSampler", "(", "\n", "sampler", ",", "group_ids", ",", "batch_size", ",", "drop_uneven", "\n", ")", "\n", "result", "=", "list", "(", "batch_sampler", ")", "\n", "merged_result", "=", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "result", ")", ")", "\n", "self", ".", "assertEqual", "(", "merged_result", ",", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.TestGroupedBatchSampler.test_respect_order": [[40, 58], ["torch.utils.data.sampler.SequentialSampler", "enumerate", "vc_rcnn.data.samplers.GroupedBatchSampler", "list", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "range"], "methods", ["None"], ["", "", "def", "test_respect_order", "(", "self", ")", ":", "\n", "        ", "drop_uneven", "=", "False", "\n", "dataset", "=", "[", "i", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "group_ids", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", "]", "\n", "sampler", "=", "SequentialSampler", "(", "dataset", ")", "\n", "\n", "expected", "=", "[", "\n", "[", "[", "0", "]", ",", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", ",", "[", "4", "]", ",", "[", "5", "]", ",", "[", "6", "]", ",", "[", "7", "]", ",", "[", "8", "]", ",", "[", "9", "]", "]", ",", "\n", "[", "[", "0", ",", "1", ",", "3", "]", ",", "[", "2", ",", "4", ",", "5", "]", ",", "[", "6", ",", "9", "]", ",", "[", "7", ",", "8", "]", "]", ",", "\n", "[", "[", "0", ",", "1", ",", "3", ",", "6", "]", ",", "[", "2", ",", "4", ",", "5", ",", "7", "]", ",", "[", "8", "]", ",", "[", "9", "]", "]", ",", "\n", "]", "\n", "\n", "for", "idx", ",", "batch_size", "in", "enumerate", "(", "[", "1", ",", "3", ",", "4", "]", ")", ":", "\n", "            ", "batch_sampler", "=", "GroupedBatchSampler", "(", "\n", "sampler", ",", "group_ids", ",", "batch_size", ",", "drop_uneven", "\n", ")", "\n", "result", "=", "list", "(", "batch_sampler", ")", "\n", "self", ".", "assertEqual", "(", "result", ",", "expected", "[", "idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.TestGroupedBatchSampler.test_respect_order_drop_uneven": [[59, 71], ["torch.utils.data.sampler.SequentialSampler", "vc_rcnn.data.samplers.GroupedBatchSampler", "list", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "range"], "methods", ["None"], ["", "", "def", "test_respect_order_drop_uneven", "(", "self", ")", ":", "\n", "        ", "batch_size", "=", "3", "\n", "drop_uneven", "=", "True", "\n", "dataset", "=", "[", "i", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "group_ids", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", "]", "\n", "sampler", "=", "SequentialSampler", "(", "dataset", ")", "\n", "batch_sampler", "=", "GroupedBatchSampler", "(", "sampler", ",", "group_ids", ",", "batch_size", ",", "drop_uneven", ")", "\n", "\n", "result", "=", "list", "(", "batch_sampler", ")", "\n", "\n", "expected", "=", "[", "[", "0", ",", "1", ",", "3", "]", ",", "[", "2", ",", "4", ",", "5", "]", "]", "\n", "self", ".", "assertEqual", "(", "result", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.TestGroupedBatchSampler.test_subset_sampler": [[72, 84], ["test_data_samplers.SubsetSampler", "vc_rcnn.data.samplers.GroupedBatchSampler", "list", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "range"], "methods", ["None"], ["", "def", "test_subset_sampler", "(", "self", ")", ":", "\n", "        ", "batch_size", "=", "3", "\n", "drop_uneven", "=", "False", "\n", "dataset", "=", "[", "i", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "group_ids", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", "]", "\n", "sampler", "=", "SubsetSampler", "(", "[", "0", ",", "3", ",", "5", ",", "6", ",", "7", ",", "8", "]", ")", "\n", "\n", "batch_sampler", "=", "GroupedBatchSampler", "(", "sampler", ",", "group_ids", ",", "batch_size", ",", "drop_uneven", ")", "\n", "result", "=", "list", "(", "batch_sampler", ")", "\n", "\n", "expected", "=", "[", "[", "0", ",", "3", ",", "6", "]", ",", "[", "5", ",", "7", ",", "8", "]", "]", "\n", "self", ".", "assertEqual", "(", "result", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.TestGroupedBatchSampler.test_permute_subset_sampler": [[85, 97], ["test_data_samplers.SubsetSampler", "vc_rcnn.data.samplers.GroupedBatchSampler", "list", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "range"], "methods", ["None"], ["", "def", "test_permute_subset_sampler", "(", "self", ")", ":", "\n", "        ", "batch_size", "=", "3", "\n", "drop_uneven", "=", "False", "\n", "dataset", "=", "[", "i", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "group_ids", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", "]", "\n", "sampler", "=", "SubsetSampler", "(", "[", "5", ",", "0", ",", "6", ",", "1", ",", "3", ",", "8", "]", ")", "\n", "\n", "batch_sampler", "=", "GroupedBatchSampler", "(", "sampler", ",", "group_ids", ",", "batch_size", ",", "drop_uneven", ")", "\n", "result", "=", "list", "(", "batch_sampler", ")", "\n", "\n", "expected", "=", "[", "[", "5", ",", "8", "]", ",", "[", "0", ",", "6", ",", "1", "]", ",", "[", "3", "]", "]", "\n", "self", ".", "assertEqual", "(", "result", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.TestGroupedBatchSampler.test_permute_subset_sampler_drop_uneven": [[98, 110], ["test_data_samplers.SubsetSampler", "vc_rcnn.data.samplers.GroupedBatchSampler", "list", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "range"], "methods", ["None"], ["", "def", "test_permute_subset_sampler_drop_uneven", "(", "self", ")", ":", "\n", "        ", "batch_size", "=", "3", "\n", "drop_uneven", "=", "True", "\n", "dataset", "=", "[", "i", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "group_ids", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", "]", "\n", "sampler", "=", "SubsetSampler", "(", "[", "5", ",", "0", ",", "6", ",", "1", ",", "3", ",", "8", "]", ")", "\n", "\n", "batch_sampler", "=", "GroupedBatchSampler", "(", "sampler", ",", "group_ids", ",", "batch_size", ",", "drop_uneven", ")", "\n", "result", "=", "list", "(", "batch_sampler", ")", "\n", "\n", "expected", "=", "[", "[", "0", ",", "6", ",", "1", "]", "]", "\n", "self", ".", "assertEqual", "(", "result", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.TestGroupedBatchSampler.test_len": [[111, 128], ["torch.utils.data.sampler.RandomSampler", "vc_rcnn.data.samplers.GroupedBatchSampler", "list", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "vc_rcnn.data.samplers.GroupedBatchSampler", "len", "list", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "test_data_samplers.TestGroupedBatchSampler.assertEqual", "random.randint", "len", "len", "len", "len", "len", "len", "len", "range"], "methods", ["None"], ["", "def", "test_len", "(", "self", ")", ":", "\n", "        ", "batch_size", "=", "3", "\n", "drop_uneven", "=", "True", "\n", "dataset", "=", "[", "i", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "group_ids", "=", "[", "random", ".", "randint", "(", "0", ",", "1", ")", "for", "_", "in", "dataset", "]", "\n", "sampler", "=", "RandomSampler", "(", "dataset", ")", "\n", "\n", "batch_sampler", "=", "GroupedBatchSampler", "(", "sampler", ",", "group_ids", ",", "batch_size", ",", "drop_uneven", ")", "\n", "result", "=", "list", "(", "batch_sampler", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "result", ")", ",", "len", "(", "batch_sampler", ")", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "result", ")", ",", "len", "(", "batch_sampler", ")", ")", "\n", "\n", "batch_sampler", "=", "GroupedBatchSampler", "(", "sampler", ",", "group_ids", ",", "batch_size", ",", "drop_uneven", ")", "\n", "batch_sampler_len", "=", "len", "(", "batch_sampler", ")", "\n", "result", "=", "list", "(", "batch_sampler", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "result", ")", ",", "batch_sampler_len", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "result", ")", ",", "len", "(", "batch_sampler", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_data_samplers.TestIterationBasedBatchSampler.test_number_of_iters_and_elements": [[131, 150], ["torch.utils.data.sampler.SequentialSampler", "torch.utils.data.sampler.BatchSampler", "vc_rcnn.data.samplers.IterationBasedBatchSampler", "enumerate", "len", "min", "test_data_samplers.TestIterationBasedBatchSampler.assertEqual", "range", "len", "len", "range"], "methods", ["None"], ["    ", "def", "test_number_of_iters_and_elements", "(", "self", ")", ":", "\n", "        ", "for", "batch_size", "in", "[", "2", ",", "3", ",", "4", "]", ":", "\n", "            ", "for", "num_iterations", "in", "[", "4", ",", "10", ",", "20", "]", ":", "\n", "                ", "for", "drop_last", "in", "[", "False", ",", "True", "]", ":", "\n", "                    ", "dataset", "=", "[", "i", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "sampler", "=", "SequentialSampler", "(", "dataset", ")", "\n", "batch_sampler", "=", "BatchSampler", "(", "\n", "sampler", ",", "batch_size", ",", "drop_last", "=", "drop_last", "\n", ")", "\n", "\n", "iter_sampler", "=", "IterationBasedBatchSampler", "(", "\n", "batch_sampler", ",", "num_iterations", "\n", ")", "\n", "assert", "len", "(", "iter_sampler", ")", "==", "num_iterations", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "iter_sampler", ")", ":", "\n", "                        ", "start", "=", "(", "i", "%", "len", "(", "batch_sampler", ")", ")", "*", "batch_size", "\n", "end", "=", "min", "(", "start", "+", "batch_size", ",", "len", "(", "dataset", ")", ")", "\n", "expected", "=", "[", "x", "for", "x", "in", "range", "(", "start", ",", "end", ")", "]", "\n", "self", ".", "assertEqual", "(", "batch", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__": [[8, 22], ["unittest.TestCase.__init__", "vc_rcnn.structures.segmentation_mask.SegmentationMask", "vc_rcnn.structures.segmentation_mask.SegmentationMask().convert", "vc_rcnn.structures.segmentation_mask.SegmentationMask"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.__init__", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert"], ["    ", "def", "__init__", "(", "self", ",", "method_name", "=", "'runTest'", ")", ":", "\n", "        ", "super", "(", "TestSegmentationMask", ",", "self", ")", ".", "__init__", "(", "method_name", ")", "\n", "poly", "=", "[", "[", "[", "423.0", ",", "306.5", ",", "406.5", ",", "277.0", ",", "400.0", ",", "271.5", ",", "389.5", ",", "277.0", ",", "\n", "387.5", ",", "292.0", ",", "384.5", ",", "295.0", ",", "374.5", ",", "220.0", ",", "378.5", ",", "210.0", ",", "\n", "391.0", ",", "200.5", ",", "404.0", ",", "199.5", ",", "414.0", ",", "203.5", ",", "425.5", ",", "221.0", ",", "\n", "438.5", ",", "297.0", ",", "423.0", ",", "306.5", "]", ",", "\n", "[", "100", ",", "100", ",", "200", ",", "100", ",", "200", ",", "200", ",", "100", ",", "200", "]", ",", "\n", "]", "]", "\n", "width", "=", "640", "\n", "height", "=", "480", "\n", "size", "=", "width", ",", "height", "\n", "\n", "self", ".", "P", "=", "SegmentationMask", "(", "poly", ",", "size", ",", "'poly'", ")", "\n", "self", ".", "M", "=", "SegmentationMask", "(", "poly", ",", "size", ",", "'poly'", ")", ".", "convert", "(", "'mask'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.L1": [[23, 27], ["torch.sum().item", "A.get_mask_tensor", "B.get_mask_tensor", "torch.sum", "torch.abs", "torch.sum().item.float"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.get_mask_tensor", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.segmentation_mask.SegmentationMask.get_mask_tensor"], ["", "def", "L1", "(", "self", ",", "A", ",", "B", ")", ":", "\n", "        ", "diff", "=", "A", ".", "get_mask_tensor", "(", ")", "-", "B", ".", "get_mask_tensor", "(", ")", "\n", "diff", "=", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "diff", ".", "float", "(", ")", ")", ")", ".", "item", "(", ")", "\n", "return", "diff", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.test_convert": [[28, 37], ["test_segmentation_mask.TestSegmentationMask.M.convert().convert", "test_segmentation_mask.TestSegmentationMask.P.convert().convert", "test_segmentation_mask.TestSegmentationMask.L1", "test_segmentation_mask.TestSegmentationMask.L1", "test_segmentation_mask.TestSegmentationMask.assertTrue", "test_segmentation_mask.TestSegmentationMask.assertTrue", "test_segmentation_mask.TestSegmentationMask.assertTrue", "test_segmentation_mask.TestSegmentationMask.M.convert", "test_segmentation_mask.TestSegmentationMask.P.convert"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.L1", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.L1", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.bounding_box.BoxList.convert"], ["", "def", "test_convert", "(", "self", ")", ":", "\n", "        ", "M_hat", "=", "self", ".", "M", ".", "convert", "(", "'poly'", ")", ".", "convert", "(", "'mask'", ")", "\n", "P_hat", "=", "self", ".", "P", ".", "convert", "(", "'mask'", ")", ".", "convert", "(", "'poly'", ")", "\n", "\n", "diff_mask", "=", "self", ".", "L1", "(", "self", ".", "M", ",", "M_hat", ")", "\n", "diff_poly", "=", "self", ".", "L1", "(", "self", ".", "P", ",", "P_hat", ")", "\n", "self", ".", "assertTrue", "(", "diff_mask", "==", "diff_poly", ")", "\n", "self", ".", "assertTrue", "(", "diff_mask", "<=", "8169.", ")", "\n", "self", ".", "assertTrue", "(", "diff_poly", "<=", "8169.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.test_crop": [[38, 42], ["test_segmentation_mask.TestSegmentationMask.L1", "test_segmentation_mask.TestSegmentationMask.assertTrue", "test_segmentation_mask.TestSegmentationMask.M.crop", "test_segmentation_mask.TestSegmentationMask.P.crop"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.L1", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.crop", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.crop"], ["", "def", "test_crop", "(", "self", ")", ":", "\n", "        ", "box", "=", "[", "400", ",", "250", ",", "500", ",", "300", "]", "# xyxy", "\n", "diff", "=", "self", ".", "L1", "(", "self", ".", "M", ".", "crop", "(", "box", ")", ",", "self", ".", "P", ".", "crop", "(", "box", ")", ")", "\n", "self", ".", "assertTrue", "(", "diff", "<=", "1.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.test_resize": [[43, 53], ["test_segmentation_mask.TestSegmentationMask.M.resize", "test_segmentation_mask.TestSegmentationMask.P.resize", "test_segmentation_mask.TestSegmentationMask.L1", "test_segmentation_mask.TestSegmentationMask.assertTrue", "test_segmentation_mask.TestSegmentationMask.assertTrue", "test_segmentation_mask.TestSegmentationMask.assertTrue", "test_segmentation_mask.TestSegmentationMask.assertTrue"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.resize", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.L1"], ["", "def", "test_resize", "(", "self", ")", ":", "\n", "        ", "new_size", "=", "50", ",", "25", "\n", "M_hat", "=", "self", ".", "M", ".", "resize", "(", "new_size", ")", "\n", "P_hat", "=", "self", ".", "P", ".", "resize", "(", "new_size", ")", "\n", "diff", "=", "self", ".", "L1", "(", "M_hat", ",", "P_hat", ")", "\n", "\n", "self", ".", "assertTrue", "(", "self", ".", "M", ".", "size", "==", "self", ".", "P", ".", "size", ")", "\n", "self", ".", "assertTrue", "(", "M_hat", ".", "size", "==", "P_hat", ".", "size", ")", "\n", "self", ".", "assertTrue", "(", "self", ".", "M", ".", "size", "!=", "M_hat", ".", "size", ")", "\n", "self", ".", "assertTrue", "(", "diff", "<=", "255.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.test_transpose": [[54, 65], ["test_segmentation_mask.TestSegmentationMask.L1", "test_segmentation_mask.TestSegmentationMask.L1", "test_segmentation_mask.TestSegmentationMask.assertTrue", "test_segmentation_mask.TestSegmentationMask.assertTrue", "test_segmentation_mask.TestSegmentationMask.M.transpose", "test_segmentation_mask.TestSegmentationMask.P.transpose", "test_segmentation_mask.TestSegmentationMask.M.transpose", "test_segmentation_mask.TestSegmentationMask.P.transpose"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.L1", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_segmentation_mask.TestSegmentationMask.L1", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.transpose"], ["", "def", "test_transpose", "(", "self", ")", ":", "\n", "        ", "FLIP_LEFT_RIGHT", "=", "0", "\n", "FLIP_TOP_BOTTOM", "=", "1", "\n", "diff_hor", "=", "self", ".", "L1", "(", "self", ".", "M", ".", "transpose", "(", "FLIP_LEFT_RIGHT", ")", ",", "\n", "self", ".", "P", ".", "transpose", "(", "FLIP_LEFT_RIGHT", ")", ")", "\n", "\n", "diff_ver", "=", "self", ".", "L1", "(", "self", ".", "M", ".", "transpose", "(", "FLIP_TOP_BOTTOM", ")", ",", "\n", "self", ".", "P", ".", "transpose", "(", "FLIP_TOP_BOTTOM", ")", ")", "\n", "\n", "self", ".", "assertTrue", "(", "diff_hor", "<=", "53250.", ")", "\n", "self", ".", "assertTrue", "(", "diff_ver", "<=", "42494.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_feature_extractors.TestFeatureExtractors.test_roi_box_feature_extractors": [[64, 71], ["test_feature_extractors._test_feature_extractors"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_feature_extractors._test_feature_extractors"], ["    ", "def", "test_roi_box_feature_extractors", "(", "self", ")", ":", "\n", "        ", "''' Make sure roi box feature extractors run '''", "\n", "_test_feature_extractors", "(", "\n", "self", ",", "\n", "registry", ".", "ROI_BOX_FEATURE_EXTRACTORS", ",", "\n", "FEATURE_EXTRACTORS_CFGS", ",", "\n", "FEATURE_EXTRACTORS_INPUT_CHANNELS", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_feature_extractors.TestFeatureExtractors.test_roi_keypoints_feature_extractors": [[73, 80], ["test_feature_extractors._test_feature_extractors"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_feature_extractors._test_feature_extractors"], ["", "def", "test_roi_keypoints_feature_extractors", "(", "self", ")", ":", "\n", "        ", "''' Make sure roi keypoints feature extractors run '''", "\n", "_test_feature_extractors", "(", "\n", "self", ",", "\n", "registry", ".", "ROI_KEYPOINT_FEATURE_EXTRACTORS", ",", "\n", "FEATURE_EXTRACTORS_CFGS", ",", "\n", "FEATURE_EXTRACTORS_INPUT_CHANNELS", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_feature_extractors.TestFeatureExtractors.test_roi_mask_feature_extractors": [[82, 89], ["test_feature_extractors._test_feature_extractors"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_feature_extractors._test_feature_extractors"], ["", "def", "test_roi_mask_feature_extractors", "(", "self", ")", ":", "\n", "        ", "''' Make sure roi mask feature extractors run '''", "\n", "_test_feature_extractors", "(", "\n", "self", ",", "\n", "registry", ".", "ROI_MASK_FEATURE_EXTRACTORS", ",", "\n", "FEATURE_EXTRACTORS_CFGS", ",", "\n", "FEATURE_EXTRACTORS_INPUT_CHANNELS", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_feature_extractors._test_feature_extractors": [[25, 60], ["test_feature_extractors..assertGreater", "extractors.items", "len", "print", "overwrite_in_channels.get", "builder", "test_feature_extractors..assertIsNotNone", "torch.rand", "vc_rcnn.structures.bounding_box.BoxList", "builder.", "test_feature_extractors..assertEqual", "utils.load_config", "copy.deepcopy", "getattr", "torch.Size", "len", "vc_rcnn.modeling.registry.ROI_BOX_FEATURE_EXTRACTORS", "vc_rcnn.modeling.registry.ROI_KEYPOINT_FEATURE_EXTRACTORS", "vc_rcnn.modeling.registry.ROI_MASK_FEATURE_EXTRACTORS"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.AoANet_VC.dataloader.BlobFetcher.get", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config"], ["def", "_test_feature_extractors", "(", "\n", "self", ",", "extractors", ",", "overwrite_cfgs", ",", "overwrite_in_channels", "\n", ")", ":", "\n", "    ", "''' Make sure roi box feature extractors run '''", "\n", "\n", "self", ".", "assertGreater", "(", "len", "(", "extractors", ")", ",", "0", ")", "\n", "\n", "in_channels_default", "=", "64", "\n", "\n", "for", "name", ",", "builder", "in", "extractors", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "'Testing {}...'", ".", "format", "(", "name", ")", ")", "\n", "if", "name", "in", "overwrite_cfgs", ":", "\n", "            ", "cfg", "=", "load_config", "(", "overwrite_cfgs", "[", "name", "]", ")", "\n", "", "else", ":", "\n", "# Use default config if config file is not specified", "\n", "            ", "cfg", "=", "copy", ".", "deepcopy", "(", "g_cfg", ")", "\n", "\n", "", "in_channels", "=", "overwrite_in_channels", ".", "get", "(", "\n", "name", ",", "in_channels_default", ")", "\n", "\n", "fe", "=", "builder", "(", "cfg", ",", "in_channels", ")", "\n", "self", ".", "assertIsNotNone", "(", "\n", "getattr", "(", "fe", ",", "'out_channels'", ",", "None", ")", ",", "\n", "'Need to provide out_channels for feature extractor {}'", ".", "format", "(", "name", ")", "\n", ")", "\n", "\n", "N", ",", "C_in", ",", "H", ",", "W", "=", "2", ",", "in_channels", ",", "24", ",", "32", "\n", "input", "=", "torch", ".", "rand", "(", "[", "N", ",", "C_in", ",", "H", ",", "W", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "bboxes", "=", "[", "[", "1", ",", "1", ",", "10", ",", "10", "]", ",", "[", "5", ",", "5", ",", "8", ",", "8", "]", ",", "[", "2", ",", "2", ",", "3", ",", "4", "]", "]", "\n", "img_size", "=", "[", "384", ",", "512", "]", "\n", "box_list", "=", "BoxList", "(", "bboxes", ",", "img_size", ",", "\"xyxy\"", ")", "\n", "out", "=", "fe", "(", "[", "input", "]", ",", "[", "box_list", "]", "*", "N", ")", "\n", "self", ".", "assertEqual", "(", "\n", "out", ".", "shape", "[", ":", "2", "]", ",", "\n", "torch", ".", "Size", "(", "[", "N", "*", "len", "(", "bboxes", ")", ",", "fe", ".", "out_channels", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet.TestFBNetBuilder.test_identity": [[24, 34], ["vc_rcnn.Identity", "torch.rand", "vc_rcnn.Identity.", "numpy.testing.assert_array_equal", "vc_rcnn.Identity", "torch.rand", "vc_rcnn.Identity.", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array"], "methods", ["None"], ["    ", "def", "test_identity", "(", "self", ")", ":", "\n", "        ", "id_op", "=", "fbnet_builder", ".", "Identity", "(", "20", ",", "20", ",", "1", ")", "\n", "input", "=", "torch", ".", "rand", "(", "[", "10", ",", "20", ",", "7", ",", "7", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "output", "=", "id_op", "(", "input", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "np", ".", "array", "(", "input", ")", ",", "np", ".", "array", "(", "output", ")", ")", "\n", "\n", "id_op", "=", "fbnet_builder", ".", "Identity", "(", "20", ",", "40", ",", "2", ")", "\n", "input", "=", "torch", ".", "rand", "(", "[", "10", ",", "20", ",", "7", ",", "7", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "output", "=", "id_op", "(", "input", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "output", ".", "shape", ",", "[", "10", ",", "40", ",", "4", ",", "4", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet.TestFBNetBuilder.test_primitives": [[35, 44], ["vc_rcnn.PRIMITIVES.items", "print", "test_fbnet._test_primitive"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet._test_primitive"], ["", "def", "test_primitives", "(", "self", ")", ":", "\n", "        ", "''' Make sures the primitives runs '''", "\n", "for", "op_name", ",", "op_func", "in", "fbnet_builder", ".", "PRIMITIVES", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'Testing {}'", ".", "format", "(", "op_name", ")", ")", "\n", "\n", "_test_primitive", "(", "\n", "self", ",", "\"cpu\"", ",", "\n", "op_name", ",", "op_func", ",", "\n", "N", "=", "20", ",", "C_in", "=", "16", ",", "C_out", "=", "32", ",", "expand", "=", "4", ",", "stride", "=", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet.TestFBNetBuilder.test_primitives_cuda": [[46, 56], ["unittest.skipIf", "vc_rcnn.PRIMITIVES.items", "print", "test_fbnet._test_primitive"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet._test_primitive"], ["", "", "@", "unittest", ".", "skipIf", "(", "not", "TEST_CUDA", ",", "\"no CUDA detected\"", ")", "\n", "def", "test_primitives_cuda", "(", "self", ")", ":", "\n", "        ", "''' Make sures the primitives runs on cuda '''", "\n", "for", "op_name", ",", "op_func", "in", "fbnet_builder", ".", "PRIMITIVES", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'Testing {}'", ".", "format", "(", "op_name", ")", ")", "\n", "\n", "_test_primitive", "(", "\n", "self", ",", "\"cuda\"", ",", "\n", "op_name", ",", "op_func", ",", "\n", "N", "=", "20", ",", "C_in", "=", "16", ",", "C_out", "=", "32", ",", "expand", "=", "4", ",", "stride", "=", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet.TestFBNetBuilder.test_primitives_empty_batch": [[58, 68], ["vc_rcnn.PRIMITIVES.items", "print", "test_fbnet._test_primitive"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet._test_primitive"], ["", "", "def", "test_primitives_empty_batch", "(", "self", ")", ":", "\n", "        ", "''' Make sures the primitives runs '''", "\n", "for", "op_name", ",", "op_func", "in", "fbnet_builder", ".", "PRIMITIVES", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'Testing {}'", ".", "format", "(", "op_name", ")", ")", "\n", "\n", "# test empty batch size", "\n", "_test_primitive", "(", "\n", "self", ",", "\"cpu\"", ",", "\n", "op_name", ",", "op_func", ",", "\n", "N", "=", "0", ",", "C_in", "=", "16", ",", "C_out", "=", "32", ",", "expand", "=", "4", ",", "stride", "=", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet.TestFBNetBuilder.test_primitives_cuda_empty_batch": [[70, 81], ["unittest.skipIf", "vc_rcnn.PRIMITIVES.items", "print", "test_fbnet._test_primitive"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet._test_primitive"], ["", "", "@", "unittest", ".", "skipIf", "(", "not", "TEST_CUDA", ",", "\"no CUDA detected\"", ")", "\n", "def", "test_primitives_cuda_empty_batch", "(", "self", ")", ":", "\n", "        ", "''' Make sures the primitives runs '''", "\n", "for", "op_name", ",", "op_func", "in", "fbnet_builder", ".", "PRIMITIVES", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'Testing {}'", ".", "format", "(", "op_name", ")", ")", "\n", "\n", "# test empty batch size", "\n", "_test_primitive", "(", "\n", "self", ",", "\"cuda\"", ",", "\n", "op_name", ",", "op_func", ",", "\n", "N", "=", "0", ",", "C_in", "=", "16", ",", "C_out", "=", "32", ",", "expand", "=", "4", ",", "stride", "=", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_fbnet._test_primitive": [[13, 20], ["op_func().to", "torch.rand().to", "op_func().to.", "test_fbnet..assertEqual", "torch.Size", "op_func", "torch.rand"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["def", "_test_primitive", "(", "self", ",", "device", ",", "op_name", ",", "op_func", ",", "N", ",", "C_in", ",", "C_out", ",", "expand", ",", "stride", ")", ":", "\n", "    ", "op", "=", "op_func", "(", "C_in", ",", "C_out", ",", "expand", ",", "stride", ")", ".", "to", "(", "device", ")", "\n", "input", "=", "torch", ".", "rand", "(", "[", "N", ",", "C_in", ",", "7", ",", "7", "]", ",", "dtype", "=", "torch", ".", "float32", ")", ".", "to", "(", "device", ")", "\n", "output", "=", "op", "(", "input", ")", "\n", "self", ".", "assertEqual", "(", "\n", "output", ".", "shape", "[", ":", "2", "]", ",", "torch", ".", "Size", "(", "[", "N", ",", "C_out", "]", ")", ",", "\n", "'Primitive {} failed for shape {}.'", ".", "format", "(", "op_name", ",", "input", ".", "shape", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_backbones.TestBackbones.test_build_backbones": [[24, 51], ["test_backbones.TestBackbones.assertGreater", "vc_rcnn.modeling.registry.BACKBONES.items", "len", "print", "backbone_builder", "test_backbones.TestBackbones.assertIsNotNone", "torch.rand", "backbone_builder.", "utils.load_config", "copy.deepcopy", "getattr", "test_backbones.TestBackbones.assertEqual", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config"], ["    ", "def", "test_build_backbones", "(", "self", ")", ":", "\n", "        ", "''' Make sure backbones run '''", "\n", "\n", "self", ".", "assertGreater", "(", "len", "(", "registry", ".", "BACKBONES", ")", ",", "0", ")", "\n", "\n", "for", "name", ",", "backbone_builder", "in", "registry", ".", "BACKBONES", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'Testing {}...'", ".", "format", "(", "name", ")", ")", "\n", "if", "name", "in", "BACKBONE_CFGS", ":", "\n", "                ", "cfg", "=", "load_config", "(", "BACKBONE_CFGS", "[", "name", "]", ")", "\n", "", "else", ":", "\n", "# Use default config if config file is not specified", "\n", "                ", "cfg", "=", "copy", ".", "deepcopy", "(", "g_cfg", ")", "\n", "", "backbone", "=", "backbone_builder", "(", "cfg", ")", "\n", "\n", "# make sures the backbone has `out_channels`", "\n", "self", ".", "assertIsNotNone", "(", "\n", "getattr", "(", "backbone", ",", "'out_channels'", ",", "None", ")", ",", "\n", "'Need to provide out_channels for backbone {}'", ".", "format", "(", "name", ")", "\n", ")", "\n", "\n", "N", ",", "C_in", ",", "H", ",", "W", "=", "2", ",", "3", ",", "224", ",", "256", "\n", "input", "=", "torch", ".", "rand", "(", "[", "N", ",", "C_in", ",", "H", ",", "W", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "out", "=", "backbone", "(", "input", ")", "\n", "for", "cur_out", "in", "out", ":", "\n", "                ", "self", ".", "assertEqual", "(", "\n", "cur_out", ".", "shape", "[", ":", "2", "]", ",", "\n", "torch", ".", "Size", "(", "[", "N", ",", "backbone", ".", "out_channels", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_nms.TestNMS.test_nms_cpu": [[11, 59], ["numpy.array().astype().reshape", "torch.from_numpy", "torch.from_numpy", "zip", "vc_rcnn.layers.nms", "numpy.sort", "numpy.testing.assert_array_equal", "numpy.array().astype", "numpy.array", "numpy.array"], "methods", ["None"], ["    ", "def", "test_nms_cpu", "(", "self", ")", ":", "\n", "        ", "\"\"\" Match unit test UtilsNMSTest.TestNMS in\n            caffe2/operators/generate_proposals_op_util_nms_test.cc\n        \"\"\"", "\n", "\n", "inputs", "=", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "10", ",", "\n", "10", ",", "\n", "50", ",", "\n", "60", ",", "\n", "0.5", ",", "\n", "11", ",", "\n", "12", ",", "\n", "48", ",", "\n", "60", ",", "\n", "0.7", ",", "\n", "8", ",", "\n", "9", ",", "\n", "40", ",", "\n", "50", ",", "\n", "0.6", ",", "\n", "100", ",", "\n", "100", ",", "\n", "150", ",", "\n", "140", ",", "\n", "0.9", ",", "\n", "99", ",", "\n", "110", ",", "\n", "155", ",", "\n", "139", ",", "\n", "0.8", ",", "\n", "]", "\n", ")", "\n", ".", "astype", "(", "np", ".", "float32", ")", "\n", ".", "reshape", "(", "-", "1", ",", "5", ")", "\n", ")", "\n", "\n", "boxes", "=", "torch", ".", "from_numpy", "(", "inputs", "[", ":", ",", ":", "4", "]", ")", "\n", "scores", "=", "torch", ".", "from_numpy", "(", "inputs", "[", ":", ",", "4", "]", ")", "\n", "test_thresh", "=", "[", "0.1", ",", "0.3", ",", "0.5", ",", "0.8", ",", "0.9", "]", "\n", "gt_indices", "=", "[", "[", "1", ",", "3", "]", ",", "[", "1", ",", "3", "]", ",", "[", "1", ",", "3", "]", ",", "[", "1", ",", "2", ",", "3", ",", "4", "]", ",", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", "]", "]", "\n", "\n", "for", "thresh", ",", "gt_index", "in", "zip", "(", "test_thresh", ",", "gt_indices", ")", ":", "\n", "            ", "keep_indices", "=", "box_nms", "(", "boxes", ",", "scores", ",", "thresh", ")", "\n", "keep_indices", "=", "np", ".", "sort", "(", "keep_indices", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "keep_indices", ",", "np", ".", "array", "(", "gt_index", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_nms.TestNMS.test_nms1_cpu": [[60, 218], ["torch.from_numpy", "torch.from_numpy", "numpy.array", "vc_rcnn.layers.nms", "numpy.sort", "numpy.testing.assert_array_equal", "numpy.array().astype", "numpy.array().astype", "numpy.array", "numpy.array"], "methods", ["None"], ["", "", "def", "test_nms1_cpu", "(", "self", ")", ":", "\n", "        ", "\"\"\" Match unit test UtilsNMSTest.TestNMS1 in\n            caffe2/operators/generate_proposals_op_util_nms_test.cc\n        \"\"\"", "\n", "\n", "boxes", "=", "torch", ".", "from_numpy", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "350.9821", ",", "161.8200", ",", "369.9685", ",", "205.2372", "]", ",", "\n", "[", "250.5236", ",", "154.2844", ",", "274.1773", ",", "204.9810", "]", ",", "\n", "[", "471.4920", ",", "160.4118", ",", "496.0094", ",", "213.4244", "]", ",", "\n", "[", "352.0421", ",", "164.5933", ",", "366.4458", ",", "205.9624", "]", ",", "\n", "[", "166.0765", ",", "169.7707", ",", "183.0102", ",", "232.6606", "]", ",", "\n", "[", "252.3000", ",", "183.1449", ",", "269.6541", ",", "210.6747", "]", ",", "\n", "[", "469.7862", ",", "162.0192", ",", "482.1673", ",", "187.0053", "]", ",", "\n", "[", "168.4862", ",", "174.2567", ",", "181.7437", ",", "232.9379", "]", ",", "\n", "[", "470.3290", ",", "162.3442", ",", "496.4272", ",", "214.6296", "]", ",", "\n", "[", "251.0450", ",", "155.5911", ",", "272.2693", ",", "203.3675", "]", ",", "\n", "[", "252.0326", ",", "154.7950", ",", "273.7404", ",", "195.3671", "]", ",", "\n", "[", "351.7479", ",", "161.9567", ",", "370.6432", ",", "204.3047", "]", ",", "\n", "[", "496.3306", ",", "161.7157", ",", "515.0573", ",", "210.7200", "]", ",", "\n", "[", "471.0749", ",", "162.6143", ",", "485.3374", ",", "207.3448", "]", ",", "\n", "[", "250.9745", ",", "160.7633", ",", "264.1924", ",", "206.8350", "]", ",", "\n", "[", "470.4792", ",", "169.0351", ",", "487.1934", ",", "220.2984", "]", ",", "\n", "[", "474.4227", ",", "161.9546", ",", "513.1018", ",", "215.5193", "]", ",", "\n", "[", "251.9428", ",", "184.1950", ",", "262.6937", ",", "207.6416", "]", ",", "\n", "[", "252.6623", ",", "175.0252", ",", "269.8806", ",", "213.7584", "]", ",", "\n", "[", "260.9884", ",", "157.0351", ",", "288.3554", ",", "206.6027", "]", ",", "\n", "[", "251.3629", ",", "164.5101", ",", "263.2179", ",", "202.4203", "]", ",", "\n", "[", "471.8361", ",", "190.8142", ",", "485.6812", ",", "220.8586", "]", ",", "\n", "[", "248.6243", ",", "156.9628", ",", "264.3355", ",", "199.2767", "]", ",", "\n", "[", "495.1643", ",", "158.0483", ",", "512.6261", ",", "184.4192", "]", ",", "\n", "[", "376.8718", ",", "168.0144", ",", "387.3584", ",", "201.3210", "]", ",", "\n", "[", "122.9191", ",", "160.7433", ",", "172.5612", ",", "231.3837", "]", ",", "\n", "[", "350.3857", ",", "175.8806", ",", "366.2500", ",", "205.4329", "]", ",", "\n", "[", "115.2958", ",", "162.7822", ",", "161.9776", ",", "229.6147", "]", ",", "\n", "[", "168.4375", ",", "177.4041", ",", "180.8028", ",", "232.4551", "]", ",", "\n", "[", "169.7939", ",", "184.4330", ",", "181.4767", ",", "232.1220", "]", ",", "\n", "[", "347.7536", ",", "175.9356", ",", "355.8637", ",", "197.5586", "]", ",", "\n", "[", "495.5434", ",", "164.6059", ",", "516.4031", ",", "207.7053", "]", ",", "\n", "[", "172.1216", ",", "194.6033", ",", "183.1217", ",", "235.2653", "]", ",", "\n", "[", "264.2654", ",", "181.5540", ",", "288.4626", ",", "214.0170", "]", ",", "\n", "[", "111.7971", ",", "183.7748", ",", "137.3745", ",", "225.9724", "]", ",", "\n", "[", "253.4919", ",", "186.3945", ",", "280.8694", ",", "210.0731", "]", ",", "\n", "[", "165.5334", ",", "169.7344", ",", "185.9159", ",", "232.8514", "]", ",", "\n", "[", "348.3662", ",", "184.5187", ",", "354.9081", ",", "201.4038", "]", ",", "\n", "[", "164.6562", ",", "162.5724", ",", "186.3108", ",", "233.5010", "]", ",", "\n", "[", "113.2999", ",", "186.8410", ",", "135.8841", ",", "219.7642", "]", ",", "\n", "[", "117.0282", ",", "179.8009", ",", "142.5375", ",", "221.0736", "]", ",", "\n", "[", "462.1312", ",", "161.1004", ",", "495.3576", ",", "217.2208", "]", ",", "\n", "[", "462.5800", ",", "159.9310", ",", "501.2937", ",", "224.1655", "]", ",", "\n", "[", "503.5242", ",", "170.0733", ",", "518.3792", ",", "209.0113", "]", ",", "\n", "[", "250.3658", ",", "195.5925", ",", "260.6523", ",", "212.4679", "]", ",", "\n", "[", "108.8287", ",", "163.6994", ",", "146.3642", ",", "229.7261", "]", ",", "\n", "[", "256.7617", ",", "187.3123", ",", "288.8407", ",", "211.2013", "]", ",", "\n", "[", "161.2781", ",", "167.4801", ",", "186.3751", ",", "232.7133", "]", ",", "\n", "[", "115.3760", ",", "177.5859", ",", "163.3512", ",", "236.9660", "]", ",", "\n", "[", "248.9077", ",", "188.0919", ",", "264.8579", ",", "207.9718", "]", ",", "\n", "[", "108.1349", ",", "160.7851", ",", "143.6370", ",", "229.6243", "]", ",", "\n", "[", "465.0900", ",", "156.7555", ",", "490.3561", ",", "213.5704", "]", ",", "\n", "[", "107.5338", ",", "173.4323", ",", "141.0704", ",", "235.2910", "]", ",", "\n", "]", "\n", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", ")", "\n", "scores", "=", "torch", ".", "from_numpy", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "0.1919", ",", "\n", "0.3293", ",", "\n", "0.0860", ",", "\n", "0.1600", ",", "\n", "0.1885", ",", "\n", "0.4297", ",", "\n", "0.0974", ",", "\n", "0.2711", ",", "\n", "0.1483", ",", "\n", "0.1173", ",", "\n", "0.1034", ",", "\n", "0.2915", ",", "\n", "0.1993", ",", "\n", "0.0677", ",", "\n", "0.3217", ",", "\n", "0.0966", ",", "\n", "0.0526", ",", "\n", "0.5675", ",", "\n", "0.3130", ",", "\n", "0.1592", ",", "\n", "0.1353", ",", "\n", "0.0634", ",", "\n", "0.1557", ",", "\n", "0.1512", ",", "\n", "0.0699", ",", "\n", "0.0545", ",", "\n", "0.2692", ",", "\n", "0.1143", ",", "\n", "0.0572", ",", "\n", "0.1990", ",", "\n", "0.0558", ",", "\n", "0.1500", ",", "\n", "0.2214", ",", "\n", "0.1878", ",", "\n", "0.2501", ",", "\n", "0.1343", ",", "\n", "0.0809", ",", "\n", "0.1266", ",", "\n", "0.0743", ",", "\n", "0.0896", ",", "\n", "0.0781", ",", "\n", "0.0983", ",", "\n", "0.0557", ",", "\n", "0.0623", ",", "\n", "0.5808", ",", "\n", "0.3090", ",", "\n", "0.1050", ",", "\n", "0.0524", ",", "\n", "0.0513", ",", "\n", "0.4501", ",", "\n", "0.4167", ",", "\n", "0.0623", ",", "\n", "0.1749", ",", "\n", "]", "\n", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", ")", "\n", "\n", "gt_indices", "=", "np", ".", "array", "(", "\n", "[", "\n", "1", ",", "\n", "6", ",", "\n", "7", ",", "\n", "8", ",", "\n", "11", ",", "\n", "12", ",", "\n", "13", ",", "\n", "14", ",", "\n", "17", ",", "\n", "18", ",", "\n", "19", ",", "\n", "21", ",", "\n", "23", ",", "\n", "24", ",", "\n", "25", ",", "\n", "26", ",", "\n", "30", ",", "\n", "32", ",", "\n", "33", ",", "\n", "34", ",", "\n", "35", ",", "\n", "37", ",", "\n", "43", ",", "\n", "44", ",", "\n", "47", ",", "\n", "50", ",", "\n", "]", "\n", ")", "\n", "keep_indices", "=", "box_nms", "(", "boxes", ",", "scores", ",", "0.5", ")", "\n", "keep_indices", "=", "np", ".", "sort", "(", "keep_indices", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "keep_indices", ",", "gt_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.TestDetectors.test_build_detectors": [[117, 120], ["test_detectors._test_build_detectors"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors._test_build_detectors"], ["    ", "def", "test_build_detectors", "(", "self", ")", ":", "\n", "        ", "''' Make sure models build '''", "\n", "_test_build_detectors", "(", "self", ",", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.TestDetectors.test_build_detectors_cuda": [[121, 125], ["unittest.skipIf", "test_detectors._test_build_detectors"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors._test_build_detectors"], ["", "@", "unittest", ".", "skipIf", "(", "not", "TEST_CUDA", ",", "\"no CUDA detected\"", ")", "\n", "def", "test_build_detectors_cuda", "(", "self", ")", ":", "\n", "        ", "''' Make sure models build on gpu'''", "\n", "_test_build_detectors", "(", "self", ",", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.TestDetectors.test_run_selected_detectors": [[126, 132], ["test_detectors.get_config_files", "test_detectors._test_run_selected_detectors"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.get_config_files", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors._test_run_selected_detectors"], ["", "def", "test_run_selected_detectors", "(", "self", ")", ":", "\n", "        ", "''' Make sure models build and run '''", "\n", "# run on selected models", "\n", "cfg_files", "=", "get_config_files", "(", "CONFIG_FILES", ",", "None", ")", "\n", "# cfg_files = get_config_files(None, EXCLUDED_FOLDERS)", "\n", "_test_run_selected_detectors", "(", "self", ",", "cfg_files", ",", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.TestDetectors.test_run_selected_detectors_cuda": [[133, 140], ["unittest.skipIf", "test_detectors.get_config_files", "test_detectors._test_run_selected_detectors"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.get_config_files", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors._test_run_selected_detectors"], ["", "@", "unittest", ".", "skipIf", "(", "not", "TEST_CUDA", ",", "\"no CUDA detected\"", ")", "\n", "def", "test_run_selected_detectors_cuda", "(", "self", ")", ":", "\n", "        ", "''' Make sure models build and run on cuda '''", "\n", "# run on selected models", "\n", "cfg_files", "=", "get_config_files", "(", "CONFIG_FILES", ",", "None", ")", "\n", "# cfg_files = get_config_files(None, EXCLUDED_FOLDERS)", "\n", "_test_run_selected_detectors", "(", "self", ",", "cfg_files", ",", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.get_config_files": [[52, 67], ["utils.get_config_root_path", "glob.glob", "any", "os.path.join", "os.path.join", "test_detectors.get_config_files._contains"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.env_tests.env.get_config_root_path"], ["def", "get_config_files", "(", "file_list", ",", "exclude_folders", ")", ":", "\n", "    ", "cfg_root_path", "=", "utils", ".", "get_config_root_path", "(", ")", "\n", "if", "file_list", "is", "not", "None", ":", "\n", "        ", "files", "=", "[", "os", ".", "path", ".", "join", "(", "cfg_root_path", ",", "x", ")", "for", "x", "in", "file_list", "]", "\n", "", "else", ":", "\n", "        ", "files", "=", "glob", ".", "glob", "(", "\n", "os", ".", "path", ".", "join", "(", "cfg_root_path", ",", "\"./**/*.yaml\"", ")", ",", "recursive", "=", "True", ")", "\n", "\n", "", "def", "_contains", "(", "path", ",", "exclude_dirs", ")", ":", "\n", "        ", "return", "any", "(", "x", "in", "path", "for", "x", "in", "exclude_dirs", ")", "\n", "\n", "", "if", "exclude_folders", "is", "not", "None", ":", "\n", "        ", "files", "=", "[", "x", "for", "x", "in", "files", "if", "not", "_contains", "(", "x", ",", "exclude_folders", ")", "]", "\n", "\n", "", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.create_model": [[69, 75], ["copy.deepcopy", "copy.deepcopy.freeze", "vc_rcnn.modeling.detector.build_detection_model", "model.to.to"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.detector.detectors.build_detection_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "create_model", "(", "cfg", ",", "device", ")", ":", "\n", "    ", "cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "model", "=", "build_detection_model", "(", "cfg", ")", "\n", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.create_random_input": [[77, 84], ["vc_rcnn.structures.image_list.to_image_list", "ret.to.to", "ret.to.append", "torch.rand", "int"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.image_list.to_image_list", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.structures.keypoint.Keypoints.to"], ["", "def", "create_random_input", "(", "cfg", ",", "device", ")", ":", "\n", "    ", "ret", "=", "[", "]", "\n", "for", "x", "in", "cfg", ".", "INPUT", ".", "MIN_SIZE_TRAIN", ":", "\n", "        ", "ret", ".", "append", "(", "torch", ".", "rand", "(", "3", ",", "x", ",", "int", "(", "x", "*", "1.2", ")", ")", ")", "\n", "", "ret", "=", "to_image_list", "(", "ret", ",", "cfg", ".", "DATALOADER", ".", "SIZE_DIVISIBILITY", ")", "\n", "ret", "=", "ret", ".", "to", "(", "device", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors._test_build_detectors": [[86, 97], ["test_detectors.get_config_files", "test_detectors..assertGreater", "len", "test_detectors..subTest", "print", "utils.load_config_from_file", "test_detectors.create_model"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.get_config_files", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config_from_file", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model"], ["", "def", "_test_build_detectors", "(", "self", ",", "device", ")", ":", "\n", "    ", "''' Make sure models build '''", "\n", "\n", "cfg_files", "=", "get_config_files", "(", "None", ",", "EXCLUDED_FOLDERS", ")", "\n", "self", ".", "assertGreater", "(", "len", "(", "cfg_files", ")", ",", "0", ")", "\n", "\n", "for", "cfg_file", "in", "cfg_files", ":", "\n", "        ", "with", "self", ".", "subTest", "(", "cfg_file", "=", "cfg_file", ")", ":", "\n", "            ", "print", "(", "'Testing {}...'", ".", "format", "(", "cfg_file", ")", ")", "\n", "cfg", "=", "utils", ".", "load_config_from_file", "(", "cfg_file", ")", "\n", "create_model", "(", "cfg", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors._test_run_selected_detectors": [[99, 114], ["test_detectors..assertGreater", "len", "test_detectors..subTest", "print", "utils.load_config_from_file", "test_detectors.create_model", "test_detectors.create_random_input", "create_model.eval", "create_model.", "test_detectors..assertEqual", "len", "len"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config_from_file", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_detectors.create_random_input", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.core.exec.Execution.eval"], ["", "", "", "def", "_test_run_selected_detectors", "(", "self", ",", "cfg_files", ",", "device", ")", ":", "\n", "    ", "''' Make sure models build and run '''", "\n", "self", ".", "assertGreater", "(", "len", "(", "cfg_files", ")", ",", "0", ")", "\n", "\n", "for", "cfg_file", "in", "cfg_files", ":", "\n", "        ", "with", "self", ".", "subTest", "(", "cfg_file", "=", "cfg_file", ")", ":", "\n", "            ", "print", "(", "'Testing {}...'", ".", "format", "(", "cfg_file", ")", ")", "\n", "cfg", "=", "utils", ".", "load_config_from_file", "(", "cfg_file", ")", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOP_N_TEST", "=", "10", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "FPN_POST_NMS_TOP_N_TEST", "=", "10", "\n", "model", "=", "create_model", "(", "cfg", ",", "device", ")", "\n", "inputs", "=", "create_random_input", "(", "cfg", ",", "device", ")", "\n", "model", ".", "eval", "(", ")", "\n", "output", "=", "model", "(", "inputs", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "output", ")", ",", "len", "(", "inputs", ".", "image_sizes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_box_coder.TestBoxCoder.test_box_decoder": [[11, 106], ["vc_rcnn.modeling.box_coder.BoxCoder", "torch.from_numpy", "torch.from_numpy", "numpy.array().astype().reshape", "vc_rcnn.modeling.box_coder.BoxCoder.decode", "numpy.testing.assert_allclose", "numpy.array().astype().reshape", "numpy.array().astype().reshape", "vc_rcnn.modeling.box_coder.BoxCoder.decode.detach().numpy", "numpy.array().astype", "numpy.array().astype", "numpy.array().astype", "vc_rcnn.modeling.box_coder.BoxCoder.decode.detach", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.models.TransformerModel.EncoderDecoder.decode"], ["    ", "def", "test_box_decoder", "(", "self", ")", ":", "\n", "        ", "\"\"\" Match unit test UtilsBoxesTest.TestBboxTransformRandom in\n            caffe2/operators/generate_proposals_op_util_boxes_test.cc\n        \"\"\"", "\n", "box_coder", "=", "BoxCoder", "(", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", "\n", "bbox", "=", "torch", ".", "from_numpy", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "175.62031555", ",", "\n", "20.91103172", ",", "\n", "253.352005", ",", "\n", "155.0145874", ",", "\n", "169.24636841", ",", "\n", "4.85241556", ",", "\n", "228.8605957", ",", "\n", "105.02092743", ",", "\n", "181.77426147", ",", "\n", "199.82876587", ",", "\n", "192.88427734", ",", "\n", "214.0255127", ",", "\n", "174.36262512", ",", "\n", "186.75761414", ",", "\n", "296.19091797", ",", "\n", "231.27906799", ",", "\n", "22.73153877", ",", "\n", "92.02596283", ",", "\n", "135.5695343", ",", "\n", "208.80291748", ",", "\n", "]", "\n", ")", "\n", ".", "astype", "(", "np", ".", "float32", ")", "\n", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", ")", "\n", "\n", "deltas", "=", "torch", ".", "from_numpy", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "0.47861834", ",", "\n", "0.13992102", ",", "\n", "0.14961673", ",", "\n", "0.71495209", ",", "\n", "0.29915856", ",", "\n", "-", "0.35664671", ",", "\n", "0.89018666", ",", "\n", "0.70815367", ",", "\n", "-", "0.03852064", ",", "\n", "0.44466892", ",", "\n", "0.49492538", ",", "\n", "0.71409376", ",", "\n", "0.28052918", ",", "\n", "0.02184832", ",", "\n", "0.65289006", ",", "\n", "1.05060139", ",", "\n", "-", "0.38172557", ",", "\n", "-", "0.08533806", ",", "\n", "-", "0.60335309", ",", "\n", "0.79052375", ",", "\n", "]", "\n", ")", "\n", ".", "astype", "(", "np", ".", "float32", ")", "\n", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", ")", "\n", "\n", "gt_bbox", "=", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "206.949539", ",", "\n", "-", "30.715202", ",", "\n", "297.387665", ",", "\n", "244.448486", ",", "\n", "143.871216", ",", "\n", "-", "83.342888", ",", "\n", "290.502289", ",", "\n", "121.053398", ",", "\n", "177.430283", ",", "\n", "198.666245", ",", "\n", "196.295273", ",", "\n", "228.703079", ",", "\n", "152.251892", ",", "\n", "145.431564", ",", "\n", "387.215454", ",", "\n", "274.594238", ",", "\n", "5.062420", ",", "\n", "11.040955", ",", "\n", "66.328903", ",", "\n", "269.686218", ",", "\n", "]", "\n", ")", "\n", ".", "astype", "(", "np", ".", "float32", ")", "\n", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", ")", "\n", "\n", "results", "=", "box_coder", ".", "decode", "(", "deltas", ",", "bbox", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "results", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "gt_bbox", ",", "atol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.test_rpn_heads.TestRPNHeads.test_build_rpn_heads": [[20, 57], ["test_rpn_heads.TestRPNHeads.assertGreater", "vc_rcnn.modeling.registry.RPN_HEADS.items", "len", "print", "builder", "torch.rand", "builder.", "test_rpn_heads.TestRPNHeads.assertEqual", "range", "utils.load_config", "copy.deepcopy", "len", "test_rpn_heads.TestRPNHeads.assertEqual", "test_rpn_heads.TestRPNHeads.assertEqual", "torch.Size", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config"], ["    ", "def", "test_build_rpn_heads", "(", "self", ")", ":", "\n", "        ", "''' Make sure rpn heads run '''", "\n", "\n", "self", ".", "assertGreater", "(", "len", "(", "registry", ".", "RPN_HEADS", ")", ",", "0", ")", "\n", "\n", "in_channels", "=", "64", "\n", "num_anchors", "=", "10", "\n", "\n", "for", "name", ",", "builder", "in", "registry", ".", "RPN_HEADS", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'Testing {}...'", ".", "format", "(", "name", ")", ")", "\n", "if", "name", "in", "RPN_CFGS", ":", "\n", "                ", "cfg", "=", "load_config", "(", "RPN_CFGS", "[", "name", "]", ")", "\n", "", "else", ":", "\n", "# Use default config if config file is not specified", "\n", "                ", "cfg", "=", "copy", ".", "deepcopy", "(", "g_cfg", ")", "\n", "\n", "", "rpn", "=", "builder", "(", "cfg", ",", "in_channels", ",", "num_anchors", ")", "\n", "\n", "N", ",", "C_in", ",", "H", ",", "W", "=", "2", ",", "in_channels", ",", "24", ",", "32", "\n", "input", "=", "torch", ".", "rand", "(", "[", "N", ",", "C_in", ",", "H", ",", "W", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "LAYERS", "=", "3", "\n", "out", "=", "rpn", "(", "[", "input", "]", "*", "LAYERS", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "out", ")", ",", "2", ")", "\n", "logits", ",", "bbox_reg", "=", "out", "\n", "for", "idx", "in", "range", "(", "LAYERS", ")", ":", "\n", "                ", "self", ".", "assertEqual", "(", "\n", "logits", "[", "idx", "]", ".", "shape", ",", "\n", "torch", ".", "Size", "(", "[", "\n", "input", ".", "shape", "[", "0", "]", ",", "num_anchors", ",", "\n", "input", ".", "shape", "[", "2", "]", ",", "input", ".", "shape", "[", "3", "]", ",", "\n", "]", ")", "\n", ")", "\n", "self", ".", "assertEqual", "(", "\n", "bbox_reg", "[", "idx", "]", ".", "shape", ",", "\n", "torch", ".", "Size", "(", "[", "\n", "logits", "[", "idx", "]", ".", "shape", "[", "0", "]", ",", "num_anchors", "*", "4", ",", "\n", "logits", "[", "idx", "]", ".", "shape", "[", "2", "]", ",", "logits", "[", "idx", "]", ".", "shape", "[", "3", "]", ",", "\n", "]", ")", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.get_config_root_path": [[14, 16], ["env_tests.get_config_root_path"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.env_tests.env.get_config_root_path"], ["if", "len", "(", "tensors", ")", "==", "1", ":", "\n", "        ", "return", "tensors", "[", "0", "]", "\n", "", "return", "torch", ".", "cat", "(", "tensors", ",", "dim", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config": [[18, 22], ["os.path.join", "utils.load_config_from_file", "env_tests.get_config_root_path"], "function", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config_from_file", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.env_tests.env.get_config_root_path"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.utils.load_config_from_file": [[24, 29], ["copy.deepcopy", "copy.deepcopy.merge_from_file"], "function", ["None"], []], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model": [[15, 17], ["torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["None"], ["self", ",", "\n", "model", ",", "\n", "optimizer", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_complex_model": [[18, 35], ["torch.nn.Module", "torch.nn.Module", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Module", "torch.nn.Linear", "collections.OrderedDict", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand"], "methods", ["None"], ["scheduler", "=", "None", ",", "\n", "save_dir", "=", "\"\"", ",", "\n", "save_to_disk", "=", "None", ",", "\n", "logger", "=", "None", ",", "\n", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "scheduler", "=", "scheduler", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "save_to_disk", "=", "save_to_disk", "\n", "if", "logger", "is", "None", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "", "self", ".", "logger", "=", "logger", "\n", "\n", "", "def", "save", "(", "self", ",", "name", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "not", "self", ".", "save_dir", ":", "\n", "            ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.test_from_last_checkpoint_model": [[36, 70], ["zip", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "torch.nn.DataParallel", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "tempfile.TemporaryDirectory", "vc_rcnn.utils.checkpoint.Checkpointer", "vc_rcnn.utils.checkpoint.Checkpointer.save", "vc_rcnn.utils.checkpoint.Checkpointer", "checkpoint.TestCheckpointer.assertTrue", "checkpoint.TestCheckpointer.assertEqual", "vc_rcnn.utils.checkpoint.Checkpointer.load", "trained_model.parameters", "fresh_model.parameters", "checkpoint.TestCheckpointer.assertFalse", "checkpoint.TestCheckpointer.assertTrue", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "vc_rcnn.utils.checkpoint.Checkpointer.has_checkpoint", "vc_rcnn.utils.checkpoint.Checkpointer.get_checkpoint_file", "os.path.join", "trained_p.equal", "id", "id"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.has_checkpoint", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.get_checkpoint_file"], ["", "if", "not", "self", ".", "save_to_disk", ":", "\n", "            ", "return", "\n", "\n", "", "data", "=", "{", "}", "\n", "data", "[", "\"model\"", "]", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "if", "self", ".", "optimizer", "is", "not", "None", ":", "\n", "            ", "data", "[", "\"optimizer\"", "]", "=", "self", ".", "optimizer", ".", "state_dict", "(", ")", "\n", "", "if", "self", ".", "scheduler", "is", "not", "None", ":", "\n", "            ", "data", "[", "\"scheduler\"", "]", "=", "self", ".", "scheduler", ".", "state_dict", "(", ")", "\n", "", "data", ".", "update", "(", "kwargs", ")", "\n", "\n", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"{}.pth\"", ".", "format", "(", "name", ")", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Saving checkpoint to {}\"", ".", "format", "(", "save_file", ")", ")", "\n", "torch", ".", "save", "(", "data", ",", "save_file", ")", "\n", "self", ".", "tag_last_checkpoint", "(", "save_file", ")", "\n", "\n", "", "def", "load", "(", "self", ",", "f", "=", "None", ",", "use_latest", "=", "True", ")", ":", "\n", "        ", "if", "self", ".", "has_checkpoint", "(", ")", "and", "use_latest", ":", "\n", "# override argument with existing checkpoint", "\n", "            ", "f", "=", "self", ".", "get_checkpoint_file", "(", ")", "\n", "", "if", "not", "f", ":", "\n", "# no checkpoint could be found", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"No checkpoint found. Initializing model from scratch\"", ")", "\n", "return", "{", "}", "\n", "", "self", ".", "logger", ".", "info", "(", "\"Loading checkpoint from {}\"", ".", "format", "(", "f", ")", ")", "\n", "checkpoint", "=", "self", ".", "_load_file", "(", "f", ")", "\n", "self", ".", "_load_model", "(", "checkpoint", ")", "\n", "if", "\"optimizer\"", "in", "checkpoint", "and", "self", ".", "optimizer", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"Loading optimizer from {}\"", ".", "format", "(", "f", ")", ")", "\n", "self", ".", "optimizer", ".", "load_state_dict", "(", "checkpoint", ".", "pop", "(", "\"optimizer\"", ")", ")", "\n", "", "if", "\"scheduler\"", "in", "checkpoint", "and", "self", ".", "scheduler", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\"Loading scheduler from {}\"", ".", "format", "(", "f", ")", ")", "\n", "self", ".", "scheduler", ".", "load_state_dict", "(", "checkpoint", ".", "pop", "(", "\"scheduler\"", ")", ")", "\n", "\n", "# return any further checkpoint data", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.test_from_name_file_model": [[71, 102], ["zip", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "torch.nn.DataParallel", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "tempfile.TemporaryDirectory", "vc_rcnn.utils.checkpoint.Checkpointer", "vc_rcnn.utils.checkpoint.Checkpointer.save", "trained_model.parameters", "fresh_model.parameters", "checkpoint.TestCheckpointer.assertFalse", "checkpoint.TestCheckpointer.assertTrue", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "checkpoint.TestCheckpointer.create_model", "tempfile.TemporaryDirectory", "vc_rcnn.utils.checkpoint.Checkpointer", "checkpoint.TestCheckpointer.assertFalse", "checkpoint.TestCheckpointer.assertEqual", "vc_rcnn.utils.checkpoint.Checkpointer.load", "trained_p.equal", "vc_rcnn.utils.checkpoint.Checkpointer.has_checkpoint", "vc_rcnn.utils.checkpoint.Checkpointer.get_checkpoint_file", "os.path.join", "id", "id"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.save", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.load", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.has_checkpoint", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.utils.checkpoint.Checkpointer.get_checkpoint_file"], ["", "return", "checkpoint", "\n", "\n", "", "def", "has_checkpoint", "(", "self", ")", ":", "\n", "        ", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"last_checkpoint\"", ")", "\n", "return", "os", ".", "path", ".", "exists", "(", "save_file", ")", "\n", "\n", "", "def", "get_checkpoint_file", "(", "self", ")", ":", "\n", "        ", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"last_checkpoint\"", ")", "\n", "try", ":", "\n", "            ", "with", "open", "(", "save_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "last_saved", "=", "f", ".", "read", "(", ")", "\n", "last_saved", "=", "last_saved", ".", "strip", "(", ")", "\n", "", "", "except", "IOError", ":", "\n", "# if file doesn't exist, maybe because it has just been", "\n", "# deleted by a separate process", "\n", "            ", "last_saved", "=", "\"\"", "\n", "", "return", "last_saved", "\n", "\n", "", "def", "tag_last_checkpoint", "(", "self", ",", "last_filename", ")", ":", "\n", "        ", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"last_checkpoint\"", ")", "\n", "with", "open", "(", "save_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "last_filename", ")", "\n", "\n", "", "", "def", "_load_file", "(", "self", ",", "f", ")", ":", "\n", "        ", "return", "torch", ".", "load", "(", "f", ",", "map_location", "=", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "\n", "", "def", "_load_model", "(", "self", ",", "checkpoint", ")", ":", "\n", "        ", "load_state_dict", "(", "self", ".", "model", ",", "checkpoint", ".", "pop", "(", "\"model\"", ")", ")", "\n", "\n", "\n", "", "", "class", "DetectronCheckpointer", "(", "Checkpointer", ")", ":", "\n", "    ", "def", "__init__", "(", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.test_complex_model_loaded": [[103, 115], ["checkpoint.TestCheckpointer.create_complex_model", "vc_rcnn.utils.model_serialization.load_state_dict", "zip", "torch.nn.DataParallel", "torch.nn.DataParallel.state_dict().values", "state_dict.values", "checkpoint.TestCheckpointer.assertFalse", "checkpoint.TestCheckpointer.assertTrue", "loaded.equal", "torch.nn.DataParallel.state_dict", "id", "id"], "methods", ["home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.tests.checkpoint.TestCheckpointer.create_complex_model", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.load_state_dict", "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.misc.utils.ReduceLROnPlateau.state_dict"], ["self", ",", "\n", "cfg", ",", "\n", "model", ",", "\n", "optimizer", "=", "None", ",", "\n", "scheduler", "=", "None", ",", "\n", "save_dir", "=", "\"\"", ",", "\n", "save_to_disk", "=", "None", ",", "\n", "logger", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "DetectronCheckpointer", ",", "self", ")", ".", "__init__", "(", "\n", "model", ",", "optimizer", ",", "scheduler", ",", "save_dir", ",", "save_to_disk", ",", "logger", "\n", ")", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n"]], "home.repos.pwc.inspect_result.Wangt-CN_VC-R-CNN.env_tests.env.get_config_root_path": [[6, 13], ["os.path.dirname", "os.path.dirname", "os.path.join", "os.path.abspath", "os.path.dirname", "os.path.realpath"], "function", ["None"], ["\n", "def", "setup_environment", "(", ")", ":", "\n", "    ", "\"\"\"Perform environment setup work. The default setup is a no-op, but this\n    function allows the user to specify a Python source file that performs\n    custom setup work that may be necessary to their computing environment.\n    \"\"\"", "\n", "custom_module_path", "=", "os", ".", "environ", ".", "get", "(", "\"TORCH_DETECTRON_ENV_MODULE\"", ")", "\n", "if", "custom_module_path", ":", "\n"]]}