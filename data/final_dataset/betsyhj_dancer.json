{"home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TF.__init__": [[12, 53], ["torch.nn.Module.__init__", "int", "int", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "tf.TF.apply", "tf.TF.log_info", "tf.TF.loss_type.upper", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "tf.TF.loss_type.upper", "torch.nn.MSELoss", "tf.TF.loss_type.upper", "torch.nn.BCELoss", "torch.nn.Sigmoid", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF_variety.log_info"], ["def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ")", ":", "\n", "        ", "super", "(", "TF", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "task", "=", "config", "[", "'task'", "]", "\n", "# load parameter info", "\n", "self", ".", "debiasing", "=", "debiasing", "\n", "self", ".", "embedding_size", "=", "int", "(", "config", "[", "'embedding_size'", "]", ")", "\n", "self", ".", "loss_type", "=", "config", "[", "'loss_type'", "]", "\n", "# self.lr_decay_step = int(config['lr_decay_step'])", "\n", "self", ".", "batch_size", "=", "int", "(", "config", "[", "'batch_size'", "]", ")", "\n", "self", ".", "n_items", "=", "data", ".", "n_items", "\n", "self", ".", "n_periods", "=", "data", ".", "n_periods", "\n", "self", ".", "n_users", "=", "data", ".", "n_users", "\n", "\n", "# define layers and loss", "\n", "self", ".", "user_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_users", ",", "self", ".", "embedding_size", ")", "\n", "self", ".", "item_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", ",", "self", ".", "embedding_size", ")", "\n", "self", ".", "time_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_periods", ",", "self", ".", "embedding_size", ")", "\n", "\n", "self", ".", "m", "=", "None", "\n", "reduction", "=", "'mean'", "\n", "if", "self", ".", "task", "==", "'OPPT'", ":", "\n", "            ", "reduction", "=", "'none'", "\n", "", "if", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'CE'", ":", "\n", "            ", "if", "self", ".", "debiasing", ":", "\n", "                ", "self", ".", "loss_fct", "=", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "'none'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "loss_fct", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "", "", "elif", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'MSE'", ":", "\n", "            ", "self", ".", "loss_fct", "=", "nn", ".", "MSELoss", "(", "reduction", "=", "reduction", ")", "\n", "", "elif", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'NLL'", ":", "\n", "# self.loss_fct = nn.NLLLoss(reduction='none')", "\n", "# self.loss_fct = nn.BCEWithLogitsLoss()", "\n", "            ", "self", ".", "loss_fct", "=", "nn", ".", "BCELoss", "(", "reduction", "=", "reduction", ")", "\n", "self", ".", "m", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Make sure 'loss_type' in ['CE', 'MSE', 'NLL']!\"", ")", "\n", "\n", "# parameters initialization", "\n", "", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "self", ".", "log_info", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TF.log_info": [[54, 57], ["print"], "methods", ["None"], ["", "def", "log_info", "(", "self", ")", ":", "\n", "# print(\"********* Using TF-variety: v_i * (v_u + v_t) **********\")", "\n", "        ", "print", "(", "\"********* Using TF-variety: v_u * (v_i + v_t) **********\"", ")", "\n", "# print(\"********* Using TF-variety: v_u * v_i * v_t **********\")", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TF._init_weights": [[61, 72], ["isinstance", "torch.nn.init.xavier_normal_", "isinstance", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "isinstance", "torch.nn.init.xavier_normal_", "constant_", "isinstance", "constant_"], "methods", ["None"], ["", "def", "_init_weights", "(", "self", ",", "module", ")", ":", "\n", "        ", "if", "isinstance", "(", "module", ",", "nn", ".", "Embedding", ")", ":", "\n", "            ", "xavier_normal_", "(", "module", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "GRU", ")", ":", "\n", "            ", "xavier_uniform_", "(", "self", ".", "gru_layers", ".", "weight_hh_l0", ")", "\n", "xavier_uniform_", "(", "self", ".", "gru_layers", ".", "weight_ih_l0", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", ":", "\n", "            ", "xavier_normal_", "(", "module", ".", "weight", ")", "\n", "constant_", "(", "module", ".", "bias", ",", "0.0", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "Parameter", ")", ":", "\n", "            ", "constant_", "(", "module", ".", "weight", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TF._gather_indexes": [[73, 78], ["gather_index.view().expand.view().expand.view().expand", "output.gather", "output.gather.squeeze", "gather_index.view().expand.view().expand.view"], "methods", ["None"], ["", "", "def", "_gather_indexes", "(", "self", ",", "output", ",", "gather_index", ")", ":", "\n", "        ", "\"\"\"Gathers the vectors at the spexific positions over a minibatch\"\"\"", "\n", "gather_index", "=", "gather_index", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "output", ".", "shape", "[", "-", "1", "]", ")", "\n", "output_tensor", "=", "output", ".", "gather", "(", "dim", "=", "1", ",", "index", "=", "gather_index", ")", "\n", "return", "output_tensor", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TF.forward": [[79, 95], ["tf.TF.user_embedding", "tf.TF.item_embedding", "tf.TF.time_embedding", "torch.mul().sum().float", "tf.TF.m", "torch.mul().sum", "torch.mul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "user", ",", "item", ",", "itemage", ")", ":", "\n", "        ", "user_e", "=", "self", ".", "user_embedding", "(", "user", ")", "\n", "item_e", "=", "self", ".", "item_embedding", "(", "item", ")", "\n", "time_e", "=", "self", ".", "time_embedding", "(", "itemage", ")", "\n", "# # u_v * i_v * T_v", "\n", "# ui_e = torch.mul(user_e, item_e) # [B D]", "\n", "# uit_e = torch.mul(ui_e, time_e).sum(-1).float() # [B, D] -> [B]", "\n", "# # u_v * (i_v + T_v)", "\n", "uit_e", "=", "torch", ".", "mul", "(", "user_e", ",", "time_e", "+", "item_e", ")", ".", "sum", "(", "-", "1", ")", ".", "float", "(", ")", "\n", "# # i_v * (u_v + T_v)", "\n", "# uit_e = torch.mul(item_e, time_e + user_e).sum(-1).float()", "\n", "# # t_v * T_v", "\n", "# uit_e = torch.mul(item_e, time_e).sum(-1).float()", "\n", "if", "self", ".", "m", "is", "None", ":", "\n", "            ", "return", "uit_e", "\n", "", "return", "self", ".", "m", "(", "uit_e", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TF.calculate_loss": [[97, 108], ["tf.TF.forward", "interaction[].float", "tf.TF.loss_fct"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "calculate_loss", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "pred", "=", "self", ".", "forward", "(", "user", ",", "item", ",", "itemage", ")", "\n", "target", "=", "interaction", "[", "'target'", "]", ".", "float", "(", ")", "\n", "loss", "=", "self", ".", "loss_fct", "(", "pred", ",", "target", ")", "\n", "# if self.debiasing:", "\n", "#     ctr = torch.reciprocal(interaction['ctr']) # [B]", "\n", "#     loss = torch.mul(loss, ctr).sum() # [B] -> [1]", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TF.predict": [[109, 115], ["tf.TF.forward"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "predict", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "pred", "=", "self", ".", "forward", "(", "user", ",", "item", ",", "itemage", ")", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TF.full_sort_predict": [[116, 123], ["test_items_emb.view.view.view", "torch.matmul", "torch.matmul.view", "tf.TF.item_embedding.weight.view", "tf.TF.item_Dyn_embedding.weight.view", "tf.TF.user_embedding", "test_items_emb.view.view.transpose"], "methods", ["None"], ["", "def", "full_sort_predict", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "test_items_emb", "=", "self", ".", "item_embedding", ".", "weight", ".", "view", "(", "self", ".", "n_items", ",", "1", ",", "self", ".", "embedding_size", ")", "+", "self", ".", "item_Dyn_embedding", ".", "weight", ".", "view", "(", "self", ".", "n_items", ",", "self", ".", "n_periods", ",", "self", ".", "embedding_size", ")", "# [N D] + [N T D] -> [N T D]", "\n", "test_items_emb", "=", "test_items_emb", ".", "view", "(", "self", ".", "n_items", "*", "self", ".", "n_periods", ",", "self", ".", "embedding_size", ")", "#[N*T D]", "\n", "scores", "=", "torch", ".", "matmul", "(", "self", ".", "user_embedding", "(", "user", ")", ",", "test_items_emb", ".", "transpose", "(", "0", ",", "1", ")", ")", "# [B D], [D N*T] -> [B N*T]", "\n", "return", "scores", ".", "view", "(", "-", "1", ",", "self", ".", "n_items", ",", "self", ".", "n_periods", ")", "# [B N T]", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TMTF.__init__": [[151, 158], ["tf.TF.__init__", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.parameter.Parameter", "tf.TMTF.apply", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ")", ":", "\n", "        ", "super", "(", "TMTF", ",", "self", ")", ".", "__init__", "(", "config", ",", "data", ",", "debiasing", ")", "\n", "self", ".", "b_T", "=", "nn", ".", "Embedding", "(", "self", ".", "n_periods", ",", "1", ")", "\n", "self", ".", "b_u", "=", "nn", ".", "Embedding", "(", "self", ".", "n_users", ",", "1", ")", "\n", "self", ".", "b_i", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", ",", "1", ")", "\n", "self", ".", "b", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "1", ")", ")", "\n", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TMTF.log_info": [[159, 166], ["tf.TMTF.task.upper", "print", "print"], "methods", ["None"], ["", "def", "log_info", "(", "self", ")", ":", "\n", "# print(\"********* Using TMTF: v_u * (v_i + v_t) + b_T **********\")", "\n", "# print(\"********* Using TMTF: v_u * (v_i + v_t) + v_i * v_t + b_T **********\")", "\n", "        ", "if", "self", ".", "task", ".", "upper", "(", ")", "==", "'OIPT'", ":", "\n", "            ", "print", "(", "\"********* Using TMTF: v_i * (v_u + v_t) + b_T **********\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"********* Using TMTF: v_u * (v_i + v_t) + b + b_i + b_u + b_T **********\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tf.TMTF.forward": [[167, 184], ["tf.TMTF.user_embedding", "tf.TMTF.item_embedding", "tf.TMTF.time_embedding", "tf.TMTF.m", "tf.TMTF.task.upper", "torch.mul().sum().float", "tf.TMTF.b_T().squeeze", "tf.TMTF.b_T().squeeze", "tf.TMTF.b_i().squeeze", "torch.mul().sum", "tf.TMTF.b_T", "tf.TMTF.b_u().squeeze", "tf.TMTF.b_T", "torch.mul().sum().float", "tf.TMTF.b_i", "torch.mul", "tf.TMTF.b_u", "torch.mul().sum", "torch.mul"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "user", ",", "item", ",", "itemage", ")", ":", "\n", "        ", "user_e", "=", "self", ".", "user_embedding", "(", "user", ")", "\n", "item_e", "=", "self", ".", "item_embedding", "(", "item", ")", "\n", "time_e", "=", "self", ".", "time_embedding", "(", "itemage", ")", "\n", "if", "self", ".", "task", ".", "upper", "(", ")", "==", "'OIPT'", ":", "\n", "# # u_v * (i_v + T_v) + b_T", "\n", "            ", "uit_e", "=", "torch", ".", "mul", "(", "user_e", ",", "time_e", "+", "item_e", ")", ".", "sum", "(", "-", "1", ")", ".", "float", "(", ")", "+", "self", ".", "b_T", "(", "itemage", ")", ".", "squeeze", "(", ")", "\n", "", "else", ":", "\n", "# # u_v * (i_v + T_v) + b + b_i + b_u + b_T ", "\n", "            ", "uit_e", "=", "torch", ".", "mul", "(", "user_e", ",", "time_e", "+", "item_e", ")", ".", "sum", "(", "-", "1", ")", ".", "float", "(", ")", "+", "self", ".", "b", "+", "self", ".", "b_u", "(", "user", ")", ".", "squeeze", "(", ")", "+", "self", ".", "b_i", "(", "item", ")", ".", "squeeze", "(", ")", "+", "self", ".", "b_T", "(", "itemage", ")", ".", "squeeze", "(", ")", "\n", "# # u_v * i_v + u_v * T_v + i_v * T_v", "\n", "# uit_e = torch.mul(user_e, time_e + item_e).sum(-1).float() + torch.mul(item_e, time_e).sum(-1).float() + self.b_T(itemage).squeeze()", "\n", "# # v_i * (v_u + v_t) + b_T", "\n", "# uit_e = torch.mul(item_e, time_e + user_e).sum(-1).float() + self.b_T(itemage).squeeze()", "\n", "", "if", "self", ".", "m", "is", "None", ":", "\n", "            ", "return", "uit_e", "\n", "", "return", "self", ".", "m", "(", "uit_e", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF.__init__": [[12, 66], ["torch.nn.Module.__init__", "int", "int", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.parameter.Parameter", "torch.nn.Embedding", "tmf.TMF.apply", "tmf.TMF.log_info", "torch.Tensor", "tmf.TMF.loss_type.upper", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "tmf.TMF.loss_type.upper", "torch.nn.MSELoss", "tmf.TMF.loss_type.upper", "torch.nn.BCELoss", "torch.nn.Sigmoid", "NotImplementedError", "torch.nn.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF_variety.log_info"], ["def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ",", "output_dim", "=", "2", ")", ":", "\n", "        ", "super", "(", "TMF", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "task", "=", "config", "[", "'task'", "]", "\n", "# load parameter info", "\n", "self", ".", "debiasing", "=", "debiasing", "\n", "self", ".", "embedding_size", "=", "int", "(", "config", "[", "'embedding_size'", "]", ")", "\n", "self", ".", "loss_type", "=", "config", "[", "'loss_type'", "]", "\n", "# self.lr_decay_step = int(config['lr_decay_step'])", "\n", "self", ".", "batch_size", "=", "int", "(", "config", "[", "'batch_size'", "]", ")", "\n", "self", ".", "n_items", "=", "data", ".", "n_items", "\n", "self", ".", "n_periods", "=", "data", ".", "n_periods", "\n", "self", ".", "n_users", "=", "data", ".", "n_users", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "\n", "# define layers and loss", "\n", "self", ".", "user_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_users", ",", "self", ".", "embedding_size", ")", "\n", "self", ".", "item_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", ",", "self", ".", "embedding_size", ")", "\n", "# self.item_Dyn_embedding = nn.Embedding(self.n_items * self.n_periods, self.embedding_size)", "\n", "self", ".", "user_Dyn_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_users", "*", "self", ".", "n_periods", ",", "self", ".", "embedding_size", ")", "\n", "\n", "self", ".", "b_u", "=", "nn", ".", "Embedding", "(", "self", ".", "n_users", ",", "1", ")", "\n", "self", ".", "b_i", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", ",", "1", ")", "\n", "self", ".", "b", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "1", ")", ")", "\n", "self", ".", "global_T", "=", "nn", ".", "Embedding", "(", "self", ".", "n_periods", ",", "1", ")", "\n", "\n", "# self.item_Dyn_embedding = [] # [T N D]", "\n", "# for t in range(self.n_periods):", "\n", "#     self.item_Dyn_embedding.append(nn.Embedding(self.n_items, self.embedding_size))", "\n", "\n", "self", ".", "m", "=", "None", "\n", "reduction", "=", "'mean'", "\n", "if", "self", ".", "task", "==", "'OPPT'", ":", "\n", "            ", "reduction", "=", "'none'", "\n", "", "if", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'CE'", ":", "\n", "            ", "if", "self", ".", "debiasing", ":", "\n", "                ", "self", ".", "loss_fct", "=", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "'none'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "loss_fct", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "", "", "elif", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'MSE'", ":", "\n", "            ", "self", ".", "loss_fct", "=", "nn", ".", "MSELoss", "(", "reduction", "=", "reduction", ")", "\n", "", "elif", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'NLL'", ":", "\n", "# self.loss_fct = nn.NLLLoss(reduction='none')", "\n", "# self.loss_fct = nn.BCEWithLogitsLoss()", "\n", "            ", "self", ".", "loss_fct", "=", "nn", ".", "BCELoss", "(", "reduction", "=", "reduction", ")", "\n", "self", ".", "m", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "if", "self", ".", "output_dim", ">", "2", ":", "\n", "                ", "self", ".", "loss_fct", "==", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "reduction", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Make sure 'loss_type' in ['CE', 'MSE', 'NLL']!\"", ")", "\n", "\n", "# parameters initialization", "\n", "", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "self", ".", "log_info", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF.log_info": [[67, 70], ["print"], "methods", ["None"], ["", "def", "log_info", "(", "self", ")", ":", "\n", "# print(\"********* Using TMF: v_u * v_i_t + b + b_i + b_u + b_T **********\")", "\n", "        ", "print", "(", "\"********* Using TMF: v_u(t) * v_i + b + b_i + b_u + b_T **********\"", ")", "\n", "# print(\"********* Using TMF: v_u(t) * v_i + b_T **********\")", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF._init_weights": [[75, 86], ["isinstance", "torch.nn.init.xavier_normal_", "isinstance", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "isinstance", "torch.nn.init.xavier_normal_", "torch.nn.init.constant_", "isinstance", "torch.nn.init.constant_"], "methods", ["None"], ["", "def", "_init_weights", "(", "self", ",", "module", ")", ":", "\n", "        ", "if", "isinstance", "(", "module", ",", "nn", ".", "Embedding", ")", ":", "\n", "            ", "xavier_normal_", "(", "module", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "GRU", ")", ":", "\n", "            ", "xavier_uniform_", "(", "self", ".", "gru_layers", ".", "weight_hh_l0", ")", "\n", "xavier_uniform_", "(", "self", ".", "gru_layers", ".", "weight_ih_l0", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", ":", "\n", "            ", "xavier_normal_", "(", "module", ".", "weight", ")", "\n", "constant_", "(", "module", ".", "bias", ",", "0.0", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "Parameter", ")", ":", "\n", "            ", "constant_", "(", "module", ".", "weight", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF._gather_indexes": [[87, 92], ["gather_index.view().expand.view().expand.view().expand", "output.gather", "output.gather.squeeze", "gather_index.view().expand.view().expand.view"], "methods", ["None"], ["", "", "def", "_gather_indexes", "(", "self", ",", "output", ",", "gather_index", ")", ":", "\n", "        ", "\"\"\"Gathers the vectors at the spexific positions over a minibatch\"\"\"", "\n", "gather_index", "=", "gather_index", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "output", ".", "shape", "[", "-", "1", "]", ")", "\n", "output_tensor", "=", "output", ".", "gather", "(", "dim", "=", "1", ",", "index", "=", "gather_index", ")", "\n", "return", "output_tensor", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF.get_item_embedding": [[93, 96], ["tmf.TMF.item_Dyn_embedding"], "methods", ["None"], ["", "def", "get_item_embedding", "(", "self", ",", "item", ",", "itemage", ")", ":", "# [B], [B]", "\n", "        ", "idx", "=", "item", "*", "self", ".", "n_periods", "+", "itemage", "\n", "return", "self", ".", "item_Dyn_embedding", "(", "idx", ")", "\n", "# return self.item_embedding(item) + self.item_Dyn_embedding(idx)", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF.get_user_embedding": [[97, 100], ["tmf.TMF.user_Dyn_embedding"], "methods", ["None"], ["", "def", "get_user_embedding", "(", "self", ",", "user", ",", "itemage", ")", ":", "# [B], [B]", "\n", "        ", "idx", "=", "user", "*", "self", ".", "n_periods", "+", "itemage", "\n", "return", "self", ".", "user_Dyn_embedding", "(", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF.forward": [[101, 114], ["tmf.TMF.get_user_embedding", "tmf.TMF.item_embedding", "torch.mul().sum().float", "tmf.TMF.m", "tmf.TMF.b_i().squeeze", "torch.mul().sum", "tmf.TMF.b_u().squeeze", "tmf.TMF.global_T().squeeze", "tmf.TMF.b_i", "torch.mul", "tmf.TMF.b_u", "tmf.TMF.global_T"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF.get_user_embedding"], ["", "def", "forward", "(", "self", ",", "user", ",", "item", ",", "itemage", ")", ":", "\n", "        ", "user_e", "=", "self", ".", "get_user_embedding", "(", "user", ",", "itemage", ")", "# self.user_embedding(user)", "\n", "item_e", "=", "self", ".", "item_embedding", "(", "item", ")", "# self.get_item_embedding(item, itemage)", "\n", "# # v_u(t) * v_i + b_T", "\n", "output", "=", "torch", ".", "mul", "(", "user_e", ",", "item_e", ")", ".", "sum", "(", "-", "1", ")", ".", "float", "(", ")", "# [B, D] -> [B]", "\n", "# # v_u(t) * (v_i + v_T) + b_T", "\n", "# time_e = self.time_embedding(itemage)", "\n", "# output = torch.mul(user_e, item_e + time_e).sum(-1).float() # [B, D] -> [B]", "\n", "\n", "output", "+=", "self", ".", "global_T", "(", "itemage", ")", ".", "squeeze", "(", ")", "+", "self", ".", "b", "+", "self", ".", "b_u", "(", "user", ")", ".", "squeeze", "(", ")", "+", "self", ".", "b_i", "(", "item", ")", ".", "squeeze", "(", ")", "\n", "if", "self", ".", "m", "is", "None", ":", "\n", "            ", "return", "output", "\n", "", "return", "self", ".", "m", "(", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF.calculate_loss": [[115, 126], ["tmf.TMF.forward", "interaction[].float", "tmf.TMF.loss_fct"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "calculate_loss", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "pred", "=", "self", ".", "forward", "(", "user", ",", "item", ",", "itemage", ")", "\n", "target", "=", "interaction", "[", "'target'", "]", ".", "float", "(", ")", "\n", "loss", "=", "self", ".", "loss_fct", "(", "pred", ",", "target", ")", "\n", "# if self.debiasing:", "\n", "#     ctr = torch.reciprocal(interaction['ctr']) # [B]", "\n", "#     loss = torch.mul(loss, ctr).sum() # [B] -> [1]", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF.predict": [[127, 133], ["tmf.TMF.forward"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "predict", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "pred", "=", "self", ".", "forward", "(", "user", ",", "item", ",", "itemage", ")", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF.full_sort_predict": [[134, 141], ["test_items_emb.view.view.view", "torch.matmul", "torch.matmul.view", "tmf.TMF.item_embedding.weight.view", "tmf.TMF.item_Dyn_embedding.weight.view", "tmf.TMF.user_embedding", "test_items_emb.view.view.transpose"], "methods", ["None"], ["", "def", "full_sort_predict", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "test_items_emb", "=", "self", ".", "item_embedding", ".", "weight", ".", "view", "(", "self", ".", "n_items", ",", "1", ",", "self", ".", "embedding_size", ")", "+", "self", ".", "item_Dyn_embedding", ".", "weight", ".", "view", "(", "self", ".", "n_items", ",", "self", ".", "n_periods", ",", "self", ".", "embedding_size", ")", "# [N D] + [N T D] -> [N T D]", "\n", "test_items_emb", "=", "test_items_emb", ".", "view", "(", "self", ".", "n_items", "*", "self", ".", "n_periods", ",", "self", ".", "embedding_size", ")", "#[N*T D]", "\n", "scores", "=", "torch", ".", "matmul", "(", "self", ".", "user_embedding", "(", "user", ")", ",", "test_items_emb", ".", "transpose", "(", "0", ",", "1", ")", ")", "# [B D], [D N*T] -> [B N*T]", "\n", "return", "scores", ".", "view", "(", "-", "1", ",", "self", ".", "n_items", ",", "self", ".", "n_periods", ")", "# [B N T]", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF_variety.__init__": [[148, 159], ["tmf.TMF.__init__", "torch.nn.Embedding", "torch.nn.Embedding", "tmf.TMF_variety.apply", "tmf.TMF_variety.task.upper", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.parameter.Parameter", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ",", "output_dim", "=", "2", ")", ":", "\n", "        ", "super", "(", "TMF_variety", ",", "self", ")", ".", "__init__", "(", "config", ",", "data", ",", "debiasing", "=", "False", ",", "output_dim", "=", "2", ")", "\n", "self", ".", "item_Dyn_embedding", "=", "None", "\n", "self", ".", "time_embedding", "=", "None", "\n", "self", ".", "item_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", ",", "self", ".", "embedding_size", ")", "\n", "if", "self", ".", "task", ".", "upper", "(", ")", "==", "'OPPT'", ":", "\n", "            ", "self", ".", "b_u", "=", "nn", ".", "Embedding", "(", "self", ".", "n_users", ",", "1", ")", "\n", "self", ".", "b_i", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", ",", "1", ")", "\n", "self", ".", "b", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "1", ")", ")", "\n", "", "self", ".", "global_T", "=", "nn", ".", "Embedding", "(", "self", ".", "n_periods", ",", "1", ")", "\n", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF_variety.log_info": [[160, 165], ["tmf.TMF_variety.task.upper", "print", "print"], "methods", ["None"], ["", "def", "log_info", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "task", ".", "upper", "(", ")", "==", "'OIPT'", ":", "\n", "            ", "print", "(", "\"********* Using TMF-variety: (v_u * v_i) + b_T **********\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"********* Using TMF-variety: (v_u * v_i) + b + b_i + b_u + b_T **********\"", ")", "\n", "# print(\"********* Using TMF-variety: (v_u * v_i) + b + b_i + b_u **********\")", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF_variety.forward": [[169, 185], ["tmf.TMF_variety.user_embedding", "tmf.TMF_variety.item_embedding", "torch.mul().sum().float", "tmf.TMF_variety.m", "tmf.TMF_variety.task.upper", "torch.mul().sum", "tmf.TMF_variety.global_T().squeeze", "tmf.TMF_variety.global_T().squeeze", "tmf.TMF_variety.b_i().squeeze", "torch.mul", "tmf.TMF_variety.global_T", "tmf.TMF_variety.b_u().squeeze", "tmf.TMF_variety.global_T", "tmf.TMF_variety.b_i", "tmf.TMF_variety.b_u"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "user", ",", "item", ",", "itemage", ")", ":", "\n", "        ", "user_e", "=", "self", ".", "user_embedding", "(", "user", ")", "\n", "item_e", "=", "self", ".", "item_embedding", "(", "item", ")", "\n", "r_ui", "=", "torch", ".", "mul", "(", "user_e", ",", "item_e", ")", ".", "sum", "(", "-", "1", ")", ".", "float", "(", ")", "# [B D] -> [B]", "\n", "# # W * p1 * T + b", "\n", "# [B 1]", "\n", "# # p1 + b", "\n", "# f_uit = torch.mul(torch.mul(r_ui, itemage), self.w) # + self.b", "\n", "if", "self", ".", "task", ".", "upper", "(", ")", "==", "'OIPT'", ":", "\n", "            ", "f_uit", "=", "r_ui", "+", "self", ".", "global_T", "(", "itemage", ")", ".", "squeeze", "(", ")", "\n", "", "else", ":", "\n", "            ", "f_uit", "=", "r_ui", "+", "self", ".", "b", "+", "self", ".", "b_u", "(", "user", ")", ".", "squeeze", "(", ")", "+", "self", ".", "b_i", "(", "item", ")", ".", "squeeze", "(", ")", "+", "self", ".", "global_T", "(", "itemage", ")", ".", "squeeze", "(", ")", "\n", "\n", "", "if", "self", ".", "m", "is", "None", ":", "\n", "            ", "return", "f_uit", "\n", "", "return", "self", ".", "m", "(", "f_uit", ")", "# [B, D] -> [B]", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF_fast.__init__": [[192, 202], ["tmf.TMF.__init__", "print", "torch.nn.Linear", "tmf.TMF_fast.apply"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ",", "output_dim", "=", "2", ")", ":", "\n", "        ", "super", "(", "TMF_fast", ",", "self", ")", ".", "__init__", "(", "config", ",", "data", ",", "debiasing", "=", "False", ",", "output_dim", "=", "2", ")", "\n", "print", "(", "\"********* Using TMF-fast: W * (v_u * v_i) * T + b **********\"", ")", "\n", "\n", "# define layers and loss", "\n", "self", ".", "item_Dyn_embedding", "=", "None", "\n", "self", ".", "dense", "=", "nn", ".", "Linear", "(", "1", ",", "1", ")", "\n", "# # self.b = Parameter(torch.Tensor(1))", "\n", "# self.w = Parameter(torch.Tensor(1))", "\n", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF_fast.forward": [[203, 213], ["tmf.TMF_fast.user_embedding", "tmf.TMF_fast.item_embedding", "torch.mul().sum().float", "tmf.TMF_fast.dense().squeeze().float", "tmf.TMF_fast.m", "torch.mul().sum", "tmf.TMF_fast.dense().squeeze", "torch.mul", "tmf.TMF_fast.dense", "torch.mul().unsqueeze", "torch.mul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "user", ",", "item", ",", "itemage", ")", ":", "\n", "        ", "user_e", "=", "self", ".", "user_embedding", "(", "user", ")", "\n", "item_e", "=", "self", ".", "item_embedding", "(", "item", ")", "\n", "r_ui", "=", "torch", ".", "mul", "(", "user_e", ",", "item_e", ")", ".", "sum", "(", "-", "1", ")", ".", "float", "(", ")", "# [B D] -> [B]", "\n", "# # W * p1 * T + b", "\n", "f_uit", "=", "self", ".", "dense", "(", "torch", ".", "mul", "(", "r_ui", ",", "itemage", ")", ".", "unsqueeze", "(", "1", ")", ")", ".", "squeeze", "(", ")", ".", "float", "(", ")", "# [B 1]", "\n", "# # p1 + b", "\n", "# f_uit = torch.mul(torch.mul(r_ui, itemage), self.w) # + self.b", "\n", "f_uit", "=", "self", ".", "m", "(", "f_uit", ")", "\n", "return", "f_uit", "# [B, D] -> [B]", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF_fast_variety.__init__": [[221, 278], ["tmf.TMF.__init__", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "print", "tmf.TMF_fast_variety.apply"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ")", ":", "\n", "        ", "super", "(", "TMF_fast_variety", ",", "self", ")", ".", "__init__", "(", "config", ",", "data", ",", "debiasing", ")", "\n", "# del useless params", "\n", "self", ".", "user_embedding", ",", "self", ".", "item_embedding", "=", "None", ",", "None", "\n", "self", ".", "item_Dyn_embedding", "=", "None", "\n", "self", ".", "dense", "=", "None", "\n", "# self.dense = nn.Linear(1, 1)", "\n", "# self.dense = nn.Linear(2, 1)", "\n", "# self.W1 = Parameter(torch.Tensor(1))", "\n", "# self.W2 = Parameter(torch.Tensor(1))", "\n", "# self.b = Parameter(torch.Tensor(1))", "\n", "\n", "# define layers and loss", "\n", "# self.n_factors = 2", "\n", "# if self.n_factors == 2:", "\n", "#     # print(\"TMF_fast_variety2: sigmoid(p1 * T1 + p2)\")", "\n", "#     # print(\"TMF_fast_variety2': sigmoid(W1 * p1 * T1 + W2 * p2 + b)\")", "\n", "#     print(\"...\")", "\n", "# else:", "\n", "#     raise NotImplementedError(\"Make sure 'n_factors' in [2]!\")", "\n", "\n", "self", ".", "n_factors", "=", "1", "\n", "self", ".", "user_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_users", "*", "self", ".", "n_factors", ",", "self", ".", "embedding_size", ")", "\n", "self", ".", "item_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", "*", "self", ".", "n_factors", ",", "self", ".", "embedding_size", ")", "\n", "# self.b_u = nn.Embedding(self.n_users, 1)", "\n", "# self.b_i = nn.Embedding(self.n_items, 1)", "\n", "# self.global_T = nn.Embedding(self.n_periods, 1)", "\n", "# self.b = Parameter(torch.Tensor(self.n_factors))", "\n", "\n", "# # self.a_i = nn.Embedding(self.n_items, 1)", "\n", "# self.a_u = nn.Embedding(self.n_users, 1)", "\n", "self", ".", "s_T", "=", "nn", ".", "Embedding", "(", "self", ".", "n_periods", ",", "1", ")", "\n", "\n", "\n", "# d_p2 = 2", "\n", "# self.user_embedding2 = nn.Embedding(self.n_users, d_p2)", "\n", "# self.item_embedding2 = nn.Embedding(self.n_items, d_p2)", "\n", "# self.b2 = Parameter(torch.Tensor(1))", "\n", "# self.itemage_embedding  = nn.Embedding(self.n_periods, 1)", "\n", "# # self.itemage_embedding = nn.Embedding(self.n_periods, self.embedding_size)", "\n", "\n", "# self.item_embedding_ = nn.Embedding(self.n_items, self.embedding_size)", "\n", "\n", "# # NLL using BinaryCrossEntropy with sigmoid", "\n", "# # self.loss_fct = nn.BCEWithLogitsLoss()", "\n", "# # Then we want to try different models.", "\n", "# self.loss_fct = nn.BCELoss()", "\n", "# self.m = nn.Tanh()", "\n", "# self.m = nn.Sigmoid()", "\n", "# print(\"-*-*-*-* We use p_T = s_T *-*-*-*-\")", "\n", "# print(\"-*-*-*-* We use p_T = sigmoid(s_T) *-*-*-*-\")", "\n", "# print(\"-*-*-*-* We use p_T = sigmoid(W*T+b) *-*-*-*-\")", "\n", "print", "(", "\"-*-*-*-* We use p_T = sigmoid(p1 * s_T) *-*-*-*-\"", ")", "\n", "# # for OPPT task", "\n", "# print(\"-*-*-*-* We use s_\\{uit\\} = p1 + (v_i * v_T) *-*-*-*-\")", "\n", "# print(\"-*-*-*-* We use s_{uit} = p_ui + b_T + a_u * s_T *-*-*-*-\")", "\n", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.tmf.TMF_fast_variety.forward": [[279, 319], ["range", "torch.mul", "prob_scores.append", "tmf.TMF_fast_variety.s_T().squeeze().float", "tmf.TMF_fast_variety.m", "torch.mul().sum().float", "tmf.TMF_fast_variety.s_T().squeeze", "torch.mul().sum", "tmf.TMF_fast_variety.s_T", "torch.mul", "tmf.TMF_fast_variety.user_embedding", "tmf.TMF_fast_variety.item_embedding"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "user", ",", "item", ",", "itemage", ")", ":", "\n", "# user_e = self.user_embedding(user)", "\n", "# item_e = self.item_embedding(item)", "\n", "# output = torch.mul(user_e, item_e).sum(-1).float() # [B, D] -> [B]", "\n", "\n", "        ", "prob_scores", "=", "[", "]", "# s1, s2, ...", "\n", "for", "i", "in", "range", "(", "self", ".", "n_factors", ")", ":", "\n", "            ", "prob_scores", ".", "append", "(", "torch", ".", "mul", "(", "self", ".", "user_embedding", "(", "self", ".", "n_users", "*", "i", "+", "user", ")", ",", "self", ".", "item_embedding", "(", "self", ".", "n_items", "*", "i", "+", "item", ")", ")", ".", "sum", "(", "-", "1", ")", ".", "float", "(", ")", ")", "#  + self.b[i]) # [B]", "\n", "\n", "# # p1 + p2^{d=1} * T", "\n", "# p2 = torch.mul(self.user_embedding2(user), self.item_embedding2(item)).sum(-1).float() + self.b2", "\n", "# output = (torch.mul(p2, self.itemage_embedding(itemage).squeeze().float()) \\", "\n", "#  + prob_scores[0]).squeeze().float() + self.global_T(itemage).squeeze()", "\n", "# # p_ui + b_T + a_u * s_T, where p_ui = v_u * v_i + b + b_u + b_i", "\n", "# p_ui = prob_scores[0] + self.b_u(user).squeeze() + self.b_i(item).squeeze()", "\n", "# output = p_ui + self.global_T(itemage).squeeze() + torch.mul(self.a_u(user), self.s_T(itemage)).squeeze()", "\n", "# output = p_ui + self.global_T(itemage).squeeze() + torch.mul(self.a_u(user).squeeze(), itemage).squeeze()", "\n", "# # p1 * T1 + p2", "\n", "# output = (torch.mul(prob_scores[1], itemage) + prob_scores[0]).squeeze().float()", "\n", "# # p1 * s_T + p2", "\n", "# output = (torch.mul(prob_scores[0], self.itemage_embedding(itemage).squeeze().float()) + prob_scores[1]).squeeze().float()", "\n", "# # p1 + v_i * v_T", "\n", "# output = prob_scores[0] + torch.mul(self.itemage_embedding(itemage), self.item_embedding_(item)).sum(-1).float()", "\n", "# # W1 * p1 * T1 + W2 * p2 + b", "\n", "# p1 = torch.mul(prob_scores[0], itemage).unsqueeze(1)", "\n", "# p2 = prob_scores[1].unsqueeze(1)", "\n", "# output = self.dense(torch.cat((p1, p2), 1)).squeeze().float()", "\n", "# output = (self.W1 * torch.mul(prob_scores[0], itemage) + self.W2 * prob_scores[1] + self.b).squeeze().float()", "\n", "# # sigmoid(P1 * s_T)", "\n", "", "output", "=", "torch", ".", "mul", "(", "prob_scores", "[", "0", "]", ",", "self", ".", "s_T", "(", "itemage", ")", ".", "squeeze", "(", ")", ".", "float", "(", ")", ")", "\n", "if", "self", ".", "m", "is", "not", "None", ":", "\n", "            ", "output", "=", "self", ".", "m", "(", "output", ")", "\n", "# # W * T + b", "\n", "# output = self.dense(itemage.float().unsqueeze(1)).squeeze().float()", "\n", "# # s_T ", "\n", "# output = self.s_T(itemage).squeeze()", "\n", "# output = self.m(output)", "\n", "# output = torch.clamp(output, min=0.000001, max=0.999999) # clip to make prob between 0 and 1", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF.__init__": [[12, 54], ["torch.nn.Module.__init__", "int", "int", "torch.nn.Embedding", "torch.nn.Embedding", "mf.MF.apply", "mf.MF.loss_type.upper", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "mf.MF.loss_type.upper", "torch.nn.MSELoss", "mf.MF.loss_type.upper", "torch.nn.BCELoss", "torch.nn.Sigmoid", "NotImplementedError", "torch.nn.Softmax", "torch.nn.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ",", "output_dim", "=", "2", ")", ":", "\n", "        ", "super", "(", "MF", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "task", "=", "config", "[", "'task'", "]", "\n", "# load parameter info", "\n", "self", ".", "debiasing", "=", "debiasing", "\n", "self", ".", "embedding_size", "=", "int", "(", "config", "[", "'embedding_size'", "]", ")", "\n", "self", ".", "loss_type", "=", "config", "[", "'loss_type'", "]", "\n", "# self.lr_decay_step = int(config['lr_decay_step'])", "\n", "self", ".", "batch_size", "=", "int", "(", "config", "[", "'batch_size'", "]", ")", "\n", "self", ".", "n_items", "=", "data", ".", "n_items", "\n", "self", ".", "n_users", "=", "data", ".", "n_users", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "\n", "# define layers and loss", "\n", "self", ".", "user_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_users", ",", "self", ".", "embedding_size", ")", "\n", "self", ".", "item_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", ",", "self", ".", "embedding_size", ")", "\n", "\n", "self", ".", "m", "=", "None", "\n", "reduction", "=", "'mean'", "\n", "if", "self", ".", "task", "==", "'OPPT'", ":", "\n", "            ", "reduction", "=", "'none'", "\n", "", "if", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'CE'", ":", "\n", "            ", "if", "self", ".", "debiasing", ":", "\n", "                ", "self", ".", "loss_fct", "=", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "'none'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "loss_fct", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "", "", "elif", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'MSE'", ":", "\n", "            ", "self", ".", "loss_fct", "=", "nn", ".", "MSELoss", "(", "reduction", "=", "reduction", ")", "\n", "", "elif", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'NLL'", ":", "\n", "# self.loss_fct = nn.NLLLoss(reduction='none')", "\n", "# self.loss_fct = nn.BCEWithLogitsLoss()", "\n", "            ", "self", ".", "loss_fct", "=", "nn", ".", "BCELoss", "(", "reduction", "=", "reduction", ")", "\n", "self", ".", "m", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "if", "self", ".", "output_dim", ">", "2", ":", "\n", "                ", "self", ".", "loss_fct", "==", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "reduction", ")", "\n", "self", ".", "m", "=", "nn", ".", "Softmax", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Make sure 'loss_type' in ['CE', 'MSE', 'NLL']!\"", ")", "\n", "\n", "# parameters initialization", "\n", "", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF._init_weights": [[55, 66], ["isinstance", "torch.nn.init.xavier_normal_", "isinstance", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "isinstance", "torch.nn.init.xavier_normal_", "constant_", "isinstance", "constant_"], "methods", ["None"], ["", "def", "_init_weights", "(", "self", ",", "module", ")", ":", "\n", "        ", "if", "isinstance", "(", "module", ",", "nn", ".", "Embedding", ")", ":", "\n", "            ", "xavier_normal_", "(", "module", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "GRU", ")", ":", "\n", "            ", "xavier_uniform_", "(", "self", ".", "gru_layers", ".", "weight_hh_l0", ")", "\n", "xavier_uniform_", "(", "self", ".", "gru_layers", ".", "weight_ih_l0", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", ":", "\n", "            ", "xavier_normal_", "(", "module", ".", "weight", ")", "\n", "constant_", "(", "module", ".", "bias", ",", "0.0", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "Parameter", ")", ":", "\n", "            ", "constant_", "(", "module", ".", "weight", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF._gather_indexes": [[67, 72], ["gather_index.view().expand.view().expand.view().expand", "output.gather", "output.gather.squeeze", "gather_index.view().expand.view().expand.view"], "methods", ["None"], ["", "", "def", "_gather_indexes", "(", "self", ",", "output", ",", "gather_index", ")", ":", "\n", "        ", "\"\"\"Gathers the vectors at the spexific positions over a minibatch\"\"\"", "\n", "gather_index", "=", "gather_index", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "output", ".", "shape", "[", "-", "1", "]", ")", "\n", "output_tensor", "=", "output", ".", "gather", "(", "dim", "=", "1", ",", "index", "=", "gather_index", ")", "\n", "return", "output_tensor", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF.forward": [[73, 84], ["mf.MF.user_embedding", "mf.MF.item_embedding", "torch.mul().sum().float", "mf.MF.m", "torch.mul().sum", "torch.mul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "user", ",", "item", ")", ":", "\n", "        ", "user_e", "=", "self", ".", "user_embedding", "(", "user", ")", "\n", "item_e", "=", "self", ".", "item_embedding", "(", "item", ")", "\n", "# if self.loss_type.upper() == 'NLL':", "\n", "#     scores = torch.mul(user_e, item_e).sum(-1).float() # [B, D] -> [B]", "\n", "#     scores = torch.sigmoid(scores).unsqueeze(-1) #[B 1] for obser", "\n", "#     return torch.cat((1.0 - scores, scores), -1) # [B, 2]", "\n", "output", "=", "torch", ".", "mul", "(", "user_e", ",", "item_e", ")", ".", "sum", "(", "-", "1", ")", ".", "float", "(", ")", "# [B, D] -> [B]", "\n", "if", "self", ".", "m", "is", "None", ":", "\n", "            ", "return", "output", "\n", "", "return", "self", ".", "m", "(", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF.calculate_loss": [[86, 96], ["mf.MF.forward", "interaction[].float", "mf.MF.loss_fct"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "calculate_loss", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "pred", "=", "self", ".", "forward", "(", "user", ",", "item", ")", "\n", "target", "=", "interaction", "[", "'target'", "]", ".", "float", "(", ")", "\n", "loss", "=", "self", ".", "loss_fct", "(", "pred", ",", "target", ")", "\n", "# if self.debiasing:", "\n", "#     ctr = torch.reciprocal(interaction['ctr']) # [B]", "\n", "#     loss = torch.mul(loss, ctr).sum() # [B] -> [1]", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF.predict": [[97, 102], ["mf.MF.forward"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "predict", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "pred", "=", "self", ".", "forward", "(", "user", ",", "item", ")", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF.full_sort_predict": [[103, 108], ["mf.MF.item_embedding.weight.view", "torch.matmul", "mf.MF.user_embedding", "mf.MF.transpose"], "methods", ["None"], ["", "def", "full_sort_predict", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "test_items_emb", "=", "self", ".", "item_embedding", ".", "weight", ".", "view", "(", "self", ".", "n_items", ",", "1", ",", "self", ".", "embedding_size", ")", "# [N D]", "\n", "scores", "=", "torch", ".", "matmul", "(", "self", ".", "user_embedding", "(", "user", ")", ",", "test_items_emb", ".", "transpose", "(", "0", ",", "1", ")", ")", "# [B D], [D N] -> [B N]", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF_dnn.__init__": [[110, 114], ["mf.MF.__init__", "torch.nn.parameter.Parameter", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ")", ":", "\n", "        ", "super", "(", "MF_dnn", ",", "self", ")", ".", "__init__", "(", "config", ",", "data", ",", "debiasing", ")", "\n", "# self.dense = nn.Linear(1, 1)", "\n", "self", ".", "b", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "1", ")", ")", "\n", "# self.w = Parameter(torch.Tensor(1))", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF_v.__init__": [[118, 127], ["mf.MF.__init__", "torch.nn.parameter.Parameter", "torch.nn.Embedding", "torch.nn.Embedding", "mf.MF_v.apply", "print", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ")", ":", "\n", "        ", "super", "(", "MF_v", ",", "self", ")", ".", "__init__", "(", "config", ",", "data", ",", "debiasing", ")", "\n", "# self.dense = nn.Linear(1, 1)", "\n", "self", ".", "b", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "1", ")", ")", "\n", "self", ".", "b_u", "=", "nn", ".", "Embedding", "(", "self", ".", "n_users", ",", "1", ")", "\n", "self", ".", "b_i", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", ",", "1", ")", "\n", "# self.w = Parameter(torch.Tensor(1))", "\n", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "print", "(", "'-*-*-*-* We use s_{uit} = v_u * v_i + b + b_u + b_i *-*-*-*-'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.mf.MF_v.forward": [[128, 141], ["mf.MF_v.user_embedding", "mf.MF_v.item_embedding", "torch.mul().sum().float", "mf.MF_v.b_i().squeeze", "mf.MF_v.m", "torch.mul().sum", "mf.MF_v.b_u().squeeze", "mf.MF_v.b_i", "torch.mul", "mf.MF_v.b_u"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "user", ",", "item", ")", ":", "\n", "        ", "user_e", "=", "self", ".", "user_embedding", "(", "user", ")", "\n", "item_e", "=", "self", ".", "item_embedding", "(", "item", ")", "\n", "r_ui", "=", "torch", ".", "mul", "(", "user_e", ",", "item_e", ")", ".", "sum", "(", "-", "1", ")", ".", "float", "(", ")", "# [B, D] -> [B]", "\n", "# # W * v_u * v_i + b", "\n", "# f_uit = self.dense(r_ui.unsqueeze(1)).squeeze().float() # [B]", "\n", "# # v_u * v_i + b", "\n", "# f_uit = r_ui + self.b", "\n", "# # v_u * v_i + b_u + b_i + b", "\n", "f_uit", "=", "r_ui", "+", "self", ".", "b", "+", "self", ".", "b_u", "(", "user", ")", ".", "squeeze", "(", ")", "+", "self", ".", "b_i", "(", "item", ")", ".", "squeeze", "(", ")", "\n", "if", "self", ".", "m", "is", "not", "None", ":", "\n", "            ", "return", "self", ".", "m", "(", "f_uit", ")", "\n", "", "return", "f_uit", "", "", "", ""]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.__init__": [[6, 42], ["torch.nn.Module.__init__", "int", "int", "int", "int", "float", "torch.nn.Embedding", "torch.nn.Dropout", "torch.nn.GRU", "torch.nn.Linear", "gru4rec.GRU4Rec.apply", "gru4rec.GRU4Rec.loss_type.upper", "NotImplementedError", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "data", ",", "debiasing", "=", "False", ")", ":", "\n", "        ", "super", "(", "GRU4Rec", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# load parameter info", "\n", "self", ".", "debiasing", "=", "debiasing", "\n", "self", ".", "embedding_size", "=", "int", "(", "config", "[", "'embedding_size'", "]", ")", "\n", "self", ".", "hidden_size", "=", "int", "(", "config", "[", "'hidden_size'", "]", ")", "\n", "self", ".", "loss_type", "=", "config", "[", "'loss_type'", "]", "\n", "# self.lr_decay_step = int(config['lr_decay_step'])", "\n", "self", ".", "batch_size", "=", "int", "(", "config", "[", "'batch_size'", "]", ")", "\n", "self", ".", "num_layers", "=", "int", "(", "config", "[", "'num_layers'", "]", ")", "\n", "self", ".", "n_items", "=", "data", ".", "n_items", "# one for padding", "\n", "self", ".", "dropout_prob", "=", "float", "(", "config", "[", "'dropout_prob'", "]", ")", "\n", "\n", "# define layers and loss", "\n", "self", ".", "item_embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "n_items", "+", "1", ",", "self", ".", "embedding_size", ",", "padding_idx", "=", "self", ".", "n_items", ")", "\n", "\n", "self", ".", "emb_dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_prob", ")", "\n", "self", ".", "gru_layers", "=", "nn", ".", "GRU", "(", "\n", "input_size", "=", "self", ".", "embedding_size", ",", "\n", "hidden_size", "=", "self", ".", "hidden_size", ",", "\n", "num_layers", "=", "self", ".", "num_layers", ",", "\n", "bias", "=", "False", ",", "\n", "batch_first", "=", "True", ",", "\n", ")", "\n", "self", ".", "dense", "=", "nn", ".", "Linear", "(", "self", ".", "hidden_size", ",", "self", ".", "embedding_size", ")", "\n", "if", "self", ".", "loss_type", ".", "upper", "(", ")", "==", "'CE'", ":", "\n", "            ", "if", "self", ".", "debiasing", ":", "\n", "                ", "self", ".", "loss_fct", "=", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "'none'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "loss_fct", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Make sure 'loss_type' in ['CE']!\"", ")", "\n", "\n", "# parameters initialization", "\n", "", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec._init_weights": [[43, 49], ["isinstance", "torch.nn.init.xavier_normal_", "isinstance", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "_init_weights", "(", "self", ",", "module", ")", ":", "\n", "        ", "if", "isinstance", "(", "module", ",", "nn", ".", "Embedding", ")", ":", "\n", "            ", "xavier_normal_", "(", "module", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "GRU", ")", ":", "\n", "            ", "xavier_uniform_", "(", "self", ".", "gru_layers", ".", "weight_hh_l0", ")", "\n", "xavier_uniform_", "(", "self", ".", "gru_layers", ".", "weight_ih_l0", ")", "\n", "# elif isinstance(module, nn.Linear):", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec._gather_indexes": [[52, 57], ["gather_index.view().expand.view().expand.view().expand", "output.gather", "output.gather.squeeze", "gather_index.view().expand.view().expand.view"], "methods", ["None"], ["", "", "def", "_gather_indexes", "(", "self", ",", "output", ",", "gather_index", ")", ":", "\n", "        ", "\"\"\"Gathers the vectors at the spexific positions over a minibatch\"\"\"", "\n", "gather_index", "=", "gather_index", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "output", ".", "shape", "[", "-", "1", "]", ")", "\n", "output_tensor", "=", "output", ".", "gather", "(", "dim", "=", "1", ",", "index", "=", "gather_index", ")", "\n", "return", "output_tensor", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward": [[58, 68], ["gru4rec.GRU4Rec.item_embedding", "gru4rec.GRU4Rec.emb_dropout", "gru4rec.GRU4Rec.gru_layers", "gru4rec.GRU4Rec.dense", "gru4rec.GRU4Rec._gather_indexes"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec._gather_indexes"], ["", "def", "forward", "(", "self", ",", "item_seq", ",", "item_seq_len", ")", ":", "\n", "# if (item_seq >= self.n_items).sum()>0:", "\n", "#     print(item_seq[item_seq >= self.n_items], self.n_items)", "\n", "        ", "item_seq_emb", "=", "self", ".", "item_embedding", "(", "item_seq", ")", "\n", "item_seq_emb_dropout", "=", "self", ".", "emb_dropout", "(", "item_seq_emb", ")", "\n", "gru_output", ",", "_", "=", "self", ".", "gru_layers", "(", "item_seq_emb_dropout", ")", "\n", "gru_output", "=", "self", ".", "dense", "(", "gru_output", ")", "\n", "# the embedding of the predicted item, shape of (batch_size, embedding_size)", "\n", "seq_output", "=", "self", ".", "_gather_indexes", "(", "gru_output", ",", "item_seq_len", "-", "1", ")", "\n", "return", "seq_output", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss": [[69, 82], ["gru4rec.GRU4Rec.forward", "torch.matmul", "gru4rec.GRU4Rec.loss_fct", "test_item_emb.transpose", "torch.reciprocal", "torch.mul().sum", "torch.mul"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "calculate_loss", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "item_seq", "=", "interaction", "[", "'seq'", "]", "\n", "item_seq_len", "=", "interaction", "[", "'seq_len'", "]", "\n", "seq_output", "=", "self", ".", "forward", "(", "item_seq", ",", "item_seq_len", ")", "\n", "pos_items", "=", "interaction", "[", "'target'", "]", "\n", "# self.loss_type = 'CE'", "\n", "test_item_emb", "=", "self", ".", "item_embedding", ".", "weight", "\n", "logits", "=", "torch", ".", "matmul", "(", "seq_output", ",", "test_item_emb", ".", "transpose", "(", "0", ",", "1", ")", ")", "\n", "loss", "=", "self", ".", "loss_fct", "(", "logits", ",", "pos_items", ")", "\n", "if", "self", ".", "debiasing", ":", "\n", "            ", "ctr", "=", "torch", ".", "reciprocal", "(", "interaction", "[", "'ctr'", "]", ")", "# [B]", "\n", "loss", "=", "torch", ".", "mul", "(", "loss", ",", "ctr", ")", ".", "sum", "(", ")", "# [B] -> [1]", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.predict": [[83, 91], ["gru4rec.GRU4Rec.forward", "gru4rec.GRU4Rec.item_embedding", "torch.mul().sum", "torch.mul"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "predict", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "item_seq", "=", "interaction", "[", "'seq'", "]", "\n", "item_seq_len", "=", "interaction", "[", "'seq_len'", "]", "\n", "test_item", "=", "interaction", "[", "'target'", "]", "\n", "seq_output", "=", "self", ".", "forward", "(", "item_seq", ",", "item_seq_len", ")", "\n", "test_item_emb", "=", "self", ".", "item_embedding", "(", "test_item", ")", "\n", "scores", "=", "torch", ".", "mul", "(", "seq_output", ",", "test_item_emb", ")", ".", "sum", "(", "dim", "=", "1", ")", "# [B]", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.full_sort_predict": [[92, 99], ["gru4rec.GRU4Rec.forward", "torch.matmul", "test_items_emb.transpose"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "full_sort_predict", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "item_seq", "=", "interaction", "[", "'seq'", "]", "\n", "item_seq_len", "=", "interaction", "[", "'seq_len'", "]", "\n", "seq_output", "=", "self", ".", "forward", "(", "item_seq", ",", "item_seq_len", ")", "\n", "test_items_emb", "=", "self", ".", "item_embedding", ".", "weight", "\n", "scores", "=", "torch", ".", "matmul", "(", "seq_output", ",", "test_items_emb", ".", "transpose", "(", "0", ",", "1", ")", ")", "# [B, n_items]", "\n", "return", "scores", "", "", "", ""]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.__init__": [[6, 118], ["config[].lower", "data.Dataset._load_ratings", "data.Dataset._load_ratings", "data.Dataset._get_item_birthdate", "data.Dataset.get_itemage", "len", "data.Dataset.test.drop", "print", "data.Dataset.get_itemage", "print", "task.upper", "data.Dataset._load_ratings", "data.Dataset._load_ratings", "data.Dataset._load_ratings", "numpy.copy", "len", "print", "print", "int", "data.Dataset.resplitting_random_OIPT", "print", "data.Dataset.resplitting_random", "data.Dataset.merge_predOP", "data.Dataset.merge_predOP", "data.Dataset.merge_predOP", "print", "max", "max", "min", "data.Dataset.interation_data_time_OIPT", "task.upper", "task.upper", "max", "max", "max", "data.Dataset.estimated_predOP_replace", "data.Dataset.years2bins", "data.Dataset.years2bins", "data.Dataset.years2bins", "max", "max", "max", "max", "data.Dataset.test[].isin", "len", "data.Dataset.train[].unique", "len", "config[].lower", "len", "data.Dataset.test[].isin", "data.Dataset.train_full[].unique"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._get_item_birthdate", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.resplitting_random_OIPT", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.resplitting_random", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.merge_predOP", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.merge_predOP", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.merge_predOP", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.interation_data_time_OIPT", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.estimated_predOP_replace", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.years2bins", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.years2bins", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.years2bins"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "task", "=", "'OIPT'", ")", ":", "\n", "# np.random.seed(2021)", "\n", "        ", "path", "=", "config", "[", "'data.input.path'", "]", "\n", "dataset", "=", "config", "[", "'data.input.dataset'", "]", "\n", "self", ".", "path", "=", "path", "\n", "self", ".", "dataset", "=", "dataset", "\n", "assert", "(", "task", ".", "upper", "(", ")", "!=", "'TART'", ")", "or", "(", "dataset", "in", "[", "'simulation'", ",", "'simulation2'", ",", "'simulation3'", ",", "'fully-synthetic'", "]", ")", "# make sure when the task is TART, we use simulated dataset", "\n", "assert", "(", "task", ".", "upper", "(", ")", "==", "'TART'", ")", "or", "(", "dataset", "not", "in", "[", "'simulation'", ",", "'simulation2'", ",", "'simulation3'", ",", "'fully-synthetic'", "]", ")", "# make sure simulated dataset be used only when task is TART", "\n", "\n", "# # load data", "\n", "if", "task", ".", "upper", "(", ")", "==", "'TART'", ":", "\n", "# train columns: [UserId,ItemId,itemage,rating,predOP]", "\n", "            ", "self", ".", "train", "=", "self", ".", "_load_ratings", "(", "path", "+", "dataset", "+", "'/train.csv'", ")", "\n", "self", ".", "valid", "=", "self", ".", "_load_ratings", "(", "path", "+", "dataset", "+", "'/valid.csv'", ")", "\n", "# test columns: [UserId,ItemId,rating,itemage]", "\n", "self", ".", "test", "=", "self", ".", "_load_ratings", "(", "path", "+", "dataset", "+", "'/test.csv'", ")", "\n", "self", ".", "test", "[", "'itemage_copy'", "]", "=", "np", ".", "copy", "(", "self", ".", "test", "[", "'itemage'", "]", ".", "values", ")", "# for getting the original itemage", "\n", "self", ".", "n_users", "=", "max", "(", "self", ".", "train", "[", "'UserId'", "]", ")", "+", "1", "#max(max(self.train['UserId']), max(self.valid['UserId']))", "\n", "self", ".", "n_items", "=", "max", "(", "self", ".", "train", "[", "'ItemId'", "]", ")", "+", "1", "#max(max(self.train['ItemId']), max(self.valid['ItemId']))", "\n", "self", ".", "n_periods", "=", "max", "(", "max", "(", "self", ".", "train", "[", "'itemage'", "]", ")", ",", "max", "(", "self", ".", "valid", "[", "'itemage'", "]", ")", ",", "max", "(", "self", ".", "test", "[", "'itemage'", "]", ")", ")", "+", "1", "\n", "\n", "''' use estimated propensities / predOP '''", "\n", "if", "(", "'StaticIPS'", "in", "config", ")", "and", "(", "config", "[", "'StaticIPS'", "]", ")", ":", "\n", "                ", "self", ".", "estimated_predOP_replace", "(", "mode", "=", "'b2_i'", ",", "static", "=", "False", ")", "\n", "# self.estimated_predOP_replace(mode='b3', static=False)", "\n", "# self.estimated_predOP_replace(mode='b4', static=False)", "\n", "# self.estimated_predOP_replace(mode='mf', static=False)", "\n", "# self.estimated_predOP_replace(mode='tmtf', static=False)", "\n", "\n", "# map the itemage into the bins:", "\n", "", "if", "'simulation'", "in", "dataset", ":", "\n", "                ", "self", ".", "train", "[", "'itemage'", "]", ",", "_", "=", "self", ".", "years2bins", "(", "self", ".", "train", "[", "'itemage'", "]", ")", "\n", "self", ".", "valid", "[", "'itemage'", "]", ",", "_", "=", "self", ".", "years2bins", "(", "self", ".", "valid", "[", "'itemage'", "]", ")", "\n", "self", ".", "test", "[", "'itemage'", "]", ",", "n_bins", "=", "self", ".", "years2bins", "(", "self", ".", "test", "[", "'itemage'", "]", ")", "\n", "self", ".", "n_periods", "=", "n_bins", "\n", "# print(self.train['itemage'].values[800:850])", "\n", "# del items in test but not in train", "\n", "", "n_test", "=", "len", "(", "self", ".", "test", ")", "\n", "self", ".", "test", "=", "self", ".", "test", "[", "self", ".", "test", "[", "'ItemId'", "]", ".", "isin", "(", "self", ".", "train", "[", "'ItemId'", "]", ".", "unique", "(", ")", ")", "]", "\n", "print", "(", "\"Simulated test: %d interactions whose items do not appear in the training set. And thus Nr. testset is %d.\"", "%", "(", "n_test", "-", "len", "(", "self", ".", "test", ")", ",", "len", "(", "self", ".", "test", ")", ")", ")", "\n", "print", "(", "\"(#users : %d, #items : %d, period_type : %s, n_periods : %d)\"", "%", "(", "self", ".", "n_users", ",", "self", ".", "n_items", ",", "config", "[", "'data.itemage.type'", "]", ".", "lower", "(", ")", ",", "self", ".", "n_periods", ")", ")", "\n", "return", "\n", "\n", "", "self", ".", "task", "=", "task", "\n", "# set the period info", "\n", "self", ".", "period_type", "=", "config", "[", "'data.itemage.type'", "]", ".", "lower", "(", ")", "\n", "if", "'data.itemage.max'", "in", "config", ":", "\n", "            ", "self", ".", "n_periods", "=", "int", "(", "config", "[", "'data.itemage.max'", "]", ")", "\n", "", "if", "self", ".", "period_type", "==", "'year'", ":", "\n", "            ", "if", "'data.itemage.max'", "not", "in", "config", ":", "\n", "                ", "self", ".", "n_periods", "=", "20", "\n", "", "", "elif", "self", ".", "period_type", "==", "'month'", ":", "\n", "            ", "if", "'data.itemage.max'", "not", "in", "config", ":", "\n", "                ", "self", ".", "n_periods", "=", "36", "\n", "\n", "# self.train_full = self._load_ratings(path + dataset + '/train.csv')", "\n", "# self.test = self._load_ratings(path + dataset + '/test.csv')", "\n", "\n", "# OIPT, do random splitting", "\n", "", "", "if", "(", "task", "==", "'OIPT'", ")", "and", "(", "config", "[", "'splitting'", "]", "==", "'random'", ")", ":", "\n", "            ", "self", ".", "resplitting_random_OIPT", "(", ")", "\n", "# self.resplitting_random_OIPT3(ratio=0.1)", "\n", "print", "(", "\"(#users : %d, #items : %d, period_type : %s, n_periods : %d)\"", "%", "(", "self", ".", "n_users", ",", "self", ".", "n_items", ",", "self", ".", "period_type", ",", "self", ".", "n_periods", ")", ")", "\n", "return", "\n", "\n", "", "self", ".", "train_full", "=", "self", ".", "_load_ratings", "(", "path", "+", "dataset", "+", "'/train.csv'", ")", "\n", "self", ".", "test", "=", "self", ".", "_load_ratings", "(", "path", "+", "dataset", "+", "'/test.csv'", ")", "\n", "\n", "# self._get_item_birthdate() # put it here to generate ./data/simulation/item_birthdate.csv", "\n", "# # for task OPPT, we do randomly training-test splitting", "\n", "if", "task", "==", "'OPPT'", ":", "\n", "            ", "self", ".", "resplitting_random", "(", ")", "\n", "\n", "# # add the predicted p(o) for task 2", "\n", "", "if", "(", "task", "==", "'OPPT'", ")", "and", "config", "[", "'debiasing'", "]", ":", "# \"Observed user preference prediction task\", add the predicted p(o) for task 2", "\n", "            ", "self", ".", "train", "=", "self", ".", "merge_predOP", "(", "self", ".", "train", ")", "\n", "self", ".", "valid", "=", "self", ".", "merge_predOP", "(", "self", ".", "valid", ")", "\n", "self", ".", "test", "=", "self", ".", "merge_predOP", "(", "self", ".", "test", ")", "\n", "print", "(", "\"Load predOP (P(O)) done.\"", ")", "\n", "\n", "", "self", ".", "n_items", "=", "max", "(", "self", ".", "train_full", "[", "'ItemId'", "]", ")", "+", "1", "\n", "self", ".", "n_users", "=", "max", "(", "self", ".", "train_full", "[", "'UserId'", "]", ")", "+", "1", "\n", "\n", "\n", "# filter the items in the test but not in the training set", "\n", "self", ".", "test", "=", "self", ".", "test", "[", "self", ".", "test", "[", "'ItemId'", "]", "<", "self", ".", "n_items", "]", "\n", "\n", "# get itemage", "\n", "self", ".", "item_birthdate", "=", "self", ".", "_get_item_birthdate", "(", ")", "\n", "\n", "self", ".", "max_period", "=", "self", ".", "n_periods", "-", "1", "\n", "self", ".", "n_bins", "=", "None", "\n", "train_itemage", "=", "self", ".", "get_itemage", "(", "self", ".", "train_full", "[", "'ItemId'", "]", ",", "self", ".", "train_full", "[", "'timestamp'", "]", ")", "\n", "self", ".", "n_periods", "=", "min", "(", "self", ".", "n_periods", "-", "1", ",", "max", "(", "train_itemage", ")", ")", "+", "1", "\n", "self", ".", "train_full", "[", "'ItemAge'", "]", "=", "train_itemage", "\n", "# # del the items only appearing in training set", "\n", "n_test", "=", "len", "(", "self", ".", "test", ")", "\n", "self", ".", "test", "=", "self", ".", "test", ".", "drop", "(", "self", ".", "test", "[", "~", "self", ".", "test", "[", "'ItemId'", "]", ".", "isin", "(", "self", ".", "train_full", "[", "'ItemId'", "]", ".", "unique", "(", ")", ")", "]", ".", "index", ")", "\n", "print", "(", "\"Drop the items appearing in training set but not in test. Nr %d\"", "%", "(", "n_test", "-", "len", "(", "self", ".", "test", ")", ")", ")", "\n", "# exit(0)", "\n", "test_itemage", "=", "self", ".", "get_itemage", "(", "self", ".", "test", "[", "'ItemId'", "]", ",", "self", ".", "test", "[", "'timestamp'", "]", ")", "\n", "self", ".", "test", "[", "'ItemAge'", "]", "=", "test_itemage", "\n", "if", "self", ".", "n_bins", "is", "not", "None", ":", "\n", "            ", "self", ".", "n_periods", "=", "self", ".", "n_bins", "\n", "\n", "# # get training and valid observation data for model learning", "\n", "# OIPT, do time-based splitting, generate train_interactions and valid_interactions with 9:1 splitting", "\n", "", "if", "(", "task", "==", "'OIPT'", ")", "and", "(", "config", "[", "'splitting'", "]", "!=", "'random'", ")", ":", "\n", "            ", "self", ".", "interation_data_time_OIPT", "(", "self", ".", "train_full", ")", "\n", "\n", "# basic info", "\n", "", "print", "(", "\"(#users : %d, #items : %d, period_type : %s, n_periods : %d)\"", "%", "(", "self", ".", "n_users", ",", "self", ".", "n_items", ",", "self", ".", "period_type", ",", "self", ".", "n_periods", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings": [[119, 123], ["pandas.read_csv"], "methods", ["None"], ["", "def", "_load_ratings", "(", "self", ",", "ratingfile", ",", "sep", "=", "','", ")", ":", "\n", "        ", "ratings", "=", "pd", ".", "read_csv", "(", "ratingfile", ",", "sep", "=", "sep", ",", "header", "=", "0", ")", "\n", "# ratings.columns = ['UserId', 'ItemId', 'rating', 'timestamp', 'ctr']", "\n", "return", "ratings", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.years2bins": [[124, 134], ["print", "numpy.copy", "numpy.arange", "range", "min", "len", "list", "len", "len", "range", "itemage.isin"], "methods", ["None"], ["", "def", "years2bins", "(", "self", ",", "itemage", ")", ":", "\n", "        ", "bins", "=", "[", "-", "1", "]", "+", "[", "0", ",", "2", ",", "4", ",", "7", ",", "10", ",", "14", ",", "20", "]", "\n", "print", "(", "\"---------- Using Bins: \"", ",", "bins", "[", "1", ":", "]", ",", "\"----------\"", ")", "\n", "itemage_", "=", "np", ".", "copy", "(", "itemage", ")", "\n", "replaces", "=", "np", ".", "arange", "(", "len", "(", "bins", ")", "-", "1", ")", "\n", "for", "bidx", "in", "range", "(", "1", ",", "len", "(", "bins", ")", ")", ":", "\n", "            ", "b", "=", "list", "(", "range", "(", "bins", "[", "bidx", "-", "1", "]", "+", "1", ",", "bins", "[", "bidx", "]", "+", "1", ")", ")", "\n", "itemage_", "[", "itemage", ".", "isin", "(", "b", ")", "]", "=", "replaces", "[", "bidx", "-", "1", "]", "\n", "", "n_bins", "=", "min", "(", "self", ".", "n_periods", ",", "len", "(", "replaces", ")", ")", "\n", "return", "itemage_", ",", "n_bins", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._get_item_birthdate": [[135, 145], ["pandas.concat", "numpy.zeros", "pandas.concat.groupby", "min", "group[].to_list"], "methods", ["None"], ["", "def", "_get_item_birthdate", "(", "self", ")", ":", "\n", "        ", "d", "=", "pd", ".", "concat", "(", "[", "self", ".", "train_full", ",", "self", ".", "test", "]", ",", "ignore_index", "=", "True", ")", "\n", "# self.n_items = max(d['ItemId'])+1", "\n", "item_birthdate", "=", "np", ".", "zeros", "(", "self", ".", "n_items", ",", "dtype", "=", "'int64'", ")", "\n", "for", "i", ",", "group", "in", "d", ".", "groupby", "(", "[", "'ItemId'", "]", ")", ":", "\n", "            ", "item_birthdate", "[", "i", "]", "=", "min", "(", "group", "[", "'timestamp'", "]", ".", "to_list", "(", ")", ")", "\n", "# df = pd.DataFrame(data=np.stack((np.arange(self.n_items), item_birthdate), 1), columns = ['ItemId', 'birthdate'])", "\n", "# df.to_csv(self.path + '/simulation/item_birthdate.csv', sep=',', header=True, index=False)", "\n", "# exit(0)", "\n", "", "return", "item_birthdate", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage": [[146, 196], ["print", "len", "len", "numpy.copy", "print", "numpy.arange", "range", "min", "len", "list", "len", "len", "range", "itemage.isin"], "methods", ["None"], ["", "def", "get_itemage", "(", "self", ",", "items", ",", "timestamp", ",", "item_birthdate", "=", "None", ",", "del_young_items", "=", "False", ")", ":", "\n", "        ", "unit", "=", "self", ".", "period_type", "\n", "# max_period = self.n_periods - 1", "\n", "max_period", "=", "self", ".", "max_period", "\n", "'''\n        # time info\n        max_month = 5 * 12 - 1 # 5 years\n        self.train_full['ItemAge_month'] = self.train_full['ItemAge_month'].clip(0, max_month)\n        self.test['ItemAge_month'] = self.test['ItemAge_month'].clip(0, max_month)\n        self.n_months = max(self.train_full['ItemAge_month']) + 1\n        '''", "\n", "\n", "period_second", "=", "24", "*", "60", "*", "60", "# how many seconds in one day.", "\n", "if", "unit", "==", "'month'", ":", "\n", "            ", "period_second", "*=", "30", "\n", "", "elif", "unit", "==", "'year'", ":", "\n", "            ", "period_second", "*=", "365", "\n", "# self.period_second = period_second", "\n", "", "if", "item_birthdate", "is", "not", "None", ":", "\n", "            ", "item_pt", "=", "item_birthdate", "[", "items", "]", "\n", "itemage", "=", "(", "(", "timestamp", "-", "item_pt", ")", "*", "1.0", "/", "period_second", ")", ".", "long", "(", ")", ".", "clip", "(", "0", ",", "max_period", ")", "\n", "# if del_young_items:", "\n", "#     itemage[(timestamp - item_pt) < 0] = -1", "\n", "", "else", ":", "\n", "            ", "item_pt", "=", "self", ".", "item_birthdate", "[", "items", "]", "\n", "# print(((timestamp - item_pt) * 1.0 / period_second))", "\n", "# exit(0)", "\n", "itemage", "=", "(", "(", "timestamp", "-", "item_pt", ")", "*", "1.0", "/", "period_second", ")", ".", "astype", "(", "int", ")", ".", "clip", "(", "0", ",", "max_period", ")", "\n", "# print(np.unique(itemage, return_counts=True))", "\n", "# if del_young_items:", "\n", "#     itemage[(timestamp - item_pt) < 0] = -1", "\n", "assert", "len", "(", "itemage", ")", "==", "len", "(", "items", ")", "\n", "\n", "# # use bins to map the itemage", "\n", "", "if", "self", ".", "task", "==", "'OPPT'", ":", "\n", "            ", "print", "(", "'For mapping itemage to bins, max_period:'", ",", "max_period", ")", "\n", "if", "self", ".", "dataset", "==", "'ml-latest-small'", ":", "\n", "                ", "itemage_", "=", "np", ".", "copy", "(", "itemage", ")", "\n", "bins", "=", "[", "-", "1", "]", "+", "[", "0", ",", "2", ",", "4", ",", "7", ",", "10", ",", "14", ",", "20", "]", "\n", "print", "(", "\"---------- Using Bins: \"", ",", "bins", "[", "1", ":", "]", ",", "\"----------\"", ")", "\n", "replaces", "=", "np", ".", "arange", "(", "len", "(", "bins", ")", "-", "1", ")", "\n", "for", "bidx", "in", "range", "(", "1", ",", "len", "(", "bins", ")", ")", ":", "\n", "                    ", "b", "=", "list", "(", "range", "(", "bins", "[", "bidx", "-", "1", "]", "+", "1", ",", "bins", "[", "bidx", "]", "+", "1", ")", ")", "\n", "itemage_", "[", "itemage", ".", "isin", "(", "b", ")", "]", "=", "replaces", "[", "bidx", "-", "1", "]", "\n", "", "self", ".", "n_bins", "=", "min", "(", "self", ".", "n_periods", ",", "len", "(", "replaces", ")", ")", "\n", "# print(np.unique(itemage, return_counts=True))", "\n", "# print(np.unique(itemage_, return_counts=True), '\\n')", "\n", "# exit(0)", "\n", "return", "itemage_", "\n", "", "", "return", "itemage", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.estimated_predOP_replace": [[197, 266], ["pandas.concat", "numpy.zeros", "numpy.zeros", "range", "print", "len", "len", "range", "print", "range", "print", "range", "pandas.read_csv", "print", "print", "exit", "numpy.zeros", "len", "df.sort_index.sort_index.sort_values", "predOP.sort_values.sort_values.sort_values", "df.sort_index.sort_index.sort_index"], "methods", ["None"], ["", "def", "estimated_predOP_replace", "(", "self", ",", "mode", "=", "'b3'", ",", "static", "=", "False", ")", ":", "\n", "        ", "df", "=", "pd", ".", "concat", "(", "[", "self", ".", "train", ",", "self", ".", "valid", "]", ",", "ignore_index", "=", "True", ")", "\n", "scores_train", ",", "scores_valid", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "train", ")", ",", "dtype", "=", "float", ")", ",", "np", ".", "zeros", "(", "len", "(", "self", ".", "valid", ")", ",", "dtype", "=", "float", ")", "\n", "if", "mode", "==", "'b3'", ":", "# popularity at item-age t", "\n", "            ", "assert", "static", "==", "False", "\n", "for", "T", "in", "range", "(", "self", ".", "n_periods", ")", ":", "\n", "                ", "s_T", "=", "(", "df", "[", "'itemage'", "]", "==", "T", ")", ".", "mean", "(", ")", "\n", "scores_train", "[", "self", ".", "train", "[", "'itemage'", "]", ".", "values", "==", "T", "]", "=", "s_T", "\n", "scores_valid", "[", "self", ".", "valid", "[", "'itemage'", "]", ".", "values", "==", "T", "]", "=", "s_T", "\n", "# print(\"MSE of %s: %.4f\" % (mode, ((self.train['predOP'] - scores_train) ** 2).mean()))", "\n", "", "self", ".", "train", "[", "'predOP'", "]", ",", "self", ".", "valid", "[", "'predOP'", "]", "=", "scores_train", ",", "scores_valid", "\n", "print", "(", "\"!!!!! Estimate and Replace the propensities with B3. Done !!!!!\"", ")", "\n", "", "elif", "mode", "==", "'b2_i'", ":", "# P(O|i)", "\n", "            ", "assert", "static", "==", "False", "\n", "for", "i", "in", "range", "(", "self", ".", "n_items", ")", ":", "\n", "                ", "s_i", "=", "(", "df", "[", "'ItemId'", "]", "==", "i", ")", ".", "mean", "(", ")", "\n", "scores_train", "[", "(", "self", ".", "train", "[", "'ItemId'", "]", ".", "values", "==", "i", ")", "]", "=", "s_i", "\n", "scores_valid", "[", "(", "self", ".", "valid", "[", "'ItemId'", "]", ".", "values", "==", "i", ")", "]", "=", "s_i", "\n", "", "self", ".", "train", "[", "'predOP'", "]", ",", "self", ".", "valid", "[", "'predOP'", "]", "=", "scores_train", ",", "scores_valid", "\n", "print", "(", "\"!!!!! Estimate and Replace the propensities with pop_i. Done !!!!!\"", ")", "\n", "", "elif", "mode", "==", "'b4'", ":", "# popularity of item i at item-age t", "\n", "            ", "assert", "static", "==", "False", "\n", "for", "T", "in", "range", "(", "self", ".", "n_periods", ")", ":", "\n", "                ", "for", "i", "in", "range", "(", "self", ".", "n_items", ")", ":", "\n", "                    ", "s_iT", "=", "(", "(", "df", "[", "'itemage'", "]", "==", "T", ")", "&", "(", "df", "[", "'ItemId'", "]", "==", "i", ")", ")", ".", "mean", "(", ")", "\n", "scores_train", "[", "(", "self", ".", "train", "[", "'itemage'", "]", ".", "values", "==", "T", ")", "&", "(", "self", ".", "train", "[", "'ItemId'", "]", ".", "values", "==", "i", ")", "]", "=", "s_iT", "\n", "scores_valid", "[", "(", "self", ".", "valid", "[", "'itemage'", "]", ".", "values", "==", "T", ")", "&", "(", "self", ".", "valid", "[", "'ItemId'", "]", ".", "values", "==", "i", ")", "]", "=", "s_iT", "\n", "# norm = 1.0 / scores_train.mean() * self.train['predOP'].values.mean()", "\n", "# scores_train *= norm", "\n", "# scores_valid *= norm", "\n", "# print((self.train['predOP'].values ** 2).mean(), ((scores_train) ** 2).mean())", "\n", "# print(\"MSE of %s: %.4f\" % (mode, ((self.train['predOP'] - scores_train) ** 2).mean()))", "\n", "", "", "self", ".", "train", "[", "'predOP'", "]", ",", "self", ".", "valid", "[", "'predOP'", "]", "=", "scores_train", ",", "scores_valid", "\n", "print", "(", "\"!!!!! Estimate and Replace the propensities with B4 (pop_it). Done !!!!!\"", ")", "\n", "", "elif", "(", "mode", "==", "'mf'", ")", "or", "(", "mode", "==", "'tmtf'", ")", ":", "\n", "            ", "path", "=", "self", ".", "path", "+", "\"/sim-estimOP/predOP_%s_small_0.1.csv\"", "\n", "predOP", "=", "pd", ".", "read_csv", "(", "path", "%", "mode", ",", "sep", "=", "','", ",", "header", "=", "0", ")", "\n", "if", "mode", "==", "'mf'", ":", "\n", "                ", "predOP_numpy", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_users", ",", "self", ".", "n_items", ")", ",", "dtype", "=", "float", ")", "\n", "predOP_numpy", "[", "predOP", "[", "'UserId'", "]", ".", "values", ",", "predOP", "[", "'ItemId'", "]", ".", "values", "]", "=", "predOP", "[", "'predOP'", "]", ".", "values", "\n", "self", ".", "train", "[", "'predOP'", "]", "=", "predOP_numpy", "[", "self", ".", "train", "[", "'UserId'", "]", ".", "values", ",", "self", ".", "train", "[", "'ItemId'", "]", ".", "values", "]", "\n", "self", ".", "valid", "[", "'predOP'", "]", "=", "predOP_numpy", "[", "self", ".", "valid", "[", "'UserId'", "]", ".", "values", ",", "self", ".", "valid", "[", "'ItemId'", "]", ".", "values", "]", "\n", "# print(self.train[self.train['predOP'] == 0.0][:20])", "\n", "# exit(0)", "\n", "", "else", ":", "\n", "                ", "num_train", "=", "len", "(", "self", ".", "train", ")", "\n", "df", "=", "df", ".", "sort_values", "(", "by", "=", "[", "'UserId'", ",", "'ItemId'", ",", "'itemage'", "]", ")", "\n", "predOP", "=", "predOP", ".", "sort_values", "(", "by", "=", "[", "'UserId'", ",", "'ItemId'", ",", "'itemage'", "]", ")", "\n", "assert", "(", "(", "df", "[", "'UserId'", "]", ".", "values", "!=", "predOP", "[", "'UserId'", "]", ".", "values", ")", ".", "sum", "(", ")", "==", "0", ")", "\n", "assert", "(", "(", "df", "[", "'ItemId'", "]", ".", "values", "!=", "predOP", "[", "'ItemId'", "]", ".", "values", ")", ".", "sum", "(", ")", "==", "0", ")", "\n", "# print(df[df['ItemId'].values != predOP['ItemId'].values])", "\n", "# print(predOP[df['ItemId'].values != predOP['ItemId'].values])", "\n", "assert", "(", "(", "df", "[", "'itemage'", "]", ".", "values", "!=", "predOP", "[", "'itemage'", "]", ".", "values", ")", ".", "sum", "(", ")", "==", "0", ")", "\n", "df", "[", "'predOP'", "]", "=", "predOP", "[", "'predOP'", "]", ".", "values", "\n", "# print(df[:10], predOP[:10])", "\n", "df", "=", "df", ".", "sort_index", "(", ")", "\n", "train_", "=", "df", "[", ":", "num_train", "]", "\n", "assert", "(", "train_", "[", "'UserId'", "]", "!=", "self", ".", "train", "[", "'UserId'", "]", ")", ".", "sum", "(", ")", "==", "0", "\n", "assert", "(", "train_", "[", "'ItemId'", "]", "!=", "self", ".", "train", "[", "'ItemId'", "]", ")", ".", "sum", "(", ")", "==", "0", "\n", "assert", "(", "train_", "[", "'itemage'", "]", "!=", "self", ".", "train", "[", "'itemage'", "]", ")", ".", "sum", "(", ")", "==", "0", "\n", "self", ".", "train", "[", "'predOP'", "]", "=", "train_", "[", "'predOP'", "]", ".", "values", "\n", "self", ".", "valid", "[", "'predOP'", "]", "=", "df", "[", "num_train", ":", "]", "[", "'predOP'", "]", ".", "values", "\n", "# print(self.train[:10])", "\n", "# print(train_[:10])", "\n", "", "print", "(", "\"!!!!! Estimate and Replace the propensities with %s. Done !!!!!\"", "%", "mode", ")", "\n", "# exit(0)", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Unknown estimated predOP\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.merge_predOP": [[268, 293], ["data.Dataset._load_ratings", "list", "data.Dataset.drop", "pandas.merge", "NotImplementedError", "set", "set", "set"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings"], ["", "", "def", "merge_predOP", "(", "self", ",", "train", ")", ":", "\n", "        ", "if", "self", ".", "dataset", "==", "'ml-latest-small'", ":", "\n", "# filename = self.path + self.dataset + '/predOP_tmtf_small_0.1.csv'", "\n", "            ", "filename", "=", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/predOP_tmtf.csv'", "\n", "", "elif", "self", ".", "dataset", "==", "'ml-100k'", ":", "\n", "            ", "filename", "=", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/predOP_mf.csv'", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Only implement for ml-100k or ml-latest-small\"", ")", "\n", "", "predOP", "=", "self", ".", "_load_ratings", "(", "filename", ")", "\n", "predOP", "=", "predOP", "[", "[", "'UserId'", ",", "'ItemId'", ",", "'rating'", ",", "'timestamp'", ",", "'predOP'", "]", "]", "\n", "del_columns", "=", "list", "(", "set", "(", "predOP", ".", "columns", ")", "-", "set", "(", "train", ".", "columns", ")", "-", "set", "(", "[", "'predOP'", "]", ")", ")", "\n", "# print(del_columns)", "\n", "predOP", ".", "drop", "(", "columns", "=", "del_columns", ")", "\n", "# print(\"the remained columns of predOP is\", predOP.columns)", "\n", "# train_ = train.copy()", "\n", "# output = train_.append(predOP, ignore_index=True, sort=False)", "\n", "# output.dropna(axis=0, how='any') #drop all rows that have any NaN values", "\n", "# output = pd.concat([train, predOP], axis=1, join='inner')", "\n", "# output = output[output.columns].T.drop_duplicates().T", "\n", "output", "=", "pd", ".", "merge", "(", "train", ",", "predOP", ",", "how", "=", "'inner'", ",", "on", "=", "[", "'UserId'", ",", "'ItemId'", ",", "'rating'", ",", "'timestamp'", "]", ")", "\n", "# print(\"After concat\", output.columns, '\\n')", "\n", "# print(output['UserId'])", "\n", "# print(len(output), len(train))", "\n", "# assert len(output) == len(train)", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.resplitting_random": [[294, 352], ["os.path.exists", "print", "pandas.concat", "numpy.random.seed", "pandas.concat.groupby", "pandas.concat", "pandas.concat", "pandas.concat", "pandas.concat", "print", "print", "print", "data.Dataset._load_ratings", "data.Dataset._load_ratings", "data.Dataset._load_ratings", "pandas.concat", "print", "data.Dataset.valid.drop", "data.Dataset.test.drop", "print", "print", "group.sample", "int", "int", "df_train.append", "df_valid.append", "df_test.append", "len", "len", "len", "len", "numpy.random.randint", "len", "len", "len", "len", "len", "len", "len", "data.Dataset.train[].mean", "data.Dataset.valid[].mean", "data.Dataset.test[].mean", "len", "len", "len", "len", "len", "data.Dataset.valid[].isin", "data.Dataset.test[].isin", "data.Dataset.train[].unique", "data.Dataset.train[].unique"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings"], ["", "def", "resplitting_random", "(", "self", ")", ":", "\n", "# if os.path.exists(self.path + self.dataset + '/train_random_OPPT_old.csv'):", "\n", "#     self.train_full = self._load_ratings(self.path + self.dataset + '/train_random_OPPT_old.csv')", "\n", "#     self.test = self._load_ratings(self.path + self.dataset + '/test_random_OPPT_old.csv')", "\n", "#     self.train, self.valid = self.train_full, self.train_full", "\n", "#     print(\"Loading randomly-splitted train, valid and test set for OPPT (Task 2). Done.\")", "\n", "#     return", "\n", "        ", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OPPT.csv'", ")", ":", "\n", "            ", "self", ".", "train_full", "=", "None", "\n", "self", ".", "train", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/train_random_OPPT.csv'", ")", "\n", "self", ".", "valid", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OPPT.csv'", ")", "\n", "self", ".", "test", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/test_random_OPPT.csv'", ")", "\n", "self", ".", "train_full", "=", "pd", ".", "concat", "(", "[", "self", ".", "train", ",", "self", ".", "valid", "]", ",", "axis", "=", "0", ",", "ignore_index", "=", "True", ")", "\n", "print", "(", "\"Nr in train, valid, test are %d, %d, %d\"", "%", "(", "len", "(", "self", ".", "train", ")", ",", "len", "(", "self", ".", "valid", ")", ",", "len", "(", "self", ".", "test", ")", ")", ")", "\n", "n_valid", ",", "n_test", "=", "len", "(", "self", ".", "valid", ")", ",", "len", "(", "self", ".", "test", ")", "\n", "self", ".", "valid", "=", "self", ".", "valid", ".", "drop", "(", "self", ".", "valid", "[", "~", "self", ".", "valid", "[", "'ItemId'", "]", ".", "isin", "(", "self", ".", "train", "[", "'ItemId'", "]", ".", "unique", "(", ")", ")", "]", ".", "index", ")", "\n", "self", ".", "test", "=", "self", ".", "test", ".", "drop", "(", "self", ".", "test", "[", "~", "self", ".", "test", "[", "'ItemId'", "]", ".", "isin", "(", "self", ".", "train", "[", "'ItemId'", "]", ".", "unique", "(", ")", ")", "]", ".", "index", ")", "\n", "print", "(", "\"Nr in valid and test whose items are not in trainset: %d and %d\"", "%", "(", "n_valid", "-", "len", "(", "self", ".", "valid", ")", ",", "n_test", "-", "len", "(", "self", ".", "test", ")", ")", ")", "\n", "print", "(", "\"Loading randomly-splitted train, valid and test set for OPPT (Task 2). Done.\"", ")", "\n", "return", "\n", "", "print", "(", "\"Generate the random-splitted training/test set.\"", ")", "\n", "# # combine train_full and test as a whole dataset", "\n", "df", "=", "pd", ".", "concat", "(", "[", "self", ".", "train_full", ",", "self", ".", "test", "]", ",", "ignore_index", "=", "True", ")", "\n", "# # random splitting by user", "\n", "df_train", ",", "df_valid", ",", "df_test", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "np", ".", "random", ".", "seed", "(", "2021", ")", "\n", "for", "(", "u", ",", "group", ")", "in", "df", ".", "groupby", "(", "[", "'UserId'", "]", ")", ":", "\n", "            ", "group_", "=", "group", ".", "sample", "(", "frac", "=", "1", ",", "random_state", "=", "np", ".", "random", ".", "randint", "(", "10000", ")", ")", "\n", "n_test", "=", "int", "(", "0.2", "*", "len", "(", "group_", ")", ")", "\n", "n_train", "=", "int", "(", "0.7", "*", "len", "(", "group_", ")", ")", "\n", "df_train", ".", "append", "(", "group_", "[", ":", "n_train", "]", ")", "\n", "df_valid", ".", "append", "(", "group_", "[", "n_train", ":", "-", "n_test", "]", ")", "\n", "df_test", ".", "append", "(", "group_", "[", "-", "n_test", ":", "]", ")", "\n", "", "self", ".", "train_full", "=", "None", "\n", "self", ".", "train", "=", "pd", ".", "concat", "(", "df_train", ",", "axis", "=", "0", ")", "\n", "self", ".", "valid", "=", "pd", ".", "concat", "(", "df_valid", ",", "axis", "=", "0", ")", "\n", "self", ".", "test", "=", "pd", ".", "concat", "(", "df_test", ",", "axis", "=", "0", ")", "\n", "assert", "(", "len", "(", "self", ".", "train", ")", "+", "len", "(", "self", ".", "valid", ")", "+", "len", "(", "self", ".", "test", ")", ")", "==", "len", "(", "df", ")", "\n", "\n", "# # # random splitting over all", "\n", "# df_ = df.sample(frac=1, random_state=2021)", "\n", "# n_train, n_test = int(len(df_) * 0.7), int(len(df_) * 0.2)", "\n", "# self.train = df_[:n_train]", "\n", "# self.valid = df_[n_train:-n_test]", "\n", "# self.test = df_[-n_test:]", "\n", "\n", "# only keep ['UserId', 'ItemId', 'rating', 'timestamp']", "\n", "cols", "=", "[", "'UserId'", ",", "'ItemId'", ",", "'rating'", ",", "'timestamp'", "]", "\n", "self", ".", "train", "=", "self", ".", "train", "[", "cols", "]", "\n", "self", ".", "valid", "=", "self", ".", "valid", "[", "cols", "]", "\n", "self", ".", "test", "=", "self", ".", "test", "[", "cols", "]", "\n", "self", ".", "train_full", "=", "pd", ".", "concat", "(", "[", "self", ".", "train", ",", "self", ".", "valid", "]", ",", "axis", "=", "0", ",", "ignore_index", "=", "True", ")", "\n", "print", "(", "\"Nr in train, valid, test are %d, %d, %d\"", "%", "(", "len", "(", "self", ".", "train", ")", ",", "len", "(", "self", ".", "valid", ")", ",", "len", "(", "self", ".", "test", ")", ")", ")", "\n", "print", "(", "\"Avg-rating in train, valid, test are %.6f, %.6f, %.6f\"", "%", "(", "self", ".", "train", "[", "'rating'", "]", ".", "mean", "(", ")", ",", "self", ".", "valid", "[", "'rating'", "]", ".", "mean", "(", ")", ",", "self", ".", "test", "[", "'rating'", "]", ".", "mean", "(", ")", ")", ")", "\n", "# self.train.to_csv(self.path + self.dataset + '/train_random_OPPT.csv', index=False)", "\n", "# self.valid.to_csv(self.path + self.dataset + '/valid_random_OPPT.csv', index=False)", "\n", "# self.test.to_csv(self.path + self.dataset + '/test_random_OPPT.csv', index=False)", "\n", "print", "(", "\"For OPPT (task 2), Saving randomly-splitted dataset. Done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.interation_data_time_OIPT": [[353, 425], ["os.path.exists", "numpy.zeros", "ratings.groupby", "numpy.ones_like", "numpy.where", "numpy.zeros_like", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "pandas.DataFrame", "min", "numpy.random.seed", "numpy.random.uniform", "print", "print", "print", "df_train.to_csv", "df_valid.to_csv", "print", "data.Dataset.task.upper", "NotImplementedError", "data.Dataset._load_ratings", "data.Dataset._df2interactions", "data.Dataset._load_ratings", "data.Dataset._df2interactions", "print", "print", "min", "max", "data.Dataset.get_itemage", "data.Dataset.get_itemage", "len", "data.Dataset._df2interactions", "data.Dataset._df2interactions", "numpy.arange", "numpy.full", "numpy.arange", "numpy.full", "numpy.arange", "numpy.concatenate.append", "numpy.concatenate.append", "numpy.concatenate.append", "numpy.concatenate.append", "len", "numpy.concatenate", "numpy.concatenate", "max", "len", "len", "numpy.arange", "numpy.full", "numpy.arange", "numpy.full", "len", "len", "len", "df[].sum", "df_train[].sum", "df_valid[].sum", "df[].mean", "df_train[].mean", "df_valid[].mean"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions"], ["", "def", "interation_data_time_OIPT", "(", "self", ",", "ratings", ")", ":", "\n", "        ", "if", "self", ".", "task", ".", "upper", "(", ")", "!=", "'OIPT'", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Make sure task as OIPT when calling resplitting_time_OIPT\"", ")", "\n", "# load as interactions", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_time_OIPT.csv'", ")", ":", "\n", "            ", "train", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/train_time_OIPT.csv'", ")", "\n", "self", ".", "train_interactions", "=", "self", ".", "_df2interactions", "(", "train", ")", "\n", "valid", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_time_OIPT.csv'", ")", "\n", "self", ".", "valid_interactions", "=", "self", ".", "_df2interactions", "(", "valid", ")", "\n", "print", "(", "\"Columns of data are, \"", ",", "train", ".", "columns", ")", "\n", "print", "(", "\"Loading time-based-splitted training and valid set. Done.\"", ")", "\n", "\n", "# print(\"The distributions of p_T in training set:\", '\\n', '[', ', '.join([str(train['target'][train['itemage'] == t].mean()) for t in range(self.n_periods)]), ']\\n')", "\n", "# print(\"The distributions of p_T in valid set:\", '\\n', '[', ', '.join([str(valid['target'][valid['itemage'] == t].mean()) for t in range(self.n_periods)]), ']\\n')", "\n", "# exit(0)", "\n", "return", "\n", "# ", "\n", "", "ob_uiT", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_users", ",", "self", ".", "n_items", ",", "self", ".", "n_periods", ")", ",", "dtype", "=", "int", ")", "\n", "# # del item without birthdate, means not be interacted", "\n", "# ob_uiT[:, self.item_birthdate == 0] = -1", "\n", "for", "u", ",", "group", "in", "ratings", ".", "groupby", "(", "by", "=", "[", "'UserId'", "]", ")", ":", "\n", "            ", "firsttime", "=", "min", "(", "group", "[", "'timestamp'", "]", ")", "\n", "lasttime", "=", "max", "(", "group", "[", "'timestamp'", "]", ")", "\n", "smallestT_perI", "=", "self", ".", "get_itemage", "(", "np", ".", "arange", "(", "self", ".", "n_items", ")", ",", "np", ".", "full", "(", "self", ".", "n_items", ",", "firsttime", ")", ")", "# inside, clip(0, .)", "\n", "biggestT_perI", "=", "self", ".", "get_itemage", "(", "np", ".", "arange", "(", "self", ".", "n_items", ")", ",", "np", ".", "full", "(", "self", ".", "n_items", ",", "lasttime", ")", ",", "del_young_items", "=", "True", ")", "# if item enters system after lasttime, < 0", "\n", "# # del items enters the system after lasttime, not available", "\n", "ob_uiT", "[", "u", "]", "[", "self", ".", "item_birthdate", ">=", "lasttime", "]", "=", "-", "1", "\n", "idx_i", ",", "idx_T", "=", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "np", ".", "arange", "(", "self", ".", "n_items", ")", "[", "self", ".", "item_birthdate", "<", "lasttime", "]", ":", "\n", "# before user enters system, not available", "\n", "                ", "idx_T", ".", "append", "(", "np", ".", "arange", "(", "smallestT_perI", "[", "i", "]", ")", ")", "\n", "idx_i", ".", "append", "(", "np", ".", "full", "(", "smallestT_perI", "[", "i", "]", ",", "i", ")", ")", "\n", "# after user leaves system, not available", "\n", "idx_T", ".", "append", "(", "np", ".", "arange", "(", "biggestT_perI", "[", "i", "]", "+", "1", ",", "self", ".", "n_periods", ")", ")", "\n", "idx_i", ".", "append", "(", "np", ".", "full", "(", "self", ".", "n_periods", "-", "(", "biggestT_perI", "[", "i", "]", "+", "1", ")", ",", "i", ")", ")", "\n", "", "if", "len", "(", "idx_i", ")", ">", "0", ":", "\n", "                ", "idx_i", "=", "np", ".", "concatenate", "(", "idx_i", ")", "\n", "idx_T", "=", "np", ".", "concatenate", "(", "idx_T", ")", "\n", "ob_uiT", "[", "u", "]", "[", "idx_i", ",", "idx_T", "]", "=", "-", "1", "\n", "# set pos = 1, (u, i, itemage)", "\n", "", "", "users", ",", "items", ",", "itemages", "=", "ratings", "[", "'UserId'", "]", ",", "ratings", "[", "'ItemId'", "]", ",", "ratings", "[", "'ItemAge'", "]", "\n", "targets", "=", "np", ".", "ones_like", "(", "users", ",", "dtype", "=", "int", ")", "\n", "ob_uiT", "[", "users", ",", "items", ",", "itemages", "]", "=", "1", "\n", "# negs", "\n", "users_neg", ",", "items_neg", ",", "itemages_neg", "=", "np", ".", "where", "(", "ob_uiT", "==", "0", ")", "\n", "assert", "users_neg", ".", "shape", "==", "items_neg", ".", "shape", "\n", "targets_neg", "=", "np", ".", "zeros_like", "(", "users_neg", ",", "dtype", "=", "int", ")", "\n", "# merge pos and neg", "\n", "users", "=", "np", ".", "concatenate", "(", "(", "users", ",", "users_neg", ")", ",", "axis", "=", "0", ")", "\n", "items", "=", "np", ".", "concatenate", "(", "(", "items", ",", "items_neg", ")", ",", "axis", "=", "0", ")", "\n", "itemages", "=", "np", ".", "concatenate", "(", "(", "itemages", ",", "itemages_neg", ")", ",", "axis", "=", "0", ")", "\n", "targets", "=", "np", ".", "concatenate", "(", "(", "targets", ",", "targets_neg", ")", ",", "axis", "=", "0", ")", "\n", "nums", "=", "users", ".", "shape", "[", "0", "]", "\n", "# numpy to pandas, cols = ['user', 'item', 'itemage', 'target']", "\n", "df", "=", "pd", ".", "DataFrame", "(", "{", "'user'", ":", "users", ",", "'item'", ":", "items", ",", "'itemage'", ":", "itemages", ",", "'target'", ":", "targets", "}", ")", "\n", "self", ".", "n_periods", "=", "min", "(", "self", ".", "n_periods", ",", "max", "(", "itemages", ")", "+", "1", ")", "\n", "\n", "# # shuffle, split and save into file", "\n", "# before we use 517 as random seed", "\n", "np", ".", "random", ".", "seed", "(", "2021", ")", "\n", "uniform_p", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "nums", ")", "\n", "# # take 10% as valid set", "\n", "df_train", "=", "df", "[", "uniform_p", "<=", "0.8", "]", "\n", "df_valid", "=", "df", "[", "uniform_p", ">", "0.8", "]", "\n", "assert", "(", "len", "(", "df_train", ")", "+", "len", "(", "df_valid", ")", ")", "==", "len", "(", "df", ")", "\n", "print", "(", "\"Nr. in data, train and valid are %d, %d and %d\"", "%", "(", "len", "(", "df", "[", "'target'", "]", ")", ",", "len", "(", "df_train", "[", "'target'", "]", ")", ",", "len", "(", "df_valid", "[", "'target'", "]", ")", ")", ")", "\n", "print", "(", "\"#o in data, train and valid are %d, %d and %d\"", "%", "(", "df", "[", "'target'", "]", ".", "sum", "(", ")", ",", "df_train", "[", "'target'", "]", ".", "sum", "(", ")", ",", "df_valid", "[", "'target'", "]", ".", "sum", "(", ")", ")", ")", "\n", "print", "(", "\"p(o) in data, train and valid are %.4f, %.4f and %.4f\"", "%", "(", "df", "[", "'target'", "]", ".", "mean", "(", ")", ",", "df_train", "[", "'target'", "]", ".", "mean", "(", ")", ",", "df_valid", "[", "'target'", "]", ".", "mean", "(", ")", ")", ")", "\n", "df_train", ".", "to_csv", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/train_time_OIPT.csv'", ",", "index", "=", "False", ")", "\n", "df_valid", ".", "to_csv", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_time_OIPT.csv'", ",", "index", "=", "False", ")", "\n", "print", "(", "\"Saving time-based-splitted dataset. Done.\"", ")", "\n", "self", ".", "train_interactions", ",", "self", ".", "test_interactions", "=", "self", ".", "_df2interactions", "(", "df_train", ")", ",", "self", ".", "_df2interactions", "(", "df_valid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.resplitting_random_OIPT": [[427, 456], ["os.path.exists", "pandas.concat", "data.Dataset._get_item_birthdate", "data.Dataset._neg_sampling_time_based", "print", "data.Dataset.task.upper", "NotImplementedError", "data.Dataset._load_ratings", "data.Dataset._df2interactions", "data.Dataset._load_ratings", "data.Dataset._df2interactions", "data.Dataset._load_ratings", "data.Dataset._df2interactions", "print", "print", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._get_item_birthdate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._neg_sampling_time_based", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions"], ["", "def", "resplitting_random_OIPT", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "task", ".", "upper", "(", ")", "!=", "'OIPT'", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Make sure task as OIPT when calling resplitting_random_OIPT\"", ")", "\n", "\n", "# load as interactions", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OIPT.csv'", ")", ":", "\n", "            ", "train", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/train_random_OIPT.csv'", ")", "\n", "self", ".", "train_interactions", "=", "self", ".", "_df2interactions", "(", "train", ")", "\n", "valid", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OIPT.csv'", ")", "\n", "self", ".", "valid_interactions", "=", "self", ".", "_df2interactions", "(", "valid", ")", "\n", "test", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/test_random_OIPT.csv'", ")", "\n", "self", ".", "test_interactions", "=", "self", ".", "_df2interactions", "(", "test", ")", "\n", "# cols = ['user', 'item', 'itemage', 'target'] which are generated by negative sampling. Not timestamp, because for negs, we do not have their timestamps", "\n", "self", ".", "n_users", "=", "max", "(", "max", "(", "train", "[", "'user'", "]", ")", ",", "max", "(", "valid", "[", "'user'", "]", ")", ",", "max", "(", "test", "[", "'user'", "]", ")", ")", "+", "1", "\n", "self", ".", "n_items", "=", "max", "(", "max", "(", "train", "[", "'item'", "]", ")", ",", "max", "(", "valid", "[", "'item'", "]", ")", ",", "max", "(", "test", "[", "'item'", "]", ")", ")", "+", "1", "\n", "self", ".", "n_periods", "=", "max", "(", "max", "(", "train", "[", "'itemage'", "]", ")", ",", "max", "(", "valid", "[", "'itemage'", "]", ")", ",", "max", "(", "test", "[", "'itemage'", "]", ")", ")", "+", "1", "\n", "self", ".", "max_period", "=", "self", ".", "n_periods", "-", "1", "\n", "print", "(", "\"Columns of data are, \"", ",", "train", ".", "columns", ")", "\n", "print", "(", "\"Loading randomly-splitted training and test set. Done.\"", ")", "\n", "return", "\n", "\n", "# generate negs, merge with pos, shuffle, split, and save", "\n", "# need item_birthdate", "\n", "", "ratings", "=", "pd", ".", "concat", "(", "[", "self", ".", "train_full", ",", "self", ".", "test", "]", ",", "ignore_index", "=", "True", ")", "\n", "self", ".", "n_users", ",", "self", ".", "n_items", "=", "max", "(", "ratings", "[", "'UserId'", "]", ")", "+", "1", ",", "max", "(", "ratings", "[", "'ItemId'", "]", ")", "+", "1", "\n", "self", ".", "max_period", "=", "self", ".", "n_periods", "-", "1", "\n", "self", ".", "item_birthdate", "=", "self", ".", "_get_item_birthdate", "(", ")", "\n", "self", ".", "train_interactions", ",", "self", ".", "valid_interactions", ",", "self", ".", "test_interactions", "=", "self", ".", "_neg_sampling_time_based", "(", "ratings", ")", "\n", "print", "(", "\"Generate the random-splitted training/test set after negative generation. Done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.resplitting_random_OIPT3": [[457, 503], ["print", "os.path.exists", "os.path.exists", "data.Dataset.task.upper", "NotImplementedError", "data.Dataset._load_ratings", "data.Dataset._df2interactions", "data.Dataset._load_ratings", "data.Dataset._df2interactions", "data.Dataset._load_ratings", "data.Dataset._df2interactions", "print", "print", "data.Dataset._load_ratings", "data.Dataset._load_ratings", "data.Dataset._load_ratings", "pandas.concat", "numpy.random.seed", "numpy.random.uniform", "data.Dataset._df2interactions", "data.Dataset._df2interactions", "data.Dataset._df2interactions", "df[].to_csv", "df[].to_csv", "df[].to_csv", "max", "max", "max", "max", "max", "max", "len", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "max", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._load_ratings", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions"], ["", "def", "resplitting_random_OIPT3", "(", "self", ",", "ratio", "=", "0.1", ")", ":", "\n", "        ", "midname", "=", "'4mf'", "# or ''", "\n", "if", "self", ".", "task", ".", "upper", "(", ")", "!=", "'OIPT'", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Make sure task as OIPT when calling resplitting_random_OIPT\"", ")", "\n", "", "print", "(", "\"!!!!!!! We only use %f data for train and %f for validation, and the rest for test for better generation for TART !!!!!!!!\"", "%", "(", "ratio", ",", "ratio", ")", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OIPT%s_task3.csv'", "%", "midname", ")", ":", "\n", "            ", "train", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/train_random_OIPT%s_task3.csv'", "%", "midname", ")", "\n", "self", ".", "train_interactions", "=", "self", ".", "_df2interactions", "(", "train", ")", "\n", "valid", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OIPT%s_task3.csv'", "%", "midname", ")", "\n", "self", ".", "valid_interactions", "=", "self", ".", "_df2interactions", "(", "valid", ")", "\n", "test", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/test_random_OIPT%s_task3.csv'", "%", "midname", ")", "\n", "self", ".", "test_interactions", "=", "self", ".", "_df2interactions", "(", "test", ")", "\n", "# cols = ['user', 'item', 'itemage', 'target'] which are generated by negative sampling. Not timestamp, because for negs, we do not have their timestamps", "\n", "self", ".", "n_users", "=", "max", "(", "max", "(", "train", "[", "'user'", "]", ")", ",", "max", "(", "valid", "[", "'user'", "]", ")", ",", "max", "(", "test", "[", "'user'", "]", ")", ")", "+", "1", "\n", "self", ".", "n_items", "=", "max", "(", "max", "(", "train", "[", "'item'", "]", ")", ",", "max", "(", "valid", "[", "'item'", "]", ")", ",", "max", "(", "test", "[", "'item'", "]", ")", ")", "+", "1", "\n", "self", ".", "n_periods", "=", "max", "(", "max", "(", "train", "[", "'itemage'", "]", ")", ",", "max", "(", "valid", "[", "'itemage'", "]", ")", ",", "max", "(", "test", "[", "'itemage'", "]", ")", ")", "+", "1", "\n", "self", ".", "max_period", "=", "self", ".", "n_periods", "-", "1", "\n", "print", "(", "\"Columns of data are, \"", ",", "train", ".", "columns", ")", "\n", "print", "(", "\"Loading randomly-splitted training and test set. Done.\"", ")", "\n", "return", "\n", "\n", "# load as interactions", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OIPT.csv'", ")", ":", "\n", "            ", "train", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/train_random_OIPT.csv'", ")", "\n", "valid", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OIPT.csv'", ")", "\n", "test", "=", "self", ".", "_load_ratings", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/test_random_OIPT.csv'", ")", "\n", "# cols = ['user', 'item', 'itemage', 'target'] which are generated by negative sampling. Not timestamp, because for negs, we do not have their timestamps", "\n", "self", ".", "n_users", "=", "max", "(", "max", "(", "train", "[", "'user'", "]", ")", ",", "max", "(", "valid", "[", "'user'", "]", ")", ",", "max", "(", "test", "[", "'user'", "]", ")", ")", "+", "1", "\n", "self", ".", "n_items", "=", "max", "(", "max", "(", "train", "[", "'item'", "]", ")", ",", "max", "(", "valid", "[", "'item'", "]", ")", ",", "max", "(", "test", "[", "'item'", "]", ")", ")", "+", "1", "\n", "self", ".", "n_periods", "=", "max", "(", "max", "(", "train", "[", "'itemage'", "]", ")", ",", "max", "(", "valid", "[", "'itemage'", "]", ")", ",", "max", "(", "test", "[", "'itemage'", "]", ")", ")", "+", "1", "\n", "self", ".", "max_period", "=", "self", ".", "n_periods", "-", "1", "\n", "df", "=", "pd", ".", "concat", "(", "[", "train", ",", "valid", ",", "test", "]", ",", "axis", "=", "0", ")", "\n", "assert", "len", "(", "df", ")", "==", "(", "len", "(", "train", ")", "+", "len", "(", "valid", ")", "+", "len", "(", "test", ")", ")", "\n", "np", ".", "random", ".", "seed", "(", "517", ")", "\n", "indice", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "len", "(", "df", ")", ")", ")", "\n", "indice_train", "=", "(", "indice", "<=", "0.1", ")", "\n", "indice_valid", "=", "(", "indice", ">", "0.9", ")", "\n", "indice_test", "=", "(", "(", "indice", ">", "0.1", ")", "&", "(", "indice", "<=", "0.9", ")", ")", "\n", "self", ".", "train_interactions", "=", "self", ".", "_df2interactions", "(", "df", "[", "indice_train", "]", ")", "\n", "self", ".", "valid_interactions", "=", "self", ".", "_df2interactions", "(", "df", "[", "indice_valid", "]", ")", "\n", "self", ".", "test_interactions", "=", "self", ".", "_df2interactions", "(", "df", "[", "indice_test", "]", ")", "\n", "df", "[", "indice_train", "]", ".", "to_csv", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/train_random_OIPT_task3.csv'", ",", "index", "=", "False", ")", "\n", "df", "[", "indice_valid", "]", ".", "to_csv", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OIPT_task3.csv'", ",", "index", "=", "False", ")", "\n", "df", "[", "indice_test", "]", ".", "to_csv", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/test_random_OIPT_task3.csv'", ",", "index", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "raise", "\"Errors\"", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._neg_sampling_time_based": [[505, 565], ["numpy.zeros", "ratings.groupby", "data.Dataset.get_itemage", "numpy.ones_like", "numpy.where", "numpy.zeros_like", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "pandas.DataFrame", "min", "numpy.random.seed", "numpy.random.uniform", "print", "print", "print", "df_train.to_csv", "df_valid.to_csv", "df_test.to_csv", "print", "min", "max", "data.Dataset.get_itemage", "data.Dataset.get_itemage", "len", "data.Dataset._df2interactions", "data.Dataset._df2interactions", "data.Dataset._df2interactions", "numpy.arange", "numpy.full", "numpy.arange", "numpy.full", "numpy.arange", "numpy.concatenate.append", "numpy.concatenate.append", "numpy.concatenate.append", "numpy.concatenate.append", "len", "numpy.concatenate", "numpy.concatenate", "max", "len", "numpy.arange", "numpy.full", "numpy.arange", "numpy.full", "len", "len", "len", "len", "len", "len", "df[].sum", "df_train[].sum", "df_valid[].sum", "df_test[].sum", "df[].mean", "df_train[].mean", "df_valid[].mean", "df_test[].mean"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions"], ["", "", "def", "_neg_sampling_time_based", "(", "self", ",", "ratings", ")", ":", "\n", "        ", "ob_uiT", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_users", ",", "self", ".", "n_items", ",", "self", ".", "n_periods", ")", ",", "dtype", "=", "int", ")", "\n", "# # del item without birthdate, means not be interacted", "\n", "ob_uiT", "[", ":", ",", "self", ".", "item_birthdate", "==", "0", "]", "=", "-", "1", "\n", "for", "u", ",", "group", "in", "ratings", ".", "groupby", "(", "by", "=", "[", "'UserId'", "]", ")", ":", "\n", "            ", "firsttime", "=", "min", "(", "group", "[", "'timestamp'", "]", ")", "\n", "lasttime", "=", "max", "(", "group", "[", "'timestamp'", "]", ")", "\n", "smallestT_perI", "=", "self", ".", "get_itemage", "(", "np", ".", "arange", "(", "self", ".", "n_items", ")", ",", "np", ".", "full", "(", "self", ".", "n_items", ",", "firsttime", ")", ")", "# inside, clip(0, .)", "\n", "biggestT_perI", "=", "self", ".", "get_itemage", "(", "np", ".", "arange", "(", "self", ".", "n_items", ")", ",", "np", ".", "full", "(", "self", ".", "n_items", ",", "lasttime", ")", ",", "del_young_items", "=", "True", ")", "# if item enters system after lasttime, < 0", "\n", "# # del items enters the system after lasttime, not available", "\n", "ob_uiT", "[", "u", "]", "[", "self", ".", "item_birthdate", ">=", "lasttime", "]", "=", "-", "1", "\n", "idx_i", ",", "idx_T", "=", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "np", ".", "arange", "(", "self", ".", "n_items", ")", "[", "self", ".", "item_birthdate", "<", "lasttime", "]", ":", "\n", "# before user enters system, not available", "\n", "                ", "idx_T", ".", "append", "(", "np", ".", "arange", "(", "smallestT_perI", "[", "i", "]", ")", ")", "\n", "idx_i", ".", "append", "(", "np", ".", "full", "(", "smallestT_perI", "[", "i", "]", ",", "i", ")", ")", "\n", "# after user leaves system, not available", "\n", "idx_T", ".", "append", "(", "np", ".", "arange", "(", "biggestT_perI", "[", "i", "]", "+", "1", ",", "self", ".", "n_periods", ")", ")", "\n", "idx_i", ".", "append", "(", "np", ".", "full", "(", "self", ".", "n_periods", "-", "(", "biggestT_perI", "[", "i", "]", "+", "1", ")", ",", "i", ")", ")", "\n", "", "if", "len", "(", "idx_i", ")", ">", "0", ":", "\n", "                ", "idx_i", "=", "np", ".", "concatenate", "(", "idx_i", ")", "\n", "idx_T", "=", "np", ".", "concatenate", "(", "idx_T", ")", "\n", "ob_uiT", "[", "u", "]", "[", "idx_i", ",", "idx_T", "]", "=", "-", "1", "\n", "# set pos = 1, (u, i, itemage)", "\n", "", "", "users", ",", "items", "=", "ratings", "[", "'UserId'", "]", ",", "ratings", "[", "'ItemId'", "]", "\n", "itemages", "=", "self", ".", "get_itemage", "(", "ratings", "[", "'ItemId'", "]", ",", "ratings", "[", "'timestamp'", "]", ")", "\n", "targets", "=", "np", ".", "ones_like", "(", "users", ",", "dtype", "=", "int", ")", "\n", "ob_uiT", "[", "users", ",", "items", ",", "itemages", "]", "=", "1", "\n", "\n", "# negs", "\n", "users_neg", ",", "items_neg", ",", "itemages_neg", "=", "np", ".", "where", "(", "ob_uiT", "==", "0", ")", "\n", "assert", "users_neg", ".", "shape", "==", "items_neg", ".", "shape", "\n", "targets_neg", "=", "np", ".", "zeros_like", "(", "users_neg", ",", "dtype", "=", "int", ")", "\n", "\n", "# merge pos and neg", "\n", "users", "=", "np", ".", "concatenate", "(", "(", "users", ",", "users_neg", ")", ",", "axis", "=", "0", ")", "\n", "items", "=", "np", ".", "concatenate", "(", "(", "items", ",", "items_neg", ")", ",", "axis", "=", "0", ")", "\n", "itemages", "=", "np", ".", "concatenate", "(", "(", "itemages", ",", "itemages_neg", ")", ",", "axis", "=", "0", ")", "\n", "targets", "=", "np", ".", "concatenate", "(", "(", "targets", ",", "targets_neg", ")", ",", "axis", "=", "0", ")", "\n", "nums", "=", "users", ".", "shape", "[", "0", "]", "\n", "# numpy to pandas, cols = ['user', 'item', 'itemage', 'target']", "\n", "df", "=", "pd", ".", "DataFrame", "(", "{", "'user'", ":", "users", ",", "'item'", ":", "items", ",", "'itemage'", ":", "itemages", ",", "'target'", ":", "targets", "}", ")", "\n", "self", ".", "n_periods", "=", "min", "(", "self", ".", "n_periods", ",", "max", "(", "itemages", ")", "+", "1", ")", "\n", "\n", "# shuffle, split and save into file", "\n", "np", ".", "random", ".", "seed", "(", "2021", ")", "\n", "uniform_p", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "nums", ")", "\n", "# ratio = [0.7, 0.8, 1.0] # following 7:1:2 for train/valid/test splitting", "\n", "df_train", "=", "df", "[", "uniform_p", "<=", "0.7", "]", "\n", "df_valid", "=", "df", "[", "(", "uniform_p", ">", "0.7", ")", "&", "(", "uniform_p", "<=", "0.8", ")", "]", "\n", "df_test", "=", "df", "[", "uniform_p", ">", "0.8", "]", "\n", "assert", "(", "len", "(", "df_train", ")", "+", "len", "(", "df_valid", ")", "+", "len", "(", "df_test", ")", ")", "==", "len", "(", "df", ")", "\n", "print", "(", "\"Nr. in data, train, valid and test are %d, %d, %d and %d\"", "%", "(", "len", "(", "df", "[", "'target'", "]", ")", ",", "len", "(", "df_train", "[", "'target'", "]", ")", ",", "len", "(", "df_valid", "[", "'target'", "]", ")", ",", "len", "(", "df_test", "[", "'target'", "]", ")", ")", ")", "\n", "print", "(", "\"#o in data, train, valid and test are %d, %d, %d and %d\"", "%", "(", "df", "[", "'target'", "]", ".", "sum", "(", ")", ",", "df_train", "[", "'target'", "]", ".", "sum", "(", ")", ",", "df_valid", "[", "'target'", "]", ".", "sum", "(", ")", ",", "df_test", "[", "'target'", "]", ".", "sum", "(", ")", ")", ")", "\n", "print", "(", "\"p(o) in data, train, valid and test are %.4f, %.4f, %.4f and %.4f\"", "%", "(", "df", "[", "'target'", "]", ".", "mean", "(", ")", ",", "df_train", "[", "'target'", "]", ".", "mean", "(", ")", ",", "df_valid", "[", "'target'", "]", ".", "mean", "(", ")", ",", "df_test", "[", "'target'", "]", ".", "mean", "(", ")", ")", ")", "\n", "df_train", ".", "to_csv", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/train_random_OIPT.csv'", ",", "index", "=", "False", ")", "\n", "df_valid", ".", "to_csv", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/valid_random_OIPT.csv'", ",", "index", "=", "False", ")", "\n", "df_test", ".", "to_csv", "(", "self", ".", "path", "+", "self", ".", "dataset", "+", "'/test_random_OIPT.csv'", ",", "index", "=", "False", ")", "\n", "print", "(", "\"Saving randomly-splitted dataset. Done.\"", ")", "\n", "return", "self", ".", "_df2interactions", "(", "df_train", ")", ",", "self", ".", "_df2interactions", "(", "df_valid", ")", ",", "self", ".", "_df2interactions", "(", "df_test", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._df2interactions": [[566, 574], ["len"], "methods", ["None"], ["", "def", "_df2interactions", "(", "self", ",", "df", ")", ":", "\n", "        ", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "df", "[", "'user'", "]", ".", "values", "\n", "interaction", "[", "'item'", "]", "=", "df", "[", "'item'", "]", ".", "values", "\n", "interaction", "[", "'itemage'", "]", "=", "df", "[", "'itemage'", "]", ".", "values", "\n", "interaction", "[", "'target'", "]", "=", "df", "[", "'target'", "]", ".", "values", "\n", "interaction", "[", "'num'", "]", "=", "len", "(", "df", ")", "\n", "return", "interaction", "\n", "", "", ""]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.AbstractEvaluator.__init__": [[154, 160], ["torch.device", "model.to", "torch.cuda.is_available"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "self", ".", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "if", "model", "is", "not", "None", ":", "\n", "            ", "self", ".", "model", "=", "model", ".", "to", "(", "self", ".", "device", ")", "\n", "", "self", ".", "config", "=", "config", "\n", "self", ".", "data", "=", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.AbstractEvaluator._check_args": [[161, 164], ["None"], "methods", ["None"], ["", "def", "_check_args", "(", "self", ")", ":", "\n", "        ", "\"\"\"check the correct of the setting\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.AbstractEvaluator.collect": [[165, 168], ["None"], "methods", ["None"], ["", "def", "collect", "(", "self", ")", ":", "\n", "        ", "\"\"\"get the intermediate results for each batch, it is called at the end of each batch\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.AbstractEvaluator.evaluate": [[169, 172], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"calculate the metrics of all batches, it is called at the end of each epoch\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.AbstractEvaluator.metrics_info": [[173, 176], ["None"], "methods", ["None"], ["", "def", "metrics_info", "(", "self", ")", ":", "\n", "        ", "\"\"\"get metrics result\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.AbstractEvaluator._calculate_metrics": [[177, 180], ["None"], "methods", ["None"], ["", "def", "_calculate_metrics", "(", "self", ")", ":", "\n", "        ", "\"\"\" to calculate the metrics\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.AbstractEvaluator._merge_interactions": [[181, 190], ["list", "set", "set", "torch.cat", "inte1.keys", "inte2.keys"], "methods", ["None"], ["", "def", "_merge_interactions", "(", "self", ",", "inte1", ",", "inte2", ")", ":", "\n", "        ", "inte_", "=", "{", "}", "\n", "keys", "=", "list", "(", "set", "(", "inte1", ".", "keys", "(", ")", ")", "&", "set", "(", "inte2", ".", "keys", "(", ")", ")", ")", "\n", "for", "key", "in", "keys", ":", "\n", "            ", "if", "key", "==", "'num'", ":", "\n", "                ", "inte_", "[", "key", "]", "=", "inte1", "[", "key", "]", "+", "inte2", "[", "key", "]", "\n", "", "else", ":", "\n", "                ", "inte_", "[", "key", "]", "=", "torch", ".", "cat", "(", "(", "inte1", "[", "key", "]", ",", "inte2", "[", "key", "]", ")", ",", "0", ")", "\n", "", "", "return", "inte_", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.AbstractEvaluator._numpy2tensor": [[191, 196], ["interaction.keys", "torch.from_numpy().to", "torch.from_numpy"], "methods", ["None"], ["", "def", "_numpy2tensor", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "for", "k", "in", "interaction", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "!=", "'num'", ":", "\n", "                ", "interaction", "[", "k", "]", "=", "torch", ".", "from_numpy", "(", "interaction", "[", "k", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.Evaluator.__init__": [[198, 201], ["evaluator.AbstractEvaluator.__init__"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "Evaluator", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "self", ".", "max_item_list_len", "=", "20", "# config['max_item_list_len']", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.Evaluator._data_pre_fullseq": [[202, 236], ["dict", "dict", "train.groupby", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "numpy.array", "zip", "zip", "group.sort_values", "len", "torch.from_numpy().to.append", "numpy.array.append", "torch.from_numpy().to.append", "torch.from_numpy().to.size", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "list"], "methods", ["None"], ["", "def", "_data_pre_fullseq", "(", "self", ",", "train_full", ",", "test", ")", ":", "\n", "        ", "train", "=", "train_full", "\n", "n_items", "=", "self", ".", "data", ".", "n_items", "\n", "uid_list", ",", "seq_list", ",", "seq_len", ",", "ctr_target", ",", "target", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "u_target", "=", "dict", "(", "zip", "(", "test", "[", "'UserId'", "]", ",", "test", "[", "'ItemId'", "]", ")", ")", "\n", "u_ctr", "=", "dict", "(", "zip", "(", "test", "[", "'UserId'", "]", ",", "test", "[", "'ctr'", "]", ")", ")", "\n", "for", "u", ",", "group", "in", "train", ".", "groupby", "(", "[", "'UserId'", "]", ")", ":", "\n", "            ", "u_ratings", "=", "group", ".", "sort_values", "(", "[", "'timestamp'", "]", ",", "ascending", "=", "True", ")", "\n", "u_items", "=", "u_ratings", "[", "'ItemId'", "]", ".", "values", "\n", "u_n_items", "=", "len", "(", "u_items", ")", "\n", "target", ".", "append", "(", "u_target", "[", "u", "]", ")", "\n", "ctr_target", ".", "append", "(", "u_ctr", "[", "u", "]", ")", "\n", "uid_list", ".", "append", "(", "u", ")", "\n", "if", "u_n_items", ">=", "self", ".", "max_item_list_len", ":", "\n", "                ", "seq_list", ".", "append", "(", "u_items", "[", "-", "self", ".", "max_item_list_len", ":", "]", ")", "\n", "seq_len", ".", "append", "(", "self", ".", "max_item_list_len", ")", "\n", "", "else", ":", "\n", "                ", "padding_list", "=", "[", "n_items", "]", "*", "(", "self", ".", "max_item_list_len", "-", "u_n_items", ")", "\n", "seq_list", ".", "append", "(", "list", "(", "u_items", ")", "+", "padding_list", ")", "\n", "seq_len", ".", "append", "(", "u_n_items", ")", "\n", "", "", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "uid_list", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "seq_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "seq_list", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "seq_len", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "seq_len", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "target", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# ctr_target = torch.from_numpy(np.array(ctr_target, dtype=float)).to(self.device)", "\n", "ctr_target", "=", "np", ".", "array", "(", "ctr_target", ",", "dtype", "=", "float", ")", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'seq'", "]", "=", "seq_list", "\n", "interaction", "[", "'seq_len'", "]", "=", "seq_len", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "# interaction['ctr'] = ctr_target", "\n", "assert", "seq_list", ".", "size", "(", ")", "[", "0", "]", "==", "seq_len", ".", "size", "(", ")", "[", "0", "]", "\n", "interaction", "[", "'num'", "]", "=", "seq_list", ".", "size", "(", ")", "[", "0", "]", "\n", "return", "interaction", ",", "ctr_target", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.Evaluator.evaluate": [[237, 251], ["evaluator.Evaluator._data_pre_fullseq", "evaluator.Evaluator.model.full_sort_predict", "torch.gather", "print", "targets.view", "ub.lower", "evaluator.calculate_metrics", "evaluator.calculate_metrics", "target_pos.cpu().numpy", "target_pos.cpu().numpy", "str", "target_pos.cpu", "target_pos.cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.Seq_Trainer._data_pre_fullseq", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.full_sort_predict", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.calculate_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.calculate_metrics"], ["", "def", "evaluate", "(", "self", ",", "ub", "=", "'false'", ",", "threshold", "=", "1e-3", ")", ":", "\n", "        ", "''' ub: unbiased evaluator'''", "\n", "interaction", ",", "ctr_target", "=", "self", ".", "_data_pre_fullseq", "(", "self", ".", "data", ".", "train_full", ",", "self", ".", "data", ".", "test", ")", "\n", "# results", "\n", "scores", "=", "self", ".", "model", ".", "full_sort_predict", "(", "interaction", ")", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "target_scores", "=", "torch", ".", "gather", "(", "scores", ",", "1", ",", "targets", ".", "view", "(", "-", "1", ",", "1", ")", ")", "# [B 1]", "\n", "target_pos", "=", "(", "scores", ">=", "target_scores", ")", ".", "sum", "(", "-", "1", ")", "# [B]", "\n", "if", "ub", ".", "lower", "(", ")", "in", "[", "'snips'", ",", "'pop'", ",", "'unpop'", "]", ":", "\n", "            ", "results", "=", "calculate_metrics", "(", "target_pos", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "weight", "=", "ctr_target", ",", "normalization", "=", "ub", ",", "threshold", "=", "threshold", ")", "\n", "", "else", ":", "\n", "            ", "results", "=", "calculate_metrics", "(", "target_pos", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "print", "(", "\"results on testset: %s\"", "%", "(", "str", "(", "results", ")", ")", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.RatPred_Evaluator.__init__": [[255, 257], ["evaluator.AbstractEvaluator.__init__"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "RatPred_Evaluator", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.RatPred_Evaluator._data_pre": [[258, 272], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to.size", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "_data_pre", "(", "self", ",", "test", ")", ":", "\n", "        ", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "iid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'rating'", "]", ".", "values", ",", "dtype", "=", "float", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "itemage", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'ItemAge'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "uid_list", "\n", "interaction", "[", "'item'", "]", "=", "iid_list", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'itemage'", "]", "=", "itemage", "\n", "\n", "interaction", "[", "'num'", "]", "=", "uid_list", ".", "size", "(", ")", "[", "0", "]", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.RatPred_Evaluator.evaluate": [[273, 283], ["torch.no_grad", "evaluator.RatPred_Evaluator._data_pre", "evaluator.RatPred_Evaluator.model.predict", "evaluator.cal_ratpred_metrics", "print", "evaluator.RatPred_Evaluator.cpu().numpy", "targets.cpu().numpy", "str", "evaluator.RatPred_Evaluator.cpu", "targets.cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.predict", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_ratpred_metrics"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "evaluate", "(", "self", ",", "ub", "=", "'false'", ",", "threshold", "=", "1e-3", ")", ":", "\n", "        ", "''' ub: unbiased evaluator'''", "\n", "interaction", "=", "self", ".", "_data_pre", "(", "self", ".", "data", ".", "test", ")", "\n", "# results", "\n", "scores", "=", "self", ".", "model", ".", "predict", "(", "interaction", ")", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "results", "=", "cal_ratpred_metrics", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "targets", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "print", "(", "\"results on testset: %s\"", "%", "(", "str", "(", "results", ")", ")", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator.__init__": [[288, 308], ["evaluator.AbstractEvaluator.__init__", "torch.from_numpy().to", "evaluator.OP_Evaluator._get_trainU_last", "torch.from_numpy", "evaluator.OP_Evaluator.data._get_item_birthdate"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._get_trainU_last", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._get_item_birthdate"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "OP_Evaluator", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "self", ".", "splitting", "=", "config", "[", "'splitting'", "]", "\n", "\n", "self", ".", "n_items", "=", "self", ".", "data", ".", "n_items", "\n", "self", ".", "n_users", "=", "self", ".", "data", ".", "n_users", "\n", "self", ".", "n_periods", "=", "self", ".", "data", ".", "n_periods", "\n", "\n", "# self.item_birthdate = torch.from_numpy(self.data._get_item_birthdate()).to(self.device)", "\n", "if", "self", ".", "splitting", "!=", "'random'", ":", "\n", "            ", "self", ".", "item_birthdate", "=", "torch", ".", "from_numpy", "(", "self", ".", "data", ".", "_get_item_birthdate", "(", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# get last timestamp of user in the system from the training set, and evaluate on the next one-month", "\n", "self", ".", "user_lasttime_train", "=", "self", ".", "_get_trainU_last", "(", ")", "\n", "self", ".", "test_user_pos", "=", "{", "}", "# filled when we call _data_pre_next_month()", "\n", "self", ".", "period_type", "=", "self", ".", "data", ".", "period_type", "\n", "if", "self", ".", "period_type", "==", "'month'", ":", "\n", "                ", "self", ".", "period_s", "=", "30", "*", "24", "*", "60", "*", "60", "\n", "", "elif", "self", ".", "period_type", "==", "'year'", ":", "\n", "                ", "self", ".", "period_s", "=", "365", "*", "24", "*", "60", "*", "60", "\n", "# torch.manual_seed(517)", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._get_trainU_last": [[311, 318], ["numpy.zeros", "train.groupby", "max"], "methods", ["None"], ["", "", "", "def", "_get_trainU_last", "(", "self", ")", ":", "\n", "        ", "train", "=", "self", ".", "data", ".", "train_full", "\n", "user_lasttime_train", "=", "np", ".", "zeros", "(", "self", ".", "n_users", ")", "\n", "for", "u", ",", "group", "in", "train", ".", "groupby", "(", "by", "=", "[", "'UserId'", "]", ")", ":", "\n", "            ", "lasttime", "=", "max", "(", "group", "[", "'timestamp'", "]", ")", "\n", "user_lasttime_train", "[", "u", "]", "=", "lasttime", "\n", "", "return", "user_lasttime_train", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._filter_test_next_month": [[320, 329], ["len", "print", "len", "len"], "methods", ["None"], ["", "def", "_filter_test_next_month", "(", "self", ")", ":", "\n", "        ", "test", "=", "self", ".", "data", ".", "test", "\n", "user_lasttime_test", "=", "self", ".", "user_lasttime_train", "+", "self", ".", "period_s", "\n", "lasttime_test", "=", "user_lasttime_test", "[", "test", "[", "'UserId'", "]", "]", "\n", "n_test", "=", "len", "(", "test", ")", "\n", "test", "=", "test", "[", "test", "[", "'timestamp'", "]", "<=", "lasttime_test", "]", "\n", "print", "(", "\"Filter %d interactions which do not happend in next month since last interaction in training, \\\n            in total %d ratings observed in testset\"", "%", "(", "n_test", "-", "len", "(", "test", ")", ",", "len", "(", "test", ")", ")", ")", "\n", "return", "test", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._data_pre_next_month": [[330, 350], ["evaluator.OP_Evaluator._filter_test_next_month", "torch.from_numpy().to", "torch.from_numpy().to", "torch.ones_like().to", "torch.from_numpy().to", "torch.from_numpy().to", "evaluator.OP_Evaluator.groupby", "torch.from_numpy().to.size", "torch.from_numpy", "torch.from_numpy", "torch.ones_like", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._filter_test_next_month"], ["", "def", "_data_pre_next_month", "(", "self", ")", ":", "\n", "        ", "test", "=", "self", ".", "_filter_test_next_month", "(", ")", "\n", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "iid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "ones_like", "(", "iid_list", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "itemage", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'ItemAge'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "timestamp", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'timestamp'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "uid_list", "\n", "interaction", "[", "'item'", "]", "=", "iid_list", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'itemage'", "]", "=", "itemage", "\n", "interaction", "[", "'timestamp'", "]", "=", "timestamp", "\n", "interaction", "[", "'num'", "]", "=", "uid_list", ".", "size", "(", ")", "[", "0", "]", "\n", "\n", "for", "u", ",", "group", "in", "test", ".", "groupby", "(", "by", "=", "[", "'UserId'", "]", ")", ":", "\n", "            ", "self", ".", "test_user_pos", "[", "u", "]", "=", "group", "[", "'ItemId'", "]", ".", "values", "\n", "\n", "", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._neg_sampling_next_month": [[351, 405], ["evaluator.OP_Evaluator._filter_test_next_month", "evaluator.OP_Evaluator.groupby", "numpy.concatenate", "numpy.concatenate", "evaluator.OP_Evaluator.data.get_itemage", "evaluator.OP_Evaluator.data.get_itemage", "print", "numpy.concatenate().astype", "torch.from_numpy().to", "numpy.concatenate().astype", "torch.from_numpy().to", "torch.cat().to", "evaluator.OP_Evaluator.data.get_itemage", "numpy.concatenate", "torch.from_numpy().to", "print", "numpy.random.uniform", "numpy.concatenate().astype.append", "numpy.concatenate().astype.append", "len", "len", "len", "len", "len", "len", "numpy.repeat", "numpy.concatenate", "torch.from_numpy", "numpy.concatenate", "torch.from_numpy", "torch.cat", "torch.from_numpy", "numpy.arange", "numpy.argsort", "len", "str", "torch.ones", "torch.zeros", "target[].cpu().numpy().mean", "range", "len", "target[].cpu().numpy", "target[].cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._filter_test_next_month", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage"], ["", "def", "_neg_sampling_next_month", "(", "self", ",", "K", "=", "1", ",", "full_negs", "=", "True", ")", ":", "\n", "# filter the data and keep one-month interactions", "\n", "        ", "test", "=", "self", ".", "_filter_test_next_month", "(", ")", "\n", "\n", "# period_s = 15 * 24 * 60 * 60 # for the negatives, we use the middle date of next one month/year (period) as timestamp", "\n", "user_time_negs", "=", "self", ".", "user_lasttime_train", "+", "self", ".", "period_s", "/", "2.0", "\n", "# negatives", "\n", "users", ",", "items", "=", "[", "]", ",", "[", "]", "\n", "for", "u", ",", "group", "in", "test", ".", "groupby", "(", "by", "=", "[", "'UserId'", "]", ")", ":", "\n", "            ", "pos_items", "=", "group", "[", "'ItemId'", "]", ".", "values", "\n", "neg_prob", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "size", "=", "(", "self", ".", "n_items", ",", ")", ")", "\n", "neg_prob", "[", "pos_items", "]", "=", "-", "1.", "\n", "# delete the items published after user last interaction in training set", "\n", "neg_prob", "[", "self", ".", "data", ".", "item_birthdate", ">=", "self", ".", "user_lasttime_train", "[", "u", "]", "]", "=", "-", "1.", "\n", "if", "full_negs", ":", "\n", "                ", "neg_items", "=", "np", ".", "arange", "(", "self", ".", "n_items", ")", "[", "neg_prob", ">=", "0.0", "]", "\n", "", "else", ":", "\n", "                ", "neg_items", "=", "np", ".", "argsort", "(", "neg_prob", ")", "[", "-", "len", "(", "pos_items", ")", ":", "]", "\n", "", "users", ".", "append", "(", "np", ".", "repeat", "(", "u", ",", "len", "(", "neg_items", ")", ")", ")", "\n", "items", ".", "append", "(", "neg_items", ")", "\n", "", "users", "=", "np", ".", "concatenate", "(", "users", ",", "axis", "=", "0", ")", "\n", "items", "=", "np", ".", "concatenate", "(", "items", ",", "axis", "=", "0", ")", "\n", "timestamps", "=", "user_time_negs", "[", "users", "]", "\n", "# print(timestamps.astype('datetime64[s]'))", "\n", "# print(items)", "\n", "# print(self.data.item_birthdate[items].astype('datetime64[s]'))", "\n", "itemage_neg", "=", "self", ".", "data", ".", "get_itemage", "(", "items", ",", "timestamps", ")", "\n", "\n", "# print(\"******** Fake test, using +5 month **********\")", "\n", "# itemage_neg = np.clip(itemage_neg+5, 0, self.data.n_periods - 1)", "\n", "itemage", "=", "self", ".", "data", ".", "get_itemage", "(", "test", "[", "'ItemId'", "]", ".", "values", ",", "test", "[", "'timestamp'", "]", ".", "values", ")", "\n", "assert", "len", "(", "users", ")", "==", "len", "(", "items", ")", "\n", "assert", "len", "(", "users", ")", "==", "len", "(", "itemage_neg", ")", "\n", "\n", "n_pos", ",", "n_neg", "=", "len", "(", "test", ")", ",", "len", "(", "users", ")", "\n", "print", "(", "\"#pos: %d, #neg: %d\"", "%", "(", "n_pos", ",", "n_neg", ")", ")", "\n", "users", "=", "np", ".", "concatenate", "(", "(", "test", "[", "'UserId'", "]", ".", "values", ",", "users", ")", ")", ".", "astype", "(", "int", ")", "\n", "uid_list", "=", "torch", ".", "from_numpy", "(", "users", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "items", "=", "np", ".", "concatenate", "(", "(", "test", "[", "'ItemId'", "]", ".", "values", ",", "items", ")", ")", ".", "astype", "(", "int", ")", "\n", "iid_list", "=", "torch", ".", "from_numpy", "(", "items", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "cat", "(", "(", "torch", ".", "ones", "(", "(", "n_pos", ",", ")", ")", ",", "torch", ".", "zeros", "(", "(", "n_neg", ",", ")", ")", ")", ",", "axis", "=", "0", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "itemage", "=", "self", ".", "data", ".", "get_itemage", "(", "test", "[", "'ItemId'", "]", ".", "values", ",", "test", "[", "'timestamp'", "]", ".", "values", ")", "\n", "itemages", "=", "np", ".", "concatenate", "(", "(", "itemage", ",", "itemage_neg", ")", ",", "axis", "=", "0", ")", "\n", "itemages", "=", "torch", ".", "from_numpy", "(", "itemages", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "print", "(", "\"The distributions of p_T in test set:\"", ",", "'\\n'", ",", "'['", ",", "', '", ".", "join", "(", "[", "str", "(", "target", "[", "itemages", "==", "t", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "mean", "(", ")", ")", "for", "t", "in", "range", "(", "self", ".", "n_periods", ")", "]", ")", ",", "']'", ")", "\n", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "uid_list", "\n", "interaction", "[", "'item'", "]", "=", "iid_list", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'itemage'", "]", "=", "itemages", "\n", "interaction", "[", "'num'", "]", "=", "n_pos", "+", "n_neg", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._data_pre": [[406, 424], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.ones_like().to", "torch.from_numpy().to", "evaluator.OP_Evaluator.data.get_itemage", "torch.from_numpy().to.size", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.ones_like", "numpy.array", "numpy.array", "numpy.array", "torch.from_numpy", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage"], ["", "def", "_data_pre", "(", "self", ",", "test", ")", ":", "\n", "        ", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "iid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "timestamp", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'timestamp'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "ones_like", "(", "iid_list", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "'ItemAge'", "in", "test", ".", "columns", ":", "\n", "            ", "itemage", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'ItemAge'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "itemage", "=", "self", ".", "data", ".", "get_itemage", "(", "iid_list", ",", "timestamp", ",", "self", ".", "item_birthdate", ")", "\n", "\n", "", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "uid_list", "\n", "interaction", "[", "'item'", "]", "=", "iid_list", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'itemage'", "]", "=", "itemage", "\n", "interaction", "[", "'timestamp'", "]", "=", "timestamp", "\n", "interaction", "[", "'num'", "]", "=", "uid_list", ".", "size", "(", ")", "[", "0", "]", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._neg_sampling": [[425, 444], ["torch.cat", "torch.randint().to", "torch.cat", "torch.cat", "evaluator.OP_Evaluator.data.get_itemage", "torch.cat", "torch.randint"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage"], ["", "def", "_neg_sampling", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "interaction_", "=", "{", "}", "\n", "users", "=", "interaction", "[", "'user'", "]", "\n", "items", "=", "interaction", "[", "'item'", "]", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "timestamp", "=", "interaction", "[", "'timestamp'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "\n", "# generate data for negs", "\n", "interaction_", "[", "'user'", "]", "=", "torch", ".", "cat", "(", "(", "users", ",", "users", ")", ",", "0", ")", "\n", "negs", "=", "torch", ".", "randint", "(", "self", ".", "n_items", ",", "size", "=", "(", "interaction", "[", "'num'", "]", ",", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction_", "[", "'item'", "]", "=", "torch", ".", "cat", "(", "(", "items", ",", "negs", ")", ",", "0", ")", "\n", "target_neg", "=", "(", "items", "==", "negs", ")", ".", "int", "(", ")", "\n", "interaction_", "[", "'target'", "]", "=", "torch", ".", "cat", "(", "(", "targets", ",", "target_neg", ")", ",", "0", ")", "\n", "itemage_neg", "=", "self", ".", "data", ".", "get_itemage", "(", "items", ",", "timestamp", ",", "self", ".", "item_birthdate", ")", "\n", "# itemage_neg = ((timestamp - self.item_birthdate[items]) * 1.0 / (30*24*60*60)).int().clip(0, self.data.n_months - 1) # unit: month", "\n", "interaction_", "[", "'itemage'", "]", "=", "torch", ".", "cat", "(", "(", "itemage", ",", "itemage_neg", ")", ",", "0", ")", "\n", "interaction_", "[", "'num'", "]", "=", "interaction", "[", "'num'", "]", "*", "2", "\n", "return", "interaction_", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._neg_sampling_timebased": [[445, 464], ["torch.cat", "torch.randint().to", "torch.cat", "torch.cat", "evaluator.OP_Evaluator.data.get_itemage", "torch.cat", "torch.randint"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage"], ["", "def", "_neg_sampling_timebased", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "interaction_", "=", "{", "}", "\n", "users", "=", "interaction", "[", "'user'", "]", "\n", "items", "=", "interaction", "[", "'item'", "]", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "timestamp", "=", "interaction", "[", "'timestamp'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "\n", "# generate data for negs", "\n", "interaction_", "[", "'user'", "]", "=", "torch", ".", "cat", "(", "(", "users", ",", "users", ")", ",", "0", ")", "\n", "negs", "=", "torch", ".", "randint", "(", "self", ".", "n_items", ",", "size", "=", "(", "interaction", "[", "'num'", "]", ",", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction_", "[", "'item'", "]", "=", "torch", ".", "cat", "(", "(", "items", ",", "negs", ")", ",", "0", ")", "\n", "target_neg", "=", "(", "items", "==", "negs", ")", ".", "int", "(", ")", "\n", "interaction_", "[", "'target'", "]", "=", "torch", ".", "cat", "(", "(", "targets", ",", "target_neg", ")", ",", "0", ")", "\n", "itemage_neg", "=", "self", ".", "data", ".", "get_itemage", "(", "items", ",", "timestamp", ",", "self", ".", "item_birthdate", ")", "\n", "# itemage_neg = ((timestamp - self.item_birthdate[items]) * 1.0 / (30*24*60*60)).int().clip(0, self.data.n_months - 1) # unit: month", "\n", "interaction_", "[", "'itemage'", "]", "=", "torch", ".", "cat", "(", "(", "itemage", ",", "itemage_neg", ")", ",", "0", ")", "\n", "interaction_", "[", "'num'", "]", "=", "interaction", "[", "'num'", "]", "*", "2", "\n", "return", "interaction_", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._data_random": [[465, 471], ["torch.randint().to", "torch.randint().to", "torch.randint().to", "torch.where().to", "torch.randint", "torch.randint", "torch.randint", "torch.where"], "methods", ["None"], ["", "def", "_data_random", "(", "self", ",", "num", "=", "1000", ")", ":", "\n", "        ", "users", "=", "torch", ".", "randint", "(", "self", ".", "data", ".", "n_users", ",", "size", "=", "(", "num", ",", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "items", "=", "torch", ".", "randint", "(", "self", ".", "n_items", ",", "size", "=", "(", "num", ",", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "itemage", "=", "torch", ".", "randint", "(", "self", ".", "n_periods", ",", "size", "=", "(", "num", ",", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "where", "(", "itemage", ">=", "0.5", "*", "self", ".", "n_periods", ",", "0", ",", "1", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "return", "{", "'user'", ":", "users", ",", "'item'", ":", "items", ",", "'target'", ":", "target", ",", "'itemage'", ":", "itemage", ",", "'num'", ":", "num", "}", "\n", "", "def", "_numpy2tensor", "(", "self", ",", "interaction", ")", ":", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._numpy2tensor": [[471, 476], ["interaction.keys", "torch.from_numpy().to", "torch.from_numpy"], "methods", ["None"], ["", "def", "_numpy2tensor", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "for", "k", "in", "interaction", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "!=", "'num'", ":", "\n", "                ", "interaction", "[", "k", "]", "=", "torch", ".", "from_numpy", "(", "interaction", "[", "k", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._eval_epoch": [[477, 493], ["torch.no_grad", "int", "range", "torch.cat", "numpy.ceil", "evaluator.OP_Evaluator.model.predict", "scores.append"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.predict"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_eval_epoch", "(", "self", ",", "interaction", ",", "batch_size", "=", "512", ")", ":", "\n", "        ", "users", "=", "interaction", "[", "'user'", "]", "\n", "items", "=", "interaction", "[", "'item'", "]", "\n", "# targets = interaction['target']", "\n", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "\n", "scores", "=", "[", "]", "\n", "num_batch", "=", "int", "(", "np", ".", "ceil", "(", "interaction", "[", "'num'", "]", "*", "1.0", "/", "batch_size", ")", ")", "\n", "for", "i_batch", "in", "range", "(", "num_batch", ")", ":", "\n", "            ", "start_idx", "=", "i_batch", "*", "batch_size", "\n", "end_idx", "=", "(", "i_batch", "+", "1", ")", "*", "batch_size", "\n", "score", "=", "self", ".", "model", ".", "predict", "(", "{", "'user'", ":", "users", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "items", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemages", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "scores", ".", "append", "(", "score", ")", "\n", "", "return", "torch", ".", "cat", "(", "scores", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator.evaluate": [[494, 540], ["torch.no_grad", "torch.manual_seed", "numpy.random.seed", "print", "evaluator.cal_op_metrics", "print", "evaluator.cal_ob_pred2ranking_metrics", "print", "evaluator.OP_Evaluator._numpy2tensor", "evaluator.OP_Evaluator._neg_sampling_next_month", "evaluator.OP_Evaluator.baselines", "evaluator.OP_Evaluator._eval_epoch", "print", "evaluator.OP_Evaluator.cpu().numpy", "targets.cpu().numpy", "cal_ob_pred2ranking_metrics.keys", "cal_ob_pred2ranking_metrics.keys", "int", "evaluator.OP_Evaluator.cpu", "targets.cpu", "str", "str", "len", "cal_ob_pred2ranking_metrics.values", "cal_ob_pred2ranking_metrics.values"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_op_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_ob_pred2ranking_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._numpy2tensor", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._neg_sampling_next_month", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator.baselines", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "evaluate", "(", "self", ",", "ub", "=", "'false'", ",", "threshold", "=", "1e-3", ",", "baselines", "=", "None", ",", "subset", "=", "None", ")", ":", "\n", "# # self._save_pred_OP()", "\n", "# self._save_something2_()", "\n", "# self._save_pred_OP(alldata=True) # target=1", "\n", "# exit(0)", "\n", "\n", "        ", "torch", ".", "manual_seed", "(", "517", ")", "\n", "np", ".", "random", ".", "seed", "(", "517", ")", "\n", "# ''' ub: unbiased evaluator'''", "\n", "# interaction_pro = self._data_pre(self.data.test)", "\n", "# interaction = interaction_pro", "\n", "# interaction = self._neg_sampling(interaction_pro)", "\n", "# # randomly generate the data to verify if time affects ?", "\n", "# interaction = self._data_random()", "\n", "\n", "# evaluate on testset with the interactions happening among next one-month per user", "\n", "if", "self", ".", "splitting", "==", "'random'", ":", "\n", "            ", "interaction", "=", "self", ".", "_numpy2tensor", "(", "self", ".", "data", ".", "test_interactions", ")", "\n", "", "else", ":", "\n", "            ", "interaction", "=", "self", ".", "_neg_sampling_next_month", "(", "full_negs", "=", "True", ")", "\n", "", "w_sigmoid", "=", "False", "\n", "\n", "# # results", "\n", "if", "baselines", "is", "not", "None", ":", "\n", "# # simple baselines", "\n", "            ", "assert", "baselines", "[", "0", "]", "==", "'b'", "\n", "scores", ",", "w_sigmoid", ",", "interaction", "=", "self", ".", "baselines", "(", "interaction", ",", "variety", "=", "int", "(", "baselines", "[", "1", "]", ")", ",", "subset", "=", "subset", ")", "# w_sigmoid means if we should do sigmoid later in cal_op_metrics.", "\n", "", "else", ":", "\n", "            ", "scores", "=", "self", ".", "_eval_epoch", "(", "interaction", ")", "\n", "if", "self", ".", "splitting", "!=", "'random'", ":", "# only for time-based splitting, because 4:1 splitting per user, eval in next year and most users exist for one year.", "\n", "                ", "scores", "/=", "4.0", "\n", "", "print", "(", "\"The chance to generate 1 is %.6f\"", "%", "(", "(", "scores", ">", "0.5", ")", ".", "sum", "(", ")", "*", "1.0", "/", "len", "(", "scores", ")", ")", ")", "\n", "# self._save_something(interaction)", "\n", "\n", "# print(\"the max score of the probability is \", torch.max(scores))", "\n", "# # evaluate it as a prediction task, but too many 0s", "\n", "", "print", "(", "\"results on testset:\"", ")", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "results", "=", "cal_op_metrics", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "targets", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "w_sigmoid", "=", "w_sigmoid", ")", "\n", "print", "(", "'\\t'", ".", "join", "(", "results", ".", "keys", "(", ")", ")", ",", "'\\n'", ",", "'\\t'", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "results", ".", "values", "(", ")", "]", ")", ")", "\n", "# evaluate it as a ranking task", "\n", "results", "=", "cal_ob_pred2ranking_metrics", "(", "interaction", ",", "scores", ")", "\n", "print", "(", "'\\t'", ".", "join", "(", "results", ".", "keys", "(", ")", ")", ",", "'\\n'", ",", "'\\t'", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "results", ".", "values", "(", ")", "]", ")", ")", "\n", "# print(\"results on testset: %s\" % (str(results)))", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._save_something": [[541, 552], ["torch.arange().to", "evaluator.OP_Evaluator.model.forward", "print", "torch.arange", "str", "evaluator.OP_Evaluator.cpu().numpy", "evaluator.OP_Evaluator.cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.forward"], ["", "def", "_save_something", "(", "self", ",", "interaction", ")", ":", "\n", "# # save itemage_obLabels", "\n", "# targets = interaction['target'].cpu().numpy()", "\n", "# itemages = interaction['itemage'].cpu().numpy()", "\n", "# df = pd.DataFrame(data={'target':targets, 'itemage':itemages})", "\n", "# df.to_csv('itemage_obLabels.csv', index=False)", "\n", "\n", "# # save the distribution of predicted scores sigmoid(W * T + b)", "\n", "        ", "itemages", "=", "torch", ".", "arange", "(", "self", ".", "n_periods", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "scores", "=", "self", ".", "model", ".", "forward", "(", "None", ",", "None", ",", "itemages", ")", "\n", "print", "(", "\"Scores at T [0 : 20): \"", ",", "', '", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._save_something2_": [[563, 577], ["range", "print", "exit", "len", "evaluator.OP_Evaluator._numpy2tensor", "evaluator.OP_Evaluator._eval_epoch().cpu().numpy", "evaluator.cal_op_metrics", "print", "pandas.DataFrame", "pandas.DataFrame.to_csv", "d[].cpu().numpy", "evaluator.OP_Evaluator._eval_epoch().cpu", "cal_op_metrics.keys", "d[].cpu", "str", "d[].cpu().numpy", "evaluator.OP_Evaluator._eval_epoch", "cal_op_metrics.values", "d[].cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._numpy2tensor", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_op_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch"], ["", "def", "_save_something2_", "(", "self", ")", ":", "\n", "# # Want to look at the distributions of P(O) on training set and testset respectly", "\n", "        ", "data_", "=", "[", "self", ".", "data", ".", "train_interactions", ",", "self", ".", "data", ".", "valid_interactions", ",", "self", ".", "data", ".", "test_interactions", "]", "\n", "name_", "=", "[", "'train'", ",", "'valid'", ",", "'test'", "]", "\n", "path", "=", "self", ".", "config", "[", "'path'", "]", "+", "'simulation'", "+", "'/predOP_%s_'", "+", "self", ".", "config", "[", "'mode'", "]", "+", "'3.csv'", "\n", "for", "i", "in", "range", "(", "len", "(", "name_", ")", ")", ":", "\n", "            ", "d", "=", "self", ".", "_numpy2tensor", "(", "data_", "[", "i", "]", ")", "\n", "scores", "=", "self", ".", "_eval_epoch", "(", "d", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "results", "=", "cal_op_metrics", "(", "scores", ",", "d", "[", "'target'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "print", "(", "\"Results on the %s data:\"", "%", "name_", "[", "i", "]", ",", "'\\t'", ".", "join", "(", "results", ".", "keys", "(", ")", ")", ",", "'\\n'", ",", "'\\t'", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "results", ".", "values", "(", ")", "]", ")", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", "=", "{", "'target'", ":", "d", "[", "'target'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "'predOP'", ":", "scores", "}", ")", "\n", "df", ".", "to_csv", "(", "path", "%", "name_", "[", "i", "]", ",", "sep", "=", "','", ",", "index", "=", "False", ")", "\n", "", "print", "(", "\"Check the distributions of predicted P(O) on train/valid/test sets.\"", ")", "\n", "exit", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator._save_pred_OP": [[578, 613], ["evaluator.OP_Evaluator._eval_epoch().cpu().numpy", "pandas.DataFrame.to_csv", "evaluator.cal_op_metrics", "print", "exit", "pandas.concat", "evaluator.OP_Evaluator._data_pre", "len", "len", "interaction[].cpu().numpy", "print", "print", "interaction[].cpu().numpy", "evaluator.OP_Evaluator._merge_interactions", "evaluator.OP_Evaluator._merge_interactions", "print", "pandas.DataFrame", "NotImplementedError", "evaluator.OP_Evaluator._eval_epoch().cpu", "cal_op_metrics.keys", "evaluator.OP_Evaluator._numpy2tensor", "evaluator.OP_Evaluator._numpy2tensor", "evaluator.OP_Evaluator._numpy2tensor", "interaction[].cpu", "len", "interaction[].cpu", "str", "interaction[].cpu().numpy", "interaction[].cpu().numpy", "interaction[].cpu().numpy", "interaction[].cpu().numpy", "evaluator.OP_Evaluator._eval_epoch", "cal_op_metrics.values", "interaction[].cpu", "interaction[].cpu", "interaction[].cpu", "interaction[].cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_op_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._merge_interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._merge_interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._numpy2tensor", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._numpy2tensor", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._numpy2tensor", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch"], ["", "def", "_save_pred_OP", "(", "self", ",", "alldata", "=", "False", ",", "target", "=", "None", ")", ":", "\n", "        ", "if", "not", "alldata", ":", "\n", "# only on the observed ratings for RQ2", "\n", "            ", "data", "=", "pd", ".", "concat", "(", "[", "self", ".", "data", ".", "train_full", ",", "self", ".", "data", ".", "test", "]", ",", "ignore_index", "=", "True", ")", "\n", "interaction", "=", "self", ".", "_data_pre", "(", "data", ")", "\n", "", "elif", "self", ".", "splitting", "==", "'random'", ":", "\n", "# for all the possible data used in RQ3", "\n", "            ", "interaction", "=", "self", ".", "_merge_interactions", "(", "self", ".", "_numpy2tensor", "(", "self", ".", "data", ".", "train_interactions", ")", ",", "self", ".", "_numpy2tensor", "(", "self", ".", "data", ".", "valid_interactions", ")", ")", "\n", "interaction", "=", "self", ".", "_merge_interactions", "(", "interaction", ",", "self", ".", "_numpy2tensor", "(", "self", ".", "data", ".", "test_interactions", ")", ")", "\n", "print", "(", "\"The total number of interactions is %d = %d + %d + %d\"", "%", "(", "interaction", "[", "'num'", "]", ",", "self", ".", "data", ".", "train_interactions", "[", "'num'", "]", ",", "self", ".", "data", ".", "valid_interactions", "[", "'num'", "]", ",", "self", ".", "data", ".", "test_interactions", "[", "'num'", "]", ")", ")", "\n", "data", "=", "pd", ".", "DataFrame", "(", "{", "'UserId'", ":", "interaction", "[", "'user'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "'ItemId'", ":", "interaction", "[", "'item'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "'itemage'", ":", "interaction", "[", "'itemage'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "'target'", ":", "interaction", "[", "'target'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "}", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Generate P(O) on all possible (u, i, t) during user presence only on randomly setting\"", ")", "\n", "\n", "", "scores", "=", "self", ".", "_eval_epoch", "(", "interaction", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "self", ".", "splitting", "!=", "'random'", ":", "\n", "            ", "scores", "/=", "4.0", "\n", "", "assert", "len", "(", "scores", ")", "==", "len", "(", "data", ")", "\n", "data", "[", "'predOP'", "]", "=", "scores", "\n", "if", "'ItemAge'", "not", "in", "data", ":", "\n", "            ", "data", "[", "'itemage'", "]", "=", "interaction", "[", "'itemage'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "if", "not", "alldata", ":", "\n", "            ", "path", "=", "self", ".", "config", "[", "'path'", "]", "+", "self", ".", "config", "[", "'dataset'", "]", "+", "'/predOP_'", "+", "self", ".", "config", "[", "'mode'", "]", "+", "'_rename.csv'", "\n", "print", "(", "\"--------- Save the predicted Observation Probabilities of all observed (u,i,t), Nr. %d ----------\"", "%", "interaction", "[", "'num'", "]", ")", "\n", "data", "=", "data", "[", "[", "'UserId'", ",", "'ItemId'", ",", "'rating'", ",", "'timestamp'", ",", "'itemage'", ",", "'predOP'", "]", "]", "\n", "", "else", ":", "\n", "            ", "path", "=", "self", ".", "config", "[", "'path'", "]", "+", "self", ".", "config", "[", "'dataset'", "]", "+", "'/predOP_'", "+", "self", ".", "config", "[", "'mode'", "]", "+", "'_rename.csv'", "# + '_small_0.1.csv'", "\n", "if", "target", "is", "not", "None", ":", "\n", "                ", "data", "=", "data", "[", "data", "[", "'target'", "]", "==", "target", "]", "\n", "", "data", "=", "data", "[", "[", "'UserId'", ",", "'ItemId'", ",", "'itemage'", ",", "'predOP'", "]", "]", "\n", "print", "(", "\"--------- Save the predicted Observation Probabilities of all possible (u,i,t), Nr. %d ----------\"", "%", "len", "(", "data", ")", ")", "\n", "", "data", ".", "to_csv", "(", "path", ",", "sep", "=", "','", ",", "header", "=", "True", ",", "index", "=", "False", ")", "\n", "results", "=", "cal_op_metrics", "(", "scores", ",", "interaction", "[", "'target'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "print", "(", "\"Results on the whole data:\"", ",", "'\\t'", ".", "join", "(", "results", ".", "keys", "(", ")", ")", ",", "'\\n'", ",", "'\\t'", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "results", ".", "values", "(", ")", "]", ")", ")", "\n", "exit", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OP_Evaluator.baselines": [[615, 706], ["torch.zeros_like().float().to", "interaction.keys", "print", "print", "print", "idx.sum", "torch.zeros_like().float", "targets.cpu().numpy().mean", "print", "scores[].cpu", "print", "range", "print", "torch.zeros_like", "targets.cpu().numpy", "scores[].cpu", "scores_T.append", "range", "range", "[].mean", "str", "range", "range", "targets.cpu", "len", "train_target[].mean", "len", "v.mean", "len", "train_target[].mean"], "methods", ["None"], ["", "def", "baselines", "(", "self", ",", "interaction", ",", "variety", "=", "1", ",", "subset", "=", "None", ")", ":", "# we should use the training set rather than test set.", "\n", "        ", "'''some simple baseline variety\n        B1: all scores equal to 0.0\n        B2: all scores equal to a fixed value, 0.005 or 0.00478 best\n        B3: scores for (u, i) at T equal to a fixed value (diff at diff T).  * Norm, 0.1 / 0.013641 best.\n        B4: scores for given (i, T) fixed.\n        --- Params ---\n        subset: the evaluation subset, if None we use all pos+negs, if pos we only use pos, else only negs\n        '''", "\n", "# # train only contains positives", "\n", "# if self.splitting == 'random':", "\n", "#     train = self.data.train_interactions", "\n", "# else:", "\n", "#     train = self.data.train_full", "\n", "train", "=", "self", ".", "data", ".", "train_interactions", "\n", "# train = self.data.train", "\n", "w_sigmoid", "=", "False", "# do not do sigmoid later in cal_op_metrics", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "if", "subset", "is", "not", "None", ":", "\n", "            ", "if", "subset", "==", "'pos'", ":", "\n", "                ", "print", "(", "\" ------ We only evaluate on the positives ----- \"", ")", "\n", "idx", "=", "targets", "==", "1", "\n", "", "else", ":", "\n", "                ", "print", "(", "\" ------ We only evaluate on the negatives ----- \"", ")", "\n", "idx", "=", "targets", "==", "0", "\n", "", "targets", "=", "targets", "[", "idx", "]", "\n", "interaction_", "=", "{", "'num'", ":", "idx", ".", "sum", "(", ")", ",", "'target'", ":", "targets", "}", "\n", "for", "key", "in", "interaction", ".", "keys", "(", ")", ":", "\n", "                ", "if", "key", "not", "in", "[", "'num'", ",", "'target'", "]", ":", "\n", "                    ", "interaction_", "[", "key", "]", "=", "interaction", "[", "key", "]", "[", "idx", "]", "\n", "", "", "interaction", "=", "interaction_", "\n", "", "scores", "=", "torch", ".", "zeros_like", "(", "targets", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "variety", "==", "1", ":", "\n", "            ", "print", "(", "\"****** Note we want to know what happened if we give all the predicted scores %.6f\"", "%", "(", "scores", "[", "0", "]", ".", "cpu", "(", ")", ")", ")", "\n", "", "elif", "variety", "==", "2", ":", "\n", "# scores += 0.006", "\n", "            ", "scores", "+=", "targets", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "mean", "(", ")", "\n", "# scores += len(train) * 1.0 / (self.n_users * self.n_items  * self.n_periods)", "\n", "print", "(", "\"****** Note we want to know what happened if we give all the predicted scores %.6f\"", "%", "(", "scores", "[", "0", "]", ".", "cpu", "(", ")", ")", ")", "\n", "", "elif", "variety", "==", "3", ":", "\n", "            ", "scores_T", "=", "[", "]", "\n", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "num_D", "=", "self", ".", "n_users", "*", "self", ".", "n_items", "\n", "norm", "=", "0.265", "#2.5 #0.1 / 0.013641", "\n", "print", "(", "\"We do normalization: %f\"", "%", "norm", ")", "\n", "for", "T", "in", "range", "(", "self", ".", "n_periods", ")", ":", "\n", "                ", "s_T", "=", "train", "[", "'target'", "]", "[", "train", "[", "'itemage'", "]", "==", "T", "]", ".", "mean", "(", ")", "*", "norm", "\n", "# if self.splitting == 'random':", "\n", "#     # s_T = train['target'][train['itemage'] == T].mean()", "\n", "#     s_T = targets[itemages == T].cpu().numpy().mean()", "\n", "# else:", "\n", "#     # # calculate in training set", "\n", "#     s_T = (train['ItemAge'] == T).sum() * 1. / num_D * norm", "\n", "# # calculate in test set", "\n", "# s_T = targets[itemages == T].mean() ", "\n", "scores", "[", "itemages", "==", "T", "]", "=", "s_T", "\n", "scores_T", ".", "append", "(", "s_T", ")", "\n", "", "print", "(", "\"****** Note we want to know what happened if we give all the predicted scores %s\"", "%", "str", "(", "scores_T", ")", ")", "\n", "", "elif", "variety", "==", "4", ":", "\n", "# itemages = interaction['itemage']", "\n", "# items = interaction['item']", "\n", "# num_D = self.n_users * self.n_items", "\n", "# s_iT = train.groupby(['ItemId', 'ItemAge']).size() * 1. / num_D", "\n", "# # norm = 0.012 / s_iT.mean()", "\n", "# print(\"We do normalization: %f\" % norm)", "\n", "# s_iT *= norm", "\n", "# for i, T in s_iT.index:", "\n", "#     scores[(items == i) & (itemages == T)] = s_iT[i, T]", "\n", "\n", "            ", "items", "=", "interaction", "[", "'item'", "]", "\n", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "train_i", "=", "train", "[", "'item'", "]", "\n", "train_ia", "=", "train", "[", "'itemage'", "]", "\n", "train_target", "=", "train", "[", "'target'", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "data", ".", "n_items", ")", ":", "\n", "                ", "if", "len", "(", "train_target", "[", "train_i", "==", "i", "]", ")", ">", "0", ":", "\n", "                    ", "scores", "[", "items", "==", "i", "]", "=", "train_target", "[", "train_i", "==", "i", "]", ".", "mean", "(", ")", "\n", "", "", "for", "i", "in", "range", "(", "self", ".", "data", ".", "n_items", ")", ":", "\n", "                ", "for", "ia", "in", "range", "(", "self", ".", "data", ".", "n_periods", ")", ":", "\n", "                    ", "v", "=", "train_target", "[", "(", "train_i", "==", "i", ")", "&", "(", "train_ia", "==", "ia", ")", "]", "\n", "if", "len", "(", "v", ")", ">", "0", ":", "\n", "                        ", "scores", "[", "(", "items", "==", "i", ")", "&", "(", "itemages", "==", "ia", ")", "]", "=", "v", ".", "mean", "(", ")", "\n", "\n", "", "", "", "", "elif", "variety", "==", "5", ":", "# pop_i", "\n", "            ", "items", "=", "interaction", "[", "'item'", "]", "\n", "train_i", "=", "train", "[", "'item'", "]", "\n", "train_target", "=", "train", "[", "'target'", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "data", ".", "n_items", ")", ":", "\n", "                ", "if", "len", "(", "train_target", "[", "train_i", "==", "i", "]", ")", ">", "0", ":", "\n", "                    ", "scores", "[", "items", "==", "i", "]", "=", "train_target", "[", "train_i", "==", "i", "]", ".", "mean", "(", ")", "\n", "", "", "", "return", "scores", ",", "w_sigmoid", ",", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OPPT_Evaluator.__init__": [[809, 824], ["evaluator.AbstractEvaluator.__init__", "torch.from_numpy().to", "torch.from_numpy", "evaluator.OPPT_Evaluator.data._get_item_birthdate"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._get_item_birthdate"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "OPPT_Evaluator", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "\n", "self", ".", "n_items", "=", "self", ".", "data", ".", "n_items", "\n", "self", ".", "n_users", "=", "self", ".", "data", ".", "n_users", "\n", "self", ".", "n_periods", "=", "self", ".", "data", ".", "n_periods", "\n", "self", ".", "item_birthdate", "=", "torch", ".", "from_numpy", "(", "self", ".", "data", ".", "_get_item_birthdate", "(", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "self", ".", "period_type", "=", "self", ".", "data", ".", "period_type", "\n", "if", "self", ".", "period_type", "==", "'month'", ":", "\n", "            ", "self", ".", "period_s", "=", "30", "*", "24", "*", "60", "*", "60", "\n", "", "elif", "self", ".", "period_type", "==", "'year'", ":", "\n", "            ", "self", ".", "period_s", "=", "365", "*", "24", "*", "60", "*", "60", "\n", "\n", "", "self", ".", "debiasing", "=", "config", "[", "'debiasing'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OPPT_Evaluator._data_pre": [[825, 847], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to.size", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "torch.from_numpy", "numpy.array"], "methods", ["None"], ["", "def", "_data_pre", "(", "self", ")", ":", "\n", "        ", "self", ".", "test", "=", "self", ".", "data", ".", "test", "\n", "test", "=", "self", ".", "test", "\n", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "iid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# target = torch.from_numpy(np.where(test['rating'].values > 3, 1, 0).astype(int)).to(self.device) # rating>3 like=1, <=3 dislike=0", "\n", "target", "=", "torch", ".", "from_numpy", "(", "test", "[", "'rating'", "]", ".", "values", ")", ".", "to", "(", "self", ".", "device", ")", "# rating>3 like=1, <=3 dislike=0", "\n", "itemage", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'ItemAge'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "timestamp", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'timestamp'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "self", ".", "debiasing", ":", "\n", "            ", "predOP", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "test", "[", "'predOP'", "]", ".", "values", ",", "dtype", "=", "float", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "uid_list", "\n", "interaction", "[", "'item'", "]", "=", "iid_list", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'itemage'", "]", "=", "itemage", "\n", "interaction", "[", "'timestamp'", "]", "=", "timestamp", "\n", "interaction", "[", "'num'", "]", "=", "uid_list", ".", "size", "(", ")", "[", "0", "]", "\n", "if", "self", ".", "debiasing", ":", "\n", "            ", "interaction", "[", "'predOP'", "]", "=", "predOP", "\n", "", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OPPT_Evaluator._eval_epoch": [[848, 865], ["torch.no_grad", "torch.cat", "evaluator.OPPT_Evaluator.model.predict", "scores.append"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.predict"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_eval_epoch", "(", "self", ",", "interaction", ",", "batch_size", "=", "512", ")", ":", "\n", "        ", "users", "=", "interaction", "[", "'user'", "]", "\n", "items", "=", "interaction", "[", "'item'", "]", "\n", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "num", "=", "interaction", "[", "'num'", "]", "\n", "scores", "=", "[", "]", "\n", "start_idx", ",", "end_idx", "=", "0", ",", "batch_size", "\n", "while", "start_idx", "<", "num", ":", "\n", "            ", "score", "=", "self", ".", "model", ".", "predict", "(", "{", "'user'", ":", "users", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "items", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemages", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "# print(score)", "\n", "# exit(0)", "\n", "scores", ".", "append", "(", "score", ")", "\n", "start_idx", "=", "end_idx", "\n", "end_idx", "+=", "batch_size", "\n", "", "return", "torch", ".", "cat", "(", "scores", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OPPT_Evaluator.evaluate": [[866, 886], ["torch.no_grad", "evaluator.OPPT_Evaluator._data_pre", "evaluator.cal_ratpred_metrics", "print", "evaluator.OPPT_Evaluator.baselines", "evaluator.OPPT_Evaluator._eval_epoch", "interaction[].cpu().numpy", "evaluator.OPPT_Evaluator.cpu().numpy", "targets.cpu().numpy", "interaction[].cpu().numpy", "cal_ratpred_metrics.keys", "int", "interaction[].cpu", "evaluator.OPPT_Evaluator.cpu", "targets.cpu", "str", "interaction[].cpu", "cal_ratpred_metrics.values"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_ratpred_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator.baselines", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "evaluate", "(", "self", ",", "ub", "=", "'false'", ",", "threshold", "=", "1e-3", ",", "baselines", "=", "None", ",", "subset", "=", "None", ")", ":", "\n", "# self._save_pred_ratings()", "\n", "\n", "        ", "interaction", "=", "self", ".", "_data_pre", "(", ")", "\n", "if", "baselines", "is", "not", "None", ":", "\n", "            ", "scores", "=", "self", ".", "baselines", "(", "interaction", ",", "variety", "=", "int", "(", "baselines", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "scores", "=", "self", ".", "_eval_epoch", "(", "interaction", ")", "\n", "", "targets", "=", "interaction", "[", "'target'", "]", "\n", "predOP", "=", "None", "\n", "if", "self", ".", "debiasing", ":", "\n", "            ", "predOP", "=", "interaction", "[", "'predOP'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "# np.reciprocal(interaction['predOP'].cpu().numpy()) # IPS weighting", "\n", "", "results", "=", "cal_ratpred_metrics", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "targets", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "predOP", "=", "predOP", ",", "users", "=", "interaction", "[", "'user'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "# for i in range(50):", "\n", "#     print(round(scores.cpu().numpy()[i], 2), targets.cpu().numpy()[i], abs(scores.cpu().numpy()[i]-targets.cpu().numpy()[i])<=0.5, predOP[i])", "\n", "print", "(", "'\\t'", ".", "join", "(", "results", ".", "keys", "(", ")", ")", ",", "'\\n'", ",", "'\\t'", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "results", ".", "values", "(", ")", "]", ")", ")", "\n", "\n", "# self._save_something(preds=scores.cpu().numpy())", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OPPT_Evaluator.baselines": [[888, 927], ["torch.zeros_like().float().to", "train[].mean", "print", "torch.zeros_like().float", "range", "print", "scores[].cpu", "targets[].cpu().numpy().mean", "scores_T.append", "range", "range", "torch.zeros_like", "str", "[].mean", "range", "range", "targets[].cpu().numpy", "[].mean", "[].mean", "targets[].cpu"], "methods", ["None"], ["", "def", "baselines", "(", "self", ",", "interaction", ",", "variety", "=", "1", ")", ":", "\n", "        ", "'''some simple baseline variety\n        B2: all scores equal to a fixed value, avg-ratings over all.\n        B3: scores for (u, i) at T equal to a fixed value (diff at diff T), avg-ratings at T\n        '''", "\n", "train", "=", "self", ".", "data", ".", "train_full", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "scores", "=", "torch", ".", "zeros_like", "(", "targets", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "variety", "==", "2", ":", "\n", "            ", "scores", "+=", "train", "[", "'rating'", "]", ".", "mean", "(", ")", "\n", "print", "(", "\"****** Note we want to know what happened if we give all the predicted scores %.6f\"", "%", "(", "scores", "[", "0", "]", ".", "cpu", "(", ")", ")", ")", "\n", "", "elif", "variety", "==", "3", ":", "\n", "            ", "scores_T", "=", "[", "]", "\n", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "for", "T", "in", "range", "(", "self", ".", "n_periods", ")", ":", "\n", "# # calculate in training set", "\n", "# s_T = train[train['ItemAge'] == T]['rating'].mean()", "\n", "# # calculate in test set", "\n", "                ", "s_T", "=", "targets", "[", "itemages", "==", "T", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "mean", "(", ")", "\n", "scores", "[", "itemages", "==", "T", "]", "=", "s_T", "\n", "scores_T", ".", "append", "(", "s_T", ")", "\n", "", "print", "(", "\"****** Note we want to know what happened if we give all the predicted scores %s\"", "%", "str", "(", "scores_T", ")", ")", "\n", "", "elif", "variety", "==", "4", ":", "# avg_{i,t}", "\n", "            ", "items", "=", "interaction", "[", "'item'", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "data", ".", "n_items", ")", ":", "\n", "                ", "scores", "[", "items", "==", "i", "]", "=", "train", "[", "train", "[", "'ItemId'", "]", "==", "i", "]", "[", "'rating'", "]", ".", "mean", "(", ")", "\n", "", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "data", ".", "n_items", ")", ":", "\n", "                ", "train_", "=", "train", "[", "train", "[", "'ItemId'", "]", "==", "i", "]", "\n", "for", "ia", "in", "range", "(", "self", ".", "data", ".", "n_periods", ")", ":", "\n", "                    ", "if", "(", "train_", "[", "'ItemAge'", "]", "==", "ia", ")", ".", "sum", "(", ")", ">", "0", ":", "\n", "                        ", "scores", "[", "(", "items", "==", "i", ")", "&", "(", "itemages", "==", "ia", ")", "]", "=", "train_", "[", "train_", "[", "'ItemAge'", "]", "==", "ia", "]", "[", "'rating'", "]", ".", "mean", "(", ")", "\n", "\n", "", "", "", "", "elif", "variety", "==", "5", ":", "# pop_i", "\n", "            ", "train", "=", "self", ".", "data", ".", "train", "\n", "items", "=", "interaction", "[", "'item'", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "data", ".", "n_items", ")", ":", "\n", "                ", "scores", "[", "items", "==", "i", "]", "=", "train", "[", "train", "[", "'ItemId'", "]", "==", "i", "]", "[", "'rating'", "]", ".", "mean", "(", ")", "\n", "", "", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OPPT_Evaluator._save_something": [[928, 943], ["numpy.round().astype", "print", "numpy.arange", "print", "print", "print", "len", "len", "avg_T.append", "numpy.round().astype.mean", "evaluator.OPPT_Evaluator.test[].unique", "evaluator.OPPT_Evaluator.model.s_T.weight.squeeze().cpu", "numpy.round", "preds[].mean", "evaluator.OPPT_Evaluator.model.s_T.weight.squeeze"], "methods", ["None"], ["", "def", "_save_something", "(", "self", ",", "preds", "=", "None", ",", "target", "=", "None", ")", ":", "\n", "# # only for tmf_v w/ global_offset_T", "\n", "# global_offset_T = self.model.global_T.weight.data.cpu().numpy().squeeze()", "\n", "# print(global_offset_T)", "\n", "# # look at the distributions on the preds per T", "\n", "        ", "preds", "=", "np", ".", "round", "(", "preds", ")", ".", "astype", "(", "int", ")", "\n", "print", "(", "len", "(", "preds", ")", ",", "len", "(", "self", ".", "test", ")", ")", "\n", "age", "=", "np", ".", "arange", "(", "self", ".", "data", ".", "n_periods", ")", "\n", "avg_T", "=", "[", "]", "\n", "for", "T", "in", "age", ":", "\n", "# print(self.test['ItemAge'] == T)", "\n", "            ", "avg_T", ".", "append", "(", "(", "preds", "[", "(", "self", ".", "test", "[", "'ItemAge'", "]", "==", "T", ")", ".", "values", "]", ")", ".", "mean", "(", ")", ")", "\n", "", "print", "(", "avg_T", ",", "preds", ".", "mean", "(", ")", ")", "\n", "print", "(", "self", ".", "test", "[", "'ItemAge'", "]", ".", "unique", "(", ")", ")", "\n", "print", "(", "\"Value of s_T:\"", ",", "self", ".", "model", ".", "s_T", ".", "weight", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ")", "\n", "# preds = preds.clip(min(targets), max(targets))", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.OPPT_Evaluator._save_pred_ratings": [[947, 987], ["pandas.read_csv", "len", "numpy.array", "numpy.array", "print", "numpy.copy", "numpy.arange", "range", "numpy.array", "evaluator.OPPT_Evaluator._numpy2tensor", "print", "evaluator.OPPT_Evaluator._eval_epoch().cpu().numpy", "pandas.read_csv.to_csv", "print", "exit", "numpy.array", "len", "list", "len", "range", "evaluator.OPPT_Evaluator._eval_epoch().cpu", "numpy.round().astype", "numpy.isin", "evaluator.OPPT_Evaluator._eval_epoch", "numpy.round"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._numpy2tensor", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch"], ["", "def", "_save_pred_ratings", "(", "self", ")", ":", "\n", "        ", "assert", "self", ".", "debiasing", "\n", "path", "=", "self", ".", "config", "[", "'path'", "]", "+", "'simulation'", "+", "'/predOP_tmtf.csv'", "\n", "# path = self.config['path'] + 'simulation' + '/predOP_tmtf_small_0.1.csv'", "\n", "data", "=", "pd", ".", "read_csv", "(", "path", ",", "sep", "=", "','", ",", "header", "=", "0", ")", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'num'", "]", "=", "len", "(", "data", ")", "\n", "interaction", "[", "'user'", "]", "=", "np", ".", "array", "(", "data", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", "\n", "interaction", "[", "'item'", "]", "=", "np", ".", "array", "(", "data", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", "\n", "# mapping itemage to bins", "\n", "bins", "=", "[", "-", "1", "]", "+", "[", "0", ",", "2", ",", "4", ",", "7", ",", "10", ",", "14", ",", "20", "]", "\n", "print", "(", "\"---------- For mapping itemage to bins: \"", ",", "bins", "[", "1", ":", "]", ",", "\"----------\"", ")", "\n", "itemage", "=", "np", ".", "copy", "(", "np", ".", "array", "(", "data", "[", "'itemage'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", "\n", "itemage_", "=", "itemage", "\n", "replaces", "=", "np", ".", "arange", "(", "len", "(", "bins", ")", "-", "1", ")", "\n", "for", "bidx", "in", "range", "(", "1", ",", "len", "(", "bins", ")", ")", ":", "\n", "            ", "b", "=", "list", "(", "range", "(", "bins", "[", "bidx", "-", "1", "]", "+", "1", ",", "bins", "[", "bidx", "]", "+", "1", ")", ")", "\n", "itemage_", "[", "np", ".", "isin", "(", "itemage", ",", "b", ")", "]", "=", "replaces", "[", "bidx", "-", "1", "]", "\n", "# print(b, itemage[:10], itemage_[:10])", "\n", "", "interaction", "[", "'itemage'", "]", "=", "np", ".", "array", "(", "itemage_", ",", "dtype", "=", "int", ")", "\n", "interaction", "=", "self", ".", "_numpy2tensor", "(", "interaction", ")", "\n", "print", "(", "\"The total number of interactions is %d \"", "%", "(", "interaction", "[", "'num'", "]", ")", ")", "\n", "\n", "scores", "=", "self", ".", "_eval_epoch", "(", "interaction", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "scores", "=", "np", ".", "round", "(", "(", "scores", "*", "2.0", ")", ".", "clip", "(", "1", ",", "10", ")", ")", ".", "astype", "(", "int", ")", "*", "1.0", "/", "2", "\n", "data", "[", "'rating'", "]", "=", "scores", "\n", "\n", "data", "=", "data", "[", "[", "'UserId'", ",", "'ItemId'", ",", "'itemage'", ",", "'rating'", ",", "'predOP'", "]", "]", "\n", "data", ".", "to_csv", "(", "self", ".", "config", "[", "'path'", "]", "+", "'simulation'", "+", "'/pred_ratings_'", "+", "self", ".", "config", "[", "'mode'", "]", "+", "'_rename.csv'", ",", "sep", "=", "','", ",", "header", "=", "True", ",", "index", "=", "False", ")", "\n", "print", "(", "data", "[", ":", "10", "]", ")", "\n", "# # also save presence of users: UserId, firsttime, lasttime", "\n", "# observed_data = pd.concat([self.data.train, self.data.valid, self.data.test], axis=0, ignore_index=True)", "\n", "# users, firsttimes, lasttimes = [], [], []", "\n", "# for u, group in observed_data.groupby(by=['UserId']):", "\n", "#     users.append(u)", "\n", "#     firsttimes.append(min(group['timestamp']))", "\n", "#     lasttimes.append(max(group['timestamp']))", "\n", "# df = pd.DataFrame({'UserId': users, 'firsttime': np.array(firsttimes), 'lasttime': np.array(lasttimes)})", "\n", "# df.to_csv(self.config['path'] + 'simulation' + '/user_presence.csv', sep=',', header=True, index=False)", "\n", "exit", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator.__init__": [[989, 994], ["evaluator.AbstractEvaluator.__init__"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "TART_Evaluator", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "self", ".", "n_items", "=", "self", ".", "data", ".", "n_items", "\n", "self", ".", "n_users", "=", "self", ".", "data", ".", "n_users", "\n", "self", ".", "n_periods", "=", "self", ".", "data", ".", "n_periods", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator._data_pre": [[995, 1003], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "len", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "_data_pre", "(", "self", ",", "train", ")", ":", "\n", "        ", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "[", "'item'", "]", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "[", "'itemage'", "]", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'itemage'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "[", "'target'", "]", "=", "torch", ".", "from_numpy", "(", "train", "[", "'rating'", "]", ".", "values", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "[", "'num'", "]", "=", "len", "(", "train", ")", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator._eval_epoch": [[1004, 1019], ["torch.no_grad", "torch.cat", "evaluator.TART_Evaluator.model.predict", "scores.append"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.predict"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_eval_epoch", "(", "self", ",", "interaction", ",", "batch_size", "=", "512", ")", ":", "\n", "        ", "users", "=", "interaction", "[", "'user'", "]", "\n", "items", "=", "interaction", "[", "'item'", "]", "\n", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "num", "=", "interaction", "[", "'num'", "]", "\n", "scores", "=", "[", "]", "\n", "start_idx", ",", "end_idx", "=", "0", ",", "batch_size", "\n", "while", "start_idx", "<", "num", ":", "\n", "            ", "score", "=", "self", ".", "model", ".", "predict", "(", "{", "'user'", ":", "users", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "items", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemages", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "scores", ".", "append", "(", "score", ")", "\n", "start_idx", "=", "end_idx", "\n", "end_idx", "+=", "batch_size", "\n", "", "return", "torch", ".", "cat", "(", "scores", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator.evaluate": [[1020, 1037], ["torch.no_grad", "evaluator.TART_Evaluator._data_pre", "evaluator.TART_Evaluator._save_something", "evaluator.TART_Evaluator._save_something", "evaluator.cal_ratpred_metrics", "print", "evaluator.cal_rating2ranking_metrics", "print", "evaluator.TART_Evaluator.baselines", "evaluator.TART_Evaluator._eval_epoch", "evaluator.TART_Evaluator.cpu().numpy", "targets.cpu().numpy", "evaluator.TART_Evaluator.cpu().numpy", "interaction[].cpu().numpy", "cal_rating2ranking_metrics.keys", "cal_rating2ranking_metrics.keys", "int", "evaluator.TART_Evaluator.cpu", "targets.cpu", "str", "str", "evaluator.TART_Evaluator.cpu", "interaction[].cpu", "cal_rating2ranking_metrics.values", "cal_rating2ranking_metrics.values"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator._save_something", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator._save_something", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_ratpred_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_rating2ranking_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator.baselines", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "evaluate", "(", "self", ",", "ub", "=", "'false'", ",", "threshold", "=", "1e-3", ",", "baselines", "=", "None", ",", "subset", "=", "None", ")", ":", "\n", "        ", "interaction", "=", "self", ".", "_data_pre", "(", "self", ".", "data", ".", "test", ")", "\n", "if", "baselines", "is", "not", "None", ":", "\n", "            ", "scores", "=", "self", ".", "baselines", "(", "interaction", ",", "variety", "=", "int", "(", "baselines", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "scores", "=", "self", ".", "_eval_epoch", "(", "interaction", ")", "\n", "", "self", ".", "_save_something", "(", "preds", "=", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "_save_something", "(", "preds", "=", "interaction", "[", "'target'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "# self._save_pred_ratings(scores.cpu().numpy())", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "results", "=", "cal_ratpred_metrics", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "targets", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "print", "(", "'\\t'", ".", "join", "(", "results", ".", "keys", "(", ")", ")", ",", "'\\n'", ",", "'\\t'", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "results", ".", "values", "(", ")", "]", ")", ")", "\n", "# evaluate it as a ranking task", "\n", "results", "=", "cal_rating2ranking_metrics", "(", "interaction", ",", "scores", ")", "\n", "print", "(", "'\\t'", ".", "join", "(", "results", ".", "keys", "(", ")", ")", ",", "'\\n'", ",", "'\\t'", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "results", ".", "values", "(", ")", "]", ")", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator.baselines": [[1038, 1076], ["torch.zeros_like().float().to", "train[].mean", "print", "torch.zeros_like().float", "range", "print", "scores[].cpu", "[].mean", "scores_T.append", "range", "range", "torch.zeros_like", "str", "[].mean", "range", "range", "[].mean", "[].mean"], "methods", ["None"], ["", "def", "baselines", "(", "self", ",", "interaction", ",", "variety", "=", "1", ")", ":", "\n", "        ", "'''some simple baseline variety\n        B2: all scores equal to a fixed value, avg-ratings over all.\n        B3: scores for (u, i) at T equal to a fixed value (diff at diff T), avg-ratings at T\n        '''", "\n", "train", "=", "self", ".", "data", ".", "train", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "scores", "=", "torch", ".", "zeros_like", "(", "targets", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "variety", "==", "2", ":", "\n", "            ", "scores", "+=", "train", "[", "'rating'", "]", ".", "mean", "(", ")", "\n", "print", "(", "\"****** Note we want to know what happened if we give all the predicted scores %.6f\"", "%", "(", "scores", "[", "0", "]", ".", "cpu", "(", ")", ")", ")", "\n", "", "elif", "variety", "==", "3", ":", "\n", "            ", "scores_T", "=", "[", "]", "\n", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "for", "T", "in", "range", "(", "self", ".", "n_periods", ")", ":", "\n", "# # calculate in training set", "\n", "                ", "s_T", "=", "train", "[", "train", "[", "'itemage'", "]", "==", "T", "]", "[", "'rating'", "]", ".", "mean", "(", ")", "\n", "# # calculate in test set", "\n", "# s_T = targets[itemages == T].cpu().numpy().mean()", "\n", "scores", "[", "itemages", "==", "T", "]", "=", "s_T", "\n", "scores_T", ".", "append", "(", "s_T", ")", "\n", "", "print", "(", "\"****** Note we want to know what happened if we give all the predicted scores %s\"", "%", "str", "(", "scores_T", ")", ")", "\n", "", "elif", "variety", "==", "4", ":", "# avg_{i,t}", "\n", "            ", "items", "=", "interaction", "[", "'item'", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "data", ".", "n_items", ")", ":", "\n", "                ", "scores", "[", "items", "==", "i", "]", "=", "train", "[", "train", "[", "'ItemId'", "]", "==", "i", "]", "[", "'rating'", "]", ".", "mean", "(", ")", "\n", "", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "data", ".", "n_items", ")", ":", "\n", "                ", "train_", "=", "train", "[", "train", "[", "'ItemId'", "]", "==", "i", "]", "\n", "for", "ia", "in", "range", "(", "self", ".", "data", ".", "n_periods", ")", ":", "\n", "                    ", "if", "(", "train_", "[", "'itemage'", "]", "==", "ia", ")", ".", "sum", "(", ")", ">", "0", ":", "\n", "                        ", "scores", "[", "(", "items", "==", "i", ")", "&", "(", "itemages", "==", "ia", ")", "]", "=", "train_", "[", "train_", "[", "'itemage'", "]", "==", "ia", "]", "[", "'rating'", "]", ".", "mean", "(", ")", "\n", "\n", "", "", "", "", "elif", "variety", "==", "5", ":", "# pop_i", "\n", "            ", "items", "=", "interaction", "[", "'item'", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "data", ".", "n_items", ")", ":", "\n", "                ", "scores", "[", "items", "==", "i", "]", "=", "train", "[", "train", "[", "'ItemId'", "]", "==", "i", "]", "[", "'rating'", "]", ".", "mean", "(", ")", "\n", "", "", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator._save_something": [[1077, 1087], ["numpy.arange", "print", "print", "numpy.round().astype", "avg_T.append", "preds.mean", "evaluator.TART_Evaluator.data.test[].unique", "preds[].mean", "numpy.round"], "methods", ["None"], ["", "def", "_save_something", "(", "self", ",", "preds", "=", "None", ",", "target", "=", "None", ")", ":", "\n", "# # # look at the distributions on the preds per T", "\n", "        ", "preds", "=", "np", ".", "round", "(", "preds", "*", "2", ")", ".", "astype", "(", "int", ")", "*", "0.5", "\n", "age", "=", "np", ".", "arange", "(", "self", ".", "n_periods", ")", "\n", "avg_T", "=", "[", "]", "\n", "for", "T", "in", "age", ":", "\n", "# print(self.test['ItemAge'] == T)", "\n", "            ", "avg_T", ".", "append", "(", "(", "preds", "[", "(", "self", ".", "data", ".", "test", "[", "'itemage'", "]", "==", "T", ")", ".", "values", "]", ")", ".", "mean", "(", ")", ")", "\n", "", "print", "(", "avg_T", ",", "preds", ".", "mean", "(", ")", ")", "\n", "print", "(", "self", ".", "data", ".", "test", "[", "'itemage'", "]", ".", "unique", "(", ")", ")", "\n", "# print(\"Value of s_T:\", self.model.global_T.weight.squeeze().cpu())", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.TART_Evaluator._save_pred_ratings": [[1089, 1097], ["evaluator.TART_Evaluator.data.test.copy", "evaluator.TART_Evaluator.to_csv", "len", "len"], "methods", ["None"], ["", "def", "_save_pred_ratings", "(", "self", ",", "preds", ")", ":", "\n", "        ", "'''save the predicted ratings'''", "\n", "data", "=", "self", ".", "data", ".", "test", ".", "copy", "(", ")", "\n", "data", "[", "'itemage'", "]", "=", "data", "[", "'itemage_copy'", "]", ".", "values", "\n", "assert", "len", "(", "data", ")", "==", "len", "(", "preds", ")", "\n", "data", "[", "'rating'", "]", "=", "preds", "\n", "data", "=", "data", "[", "[", "'UserId'", ",", "'ItemId'", ",", "'itemage'", ",", "'rating'", "]", "]", "\n", "data", ".", "to_csv", "(", "self", ".", "data", ".", "path", "+", "self", ".", "data", ".", "dataset", "+", "'/TART_pred_ratings_'", "+", "self", ".", "config", "[", "'mode'", "]", "+", "'_rename.csv'", ",", "sep", "=", "','", ",", "header", "=", "True", ",", "index", "=", "False", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.hit_": [[8, 10], ["None"], "function", ["None"], ["def", "hit_", "(", "target_pos", ",", "K", ")", ":", "\n", "    ", "return", "(", "target_pos", "<=", "K", ")", "\n", "", "def", "mrr_", "(", "target_pos", ",", "K", ")", ":", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.mrr_": [[10, 14], ["numpy.where"], "function", ["None"], ["", "def", "mrr_", "(", "target_pos", ",", "K", ")", ":", "\n", "    ", "mrr", "=", "1.0", "/", "target_pos", "\n", "mrr", "=", "np", ".", "where", "(", "target_pos", "<=", "K", ",", "mrr", ",", "0.0", ")", "\n", "return", "mrr", "\n", "", "def", "ndcg_", "(", "target_pos", ",", "K", ")", ":", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.ndcg_": [[14, 19], ["numpy.where", "numpy.log", "numpy.log"], "function", ["None"], ["", "def", "ndcg_", "(", "target_pos", ",", "K", ")", ":", "\n", "# for only one correct example, (1 / log2(posi+1)) / (1 / log2(1+1)) = log2(2) / log2(posi+1)", "\n", "    ", "result", "=", "np", ".", "log", "(", "2.", ")", "/", "np", ".", "log", "(", "1.0", "+", "target_pos", ")", "\n", "result", "=", "np", ".", "where", "(", "target_pos", "<=", "K", ",", "result", ",", "0.0", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.calculate_metrics": [[21, 54], ["print", "round", "round", "round", "mrr_().mean", "hit_().mean", "ndcg_().mean", "normalization.lower", "print", "numpy.reciprocal", "round", "round", "round", "np.reciprocal.sum", "print", "round", "round", "round", "str", "evaluator.mrr_", "str", "evaluator.hit_", "str", "evaluator.ndcg_", "condition.sum", "[].mean", "[].mean", "[].mean", "print", "round", "round", "round", "str", "str", "str", "condition.sum", "[].mean", "[].mean", "[].mean", "evaluator.mrr_", "evaluator.hit_", "evaluator.ndcg_", "str", "str", "str", "evaluator.mrr_", "evaluator.hit_", "evaluator.ndcg_", "str", "str", "str", "evaluator.mrr_", "evaluator.hit_", "evaluator.ndcg_"], "function", ["home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.mrr_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.hit_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.ndcg_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.mrr_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.hit_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.ndcg_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.mrr_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.hit_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.ndcg_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.mrr_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.hit_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.ndcg_"], ["", "def", "calculate_metrics", "(", "target_pos", ",", "weight", "=", "None", ",", "normalization", "=", "'snips'", ",", "threshold", "=", "1e-3", ")", ":", "\n", "    ", "results", "=", "{", "}", "\n", "K", "=", "10", "\n", "if", "weight", "is", "None", ":", "\n", "        ", "print", "(", "\"evaluation on standard metrics\"", ")", "\n", "results", "[", "'mrr@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "mrr_", "(", "target_pos", ",", "K", ")", ".", "mean", "(", ")", ",", "8", ")", "\n", "results", "[", "'hit@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "hit_", "(", "target_pos", ",", "K", ")", ".", "mean", "(", ")", ",", "8", ")", "\n", "results", "[", "'ndcg@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "ndcg_", "(", "target_pos", ",", "K", ")", ".", "mean", "(", ")", ",", "8", ")", "\n", "", "elif", "normalization", ".", "lower", "(", ")", "==", "\"snips\"", ":", "\n", "        ", "print", "(", "\"evaluation on snips metrics\"", ")", "\n", "weight_inverse", "=", "np", ".", "reciprocal", "(", "weight", ")", "\n", "weight_", "=", "weight_inverse", "/", "weight_inverse", ".", "sum", "(", ")", "# normalization based on users, since one target per user", "\n", "results", "[", "'mrr@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "(", "mrr_", "(", "target_pos", ",", "K", ")", "*", "weight_", ")", ".", "sum", "(", ")", ",", "8", ")", "\n", "results", "[", "'hit@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "(", "hit_", "(", "target_pos", ",", "K", ")", "*", "weight_", ")", ".", "sum", "(", ")", ",", "8", ")", "\n", "results", "[", "'ndcg@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "(", "ndcg_", "(", "target_pos", ",", "K", ")", "*", "weight_", ")", ".", "sum", "(", ")", ",", "8", ")", "\n", "", "elif", "normalization", "==", "'pop'", ":", "\n", "# threshold = 1.0e-3", "\n", "        ", "condition", "=", "(", "weight", ">", "threshold", ")", "\n", "print", "(", "\"evaluation on pop items with ctr bigger than\"", ",", "threshold", ",", "\", #ui_pairs\"", ",", "condition", ".", "sum", "(", ")", ")", "\n", "results", "[", "'mrr@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "(", "mrr_", "(", "target_pos", ",", "K", ")", "[", "condition", "]", ")", ".", "mean", "(", ")", ",", "3", ")", "\n", "results", "[", "'hit@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "(", "hit_", "(", "target_pos", ",", "K", ")", "[", "condition", "]", ")", ".", "mean", "(", ")", ",", "3", ")", "\n", "results", "[", "'ndcg@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "(", "ndcg_", "(", "target_pos", ",", "K", ")", "[", "condition", "]", ")", ".", "mean", "(", ")", ",", "3", ")", "\n", "", "elif", "normalization", "==", "'unpop'", ":", "\n", "# threshold = 1.0e-3", "\n", "        ", "condition", "=", "(", "weight", "<", "threshold", ")", "\n", "print", "(", "\"evaluation on un-pop items with ctr smaller than\"", ",", "threshold", ",", "\", #ui_pairs\"", ",", "condition", ".", "sum", "(", ")", ")", "\n", "results", "[", "'mrr@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "(", "mrr_", "(", "target_pos", ",", "K", ")", "[", "condition", "]", ")", ".", "mean", "(", ")", ",", "3", ")", "\n", "results", "[", "'hit@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "(", "hit_", "(", "target_pos", ",", "K", ")", "[", "condition", "]", ")", ".", "mean", "(", ")", ",", "3", ")", "\n", "results", "[", "'ndcg@'", "+", "str", "(", "K", ")", "]", "=", "round", "(", "(", "ndcg_", "(", "target_pos", ",", "K", ")", "[", "condition", "]", ")", ".", "mean", "(", ")", ",", "3", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._mse": [[55, 58], ["None"], "function", ["None"], ["", "def", "_mse", "(", "pred", ",", "true", ")", ":", "\n", "# return np.mean((true - pred)**2)", "\n", "    ", "return", "(", "true", "-", "pred", ")", "**", "2", "\n", "", "def", "_mae", "(", "pred", ",", "true", ")", ":", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._mae": [[58, 61], ["numpy.absolute"], "function", ["None"], ["", "def", "_mae", "(", "pred", ",", "true", ")", ":", "\n", "# return np.absolute(true - pred).mean()", "\n", "    ", "return", "np", ".", "absolute", "(", "true", "-", "pred", ")", "\n", "", "def", "_acc", "(", "pred", ",", "true", ")", ":", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._acc": [[61, 66], ["numpy.round().astype", "numpy.round"], "function", ["None"], ["", "def", "_acc", "(", "pred", ",", "true", ")", ":", "\n", "    ", "if", "(", "true", ">", "1", ")", ".", "sum", "(", ")", "==", "0", ":", "\n", "        ", "pred", "=", "np", ".", "round", "(", "pred", ")", ".", "astype", "(", "int", ")", "\n", "# return (pred == true).mean()", "\n", "", "return", "(", "pred", "==", "true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_ratpred_metrics": [[67, 122], ["score.clip.clip", "evaluator._mse", "evaluator._mae", "evaluator._acc", "numpy.mean", "_mae.mean", "_acc.mean", "min", "max", "numpy.reciprocal", "numpy.argsort", "numpy.unique", "len", "range", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.round().astype", "exit", "prop_group.sum", "mse_SNIPS.append", "mae_SNIPS.append", "acc_SNIPS.append", "len", "numpy.round"], "function", ["home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._mse", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._mae", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._acc"], ["", "def", "cal_ratpred_metrics", "(", "score", ",", "target", ",", "predOP", "=", "None", ",", "users", "=", "None", ")", ":", "\n", "# # for ml-100K, ratings are 1, 2, 3, 4, 5", "\n", "# score = score.clip(min(target), max(target))", "\n", "# score_ = np.round(score).astype(int)", "\n", "\n", "# since in target, 0.5, 1.0, 1.5, ..., 4.5, 5.0", "\n", "    ", "target", "=", "target", "*", "2", "# 1, 2, 3, ..., 9, 10", "\n", "score", "=", "score", "*", "2", "\n", "score", "=", "score", ".", "clip", "(", "min", "(", "target", ")", ",", "max", "(", "target", ")", ")", "\n", "score_", "=", "np", ".", "round", "(", "score", ")", ".", "astype", "(", "int", ")", "*", "1.0", "/", "2", "\n", "score", "/=", "2.0", "\n", "target", "/=", "2.0", "\n", "\n", "results", "=", "{", "}", "\n", "mse", "=", "_mse", "(", "score", ",", "target", ")", "\n", "mae", "=", "_mae", "(", "score", ",", "target", ")", "\n", "acc", "=", "_acc", "(", "score_", ",", "target", ")", "\n", "results", "[", "'mse'", "]", "=", "np", ".", "mean", "(", "mse", ")", "\n", "results", "[", "'mae'", "]", "=", "mae", ".", "mean", "(", ")", "\n", "results", "[", "'acc'", "]", "=", "acc", ".", "mean", "(", ")", "\n", "if", "predOP", "is", "not", "None", ":", "\n", "        ", "if", "users", "is", "None", ":", "\n", "            ", "exit", "(", "1", ")", "\n", "", "propensities", "=", "np", ".", "reciprocal", "(", "predOP", ")", "\n", "# # cal SNIPS-metric per user, then avg user", "\n", "indices", "=", "np", ".", "argsort", "(", "users", ")", "# sort the user, do per user", "\n", "u_unique", ",", "first_idxs", "=", "np", ".", "unique", "(", "users", "[", "indices", "]", ",", "return_index", "=", "True", ")", "\n", "n_fidxs", "=", "len", "(", "first_idxs", ")", "\n", "mse_SNIPS", ",", "mae_SNIPS", ",", "acc_SNIPS", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "f_idx", "in", "range", "(", "n_fidxs", ")", ":", "\n", "            ", "start", "=", "first_idxs", "[", "f_idx", "]", "\n", "if", "f_idx", "==", "n_fidxs", "-", "1", ":", "\n", "                ", "end", "=", "len", "(", "users", ")", "\n", "", "else", ":", "\n", "                ", "end", "=", "first_idxs", "[", "f_idx", "+", "1", "]", "\n", "", "u_group", "=", "indices", "[", "start", ":", "end", "]", "\n", "prop_group", "=", "propensities", "[", "u_group", "]", "\n", "prop_sum", "=", "prop_group", ".", "sum", "(", ")", "\n", "mse_SNIPS", ".", "append", "(", "(", "mse", "[", "u_group", "]", "*", "prop_group", ")", ".", "sum", "(", ")", "/", "prop_sum", ")", "\n", "mae_SNIPS", ".", "append", "(", "(", "mae", "[", "u_group", "]", "*", "prop_group", ")", ".", "sum", "(", ")", "/", "prop_sum", ")", "\n", "acc_SNIPS", ".", "append", "(", "(", "acc", "[", "u_group", "]", "*", "prop_group", ")", ".", "sum", "(", ")", "/", "prop_sum", ")", "\n", "\n", "", "results", "[", "'mse-SNIPS'", "]", "=", "np", ".", "mean", "(", "mse_SNIPS", ")", "\n", "results", "[", "'mae-SNIPS'", "]", "=", "np", ".", "mean", "(", "mae_SNIPS", ")", "\n", "results", "[", "'acc-SNIPS'", "]", "=", "np", ".", "mean", "(", "acc_SNIPS", ")", "\n", "\n", "# SNIPS = np.sum(propensities)", "\n", "# print(\"acc:\", acc[:100], acc[:100].mean())", "\n", "# print(\"SNIPS-acc:\", (acc * propensities)[:100], ((acc * propensities)[:100] / propensities[:100].sum()).sum(), propensities[:100].sum(), max(propensities[:100]))", "\n", "\n", "# results['mse-SNIPS'] = (mse * propensities).sum() / SNIPS", "\n", "# results['mae-SNIPS'] = (mae * propensities).sum() / SNIPS", "\n", "# results['acc-SNIPS'] = (acc * propensities).sum() / SNIPS", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._nll": [[123, 126], ["nll_score.mean", "numpy.log", "numpy.log"], "function", ["None"], ["", "def", "_nll", "(", "score", ",", "true", ")", ":", "\n", "    ", "nll_score", "=", "true", "*", "np", ".", "log", "(", "score", ")", "+", "(", "1.0", "-", "true", ")", "*", "np", ".", "log", "(", "1", "-", "score", ")", "\n", "return", "-", "nll_score", ".", "mean", "(", ")", "\n", "", "def", "_perplexity", "(", "score", ",", "true", ")", ":", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._perplexity": [[126, 130], ["numpy.power", "numpy.log2", "numpy.log2", "nll_score.mean"], "function", ["None"], ["", "def", "_perplexity", "(", "score", ",", "true", ")", ":", "\n", "# nll_score = true * score * np.log2(score) + (1.0-true) * (1-score) * np.log2(1-score) ", "\n", "    ", "nll_score", "=", "true", "*", "np", ".", "log2", "(", "score", ")", "+", "(", "1.0", "-", "true", ")", "*", "np", ".", "log2", "(", "1.0", "-", "score", ")", "\n", "return", "np", ".", "power", "(", "2", ",", "-", "nll_score", ".", "mean", "(", ")", ")", "\n", "", "def", "cal_op_metrics", "(", "score", ",", "target", ",", "w_sigmoid", "=", "True", ")", ":", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_op_metrics": [[130, 143], ["score.clip.clip", "_acc().mean", "evaluator._nll", "evaluator._perplexity", "evaluator._acc"], "function", ["home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._nll", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._perplexity", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator._acc"], ["", "def", "cal_op_metrics", "(", "score", ",", "target", ",", "w_sigmoid", "=", "True", ")", ":", "\n", "# score_ = score.copy()", "\n", "# if w_sigmoid:", "\n", "#     score = 1.0 / (1.0 + np.exp(-score)) # sigmoid(score)", "\n", "    ", "score", "=", "score", ".", "clip", "(", "0.000001", ",", "0.999999", ")", "\n", "# if (score == 1.0).sum() + (score == 0.0).sum() > 0:", "\n", "#     print(score_[score == 1.0], score_[score==0.0])", "\n", "#     exit(1)", "\n", "results", "=", "{", "}", "\n", "results", "[", "'acc'", "]", "=", "_acc", "(", "score", ",", "target", ")", ".", "mean", "(", ")", "\n", "results", "[", "'nll'", "]", "=", "_nll", "(", "score", ",", "target", ")", "\n", "results", "[", "'ppl'", "]", "=", "_perplexity", "(", "score", ",", "target", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_ob_pred2ranking_metrics": [[709, 740], ["interaction[].cpu().numpy", "scores.cpu().numpy.cpu().numpy", "pandas.DataFrame", "pd.DataFrame.groupby", "numpy.array().mean", "numpy.array().mean", "numpy.array().mean", "numpy.array().mean", "numpy.array().mean", "interaction[].cpu().numpy", "interaction[].cpu().numpy", "numpy.random.permutation", "group_shuffled.sort_values", "Prec.append", "MRR.append", "MAP.append", "NDCG.append", "interaction[].cpu", "scores.cpu().numpy.cpu", "len", "group_sorted[].sum", "Recall.append", "Recall.append", "evaluator.mrrs_", "evaluator.maps_", "evaluator.ndcgs_", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "interaction[].cpu", "interaction[].cpu", "len", "preds.sum", "group_sorted[].sum", "preds.sum"], "function", ["home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.mrrs_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.maps_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.ndcgs_"], ["", "", "def", "cal_ob_pred2ranking_metrics", "(", "interaction", ",", "scores", ",", "K", "=", "10", ")", ":", "\n", "    ", "users", ",", "items", "=", "interaction", "[", "'user'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "interaction", "[", "'item'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "targets", "=", "interaction", "[", "'target'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "scores", "=", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", "=", "{", "'user'", ":", "users", ",", "'item'", ":", "items", ",", "'target'", ":", "targets", ",", "'score'", ":", "scores", "}", ")", "\n", "Prec", ",", "Recall", ",", "MRR", ",", "MAP", ",", "NDCG", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "u", ",", "group", "in", "df", ".", "groupby", "(", "[", "'user'", "]", ")", ":", "\n", "# for now poss before the negs, so we need shuffle first", "\n", "        ", "shuffle_order", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "group", ")", ")", "\n", "group_shuffled", "=", "group", ".", "iloc", "[", "shuffle_order", "]", "\n", "group_sorted", "=", "group_shuffled", ".", "sort_values", "(", "by", "=", "[", "'score'", "]", ",", "ascending", "=", "False", ")", "\n", "'''NDCG...MAP...'''", "\n", "preds", "=", "group_sorted", "[", "'target'", "]", "[", ":", "K", "]", "\n", "Prec", ".", "append", "(", "preds", ".", "sum", "(", ")", "*", "1.0", "/", "len", "(", "preds", ")", ")", "\n", "if", "group_sorted", "[", "'target'", "]", ".", "sum", "(", ")", "==", "0", ":", "\n", "            ", "Recall", ".", "append", "(", "0.0", ")", "\n", "", "else", ":", "\n", "            ", "Recall", ".", "append", "(", "preds", ".", "sum", "(", ")", "*", "1.0", "/", "group_sorted", "[", "'target'", "]", ".", "sum", "(", ")", ")", "\n", "", "MRR", ".", "append", "(", "mrrs_", "(", "preds", ")", ")", "\n", "MAP", ".", "append", "(", "maps_", "(", "preds", ")", ")", "\n", "NDCG", ".", "append", "(", "ndcgs_", "(", "preds", ")", ")", "\n", "# print(preds)", "\n", "# print(group_shuffled['score'][:K])", "\n", "# exit(0)", "\n", "", "results", "=", "{", "}", "\n", "results", "[", "'Prec@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "Prec", ")", ")", ".", "mean", "(", ")", "\n", "results", "[", "'Recall@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "Recall", ")", ")", ".", "mean", "(", ")", "\n", "results", "[", "'MRR@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "MRR", ")", ")", ".", "mean", "(", ")", "\n", "results", "[", "'MAP@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "MAP", ")", ")", ".", "mean", "(", ")", "\n", "results", "[", "'NDCG@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "NDCG", ")", ")", ".", "mean", "(", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_rating2ranking_metrics": [[741, 778], ["interaction[].cpu().numpy", "scores.cpu().numpy.cpu().numpy", "pandas.DataFrame", "pd.DataFrame.groupby", "numpy.array().mean", "numpy.array().mean", "numpy.array().mean", "numpy.array().mean", "numpy.array().mean", "interaction[].cpu().numpy", "interaction[].cpu().numpy", "numpy.random.permutation", "group_shuffled.sort_values", "numpy.where", "Prec.append", "MRR.append", "MAP.append", "NDCG.append", "interaction[].cpu", "scores.cpu().numpy.cpu", "len", "np.where.sum", "Recall.append", "Recall.append", "evaluator.mrrs_", "evaluator.maps_", "sklearn.metrics.ndcg_score", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "interaction[].cpu", "interaction[].cpu", "len", "numpy.array", "numpy.array", "np.where.sum", "np.where.sum"], "function", ["home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.mrrs_", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.maps_"], ["", "def", "cal_rating2ranking_metrics", "(", "interaction", ",", "scores", ",", "K", "=", "10", ")", ":", "\n", "    ", "users", ",", "items", "=", "interaction", "[", "'user'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "interaction", "[", "'item'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "targets", "=", "interaction", "[", "'target'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "scores", "=", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", "=", "{", "'user'", ":", "users", ",", "'item'", ":", "items", ",", "'target'", ":", "targets", ",", "'score'", ":", "scores", "}", ")", "\n", "Prec", ",", "Recall", ",", "MRR", ",", "MAP", ",", "NDCG", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "u", ",", "group", "in", "df", ".", "groupby", "(", "[", "'user'", "]", ")", ":", "\n", "# for now poss before the negs, so we need shuffle first", "\n", "        ", "shuffle_order", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "group", ")", ")", "\n", "group_shuffled", "=", "group", ".", "iloc", "[", "shuffle_order", "]", "\n", "group_sorted", "=", "group_shuffled", ".", "sort_values", "(", "by", "=", "[", "'score'", "]", ",", "ascending", "=", "False", ")", "\n", "'''NDCG...MAP...'''", "\n", "preds", "=", "group_sorted", "[", "'target'", "]", "[", ":", "K", "]", "\n", "rels", "=", "np", ".", "where", "(", "preds", ".", "values", ">=", "4", ",", "1.0", ",", "0.0", ")", "\n", "# print(rels.mean())", "\n", "Prec", ".", "append", "(", "rels", ".", "sum", "(", ")", "*", "1.0", "/", "len", "(", "preds", ")", ")", "\n", "if", "rels", ".", "sum", "(", ")", "==", "0", ":", "\n", "            ", "Recall", ".", "append", "(", "0.0", ")", "\n", "", "else", ":", "\n", "            ", "Recall", ".", "append", "(", "rels", ".", "sum", "(", ")", "*", "1.0", "/", "(", "group_sorted", "[", "'target'", "]", ".", "values", ">", "3", ")", ".", "sum", "(", ")", ")", "\n", "", "MRR", ".", "append", "(", "mrrs_", "(", "rels", ")", ")", "\n", "# MAP.append(average_precision_score(rels))", "\n", "MAP", ".", "append", "(", "maps_", "(", "rels", ")", ")", "# MRR and MAP can only on rels not preds", "\n", "\n", "# NDCG.append(ndcg_score(np.array([group_sorted['target'].values[:10]]), np.array([group_sorted['score'].values[:10]]), k=10)) ### Wrong!!!", "\n", "NDCG", ".", "append", "(", "ndcg_score", "(", "np", ".", "array", "(", "[", "group_shuffled", "[", "'target'", "]", ".", "values", "]", ")", ",", "np", ".", "array", "(", "[", "group_shuffled", "[", "'score'", "]", ".", "values", "]", ")", ",", "k", "=", "10", ")", ")", "\n", "# print(preds.values, rels)", "\n", "# print(Prec[-1], Recall[-1], MRR[-1], MAP[-1], NDCG[-1])", "\n", "# if len(Prec) == 20:", "\n", "#     exit(0)", "\n", "", "results", "=", "{", "}", "\n", "results", "[", "'Prec@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "Prec", ")", ")", ".", "mean", "(", ")", "\n", "results", "[", "'Recall@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "Recall", ")", ")", ".", "mean", "(", ")", "\n", "results", "[", "'MRR@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "MRR", ")", ")", ".", "mean", "(", ")", "\n", "results", "[", "'MAP@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "MAP", ")", ")", ".", "mean", "(", ")", "\n", "results", "[", "'NDCG@%d'", "%", "K", "]", "=", "(", "np", ".", "array", "(", "NDCG", ")", ")", ".", "mean", "(", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.mrrs_": [[783, 788], ["preds.sum", "numpy.where"], "function", ["None"], ["", "def", "mrrs_", "(", "preds", ")", ":", "\n", "    ", "if", "preds", ".", "sum", "(", ")", "==", "0", ":", "\n", "        ", "return", "0.0", "\n", "", "position", "=", "np", ".", "where", "(", "preds", ">", "0", ")", "[", "0", "]", "[", "0", "]", "+", "1", "\n", "return", "1.0", "/", "position", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.maps_": [[789, 795], ["preds[].sum", "numpy.where", "preds.sum", "numpy.reciprocal", "numpy.arange", "positions.astype", "len"], "function", ["None"], ["", "def", "maps_", "(", "preds", ",", "k", "=", "10", ")", ":", "\n", "    ", "if", "preds", "[", ":", "k", "]", ".", "sum", "(", ")", "==", "0", ":", "\n", "        ", "return", "0.0", "\n", "", "positions", "=", "np", ".", "where", "(", "preds", "[", ":", "k", "]", ">", "0", ")", "[", "0", "]", "\n", "MAP", "=", "(", "np", ".", "reciprocal", "(", "positions", ".", "astype", "(", "float", ")", "+", "1", ")", "*", "(", "np", ".", "arange", "(", "len", "(", "positions", ")", ")", "+", "1", ")", ")", ".", "sum", "(", ")", "/", "preds", ".", "sum", "(", ")", "\n", "return", "MAP", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.ndcgs_": [[797, 806], ["preds.sum", "numpy.log2", "numpy.arange().astype", "numpy.power().astype", "numpy.arange", "len", "numpy.power"], "function", ["None"], ["", "def", "ndcgs_", "(", "preds", ",", "denominator", "=", "None", ")", ":", "\n", "    ", "if", "preds", ".", "sum", "(", ")", "==", "0", ":", "\n", "        ", "return", "0.0", "\n", "", "if", "denominator", "is", "None", ":", "\n", "        ", "denominator", "=", "np", ".", "log2", "(", "np", ".", "arange", "(", "len", "(", "preds", ")", ")", ".", "astype", "(", "float", ")", "+", "2", ")", "# i=2,...,k+1", "\n", "", "dcgs", "=", "(", "(", "np", ".", "power", "(", "2", ",", "preds", ")", ".", "astype", "(", "float", ")", "-", "1.0", ")", "/", "denominator", ")", ".", "sum", "(", ")", "\n", "pos_num", "=", "(", "preds", ">", "0", ")", ".", "sum", "(", ")", "\n", "idcgs", "=", "(", "1.0", "/", "denominator", "[", ":", "pos_num", "]", ")", ".", "sum", "(", ")", "\n", "return", "dcgs", "/", "idcgs", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.__init__": [[20, 33], ["torch.device", "torch.device", "torch.device", "torch.device", "model.to", "float", "float", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "self", ".", "config", "=", "config", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "data", "=", "data", "\n", "# self.train = self.data.train_full", "\n", "self", ".", "learner", "=", "config", "[", "'optimizer'", "]", "\n", "self", ".", "learning_rate", "=", "float", "(", "config", "[", "'learning_rate'", "]", ")", "\n", "self", ".", "l2_reg", "=", "0", "\n", "if", "'l2_reg'", "in", "config", ":", "\n", "            ", "self", ".", "l2_reg", "=", "float", "(", "config", "[", "'l2_reg'", "]", ")", "\n", "\n", "", "self", ".", "best_valid_score", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._build_optimizer": [[34, 51], ["trainer.AbstractTrainer.learner.lower", "torch.Adam", "torch.Adam", "trainer.AbstractTrainer.model.parameters", "trainer.AbstractTrainer.learner.lower", "torch.SGD", "torch.SGD", "trainer.AbstractTrainer.model.parameters", "trainer.AbstractTrainer.learner.lower", "torch.Adagrad", "torch.Adagrad", "trainer.AbstractTrainer.model.parameters", "trainer.AbstractTrainer.learner.lower", "torch.RMSprop", "torch.RMSprop", "trainer.AbstractTrainer.logger.warning", "torch.Adam", "torch.Adam", "trainer.AbstractTrainer.model.parameters", "trainer.AbstractTrainer.model.parameters"], "methods", ["None"], ["", "def", "_build_optimizer", "(", "self", ")", ":", "\n", "        ", "r\"\"\"Init the Optimizer\n        Returns:\n            torch.optim: the optimizer\n        \"\"\"", "\n", "if", "self", ".", "learner", ".", "lower", "(", ")", "==", "'adam'", ":", "\n", "            ", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "learning_rate", ",", "weight_decay", "=", "self", ".", "l2_reg", ")", "\n", "", "elif", "self", ".", "learner", ".", "lower", "(", ")", "==", "'sgd'", ":", "\n", "            ", "optimizer", "=", "optim", ".", "SGD", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "learning_rate", ",", "weight_decay", "=", "self", ".", "l2_reg", ")", "\n", "", "elif", "self", ".", "learner", ".", "lower", "(", ")", "==", "'adagrad'", ":", "\n", "            ", "optimizer", "=", "optim", ".", "Adagrad", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "learning_rate", ",", "weight_decay", "=", "self", ".", "l2_reg", ")", "\n", "", "elif", "self", ".", "learner", ".", "lower", "(", ")", "==", "'rmsprop'", ":", "\n", "            ", "optimizer", "=", "optim", ".", "RMSprop", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "learning_rate", ",", "weight_decay", "=", "self", ".", "l2_reg", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "logger", ".", "warning", "(", "'Received unrecognized optimizer, set default Adam optimizer'", ")", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "learning_rate", ",", "weight_decay", "=", "self", ".", "l2_reg", ")", "\n", "", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._early_stopping": [[52, 93], ["None"], "methods", ["None"], ["", "def", "_early_stopping", "(", "self", ",", "value", ",", "best", ",", "cur_step", ",", "max_step", ",", "bigger", "=", "True", ")", ":", "\n", "        ", "r\"\"\" validation-based early stopping\n        Args:\n            value (float): current result\n            best (float): best result\n            cur_step (int): the number of consecutive steps that did not exceed the best result\n            max_step (int): threshold steps for stopping\n            bigger (bool, optional): whether the bigger the better\n        Returns:\n            tuple:\n            - float, best result after this step\n            - int, the number of consecutive steps that did not exceed the best result after this step\n            - bool, whether to stop\n            - bool, whether to update\n        \"\"\"", "\n", "stop_flag", "=", "False", "\n", "update_flag", "=", "False", "\n", "if", "best", "is", "None", ":", "\n", "            ", "cur_step", "=", "0", "\n", "best", "=", "value", "\n", "update_flag", "=", "True", "\n", "return", "best", ",", "cur_step", ",", "stop_flag", ",", "update_flag", "\n", "", "if", "bigger", ":", "\n", "            ", "if", "value", ">", "best", ":", "\n", "                ", "cur_step", "=", "0", "\n", "best", "=", "value", "\n", "update_flag", "=", "True", "\n", "", "else", ":", "\n", "                ", "cur_step", "+=", "1", "\n", "if", "cur_step", ">", "max_step", ":", "\n", "                    ", "stop_flag", "=", "True", "\n", "", "", "", "else", ":", "\n", "            ", "if", "value", "<", "best", ":", "\n", "                ", "cur_step", "=", "0", "\n", "best", "=", "value", "\n", "update_flag", "=", "True", "\n", "", "else", ":", "\n", "                ", "cur_step", "+=", "1", "\n", "if", "cur_step", ">", "max_step", ":", "\n", "                    ", "stop_flag", "=", "True", "\n", "", "", "", "return", "best", ",", "cur_step", ",", "stop_flag", ",", "update_flag", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.fit": [[94, 98], ["NotImplementedError"], "methods", ["None"], ["", "def", "fit", "(", "self", ")", ":", "\n", "        ", "r\"\"\"Train the model based on the train data.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "'Method [next] should be implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.evaluate": [[99, 104], ["NotImplementedError"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "eval_data", ")", ":", "\n", "        ", "r\"\"\"Evaluate the model based on the eval data.\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "(", "'Method [next] should be implemented.'", ")", "\n", "", "def", "save_model", "(", "self", ",", "epoch", ")", ":", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.save_model": [[104, 107], ["torch.save", "torch.save", "torch.save", "torch.save", "trainer.AbstractTrainer.model.state_dict", "trainer.AbstractTrainer.optimizer.state_dict"], "methods", ["None"], ["", "def", "save_model", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "state", "=", "{", "'net'", ":", "self", ".", "model", ".", "state_dict", "(", ")", ",", "'optimizer'", ":", "self", ".", "optimizer", ".", "state_dict", "(", ")", ",", "'epoch'", ":", "epoch", "}", "\n", "torch", ".", "save", "(", "state", ",", "self", ".", "saved_model_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.load_model": [[108, 112], ["torch.load", "torch.load", "torch.load", "torch.load", "trainer.AbstractTrainer.model.load_state_dict", "trainer.AbstractTrainer.optimizer.load_state_dict"], "methods", ["None"], ["", "def", "load_model", "(", "self", ")", ":", "\n", "        ", "checkpoint", "=", "torch", ".", "load", "(", "self", ".", "saved_model_file", ")", "\n", "self", ".", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'net'", "]", ")", "\n", "self", ".", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TARS_Trainer.__init__": [[118, 132], ["trainer.AbstractTrainer.__init__", "print", "int", "trainer.TARS_Trainer._build_optimizer"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._build_optimizer"], ["def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "TARS_Trainer", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "\n", "self", ".", "optimizer", "=", "config", "[", "'optimizer'", "]", "\n", "if", "config", "[", "'debiasing'", "]", ":", "\n", "            ", "self", ".", "debiasing", "=", "\"_ips\"", "\n", "", "else", ":", "\n", "            ", "self", ".", "debiasing", "=", "'_naive'", "\n", "", "self", ".", "saved_model_file", "=", "\"./checkpoint_dir/\"", "+", "config", "[", "'dataset'", "]", "+", "self", ".", "debiasing", "# config['checkpoint_dir']", "\n", "print", "(", "\"model will be saved into:\"", ",", "self", ".", "saved_model_file", ")", "\n", "self", ".", "epochs", "=", "config", "[", "'epochs'", "]", "\n", "self", ".", "batch_size", "=", "int", "(", "config", "[", "'batch_size'", "]", ")", "\n", "\n", "self", ".", "optimizer", "=", "self", ".", "_build_optimizer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TARS_Trainer._data_pre": [[133, 150], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "_data_pre", "(", "self", ",", "train_set", ")", ":", "\n", "        ", "train", "=", "train_set", "\n", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "iid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'rating'", "]", ".", "values", ",", "dtype", "=", "float", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "itemage", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'ItemAge'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "ctr", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'ctr'", "]", ".", "values", ",", "dtype", "=", "float", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "uid_list", "\n", "interaction", "[", "'item'", "]", "=", "iid_list", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'ctr'", "]", "=", "ctr", "\n", "interaction", "[", "'itemage'", "]", "=", "itemage", "\n", "\n", "interaction", "[", "'num'", "]", "=", "uid_list", ".", "size", "(", ")", "[", "0", "]", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TARS_Trainer._train_epoch": [[151, 188], ["math.ceil", "range", "numpy.array.append", "numpy.array.append", "numpy.array", "numpy.array", "range", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "numpy.array.append", "numpy.array.append", "len", "trainer.TARS_Trainer.optimizer.zero_grad", "trainer.TARS_Trainer.model.calculate_loss", "trainer.TARS_Trainer.item", "trainer.TARS_Trainer.backward", "trainer.TARS_Trainer.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss"], ["", "def", "_train_epoch", "(", "self", ",", "interaction", ",", "shuffle_data", "=", "True", ")", ":", "\n", "        ", "if", "shuffle_data", ":", "\n", "# shuffle the data", "\n", "            ", "order", "=", "torch", ".", "randperm", "(", "interaction", "[", "'num'", "]", ")", "\n", "for", "key", "in", "[", "'user'", ",", "'item'", ",", "'itemage'", ",", "'target'", ",", "'ctr'", "]", ":", "\n", "                ", "value", "=", "interaction", "[", "key", "]", "\n", "interaction", "[", "key", "]", "=", "value", "[", "order", "]", "\n", "\n", "", "", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "ctr", "=", "interaction", "[", "'ctr'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "\n", "# batch split", "\n", "num_batch", "=", "math", ".", "ceil", "(", "interaction", "[", "'num'", "]", "*", "1.0", "/", "self", ".", "batch_size", ")", "\n", "start_idxs", ",", "end_idxs", "=", "[", "]", ",", "[", "]", "\n", "for", "i_batch", "in", "range", "(", "num_batch", "-", "1", ")", ":", "\n", "            ", "start_idxs", ".", "append", "(", "i_batch", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "(", "i_batch", "+", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "", "start_idxs", ".", "append", "(", "(", "num_batch", "-", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "interaction", "[", "'num'", "]", ")", "\n", "start_idxs", "=", "np", ".", "array", "(", "start_idxs", ",", "dtype", "=", "int", ")", "\n", "end_idxs", "=", "np", ".", "array", "(", "end_idxs", ",", "dtype", "=", "int", ")", "\n", "\n", "# train on batch", "\n", "total_loss", "=", "0", "\n", "for", "i_batch", "in", "range", "(", "len", "(", "start_idxs", ")", ")", ":", "\n", "            ", "start_idx", ",", "end_idx", "=", "start_idxs", "[", "i_batch", "]", ",", "end_idxs", "[", "i_batch", "]", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "{", "'user'", ":", "user", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "item", "[", "start_idx", ":", "end_idx", "]", ",", "'target'", ":", "target", "[", "start_idx", ":", "end_idx", "]", ",", "'ctr'", ":", "ctr", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemage", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TARS_Trainer.fit": [[189, 207], ["trainer.TARS_Trainer._data_pre", "time.time.time", "range", "trainer.TARS_Trainer.save_model", "trainer.TARS_Trainer._train_epoch", "trainer.TARS_Trainer.evaluate", "print", "trainer.TARS_Trainer._early_stopping", "time.time.time", "print", "str", "time.time.time"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.save_model", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._train_epoch", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._early_stopping"], ["", "def", "fit", "(", "self", ",", "valid_data", "=", "None", ",", "verbose", "=", "True", ",", "saved", "=", "True", ")", ":", "\n", "        ", "interaction", "=", "self", ".", "_data_pre", "(", "self", ".", "train", ")", "\n", "start", "=", "time", "(", ")", "\n", "for", "epoch_idx", "in", "range", "(", "self", ".", "epochs", ")", ":", "\n", "            ", "train_loss", "=", "self", ".", "_train_epoch", "(", "interaction", ")", "\n", "if", "(", "epoch_idx", "+", "1", ")", "%", "1", "==", "0", ":", "# evaluate on valid set", "\n", "# self.load_model()", "\n", "                ", "valid_results", ",", "valid_loss", "=", "self", ".", "evaluate", "(", ")", "\n", "print", "(", "\"epoch %d, time-consumin: %f s, train-loss: %f, valid-loss: %f, \\nresults on validset: %s\"", "%", "(", "epoch_idx", "+", "1", ",", "time", "(", ")", "-", "start", ",", "train_loss", ",", "valid_loss", ",", "str", "(", "valid_results", ")", ")", ",", "flush", "=", "True", ")", "\n", "self", ".", "best_valid_score", ",", "_", ",", "stop_flag", ",", "_", "=", "self", ".", "_early_stopping", "(", "valid_loss", ",", "self", ".", "best_valid_score", ",", "epoch_idx", ",", "10", ",", "bigger", "=", "False", ")", "\n", "# print(self.best_valid_score, stop_flag, valid_loss)", "\n", "# exit(0)", "\n", "if", "stop_flag", ":", "\n", "                    ", "print", "(", "\"Finished training, best eval result in epoch %d\"", "%", "epoch_idx", ")", "\n", "break", "\n", "", "start", "=", "time", "(", ")", "\n", "", "", "self", ".", "save_model", "(", "epoch_idx", ")", "\n", "return", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TARS_Trainer._eval_epoch": [[208, 239], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "math.ceil", "range", "numpy.array.append", "numpy.array.append", "numpy.array", "numpy.array", "range", "numpy.array.append", "numpy.array.append", "len", "trainer.TARS_Trainer.optimizer.zero_grad", "trainer.TARS_Trainer.model.calculate_loss", "trainer.TARS_Trainer.item", "trainer.TARS_Trainer.backward", "trainer.TARS_Trainer.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_eval_epoch", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "ctr", "=", "interaction", "[", "'ctr'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "\n", "# batch split", "\n", "num_batch", "=", "math", ".", "ceil", "(", "interaction", "[", "'num'", "]", "*", "1.0", "/", "self", ".", "batch_size", ")", "\n", "start_idxs", ",", "end_idxs", "=", "[", "]", ",", "[", "]", "\n", "for", "i_batch", "in", "range", "(", "num_batch", "-", "1", ")", ":", "\n", "            ", "start_idxs", ".", "append", "(", "i_batch", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "(", "i_batch", "+", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "", "start_idxs", ".", "append", "(", "(", "num_batch", "-", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "interaction", "[", "'num'", "]", ")", "\n", "start_idxs", "=", "np", ".", "array", "(", "start_idxs", ",", "dtype", "=", "int", ")", "\n", "end_idxs", "=", "np", ".", "array", "(", "end_idxs", ",", "dtype", "=", "int", ")", "\n", "\n", "# eval on batch", "\n", "total_loss", "=", "0", "\n", "\n", "for", "i_batch", "in", "range", "(", "len", "(", "start_idxs", ")", ")", ":", "\n", "            ", "start_idx", ",", "end_idx", "=", "start_idxs", "[", "i_batch", "]", ",", "end_idxs", "[", "i_batch", "]", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "{", "'user'", ":", "user", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "item", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemage", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TARS_Trainer.evaluate": [[240, 251], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.TARS_Trainer._data_pre", "trainer.TARS_Trainer.model.calculate_loss().item", "trainer.TARS_Trainer.model.predict", "evaluator.evaluator.cal_ratpred_metrics", "trainer.TARS_Trainer.cpu().numpy", "targets.cpu().numpy", "trainer.TARS_Trainer.model.calculate_loss", "trainer.TARS_Trainer.cpu", "targets.cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.predict", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_ratpred_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "interaction", "=", "self", ".", "_data_pre", "(", "self", ".", "data", ".", "valid", ")", "\n", "# losses", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "interaction", ")", ".", "item", "(", ")", "\n", "# results", "\n", "scores", "=", "self", ".", "model", ".", "predict", "(", "interaction", ")", "\n", "# find the position of the target item", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "results", "=", "cal_ratpred_metrics", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "targets", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "return", "results", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.Seq_Trainer.__init__": [[254, 269], ["trainer.AbstractTrainer.__init__", "print", "int", "int", "trainer.Seq_Trainer._build_optimizer"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._build_optimizer"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "Seq_Trainer", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "\n", "self", ".", "optimizer", "=", "config", "[", "'optimizer'", "]", "\n", "if", "config", "[", "'debiasing'", "]", ":", "\n", "            ", "self", ".", "debiasing", "=", "\"_ips\"", "\n", "", "else", ":", "\n", "            ", "self", ".", "debiasing", "=", "'_naive'", "\n", "", "self", ".", "saved_model_file", "=", "\"./checkpoint_dir/\"", "+", "config", "[", "'dataset'", "]", "+", "'_'", "+", "config", "[", "'mode'", "]", "+", "self", ".", "debiasing", "# config['checkpoint_dir']", "\n", "print", "(", "\"model will be saved into:\"", ",", "self", ".", "saved_model_file", ")", "\n", "self", ".", "epochs", "=", "config", "[", "'epochs'", "]", "\n", "self", ".", "batch_size", "=", "int", "(", "config", "[", "'batch_size'", "]", ")", "\n", "self", ".", "max_item_list_len", "=", "int", "(", "config", "[", "'max_item_list_len'", "]", ")", "\n", "\n", "self", ".", "optimizer", "=", "self", ".", "_build_optimizer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.Seq_Trainer._data_pre": [[271, 306], ["train.groupby", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "group.sort_values", "range", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "len", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "list"], "methods", ["None"], ["", "def", "_data_pre", "(", "self", ",", "train_set", ")", ":", "\n", "        ", "train", "=", "train_set", "\n", "n_items", "=", "self", ".", "data", ".", "n_items", "\n", "uid_list", ",", "seq_list", ",", "seq_len", ",", "ctr_target", ",", "target", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "u", ",", "group", "in", "train", ".", "groupby", "(", "[", "'UserId'", "]", ")", ":", "\n", "            ", "u_ratings", "=", "group", ".", "sort_values", "(", "[", "'timestamp'", "]", ",", "ascending", "=", "True", ")", "\n", "u_items", "=", "u_ratings", "[", "'ItemId'", "]", ".", "values", "\n", "u_ctrs", "=", "u_ratings", "[", "'ctr'", "]", ".", "values", "\n", "for", "idx", "in", "range", "(", "len", "(", "u_items", ")", "-", "1", ")", ":", "\n", "                ", "uid_list", ".", "append", "(", "u", ")", "\n", "ctr_target", ".", "append", "(", "u_ctrs", "[", "idx", "+", "1", "]", ")", "\n", "target", ".", "append", "(", "u_items", "[", "idx", "+", "1", "]", ")", "\n", "if", "idx", ">=", "self", ".", "max_item_list_len", ":", "\n", "                    ", "seq_list", ".", "append", "(", "u_items", "[", "(", "idx", "-", "self", ".", "max_item_list_len", "+", "1", ")", ":", "(", "idx", "+", "1", ")", "]", ")", "\n", "seq_len", ".", "append", "(", "self", ".", "max_item_list_len", ")", "\n", "", "else", ":", "\n", "                    ", "padding_list", "=", "[", "n_items", "]", "*", "(", "self", ".", "max_item_list_len", "-", "idx", "-", "1", ")", "\n", "# print(u_items[:(idx+1)], padding_list)", "\n", "seq_list", ".", "append", "(", "list", "(", "u_items", "[", ":", "(", "idx", "+", "1", ")", "]", ")", "+", "padding_list", ")", "\n", "seq_len", ".", "append", "(", "idx", "+", "1", ")", "\n", "# print(seq_list, len(seq_list[-1]))", "\n", "# assert len(seq_list[-1]) == self.max_item_list_len", "\n", "", "", "", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "uid_list", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "seq_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "seq_list", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "seq_len", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "seq_len", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "target", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "ctr_target", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "ctr_target", ",", "dtype", "=", "float", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'seq'", "]", "=", "seq_list", "\n", "interaction", "[", "'seq_len'", "]", "=", "seq_len", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'ctr'", "]", "=", "ctr_target", "\n", "assert", "seq_list", ".", "size", "(", ")", "[", "0", "]", "==", "ctr_target", ".", "size", "(", ")", "[", "0", "]", "\n", "interaction", "[", "'num'", "]", "=", "seq_list", ".", "size", "(", ")", "[", "0", "]", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.Seq_Trainer._data_pre_fullseq": [[307, 341], ["train.groupby", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "group.sort_values", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "len", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy().to.append", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "list"], "methods", ["None"], ["", "def", "_data_pre_fullseq", "(", "self", ",", "train_full", ")", ":", "\n", "        ", "train", "=", "train_full", "\n", "n_items", "=", "self", ".", "data", ".", "n_items", "\n", "uid_list", ",", "seq_list", ",", "seq_len", ",", "ctr_target", ",", "target", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "u", ",", "group", "in", "train", ".", "groupby", "(", "[", "'UserId'", "]", ")", ":", "\n", "            ", "u_ratings", "=", "group", ".", "sort_values", "(", "[", "'timestamp'", "]", ",", "ascending", "=", "True", ")", "\n", "u_items", "=", "u_ratings", "[", "'ItemId'", "]", ".", "values", "\n", "u_ctrs", "=", "u_ratings", "[", "'ctr'", "]", ".", "values", "\n", "u_n_items", "=", "len", "(", "u_items", ")", "-", "1", "\n", "target", ".", "append", "(", "u_items", "[", "-", "1", "]", ")", "\n", "ctr_target", ".", "append", "(", "u_ctrs", "[", "-", "1", "]", ")", "\n", "u_items", "=", "u_items", "[", ":", "-", "1", "]", "\n", "uid_list", ".", "append", "(", "u", ")", "\n", "if", "u_n_items", ">=", "self", ".", "max_item_list_len", ":", "\n", "                ", "seq_list", ".", "append", "(", "u_items", "[", "-", "self", ".", "max_item_list_len", ":", "]", ")", "\n", "seq_len", ".", "append", "(", "self", ".", "max_item_list_len", ")", "\n", "", "else", ":", "\n", "                ", "padding_list", "=", "[", "n_items", "]", "*", "(", "self", ".", "max_item_list_len", "-", "u_n_items", ")", "\n", "seq_list", ".", "append", "(", "list", "(", "u_items", ")", "+", "padding_list", ")", "\n", "seq_len", ".", "append", "(", "u_n_items", ")", "\n", "\n", "", "", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "uid_list", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "seq_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "seq_list", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "seq_len", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "seq_len", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "target", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "ctr_target", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "ctr_target", ",", "dtype", "=", "float", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'seq'", "]", "=", "seq_list", "\n", "interaction", "[", "'seq_len'", "]", "=", "seq_len", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'ctr'", "]", "=", "ctr_target", "\n", "assert", "seq_list", ".", "size", "(", ")", "[", "0", "]", "==", "seq_len", ".", "size", "(", ")", "[", "0", "]", "\n", "interaction", "[", "'num'", "]", "=", "seq_list", ".", "size", "(", ")", "[", "0", "]", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.Seq_Trainer._train_epoch": [[342, 380], ["math.ceil", "range", "numpy.array.append", "numpy.array.append", "numpy.array", "numpy.array", "range", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "numpy.array.append", "numpy.array.append", "len", "trainer.Seq_Trainer.optimizer.zero_grad", "trainer.Seq_Trainer.model.calculate_loss", "trainer.Seq_Trainer.item", "trainer.Seq_Trainer.backward", "trainer.Seq_Trainer.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss"], ["", "def", "_train_epoch", "(", "self", ",", "interaction", ",", "shuffle_data", "=", "True", ")", ":", "\n", "# print(interaction['num'])", "\n", "# exit(0)", "\n", "        ", "if", "shuffle_data", ":", "\n", "# shuffle the data", "\n", "            ", "order", "=", "torch", ".", "randperm", "(", "interaction", "[", "'num'", "]", ")", "\n", "for", "key", "in", "[", "'seq'", ",", "'seq_len'", ",", "'target'", ",", "'ctr'", "]", ":", "\n", "                ", "value", "=", "interaction", "[", "key", "]", "\n", "interaction", "[", "key", "]", "=", "value", "[", "order", "]", "\n", "\n", "", "", "seq_list", "=", "interaction", "[", "'seq'", "]", "\n", "seq_len", "=", "interaction", "[", "'seq_len'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "ctr", "=", "interaction", "[", "'ctr'", "]", "\n", "\n", "# batch split", "\n", "num_batch", "=", "math", ".", "ceil", "(", "interaction", "[", "'num'", "]", "*", "1.0", "/", "self", ".", "batch_size", ")", "\n", "start_idxs", ",", "end_idxs", "=", "[", "]", ",", "[", "]", "\n", "for", "i_batch", "in", "range", "(", "num_batch", "-", "1", ")", ":", "\n", "            ", "start_idxs", ".", "append", "(", "i_batch", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "(", "i_batch", "+", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "", "start_idxs", ".", "append", "(", "(", "num_batch", "-", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "interaction", "[", "'num'", "]", ")", "\n", "start_idxs", "=", "np", ".", "array", "(", "start_idxs", ",", "dtype", "=", "int", ")", "\n", "end_idxs", "=", "np", ".", "array", "(", "end_idxs", ",", "dtype", "=", "int", ")", "\n", "\n", "# train on batch", "\n", "total_loss", "=", "0", "\n", "for", "i_batch", "in", "range", "(", "len", "(", "start_idxs", ")", ")", ":", "\n", "            ", "start_idx", ",", "end_idx", "=", "start_idxs", "[", "i_batch", "]", ",", "end_idxs", "[", "i_batch", "]", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "{", "'seq'", ":", "seq_list", "[", "start_idx", ":", "end_idx", "]", ",", "'seq_len'", ":", "seq_len", "[", "start_idx", ":", "end_idx", "]", ",", "'target'", ":", "target", "[", "start_idx", ":", "end_idx", "]", ",", "'ctr'", ":", "ctr", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.Seq_Trainer.fit": [[382, 400], ["trainer.Seq_Trainer._data_pre", "time.time.time", "range", "trainer.Seq_Trainer._train_epoch", "trainer.Seq_Trainer.evaluate", "print", "trainer.Seq_Trainer._early_stopping", "trainer.Seq_Trainer.save_model", "time.time.time", "print", "str", "time.time.time"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._train_epoch", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._early_stopping", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.save_model"], ["", "def", "fit", "(", "self", ",", "valid_data", "=", "None", ",", "verbose", "=", "True", ",", "saved", "=", "True", ")", ":", "\n", "        ", "interaction", "=", "self", ".", "_data_pre", "(", "self", ".", "train", ")", "\n", "start", "=", "time", "(", ")", "\n", "for", "epoch_idx", "in", "range", "(", "self", ".", "epochs", ")", ":", "\n", "            ", "train_loss", "=", "self", ".", "_train_epoch", "(", "interaction", ")", "\n", "if", "(", "epoch_idx", "+", "1", ")", "%", "1", "==", "0", ":", "# evaluate on valid set", "\n", "# self.load_model()", "\n", "                ", "valid_results", ",", "valid_loss", "=", "self", ".", "evaluate", "(", ")", "\n", "print", "(", "\"epoch %d, time-consumin: %f s, train-loss: %f, valid-loss: %f, \\nresults on validset: %s\"", "%", "(", "epoch_idx", "+", "1", ",", "time", "(", ")", "-", "start", ",", "train_loss", ",", "valid_loss", ",", "str", "(", "valid_results", ")", ")", ")", "\n", "self", ".", "best_valid_score", ",", "_", ",", "stop_flag", ",", "_", "=", "self", ".", "_early_stopping", "(", "valid_loss", ",", "self", ".", "best_valid_score", ",", "epoch_idx", ",", "10", ",", "bigger", "=", "False", ")", "\n", "# print(self.best_valid_score, stop_flag, valid_loss)", "\n", "# exit(0)", "\n", "if", "stop_flag", ":", "\n", "                    ", "print", "(", "\"Finished training, best eval result in epoch %d\"", "%", "epoch_idx", ")", "\n", "break", "\n", "", "self", ".", "save_model", "(", "epoch_idx", ")", "\n", "start", "=", "time", "(", ")", "\n", "", "", "return", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.Seq_Trainer._eval_epoch": [[401, 434], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "math.ceil", "range", "numpy.array.append", "numpy.array.append", "numpy.array", "numpy.array", "range", "numpy.array.append", "numpy.array.append", "len", "trainer.Seq_Trainer.self.model.full_sort_predict", "trainer.Seq_Trainer.optimizer.zero_grad", "trainer.Seq_Trainer.model.calculate_loss", "trainer.Seq_Trainer.item", "trainer.Seq_Trainer.backward", "trainer.Seq_Trainer.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.full_sort_predict", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_eval_epoch", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "seq_list", "=", "interaction", "[", "'seq'", "]", "\n", "seq_len", "=", "interaction", "[", "'seq_len'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "ctr", "=", "interaction", "[", "'ctr'", "]", "\n", "\n", "# batch split", "\n", "num_batch", "=", "math", ".", "ceil", "(", "interaction", "[", "'num'", "]", "*", "1.0", "/", "self", ".", "batch_size", ")", "\n", "start_idxs", ",", "end_idxs", "=", "[", "]", ",", "[", "]", "\n", "for", "i_batch", "in", "range", "(", "num_batch", "-", "1", ")", ":", "\n", "            ", "start_idxs", ".", "append", "(", "i_batch", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "(", "i_batch", "+", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "", "start_idxs", ".", "append", "(", "(", "num_batch", "-", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "interaction", "[", "'num'", "]", ")", "\n", "start_idxs", "=", "np", ".", "array", "(", "start_idxs", ",", "dtype", "=", "int", ")", "\n", "end_idxs", "=", "np", ".", "array", "(", "end_idxs", ",", "dtype", "=", "int", ")", "\n", "\n", "# eval on batch", "\n", "total_loss", "=", "0", "\n", "\n", "for", "i_batch", "in", "range", "(", "len", "(", "start_idxs", ")", ")", ":", "\n", "            ", "start_idx", ",", "end_idx", "=", "start_idxs", "[", "i_batch", "]", ",", "end_idxs", "[", "i_batch", "]", "\n", "scores", "=", "self", ".", "self", ".", "model", ".", "full_sort_predict", "(", "{", "'seq'", ":", "seq_list", "[", "start_idx", ":", "end_idx", "]", ",", "'seq_len'", ":", "seq_len", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "{", "'seq'", ":", "seq_list", "[", "start_idx", ":", "end_idx", "]", ",", "'seq_len'", ":", "seq_len", "[", "start_idx", ":", "end_idx", "]", ",", "'target'", ":", "target", "[", "start_idx", ":", "end_idx", "]", ",", "'ctr'", ":", "ctr", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.Seq_Trainer.evaluate": [[435, 447], ["trainer.Seq_Trainer._data_pre_fullseq", "trainer.Seq_Trainer.model.calculate_loss().item", "trainer.Seq_Trainer.model.full_sort_predict", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "evaluator.evaluator.calculate_metrics", "targets.view", "target_pos.cpu().numpy", "trainer.Seq_Trainer.model.calculate_loss", "target_pos.cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.Seq_Trainer._data_pre_fullseq", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.full_sort_predict", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.calculate_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "interaction", "=", "self", ".", "_data_pre_fullseq", "(", "self", ".", "data", ".", "train_full", ")", "\n", "# losses", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "interaction", ")", ".", "item", "(", ")", "\n", "# results", "\n", "scores", "=", "self", ".", "model", ".", "full_sort_predict", "(", "interaction", ")", "\n", "# find the position of the target item", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "target_scores", "=", "torch", ".", "gather", "(", "scores", ",", "1", ",", "targets", ".", "view", "(", "-", "1", ",", "1", ")", ")", "# [B 1]", "\n", "target_pos", "=", "(", "scores", ">=", "target_scores", ")", ".", "sum", "(", "-", "1", ")", "# [B]", "\n", "results", "=", "calculate_metrics", "(", "target_pos", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "return", "results", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer.__init__": [[452, 486], ["trainer.AbstractTrainer.__init__", "print", "int", "trainer.OP_Trainer._build_optimizer", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "print", "trainer.OP_Trainer.data.train_full.groupby", "config[].lower", "print", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "trainer.OP_Trainer.data._get_item_birthdate"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._build_optimizer", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._get_item_birthdate"], ["def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "OP_Trainer", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "\n", "self", ".", "splitting", "=", "config", "[", "'splitting'", "]", "\n", "self", ".", "optimizer", "=", "config", "[", "'optimizer'", "]", "\n", "self", ".", "saved_model_file", "=", "\"./checkpoint_dir/\"", "+", "config", "[", "'dataset'", "]", "+", "'_'", "+", "config", "[", "'mode'", "]", "+", "'_ObsPred'", "\n", "print", "(", "\"model will be saved into:\"", ",", "self", ".", "saved_model_file", ")", "\n", "self", ".", "epochs", "=", "config", "[", "'epochs'", "]", "\n", "self", ".", "batch_size", "=", "int", "(", "config", "[", "'batch_size'", "]", ")", "\n", "self", ".", "n_users", "=", "self", ".", "data", ".", "n_users", "\n", "self", ".", "n_items", "=", "self", ".", "data", ".", "n_items", "\n", "self", ".", "n_periods", "=", "self", ".", "data", ".", "n_periods", "\n", "\n", "self", ".", "optimizer", "=", "self", ".", "_build_optimizer", "(", ")", "\n", "if", "self", ".", "splitting", "==", "'random'", ":", "\n", "            ", "return", "\n", "\n", "", "self", ".", "item_birthdate", "=", "torch", ".", "from_numpy", "(", "self", ".", "data", ".", "_get_item_birthdate", "(", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# if config['mode'].lower() in ['tmf','tf']:", "\n", "#     self.ns_type = 'random'", "\n", "# else:", "\n", "#     self.ns_type = 'random'", "\n", "if", "'ns_type'", "not", "in", "config", ":", "\n", "            ", "self", ".", "ns_type", "=", "'random'", "\n", "", "else", ":", "\n", "            ", "self", ".", "ns_type", "=", "config", "[", "'ns_type'", "]", ".", "lower", "(", ")", "\n", "", "print", "(", "\"Training with Negative-Sampling: %s based\"", "%", "self", ".", "ns_type", ")", "\n", "if", "'time'", "in", "self", ".", "ns_type", ":", "\n", "            ", "self", ".", "time_offset", "=", "1", "\n", "print", "(", "\"*********** Training with time-based negative sampling (Assumption: after %d month the user lose attention)\"", "%", "self", ".", "time_offset", ")", "\n", "\n", "", "self", ".", "train_user_pos", "=", "{", "}", "\n", "for", "u", ",", "group", "in", "self", ".", "data", ".", "train_full", ".", "groupby", "(", "by", "=", "[", "'UserId'", "]", ")", ":", "\n", "            ", "self", ".", "train_user_pos", "[", "u", "]", "=", "group", "[", "'ItemId'", "]", ".", "values", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._data_pre": [[488, 504], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.ones_like().to", "torch.ones_like().to", "torch.ones_like().to", "torch.ones_like().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "", "def", "_data_pre", "(", "self", ",", "train_set", ")", ":", "\n", "        ", "train", "=", "train_set", "\n", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "iid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "target", "=", "torch", ".", "ones_like", "(", "iid_list", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "itemage", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'ItemAge'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "timestamp", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'timestamp'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "uid_list", "\n", "interaction", "[", "'item'", "]", "=", "iid_list", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'itemage'", "]", "=", "itemage", "\n", "interaction", "[", "'timestamp'", "]", "=", "timestamp", "\n", "interaction", "[", "'num'", "]", "=", "uid_list", ".", "size", "(", ")", "[", "0", "]", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._merge_interactions": [[506, 519], ["list", "set", "set", "inte1.keys", "inte2.keys", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "print", "exit"], "methods", ["None"], ["", "def", "_merge_interactions", "(", "self", ",", "inte1", ",", "inte2", ")", ":", "\n", "        ", "inte_", "=", "{", "}", "\n", "keys", "=", "list", "(", "set", "(", "inte1", ".", "keys", "(", ")", ")", "&", "set", "(", "inte2", ".", "keys", "(", ")", ")", ")", "\n", "for", "key", "in", "keys", ":", "\n", "            ", "if", "key", "==", "'num'", ":", "\n", "                ", "inte_", "[", "key", "]", "=", "inte1", "[", "key", "]", "+", "inte2", "[", "key", "]", "\n", "", "else", ":", "\n", "                ", "try", ":", "\n", "                    ", "inte_", "[", "key", "]", "=", "torch", ".", "cat", "(", "(", "inte1", "[", "key", "]", ",", "inte2", "[", "key", "]", ")", ",", "0", ")", "\n", "", "except", ":", "\n", "                    ", "print", "(", "key", ")", "\n", "exit", "(", "1", ")", "\n", "", "", "", "return", "inte_", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._neg_sampling_random": [[521, 546], ["train_set.groupby", "numpy.concatenate().astype", "numpy.concatenate().astype", "numpy.concatenate().astype", "numpy.repeat().astype", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "len", "numpy.random.uniform", "numpy.concatenate().astype.append", "numpy.concatenate().astype.append", "numpy.concatenate().astype.append", "numpy.repeat", "numpy.random.randint", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.repeat", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.arange", "numpy.argsort", "len", "len", "len"], "methods", ["None"], ["", "def", "_neg_sampling_random", "(", "self", ",", "train_set", ",", "full_negs", "=", "False", ")", ":", "\n", "        ", "interaction_neg", "=", "{", "}", "\n", "users", ",", "items", ",", "itemages", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "u", ",", "group", "in", "train_set", ".", "groupby", "(", "by", "=", "[", "'UserId'", "]", ")", ":", "\n", "            ", "pos_items", "=", "group", "[", "'ItemId'", "]", ".", "values", "\n", "neg_prob", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "size", "=", "(", "self", ".", "n_items", ",", ")", ")", "\n", "neg_prob", "[", "pos_items", "]", "=", "-", "1.", "\n", "if", "full_negs", ":", "\n", "                ", "neg_items", "=", "np", ".", "arange", "(", "self", ".", "n_items", ")", "[", "neg_prob", ">=", "0.0", "]", "\n", "", "else", ":", "\n", "                ", "neg_items", "=", "np", ".", "argsort", "(", "neg_prob", ")", "[", "-", "len", "(", "pos_items", ")", ":", "]", "\n", "", "users", ".", "append", "(", "np", ".", "repeat", "(", "u", ",", "len", "(", "neg_items", ")", ")", ")", "\n", "items", ".", "append", "(", "neg_items", ")", "\n", "itemages", ".", "append", "(", "np", ".", "random", ".", "randint", "(", "self", ".", "n_periods", ",", "size", "=", "neg_items", ".", "shape", ")", ")", "# randomly generate the itemage", "\n", "", "users", "=", "np", ".", "concatenate", "(", "users", ",", "axis", "=", "0", ")", ".", "astype", "(", "int", ")", "\n", "items", "=", "np", ".", "concatenate", "(", "items", ",", "axis", "=", "0", ")", ".", "astype", "(", "int", ")", "\n", "itemages", "=", "np", ".", "concatenate", "(", "itemages", ",", "axis", "=", "0", ")", ".", "astype", "(", "int", ")", "\n", "targets", "=", "np", ".", "repeat", "(", "0", ",", "len", "(", "users", ")", ")", ".", "astype", "(", "float", ")", "\n", "\n", "interaction_neg", "[", "'user'", "]", "=", "torch", ".", "from_numpy", "(", "users", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction_neg", "[", "'item'", "]", "=", "torch", ".", "from_numpy", "(", "items", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction_neg", "[", "'target'", "]", "=", "torch", ".", "from_numpy", "(", "targets", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction_neg", "[", "'itemage'", "]", "=", "torch", ".", "from_numpy", "(", "itemages", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction_neg", "[", "'num'", "]", "=", "len", "(", "users", ")", "\n", "return", "interaction_neg", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._neg_sampling_time": [[547, 576], ["len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.where", "torch.where", "torch.where", "torch.where", "id2.to", "torch.zeros_like().to", "torch.zeros_like().to", "torch.zeros_like().to", "torch.zeros_like().to", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.randint().to", "torch.randint().to", "torch.randint().to", "torch.randint().to", "torch.randint", "torch.randint", "torch.randint", "torch.randint"], "methods", ["None"], ["", "def", "_neg_sampling_time", "(", "self", ",", "interaction", ",", "full_negs", "=", "False", ",", "bigger", "=", "True", ")", ":", "\n", "# only add the negatives of different timestamp/itemage, O(T*#Ratings)", "\n", "        ", "users", "=", "interaction", "[", "'user'", "]", "\n", "items", "=", "interaction", "[", "'item'", "]", "\n", "num", "=", "interaction", "[", "'num'", "]", "\n", "itemages", "=", "interaction", "[", "'itemage'", "]", "\n", "\n", "interaction_neg", "=", "{", "}", "\n", "if", "full_negs", ":", "\n", "            ", "ui_ia", "=", "torch", ".", "zeros", "(", "(", "num", ",", "self", ".", "n_periods", ")", ",", "dtype", "=", "int", ")", "\n", "ui_ia", "[", "range", "(", "num", ")", ",", "itemages", "]", "=", "1", "\n", "id1", ",", "id2", "=", "torch", ".", "where", "(", "ui_ia", "==", "0", ")", "\n", "users_neg", "=", "users", "[", "id1", "]", "\n", "items_neg", "=", "items", "[", "id1", "]", "\n", "itemages_neg", "=", "id2", ".", "to", "(", "self", ".", "device", ")", "\n", "targets_neg", "=", "torch", ".", "zeros_like", "(", "id2", ",", "dtype", "=", "float", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "# simply add itemage", "\n", "            ", "users_neg", "=", "users", "\n", "items_neg", "=", "items", "\n", "itemages_neg", "=", "(", "itemage", "+", "torch", ".", "randint", "(", "self", ".", "time_offset", ",", "self", ".", "data", ".", "n_periods", ",", "size", "=", "(", "num", ",", ")", ")", ".", "to", "(", "self", ".", "device", ")", ")", ".", "clip", "(", "0", ",", "self", ".", "data", ".", "n_periods", "-", "1", ")", "\n", "targets_neg", "=", "(", "itemages", "==", "itemages_neg", ")", ".", "int", "(", ")", "\n", "\n", "", "interaction_neg", "[", "'num'", "]", "=", "len", "(", "users_neg", ")", "\n", "interaction_neg", "[", "'user'", "]", "=", "users_neg", "\n", "interaction_neg", "[", "'item'", "]", "=", "items_neg", "\n", "interaction_neg", "[", "'target'", "]", "=", "targets_neg", "\n", "interaction_neg", "[", "'itemage'", "]", "=", "itemages_neg", "\n", "return", "interaction_neg", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._neg_sampling_time_based": [[577, 669], ["numpy.zeros", "train.groupby", "numpy.where", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.zeros_like().to", "torch.zeros_like().to", "torch.zeros_like().to", "torch.zeros_like().to", "print", "len", "max", "min", "max", "trainer.OP_Trainer.data.get_itemage", "trainer.OP_Trainer.data.get_itemage", "numpy.arange", "numpy.full", "numpy.arange", "numpy.full", "numpy.arange", "numpy.concatenate.append", "numpy.concatenate.append", "numpy.concatenate.append", "numpy.concatenate.append", "len", "numpy.concatenate", "numpy.concatenate", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "numpy.arange", "numpy.full", "numpy.arange", "numpy.full", "str", "range"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage"], ["", "def", "_neg_sampling_time_based", "(", "self", ")", ":", "\n", "# negatives for training Time-based baselines, O(U*I*T)", "\n", "        ", "train", "=", "self", ".", "data", ".", "train_full", "\n", "ob_uiT", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_users", ",", "self", ".", "n_items", ",", "self", ".", "n_periods", ")", ",", "dtype", "=", "int", ")", "# O(U*I*T)", "\n", "# give all pos (u, i, itemage) label=1", "\n", "users", ",", "items", ",", "itemages", "=", "train", "[", "'UserId'", "]", ",", "train", "[", "'ItemId'", "]", ",", "train", "[", "'ItemAge'", "]", "\n", "# # negatives", "\n", "# u_lifelength = []", "\n", "# n_nnnegs = 0", "\n", "for", "u", ",", "group", "in", "train", ".", "groupby", "(", "by", "=", "[", "'UserId'", "]", ")", ":", "\n", "            ", "lasttime", "=", "max", "(", "group", "[", "'timestamp'", "]", ")", "\n", "# # # dropout the items which are published after the lasttime per user", "\n", "# idx1 = self.data.item_birthdate >= lasttime ", "\n", "# items_neg1 = np.where(idx1)[0]", "\n", "# ob_uiT[u][items_neg1] = -1", "\n", "# # # for each unobserved (u, i), we have L(u, i, all T before lastT_i) = 1, and L(u, i, after lastT_i) = -1", "\n", "# unobserved_items = np.ones(self.n_items)", "\n", "# unobserved_items[group['ItemId']] = 0 # delete observed items", "\n", "# unobserved_items[idx1] = 0 # delete too young items", "\n", "# unobserved_items = np.where(unobserved_items)[0]", "\n", "# # get all T before lasttime", "\n", "# biggestT_perI = self.data.get_itemage(unobserved_items, np.full(unobserved_items.shape, lasttime))", "\n", "# idx_i, idx_T = [], []", "\n", "# for i in range(len(unobserved_items)):", "\n", "#     if (biggestT_perI[i]+1) >= self.n_periods:", "\n", "#         continue", "\n", "#     idx_T.append(np.arange(biggestT_perI[i]+1, self.n_periods))", "\n", "#     idx_i.append(np.full(self.n_periods-(biggestT_perI[i]+1), unobserved_items[i]))", "\n", "# if len(idx_i) > 0:", "\n", "#     idx_i = np.concatenate(idx_i)", "\n", "#     idx_T = np.concatenate(idx_T)", "\n", "#     ob_uiT[u][idx_i, idx_T] = -1", "\n", "# # for (u, any i, t before user first) =-1", "\n", "firsttime", "=", "min", "(", "group", "[", "'timestamp'", "]", ")", "\n", "lasttime", "=", "max", "(", "group", "[", "'timestamp'", "]", ")", "\n", "# u_lifelength.append(lasttime-firsttime)", "\n", "\n", "smallestT_perI", "=", "self", ".", "data", ".", "get_itemage", "(", "np", ".", "arange", "(", "self", ".", "n_items", ")", ",", "np", ".", "full", "(", "self", ".", "n_items", ",", "firsttime", ")", ")", "# inside, clip(0, .)", "\n", "biggestT_perI", "=", "self", ".", "data", ".", "get_itemage", "(", "np", ".", "arange", "(", "self", ".", "n_items", ")", ",", "np", ".", "full", "(", "self", ".", "n_items", ",", "lasttime", ")", ",", "del_young_items", "=", "True", ")", "# if item enters system after lasttime, < 0", "\n", "# if items enters the system after lasttime, not available", "\n", "ob_uiT", "[", "u", "]", "[", "self", ".", "data", ".", "item_birthdate", ">=", "lasttime", "]", "=", "-", "1", "\n", "idx_i", ",", "idx_T", "=", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "np", ".", "arange", "(", "self", ".", "n_items", ")", "[", "self", ".", "data", ".", "item_birthdate", "<", "lasttime", "]", ":", "\n", "# Before user enters the system or after he leaves, item with age = [0, itemage in firsttime] & [itemage in lasttime, n_period]= -1", "\n", "# n_nnnegs += biggestT_perI[i] - smallestT_perI[i] + 1", "\n", "                ", "idx_T", ".", "append", "(", "np", ".", "arange", "(", "smallestT_perI", "[", "i", "]", ")", ")", "\n", "idx_i", ".", "append", "(", "np", ".", "full", "(", "smallestT_perI", "[", "i", "]", ",", "i", ")", ")", "\n", "# idx_T.append(np.arange(smallestT_perI[i]))", "\n", "# idx_i.append(np.full(smallestT_perI[i], i))", "\n", "# if item enters the system before lasttime, [itemage in lasttime, n_periods] not available", "\n", "idx_T", ".", "append", "(", "np", ".", "arange", "(", "biggestT_perI", "[", "i", "]", "+", "1", ",", "self", ".", "n_periods", ")", ")", "\n", "idx_i", ".", "append", "(", "np", ".", "full", "(", "self", ".", "n_periods", "-", "(", "biggestT_perI", "[", "i", "]", "+", "1", ")", ",", "i", ")", ")", "\n", "# if biggestT_perI[i] < 0: # if item enters the system after lasttime, all 1-T is not available (-1)", "\n", "#     idx_T.append(np.arange(self.n_periods))", "\n", "#     idx_i.append(np.full(self.n_periods, i))", "\n", "# else: # if item enters the system before lasttime, [itemage in lasttime, n_periods] not available", "\n", "#     if ((biggestT_perI[i] + 1) < self.n_periods):", "\n", "#         idx_T.append(np.arange(biggestT_perI[i]+1, self.n_periods))", "\n", "#         idx_i.append(np.full(self.n_periods-(biggestT_perI[i]+1), i))", "\n", "", "if", "len", "(", "idx_i", ")", ">", "0", ":", "\n", "                ", "idx_i", "=", "np", ".", "concatenate", "(", "idx_i", ")", "\n", "idx_T", "=", "np", ".", "concatenate", "(", "idx_T", ")", "\n", "ob_uiT", "[", "u", "]", "[", "idx_i", ",", "idx_T", "]", "=", "-", "1", "\n", "", "", "ob_uiT", "[", "users", ",", "items", ",", "itemages", "]", "=", "1", "# positives set 1", "\n", "# u_lifelength_ = (np.array(u_lifelength) / (365 * 24 * 60 * 60)).astype(int)", "\n", "# print(\"user life-length (unit: year): \", np.unique(u_lifelength_, return_counts=True))", "\n", "\n", "# # ob_uiT: l=0 negatives; l=1 positives, l=-1 meaningless samples.", "\n", "users_neg", ",", "items_neg", ",", "itemages_neg", "=", "np", ".", "where", "(", "ob_uiT", "==", "0", ")", "\n", "assert", "users_neg", ".", "shape", "==", "items_neg", ".", "shape", "\n", "users_neg", "=", "torch", ".", "from_numpy", "(", "users_neg", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "items_neg", "=", "torch", ".", "from_numpy", "(", "items_neg", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "itemages_neg", "=", "torch", ".", "from_numpy", "(", "itemages_neg", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "targets_neg", "=", "torch", ".", "zeros_like", "(", "users_neg", ",", "dtype", "=", "float", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# # output the distribution of itemage in training set", "\n", "print", "(", "\"The distributions of p_T in train set:\"", ",", "'\\n'", ",", "'['", ",", "', '", ".", "join", "(", "[", "str", "(", "(", "itemages", ".", "values", "==", "t", ")", ".", "sum", "(", ")", "*", "1.0", "/", "(", "(", "itemages", ".", "values", "==", "t", ")", ".", "sum", "(", ")", "+", "(", "itemages_neg", "==", "t", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "sum", "(", ")", ")", ")", "for", "t", "in", "range", "(", "self", ".", "n_periods", ")", "]", ")", ",", "']'", ")", "\n", "# p_T = []", "\n", "# for t in range(self.n_periods):", "\n", "#     n_pos, n_neg = (itemages.values == t).sum(), (itemages_neg == t).cpu().numpy().sum()", "\n", "#     # print(t, n_pos, n_neg)", "\n", "#     p_T.append(n_pos * 1.0 / (n_pos + n_neg))", "\n", "# print(\"The distributions of p_T in training set:\", '\\n', '[', ', '.join([str(x) for x in p_T]), ']')", "\n", "# exit(0)", "\n", "\n", "interaction_neg", "=", "{", "}", "\n", "interaction_neg", "[", "'num'", "]", "=", "len", "(", "users_neg", ")", "\n", "interaction_neg", "[", "'user'", "]", "=", "users_neg", "\n", "interaction_neg", "[", "'item'", "]", "=", "items_neg", "\n", "interaction_neg", "[", "'target'", "]", "=", "targets_neg", "\n", "interaction_neg", "[", "'itemage'", "]", "=", "itemages_neg", "\n", "return", "interaction_neg", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._neg_sampling": [[670, 720], ["print", "trainer.OP_Trainer._shuffle_date", "trainer.OP_Trainer._neg_sampling_random", "trainer.OP_Trainer._merge_interactions", "trainer.OP_Trainer._neg_sampling_time_based", "trainer.OP_Trainer._merge_interactions", "trainer.OP_Trainer._neg_sampling_time", "trainer.OP_Trainer._merge_interactions", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._shuffle_date", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._neg_sampling_random", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._merge_interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._neg_sampling_time_based", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._merge_interactions", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._neg_sampling_time", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._merge_interactions"], ["", "def", "_neg_sampling", "(", "self", ",", "interaction", ",", "train_set", ")", ":", "\n", "        ", "ns_type", "=", "self", ".", "ns_type", "\n", "# interaction_ = {}", "\n", "# users = interaction['user']", "\n", "# items = interaction['item']", "\n", "# targets = interaction['target']", "\n", "# timestamp = interaction['timestamp']", "\n", "# itemage = interaction['itemage']", "\n", "\n", "if", "ns_type", "==", "'random'", ":", "\n", "# # generate data for negs", "\n", "# interaction_['user'] = torch.cat((users, users), 0)", "\n", "# negs = torch.randint(self.n_items, size=(interaction['num'],)).to(self.device)", "\n", "# interaction_['item'] = torch.cat((items, negs), 0)", "\n", "# target_neg = (items == negs).int()", "\n", "# interaction_['target'] = torch.cat((targets, target_neg), 0)", "\n", "# itemage_neg = self.data.get_itemage(items, timestamp, self.item_birthdate)", "\n", "# # itemage_neg = ((timestamp - self.item_birthdate[items]) * 1.0 / (30*24*60*60)).int().clip(0, self.data.n_months - 1) # unit: month", "\n", "# interaction_['itemage'] = torch.cat((itemage, itemage_neg), 0)", "\n", "# interaction_['num'] = interaction['num'] * 2", "\n", "            ", "interaction_neg", "=", "self", ".", "_neg_sampling_random", "(", "train_set", ",", "full_negs", "=", "True", ")", "\n", "interaction_", "=", "self", ".", "_merge_interactions", "(", "interaction", ",", "interaction_neg", ")", "\n", "", "elif", "ns_type", "==", "'time'", ":", "\n", "# # (u, i, ia) -> 1 as pos, then (u, i-, ia) & (u, i, ia+) as neg", "\n", "# interaction_neg1 = self._neg_sampling_random(train_set, full_negs=True)", "\n", "# interaction_neg2 = self._neg_sampling_time(interaction, full_negs=True)", "\n", "# interaction_ = self._merge_interactions(interaction, interaction_neg1)", "\n", "# interaction_ = self._merge_interactions(interaction_, interaction)", "\n", "# interaction_ = self._merge_interactions(interaction_, interaction_neg2)", "\n", "# # (u, i, T-) and (u, i-, all T) as negatives", "\n", "            ", "interaction_neg", "=", "self", ".", "_neg_sampling_time_based", "(", ")", "\n", "interaction_", "=", "self", ".", "_merge_interactions", "(", "interaction", ",", "interaction_neg", ")", "\n", "", "elif", "ns_type", "==", "'time-only'", ":", "\n", "# # (u,i,t) -> 1, (u,i,t+) -> 0", "\n", "# interaction_['user'] = torch.cat((users, users), 0)", "\n", "# interaction_['item'] = torch.cat((items, items), 0)", "\n", "# num = interaction['num'] ", "\n", "# itemage_neg = (itemage + torch.randint(1, self.data.n_periods, size=(num, )).to(self.device)).clip(0, self.data.n_periods-1)", "\n", "# target_neg = (itemage == itemage_neg).int()", "\n", "# # target_neg = torch.zeros_like(targets).to(self.device)", "\n", "# interaction_['target'] = torch.cat((targets, target_neg), 0)", "\n", "# interaction_['itemage'] = torch.cat((itemage, itemage_neg), 0)", "\n", "# interaction_['num'] = num * 2", "\n", "            ", "interaction_neg", "=", "self", ".", "_neg_sampling_time", "(", "interaction", ",", "full_negs", "=", "True", ")", "\n", "interaction_", "=", "self", ".", "_merge_interactions", "(", "interaction", ",", "interaction_neg", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'[ns_type] should be implemented.'", ")", "\n", "", "print", "(", "\"#pos: %d, #neg: %d\"", "%", "(", "interaction", "[", "'num'", "]", ",", "interaction_", "[", "'num'", "]", "-", "interaction", "[", "'num'", "]", ")", ")", "\n", "# exit(0)", "\n", "return", "self", ".", "_shuffle_date", "(", "interaction_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._train_epoch": [[722, 753], ["int", "range", "numpy.array.append", "numpy.array.append", "numpy.array", "numpy.array", "range", "trainer.OP_Trainer._shuffle_date", "numpy.ceil", "numpy.array.append", "numpy.array.append", "len", "trainer.OP_Trainer.optimizer.zero_grad", "trainer.OP_Trainer.model.calculate_loss", "trainer.OP_Trainer.item", "trainer.OP_Trainer.backward", "trainer.OP_Trainer.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._shuffle_date", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss"], ["", "def", "_train_epoch", "(", "self", ",", "interaction", ",", "shuffle_data", "=", "True", ")", ":", "\n", "        ", "if", "shuffle_data", ":", "\n", "            ", "interaction", "=", "self", ".", "_shuffle_date", "(", "interaction", ")", "\n", "", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "\n", "# batch split", "\n", "num_batch", "=", "int", "(", "np", ".", "ceil", "(", "interaction", "[", "'num'", "]", "*", "1.0", "/", "self", ".", "batch_size", ")", ")", "\n", "start_idxs", ",", "end_idxs", "=", "[", "]", ",", "[", "]", "\n", "for", "i_batch", "in", "range", "(", "num_batch", "-", "1", ")", ":", "\n", "            ", "start_idxs", ".", "append", "(", "i_batch", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "(", "i_batch", "+", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "", "start_idxs", ".", "append", "(", "(", "num_batch", "-", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "interaction", "[", "'num'", "]", ")", "\n", "start_idxs", "=", "np", ".", "array", "(", "start_idxs", ",", "dtype", "=", "int", ")", "\n", "end_idxs", "=", "np", ".", "array", "(", "end_idxs", ",", "dtype", "=", "int", ")", "\n", "\n", "# train on batch", "\n", "total_loss", "=", "0", "\n", "for", "i_batch", "in", "range", "(", "len", "(", "start_idxs", ")", ")", ":", "\n", "            ", "start_idx", ",", "end_idx", "=", "start_idxs", "[", "i_batch", "]", ",", "end_idxs", "[", "i_batch", "]", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "{", "'user'", ":", "user", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "item", "[", "start_idx", ":", "end_idx", "]", ",", "'target'", ":", "target", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemage", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._shuffle_date": [[754, 762], ["torch.randperm().to", "torch.randperm().to", "torch.randperm().to", "torch.randperm().to", "interaction.keys", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm"], "methods", ["None"], ["", "def", "_shuffle_date", "(", "self", ",", "interaction", ")", ":", "\n", "# shuffle the data", "\n", "        ", "order", "=", "torch", ".", "randperm", "(", "interaction", "[", "'num'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "for", "key", "in", "interaction", ".", "keys", "(", ")", ":", "\n", "            ", "if", "key", "!=", "'num'", ":", "\n", "                ", "value", "=", "interaction", "[", "key", "]", "\n", "interaction", "[", "key", "]", "=", "value", "[", "order", "]", "\n", "", "", "return", "interaction", "\n", "", "def", "_numpy2tensor", "(", "self", ",", "interaction", ")", ":", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._numpy2tensor": [[762, 767], ["interaction.keys", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "def", "_numpy2tensor", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "for", "k", "in", "interaction", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "!=", "'num'", ":", "\n", "                ", "interaction", "[", "k", "]", "=", "torch", ".", "from_numpy", "(", "interaction", "[", "k", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer.fit": [[768, 800], ["trainer.OP_Trainer._numpy2tensor", "trainer.OP_Trainer._numpy2tensor", "time.time.time", "range", "trainer.OP_Trainer._train_epoch", "trainer.OP_Trainer.evaluate", "print", "print", "trainer.OP_Trainer._early_stopping", "trainer.OP_Trainer.save_model", "time.time.time", "trainer.OP_Trainer.evaluate", "trainer.OP_Trainer.evaluate", "print", "str", "str", "time.time.time"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._numpy2tensor", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._numpy2tensor", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._train_epoch", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._early_stopping", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.save_model", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate"], ["", "def", "fit", "(", "self", ",", "valid_data", "=", "None", ",", "verbose", "=", "True", ",", "saved", "=", "True", ",", "resampling", "=", "False", ")", ":", "\n", "# if self.splitting == 'random':", "\n", "#     interaction = self._numpy2tensor(self.data.train_interactions)", "\n", "#     interaction_valid = self._numpy2tensor(self.data.valid_interactions)", "\n", "# else: # else, time-based splitting, as old-version: generate negs during training", "\n", "#     interaction_pos = self._data_pre(self.train)", "\n", "        ", "interaction", "=", "self", ".", "_numpy2tensor", "(", "self", ".", "data", ".", "train_interactions", ")", "\n", "interaction_valid", "=", "self", ".", "_numpy2tensor", "(", "self", ".", "data", ".", "valid_interactions", ")", "\n", "\n", "start", "=", "time", "(", ")", "\n", "for", "epoch_idx", "in", "range", "(", "self", ".", "epochs", ")", ":", "\n", "# if (self.splitting != 'random') and ((epoch_idx == 0) or (resampling)):", "\n", "#     interaction = self._neg_sampling(interaction_pos, self.train)", "\n", "            ", "train_loss", "=", "self", ".", "_train_epoch", "(", "interaction", ")", "\n", "if", "(", "epoch_idx", "+", "1", ")", "%", "1", "==", "0", ":", "# evaluate on valid set", "\n", "# self.load_model()", "\n", "                ", "if", "self", ".", "splitting", "==", "'random'", ":", "\n", "                    ", "valid_results", ",", "valid_loss", "=", "self", ".", "evaluate", "(", "interaction_valid", ",", "samplings", "=", "1.0", ")", "\n", "", "else", ":", "\n", "                    ", "valid_results", ",", "valid_loss", "=", "self", ".", "evaluate", "(", "interaction", ")", "\n", "", "print", "(", "\"epoch %d, time-consumin: %f s, train-loss: %f, valid-loss: %f, \\nresults on validset: %s\"", "%", "(", "epoch_idx", "+", "1", ",", "time", "(", ")", "-", "start", ",", "train_loss", ",", "valid_loss", ",", "str", "(", "valid_results", ")", ")", ")", "\n", "self", ".", "best_valid_score", ",", "_", ",", "stop_flag", ",", "_", "=", "self", ".", "_early_stopping", "(", "valid_loss", ",", "self", ".", "best_valid_score", ",", "epoch_idx", ",", "10", ",", "bigger", "=", "False", ")", "\n", "# print(self.best_valid_score, stop_flag, valid_loss)", "\n", "if", "stop_flag", ":", "\n", "                    ", "print", "(", "\"Finished training, best eval result in epoch %d\"", "%", "epoch_idx", ")", "\n", "break", "\n", "", "self", ".", "save_model", "(", "epoch_idx", ")", "\n", "start", "=", "time", "(", ")", "\n", "", "", "if", "self", ".", "splitting", "!=", "'random'", ":", "\n", "            ", "valid_results", ",", "valid_loss", "=", "self", ".", "evaluate", "(", "interaction_valid", ",", "samplings", "=", "1.0", ")", "\n", "print", "(", "\"results on fixed valid set: %s\"", "%", "(", "str", "(", "valid_results", ")", ")", ")", "\n", "", "return", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._eval_epoch": [[801, 832], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "math.ceil", "range", "numpy.array.append", "numpy.array.append", "numpy.array", "numpy.array", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "numpy.array.append", "numpy.array.append", "len", "trainer.OP_Trainer.model.calculate_loss", "torch.cat.append", "torch.cat.append", "trainer.OP_Trainer.item", "trainer.OP_Trainer.model.predict"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.predict"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_eval_epoch", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "\n", "# batch split", "\n", "num_batch", "=", "math", ".", "ceil", "(", "interaction", "[", "'num'", "]", "*", "1.0", "/", "self", ".", "batch_size", ")", "\n", "start_idxs", ",", "end_idxs", "=", "[", "]", ",", "[", "]", "\n", "for", "i_batch", "in", "range", "(", "num_batch", "-", "1", ")", ":", "\n", "            ", "start_idxs", ".", "append", "(", "i_batch", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "(", "i_batch", "+", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "", "start_idxs", ".", "append", "(", "(", "num_batch", "-", "1", ")", "*", "self", ".", "batch_size", ")", "\n", "end_idxs", ".", "append", "(", "interaction", "[", "'num'", "]", ")", "\n", "start_idxs", "=", "np", ".", "array", "(", "start_idxs", ",", "dtype", "=", "int", ")", "\n", "end_idxs", "=", "np", ".", "array", "(", "end_idxs", ",", "dtype", "=", "int", ")", "\n", "\n", "# eval on batch", "\n", "total_loss", "=", "0", "\n", "scores", "=", "[", "]", "\n", "for", "i_batch", "in", "range", "(", "len", "(", "start_idxs", ")", ")", ":", "\n", "            ", "start_idx", ",", "end_idx", "=", "start_idxs", "[", "i_batch", "]", ",", "end_idxs", "[", "i_batch", "]", "\n", "interaction_batch", "=", "{", "'user'", ":", "user", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "item", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemage", "[", "start_idx", ":", "end_idx", "]", ",", "'target'", ":", "target", "[", "start_idx", ":", "end_idx", "]", "}", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "interaction_batch", ")", "\n", "scores", ".", "append", "(", "self", ".", "model", ".", "predict", "(", "interaction_batch", ")", ")", "\n", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "", "scores", "=", "torch", ".", "cat", "(", "scores", ",", "0", ")", "\n", "# scores.clip(min(target), max(target)) # clip the output scores", "\n", "return", "total_loss", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._interaction_split": [[833, 844], ["int", "torch.randperm().to", "torch.randperm().to", "torch.randperm().to", "torch.randperm().to", "interaction.keys", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm"], "methods", ["None"], ["", "def", "_interaction_split", "(", "self", ",", "interaction", ",", "ratio", "=", "0.1", ")", ":", "\n", "        ", "num2", "=", "int", "(", "interaction", "[", "'num'", "]", "*", "ratio", ")", "# valid", "\n", "reorder", "=", "torch", ".", "randperm", "(", "interaction", "[", "'num'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction1", ",", "interaction2", "=", "{", "}", ",", "{", "}", "\n", "interaction1", "[", "'num'", "]", ",", "interaction2", "[", "'num'", "]", "=", "interaction", "[", "'num'", "]", "-", "num2", ",", "num2", "\n", "for", "k", "in", "interaction", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "!=", "'num'", ":", "\n", "                ", "v", "=", "interaction", "[", "k", "]", "[", "reorder", "]", "\n", "interaction1", "[", "k", "]", "=", "v", "[", ":", "-", "num2", "]", "\n", "interaction2", "[", "k", "]", "=", "v", "[", "-", "num2", ":", "]", "\n", "", "", "return", "interaction1", ",", "interaction2", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer.evaluate": [[845, 873], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.OP_Trainer._eval_epoch", "evaluator.evaluator.cal_op_metrics", "trainer.OP_Trainer._data_pre", "trainer.OP_Trainer._neg_sampling", "scores.cpu().numpy", "targets.cpu().numpy", "int", "numpy.random.choice", "scores.cpu", "targets.cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_op_metrics", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OP_Trainer._neg_sampling"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "evaluate", "(", "self", ",", "interaction", "=", "None", ",", "samplings", "=", "0.1", ")", ":", "\n", "# # use training set (pos+negs), sample a small", "\n", "        ", "if", "interaction", "is", "not", "None", ":", "\n", "            ", "if", "samplings", "<", "1.0", ":", "\n", "                ", "num", "=", "int", "(", "interaction", "[", "'num'", "]", "*", "samplings", ")", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "interaction", "[", "'num'", "]", ",", "num", ")", "\n", "interaction_", "=", "{", "}", "\n", "interaction_", "[", "'num'", "]", "=", "num", "\n", "interaction_", "[", "'user'", "]", "=", "interaction", "[", "'user'", "]", "[", "idx", "]", "\n", "interaction_", "[", "'item'", "]", "=", "interaction", "[", "'item'", "]", "[", "idx", "]", "\n", "interaction_", "[", "'itemage'", "]", "=", "interaction", "[", "'itemage'", "]", "[", "idx", "]", "\n", "interaction_", "[", "'target'", "]", "=", "interaction", "[", "'target'", "]", "[", "idx", "]", "\n", "interaction", "=", "interaction_", "\n", "", "", "else", ":", "\n", "# # generate negatives based on validset", "\n", "            ", "interaction_pos", "=", "self", ".", "_data_pre", "(", "self", ".", "data", ".", "valid", ")", "\n", "interaction", "=", "self", ".", "_neg_sampling", "(", "interaction_pos", ",", "self", ".", "data", ".", "valid", ")", "\n", "\n", "# # losses and results", "\n", "# losses = self.model.calculate_loss(interaction).item()", "\n", "# scores = self.model.predict(interaction)", "\n", "", "losses", ",", "scores", "=", "self", ".", "_eval_epoch", "(", "interaction", ")", "\n", "\n", "# find the position of the target item", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "results", "=", "cal_op_metrics", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "targets", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "w_sigmoid", "=", "False", ")", "\n", "return", "results", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OPPT_Trainer.__init__": [[881, 905], ["trainer.AbstractTrainer.__init__", "print", "int", "trainer.OPPT_Trainer._build_optimizer", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "print", "config[].lower", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "trainer.OPPT_Trainer.data._get_item_birthdate"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._build_optimizer", "home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset._get_item_birthdate"], ["def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "OPPT_Trainer", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "if", "config", "[", "'debiasing'", "]", ":", "\n", "            ", "self", ".", "debiasing", "=", "\"_ips\"", "\n", "", "else", ":", "\n", "            ", "self", ".", "debiasing", "=", "'_naive'", "\n", "", "self", ".", "saved_model_file", "=", "\"./checkpoint_dir/OPPT_\"", "+", "config", "[", "'dataset'", "]", "+", "'_'", "+", "config", "[", "'mode'", "]", "+", "self", ".", "debiasing", "\n", "print", "(", "\"model will be saved into:\"", ",", "self", ".", "saved_model_file", ")", "\n", "\n", "self", ".", "optimizer", "=", "config", "[", "'optimizer'", "]", "\n", "self", ".", "epochs", "=", "config", "[", "'epochs'", "]", "\n", "self", ".", "batch_size", "=", "int", "(", "config", "[", "'batch_size'", "]", ")", "\n", "self", ".", "n_users", "=", "self", ".", "data", ".", "n_users", "\n", "self", ".", "n_items", "=", "self", ".", "data", ".", "n_items", "\n", "self", ".", "n_periods", "=", "self", ".", "data", ".", "n_periods", "\n", "\n", "self", ".", "optimizer", "=", "self", ".", "_build_optimizer", "(", ")", "\n", "self", ".", "item_birthdate", "=", "torch", ".", "from_numpy", "(", "self", ".", "data", ".", "_get_item_birthdate", "(", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# negative sampling strategy, random or time (with temporal order)", "\n", "if", "'ns_type'", "not", "in", "config", ":", "\n", "            ", "self", ".", "ns_type", "=", "'random'", "\n", "", "else", ":", "\n", "            ", "self", ".", "ns_type", "=", "config", "[", "'ns_type'", "]", ".", "lower", "(", ")", "\n", "", "print", "(", "\"Training with Negative-Sampling: %s based\"", "%", "self", ".", "ns_type", ")", "\n", "# # np.random.seed only control the train-test-splitting", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OPPT_Trainer._data_pre": [[908, 942], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "trainer.OPPT_Trainer.data.get_itemage", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to.size", "torch.from_numpy().to.size", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.util.data.Dataset.get_itemage"], ["", "def", "_data_pre", "(", "self", ",", "train", ")", ":", "\n", "        ", "'''\n        Different from OIPT, we only need the observed data rather than with negatives (unobservation indicators).\n        Return: (u, i, temporal_content, p(o_{u,i,t}), y), y is one-hot vector\n        '''", "\n", "uid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "iid_list", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "'ItemAge'", "not", "in", "train", ".", "columns", ":", "\n", "            ", "itemage", "=", "self", ".", "data", ".", "get_itemage", "(", "train", "[", "'ItemId'", "]", ",", "train", "[", "'timestamp'", "]", ")", "\n", "itemage", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "itemage", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "itemage", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'ItemAge'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# target = torch.from_numpy(np.where(train['rating'].values > 3, 1, 0).astype(int)).to(self.device) # rating>3 like=1, <=3 dislike=0", "\n", "", "target", "=", "torch", ".", "from_numpy", "(", "train", "[", "'rating'", "]", ".", "values", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "            ", "predOP", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'predOP'", "]", ".", "values", ",", "dtype", "=", "float", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# target = torch.from_numpy(np.array(train['rating'].values, dtype=int)-1).to(self.device)", "\n", "\n", "# train_itemage = self.get_itemage(self.train['ItemId'], self.train['timestamp'])", "\n", "# valid_itemage = self.get_itemage(self.valid['ItemId'], self.valid['timestamp'])", "\n", "# print(\"The distributions of p_T in train set:\", '\\n', '[', ', '.join([str(self.train[train_itemage == t]['rating'].mean()) for t in range(self.n_periods)]), ']')", "\n", "# print(\"The distributions of p_T in valid set:\", '\\n', '[', ', '.join([str(self.valid[valid_itemage == t]['rating'].mean()) for t in range(self.n_periods)]), ']')", "\n", "# print(\"The distributions of p_T in subset:\", '\\n', '[', ', '.join([str(train[test_itemage == t]['rating'].mean()) for t in range(self.n_periods)]), ']')", "\n", "# exit(0)", "\n", "\n", "", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "uid_list", "\n", "interaction", "[", "'item'", "]", "=", "iid_list", "\n", "interaction", "[", "'target'", "]", "=", "target", "\n", "interaction", "[", "'itemage'", "]", "=", "itemage", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "            ", "interaction", "[", "'predOP'", "]", "=", "predOP", "\n", "", "interaction", "[", "'num'", "]", "=", "uid_list", ".", "size", "(", ")", "[", "0", "]", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OPPT_Trainer._shuffle_date": [[943, 951], ["torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "interaction.keys"], "methods", ["None"], ["", "def", "_shuffle_date", "(", "self", ",", "interaction", ")", ":", "\n", "# shuffle the data", "\n", "        ", "order", "=", "torch", ".", "randperm", "(", "interaction", "[", "'num'", "]", ")", "\n", "for", "key", "in", "interaction", ".", "keys", "(", ")", ":", "\n", "            ", "if", "key", "!=", "'num'", ":", "\n", "                ", "value", "=", "interaction", "[", "key", "]", "\n", "interaction", "[", "key", "]", "=", "value", "[", "order", "]", "\n", "", "", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OPPT_Trainer._train_epoch": [[952, 980], ["torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "trainer.OPPT_Trainer.optimizer.zero_grad", "trainer.OPPT_Trainer.model.calculate_loss", "losses.mean.mean.item", "losses.mean.mean.backward", "trainer.OPPT_Trainer.optimizer.step", "torch.mul().mean", "torch.mul().mean", "torch.mul().mean", "torch.mul().mean", "losses.mean.mean.mean", "torch.mul", "torch.mul", "torch.mul", "torch.mul"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss"], ["", "def", "_train_epoch", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "num", "=", "interaction", "[", "'num'", "]", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "            ", "inv_predOP", "=", "torch", ".", "reciprocal", "(", "interaction", "[", "'predOP'", "]", ")", "\n", "# train on batch", "\n", "", "total_loss", "=", "0", "\n", "start_idx", "=", "0", "\n", "end_idx", "=", "start_idx", "+", "self", ".", "batch_size", "\n", "while", "start_idx", "<", "num", ":", "\n", "            ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "{", "'user'", ":", "user", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "item", "[", "start_idx", ":", "end_idx", "]", ",", "'target'", ":", "target", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemage", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "# In task OPPT, the reduction of calculate_loss is none, then ...", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "                ", "losses", "=", "torch", ".", "mul", "(", "losses", ",", "inv_predOP", "[", "start_idx", ":", "end_idx", "]", ")", ".", "mean", "(", ")", "# w/ P(O)", "\n", "", "else", ":", "\n", "                ", "losses", "=", "losses", ".", "mean", "(", ")", "# /o P(O)", "\n", "", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "start_idx", "=", "end_idx", "\n", "end_idx", "+=", "self", ".", "batch_size", "\n", "", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OPPT_Trainer.fit": [[981, 1004], ["trainer.OPPT_Trainer._data_pre", "trainer.OPPT_Trainer._data_pre", "time.time.time", "range", "trainer.OPPT_Trainer._train_epoch", "trainer.OPPT_Trainer.save_model", "trainer.OPPT_Trainer._shuffle_date", "trainer.OPPT_Trainer.evaluate", "print", "trainer.OPPT_Trainer._early_stopping", "time.time.time", "print", "str", "time.time.time"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._train_epoch", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.save_model", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._shuffle_date", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._early_stopping"], ["", "def", "fit", "(", "self", ",", "valid_data", "=", "None", ",", "verbose", "=", "True", ",", "saved", "=", "True", ",", "resampling", "=", "True", ")", ":", "\n", "# interaction = self._data_pre(self.data.train_full)", "\n", "# interaction, interaction_valid = self.train_valid_split(interaction, sampling=0.1)", "\n", "        ", "interaction", "=", "self", ".", "_data_pre", "(", "self", ".", "data", ".", "train", ")", "\n", "interaction_valid", "=", "self", ".", "_data_pre", "(", "self", ".", "data", ".", "valid", ")", "\n", "\n", "start", "=", "time", "(", ")", "\n", "for", "epoch_idx", "in", "range", "(", "self", ".", "epochs", ")", ":", "\n", "            ", "if", "resampling", ":", "\n", "                ", "interaction", "=", "self", ".", "_shuffle_date", "(", "interaction", ")", "\n", "", "train_loss", "=", "self", ".", "_train_epoch", "(", "interaction", ")", "\n", "if", "(", "epoch_idx", "+", "1", ")", "%", "1", "==", "0", ":", "# evaluate on valid set", "\n", "# _, interaction_valid = self.train_valid_split(interaction, sampling=0.25)", "\n", "                ", "valid_results", ",", "valid_loss", "=", "self", ".", "evaluate", "(", "interaction_valid", ")", "\n", "print", "(", "\"epoch %d, time-consumin: %f s, train-loss: %f, valid-loss: %f, \\nresults on validset: %s\"", "%", "(", "epoch_idx", "+", "1", ",", "time", "(", ")", "-", "start", ",", "train_loss", ",", "valid_loss", ",", "str", "(", "valid_results", ")", ")", ")", "\n", "self", ".", "best_valid_score", ",", "_", ",", "stop_flag", ",", "_", "=", "self", ".", "_early_stopping", "(", "valid_loss", ",", "self", ".", "best_valid_score", ",", "epoch_idx", ",", "10", ",", "bigger", "=", "False", ")", "\n", "# print(self.best_valid_score, stop_flag, valid_loss)", "\n", "if", "stop_flag", ":", "\n", "                    ", "print", "(", "\"Finished training, best eval result in epoch %d\"", "%", "epoch_idx", ")", "\n", "break", "\n", "", "start", "=", "time", "(", ")", "\n", "", "self", ".", "save_model", "(", "epoch_idx", ")", "\n", "", "return", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OPPT_Trainer.train_valid_split": [[1005, 1023], ["numpy.random.uniform", "numpy.invert", "interaction.keys", "train_idx.sum", "numpy.invert.sum"], "methods", ["None"], ["", "def", "train_valid_split", "(", "self", ",", "interaction", ",", "sampling", "=", "0.1", ")", ":", "\n", "        ", "num", "=", "interaction", "[", "'num'", "]", "\n", "# np.random.seed(2021)", "\n", "indices", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "num", ")", "\n", "train_idx", "=", "indices", ">=", "sampling", "\n", "valid_idx", "=", "np", ".", "invert", "(", "train_idx", ")", "\n", "num_train", ",", "num_valid", "=", "(", "train_idx", ")", ".", "sum", "(", ")", ",", "(", "valid_idx", ")", ".", "sum", "(", ")", "\n", "assert", "(", "num_train", "+", "num_valid", ")", "==", "num", "\n", "\n", "interaction_train", ",", "interaction_valid", "=", "{", "}", ",", "{", "}", "\n", "interaction_train", "[", "'num'", "]", "=", "num_train", "\n", "interaction_valid", "[", "'num'", "]", "=", "num_valid", "\n", "for", "k", "in", "interaction", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "!=", "'num'", ":", "\n", "                ", "value", "=", "interaction", "[", "k", "]", "\n", "interaction_train", "[", "k", "]", "=", "value", "[", "train_idx", "]", "\n", "interaction_valid", "[", "k", "]", "=", "value", "[", "valid_idx", "]", "\n", "", "", "return", "interaction_train", ",", "interaction_valid", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OPPT_Trainer.evaluate": [[1024, 1037], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.OPPT_Trainer._eval_epoch", "evaluator.evaluator.cal_ratpred_metrics", "scores.size", "targets.size", "interaction[].cpu().numpy", "scores.cpu().numpy", "targets.cpu().numpy", "interaction[].cpu().numpy", "interaction[].cpu", "scores.cpu", "targets.cpu", "interaction[].cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_ratpred_metrics"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "evaluate", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "losses", ",", "scores", "=", "self", ".", "_eval_epoch", "(", "interaction", ")", "\n", "# find the position of the target item", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "# print(targets.size(), scores.size())", "\n", "assert", "scores", ".", "size", "(", ")", "==", "targets", ".", "size", "(", ")", "\n", "# results = cal_op_metrics(scores.cpu().numpy(), targets.cpu().numpy(), w_sigmoid=False)", "\n", "predOP", "=", "None", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "            ", "predOP", "=", "interaction", "[", "'predOP'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "# np.reciprocal(interaction['predOP'].cpu().numpy()) # IPS ", "\n", "", "results", "=", "cal_ratpred_metrics", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "targets", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "predOP", "=", "predOP", ",", "users", "=", "interaction", "[", "'user'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "return", "results", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.OPPT_Trainer._eval_epoch": [[1038, 1072], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "trainer.OPPT_Trainer.model.calculate_loss", "losses.mean.mean.item", "torch.cat.append", "torch.cat.append", "torch.mul().mean", "torch.mul().mean", "torch.mul().mean", "torch.mul().mean", "losses.mean.mean.mean", "trainer.OPPT_Trainer.model.predict", "torch.mul", "torch.mul", "torch.mul", "torch.mul"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.predict"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_eval_epoch", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "            ", "inv_predOP", "=", "torch", ".", "reciprocal", "(", "interaction", "[", "'predOP'", "]", ")", "\n", "", "num", "=", "interaction", "[", "'num'", "]", "\n", "\n", "start_idx", "=", "0", "\n", "end_idx", "=", "start_idx", "+", "self", ".", "batch_size", "\n", "total_loss", "=", "0", "\n", "scores", "=", "[", "]", "\n", "while", "start_idx", "<", "num", ":", "\n", "            ", "interaction_batch", "=", "{", "'user'", ":", "user", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "item", "[", "start_idx", ":", "end_idx", "]", ",", "'target'", ":", "target", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemage", "[", "start_idx", ":", "end_idx", "]", "}", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "interaction_batch", ")", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "                ", "losses", "=", "torch", ".", "mul", "(", "losses", ",", "inv_predOP", "[", "start_idx", ":", "end_idx", "]", ")", ".", "mean", "(", ")", "# w/ P(O)", "\n", "", "else", ":", "\n", "                ", "losses", "=", "losses", ".", "mean", "(", ")", "# /o P(O)", "\n", "", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "scores", ".", "append", "(", "self", ".", "model", ".", "predict", "(", "interaction_batch", ")", ")", "\n", "start_idx", "=", "end_idx", "\n", "end_idx", "+=", "self", ".", "batch_size", "\n", "# print(scores[-1].size())", "\n", "", "scores", "=", "torch", ".", "cat", "(", "scores", ",", "0", ")", "\n", "# scores.clip(min(target), max(target)) # clip the output scores", "\n", "# scores = scores * 0 + 3.514037", "\n", "\n", "# preds_ = np.stack((target.cpu().numpy(), scores.cpu().numpy(), np.zeros_like(scores.cpu().numpy())+3.514037),axis=1)", "\n", "# np.savetxt('preds_onValid.csv', preds_)", "\n", "return", "total_loss", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__": [[1080, 1097], ["trainer.AbstractTrainer.__init__", "print", "int", "trainer.TART_Trainer._build_optimizer"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.__init__", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._build_optimizer"], ["def", "__init__", "(", "self", ",", "config", ",", "model", ",", "data", ")", ":", "\n", "        ", "super", "(", "TART_Trainer", ",", "self", ")", ".", "__init__", "(", "config", ",", "model", ",", "data", ")", "\n", "if", "config", "[", "'debiasing'", "]", ":", "\n", "            ", "self", ".", "debiasing", "=", "\"_ips\"", "\n", "", "else", ":", "\n", "            ", "self", ".", "debiasing", "=", "'_naive'", "\n", "", "self", ".", "saved_model_file", "=", "\"./checkpoint_dir/TART_\"", "+", "config", "[", "'dataset'", "]", "+", "'_'", "+", "config", "[", "'mode'", "]", "+", "self", ".", "debiasing", "\n", "print", "(", "\"model will be saved into:\"", ",", "self", ".", "saved_model_file", ")", "\n", "\n", "self", ".", "optimizer", "=", "config", "[", "'optimizer'", "]", "\n", "self", ".", "epochs", "=", "config", "[", "'epochs'", "]", "\n", "self", ".", "batch_size", "=", "int", "(", "config", "[", "'batch_size'", "]", ")", "\n", "self", ".", "n_users", "=", "self", ".", "data", ".", "n_users", "\n", "self", ".", "n_items", "=", "self", ".", "data", ".", "n_items", "\n", "self", ".", "n_periods", "=", "self", ".", "data", ".", "n_periods", "\n", "\n", "self", ".", "optimizer", "=", "self", ".", "_build_optimizer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre": [[1098, 1111], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "len", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "_data_pre", "(", "self", ",", "train", ")", ":", "\n", "        ", "'''\n        Different from OIPT, we only need the observed data rather than with negatives (unobservation indicators).\n        Return: (u, i, temporal_content, p(o_{u,i,t}), y), y is one-hot vector\n        '''", "\n", "interaction", "=", "{", "}", "\n", "interaction", "[", "'user'", "]", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'UserId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "[", "'item'", "]", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'ItemId'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "[", "'itemage'", "]", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'itemage'", "]", ".", "values", ",", "dtype", "=", "int", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "[", "'target'", "]", "=", "torch", ".", "from_numpy", "(", "train", "[", "'rating'", "]", ".", "values", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "[", "'predOP'", "]", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "train", "[", "'predOP'", "]", ".", "values", ",", "dtype", "=", "float", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "interaction", "[", "'num'", "]", "=", "len", "(", "train", ")", "\n", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._shuffle_date": [[1112, 1120], ["torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "interaction.keys"], "methods", ["None"], ["", "def", "_shuffle_date", "(", "self", ",", "interaction", ")", ":", "\n", "# shuffle the data", "\n", "        ", "order", "=", "torch", ".", "randperm", "(", "interaction", "[", "'num'", "]", ")", "\n", "for", "key", "in", "interaction", ".", "keys", "(", ")", ":", "\n", "            ", "if", "key", "!=", "'num'", ":", "\n", "                ", "value", "=", "interaction", "[", "key", "]", "\n", "interaction", "[", "key", "]", "=", "value", "[", "order", "]", "\n", "", "", "return", "interaction", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._train_epoch": [[1121, 1151], ["torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "trainer.TART_Trainer.optimizer.zero_grad", "trainer.TART_Trainer.model.calculate_loss", "losses.mean.mean.item", "losses.mean.mean.backward", "trainer.TART_Trainer.optimizer.step", "torch.mul().mean", "torch.mul().mean", "torch.mul().mean", "torch.mul().mean", "losses.mean.mean.mean", "torch.mul", "torch.mul", "torch.mul", "torch.mul"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss"], ["", "def", "_train_epoch", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "num", "=", "interaction", "[", "'num'", "]", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "            ", "inv_predOP", "=", "torch", ".", "reciprocal", "(", "interaction", "[", "'predOP'", "]", ")", "\n", "# print(\"!!!! Using SNIPS !!!!\")", "\n", "# inv_predOP = inv_predOP / inv_predOP.mean()", "\n", "# train on batch", "\n", "", "total_loss", "=", "0", "\n", "start_idx", "=", "0", "\n", "end_idx", "=", "start_idx", "+", "self", ".", "batch_size", "\n", "while", "start_idx", "<", "num", ":", "\n", "            ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "{", "'user'", ":", "user", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "item", "[", "start_idx", ":", "end_idx", "]", ",", "'target'", ":", "target", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemage", "[", "start_idx", ":", "end_idx", "]", "}", ")", "\n", "# In task TART, the reduction of calculate_loss is none, then ...", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "                ", "losses", "=", "torch", ".", "mul", "(", "losses", ",", "inv_predOP", "[", "start_idx", ":", "end_idx", "]", ")", ".", "mean", "(", ")", "#.sum() / (self.n_users * self.n_items) # w/ P(O)", "\n", "", "else", ":", "\n", "                ", "losses", "=", "losses", ".", "mean", "(", ")", "# /o P(O)", "\n", "", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "start_idx", "=", "end_idx", "\n", "end_idx", "+=", "self", ".", "batch_size", "\n", "", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.fit": [[1152, 1171], ["trainer.TART_Trainer._data_pre", "trainer.TART_Trainer._data_pre", "time.time.time", "range", "trainer.TART_Trainer._train_epoch", "trainer.TART_Trainer.save_model", "trainer.TART_Trainer._shuffle_date", "trainer.TART_Trainer.evaluate", "print", "trainer.TART_Trainer._early_stopping", "time.time.time", "print", "str", "time.time.time"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._data_pre", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._train_epoch", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.save_model", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._shuffle_date", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer._early_stopping"], ["", "def", "fit", "(", "self", ",", "valid_data", "=", "None", ",", "verbose", "=", "True", ",", "saved", "=", "True", ",", "resampling", "=", "True", ")", ":", "\n", "        ", "interaction", "=", "self", ".", "_data_pre", "(", "self", ".", "data", ".", "train", ")", "\n", "interaction_valid", "=", "self", ".", "_data_pre", "(", "self", ".", "data", ".", "valid", ")", "\n", "\n", "start", "=", "time", "(", ")", "\n", "for", "epoch_idx", "in", "range", "(", "self", ".", "epochs", ")", ":", "\n", "            ", "if", "resampling", ":", "\n", "                ", "interaction", "=", "self", ".", "_shuffle_date", "(", "interaction", ")", "\n", "", "train_loss", "=", "self", ".", "_train_epoch", "(", "interaction", ")", "\n", "if", "(", "epoch_idx", "+", "1", ")", "%", "1", "==", "0", ":", "# evaluate on valid set", "\n", "                ", "valid_results", ",", "valid_loss", "=", "self", ".", "evaluate", "(", "interaction_valid", ")", "\n", "print", "(", "\"epoch %d, time-consumin: %f s, train-loss: %f, valid-loss: %f, \\nresults on validset: %s\"", "%", "(", "epoch_idx", "+", "1", ",", "time", "(", ")", "-", "start", ",", "train_loss", ",", "valid_loss", ",", "str", "(", "valid_results", ")", ")", ")", "\n", "self", ".", "best_valid_score", ",", "_", ",", "stop_flag", ",", "_", "=", "self", ".", "_early_stopping", "(", "valid_loss", ",", "self", ".", "best_valid_score", ",", "epoch_idx", ",", "10", ",", "bigger", "=", "False", ")", "\n", "if", "stop_flag", ":", "\n", "                    ", "print", "(", "\"Finished training, best eval result in epoch %d\"", "%", "epoch_idx", ")", "\n", "break", "\n", "", "start", "=", "time", "(", ")", "\n", "", "self", ".", "save_model", "(", "epoch_idx", ")", "\n", "", "return", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate": [[1172, 1183], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.TART_Trainer._eval_epoch", "evaluator.evaluator.cal_ratpred_metrics", "scores.size", "targets.size", "interaction[].cpu().numpy", "scores.cpu().numpy", "targets.cpu().numpy", "interaction[].cpu().numpy", "interaction[].cpu", "scores.cpu", "targets.cpu", "interaction[].cpu"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch", "home.repos.pwc.inspect_result.betsyhj_dancer.evaluator.evaluator.cal_ratpred_metrics"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "evaluate", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "losses", ",", "scores", "=", "self", ".", "_eval_epoch", "(", "interaction", ")", "\n", "targets", "=", "interaction", "[", "'target'", "]", "\n", "assert", "scores", ".", "size", "(", ")", "==", "targets", ".", "size", "(", ")", "\n", "# results = cal_op_metrics(scores.cpu().numpy(), targets.cpu().numpy(), w_sigmoid=False)", "\n", "predOP", "=", "None", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "            ", "predOP", "=", "interaction", "[", "'predOP'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "# np.reciprocal(interaction['predOP'].cpu().numpy()) # IPS ", "\n", "", "results", "=", "cal_ratpred_metrics", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "targets", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "predOP", "=", "predOP", ",", "users", "=", "interaction", "[", "'user'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "return", "results", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer._eval_epoch": [[1184, 1215], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "trainer.TART_Trainer.model.calculate_loss", "losses.mean.mean.item", "torch.cat.append", "torch.cat.append", "torch.mul().mean", "torch.mul().mean", "torch.mul().mean", "torch.mul().mean", "losses.mean.mean.mean", "trainer.TART_Trainer.model.predict", "torch.mul", "torch.mul", "torch.mul", "torch.mul"], "methods", ["home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.calculate_loss", "home.repos.pwc.inspect_result.betsyhj_dancer.offlineExp.gru4rec.GRU4Rec.predict"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_eval_epoch", "(", "self", ",", "interaction", ")", ":", "\n", "        ", "user", "=", "interaction", "[", "'user'", "]", "\n", "item", "=", "interaction", "[", "'item'", "]", "\n", "target", "=", "interaction", "[", "'target'", "]", "\n", "itemage", "=", "interaction", "[", "'itemage'", "]", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "            ", "inv_predOP", "=", "torch", ".", "reciprocal", "(", "interaction", "[", "'predOP'", "]", ")", "\n", "# # print(\"!!!! Using SNIPS !!!!\")", "\n", "# inv_predOP = inv_predOP / inv_predOP.mean()", "\n", "", "num", "=", "interaction", "[", "'num'", "]", "\n", "\n", "start_idx", "=", "0", "\n", "end_idx", "=", "start_idx", "+", "self", ".", "batch_size", "\n", "total_loss", "=", "0", "\n", "scores", "=", "[", "]", "\n", "while", "start_idx", "<", "num", ":", "\n", "            ", "interaction_batch", "=", "{", "'user'", ":", "user", "[", "start_idx", ":", "end_idx", "]", ",", "'item'", ":", "item", "[", "start_idx", ":", "end_idx", "]", ",", "'target'", ":", "target", "[", "start_idx", ":", "end_idx", "]", ",", "'itemage'", ":", "itemage", "[", "start_idx", ":", "end_idx", "]", "}", "\n", "losses", "=", "self", ".", "model", ".", "calculate_loss", "(", "interaction_batch", ")", "\n", "if", "'ips'", "in", "self", ".", "debiasing", ":", "\n", "                ", "losses", "=", "torch", ".", "mul", "(", "losses", ",", "inv_predOP", "[", "start_idx", ":", "end_idx", "]", ")", ".", "mean", "(", ")", "# w/ P(O)", "\n", "", "else", ":", "\n", "                ", "losses", "=", "losses", ".", "mean", "(", ")", "# /o P(O)", "\n", "", "total_loss", "+=", "losses", ".", "item", "(", ")", "\n", "scores", ".", "append", "(", "self", ".", "model", ".", "predict", "(", "interaction_batch", ")", ")", "\n", "start_idx", "=", "end_idx", "\n", "end_idx", "+=", "self", ".", "batch_size", "\n", "# print(scores[-1].size())", "\n", "", "scores", "=", "torch", ".", "cat", "(", "scores", ",", "0", ")", "\n", "return", "total_loss", ",", "scores", "", "", "", ""]], "home.repos.pwc.inspect_result.betsyhj_dancer.examples.run_exp._get_conf": [[25, 31], ["configparser.ConfigParser", "configparser.ConfigParser.read", "dict", "conf[].lower", "configparser.ConfigParser.items"], "function", ["None"], ["def", "_get_conf", "(", "conf_name", ")", ":", "\n", "    ", "config", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "config", ".", "read", "(", "\"../conf/\"", "+", "conf_name", "+", "\".properties\"", ")", "\n", "conf", "=", "dict", "(", "config", ".", "items", "(", "\"default\"", ")", ")", "\n", "conf", "[", "'mode'", "]", "=", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "\n", "return", "conf", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.examples.run_exp._logging_": [[32, 46], ["time.localtime", "time.strftime", "print", "print", "print", "time.time", "print", "print", "basis_conf[].lower", "str"], "function", ["None"], ["", "def", "_logging_", "(", "basis_conf", ",", "params_conf", ")", ":", "\n", "    ", "now", "=", "localtime", "(", "time", "(", ")", ")", "\n", "now", "=", "strftime", "(", "\"%Y-%m-%d %H:%M:%S\"", ",", "now", ")", "\n", "origin_data_name", "=", "basis_conf", "[", "\"data.input.dataset\"", "]", "\n", "debiasing", "=", "basis_conf", "[", "\"debiasing\"", "]", "\n", "print", "(", "now", "+", "\" - data: %s\"", "%", "origin_data_name", ")", "\n", "print", "(", "now", "+", "\" - task: %s\"", "%", "(", "params_conf", "[", "'task'", "]", ")", ")", "\n", "print", "(", "now", "+", "\" - model: %s, debiasing: %s\"", "%", "(", "basis_conf", "[", "'mode'", "]", ",", "debiasing", ")", ")", "\n", "# print(now + \" - use gpu: %s\" % (basis_conf['use_gpu']))", "\n", "if", "(", "\"evaluation\"", "in", "basis_conf", ")", "and", "(", "basis_conf", "[", "'evaluation'", "]", ".", "lower", "(", ")", "==", "'true'", ")", ":", "\n", "        ", "print", "(", "now", "+", "\" - directly load well-trained model and evaluate\"", ",", "flush", "=", "True", ")", "\n", "\n", "", "if", "basis_conf", "[", "'mode'", "]", "[", "0", "]", "!=", "'b'", ":", "# baselines do not have params", "\n", "        ", "print", "(", "\"conf : \"", "+", "str", "(", "params_conf", ")", ",", "flush", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.examples.run_exp.run_dqn": [[48, 184], ["run_exp._get_conf", "run_exp.set_hparams", "run_exp.load_parameters", "run_exp._logging_", "util.data.Dataset", "MODEL", "Trainer", "trainer.fit.eval", "Evaluator", "evaluator.evaluator.TART_Evaluator.evaluate", "set_hparams.mode.lower", "conf[].upper", "conf[].upper", "random.seed", "numpy.random.seed", "torch.manual_seed", "task.upper", "conf[].lower", "exit", "conf[].lower", "print", "Trainer.load_model", "print", "Trainer.fit", "conf[].upper", "task.upper", "set_hparams.setting.lower", "set_hparams.setting.lower", "evaluator.evaluator.OP_Evaluator", "conf[].lower", "conf[].lower", "trainer.fit.state_dict().keys", "set_hparams.setting.lower", "evaluator.evaluator.TART_Evaluator.evaluate", "evaluator.evaluator.OPPT_Evaluator", "evaluator.evaluator.TART_Evaluator.evaluate", "evaluator.evaluator.TART_Evaluator", "evaluator.evaluator.TART_Evaluator.evaluate", "conf[].lower", "conf[].lower", "trainer.fit.state_dict", "conf[].lower", "conf[].lower", "conf[].lower", "conf[].lower", "conf[].lower", "NotImplementedError"], "function", ["home.repos.pwc.inspect_result.betsyhj_dancer.examples.run_exp._get_conf", "home.repos.pwc.inspect_result.betsyhj_dancer.examples.run_exp.set_hparams", "home.repos.pwc.inspect_result.betsyhj_dancer.examples.run_exp.load_parameters", "home.repos.pwc.inspect_result.betsyhj_dancer.examples.run_exp._logging_", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.AbstractTrainer.load_model", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.fit", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate", "home.repos.pwc.inspect_result.betsyhj_dancer.trainer.trainer.TART_Trainer.evaluate"], ["", "", "def", "run_dqn", "(", ")", ":", "\n", "    ", "conf", "=", "_get_conf", "(", "'ml-100k'", ")", "\n", "# for multiple jobs in ", "\n", "args", "=", "set_hparams", "(", ")", "\n", "if", "args", ".", "mode", "is", "not", "None", ":", "\n", "        ", "conf", "[", "'mode'", "]", "=", "args", ".", "mode", ".", "lower", "(", ")", "\n", "", "if", "args", ".", "task", "is", "not", "None", ":", "\n", "        ", "conf", "[", "'task'", "]", "=", "args", ".", "task", "\n", "", "if", "conf", "[", "'task'", "]", ".", "upper", "(", ")", "in", "[", "'OIPT'", ",", "'OPPT'", "]", ":", "\n", "        ", "conf", "[", "'data.input.dataset'", "]", "=", "'ml-latest-small'", "\n", "", "else", ":", "\n", "        ", "conf", "[", "'data.input.dataset'", "]", "=", "'simulation2'", "\n", "# for splitting setting or observed setting in first two tasks:", "\n", "", "if", "conf", "[", "'task'", "]", ".", "upper", "(", ")", "==", "'OIPT'", ":", "\n", "        ", "if", "args", ".", "setting", "is", "not", "None", ":", "\n", "            ", "conf", "[", "'splitting'", "]", "=", "args", ".", "setting", "\n", "", "", "elif", "conf", "[", "'task'", "]", ".", "upper", "(", ")", "==", "'OPPT'", ":", "\n", "        ", "conf", "[", "'debiasing'", "]", "=", "args", ".", "setting", "\n", "\n", "# init DQN", "\n", "", "config", "=", "load_parameters", "(", "conf", "[", "'mode'", "]", ")", "\n", "if", "args", ".", "lr", "is", "not", "None", ":", "\n", "        ", "config", "[", "\"learning_rate\"", "]", "=", "args", ".", "lr", "\n", "", "if", "args", ".", "reg", "is", "not", "None", ":", "\n", "        ", "config", "[", "'l2_reg'", "]", "=", "args", ".", "reg", "\n", "", "if", "args", ".", "seed", "is", "not", "None", ":", "\n", "        ", "config", "[", "'seed'", "]", "=", "args", ".", "seed", "\n", "\n", "# # set random seed", "\n", "", "if", "'seed'", "in", "config", ":", "\n", "        ", "random", ".", "seed", "(", "config", "[", "'seed'", "]", ")", "\n", "np", ".", "random", ".", "seed", "(", "config", "[", "'seed'", "]", ")", "\n", "torch", ".", "manual_seed", "(", "config", "[", "'seed'", "]", ")", "\n", "\n", "", "task", "=", "'OIPT'", "\n", "# task = 'OPPT' # task 2: in paper, named as UPPT", "\n", "# task = 'TART' # task 3, only on simulated data", "\n", "if", "'task'", "in", "conf", ":", "\n", "        ", "task", "=", "conf", "[", "'task'", "]", "\n", "", "config", "[", "'task'", "]", "=", "task", "\n", "if", "task", ".", "upper", "(", ")", "in", "[", "'OPPT'", ",", "'TART'", "]", ":", "\n", "        ", "config", "[", "'loss_type'", "]", "=", "'mse'", "\n", "", "if", "(", "task", ".", "upper", "(", ")", "==", "'TART'", ")", "and", "(", "args", ".", "setting", "is", "not", "None", ")", ":", "\n", "        ", "conf", "[", "'StaticIPS'", "]", "=", "(", "args", ".", "setting", ".", "lower", "(", ")", "==", "'staticips'", ")", "\n", "if", "'ips'", "in", "args", ".", "setting", ".", "lower", "(", ")", ":", "\n", "            ", "conf", "[", "'debiasing'", "]", "=", "'ips'", "\n", "", "elif", "'dancer'", "in", "args", ".", "setting", ".", "lower", "(", ")", ":", "\n", "            ", "conf", "[", "'debiasing'", "]", "=", "'ips'", "\n", "", "else", ":", "\n", "            ", "conf", "[", "'debiasing'", "]", "=", "'naive'", "\n", "", "", "_logging_", "(", "conf", ",", "config", ")", "\n", "## loading data", "\n", "data", "=", "Dataset", "(", "conf", ",", "task", "=", "task", ")", "\n", "# ctr = data.train['ctr']", "\n", "\n", "# # add random-splitting for task 1: OIPT", "\n", "if", "task", "==", "'OIPT'", ":", "\n", "        ", "config", "[", "'splitting'", "]", "=", "'time'", "\n", "if", "'splitting'", "in", "conf", ":", "\n", "            ", "config", "[", "'splitting'", "]", "=", "conf", "[", "'splitting'", "]", "\n", "# add some fixed parameters", "\n", "", "", "config", "[", "'path'", "]", "=", "conf", "[", "'data.input.path'", "]", "\n", "config", "[", "'dataset'", "]", "=", "conf", "[", "'data.input.dataset'", "]", "\n", "config", "[", "'epochs'", "]", "=", "500", "\n", "if", "conf", "[", "'debiasing'", "]", ".", "lower", "(", ")", "==", "'ips'", ":", "\n", "        ", "config", "[", "'debiasing'", "]", "=", "True", "\n", "", "else", ":", "\n", "        ", "config", "[", "'debiasing'", "]", "=", "False", "\n", "\n", "# Super simple baselines just need some statistic info without training process.", "\n", "", "if", "'b'", "in", "conf", "[", "'mode'", "]", ":", "\n", "        ", "if", "config", "[", "'task'", "]", "==", "'OIPT'", ":", "\n", "            ", "evaluator", "=", "OP_Evaluator", "(", "config", ",", "None", ",", "data", ")", "\n", "# evaluator.evaluate(baselines=conf['mode'], subset='neg')", "\n", "for", "subset", "in", "[", "None", ",", "'pos'", ",", "'neg'", "]", ":", "\n", "                ", "evaluator", ".", "evaluate", "(", "baselines", "=", "conf", "[", "'mode'", "]", ",", "subset", "=", "subset", ")", "\n", "# for subset in [None, 'pos', 'neg']:", "\n", "#     for i in range(1, 4):", "\n", "#         print(\"\\n*-*-*-*-*- B%d -*-*-*-*-*\" % i)", "\n", "#         evaluator.evaluate(baselines='b%d'%i, subset=subset)", "\n", "", "", "elif", "config", "[", "'task'", "]", "==", "'OPPT'", ":", "\n", "            ", "evaluator", "=", "OPPT_Evaluator", "(", "config", ",", "None", ",", "data", ")", "\n", "evaluator", ".", "evaluate", "(", "baselines", "=", "conf", "[", "'mode'", "]", ")", "\n", "", "else", ":", "\n", "            ", "evaluator", "=", "TART_Evaluator", "(", "config", ",", "None", ",", "data", ")", "\n", "evaluator", ".", "evaluate", "(", "baselines", "=", "conf", "[", "'mode'", "]", ")", "\n", "", "exit", "(", "0", ")", "\n", "\n", "", "if", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "==", "\"tmf\"", ":", "\n", "        ", "MODEL", "=", "TMF", "\n", "", "elif", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "==", "\"tmf_v\"", ":", "\n", "        ", "MODEL", "=", "TMF_variety", "\n", "", "elif", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "==", "\"tmf_fast\"", ":", "\n", "        ", "MODEL", "=", "TMF_fast", "\n", "", "elif", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "==", "\"tmf_fast_v\"", ":", "\n", "        ", "MODEL", "=", "TMF_fast_variety", "\n", "", "elif", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "==", "\"tmtf\"", ":", "\n", "        ", "MODEL", "=", "TMTF", "\n", "", "elif", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "==", "\"tf\"", ":", "\n", "        ", "MODEL", "=", "TF", "\n", "", "elif", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "==", "\"mf\"", ":", "\n", "        ", "MODEL", "=", "MF", "\n", "", "elif", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "==", "\"mf_v\"", ":", "\n", "        ", "MODEL", "=", "MF_v", "\n", "", "elif", "conf", "[", "'mode'", "]", ".", "lower", "(", ")", "==", "\"gru4rec\"", ":", "\n", "        ", "MODEL", "=", "GRU4Rec", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Make sure 'mode' in ['GRU4Rec', 'TMF', 'TMF_fast', 'MF', 'TF', 'TMTF']!\"", ")", "\n", "\n", "# # train process", "\n", "", "config", "[", "'mode'", "]", "=", "conf", "[", "'mode'", "]", "\n", "model", "=", "MODEL", "(", "config", ",", "data", ",", "debiasing", "=", "config", "[", "'debiasing'", "]", ")", "\n", "if", "(", "'task'", "in", "config", ")", "and", "(", "config", "[", "'task'", "]", "==", "'OPPT'", ")", ":", "\n", "        ", "Trainer", "=", "OPPT_Trainer", "\n", "", "elif", "(", "'task'", "in", "config", ")", "and", "(", "config", "[", "'task'", "]", "==", "'TART'", ")", ":", "\n", "        ", "Trainer", "=", "TART_Trainer", "\n", "", "else", ":", "\n", "        ", "Trainer", "=", "OP_Trainer", "\n", "", "trainer", "=", "Trainer", "(", "config", ",", "model", ",", "data", ")", "\n", "if", "(", "\"evaluation\"", "in", "conf", ")", "and", "(", "conf", "[", "'evaluation'", "]", ".", "lower", "(", ")", "==", "'true'", ")", ":", "\n", "        ", "print", "(", "\"Directly load well-trained model and evaluate\"", ")", "\n", "trainer", ".", "load_model", "(", ")", "\n", "print", "(", "\"saved params:\"", ",", "model", ".", "state_dict", "(", ")", ".", "keys", "(", ")", ")", "\n", "", "else", ":", "\n", "        ", "model", "=", "trainer", ".", "fit", "(", ")", "\n", "\n", "# evaluate process", "\n", "", "model", ".", "eval", "(", ")", "\n", "if", "(", "'task'", "in", "config", ")", "and", "(", "config", "[", "'task'", "]", "==", "'OPPT'", ")", ":", "\n", "        ", "Evaluator", "=", "OPPT_Evaluator", "\n", "", "elif", "(", "'task'", "in", "config", ")", "and", "(", "config", "[", "'task'", "]", "==", "'TART'", ")", ":", "\n", "        ", "Evaluator", "=", "TART_Evaluator", "\n", "", "else", ":", "\n", "        ", "Evaluator", "=", "OP_Evaluator", "\n", "", "evaluator", "=", "Evaluator", "(", "config", ",", "model", ",", "data", ")", "\n", "evaluator", ".", "evaluate", "(", ")", "\n", "# evaluator.evaluate(ub='false')", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.examples.run_exp.load_parameters": [[191, 205], ["configparser.ConfigParser", "configparser.ConfigParser.read", "dict", "mode.lower", "configparser.ConfigParser.items", "mode.lower", "mode.lower"], "function", ["None"], ["", "def", "load_parameters", "(", "mode", ")", ":", "\n", "    ", "params", "=", "{", "}", "\n", "config", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "if", "'tmf_fast_v'", "in", "mode", ".", "lower", "(", ")", ":", "\n", "        ", "mode", "=", "'tmf_fast'", "\n", "", "elif", "'tmf_v'", "in", "mode", ".", "lower", "(", ")", ":", "\n", "        ", "mode", "=", "'tmf'", "\n", "", "elif", "'mf_v'", "in", "mode", ".", "lower", "(", ")", ":", "\n", "        ", "mode", "=", "'mf'", "\n", "", "elif", "mode", "[", "0", "]", "==", "'b'", ":", "\n", "        ", "return", "{", "}", "\n", "", "config", ".", "read", "(", "\"../conf/\"", "+", "mode", "+", "\".properties\"", ")", "\n", "conf", "=", "dict", "(", "config", ".", "items", "(", "\"hyperparameters\"", ")", ")", "\n", "return", "conf", "\n", "\n"]], "home.repos.pwc.inspect_result.betsyhj_dancer.examples.run_exp.set_hparams": [[206, 217], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["", "def", "set_hparams", "(", ")", ":", "\n", "    ", "import", "argparse", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'--task'", ",", "type", "=", "str", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "type", "=", "float", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--reg'", ",", "type", "=", "float", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--mode'", ",", "type", "=", "str", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--setting'", ",", "type", "=", "str", ",", "default", "=", "None", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]]}