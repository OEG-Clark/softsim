{"home.repos.pwc.inspect_result.IBM_AIF360.examples.common_utils.compute_metrics": [[5, 27], ["aif360.metrics.ClassificationMetric", "collections.OrderedDict", "aif360.metrics.ClassificationMetric.statistical_parity_difference", "aif360.metrics.ClassificationMetric.disparate_impact", "aif360.metrics.ClassificationMetric.average_odds_difference", "aif360.metrics.ClassificationMetric.equal_opportunity_difference", "aif360.metrics.ClassificationMetric.theil_index", "aif360.metrics.ClassificationMetric.true_positive_rate", "aif360.metrics.ClassificationMetric.true_negative_rate", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_odds_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.equal_opportunity_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.theil_index", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate"], ["def", "compute_metrics", "(", "dataset_true", ",", "dataset_pred", ",", "\n", "unprivileged_groups", ",", "privileged_groups", ",", "\n", "disp", "=", "True", ")", ":", "\n", "    ", "\"\"\" Compute the key metrics \"\"\"", "\n", "classified_metric_pred", "=", "ClassificationMetric", "(", "dataset_true", ",", "\n", "dataset_pred", ",", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ")", "\n", "metrics", "=", "OrderedDict", "(", ")", "\n", "metrics", "[", "\"Balanced accuracy\"", "]", "=", "0.5", "*", "(", "classified_metric_pred", ".", "true_positive_rate", "(", ")", "+", "\n", "classified_metric_pred", ".", "true_negative_rate", "(", ")", ")", "\n", "metrics", "[", "\"Statistical parity difference\"", "]", "=", "classified_metric_pred", ".", "statistical_parity_difference", "(", ")", "\n", "metrics", "[", "\"Disparate impact\"", "]", "=", "classified_metric_pred", ".", "disparate_impact", "(", ")", "\n", "metrics", "[", "\"Average odds difference\"", "]", "=", "classified_metric_pred", ".", "average_odds_difference", "(", ")", "\n", "metrics", "[", "\"Equal opportunity difference\"", "]", "=", "classified_metric_pred", ".", "equal_opportunity_difference", "(", ")", "\n", "metrics", "[", "\"Theil index\"", "]", "=", "classified_metric_pred", ".", "theil_index", "(", ")", "\n", "\n", "if", "disp", ":", "\n", "        ", "for", "k", "in", "metrics", ":", "\n", "            ", "print", "(", "\"%s = %.4f\"", "%", "(", "k", ",", "metrics", "[", "k", "]", ")", ")", "\n", "\n", "", "", "return", "metrics", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.aif360.decorating_metaclass.do_decorate": [[4, 6], ["callable", "getattr", "attr.startswith"], "function", ["None"], ["def", "do_decorate", "(", "attr", ",", "value", ")", ":", "\n", "    ", "return", "not", "attr", ".", "startswith", "(", "'_'", ")", "and", "callable", "(", "value", ")", "and", "getattr", "(", "value", ",", "'__decorate__'", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.aif360.decorating_metaclass.factory": [[7, 23], ["dct.items", "super().__new__", "decorating_metaclass.do_decorate", "decorator"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.aif360.decorating_metaclass.do_decorate"], ["", "def", "factory", "(", "decorator", ")", ":", "\n", "    ", "class", "ApplyDecoratorMeta", "(", "ABCMeta", ")", ":", "\n", "        ", "\"\"\"Metaclass which applies a decorator to all public, non-special\n        instance methods.\n\n        Note:\n            `decorator` must use @functools.wraps(f) for abstractmethod to work.\n\n        https://stackoverflow.com/questions/10067262/automatically-decorating-every-instance-method-in-a-class\n        \"\"\"", "\n", "def", "__new__", "(", "cls", ",", "name", ",", "bases", ",", "dct", ")", ":", "\n", "            ", "for", "attr", ",", "value", "in", "dct", ".", "items", "(", ")", ":", "\n", "                ", "if", "do_decorate", "(", "attr", ",", "value", ")", ":", "\n", "                    ", "dct", "[", "attr", "]", "=", "decorator", "(", "value", ")", "\n", "", "", "return", "super", "(", "ApplyDecoratorMeta", ",", "cls", ")", ".", "__new__", "(", "cls", ",", "name", ",", "bases", ",", "dct", ")", "\n", "", "", "return", "ApplyDecoratorMeta", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.aif360.decorating_metaclass.dont_decorate": [[24, 27], ["None"], "function", ["None"], ["", "def", "dont_decorate", "(", "func", ")", ":", "\n", "    ", "func", ".", "__decorate__", "=", "False", "\n", "return", "func", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.aif360.decorating_metaclass.ApplyDecorator": [[28, 30], ["decorating_metaclass.factory", "str"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.aif360.decorating_metaclass.factory"], ["", "def", "ApplyDecorator", "(", "decorator", ")", ":", "\n", "    ", "return", "factory", "(", "decorator", ")", "(", "str", "(", "'ApplyDecorator'", ")", ",", "(", ")", ",", "{", "}", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.binary_label_dataset.BinaryLabelDataset.__init__": [[9, 22], ["float", "float", "aif360.datasets.StructuredDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "favorable_label", "=", "1.", ",", "unfavorable_label", "=", "0.", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            favorable_label (float): Label value which is considered favorable\n                (i.e. \"positive\").\n            unfavorable_label (float): Label value which is considered\n                unfavorable (i.e. \"negative\").\n            **kwargs: StructuredDataset arguments.\n        \"\"\"", "\n", "self", ".", "favorable_label", "=", "float", "(", "favorable_label", ")", "\n", "self", ".", "unfavorable_label", "=", "float", "(", "unfavorable_label", ")", "\n", "\n", "super", "(", "BinaryLabelDataset", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.binary_label_dataset.BinaryLabelDataset.validate_dataset": [[23, 48], ["numpy.all", "super().validate_dataset", "ValueError", "ValueError", "set", "set", "binary_label_dataset.BinaryLabelDataset.labels.ravel"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.validate_dataset"], ["", "def", "validate_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Error checking and type validation.\n\n        Raises:\n            ValueError: `labels` must be shape [n, 1].\n            ValueError: `favorable_label` and `unfavorable_label` must be the\n                only values present in `labels`.\n        \"\"\"", "\n", "# fix scores before validating", "\n", "if", "np", ".", "all", "(", "self", ".", "scores", "==", "self", ".", "labels", ")", ":", "\n", "            ", "self", ".", "scores", "=", "(", "self", ".", "scores", "==", "self", ".", "favorable_label", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "\n", "", "super", "(", "BinaryLabelDataset", ",", "self", ")", ".", "validate_dataset", "(", ")", "\n", "\n", "# =========================== SHAPE CHECKING ===========================", "\n", "# Verify if the labels are only 1 column", "\n", "if", "self", ".", "labels", ".", "shape", "[", "1", "]", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"BinaryLabelDataset only supports single-column \"", "\n", "\"labels:\\n\\tlabels.shape = {}\"", ".", "format", "(", "self", ".", "labels", ".", "shape", ")", ")", "\n", "\n", "# =========================== VALUE CHECKING ===========================", "\n", "# Check if the favorable and unfavorable labels match those in the dataset", "\n", "", "if", "(", "not", "set", "(", "self", ".", "labels", ".", "ravel", "(", ")", ")", "<=", "\n", "set", "(", "[", "self", ".", "favorable_label", ",", "self", ".", "unfavorable_label", "]", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"The favorable and unfavorable labels provided do \"", "\n", "\"not match the labels in the dataset.\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.multiclass_label_dataset.MulticlassLabelDataset.__init__": [[10, 23], ["aif360.datasets.StructuredDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "favorable_label", "=", "[", "1.", "]", ",", "unfavorable_label", "=", "[", "0.", "]", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            favorable_label (list): Label value which is considered favorable\n                (i.e. \"positive\").\n            unfavorable_label (list): Label value which is considered\n                unfavorable (i.e. \"negative\").\n            **kwargs: StructuredDataset arguments.\n        \"\"\"", "\n", "self", ".", "favorable_label", "=", "favorable_label", "\n", "self", ".", "unfavorable_label", "=", "unfavorable_label", "\n", "\n", "super", "(", "MulticlassLabelDataset", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.multiclass_label_dataset.MulticlassLabelDataset.validate_dataset": [[25, 54], ["numpy.all", "super().validate_dataset", "range", "ValueError", "ValueError", "len", "set", "set", "float", "float", "multiclass_label_dataset.MulticlassLabelDataset.labels.ravel"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.validate_dataset", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "validate_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Error checking and type validation.\n\u200b\n        Raises:\n            ValueError: `labels` must be shape [n, 1].\n            ValueError: `favorable_label` and `unfavorable_label` must be the\n                only values present in `labels`.\n        \"\"\"", "\n", "# fix scores before validating", "\n", "if", "np", ".", "all", "(", "self", ".", "scores", "==", "self", ".", "labels", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "scores", ")", ")", ":", "\n", "                ", "if", "self", ".", "scores", "[", "i", "]", "in", "self", ".", "favorable_label", ":", "\n", "                    ", "self", ".", "scores", "[", "i", "]", "=", "float", "(", "1", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "scores", "[", "i", "]", "=", "float", "(", "0", ")", "\n", "\n", "", "", "", "super", "(", "MulticlassLabelDataset", ",", "self", ")", ".", "validate_dataset", "(", ")", "\n", "\n", "# =========================== SHAPE CHECKING ===========================", "\n", "# Verify if the labels are only 1 column", "\n", "if", "self", ".", "labels", ".", "shape", "[", "1", "]", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"MulticlassLabelDataset only supports single-column \"", "\n", "\"labels:\\n\\tlabels.shape = {}\"", ".", "format", "(", "self", ".", "labels", ".", "shape", ")", ")", "\n", "\n", "# =========================== VALUE CHECKING ===========================", "\n", "# Check if the favorable and unfavorable labels match those in the dataset", "\n", "", "if", "(", "not", "set", "(", "self", ".", "labels", ".", "ravel", "(", ")", ")", "<=", "\n", "set", "(", "self", ".", "favorable_label", "+", "(", "self", ".", "unfavorable_label", ")", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"The favorable and unfavorable labels provided do \"", "\n", "\"not match the labels in the dataset.\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.adult_dataset.AdultDataset.__init__": [[20, 116], ["os.path.join", "os.path.join", "pandas.concat", "aif360.datasets.StandardDataset.__init__", "os.path.dirname", "os.path.dirname", "pandas.read_csv", "pandas.read_csv", "os.path.abspath", "os.path.abspath", "print", "print", "print", "print", "print", "print", "print", "sys.exit", "os.path.abspath", "os.path.join", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "label_name", "=", "'income-per-year'", ",", "\n", "favorable_classes", "=", "[", "'>50K'", ",", "'>50K.'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'race'", ",", "'sex'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'White'", "]", ",", "[", "'Male'", "]", "]", ",", "\n", "instance_weights_name", "=", "None", ",", "\n", "categorical_features", "=", "[", "'workclass'", ",", "'education'", ",", "\n", "'marital-status'", ",", "'occupation'", ",", "'relationship'", ",", "\n", "'native-country'", "]", ",", "\n", "features_to_keep", "=", "[", "]", ",", "features_to_drop", "=", "[", "'fnlwgt'", "]", ",", "\n", "na_values", "=", "[", "'?'", "]", ",", "custom_preprocessing", "=", "None", ",", "\n", "metadata", "=", "default_mappings", ")", ":", "\n", "        ", "\"\"\"See :obj:`StandardDataset` for a description of the arguments.\n\n        Examples:\n            The following will instantiate a dataset which uses the `fnlwgt`\n            feature:\n\n            >>> from aif360.datasets import AdultDataset\n            >>> ad = AdultDataset(instance_weights_name='fnlwgt',\n            ... features_to_drop=[])\n            WARNING:root:Missing Data: 3620 rows removed from dataset.\n            >>> not np.all(ad.instance_weights == 1.)\n            True\n\n            To instantiate a dataset which utilizes only numerical features and\n            a single protected attribute, run:\n\n            >>> single_protected = ['sex']\n            >>> single_privileged = [['Male']]\n            >>> ad = AdultDataset(protected_attribute_names=single_protected,\n            ... privileged_classes=single_privileged,\n            ... categorical_features=[],\n            ... features_to_keep=['age', 'education-num'])\n            >>> print(ad.feature_names)\n            ['education-num', 'age', 'sex']\n            >>> print(ad.label_names)\n            ['income-per-year']\n\n            Note: the `protected_attribute_names` and `label_name` are kept even\n            if they are not explicitly given in `features_to_keep`.\n\n            In some cases, it may be useful to keep track of a mapping from\n            `float -> str` for protected attributes and/or labels. If our use\n            case differs from the default, we can modify the mapping stored in\n            `metadata`:\n\n            >>> label_map = {1.0: '>50K', 0.0: '<=50K'}\n            >>> protected_attribute_maps = [{1.0: 'Male', 0.0: 'Female'}]\n            >>> ad = AdultDataset(protected_attribute_names=['sex'],\n            ... categorical_features=['workclass', 'education', 'marital-status',\n            ... 'occupation', 'relationship', 'native-country', 'race'],\n            ... privileged_classes=[['Male']], metadata={'label_map': label_map,\n            ... 'protected_attribute_maps': protected_attribute_maps})\n\n            Note that we are now adding `race` as a `categorical_features`.\n            Now this information will stay attached to the dataset and can be\n            used for more descriptive visualizations.\n        \"\"\"", "\n", "\n", "train_path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'data'", ",", "'raw'", ",", "'adult'", ",", "'adult.data'", ")", "\n", "test_path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'data'", ",", "'raw'", ",", "'adult'", ",", "'adult.test'", ")", "\n", "# as given by adult.names", "\n", "column_names", "=", "[", "'age'", ",", "'workclass'", ",", "'fnlwgt'", ",", "'education'", ",", "\n", "'education-num'", ",", "'marital-status'", ",", "'occupation'", ",", "'relationship'", ",", "\n", "'race'", ",", "'sex'", ",", "'capital-gain'", ",", "'capital-loss'", ",", "'hours-per-week'", ",", "\n", "'native-country'", ",", "'income-per-year'", "]", "\n", "try", ":", "\n", "            ", "train", "=", "pd", ".", "read_csv", "(", "train_path", ",", "header", "=", "None", ",", "names", "=", "column_names", ",", "\n", "skipinitialspace", "=", "True", ",", "na_values", "=", "na_values", ")", "\n", "test", "=", "pd", ".", "read_csv", "(", "test_path", ",", "header", "=", "0", ",", "names", "=", "column_names", ",", "\n", "skipinitialspace", "=", "True", ",", "na_values", "=", "na_values", ")", "\n", "", "except", "IOError", "as", "err", ":", "\n", "            ", "print", "(", "\"IOError: {}\"", ".", "format", "(", "err", ")", ")", "\n", "print", "(", "\"To use this class, please download the following files:\"", ")", "\n", "print", "(", "\"\\n\\thttps://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\"", ")", "\n", "print", "(", "\"\\thttps://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.test\"", ")", "\n", "print", "(", "\"\\thttps://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.names\"", ")", "\n", "print", "(", "\"\\nand place them, as-is, in the folder:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'adult'", ")", ")", ")", ")", "\n", "import", "sys", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "df", "=", "pd", ".", "concat", "(", "[", "test", ",", "train", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "super", "(", "AdultDataset", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_name", "=", "label_name", ",", "\n", "favorable_classes", "=", "favorable_classes", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_classes", "=", "privileged_classes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "features_to_keep", ",", "\n", "features_to_drop", "=", "features_to_drop", ",", "na_values", "=", "na_values", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ",", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.meps_dataset_panel21_fy2016.MEPSDataset21.__init__": [[70, 116], ["os.path.join", "aif360.datasets.StandardDataset.__init__", "os.path.dirname", "pandas.read_csv", "os.path.abspath", "print", "print", "print", "print", "print", "sys.exit", "os.path.abspath", "os.path.abspath", "os.path.join", "os.path.join", "os.path.abspath", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "label_name", "=", "'UTILIZATION'", ",", "favorable_classes", "=", "[", "1.0", "]", ",", "\n", "protected_attribute_names", "=", "[", "'RACE'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'White'", "]", "]", ",", "\n", "instance_weights_name", "=", "'PERWT16F'", ",", "\n", "categorical_features", "=", "[", "'REGION'", ",", "'SEX'", ",", "'MARRY'", ",", "\n", "'FTSTU'", ",", "'ACTDTY'", ",", "'HONRDC'", ",", "'RTHLTH'", ",", "'MNHLTH'", ",", "'HIBPDX'", ",", "'CHDDX'", ",", "'ANGIDX'", ",", "\n", "'MIDX'", ",", "'OHRTDX'", ",", "'STRKDX'", ",", "'EMPHDX'", ",", "'CHBRON'", ",", "'CHOLDX'", ",", "'CANCERDX'", ",", "'DIABDX'", ",", "\n", "'JTPAIN'", ",", "'ARTHDX'", ",", "'ARTHTYPE'", ",", "'ASTHDX'", ",", "'ADHDADDX'", ",", "'PREGNT'", ",", "'WLKLIM'", ",", "\n", "'ACTLIM'", ",", "'SOCLIM'", ",", "'COGLIM'", ",", "'DFHEAR42'", ",", "'DFSEE42'", ",", "'ADSMOK42'", ",", "'PHQ242'", ",", "\n", "'EMPST'", ",", "'POVCAT'", ",", "'INSCOV'", "]", ",", "\n", "features_to_keep", "=", "[", "'REGION'", ",", "'AGE'", ",", "'SEX'", ",", "'RACE'", ",", "'MARRY'", ",", "\n", "'FTSTU'", ",", "'ACTDTY'", ",", "'HONRDC'", ",", "'RTHLTH'", ",", "'MNHLTH'", ",", "'HIBPDX'", ",", "'CHDDX'", ",", "'ANGIDX'", ",", "\n", "'MIDX'", ",", "'OHRTDX'", ",", "'STRKDX'", ",", "'EMPHDX'", ",", "'CHBRON'", ",", "'CHOLDX'", ",", "'CANCERDX'", ",", "'DIABDX'", ",", "\n", "'JTPAIN'", ",", "'ARTHDX'", ",", "'ARTHTYPE'", ",", "'ASTHDX'", ",", "'ADHDADDX'", ",", "'PREGNT'", ",", "'WLKLIM'", ",", "\n", "'ACTLIM'", ",", "'SOCLIM'", ",", "'COGLIM'", ",", "'DFHEAR42'", ",", "'DFSEE42'", ",", "'ADSMOK42'", ",", "\n", "'PCS42'", ",", "\n", "'MCS42'", ",", "'K6SUM42'", ",", "'PHQ242'", ",", "'EMPST'", ",", "'POVCAT'", ",", "'INSCOV'", ",", "'UTILIZATION'", ",", "'PERWT16F'", "]", ",", "\n", "features_to_drop", "=", "[", "]", ",", "\n", "na_values", "=", "[", "]", ",", "custom_preprocessing", "=", "default_preprocessing", ",", "\n", "metadata", "=", "default_mappings", ")", ":", "\n", "\n", "        ", "filepath", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'data'", ",", "'raw'", ",", "'meps'", ",", "'h192.csv'", ")", "\n", "\n", "try", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "sep", "=", "','", ",", "na_values", "=", "na_values", ")", "\n", "", "except", "IOError", "as", "err", ":", "\n", "            ", "print", "(", "\"IOError: {}\"", ".", "format", "(", "err", ")", ")", "\n", "print", "(", "\"To use this class, please follow the instructions in:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'meps'", ",", "'README.md'", ")", ")", ")", ")", "\n", "print", "(", "\"\\n to download and convert the 2016 data and place the final h192.csv file, as-is, in the folder:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'meps'", ")", ")", ")", ")", "\n", "import", "sys", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "super", "(", "MEPSDataset21", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_name", "=", "label_name", ",", "\n", "favorable_classes", "=", "favorable_classes", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_classes", "=", "privileged_classes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "features_to_keep", ",", "\n", "features_to_drop", "=", "features_to_drop", ",", "na_values", "=", "na_values", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ",", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.meps_dataset_panel21_fy2016.default_preprocessing": [[12, 62], ["df.rename.apply", "df.rename.rename", "df.rename.rename", "df.rename.apply", "df.rename.rename", "meps_dataset_panel21_fy2016.default_preprocessing.race"], "function", ["None"], ["def", "default_preprocessing", "(", "df", ")", ":", "\n", "    ", "\"\"\"\n    1.Create a new column, RACE that is 'White' if RACEV2X = 1 and HISPANX = 2 i.e. non Hispanic White\n      and 'Non-White' otherwise\n    2. Restrict to Panel 21\n    3. RENAME all columns that are PANEL/ROUND SPECIFIC\n    4. Drop rows based on certain values of individual features that correspond to missing/unknown - generally < -1\n    5. Compute UTILIZATION, binarize it to 0 (< 10) and 1 (>= 10)\n    \"\"\"", "\n", "def", "race", "(", "row", ")", ":", "\n", "        ", "if", "(", "(", "row", "[", "'HISPANX'", "]", "==", "2", ")", "and", "(", "row", "[", "'RACEV2X'", "]", "==", "1", ")", ")", ":", "#non-Hispanic Whites are marked as WHITE; all others as NON-WHITE", "\n", "            ", "return", "'White'", "\n", "", "return", "'Non-White'", "\n", "\n", "", "df", "[", "'RACEV2X'", "]", "=", "df", ".", "apply", "(", "lambda", "row", ":", "race", "(", "row", ")", ",", "axis", "=", "1", ")", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'RACEV2X'", ":", "'RACE'", "}", ")", "\n", "\n", "df", "=", "df", "[", "df", "[", "'PANEL'", "]", "==", "21", "]", "\n", "\n", "# RENAME COLUMNS", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'FTSTU53X'", ":", "'FTSTU'", ",", "'ACTDTY53'", ":", "'ACTDTY'", ",", "'HONRDC53'", ":", "'HONRDC'", ",", "'RTHLTH53'", ":", "'RTHLTH'", ",", "\n", "'MNHLTH53'", ":", "'MNHLTH'", ",", "'CHBRON53'", ":", "'CHBRON'", ",", "'JTPAIN53'", ":", "'JTPAIN'", ",", "'PREGNT53'", ":", "'PREGNT'", ",", "\n", "'WLKLIM53'", ":", "'WLKLIM'", ",", "'ACTLIM53'", ":", "'ACTLIM'", ",", "'SOCLIM53'", ":", "'SOCLIM'", ",", "'COGLIM53'", ":", "'COGLIM'", ",", "\n", "'EMPST53'", ":", "'EMPST'", ",", "'REGION53'", ":", "'REGION'", ",", "'MARRY53X'", ":", "'MARRY'", ",", "'AGE53X'", ":", "'AGE'", ",", "\n", "'POVCAT16'", ":", "'POVCAT'", ",", "'INSCOV16'", ":", "'INSCOV'", "}", ")", "\n", "\n", "df", "=", "df", "[", "df", "[", "'REGION'", "]", ">=", "0", "]", "# remove values -1", "\n", "df", "=", "df", "[", "df", "[", "'AGE'", "]", ">=", "0", "]", "# remove values -1", "\n", "\n", "df", "=", "df", "[", "df", "[", "'MARRY'", "]", ">=", "0", "]", "# remove values -1, -7, -8, -9", "\n", "\n", "df", "=", "df", "[", "df", "[", "'ASTHDX'", "]", ">=", "0", "]", "# remove values -1, -7, -8, -9", "\n", "\n", "df", "=", "df", "[", "(", "df", "[", "[", "'FTSTU'", ",", "'ACTDTY'", ",", "'HONRDC'", ",", "'RTHLTH'", ",", "'MNHLTH'", ",", "'HIBPDX'", ",", "'CHDDX'", ",", "'ANGIDX'", ",", "'EDUCYR'", ",", "'HIDEG'", ",", "\n", "'MIDX'", ",", "'OHRTDX'", ",", "'STRKDX'", ",", "'EMPHDX'", ",", "'CHBRON'", ",", "'CHOLDX'", ",", "'CANCERDX'", ",", "'DIABDX'", ",", "\n", "'JTPAIN'", ",", "'ARTHDX'", ",", "'ARTHTYPE'", ",", "'ASTHDX'", ",", "'ADHDADDX'", ",", "'PREGNT'", ",", "'WLKLIM'", ",", "\n", "'ACTLIM'", ",", "'SOCLIM'", ",", "'COGLIM'", ",", "'DFHEAR42'", ",", "'DFSEE42'", ",", "'ADSMOK42'", ",", "\n", "'PHQ242'", ",", "'EMPST'", ",", "'POVCAT'", ",", "'INSCOV'", "]", "]", ">=", "-", "1", ")", ".", "all", "(", "1", ")", "]", "#for all other categorical features, remove values < -1", "\n", "\n", "def", "utilization", "(", "row", ")", ":", "\n", "        ", "return", "row", "[", "'OBTOTV16'", "]", "+", "row", "[", "'OPTOTV16'", "]", "+", "row", "[", "'ERTOT16'", "]", "+", "row", "[", "'IPNGTD16'", "]", "+", "row", "[", "'HHTOTD16'", "]", "\n", "\n", "", "df", "[", "'TOTEXP16'", "]", "=", "df", ".", "apply", "(", "lambda", "row", ":", "utilization", "(", "row", ")", ",", "axis", "=", "1", ")", "\n", "lessE", "=", "df", "[", "'TOTEXP16'", "]", "<", "10.0", "\n", "df", ".", "loc", "[", "lessE", ",", "'TOTEXP16'", "]", "=", "0.0", "\n", "moreE", "=", "df", "[", "'TOTEXP16'", "]", ">=", "10.0", "\n", "df", ".", "loc", "[", "moreE", ",", "'TOTEXP16'", "]", "=", "1.0", "\n", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'TOTEXP16'", ":", "'UTILIZATION'", "}", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.lime_encoder.LimeEncoder.__init__": [[21, 23], ["aif360.algorithms.Transformer.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "LimeEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.lime_encoder.LimeEncoder.fit": [[24, 80], ["dataset.convert_to_dataframe", "df.drop", "list", "list", "sklearn.preprocessing.LabelEncoder", "sklearn.preprocessing.LabelEncoder.fit", "lime_encoder.LimeEncoder.s_feature_names.index", "sklearn.preprocessing.LabelEncoder", "lime_encoder.LimeEncoder.le.fit", "set", "set"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.convert_to_dataframe", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "fit", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Take an aif360 dataset and save all relevant metadata as well as\n        mappings needed to transform/inverse_transform the data between aif360\n        and lime.\n\n        Args:\n            dataset (BinaryLabelDataset): aif360 dataset\n\n        Returns:\n            LimeEncoder: Returns self.\n        \"\"\"", "\n", "self", ".", "s_feature_names_with_one_hot_encoding", "=", "dataset", ".", "feature_names", "\n", "df", ",", "df_dict", "=", "dataset", ".", "convert_to_dataframe", "(", "de_dummy_code", "=", "True", ")", "\n", "\n", "dfc", "=", "df", ".", "drop", "(", "dataset", ".", "label_names", "[", "0", "]", ",", "axis", "=", "1", ")", "# remove label (class) column", "\n", "\n", "self", ".", "s_feature_names", "=", "list", "(", "dfc", ".", "columns", ")", "# create list of feature names", "\n", "self", ".", "s_data", "=", "dfc", ".", "values", "# create array of feature values", "\n", "\n", "# since categorical features are 1-hot-encoded and their names changed,", "\n", "# the set diff gives us the list of categorical features as non-", "\n", "# categorical feature names are not changed", "\n", "self", ".", "s_categorical_features", "=", "list", "(", "set", "(", "self", ".", "s_feature_names", ")", "\n", "-", "set", "(", "self", ".", "s_feature_names_with_one_hot_encoding", ")", ")", "\n", "\n", "self", ".", "s_protected_attribute_names", "=", "dataset", ".", "protected_attribute_names", "\n", "\n", "# add protected attribute names to the list of categorical features", "\n", "self", ".", "s_categorical_features", "=", "self", ".", "s_categorical_features", "+", "self", ".", "s_protected_attribute_names", "\n", "\n", "self", ".", "s_labels", "=", "df", "[", "dataset", ".", "label_names", "[", "0", "]", "]", "# create labels", "\n", "\n", "# following 3 lines are not really needed", "\n", "# using to create s_class_names..can do so manually as well ...array([ 0.,  1.])", "\n", "s_le", "=", "sklearn", ".", "preprocessing", ".", "LabelEncoder", "(", ")", "\n", "s_le", ".", "fit", "(", "self", ".", "s_labels", ")", "\n", "# self.s_labels = s_le.transform(self.s_labels)", "\n", "self", ".", "s_class_names", "=", "s_le", ".", "classes_", "\n", "\n", "# convert s_categorical_features to a list of array indexes in", "\n", "# s_feature_names corresponding to categorical features", "\n", "# (NOTE - does not included protected attributes)", "\n", "self", ".", "s_categorical_features", "=", "[", "self", ".", "s_feature_names", ".", "index", "(", "x", ")", "\n", "for", "x", "in", "self", ".", "s_categorical_features", "]", "\n", "\n", "# map all the categorical features to numerical values and store the", "\n", "# mappings in s_categorical_names", "\n", "self", ".", "s_categorical_names", "=", "{", "}", "\n", "for", "feature", "in", "self", ".", "s_categorical_features", ":", "\n", "            ", "self", ".", "le", "=", "sklearn", ".", "preprocessing", ".", "LabelEncoder", "(", ")", "\n", "self", ".", "le", ".", "fit", "(", "self", ".", "s_data", "[", ":", ",", "feature", "]", ")", "\n", "#self.s_data[:, feature] = le.transform(self.s_data[:, feature])", "\n", "self", ".", "s_categorical_names", "[", "feature", "]", "=", "self", ".", "le", ".", "classes_", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.lime_encoder.LimeEncoder.transform": [[81, 116], ["len", "numpy.zeros", "range", "enumerate", "range", "len", "lime_encoder.LimeEncoder.s_feature_names_with_one_hot_encoding.index", "lime_encoder.LimeEncoder.s_feature_names_with_one_hot_encoding.index", "lime_encoder.LimeEncoder.s_feature_names_with_one_hot_encoding.index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "transform", "(", "self", ",", "aif360data", ")", ":", "\n", "        ", "\"\"\"Take aif360 data array and return data array that is lime encoded\n        (numeric array in which categorical features are NOT one-hot-encoded).\n\n        Args:\n            aif360data (np.ndarray): Dataset features\n\n        Returns:\n            np.ndarray: LIME dataset features\n        \"\"\"", "\n", "tgtNumRows", "=", "aif360data", ".", "shape", "[", "0", "]", "\n", "tgtNumcolumns", "=", "len", "(", "self", ".", "s_feature_names", ")", "\n", "limedata", "=", "np", ".", "zeros", "(", "shape", "=", "(", "tgtNumRows", ",", "tgtNumcolumns", ")", ")", "\n", "\n", "# non_categorical_features = list(set(self.s_feature_names) & set(self.s_feature_names_with_one_hot_encoding))", "\n", "for", "rw", "in", "range", "(", "limedata", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "ind", ",", "feature", "in", "enumerate", "(", "self", ".", "s_feature_names", ")", ":", "\n", "                ", "if", "ind", "in", "self", ".", "s_categorical_features", ":", "\n", "# tranform the value since categorical feature except if it", "\n", "# is also a protected attribute", "\n", "                    ", "if", "feature", "in", "self", ".", "s_protected_attribute_names", ":", "\n", "# just copy the value as is", "\n", "                        ", "limedata", "[", "rw", ",", "ind", "]", "=", "aif360data", "[", "rw", ",", "self", ".", "s_feature_names_with_one_hot_encoding", ".", "index", "(", "feature", ")", "]", "\n", "", "else", ":", "\n", "                        ", "possible_feature_values", "=", "self", ".", "s_categorical_names", "[", "ind", "]", "\n", "for", "indc", "in", "range", "(", "len", "(", "possible_feature_values", ")", ")", ":", "\n", "                            ", "cval", "=", "possible_feature_values", "[", "indc", "]", "\n", "colName", "=", "feature", "+", "\"=\"", "+", "cval", "\n", "if", "(", "aif360data", "[", "rw", "]", "[", "self", ".", "s_feature_names_with_one_hot_encoding", ".", "index", "(", "colName", ")", "]", "==", "1.0", ")", ":", "\n", "                                ", "limedata", "[", "rw", "]", "[", "ind", "]", "=", "indc", "\n", "", "", "", "", "else", ":", "\n", "# just copy the value as is", "\n", "                    ", "limedata", "[", "rw", ",", "ind", "]", "=", "aif360data", "[", "rw", ",", "self", ".", "s_feature_names_with_one_hot_encoding", ".", "index", "(", "feature", ")", "]", "\n", "\n", "", "", "", "return", "limedata", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.lime_encoder.LimeEncoder.inverse_transform": [[117, 151], ["len", "numpy.zeros", "range", "enumerate", "lime_encoder.LimeEncoder.s_feature_names_with_one_hot_encoding.index", "lime_encoder.LimeEncoder.s_feature_names_with_one_hot_encoding.index", "int", "lime_encoder.LimeEncoder.s_feature_names_with_one_hot_encoding.index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "inverse_transform", "(", "self", ",", "limedata", ")", ":", "\n", "        ", "\"\"\"Take data array that is lime encoded (that is, lime-compatible data\n        created by this class from a given aif360 dataset) and return data array\n        consistent with the original aif360 dataset.\n\n        Args:\n            limedata (np.ndarray): Dataset features\n\n        Returns:\n            np.ndarray: aif360 dataset features\n        \"\"\"", "\n", "tgtNumRows", "=", "limedata", ".", "shape", "[", "0", "]", "\n", "tgtNumcolumns", "=", "len", "(", "self", ".", "s_feature_names_with_one_hot_encoding", ")", "\n", "aif360data", "=", "np", ".", "zeros", "(", "shape", "=", "(", "tgtNumRows", ",", "tgtNumcolumns", ")", ")", "\n", "\n", "for", "rw", "in", "range", "(", "aif360data", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "ind", ",", "feature", "in", "enumerate", "(", "self", ".", "s_feature_names", ")", ":", "\n", "# s_categorical_features has list of indexes into", "\n", "# s_feature_names for categorical features", "\n", "                ", "if", "ind", "in", "self", ".", "s_categorical_features", ":", "\n", "                    ", "if", "feature", "in", "self", ".", "s_protected_attribute_names", ":", "\n", "# just copy the value as is", "\n", "                        ", "aif360data", "[", "rw", ",", "self", ".", "s_feature_names_with_one_hot_encoding", ".", "index", "(", "feature", ")", "]", "=", "limedata", "[", "rw", ",", "ind", "]", "\n", "", "else", ":", "\n", "# s_categorical_names[ind] has mapping of categorical to", "\n", "# numerical values i.e. limedata[rw, ind] is index of", "\n", "# this array. value is string val", "\n", "                        ", "new_feature", "=", "feature", "+", "'='", "+", "self", ".", "s_categorical_names", "[", "ind", "]", "[", "int", "(", "limedata", "[", "rw", ",", "ind", "]", ")", "]", "\n", "# categorical feature:", "\n", "aif360data", "[", "rw", ",", "self", ".", "s_feature_names_with_one_hot_encoding", ".", "index", "(", "new_feature", ")", "]", "=", "1.0", "\n", "", "", "else", ":", "# just copy value", "\n", "                    ", "aif360data", "[", "rw", ",", "self", ".", "s_feature_names_with_one_hot_encoding", ".", "index", "(", "feature", ")", "]", "=", "limedata", "[", "rw", ",", "ind", "]", "\n", "\n", "", "", "", "return", "aif360data", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.meps_dataset_panel20_fy2015.MEPSDataset20.__init__": [[70, 116], ["os.path.join", "aif360.datasets.StandardDataset.__init__", "os.path.dirname", "pandas.read_csv", "os.path.abspath", "print", "print", "print", "print", "print", "sys.exit", "os.path.abspath", "os.path.abspath", "os.path.join", "os.path.join", "os.path.abspath", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "label_name", "=", "'UTILIZATION'", ",", "favorable_classes", "=", "[", "1.0", "]", ",", "\n", "protected_attribute_names", "=", "[", "'RACE'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'White'", "]", "]", ",", "\n", "instance_weights_name", "=", "'PERWT15F'", ",", "\n", "categorical_features", "=", "[", "'REGION'", ",", "'SEX'", ",", "'MARRY'", ",", "\n", "'FTSTU'", ",", "'ACTDTY'", ",", "'HONRDC'", ",", "'RTHLTH'", ",", "'MNHLTH'", ",", "'HIBPDX'", ",", "'CHDDX'", ",", "'ANGIDX'", ",", "\n", "'MIDX'", ",", "'OHRTDX'", ",", "'STRKDX'", ",", "'EMPHDX'", ",", "'CHBRON'", ",", "'CHOLDX'", ",", "'CANCERDX'", ",", "'DIABDX'", ",", "\n", "'JTPAIN'", ",", "'ARTHDX'", ",", "'ARTHTYPE'", ",", "'ASTHDX'", ",", "'ADHDADDX'", ",", "'PREGNT'", ",", "'WLKLIM'", ",", "\n", "'ACTLIM'", ",", "'SOCLIM'", ",", "'COGLIM'", ",", "'DFHEAR42'", ",", "'DFSEE42'", ",", "'ADSMOK42'", ",", "'PHQ242'", ",", "\n", "'EMPST'", ",", "'POVCAT'", ",", "'INSCOV'", "]", ",", "\n", "features_to_keep", "=", "[", "'REGION'", ",", "'AGE'", ",", "'SEX'", ",", "'RACE'", ",", "'MARRY'", ",", "\n", "'FTSTU'", ",", "'ACTDTY'", ",", "'HONRDC'", ",", "'RTHLTH'", ",", "'MNHLTH'", ",", "'HIBPDX'", ",", "'CHDDX'", ",", "'ANGIDX'", ",", "\n", "'MIDX'", ",", "'OHRTDX'", ",", "'STRKDX'", ",", "'EMPHDX'", ",", "'CHBRON'", ",", "'CHOLDX'", ",", "'CANCERDX'", ",", "'DIABDX'", ",", "\n", "'JTPAIN'", ",", "'ARTHDX'", ",", "'ARTHTYPE'", ",", "'ASTHDX'", ",", "'ADHDADDX'", ",", "'PREGNT'", ",", "'WLKLIM'", ",", "\n", "'ACTLIM'", ",", "'SOCLIM'", ",", "'COGLIM'", ",", "'DFHEAR42'", ",", "'DFSEE42'", ",", "'ADSMOK42'", ",", "\n", "'PCS42'", ",", "\n", "'MCS42'", ",", "'K6SUM42'", ",", "'PHQ242'", ",", "'EMPST'", ",", "'POVCAT'", ",", "'INSCOV'", ",", "'UTILIZATION'", ",", "'PERWT15F'", "]", ",", "\n", "features_to_drop", "=", "[", "]", ",", "\n", "na_values", "=", "[", "]", ",", "custom_preprocessing", "=", "default_preprocessing", ",", "\n", "metadata", "=", "default_mappings", ")", ":", "\n", "\n", "        ", "filepath", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'data'", ",", "'raw'", ",", "'meps'", ",", "'h181.csv'", ")", "\n", "\n", "try", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "sep", "=", "','", ",", "na_values", "=", "na_values", ")", "\n", "", "except", "IOError", "as", "err", ":", "\n", "            ", "print", "(", "\"IOError: {}\"", ".", "format", "(", "err", ")", ")", "\n", "print", "(", "\"To use this class, please follow the instructions in:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'meps'", ",", "'README.md'", ")", ")", ")", ")", "\n", "print", "(", "\"\\n to download and convert the 2015 data and place the final h181.csv file, as-is, in the folder:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'meps'", ")", ")", ")", ")", "\n", "import", "sys", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "super", "(", "MEPSDataset20", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_name", "=", "label_name", ",", "\n", "favorable_classes", "=", "favorable_classes", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_classes", "=", "privileged_classes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "features_to_keep", ",", "\n", "features_to_drop", "=", "features_to_drop", ",", "na_values", "=", "na_values", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ",", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.meps_dataset_panel20_fy2015.default_preprocessing": [[12, 62], ["df.rename.apply", "df.rename.rename", "df.rename.rename", "df.rename.apply", "df.rename.rename", "meps_dataset_panel20_fy2015.default_preprocessing.race"], "function", ["None"], ["def", "default_preprocessing", "(", "df", ")", ":", "\n", "    ", "\"\"\"\n    1.Create a new column, RACE that is 'White' if RACEV2X = 1 and HISPANX = 2 i.e. non Hispanic White\n      and 'non-White' otherwise\n    2. Restrict to Panel 20\n    3. RENAME all columns that are PANEL/ROUND SPECIFIC\n    4. Drop rows based on certain values of individual features that correspond to missing/unknown - generally < -1\n    5. Compute UTILIZATION, binarize it to 0 (< 10) and 1 (>= 10)\n    \"\"\"", "\n", "def", "race", "(", "row", ")", ":", "\n", "        ", "if", "(", "(", "row", "[", "'HISPANX'", "]", "==", "2", ")", "and", "(", "row", "[", "'RACEV2X'", "]", "==", "1", ")", ")", ":", "#non-Hispanic Whites are marked as WHITE; all others as NON-WHITE", "\n", "            ", "return", "'White'", "\n", "", "return", "'Non-White'", "\n", "\n", "", "df", "[", "'RACEV2X'", "]", "=", "df", ".", "apply", "(", "lambda", "row", ":", "race", "(", "row", ")", ",", "axis", "=", "1", ")", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'RACEV2X'", ":", "'RACE'", "}", ")", "\n", "\n", "df", "=", "df", "[", "df", "[", "'PANEL'", "]", "==", "20", "]", "\n", "\n", "# RENAME COLUMNS", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'FTSTU53X'", ":", "'FTSTU'", ",", "'ACTDTY53'", ":", "'ACTDTY'", ",", "'HONRDC53'", ":", "'HONRDC'", ",", "'RTHLTH53'", ":", "'RTHLTH'", ",", "\n", "'MNHLTH53'", ":", "'MNHLTH'", ",", "'CHBRON53'", ":", "'CHBRON'", ",", "'JTPAIN53'", ":", "'JTPAIN'", ",", "'PREGNT53'", ":", "'PREGNT'", ",", "\n", "'WLKLIM53'", ":", "'WLKLIM'", ",", "'ACTLIM53'", ":", "'ACTLIM'", ",", "'SOCLIM53'", ":", "'SOCLIM'", ",", "'COGLIM53'", ":", "'COGLIM'", ",", "\n", "'EMPST53'", ":", "'EMPST'", ",", "'REGION53'", ":", "'REGION'", ",", "'MARRY53X'", ":", "'MARRY'", ",", "'AGE53X'", ":", "'AGE'", ",", "\n", "'POVCAT15'", ":", "'POVCAT'", ",", "'INSCOV15'", ":", "'INSCOV'", "}", ")", "\n", "\n", "df", "=", "df", "[", "df", "[", "'REGION'", "]", ">=", "0", "]", "# remove values -1", "\n", "df", "=", "df", "[", "df", "[", "'AGE'", "]", ">=", "0", "]", "# remove values -1", "\n", "\n", "df", "=", "df", "[", "df", "[", "'MARRY'", "]", ">=", "0", "]", "# remove values -1, -7, -8, -9", "\n", "\n", "df", "=", "df", "[", "df", "[", "'ASTHDX'", "]", ">=", "0", "]", "# remove values -1, -7, -8, -9", "\n", "\n", "df", "=", "df", "[", "(", "df", "[", "[", "'FTSTU'", ",", "'ACTDTY'", ",", "'HONRDC'", ",", "'RTHLTH'", ",", "'MNHLTH'", ",", "'HIBPDX'", ",", "'CHDDX'", ",", "'ANGIDX'", ",", "'EDUCYR'", ",", "'HIDEG'", ",", "\n", "'MIDX'", ",", "'OHRTDX'", ",", "'STRKDX'", ",", "'EMPHDX'", ",", "'CHBRON'", ",", "'CHOLDX'", ",", "'CANCERDX'", ",", "'DIABDX'", ",", "\n", "'JTPAIN'", ",", "'ARTHDX'", ",", "'ARTHTYPE'", ",", "'ASTHDX'", ",", "'ADHDADDX'", ",", "'PREGNT'", ",", "'WLKLIM'", ",", "\n", "'ACTLIM'", ",", "'SOCLIM'", ",", "'COGLIM'", ",", "'DFHEAR42'", ",", "'DFSEE42'", ",", "'ADSMOK42'", ",", "\n", "'PHQ242'", ",", "'EMPST'", ",", "'POVCAT'", ",", "'INSCOV'", "]", "]", ">=", "-", "1", ")", ".", "all", "(", "1", ")", "]", "#for all other categorical features, remove values < -1", "\n", "\n", "def", "utilization", "(", "row", ")", ":", "\n", "        ", "return", "row", "[", "'OBTOTV15'", "]", "+", "row", "[", "'OPTOTV15'", "]", "+", "row", "[", "'ERTOT15'", "]", "+", "row", "[", "'IPNGTD15'", "]", "+", "row", "[", "'HHTOTD15'", "]", "\n", "\n", "", "df", "[", "'TOTEXP15'", "]", "=", "df", ".", "apply", "(", "lambda", "row", ":", "utilization", "(", "row", ")", ",", "axis", "=", "1", ")", "\n", "lessE", "=", "df", "[", "'TOTEXP15'", "]", "<", "10.0", "\n", "df", ".", "loc", "[", "lessE", ",", "'TOTEXP15'", "]", "=", "0.0", "\n", "moreE", "=", "df", "[", "'TOTEXP15'", "]", ">=", "10.0", "\n", "df", ".", "loc", "[", "moreE", ",", "'TOTEXP15'", "]", "=", "1.0", "\n", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'TOTEXP15'", ":", "'UTILIZATION'", "}", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.law_school_gpa_dataset.LawSchoolGPADataset.__init__": [[13, 39], ["dataset.get_X", "dataset.get_y", "dataset.get_sensitive_features", "pandas.concat", "pandas.concat", "pandas.concat", "aif360.datasets.RegressionDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "dep_var_name", "=", "'zfygpa'", ",", "\n", "protected_attribute_names", "=", "[", "'race'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'white'", "]", "]", ",", "\n", "instance_weights_name", "=", "None", ",", "\n", "categorical_features", "=", "[", "]", ",", "\n", "na_values", "=", "[", "]", ",", "custom_preprocessing", "=", "None", ",", "\n", "metadata", "=", "None", ")", ":", "\n", "        ", "\"\"\"See :obj:`RegressionDataset` for a description of the arguments.\"\"\"", "\n", "dataset", "=", "tc", ".", "datasets", "[", "\"lawschool_gpa\"", "]", "(", ")", "\n", "X_train", ",", "X_test", "=", "dataset", ".", "get_X", "(", "format", "=", "pd", ".", "DataFrame", ")", "\n", "y_train", ",", "y_test", "=", "dataset", ".", "get_y", "(", "format", "=", "pd", ".", "Series", ")", "\n", "A_train", ",", "A_test", "=", "dataset", ".", "get_sensitive_features", "(", "name", "=", "'race'", ",", "\n", "format", "=", "pd", ".", "Series", ")", "\n", "all_train", "=", "pd", ".", "concat", "(", "[", "X_train", ",", "y_train", ",", "A_train", "]", ",", "axis", "=", "1", ")", "\n", "all_test", "=", "pd", ".", "concat", "(", "[", "X_test", ",", "y_test", ",", "A_test", "]", ",", "axis", "=", "1", ")", "\n", "\n", "df", "=", "pd", ".", "concat", "(", "[", "all_train", ",", "all_test", "]", ",", "axis", "=", "0", ")", "\n", "\n", "super", "(", "LawSchoolGPADataset", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "\n", "dep_var_name", "=", "dep_var_name", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_classes", "=", "privileged_classes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "na_values", "=", "na_values", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ",", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.compas_dataset.CompasDataset.__init__": [[30, 88], ["os.path.join", "aif360.datasets.StandardDataset.__init__", "os.path.dirname", "pandas.read_csv", "os.path.abspath", "print", "print", "print", "print", "print", "sys.exit", "os.path.abspath", "os.path.join", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "label_name", "=", "'two_year_recid'", ",", "favorable_classes", "=", "[", "0", "]", ",", "\n", "protected_attribute_names", "=", "[", "'sex'", ",", "'race'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'Female'", "]", ",", "[", "'Caucasian'", "]", "]", ",", "\n", "instance_weights_name", "=", "None", ",", "\n", "categorical_features", "=", "[", "'age_cat'", ",", "'c_charge_degree'", ",", "\n", "'c_charge_desc'", "]", ",", "\n", "features_to_keep", "=", "[", "'sex'", ",", "'age'", ",", "'age_cat'", ",", "'race'", ",", "\n", "'juv_fel_count'", ",", "'juv_misd_count'", ",", "'juv_other_count'", ",", "\n", "'priors_count'", ",", "'c_charge_degree'", ",", "'c_charge_desc'", ",", "\n", "'two_year_recid'", "]", ",", "\n", "features_to_drop", "=", "[", "]", ",", "na_values", "=", "[", "]", ",", "\n", "custom_preprocessing", "=", "default_preprocessing", ",", "\n", "metadata", "=", "default_mappings", ")", ":", "\n", "        ", "\"\"\"See :obj:`StandardDataset` for a description of the arguments.\n\n        Note: The label value 0 in this case is considered favorable (no\n        recidivism).\n\n        Examples:\n            In some cases, it may be useful to keep track of a mapping from\n            `float -> str` for protected attributes and/or labels. If our use\n            case differs from the default, we can modify the mapping stored in\n            `metadata`:\n\n            >>> label_map = {1.0: 'Did recid.', 0.0: 'No recid.'}\n            >>> protected_attribute_maps = [{1.0: 'Male', 0.0: 'Female'}]\n            >>> cd = CompasDataset(protected_attribute_names=['sex'],\n            ... privileged_classes=[['Male']], metadata={'label_map': label_map,\n            ... 'protected_attribute_maps': protected_attribute_maps})\n\n            Now this information will stay attached to the dataset and can be\n            used for more descriptive visualizations.\n        \"\"\"", "\n", "\n", "filepath", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'data'", ",", "'raw'", ",", "'compas'", ",", "'compas-scores-two-years.csv'", ")", "\n", "\n", "try", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "'id'", ",", "na_values", "=", "na_values", ")", "\n", "", "except", "IOError", "as", "err", ":", "\n", "            ", "print", "(", "\"IOError: {}\"", ".", "format", "(", "err", ")", ")", "\n", "print", "(", "\"To use this class, please download the following file:\"", ")", "\n", "print", "(", "\"\\n\\thttps://raw.githubusercontent.com/propublica/compas-analysis/master/compas-scores-two-years.csv\"", ")", "\n", "print", "(", "\"\\nand place it, as-is, in the folder:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'compas'", ")", ")", ")", ")", "\n", "import", "sys", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "super", "(", "CompasDataset", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_name", "=", "label_name", ",", "\n", "favorable_classes", "=", "favorable_classes", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_classes", "=", "privileged_classes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "features_to_keep", ",", "\n", "features_to_drop", "=", "features_to_drop", ",", "na_values", "=", "na_values", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ",", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.compas_dataset.default_preprocessing": [[14, 23], ["None"], "function", ["None"], ["def", "default_preprocessing", "(", "df", ")", ":", "\n", "    ", "\"\"\"Perform the same preprocessing as the original analysis:\n    https://github.com/propublica/compas-analysis/blob/master/Compas%20Analysis.ipynb\n    \"\"\"", "\n", "return", "df", "[", "(", "df", ".", "days_b_screening_arrest", "<=", "30", ")", "\n", "&", "(", "df", ".", "days_b_screening_arrest", ">=", "-", "30", ")", "\n", "&", "(", "df", ".", "is_recid", "!=", "-", "1", ")", "\n", "&", "(", "df", ".", "c_charge_degree", "!=", "'O'", ")", "\n", "&", "(", "df", ".", "score_text", "!=", "'N/A'", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.regression_dataset.RegressionDataset.__init__": [[14, 111], ["custom_preprocessing.dropna", "pandas.get_dummies", "zip", "pandas.DataFrame", "aif360.datasets.StructuredDataset.__init__", "custom_preprocessing", "logging.warning", "callable", "privileged_protected_attributes.append", "unprivileged_protected_attributes.append", "sklearn.preprocessing.MinMaxScaler().fit_transform", "df[].apply", "numpy.issubdtype", "numpy.array", "numpy.array", "list", "list", "numpy.logical_or.reduce", "sklearn.preprocessing.MinMaxScaler", "type", "set().difference", "numpy.equal.outer", "df[].to_numpy", "set"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["def", "__init__", "(", "self", ",", "df", ",", "dep_var_name", ",", "protected_attribute_names", ",", "\n", "privileged_classes", ",", "instance_weights_name", "=", "''", ",", "\n", "categorical_features", "=", "[", "]", ",", "na_values", "=", "[", "]", ",", "\n", "custom_preprocessing", "=", "None", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Subclasses of RegressionDataset should perform the following before\n        calling `super().__init__`:\n\n            1. Load the dataframe from a raw file.\n\n        Then, this class will go through a standard preprocessing routine which:\n\n            2. (optional) Performs some dataset-specific preprocessing (e.g.\n               renaming columns/values, handling missing data).\n\n            3. Drops rows with NA values.\n\n            4. Creates a one-hot encoding of the categorical variables.\n\n            5. Maps protected attributes to binary privileged/unprivileged\n               values (1/0).\n\n            6. Normalizes df values\n\n        Args:\n            df (pandas.DataFrame): DataFrame on which to perform standard\n                processing.\n            dep_var_name: Name of the dependent variable column in `df`.\n            protected_attribute_names (list): List of names corresponding to\n                protected attribute columns in `df`.\n            privileged_classes (list(list or function)): Each element is\n                a list of values which are considered privileged or a boolean\n                function which return `True` if privileged for the corresponding\n                column in `protected_attribute_names`. All others are\n                unprivileged. Values are mapped to 1 (privileged) and 0\n                (unprivileged) if they are not already numerical.\n            instance_weights_name (optional): Name of the instance weights\n                column in `df`.\n            categorical_features (optional, list): List of column names in the\n                DataFrame which are to be expanded into one-hot vectors.\n            na_values (optional): Additional strings to recognize as NA. See\n                :func:`pandas.read_csv` for details.\n            custom_preprocessing (function): A function object which\n                acts on and returns a DataFrame (f: DataFrame -> DataFrame). If\n                `None`, no extra preprocessing is applied.\n            metadata (optional): Additional metadata to append.\n        \"\"\"", "\n", "# 2. Perform dataset-specific preprocessing", "\n", "if", "custom_preprocessing", ":", "\n", "            ", "df", "=", "custom_preprocessing", "(", "df", ")", "\n", "\n", "# 3. Remove any rows that have missing data.", "\n", "", "dropped", "=", "df", ".", "dropna", "(", ")", "\n", "count", "=", "df", ".", "shape", "[", "0", "]", "-", "dropped", ".", "shape", "[", "0", "]", "\n", "if", "count", ">", "0", ":", "\n", "            ", "warning", "(", "\"Missing Data: {} rows removed from {}.\"", ".", "format", "(", "count", ",", "\n", "type", "(", "self", ")", ".", "__name__", ")", ")", "\n", "", "df", "=", "dropped", "\n", "\n", "# 4. Create a one-hot encoding of the categorical variables.", "\n", "df", "=", "pd", ".", "get_dummies", "(", "df", ",", "columns", "=", "categorical_features", ",", "prefix_sep", "=", "'='", ")", "\n", "\n", "# 5. Map protected attributes to privileged/unprivileged", "\n", "privileged_protected_attributes", "=", "[", "]", "\n", "unprivileged_protected_attributes", "=", "[", "]", "\n", "for", "attr", ",", "vals", "in", "zip", "(", "protected_attribute_names", ",", "privileged_classes", ")", ":", "\n", "            ", "privileged_values", "=", "[", "1.", "]", "\n", "unprivileged_values", "=", "[", "0.", "]", "\n", "if", "callable", "(", "vals", ")", ":", "\n", "                ", "df", "[", "attr", "]", "=", "df", "[", "attr", "]", ".", "apply", "(", "vals", ")", "\n", "", "elif", "np", ".", "issubdtype", "(", "df", "[", "attr", "]", ".", "dtype", ",", "np", ".", "number", ")", ":", "\n", "# this attribute is numeric; no remapping needed", "\n", "                ", "privileged_values", "=", "vals", "\n", "unprivileged_values", "=", "list", "(", "set", "(", "df", "[", "attr", "]", ")", ".", "difference", "(", "vals", ")", ")", "\n", "", "else", ":", "\n", "# find all instances which match any of the attribute values", "\n", "                ", "priv", "=", "np", ".", "logical_or", ".", "reduce", "(", "np", ".", "equal", ".", "outer", "(", "vals", ",", "df", "[", "attr", "]", ".", "to_numpy", "(", ")", ")", ")", "\n", "df", ".", "loc", "[", "priv", ",", "attr", "]", "=", "privileged_values", "[", "0", "]", "\n", "df", ".", "loc", "[", "~", "priv", ",", "attr", "]", "=", "unprivileged_values", "[", "0", "]", "\n", "\n", "", "privileged_protected_attributes", ".", "append", "(", "\n", "np", ".", "array", "(", "privileged_values", ",", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "unprivileged_protected_attributes", ".", "append", "(", "\n", "np", ".", "array", "(", "unprivileged_values", ",", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "\n", "# 6. Normalize df values", "\n", "", "df", "=", "pd", ".", "DataFrame", "(", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "df", ".", "values", ")", ",", "\n", "columns", "=", "list", "(", "df", ")", ",", "index", "=", "df", ".", "index", ")", "\n", "\n", "super", "(", "RegressionDataset", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "\n", "label_names", "=", "[", "dep_var_name", "]", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_protected_attributes", "=", "privileged_protected_attributes", ",", "\n", "unprivileged_protected_attributes", "=", "unprivileged_protected_attributes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "scores_names", "=", "[", "]", ",", "\n", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.standard_dataset.StandardDataset.__init__": [[20, 154], ["sorted", "custom_preprocessing.dropna", "pandas.get_dummies", "zip", "callable", "aif360.datasets.BinaryLabelDataset.__init__", "custom_preprocessing", "custom_preprocessing.columns.tolist", "set", "set", "logging.warning", "callable", "privileged_protected_attributes.append", "unprivileged_protected_attributes.append", "df[].apply", "set", "sorted", "set", "set", "df[].apply", "numpy.issubdtype", "numpy.array", "numpy.array", "numpy.issubdtype", "set().difference().pop", "numpy.logical_or.reduce", "set", "set", "list", "numpy.logical_or.reduce", "len", "numpy.equal.outer", "set", "type", "set().difference", "numpy.equal.outer", "set", "set().difference", "df[].to_numpy", "df[].to_numpy", "set", "set"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["def", "__init__", "(", "self", ",", "df", ",", "label_name", ",", "favorable_classes", ",", "\n", "protected_attribute_names", ",", "privileged_classes", ",", "\n", "instance_weights_name", "=", "''", ",", "scores_name", "=", "''", ",", "\n", "categorical_features", "=", "[", "]", ",", "features_to_keep", "=", "[", "]", ",", "\n", "features_to_drop", "=", "[", "]", ",", "na_values", "=", "[", "]", ",", "custom_preprocessing", "=", "None", ",", "\n", "metadata", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Subclasses of StandardDataset should perform the following before\n        calling `super().__init__`:\n\n            1. Load the dataframe from a raw file.\n\n        Then, this class will go through a standard preprocessing routine which:\n\n            2. (optional) Performs some dataset-specific preprocessing (e.g.\n               renaming columns/values, handling missing data).\n\n            3. Drops unrequested columns (see `features_to_keep` and\n               `features_to_drop` for details).\n\n            4. Drops rows with NA values.\n\n            5. Creates a one-hot encoding of the categorical variables.\n\n            6. Maps protected attributes to binary privileged/unprivileged\n               values (1/0).\n\n            7. Maps labels to binary favorable/unfavorable labels (1/0).\n\n        Args:\n            df (pandas.DataFrame): DataFrame on which to perform standard\n                processing.\n            label_name: Name of the label column in `df`.\n            favorable_classes (list or function): Label values which are\n                considered favorable or a boolean function which returns `True`\n                if favorable. All others are unfavorable. Label values are\n                mapped to 1 (favorable) and 0 (unfavorable) if they are not\n                already binary and numerical.\n            protected_attribute_names (list): List of names corresponding to\n                protected attribute columns in `df`.\n            privileged_classes (list(list or function)): Each element is\n                a list of values which are considered privileged or a boolean\n                function which return `True` if privileged for the corresponding\n                column in `protected_attribute_names`. All others are\n                unprivileged. Values are mapped to 1 (privileged) and 0\n                (unprivileged) if they are not already numerical.\n            instance_weights_name (optional): Name of the instance weights\n                column in `df`.\n            categorical_features (optional, list): List of column names in the\n                DataFrame which are to be expanded into one-hot vectors.\n            features_to_keep (optional, list): Column names to keep. All others\n                are dropped except those present in `protected_attribute_names`,\n                `categorical_features`, `label_name` or `instance_weights_name`.\n                Defaults to all columns if not provided.\n            features_to_drop (optional, list): Column names to drop. *Note: this\n                overrides* `features_to_keep`.\n            na_values (optional): Additional strings to recognize as NA. See\n                :func:`pandas.read_csv` for details.\n            custom_preprocessing (function): A function object which\n                acts on and returns a DataFrame (f: DataFrame -> DataFrame). If\n                `None`, no extra preprocessing is applied.\n            metadata (optional): Additional metadata to append.\n        \"\"\"", "\n", "# 2. Perform dataset-specific preprocessing", "\n", "if", "custom_preprocessing", ":", "\n", "            ", "df", "=", "custom_preprocessing", "(", "df", ")", "\n", "\n", "# 3. Drop unrequested columns", "\n", "", "features_to_keep", "=", "features_to_keep", "or", "df", ".", "columns", ".", "tolist", "(", ")", "\n", "keep", "=", "(", "set", "(", "features_to_keep", ")", "|", "set", "(", "protected_attribute_names", ")", "\n", "|", "set", "(", "categorical_features", ")", "|", "set", "(", "[", "label_name", "]", ")", ")", "\n", "if", "instance_weights_name", ":", "\n", "            ", "keep", "|=", "set", "(", "[", "instance_weights_name", "]", ")", "\n", "", "df", "=", "df", "[", "sorted", "(", "keep", "-", "set", "(", "features_to_drop", ")", ",", "key", "=", "df", ".", "columns", ".", "get_loc", ")", "]", "\n", "categorical_features", "=", "sorted", "(", "set", "(", "categorical_features", ")", "-", "set", "(", "features_to_drop", ")", ",", "key", "=", "df", ".", "columns", ".", "get_loc", ")", "\n", "\n", "# 4. Remove any rows that have missing data.", "\n", "dropped", "=", "df", ".", "dropna", "(", ")", "\n", "count", "=", "df", ".", "shape", "[", "0", "]", "-", "dropped", ".", "shape", "[", "0", "]", "\n", "if", "count", ">", "0", ":", "\n", "            ", "warning", "(", "\"Missing Data: {} rows removed from {}.\"", ".", "format", "(", "count", ",", "\n", "type", "(", "self", ")", ".", "__name__", ")", ")", "\n", "", "df", "=", "dropped", "\n", "\n", "# 5. Create a one-hot encoding of the categorical variables.", "\n", "df", "=", "pd", ".", "get_dummies", "(", "df", ",", "columns", "=", "categorical_features", ",", "prefix_sep", "=", "'='", ")", "\n", "\n", "# 6. Map protected attributes to privileged/unprivileged", "\n", "privileged_protected_attributes", "=", "[", "]", "\n", "unprivileged_protected_attributes", "=", "[", "]", "\n", "for", "attr", ",", "vals", "in", "zip", "(", "protected_attribute_names", ",", "privileged_classes", ")", ":", "\n", "            ", "privileged_values", "=", "[", "1.", "]", "\n", "unprivileged_values", "=", "[", "0.", "]", "\n", "if", "callable", "(", "vals", ")", ":", "\n", "                ", "df", "[", "attr", "]", "=", "df", "[", "attr", "]", ".", "apply", "(", "vals", ")", "\n", "", "elif", "np", ".", "issubdtype", "(", "df", "[", "attr", "]", ".", "dtype", ",", "np", ".", "number", ")", ":", "\n", "# this attribute is numeric; no remapping needed", "\n", "                ", "privileged_values", "=", "vals", "\n", "unprivileged_values", "=", "list", "(", "set", "(", "df", "[", "attr", "]", ")", ".", "difference", "(", "vals", ")", ")", "\n", "", "else", ":", "\n", "# find all instances which match any of the attribute values", "\n", "                ", "priv", "=", "np", ".", "logical_or", ".", "reduce", "(", "np", ".", "equal", ".", "outer", "(", "vals", ",", "df", "[", "attr", "]", ".", "to_numpy", "(", ")", ")", ")", "\n", "df", ".", "loc", "[", "priv", ",", "attr", "]", "=", "privileged_values", "[", "0", "]", "\n", "df", ".", "loc", "[", "~", "priv", ",", "attr", "]", "=", "unprivileged_values", "[", "0", "]", "\n", "\n", "", "privileged_protected_attributes", ".", "append", "(", "\n", "np", ".", "array", "(", "privileged_values", ",", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "unprivileged_protected_attributes", ".", "append", "(", "\n", "np", ".", "array", "(", "unprivileged_values", ",", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "\n", "# 7. Make labels binary", "\n", "", "favorable_label", "=", "1.", "\n", "unfavorable_label", "=", "0.", "\n", "if", "callable", "(", "favorable_classes", ")", ":", "\n", "            ", "df", "[", "label_name", "]", "=", "df", "[", "label_name", "]", ".", "apply", "(", "favorable_classes", ")", "\n", "", "elif", "np", ".", "issubdtype", "(", "df", "[", "label_name", "]", ",", "np", ".", "number", ")", "and", "len", "(", "set", "(", "df", "[", "label_name", "]", ")", ")", "==", "2", ":", "\n", "# labels are already binary; don't change them", "\n", "            ", "favorable_label", "=", "favorable_classes", "[", "0", "]", "\n", "unfavorable_label", "=", "set", "(", "df", "[", "label_name", "]", ")", ".", "difference", "(", "favorable_classes", ")", ".", "pop", "(", ")", "\n", "", "else", ":", "\n", "# find all instances which match any of the favorable classes", "\n", "            ", "pos", "=", "np", ".", "logical_or", ".", "reduce", "(", "np", ".", "equal", ".", "outer", "(", "favorable_classes", ",", "\n", "df", "[", "label_name", "]", ".", "to_numpy", "(", ")", ")", ")", "\n", "df", ".", "loc", "[", "pos", ",", "label_name", "]", "=", "favorable_label", "\n", "df", ".", "loc", "[", "~", "pos", ",", "label_name", "]", "=", "unfavorable_label", "\n", "\n", "", "super", "(", "StandardDataset", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_names", "=", "[", "label_name", "]", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_protected_attributes", "=", "privileged_protected_attributes", ",", "\n", "unprivileged_protected_attributes", "=", "unprivileged_protected_attributes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "scores_names", "=", "[", "scores_name", "]", "if", "scores_name", "else", "[", "]", ",", "\n", "favorable_label", "=", "favorable_label", ",", "\n", "unfavorable_label", "=", "unfavorable_label", ",", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.meps_dataset_panel19_fy2015.MEPSDataset19.__init__": [[70, 115], ["os.path.join", "aif360.datasets.StandardDataset.__init__", "os.path.dirname", "pandas.read_csv", "os.path.abspath", "print", "print", "print", "print", "print", "sys.exit", "os.path.abspath", "os.path.abspath", "os.path.join", "os.path.join", "os.path.abspath", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "label_name", "=", "'UTILIZATION'", ",", "favorable_classes", "=", "[", "1.0", "]", ",", "\n", "protected_attribute_names", "=", "[", "'RACE'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'White'", "]", "]", ",", "\n", "instance_weights_name", "=", "'PERWT15F'", ",", "\n", "categorical_features", "=", "[", "'REGION'", ",", "'SEX'", ",", "'MARRY'", ",", "\n", "'FTSTU'", ",", "'ACTDTY'", ",", "'HONRDC'", ",", "'RTHLTH'", ",", "'MNHLTH'", ",", "'HIBPDX'", ",", "'CHDDX'", ",", "'ANGIDX'", ",", "\n", "'MIDX'", ",", "'OHRTDX'", ",", "'STRKDX'", ",", "'EMPHDX'", ",", "'CHBRON'", ",", "'CHOLDX'", ",", "'CANCERDX'", ",", "'DIABDX'", ",", "\n", "'JTPAIN'", ",", "'ARTHDX'", ",", "'ARTHTYPE'", ",", "'ASTHDX'", ",", "'ADHDADDX'", ",", "'PREGNT'", ",", "'WLKLIM'", ",", "\n", "'ACTLIM'", ",", "'SOCLIM'", ",", "'COGLIM'", ",", "'DFHEAR42'", ",", "'DFSEE42'", ",", "'ADSMOK42'", ",", "\n", "'PHQ242'", ",", "'EMPST'", ",", "'POVCAT'", ",", "'INSCOV'", "]", ",", "\n", "features_to_keep", "=", "[", "'REGION'", ",", "'AGE'", ",", "'SEX'", ",", "'RACE'", ",", "'MARRY'", ",", "\n", "'FTSTU'", ",", "'ACTDTY'", ",", "'HONRDC'", ",", "'RTHLTH'", ",", "'MNHLTH'", ",", "'HIBPDX'", ",", "'CHDDX'", ",", "'ANGIDX'", ",", "\n", "'MIDX'", ",", "'OHRTDX'", ",", "'STRKDX'", ",", "'EMPHDX'", ",", "'CHBRON'", ",", "'CHOLDX'", ",", "'CANCERDX'", ",", "'DIABDX'", ",", "\n", "'JTPAIN'", ",", "'ARTHDX'", ",", "'ARTHTYPE'", ",", "'ASTHDX'", ",", "'ADHDADDX'", ",", "'PREGNT'", ",", "'WLKLIM'", ",", "\n", "'ACTLIM'", ",", "'SOCLIM'", ",", "'COGLIM'", ",", "'DFHEAR42'", ",", "'DFSEE42'", ",", "'ADSMOK42'", ",", "'PCS42'", ",", "\n", "'MCS42'", ",", "'K6SUM42'", ",", "'PHQ242'", ",", "'EMPST'", ",", "'POVCAT'", ",", "'INSCOV'", ",", "'UTILIZATION'", ",", "'PERWT15F'", "]", ",", "\n", "features_to_drop", "=", "[", "]", ",", "\n", "na_values", "=", "[", "]", ",", "custom_preprocessing", "=", "default_preprocessing", ",", "\n", "metadata", "=", "default_mappings", ")", ":", "\n", "\n", "        ", "filepath", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'data'", ",", "'raw'", ",", "'meps'", ",", "'h181.csv'", ")", "\n", "\n", "try", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "sep", "=", "','", ",", "na_values", "=", "na_values", ")", "\n", "", "except", "IOError", "as", "err", ":", "\n", "            ", "print", "(", "\"IOError: {}\"", ".", "format", "(", "err", ")", ")", "\n", "print", "(", "\"To use this class, please follow the instructions in:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'meps'", ",", "'README.md'", ")", ")", ")", ")", "\n", "print", "(", "\"\\n to download and convert the 2015 data and place the final h181.csv file, as-is, in the folder:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'meps'", ")", ")", ")", ")", "\n", "import", "sys", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "super", "(", "MEPSDataset19", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_name", "=", "label_name", ",", "\n", "favorable_classes", "=", "favorable_classes", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_classes", "=", "privileged_classes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "features_to_keep", ",", "\n", "features_to_drop", "=", "features_to_drop", ",", "na_values", "=", "na_values", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ",", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.meps_dataset_panel19_fy2015.default_preprocessing": [[12, 62], ["df.rename.apply", "df.rename.rename", "df.rename.rename", "df.rename.apply", "df.rename.rename", "meps_dataset_panel19_fy2015.default_preprocessing.race"], "function", ["None"], ["def", "default_preprocessing", "(", "df", ")", ":", "\n", "    ", "\"\"\"\n    1.Create a new column, RACE that is 'White' if RACEV2X = 1 and HISPANX = 2 i.e. non Hispanic White\n      and 'non-White' otherwise\n    2. Restrict to Panel 19\n    3. RENAME all columns that are PANEL/ROUND SPECIFIC\n    4. Drop rows based on certain values of individual features that correspond to missing/unknown - generally < -1\n    5. Compute UTILIZATION, binarize it to 0 (< 10) and 1 (>= 10)\n    \"\"\"", "\n", "def", "race", "(", "row", ")", ":", "\n", "        ", "if", "(", "(", "row", "[", "'HISPANX'", "]", "==", "2", ")", "and", "(", "row", "[", "'RACEV2X'", "]", "==", "1", ")", ")", ":", "#non-Hispanic Whites are marked as WHITE; all others as NON-WHITE", "\n", "            ", "return", "'White'", "\n", "", "return", "'Non-White'", "\n", "\n", "", "df", "[", "'RACEV2X'", "]", "=", "df", ".", "apply", "(", "lambda", "row", ":", "race", "(", "row", ")", ",", "axis", "=", "1", ")", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'RACEV2X'", ":", "'RACE'", "}", ")", "\n", "\n", "df", "=", "df", "[", "df", "[", "'PANEL'", "]", "==", "19", "]", "\n", "\n", "# RENAME COLUMNS", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'FTSTU53X'", ":", "'FTSTU'", ",", "'ACTDTY53'", ":", "'ACTDTY'", ",", "'HONRDC53'", ":", "'HONRDC'", ",", "'RTHLTH53'", ":", "'RTHLTH'", ",", "\n", "'MNHLTH53'", ":", "'MNHLTH'", ",", "'CHBRON53'", ":", "'CHBRON'", ",", "'JTPAIN53'", ":", "'JTPAIN'", ",", "'PREGNT53'", ":", "'PREGNT'", ",", "\n", "'WLKLIM53'", ":", "'WLKLIM'", ",", "'ACTLIM53'", ":", "'ACTLIM'", ",", "'SOCLIM53'", ":", "'SOCLIM'", ",", "'COGLIM53'", ":", "'COGLIM'", ",", "\n", "'EMPST53'", ":", "'EMPST'", ",", "'REGION53'", ":", "'REGION'", ",", "'MARRY53X'", ":", "'MARRY'", ",", "'AGE53X'", ":", "'AGE'", ",", "\n", "'POVCAT15'", ":", "'POVCAT'", ",", "'INSCOV15'", ":", "'INSCOV'", "}", ")", "\n", "\n", "df", "=", "df", "[", "df", "[", "'REGION'", "]", ">=", "0", "]", "# remove values -1", "\n", "df", "=", "df", "[", "df", "[", "'AGE'", "]", ">=", "0", "]", "# remove values -1", "\n", "\n", "df", "=", "df", "[", "df", "[", "'MARRY'", "]", ">=", "0", "]", "# remove values -1, -7, -8, -9", "\n", "\n", "df", "=", "df", "[", "df", "[", "'ASTHDX'", "]", ">=", "0", "]", "# remove values -1, -7, -8, -9", "\n", "\n", "df", "=", "df", "[", "(", "df", "[", "[", "'FTSTU'", ",", "'ACTDTY'", ",", "'HONRDC'", ",", "'RTHLTH'", ",", "'MNHLTH'", ",", "'HIBPDX'", ",", "'CHDDX'", ",", "'ANGIDX'", ",", "'EDUCYR'", ",", "'HIDEG'", ",", "\n", "'MIDX'", ",", "'OHRTDX'", ",", "'STRKDX'", ",", "'EMPHDX'", ",", "'CHBRON'", ",", "'CHOLDX'", ",", "'CANCERDX'", ",", "'DIABDX'", ",", "\n", "'JTPAIN'", ",", "'ARTHDX'", ",", "'ARTHTYPE'", ",", "'ASTHDX'", ",", "'ADHDADDX'", ",", "'PREGNT'", ",", "'WLKLIM'", ",", "\n", "'ACTLIM'", ",", "'SOCLIM'", ",", "'COGLIM'", ",", "'DFHEAR42'", ",", "'DFSEE42'", ",", "'ADSMOK42'", ",", "\n", "'PHQ242'", ",", "'EMPST'", ",", "'POVCAT'", ",", "'INSCOV'", "]", "]", ">=", "-", "1", ")", ".", "all", "(", "1", ")", "]", "#for all other categorical features, remove values < -1", "\n", "\n", "def", "utilization", "(", "row", ")", ":", "\n", "        ", "return", "row", "[", "'OBTOTV15'", "]", "+", "row", "[", "'OPTOTV15'", "]", "+", "row", "[", "'ERTOT15'", "]", "+", "row", "[", "'IPNGTD15'", "]", "+", "row", "[", "'HHTOTD15'", "]", "\n", "\n", "", "df", "[", "'TOTEXP15'", "]", "=", "df", ".", "apply", "(", "lambda", "row", ":", "utilization", "(", "row", ")", ",", "axis", "=", "1", ")", "\n", "lessE", "=", "df", "[", "'TOTEXP15'", "]", "<", "10.0", "\n", "df", ".", "loc", "[", "lessE", ",", "'TOTEXP15'", "]", "=", "0.0", "\n", "moreE", "=", "df", "[", "'TOTEXP15'", "]", ">=", "10.0", "\n", "df", ".", "loc", "[", "moreE", ",", "'TOTEXP15'", "]", "=", "1.0", "\n", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'TOTEXP15'", ":", "'UTILIZATION'", "}", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.__init__": [[61, 151], ["df.astype.astype.isna().any().any", "df.astype.astype.columns.astype().tolist", "list", "list", "df[].values.copy", "df[].values.copy", "df.astype.astype.index.astype().tolist", "df_prot.columns.astype().tolist", "df_prot.values.copy", "aif360.datasets.Dataset.__init__", "TypeError", "ValueError", "df.astype.astype.astype", "map", "map", "df[].values.copy", "structured_dataset.StructuredDataset.labels.copy", "df[].values.copy", "numpy.ones_like", "df.astype.astype.isna().any", "print", "ValueError", "df.astype.astype.columns.astype", "df.astype.astype.index.astype", "df_prot.columns.astype", "numpy.sort", "numpy.sort", "df.astype.astype.isna", "numpy.unique", "numpy.unique"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["def", "__init__", "(", "self", ",", "df", ",", "label_names", ",", "protected_attribute_names", ",", "\n", "instance_weights_name", "=", "None", ",", "scores_names", "=", "[", "]", ",", "\n", "unprivileged_protected_attributes", "=", "[", "]", ",", "\n", "privileged_protected_attributes", "=", "[", "]", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            df (pandas.DataFrame): Input DataFrame with features, labels, and\n                protected attributes. Values should be preprocessed\n                to remove NAs and make all data numerical. Index values are\n                taken as instance names.\n            label_names (iterable): Names of the label columns in `df`.\n            protected_attribute_names (iterable): List of names corresponding to\n                protected attribute columns in `df`.\n            instance_weights_name (optional): Column name in `df` corresponding\n                to instance weights. If not provided, `instance_weights` will be\n                all set to 1.\n            unprivileged_protected_attributes (optional): If not provided, all\n                but the highest numerical value of each protected attribute will\n                be considered not privileged.\n            privileged_protected_attributes (optional): If not provided, the\n                highest numerical value of each protected attribute will be\n                considered privileged.\n            metadata (optional): Additional metadata to append.\n\n        Raises:\n            TypeError: Certain fields must be np.ndarrays as specified in the\n                class description.\n            ValueError: ndarray shapes must match.\n        \"\"\"", "\n", "if", "df", "is", "None", ":", "\n", "            ", "raise", "TypeError", "(", "\"Must provide a pandas DataFrame representing \"", "\n", "\"the data (features, labels, protected attributes)\"", ")", "\n", "", "if", "df", ".", "isna", "(", ")", ".", "any", "(", ")", ".", "any", "(", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Input DataFrames cannot contain NA values.\"", ")", "\n", "", "try", ":", "\n", "            ", "df", "=", "df", ".", "astype", "(", "np", ".", "float64", ")", "\n", "", "except", "ValueError", "as", "e", ":", "\n", "            ", "print", "(", "\"ValueError: {}\"", ".", "format", "(", "e", ")", ")", "\n", "raise", "ValueError", "(", "\"DataFrame values must be numerical.\"", ")", "\n", "\n", "# Convert all column names to strings", "\n", "", "df", ".", "columns", "=", "df", ".", "columns", ".", "astype", "(", "str", ")", ".", "tolist", "(", ")", "\n", "label_names", "=", "list", "(", "map", "(", "str", ",", "label_names", ")", ")", "\n", "protected_attribute_names", "=", "list", "(", "map", "(", "str", ",", "protected_attribute_names", ")", ")", "\n", "\n", "self", ".", "feature_names", "=", "[", "n", "for", "n", "in", "df", ".", "columns", "if", "n", "not", "in", "label_names", "\n", "and", "(", "not", "scores_names", "or", "n", "not", "in", "scores_names", ")", "\n", "and", "n", "!=", "instance_weights_name", "]", "\n", "self", ".", "label_names", "=", "label_names", "\n", "self", ".", "features", "=", "df", "[", "self", ".", "feature_names", "]", ".", "values", ".", "copy", "(", ")", "\n", "self", ".", "labels", "=", "df", "[", "self", ".", "label_names", "]", ".", "values", ".", "copy", "(", ")", "\n", "self", ".", "instance_names", "=", "df", ".", "index", ".", "astype", "(", "str", ")", ".", "tolist", "(", ")", "\n", "\n", "if", "scores_names", ":", "\n", "            ", "self", ".", "scores", "=", "df", "[", "scores_names", "]", ".", "values", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "scores", "=", "self", ".", "labels", ".", "copy", "(", ")", "\n", "\n", "", "df_prot", "=", "df", ".", "loc", "[", ":", ",", "protected_attribute_names", "]", "\n", "self", ".", "protected_attribute_names", "=", "df_prot", ".", "columns", ".", "astype", "(", "str", ")", ".", "tolist", "(", ")", "\n", "self", ".", "protected_attributes", "=", "df_prot", ".", "values", ".", "copy", "(", ")", "\n", "\n", "# Infer the privileged and unprivileged values in not provided", "\n", "if", "unprivileged_protected_attributes", "and", "privileged_protected_attributes", ":", "\n", "            ", "self", ".", "unprivileged_protected_attributes", "=", "unprivileged_protected_attributes", "\n", "self", ".", "privileged_protected_attributes", "=", "privileged_protected_attributes", "\n", "", "else", ":", "\n", "            ", "self", ".", "unprivileged_protected_attributes", "=", "[", "\n", "np", ".", "sort", "(", "np", ".", "unique", "(", "df_prot", "[", "attr", "]", ".", "values", ")", ")", "[", ":", "-", "1", "]", "\n", "for", "attr", "in", "self", ".", "protected_attribute_names", "]", "\n", "self", ".", "privileged_protected_attributes", "=", "[", "\n", "np", ".", "sort", "(", "np", ".", "unique", "(", "df_prot", "[", "attr", "]", ".", "values", ")", ")", "[", "-", "1", ":", "]", "\n", "for", "attr", "in", "self", ".", "protected_attribute_names", "]", "\n", "\n", "", "if", "instance_weights_name", ":", "\n", "            ", "self", ".", "instance_weights", "=", "df", "[", "instance_weights_name", "]", ".", "values", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "instance_weights", "=", "np", ".", "ones_like", "(", "self", ".", "instance_names", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "# always ignore metadata and ignore_fields", "\n", "", "self", ".", "ignore_fields", "=", "{", "'metadata'", ",", "'ignore_fields'", "}", "\n", "\n", "# sets metadata", "\n", "super", "(", "StructuredDataset", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_names", "=", "label_names", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "unprivileged_protected_attributes", "=", "unprivileged_protected_attributes", ",", "\n", "privileged_protected_attributes", "=", "privileged_protected_attributes", ",", "\n", "metadata", "=", "metadata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.subset": [[153, 171], ["structured_dataset.StructuredDataset.copy"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "subset", "(", "self", ",", "indexes", ")", ":", "\n", "        ", "\"\"\" Subset of dataset based on position\n        Args:\n            indexes: iterable which contains row indexes\n\n        Returns:\n            `StructuredDataset`: subset of dataset based on indexes\n        \"\"\"", "\n", "# convert each element of indexes to string", "\n", "indexes_str", "=", "[", "self", ".", "instance_names", "[", "i", "]", "for", "i", "in", "indexes", "]", "\n", "subset", "=", "self", ".", "copy", "(", ")", "\n", "subset", ".", "instance_names", "=", "indexes_str", "\n", "subset", ".", "features", "=", "self", ".", "features", "[", "indexes", "]", "\n", "subset", ".", "labels", "=", "self", ".", "labels", "[", "indexes", "]", "\n", "subset", ".", "instance_weights", "=", "self", ".", "instance_weights", "[", "indexes", "]", "\n", "subset", ".", "protected_attributes", "=", "self", ".", "protected_attributes", "[", "indexes", "]", "\n", "subset", ".", "scores", "=", "self", ".", "scores", "[", "indexes", "]", "\n", "return", "subset", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.__eq__": [[173, 190], ["all", "isinstance", "isinstance", "isinstance", "numpy.all", "structured_dataset.StructuredDataset.__eq__._eq"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Equality comparison for StructuredDatasets.\n\n        Note: Compares all fields other than those specified in `ignore_fields`.\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "other", ",", "StructuredDataset", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "def", "_eq", "(", "x", ",", "y", ")", ":", "\n", "            ", "if", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", "and", "isinstance", "(", "y", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "return", "np", ".", "all", "(", "x", "==", "y", ")", "\n", "", "elif", "isinstance", "(", "x", ",", "list", ")", "and", "isinstance", "(", "y", ",", "list", ")", ":", "\n", "                ", "return", "len", "(", "x", ")", "==", "len", "(", "y", ")", "and", "all", "(", "_eq", "(", "xi", ",", "yi", ")", "for", "xi", ",", "yi", "in", "zip", "(", "x", ",", "y", ")", ")", "\n", "", "return", "x", "==", "y", "\n", "\n", "", "return", "all", "(", "_eq", "(", "self", ".", "__dict__", "[", "k", "]", ",", "other", ".", "__dict__", "[", "k", "]", ")", "\n", "for", "k", "in", "self", ".", "__dict__", ".", "keys", "(", ")", "if", "k", "not", "in", "self", ".", "ignore_fields", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.__ne__": [[191, 193], ["None"], "methods", ["None"], ["", "def", "__ne__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "not", "self", "==", "other", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.__repr__": [[194, 197], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "# return repr(self.metadata)", "\n", "        ", "return", "str", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.__str__": [[198, 214], ["structured_dataset.StructuredDataset.convert_to_dataframe", "df.insert", "pandas.MultiIndex.from_arrays", "str", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.convert_to_dataframe"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "df", ",", "_", "=", "self", ".", "convert_to_dataframe", "(", ")", "\n", "df", ".", "insert", "(", "0", ",", "'instance_weights'", ",", "self", ".", "instance_weights", ")", "\n", "highest_level", "=", "[", "'instance weights'", "]", "+", "[", "'features'", "]", "*", "len", "(", "self", ".", "feature_names", ")", "+", "[", "'labels'", "]", "*", "len", "(", "self", ".", "label_names", ")", "\n", "middle_level", "=", "[", "''", "]", "+", "[", "'protected attribute'", "\n", "if", "f", "in", "self", ".", "protected_attribute_names", "else", "''", "\n", "for", "f", "in", "self", ".", "feature_names", "]", "+", "[", "''", "]", "*", "len", "(", "self", ".", "label_names", ")", "\n", "lowest_level", "=", "[", "''", "]", "+", "self", ".", "feature_names", "+", "[", "''", "]", "*", "len", "(", "self", ".", "label_names", ")", "\n", "df", ".", "columns", "=", "pd", ".", "MultiIndex", ".", "from_arrays", "(", "\n", "[", "highest_level", ",", "middle_level", ",", "lowest_level", "]", ")", "\n", "df", ".", "index", ".", "name", "=", "'instance names'", "\n", "return", "str", "(", "df", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.validate_dataset": [[216, 281], ["super().validate_dataset", "structured_dataset.StructuredDataset.features.astype", "structured_dataset.StructuredDataset.protected_attributes.astype", "structured_dataset.StructuredDataset.labels.astype", "structured_dataset.StructuredDataset.instance_weights.astype", "numpy.any", "range", "len", "structured_dataset.StructuredDataset.labels.reshape", "structured_dataset.StructuredDataset.scores.reshape", "ValueError", "ValueError", "numpy.logical_or", "logging.warning", "len", "set", "set", "isinstance", "TypeError", "print", "ValueError", "ValueError", "ValueError", "logging.warning", "set", "set", "list", "list", "list", "set", "set"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.validate_dataset", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "validate_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Error checking and type validation.\n\n        Raises:\n            TypeError: Certain fields must be np.ndarrays as specified in the\n                class description.\n            ValueError: ndarray shapes must match.\n        \"\"\"", "\n", "super", "(", "StructuredDataset", ",", "self", ")", ".", "validate_dataset", "(", ")", "\n", "\n", "# =========================== TYPE CHECKING ============================", "\n", "for", "f", "in", "[", "self", ".", "features", ",", "self", ".", "protected_attributes", ",", "self", ".", "labels", ",", "\n", "self", ".", "scores", ",", "self", ".", "instance_weights", "]", ":", "\n", "            ", "if", "not", "isinstance", "(", "f", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "raise", "TypeError", "(", "\"'{}' must be an np.ndarray.\"", ".", "format", "(", "f", ".", "__name__", ")", ")", "\n", "\n", "# convert ndarrays to float64", "\n", "", "", "self", ".", "features", "=", "self", ".", "features", ".", "astype", "(", "np", ".", "float64", ")", "\n", "self", ".", "protected_attributes", "=", "self", ".", "protected_attributes", ".", "astype", "(", "np", ".", "float64", ")", "\n", "self", ".", "labels", "=", "self", ".", "labels", ".", "astype", "(", "np", ".", "float64", ")", "\n", "self", ".", "instance_weights", "=", "self", ".", "instance_weights", ".", "astype", "(", "np", ".", "float64", ")", "\n", "\n", "# =========================== SHAPE CHECKING ===========================", "\n", "if", "len", "(", "self", ".", "labels", ".", "shape", ")", "==", "1", ":", "\n", "            ", "self", ".", "labels", "=", "self", ".", "labels", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "", "try", ":", "\n", "            ", "self", ".", "scores", ".", "reshape", "(", "self", ".", "labels", ".", "shape", ")", "\n", "", "except", "ValueError", "as", "e", ":", "\n", "            ", "print", "(", "\"ValueError: {}\"", ".", "format", "(", "e", ")", ")", "\n", "raise", "ValueError", "(", "\"'scores' should have the same shape as 'labels'.\"", ")", "\n", "", "if", "not", "self", ".", "labels", ".", "shape", "[", "0", "]", "==", "self", ".", "features", ".", "shape", "[", "0", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Number of labels must match number of instances:\"", "\n", "\"\\n\\tlabels.shape = {}\\n\\tfeatures.shape = {}\"", ".", "format", "(", "\n", "self", ".", "labels", ".", "shape", ",", "self", ".", "features", ".", "shape", ")", ")", "\n", "", "if", "not", "self", ".", "instance_weights", ".", "shape", "[", "0", "]", "==", "self", ".", "features", ".", "shape", "[", "0", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Number of weights must match number of instances:\"", "\n", "\"\\n\\tinstance_weights.shape = {}\\n\\tfeatures.shape = {}\"", ".", "format", "(", "\n", "self", ".", "instance_weights", ".", "shape", ",", "self", ".", "features", ".", "shape", ")", ")", "\n", "\n", "# =========================== VALUE CHECKING ===========================", "\n", "", "if", "np", ".", "any", "(", "np", ".", "logical_or", "(", "self", ".", "scores", "<", "0.", ",", "self", ".", "scores", ">", "1.", ")", ")", ":", "\n", "            ", "warning", "(", "\"'scores' has no well-defined meaning out of range [0, 1].\"", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "privileged_protected_attributes", ")", ")", ":", "\n", "            ", "priv", "=", "set", "(", "self", ".", "privileged_protected_attributes", "[", "i", "]", ")", "\n", "unpriv", "=", "set", "(", "self", ".", "unprivileged_protected_attributes", "[", "i", "]", ")", "\n", "# check for duplicates", "\n", "if", "priv", "&", "unpriv", ":", "\n", "                ", "raise", "ValueError", "(", "\"'privileged_protected_attributes' and \"", "\n", "\"'unprivileged_protected_attributes' should not share any \"", "\n", "\"common elements:\\n\\tBoth contain {} for feature {}\"", ".", "format", "(", "\n", "list", "(", "priv", "&", "unpriv", ")", ",", "self", ".", "protected_attribute_names", "[", "i", "]", ")", ")", "\n", "# check for unclassified values", "\n", "", "if", "not", "set", "(", "self", ".", "protected_attributes", "[", ":", ",", "i", "]", ")", "<=", "(", "priv", "|", "unpriv", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"All observed values for protected attributes \"", "\n", "\"should be designated as either privileged or unprivileged:\"", "\n", "\"\\n\\t{} not designated for feature {}\"", ".", "format", "(", "\n", "list", "(", "set", "(", "self", ".", "protected_attributes", "[", ":", ",", "i", "]", ")", "\n", "-", "(", "priv", "|", "unpriv", ")", ")", ",", "\n", "self", ".", "protected_attribute_names", "[", "i", "]", ")", ")", "\n", "# warn for unobserved values", "\n", "", "if", "not", "(", "priv", "|", "unpriv", ")", "<=", "set", "(", "self", ".", "protected_attributes", "[", ":", ",", "i", "]", ")", ":", "\n", "                ", "warning", "(", "\"{} listed but not observed for feature {}\"", ".", "format", "(", "\n", "list", "(", "(", "priv", "|", "unpriv", ")", "-", "set", "(", "self", ".", "protected_attributes", "[", ":", ",", "i", "]", ")", ")", ",", "\n", "self", ".", "protected_attribute_names", "[", "i", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.temporarily_ignore": [[282, 311], ["copy.deepcopy", "set"], "methods", ["None"], ["", "", "", "@", "contextmanager", "\n", "def", "temporarily_ignore", "(", "self", ",", "*", "fields", ")", ":", "\n", "        ", "\"\"\"Temporarily add the fields provided to `ignore_fields`.\n\n        To be used in a `with` statement. Upon completing the `with` block,\n        `ignore_fields` is restored to its original value.\n\n        Args:\n            *fields: Additional fields to ignore for equality comparison within\n                the scope of this context manager, e.g.\n                `temporarily_ignore('features', 'labels')`. The temporary\n                `ignore_fields` attribute is the union of the old attribute and\n                the set of these fields.\n\n        Examples:\n            >>> sd = StructuredDataset(...)\n            >>> modified = sd.copy()\n            >>> modified.labels = sd.labels + 1\n            >>> assert sd != modified\n            >>> with sd.temporarily_ignore('labels'):\n            >>>     assert sd == modified\n            >>> assert 'labels' not in sd.ignore_fields\n        \"\"\"", "\n", "old_ignore", "=", "deepcopy", "(", "self", ".", "ignore_fields", ")", "\n", "self", ".", "ignore_fields", "|=", "set", "(", "fields", ")", "\n", "try", ":", "\n", "            ", "yield", "\n", "", "finally", ":", "\n", "            ", "self", ".", "ignore_fields", "=", "old_ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.align_datasets": [[312, 354], ["other.copy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "ValueError", "other.copy.feature_names.index", "other.copy.label_names.index", "other.copy.protected_attribute_names.index", "set", "set", "set", "set", "set", "set"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "", "def", "align_datasets", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Align the other dataset features, labels and protected_attributes to\n        this dataset.\n\n        Args:\n            other (StructuredDataset): Other dataset that needs to be aligned\n\n        Returns:\n            StructuredDataset: New aligned dataset\n        \"\"\"", "\n", "\n", "if", "(", "set", "(", "self", ".", "feature_names", ")", "!=", "set", "(", "other", ".", "feature_names", ")", "or", "\n", "set", "(", "self", ".", "label_names", ")", "!=", "set", "(", "other", ".", "label_names", ")", "or", "\n", "set", "(", "self", ".", "protected_attribute_names", ")", "\n", "!=", "set", "(", "other", ".", "protected_attribute_names", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"feature_names, label_names, and protected_attribute_names \"", "\n", "\"should match between this and other dataset.\"", ")", "\n", "\n", "# New dataset", "\n", "", "new", "=", "other", ".", "copy", "(", ")", "\n", "\n", "# re-order the columns of the new dataset", "\n", "feat_inds", "=", "[", "new", ".", "feature_names", ".", "index", "(", "f", ")", "for", "f", "in", "self", ".", "feature_names", "]", "\n", "label_inds", "=", "[", "new", ".", "label_names", ".", "index", "(", "f", ")", "for", "f", "in", "self", ".", "label_names", "]", "\n", "prot_inds", "=", "[", "new", ".", "protected_attribute_names", ".", "index", "(", "f", ")", "\n", "for", "f", "in", "self", ".", "protected_attribute_names", "]", "\n", "\n", "new", ".", "features", "=", "new", ".", "features", "[", ":", ",", "feat_inds", "]", "\n", "new", ".", "labels", "=", "new", ".", "labels", "[", ":", ",", "label_inds", "]", "\n", "new", ".", "scores", "=", "new", ".", "scores", "[", ":", ",", "label_inds", "]", "\n", "new", ".", "protected_attributes", "=", "new", ".", "protected_attributes", "[", ":", ",", "prot_inds", "]", "\n", "\n", "new", ".", "privileged_protected_attributes", "=", "[", "\n", "new", ".", "privileged_protected_attributes", "[", "i", "]", "for", "i", "in", "prot_inds", "]", "\n", "new", ".", "unprivileged_protected_attributes", "=", "[", "\n", "new", ".", "unprivileged_protected_attributes", "[", "i", "]", "for", "i", "in", "prot_inds", "]", "\n", "new", ".", "feature_names", "=", "deepcopy", "(", "self", ".", "feature_names", ")", "\n", "new", ".", "label_names", "=", "deepcopy", "(", "self", ".", "label_names", ")", "\n", "new", ".", "protected_attribute_names", "=", "deepcopy", "(", "self", ".", "protected_attribute_names", ")", "\n", "\n", "return", "new", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.convert_to_dataframe": [[356, 415], ["pandas.DataFrame", "numpy.hstack", "structured_dataset.StructuredDataset._de_dummy_code_df", "enumerate", "enumerate", "df[].replace", "df[].replace"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset._de_dummy_code_df"], ["", "def", "convert_to_dataframe", "(", "self", ",", "de_dummy_code", "=", "False", ",", "sep", "=", "'='", ",", "\n", "set_category", "=", "True", ")", ":", "\n", "        ", "\"\"\"Convert the StructuredDataset to a :obj:`pandas.DataFrame`.\n\n        Args:\n            de_dummy_code (bool): Performs de_dummy_coding, converting dummy-\n                coded columns to categories. If `de_dummy_code` is `True` and\n                this dataset contains mappings for label and/or protected\n                attribute values to strings in the `metadata`, this method will\n                convert those as well.\n            sep (char): Separator between the prefix in the dummy indicators and\n                the dummy-coded categorical levels.\n            set_category (bool): Set the de-dummy coded features to categorical\n                type.\n\n        Returns:\n            (pandas.DataFrame, dict):\n\n                * `pandas.DataFrame`: Equivalent dataframe for a dataset. All\n                  columns will have only numeric values. The\n                  `protected_attributes` field in the dataset will override the\n                  values in the `features` field.\n\n                * `dict`: Attributes. Will contain additional information pulled\n                  from the dataset such as `feature_names`, `label_names`,\n                  `protected_attribute_names`, `instance_names`,\n                  `instance_weights`, `privileged_protected_attributes`,\n                  `unprivileged_protected_attributes`. The metadata will not be\n                  returned.\n\n        \"\"\"", "\n", "df", "=", "pd", ".", "DataFrame", "(", "np", ".", "hstack", "(", "(", "self", ".", "features", ",", "self", ".", "labels", ")", ")", ",", "\n", "columns", "=", "self", ".", "feature_names", "+", "self", ".", "label_names", ",", "\n", "index", "=", "self", ".", "instance_names", ")", "\n", "df", ".", "loc", "[", ":", ",", "self", ".", "protected_attribute_names", "]", "=", "self", ".", "protected_attributes", "\n", "\n", "# De-dummy code if necessary", "\n", "if", "de_dummy_code", ":", "\n", "            ", "df", "=", "self", ".", "_de_dummy_code_df", "(", "df", ",", "sep", "=", "sep", ",", "set_category", "=", "set_category", ")", "\n", "if", "'label_maps'", "in", "self", ".", "metadata", ":", "\n", "                ", "for", "i", ",", "label", "in", "enumerate", "(", "self", ".", "label_names", ")", ":", "\n", "                    ", "df", "[", "label", "]", "=", "df", "[", "label", "]", ".", "replace", "(", "self", ".", "metadata", "[", "'label_maps'", "]", "[", "i", "]", ")", "\n", "", "", "if", "'protected_attribute_maps'", "in", "self", ".", "metadata", ":", "\n", "                ", "for", "i", ",", "prot_attr", "in", "enumerate", "(", "self", ".", "protected_attribute_names", ")", ":", "\n", "                    ", "df", "[", "prot_attr", "]", "=", "df", "[", "prot_attr", "]", ".", "replace", "(", "\n", "self", ".", "metadata", "[", "'protected_attribute_maps'", "]", "[", "i", "]", ")", "\n", "\n", "# Attributes", "\n", "", "", "", "attributes", "=", "{", "\n", "\"feature_names\"", ":", "self", ".", "feature_names", ",", "\n", "\"label_names\"", ":", "self", ".", "label_names", ",", "\n", "\"protected_attribute_names\"", ":", "self", ".", "protected_attribute_names", ",", "\n", "\"instance_names\"", ":", "self", ".", "instance_names", ",", "\n", "\"instance_weights\"", ":", "self", ".", "instance_weights", ",", "\n", "\"privileged_protected_attributes\"", ":", "self", ".", "privileged_protected_attributes", ",", "\n", "\"unprivileged_protected_attributes\"", ":", "self", ".", "unprivileged_protected_attributes", "\n", "}", "\n", "\n", "return", "df", ",", "attributes", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.export_dataset": [[416, 426], ["NotImplementedError"], "methods", ["None"], ["", "def", "export_dataset", "(", "self", ",", "export_metadata", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Export the dataset and supporting attributes\n        TODO: The preferred file format is HDF\n        \"\"\"", "\n", "\n", "if", "export_metadata", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"The option to export metadata has not been implemented yet\"", ")", "\n", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.import_dataset": [[427, 435], ["NotImplementedError"], "methods", ["None"], ["", "def", "import_dataset", "(", "self", ",", "import_metadata", "=", "False", ")", ":", "\n", "        ", "\"\"\" Import the dataset and supporting attributes\n            TODO: The preferred file format is HDF\n        \"\"\"", "\n", "\n", "if", "import_metadata", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"The option to import metadata has not been implemented yet\"", ")", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.split": [[436, 501], ["isinstance", "list", "numpy.array_split", "numpy.array_split", "numpy.array_split", "numpy.array_split", "numpy.array_split", "numpy.array_split", "zip", "numpy.random.seed", "structured_dataset.StructuredDataset.copy", "list", "fold.metadata.copy", "fold.metadata.update", "len", "all", "numpy.random.permutation", "range", "range", "numpy.array", "map", "int", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "split", "(", "self", ",", "num_or_size_splits", ",", "shuffle", "=", "False", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Split this dataset into multiple partitions.\n\n        Args:\n            num_or_size_splits (array or int): If `num_or_size_splits` is an\n                int, *k*, the value is the number of equal-sized folds to make\n                (if *k* does not evenly divide the dataset these folds are\n                approximately equal-sized). If `num_or_size_splits` is an array\n                of type int, the values are taken as the indices at which to\n                split the dataset. If the values are floats (< 1.), they are\n                considered to be fractional proportions of the dataset at which\n                to split.\n            shuffle (bool, optional): Randomly shuffle the dataset before\n                splitting.\n            seed (int or array_like): Takes the same argument as\n                :func:`numpy.random.seed()`.\n\n        Returns:\n            list: Splits. Contains *k* or `len(num_or_size_splits) + 1`\n            datasets depending on `num_or_size_splits`.\n        \"\"\"", "\n", "\n", "# Set seed", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "", "n", "=", "self", ".", "features", ".", "shape", "[", "0", "]", "\n", "if", "isinstance", "(", "num_or_size_splits", ",", "list", ")", ":", "\n", "            ", "num_folds", "=", "len", "(", "num_or_size_splits", ")", "+", "1", "\n", "if", "num_folds", ">", "1", "and", "all", "(", "x", "<=", "1.", "for", "x", "in", "num_or_size_splits", ")", ":", "\n", "                ", "num_or_size_splits", "=", "[", "int", "(", "x", "*", "n", ")", "for", "x", "in", "num_or_size_splits", "]", "\n", "", "", "else", ":", "\n", "            ", "num_folds", "=", "num_or_size_splits", "\n", "\n", "", "order", "=", "list", "(", "np", ".", "random", ".", "permutation", "(", "n", ")", "if", "shuffle", "else", "range", "(", "n", ")", ")", "\n", "folds", "=", "[", "self", ".", "copy", "(", ")", "for", "_", "in", "range", "(", "num_folds", ")", "]", "\n", "\n", "features", "=", "np", ".", "array_split", "(", "self", ".", "features", "[", "order", "]", ",", "num_or_size_splits", ")", "\n", "labels", "=", "np", ".", "array_split", "(", "self", ".", "labels", "[", "order", "]", ",", "num_or_size_splits", ")", "\n", "scores", "=", "np", ".", "array_split", "(", "self", ".", "scores", "[", "order", "]", ",", "num_or_size_splits", ")", "\n", "protected_attributes", "=", "np", ".", "array_split", "(", "self", ".", "protected_attributes", "[", "order", "]", ",", "\n", "num_or_size_splits", ")", "\n", "instance_weights", "=", "np", ".", "array_split", "(", "self", ".", "instance_weights", "[", "order", "]", ",", "\n", "num_or_size_splits", ")", "\n", "instance_names", "=", "np", ".", "array_split", "(", "np", ".", "array", "(", "self", ".", "instance_names", ")", "[", "order", "]", ",", "\n", "num_or_size_splits", ")", "\n", "for", "fold", ",", "feats", ",", "labs", ",", "scors", ",", "prot_attrs", ",", "inst_wgts", ",", "inst_name", "in", "zip", "(", "\n", "folds", ",", "features", ",", "labels", ",", "scores", ",", "protected_attributes", ",", "instance_weights", ",", "\n", "instance_names", ")", ":", "\n", "\n", "            ", "fold", ".", "features", "=", "feats", "\n", "fold", ".", "labels", "=", "labs", "\n", "fold", ".", "scores", "=", "scors", "\n", "fold", ".", "protected_attributes", "=", "prot_attrs", "\n", "fold", ".", "instance_weights", "=", "inst_wgts", "\n", "fold", ".", "instance_names", "=", "list", "(", "map", "(", "str", ",", "inst_name", ")", ")", "\n", "fold", ".", "metadata", "=", "fold", ".", "metadata", ".", "copy", "(", ")", "\n", "fold", ".", "metadata", ".", "update", "(", "{", "\n", "'transformer'", ":", "'{}.split'", ".", "format", "(", "type", "(", "self", ")", ".", "__name__", ")", ",", "\n", "'params'", ":", "{", "'num_or_size_splits'", ":", "num_or_size_splits", ",", "\n", "'shuffle'", ":", "shuffle", "}", ",", "\n", "'previous'", ":", "[", "self", "]", "\n", "}", ")", "\n", "\n", "", "return", "folds", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset._de_dummy_code_df": [[502, 541], ["structured_dataset.StructuredDataset._parse_feature_names", "pandas.DataFrame", "feature_names_dum_d.items", "df[].values.copy", "feature_names_dum_d.keys", "str", "df_new[].astype", "list", "feature_names_dum_d.keys", "str"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset._parse_feature_names", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "@", "staticmethod", "\n", "def", "_de_dummy_code_df", "(", "df", ",", "sep", "=", "\"=\"", ",", "set_category", "=", "False", ")", ":", "\n", "        ", "\"\"\"De-dummy code a dummy-coded dataframe obtained with pd.get_dummies().\n\n        After reversing dummy coding the corresponding fields will be converted\n        to categorical.\n\n        Args:\n            df (pandas.DataFrame): Input dummy coded dataframe\n            sep (char): Separator between base name and dummy code\n            set_category (bool): Set the de-dummy coded features\n                    to categorical type\n\n        Examples:\n            >>> columns = [\"Age\", \"Gender=Male\", \"Gender=Female\"]\n            >>> df = pd.DataFrame([[10, 1, 0], [20, 0, 1]], columns=columns)\n            >>> _de_dummy_code_df(df, sep=\"=\")\n               Age  Gender\n            0   10    Male\n            1   20  Female\n        \"\"\"", "\n", "\n", "feature_names_dum_d", ",", "feature_names_nodum", "=", "StructuredDataset", ".", "_parse_feature_names", "(", "df", ".", "columns", ")", "\n", "df_new", "=", "pd", ".", "DataFrame", "(", "index", "=", "df", ".", "index", ",", "\n", "columns", "=", "feature_names_nodum", "+", "list", "(", "feature_names_dum_d", ".", "keys", "(", ")", ")", ")", "\n", "\n", "for", "fname", "in", "feature_names_nodum", ":", "\n", "            ", "df_new", "[", "fname", "]", "=", "df", "[", "fname", "]", ".", "values", ".", "copy", "(", ")", "\n", "\n", "", "for", "fname", ",", "vl", "in", "feature_names_dum_d", ".", "items", "(", ")", ":", "\n", "            ", "for", "v", "in", "vl", ":", "\n", "                ", "df_new", ".", "loc", "[", "df", "[", "fname", "+", "sep", "+", "str", "(", "v", ")", "]", "==", "1", ",", "fname", "]", "=", "str", "(", "v", ")", "\n", "\n", "", "", "if", "set_category", ":", "\n", "            ", "for", "fname", "in", "feature_names_dum_d", ".", "keys", "(", ")", ":", "\n", "                ", "df_new", "[", "fname", "]", "=", "df_new", "[", "fname", "]", ".", "astype", "(", "'category'", ")", "\n", "\n", "", "", "return", "df_new", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset._parse_feature_names": [[542, 574], ["collections.defaultdict", "list", "fname.split", "feature_names_dum_d[].append", "list.append"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split"], ["", "@", "staticmethod", "\n", "def", "_parse_feature_names", "(", "feature_names", ",", "sep", "=", "\"=\"", ")", ":", "\n", "        ", "\"\"\"Parse feature names to ordinary and dummy coded candidates.\n\n        Args:\n            feature_names (list): Names of features\n            sep (char): Separator to designate the dummy coded category in the\n                feature name\n\n        Returns:\n            (dict, list):\n\n                * feature_names_dum_d (dict): Keys are the base feature names\n                  and values are the categories.\n\n                * feature_names_nodum (list): Non-dummy coded feature names.\n\n        Examples:\n            >>> feature_names = [\"Age\", \"Gender=Male\", \"Gender=Female\"]\n            >>> StructuredDataset._parse_feature_names(feature_names, sep=\"=\")\n            (defaultdict(<type 'list'>, {'Gender': ['Male', 'Female']}), ['Age'])\n        \"\"\"", "\n", "feature_names_dum_d", "=", "defaultdict", "(", "list", ")", "\n", "feature_names_nodum", "=", "list", "(", ")", "\n", "for", "fname", "in", "feature_names", ":", "\n", "            ", "if", "sep", "in", "fname", ":", "\n", "                ", "fname_dum", ",", "v", "=", "fname", ".", "split", "(", "sep", ",", "1", ")", "\n", "feature_names_dum_d", "[", "fname_dum", "]", ".", "append", "(", "v", ")", "\n", "", "else", ":", "\n", "                ", "feature_names_nodum", ".", "append", "(", "fname", ")", "\n", "\n", "", "", "return", "feature_names_dum_d", ",", "feature_names_nodum", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.__init__": [[8, 17], ["dataset.Dataset.metadata.update", "dataset.Dataset.validate_dataset", "kwargs.pop", "dict", "dict", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.validate_dataset"], ["@", "abstractmethod", "\n", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "metadata", "=", "kwargs", ".", "pop", "(", "'metadata'", ",", "dict", "(", ")", ")", "or", "dict", "(", ")", "\n", "self", ".", "metadata", ".", "update", "(", "{", "\n", "'transformer'", ":", "'{}.__init__'", ".", "format", "(", "type", "(", "self", ")", ".", "__name__", ")", ",", "\n", "'params'", ":", "kwargs", ",", "\n", "'previous'", ":", "[", "]", "\n", "}", ")", "\n", "self", ".", "validate_dataset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.validate_dataset": [[18, 21], ["None"], "methods", ["None"], ["", "def", "validate_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Error checking and type validation.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy": [[22, 42], ["cpy.metadata.copy", "cpy.metadata.update", "copy.deepcopy", "copy.copy", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "copy", "(", "self", ",", "deepcopy", "=", "False", ")", ":", "\n", "        ", "\"\"\"Convenience method to return a copy of this dataset.\n\n        Args:\n            deepcopy (bool, optional): :func:`~copy.deepcopy` this dataset if\n                `True`, shallow copy otherwise.\n\n        Returns:\n            Dataset: A new dataset with fields copied from this object and\n            metadata set accordingly.\n        \"\"\"", "\n", "cpy", "=", "copy", ".", "deepcopy", "(", "self", ")", "if", "deepcopy", "else", "copy", ".", "copy", "(", "self", ")", "\n", "# preserve any user-created fields", "\n", "cpy", ".", "metadata", "=", "cpy", ".", "metadata", ".", "copy", "(", ")", "\n", "cpy", ".", "metadata", ".", "update", "(", "{", "\n", "'transformer'", ":", "'{}.copy'", ".", "format", "(", "type", "(", "self", ")", ".", "__name__", ")", ",", "\n", "'params'", ":", "{", "'deepcopy'", ":", "deepcopy", "}", ",", "\n", "'previous'", ":", "[", "self", "]", "\n", "}", ")", "\n", "return", "cpy", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.export_dataset": [[43, 47], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "export_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Save this Dataset to disk.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split": [[48, 69], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "split", "(", "self", ",", "num_or_size_splits", ",", "shuffle", "=", "False", ")", ":", "\n", "        ", "\"\"\"Split this dataset into multiple partitions.\n\n        Args:\n            num_or_size_splits (array or int): If `num_or_size_splits` is an\n                int, *k*, the value is the number of equal-sized folds to make\n                (if *k* does not evenly divide the dataset these folds are\n                approximately equal-sized). If `num_or_size_splits` is an array\n                of type int, the values are taken as the indices at which to\n                split the dataset. If the values are floats (< 1.), they are\n                considered to be fractional proportions of the dataset at which\n                to split.\n            shuffle (bool, optional): Randomly shuffle the dataset before\n                splitting.\n\n        Returns:\n            list(Dataset): Splits. Contains *k* or `len(num_or_size_splits) + 1`\n            datasets depending on `num_or_size_splits`.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.bank_dataset.BankDataset.__init__": [[14, 55], ["os.path.join", "aif360.datasets.StandardDataset.__init__", "os.path.dirname", "pandas.read_csv", "os.path.abspath", "print", "print", "print", "print", "print", "sys.exit", "os.path.abspath", "os.path.join", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "label_name", "=", "'y'", ",", "favorable_classes", "=", "[", "'yes'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'age'", "]", ",", "\n", "privileged_classes", "=", "[", "lambda", "x", ":", "x", ">=", "25", "]", ",", "\n", "instance_weights_name", "=", "None", ",", "\n", "categorical_features", "=", "[", "'job'", ",", "'marital'", ",", "'education'", ",", "'default'", ",", "\n", "'housing'", ",", "'loan'", ",", "'contact'", ",", "'month'", ",", "'day_of_week'", ",", "\n", "'poutcome'", "]", ",", "\n", "features_to_keep", "=", "[", "]", ",", "features_to_drop", "=", "[", "]", ",", "\n", "na_values", "=", "[", "\"unknown\"", "]", ",", "custom_preprocessing", "=", "None", ",", "\n", "metadata", "=", "None", ")", ":", "\n", "        ", "\"\"\"See :obj:`StandardDataset` for a description of the arguments.\n\n        By default, this code converts the 'age' attribute to a binary value\n        where privileged is `age >= 25` and unprivileged is `age < 25` as in\n        :obj:`GermanDataset`.\n        \"\"\"", "\n", "\n", "filepath", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'data'", ",", "'raw'", ",", "'bank'", ",", "'bank-additional-full.csv'", ")", "\n", "\n", "try", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "sep", "=", "';'", ",", "na_values", "=", "na_values", ")", "\n", "", "except", "IOError", "as", "err", ":", "\n", "            ", "print", "(", "\"IOError: {}\"", ".", "format", "(", "err", ")", ")", "\n", "print", "(", "\"To use this class, please download the following file:\"", ")", "\n", "print", "(", "\"\\n\\thttps://archive.ics.uci.edu/ml/machine-learning-databases/00222/bank-additional.zip\"", ")", "\n", "print", "(", "\"\\nunzip it and place the files, as-is, in the folder:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'bank'", ")", ")", ")", ")", "\n", "import", "sys", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "super", "(", "BankDataset", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_name", "=", "label_name", ",", "\n", "favorable_classes", "=", "favorable_classes", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_classes", "=", "privileged_classes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "features_to_keep", ",", "\n", "features_to_drop", "=", "features_to_drop", ",", "na_values", "=", "na_values", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ",", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.german_dataset.GermanDataset.__init__": [[29, 100], ["os.path.join", "aif360.datasets.StandardDataset.__init__", "os.path.dirname", "pandas.read_csv", "os.path.abspath", "print", "print", "print", "print", "print", "print", "sys.exit", "os.path.abspath", "os.path.join", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "label_name", "=", "'credit'", ",", "favorable_classes", "=", "[", "1", "]", ",", "\n", "protected_attribute_names", "=", "[", "'sex'", ",", "'age'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'male'", "]", ",", "lambda", "x", ":", "x", ">", "25", "]", ",", "\n", "instance_weights_name", "=", "None", ",", "\n", "categorical_features", "=", "[", "'status'", ",", "'credit_history'", ",", "'purpose'", ",", "\n", "'savings'", ",", "'employment'", ",", "'other_debtors'", ",", "'property'", ",", "\n", "'installment_plans'", ",", "'housing'", ",", "'skill_level'", ",", "'telephone'", ",", "\n", "'foreign_worker'", "]", ",", "\n", "features_to_keep", "=", "[", "]", ",", "features_to_drop", "=", "[", "'personal_status'", "]", ",", "\n", "na_values", "=", "[", "]", ",", "custom_preprocessing", "=", "default_preprocessing", ",", "\n", "metadata", "=", "default_mappings", ")", ":", "\n", "        ", "\"\"\"See :obj:`StandardDataset` for a description of the arguments.\n\n        By default, this code converts the 'age' attribute to a binary value\n        where privileged is `age > 25` and unprivileged is `age <= 25` as\n        proposed by Kamiran and Calders [1]_.\n\n        References:\n            .. [1] F. Kamiran and T. Calders, \"Classifying without\n               discriminating,\" 2nd International Conference on Computer,\n               Control and Communication, 2009.\n\n        Examples:\n            In some cases, it may be useful to keep track of a mapping from\n            `float -> str` for protected attributes and/or labels. If our use\n            case differs from the default, we can modify the mapping stored in\n            `metadata`:\n\n            >>> label_map = {1.0: 'Good Credit', 0.0: 'Bad Credit'}\n            >>> protected_attribute_maps = [{1.0: 'Male', 0.0: 'Female'}]\n            >>> gd = GermanDataset(protected_attribute_names=['sex'],\n            ... privileged_classes=[['male']], metadata={'label_map': label_map,\n            ... 'protected_attribute_maps': protected_attribute_maps})\n\n            Now this information will stay attached to the dataset and can be\n            used for more descriptive visualizations.\n        \"\"\"", "\n", "\n", "filepath", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'data'", ",", "'raw'", ",", "'german'", ",", "'german.data'", ")", "\n", "# as given by german.doc", "\n", "column_names", "=", "[", "'status'", ",", "'month'", ",", "'credit_history'", ",", "\n", "'purpose'", ",", "'credit_amount'", ",", "'savings'", ",", "'employment'", ",", "\n", "'investment_as_income_percentage'", ",", "'personal_status'", ",", "\n", "'other_debtors'", ",", "'residence_since'", ",", "'property'", ",", "'age'", ",", "\n", "'installment_plans'", ",", "'housing'", ",", "'number_of_credits'", ",", "\n", "'skill_level'", ",", "'people_liable_for'", ",", "'telephone'", ",", "\n", "'foreign_worker'", ",", "'credit'", "]", "\n", "try", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "sep", "=", "' '", ",", "header", "=", "None", ",", "names", "=", "column_names", ",", "\n", "na_values", "=", "na_values", ")", "\n", "", "except", "IOError", "as", "err", ":", "\n", "            ", "print", "(", "\"IOError: {}\"", ".", "format", "(", "err", ")", ")", "\n", "print", "(", "\"To use this class, please download the following files:\"", ")", "\n", "print", "(", "\"\\n\\thttps://archive.ics.uci.edu/ml/machine-learning-databases/statlog/german/german.data\"", ")", "\n", "print", "(", "\"\\thttps://archive.ics.uci.edu/ml/machine-learning-databases/statlog/german/german.doc\"", ")", "\n", "print", "(", "\"\\nand place them, as-is, in the folder:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'german'", ")", ")", ")", ")", "\n", "import", "sys", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "super", "(", "GermanDataset", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_name", "=", "label_name", ",", "\n", "favorable_classes", "=", "favorable_classes", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_classes", "=", "privileged_classes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "features_to_keep", ",", "\n", "features_to_drop", "=", "features_to_drop", ",", "na_values", "=", "na_values", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ",", "metadata", "=", "metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.german_dataset.default_preprocessing": [[14, 22], ["df[].replace"], "function", ["None"], ["def", "default_preprocessing", "(", "df", ")", ":", "\n", "    ", "\"\"\"Adds a derived sex attribute based on personal_status.\"\"\"", "\n", "# TODO: ignores the value of privileged_classes for 'sex'", "\n", "status_map", "=", "{", "'A91'", ":", "'male'", ",", "'A93'", ":", "'male'", ",", "'A94'", ":", "'male'", ",", "\n", "'A92'", ":", "'female'", ",", "'A95'", ":", "'female'", "}", "\n", "df", "[", "'sex'", "]", "=", "df", "[", "'personal_status'", "]", ".", "replace", "(", "status_map", ")", "\n", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.tempeh_datasets.fetch_lawschool_gpa": [[7, 52], ["dataset.get_X", "dataset.get_y", "dataset.get_sensitive_features", "pandas.concat", "pandas.concat", "aif360.sklearn.datasets.utils.standardize_dataset", "ValueError", "pandas.concat"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.standardize_dataset"], ["def", "fetch_lawschool_gpa", "(", "subset", "=", "\"all\"", ",", "usecols", "=", "[", "]", ",", "dropcols", "=", "[", "]", ",", "\n", "numeric_only", "=", "False", ",", "dropna", "=", "False", ")", ":", "\n", "    ", "\"\"\"Load the Law School GPA dataset\n\n    Note:\n        By default, the data is downloaded from tempeh. See\n        https://github.com/microsoft/tempeh for details.\n\n    Args:\n        subset ({'train', 'test', or 'all'}, optional): Select the dataset to\n            load: 'train' for the training set, 'test' for the test set, 'all'\n            for both.\n        usecols (single label or list-like, optional): Feature column(s) to\n            keep. All others are dropped.\n        dropcols (single label or list-like, optional): Feature column(s) to\n            drop.\n        numeric_only (bool): Drop all non-numeric feature columns.\n        dropna (bool): Drop rows with NAs.\n\n    Returns:\n        namedtuple: Tuple containing X, y, and sample_weights for the Law School\n        GPA dataset accessible by index or name.\n    \"\"\"", "\n", "if", "subset", "not", "in", "{", "'train'", ",", "'test'", ",", "'all'", "}", ":", "\n", "        ", "raise", "ValueError", "(", "\"subset must be either 'train', 'test', or 'all'; \"", "\n", "\"cannot be {}\"", ".", "format", "(", "subset", ")", ")", "\n", "\n", "", "dataset", "=", "tc", ".", "datasets", "[", "\"lawschool_gpa\"", "]", "(", ")", "\n", "X_train", ",", "X_test", "=", "dataset", ".", "get_X", "(", "format", "=", "pd", ".", "DataFrame", ")", "\n", "y_train", ",", "y_test", "=", "dataset", ".", "get_y", "(", "format", "=", "pd", ".", "Series", ")", "\n", "A_train", ",", "A_test", "=", "dataset", ".", "get_sensitive_features", "(", "name", "=", "'race'", ",", "\n", "format", "=", "pd", ".", "Series", ")", "\n", "all_train", "=", "pd", ".", "concat", "(", "[", "X_train", ",", "y_train", ",", "A_train", "]", ",", "axis", "=", "1", ")", "\n", "all_test", "=", "pd", ".", "concat", "(", "[", "X_test", ",", "y_test", ",", "A_test", "]", ",", "axis", "=", "1", ")", "\n", "\n", "if", "subset", "==", "\"train\"", ":", "\n", "        ", "df", "=", "all_train", "\n", "", "elif", "subset", "==", "\"test\"", ":", "\n", "        ", "df", "=", "all_test", "\n", "", "else", ":", "\n", "        ", "df", "=", "pd", ".", "concat", "(", "[", "all_train", ",", "all_test", "]", ",", "axis", "=", "0", ")", "\n", "\n", "", "return", "standardize_dataset", "(", "df", ",", "prot_attr", "=", "[", "'race'", "]", ",", "target", "=", "'zfygpa'", ",", "\n", "usecols", "=", "usecols", ",", "dropcols", "=", "dropcols", ",", "\n", "numeric_only", "=", "numeric_only", ",", "dropna", "=", "dropna", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.compas_dataset.fetch_compas": [[13, 84], ["os.path.join", "os.path.isfile", "pd.read_csv.two_year_recid.replace().astype", "pd.read_csv.two_year_recid.cat.set_categories", "pd.read_csv.sex.astype().cat.reorder_categories", "aif360.sklearn.datasets.utils.standardize_dataset", "os.path.basename", "pandas.read_csv", "pandas.read_csv", "os.makedirs", "pd.read_csv.to_csv", "df[].astype", "pd.read_csv.race.cat.set_categories", "os.path.dirname", "pd.read_csv.two_year_recid.replace", "pd.read_csv.sex.astype"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.standardize_dataset"], ["\n", "def", "default_preprocessing", "(", "df", ")", ":", "\n", "    ", "\"\"\"Perform the same preprocessing as the original analysis:\n    https://github.com/propublica/compas-analysis/blob/master/Compas%20Analysis.ipynb\n    \"\"\"", "\n", "return", "df", "[", "(", "df", ".", "days_b_screening_arrest", "<=", "30", ")", "\n", "&", "(", "df", ".", "days_b_screening_arrest", ">=", "-", "30", ")", "\n", "&", "(", "df", ".", "is_recid", "!=", "-", "1", ")", "\n", "&", "(", "df", ".", "c_charge_degree", "!=", "'O'", ")", "\n", "&", "(", "df", ".", "score_text", "!=", "'N/A'", ")", "]", "\n", "\n", "", "class", "CompasDataset", "(", "StandardDataset", ")", ":", "\n", "    ", "\"\"\"ProPublica COMPAS Dataset.\n\n    See :file:`aif360/data/raw/compas/README.md`.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "label_name", "=", "'two_year_recid'", ",", "favorable_classes", "=", "[", "0", "]", ",", "\n", "protected_attribute_names", "=", "[", "'sex'", ",", "'race'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'Female'", "]", ",", "[", "'Caucasian'", "]", "]", ",", "\n", "instance_weights_name", "=", "None", ",", "\n", "categorical_features", "=", "[", "'age_cat'", ",", "'c_charge_degree'", ",", "\n", "'c_charge_desc'", "]", ",", "\n", "features_to_keep", "=", "[", "'sex'", ",", "'age'", ",", "'age_cat'", ",", "'race'", ",", "\n", "'juv_fel_count'", ",", "'juv_misd_count'", ",", "'juv_other_count'", ",", "\n", "'priors_count'", ",", "'c_charge_degree'", ",", "'c_charge_desc'", ",", "\n", "'two_year_recid'", "]", ",", "\n", "features_to_drop", "=", "[", "]", ",", "na_values", "=", "[", "]", ",", "\n", "custom_preprocessing", "=", "default_preprocessing", ",", "\n", "metadata", "=", "default_mappings", ")", ":", "\n", "        ", "\"\"\"See :obj:`StandardDataset` for a description of the arguments.\n\n        Note: The label value 0 in this case is considered favorable (no\n        recidivism).\n\n        Examples:\n            In some cases, it may be useful to keep track of a mapping from\n            `float -> str` for protected attributes and/or labels. If our use\n            case differs from the default, we can modify the mapping stored in\n            `metadata`:\n\n            >>> label_map = {1.0: 'Did recid.', 0.0: 'No recid.'}\n            >>> protected_attribute_maps = [{1.0: 'Male', 0.0: 'Female'}]\n            >>> cd = CompasDataset(protected_attribute_names=['sex'],\n            ... privileged_classes=[['Male']], metadata={'label_map': label_map,\n            ... 'protected_attribute_maps': protected_attribute_maps})\n\n            Now this information will stay attached to the dataset and can be\n            used for more descriptive visualizations.\n        \"\"\"", "\n", "\n", "filepath", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'data'", ",", "'raw'", ",", "'compas'", ",", "'compas-scores-two-years.csv'", ")", "\n", "\n", "try", ":", "\n", "            ", "df", "=", "pd", ".", "read_csv", "(", "filepath", ",", "index_col", "=", "'id'", ",", "na_values", "=", "na_values", ")", "\n", "", "except", "IOError", "as", "err", ":", "\n", "            ", "print", "(", "\"IOError: {}\"", ".", "format", "(", "err", ")", ")", "\n", "print", "(", "\"To use this class, please download the following file:\"", ")", "\n", "print", "(", "\"\\n\\thttps://raw.githubusercontent.com/propublica/compas-analysis/master/compas-scores-two-years.csv\"", ")", "\n", "print", "(", "\"\\nand place it, as-is, in the folder:\"", ")", "\n", "print", "(", "\"\\n\\t{}\\n\"", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ",", "'..'", ",", "'..'", ",", "'data'", ",", "'raw'", ",", "'compas'", ")", ")", ")", ")", "\n", "import", "sys", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "super", "(", "CompasDataset", ",", "self", ")", ".", "__init__", "(", "df", "=", "df", ",", "label_name", "=", "label_name", ",", "\n", "favorable_classes", "=", "favorable_classes", ",", "\n", "protected_attribute_names", "=", "protected_attribute_names", ",", "\n", "privileged_classes", "=", "privileged_classes", ",", "\n", "instance_weights_name", "=", "instance_weights_name", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.to_dataframe": [[13, 34], ["pandas.DataFrame", "data[].items", "df[].apply().astype", "pandas.isna", "df[].apply", "int"], "function", ["None"], ["def", "to_dataframe", "(", "data", ")", ":", "\n", "    ", "\"\"\"Format an OpenML dataset Bunch as a DataFrame with categorical features\n    if needed.\n\n    Args:\n        data (Bunch): Dict-like object containing ``data``, ``feature_names``\n            and, optionally, ``categories`` attributes. Note: ``data`` should\n            contain both X and y data.\n\n    Returns:\n        pandas.DataFrame: A DataFrame containing all data, including target,\n        with categorical features converted to 'category' dtypes.\n    \"\"\"", "\n", "def", "categorize", "(", "item", ")", ":", "\n", "        ", "return", "cats", "[", "int", "(", "item", ")", "]", "if", "not", "pd", ".", "isna", "(", "item", ")", "else", "item", "\n", "\n", "", "df", "=", "pd", ".", "DataFrame", "(", "data", "[", "'data'", "]", ",", "columns", "=", "data", "[", "'feature_names'", "]", ")", "\n", "for", "col", ",", "cats", "in", "data", "[", "'categories'", "]", ".", "items", "(", ")", ":", "\n", "        ", "df", "[", "col", "]", "=", "df", "[", "col", "]", ".", "apply", "(", "categorize", ")", ".", "astype", "(", "'category'", ")", "\n", "\n", "", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_adult": [[35, 103], ["openml_datasets.to_dataframe", "df.rename.rename", "df[].cat.as_ordered", "df.rename.sex.cat.as_ordered", "aif360.sklearn.datasets.utils.standardize_dataset", "ValueError", "sklearn.datasets.fetch_openml", "df.rename.race.cat.set_categories().fillna", "df.rename.race.cat.set_categories"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.to_dataframe", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.standardize_dataset"], ["", "def", "fetch_adult", "(", "subset", "=", "'all'", ",", "data_home", "=", "None", ",", "binary_race", "=", "True", ",", "usecols", "=", "[", "]", ",", "\n", "dropcols", "=", "[", "]", ",", "numeric_only", "=", "False", ",", "dropna", "=", "True", ")", ":", "\n", "    ", "\"\"\"Load the Adult Census Income Dataset.\n\n    Binarizes 'race' to 'White' (privileged) or 'Non-white' (unprivileged). The\n    other protected attribute is 'sex' ('Male' is privileged and 'Female' is\n    unprivileged). The outcome variable is 'annual-income': '>50K' (favorable)\n    or '<=50K' (unfavorable).\n\n    Note:\n        By default, the data is downloaded from OpenML. See the `adult\n        <https://www.openml.org/d/1590>`_ page for details.\n\n    Args:\n        subset ({'train', 'test', or 'all'}, optional): Select the dataset to\n            load: 'train' for the training set, 'test' for the test set, 'all'\n            for both.\n        data_home (string, optional): Specify another download and cache folder\n            for the datasets. By default all AIF360 datasets are stored in\n            'aif360/sklearn/data/raw' subfolders.\n        binary_race (bool, optional): Group all non-white races together.\n        usecols (single label or list-like, optional): Feature column(s) to\n            keep. All others are dropped.\n        dropcols (single label or list-like, optional): Feature column(s) to\n            drop.\n        numeric_only (bool): Drop all non-numeric feature columns.\n        dropna (bool): Drop rows with NAs.\n\n    Returns:\n        namedtuple: Tuple containing X, y, and sample_weights for the Adult\n        dataset accessible by index or name.\n\n    See also:\n        :func:`sklearn.datasets.fetch_openml`\n\n    Examples:\n        >>> adult = fetch_adult()\n        >>> adult.X.shape\n        (45222, 13)\n\n        >>> adult_num = fetch_adult(numeric_only=True)\n        >>> adult_num.X.shape\n        (48842, 5)\n    \"\"\"", "\n", "if", "subset", "not", "in", "{", "'train'", ",", "'test'", ",", "'all'", "}", ":", "\n", "        ", "raise", "ValueError", "(", "\"subset must be either 'train', 'test', or 'all'; \"", "\n", "\"cannot be {}\"", ".", "format", "(", "subset", ")", ")", "\n", "", "df", "=", "to_dataframe", "(", "fetch_openml", "(", "data_id", "=", "1590", ",", "target_column", "=", "None", ",", "\n", "data_home", "=", "data_home", "or", "DATA_HOME_DEFAULT", ",", "\n", "as_frame", "=", "False", ")", ")", "\n", "if", "subset", "==", "'train'", ":", "\n", "        ", "df", "=", "df", ".", "iloc", "[", "16281", ":", "]", "\n", "", "elif", "subset", "==", "'test'", ":", "\n", "        ", "df", "=", "df", ".", "iloc", "[", ":", "16281", "]", "\n", "\n", "", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'class'", ":", "'annual-income'", "}", ")", "# more descriptive name", "\n", "df", "[", "'annual-income'", "]", "=", "df", "[", "'annual-income'", "]", ".", "cat", ".", "as_ordered", "(", ")", "# '<=50K' < '>50K'", "\n", "\n", "# binarize protected attributes", "\n", "if", "binary_race", ":", "\n", "        ", "df", ".", "race", "=", "df", ".", "race", ".", "cat", ".", "set_categories", "(", "[", "'Non-white'", ",", "'White'", "]", ",", "\n", "ordered", "=", "True", ")", ".", "fillna", "(", "'Non-white'", ")", "\n", "", "df", ".", "sex", "=", "df", ".", "sex", ".", "cat", ".", "as_ordered", "(", ")", "# 'Female' < 'Male'", "\n", "\n", "return", "standardize_dataset", "(", "df", ",", "prot_attr", "=", "[", "'race'", ",", "'sex'", "]", ",", "\n", "target", "=", "'annual-income'", ",", "sample_weight", "=", "'fnlwgt'", ",", "\n", "usecols", "=", "usecols", ",", "dropcols", "=", "dropcols", ",", "\n", "numeric_only", "=", "numeric_only", ",", "dropna", "=", "dropna", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_german": [[104, 187], ["openml_datasets.to_dataframe", "df.join.rename", "df[].cat.as_ordered", "df.join.pop().str.split", "df.join.join", "df.join.sex.cat.as_ordered", "df.join.foreign_worker.astype().cat.as_ordered", "aif360.sklearn.datasets.utils.standardize_dataset", "sklearn.datasets.fetch_openml", "pandas.cut", "df.pop().str.split.astype", "df.join.pop", "df.join.foreign_worker.astype"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.to_dataframe", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.standardize_dataset"], ["", "def", "fetch_german", "(", "data_home", "=", "None", ",", "binary_age", "=", "True", ",", "usecols", "=", "[", "]", ",", "dropcols", "=", "[", "]", ",", "\n", "numeric_only", "=", "False", ",", "dropna", "=", "True", ")", ":", "\n", "    ", "\"\"\"Load the German Credit Dataset.\n\n    Protected attributes are 'sex' ('male' is privileged and 'female' is\n    unprivileged) and 'age' (binarized by default as recommended by\n    [#kamiran09]_: age >= 25 is considered privileged and age < 25 is considered\n    unprivileged; see the binary_age flag to keep this continuous). The outcome\n    variable is 'credit-risk': 'good' (favorable) or 'bad' (unfavorable).\n\n    Note:\n        By default, the data is downloaded from OpenML. See the `credit-g\n        <https://www.openml.org/d/31>`_ page for details.\n\n    Args:\n        data_home (string, optional): Specify another download and cache folder\n            for the datasets. By default all AIF360 datasets are stored in\n            'aif360/sklearn/data/raw' subfolders.\n        binary_age (bool, optional): If ``True``, split protected attribute,\n            'age', into 'aged' (privileged) and 'youth' (unprivileged). The\n            'age' feature remains continuous.\n        usecols (single label or list-like, optional): Column name(s) to keep.\n            All others are dropped.\n        dropcols (single label or list-like, optional): Column name(s) to drop.\n        numeric_only (bool): Drop all non-numeric feature columns.\n        dropna (bool): Drop rows with NAs.\n\n    Returns:\n        namedtuple: Tuple containing X and y for the German dataset accessible\n        by index or name.\n\n    See also:\n        :func:`sklearn.datasets.fetch_openml`\n\n    References:\n        .. [#kamiran09] `F. Kamiran and T. Calders, \"Classifying without\n           discriminating,\" 2nd International Conference on Computer,\n           Control and Communication, 2009.\n           <https://ieeexplore.ieee.org/abstract/document/4909197>`_\n\n    Examples:\n        >>> german = fetch_german()\n        >>> german.X.shape\n        (1000, 21)\n\n        >>> german_num = fetch_german(numeric_only=True)\n        >>> german_num.X.shape\n        (1000, 7)\n\n\n\n        >>> X, y = fetch_german(numeric_only=True)\n        >>> y_pred = LogisticRegression().fit(X, y).predict(X)\n        >>> disparate_impact_ratio(y, y_pred, prot_attr='age', priv_group=True,\n        ... pos_label='good')\n        0.9483094846144106\n    \"\"\"", "\n", "df", "=", "to_dataframe", "(", "fetch_openml", "(", "data_id", "=", "31", ",", "target_column", "=", "None", ",", "\n", "data_home", "=", "data_home", "or", "DATA_HOME_DEFAULT", ",", "\n", "as_frame", "=", "False", ")", ")", "\n", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "{", "'class'", ":", "'credit-risk'", "}", ")", "# more descriptive name", "\n", "df", "[", "'credit-risk'", "]", "=", "df", "[", "'credit-risk'", "]", ".", "cat", ".", "as_ordered", "(", ")", "# 'bad' < 'good'", "\n", "\n", "# binarize protected attribute (but not corresponding feature)", "\n", "age", "=", "(", "pd", ".", "cut", "(", "df", ".", "age", ",", "[", "0", ",", "25", ",", "100", "]", ",", "\n", "labels", "=", "False", "if", "numeric_only", "else", "[", "'young'", ",", "'aged'", "]", ")", "\n", "if", "binary_age", "else", "'age'", ")", "\n", "\n", "# Note: marital_status directly implies sex. i.e. 'div/dep/mar' => 'female'", "\n", "# and all others => 'male'", "\n", "personal_status", "=", "df", ".", "pop", "(", "'personal_status'", ")", ".", "str", ".", "split", "(", "expand", "=", "True", ")", "\n", "personal_status", ".", "columns", "=", "[", "'sex'", ",", "'marital_status'", "]", "\n", "df", "=", "df", ".", "join", "(", "personal_status", ".", "astype", "(", "'category'", ")", ")", "\n", "df", ".", "sex", "=", "df", ".", "sex", ".", "cat", ".", "as_ordered", "(", ")", "# 'female' < 'male'", "\n", "\n", "# 'no' < 'yes'", "\n", "df", ".", "foreign_worker", "=", "df", ".", "foreign_worker", ".", "astype", "(", "'category'", ")", ".", "cat", ".", "as_ordered", "(", ")", "\n", "\n", "return", "standardize_dataset", "(", "df", ",", "prot_attr", "=", "[", "'sex'", ",", "age", ",", "'foreign_worker'", "]", ",", "\n", "target", "=", "'credit-risk'", ",", "usecols", "=", "usecols", ",", "\n", "dropcols", "=", "dropcols", ",", "numeric_only", "=", "numeric_only", ",", "\n", "dropna", "=", "dropna", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_bank": [[188, 250], ["openml_datasets.to_dataframe", "to_dataframe.deposit.map().astype", "to_dataframe.deposit.cat.as_ordered", "to_dataframe.apply", "to_dataframe.education.astype().cat.as_ordered", "aif360.sklearn.datasets.utils.standardize_dataset", "sklearn.datasets.fetch_openml", "to_dataframe.deposit.map", "s.cat.remove_categories", "to_dataframe.education.astype", "hasattr"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.to_dataframe", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.standardize_dataset"], ["", "def", "fetch_bank", "(", "data_home", "=", "None", ",", "percent10", "=", "False", ",", "usecols", "=", "[", "]", ",", "dropcols", "=", "'duration'", ",", "\n", "numeric_only", "=", "False", ",", "dropna", "=", "False", ")", ":", "\n", "    ", "\"\"\"Load the Bank Marketing Dataset.\n\n    The protected attribute is 'age' (left as continuous). The outcome variable\n    is 'deposit': 'yes' or 'no'.\n\n    Note:\n        By default, the data is downloaded from OpenML. See the `bank-marketing\n        <https://www.openml.org/d/1461>`_ page for details.\n\n    Args:\n        data_home (string, optional): Specify another download and cache folder\n            for the datasets. By default all AIF360 datasets are stored in\n            'aif360/sklearn/data/raw' subfolders.\n        percent10 (bool, optional): Download the reduced version (10% of data).\n        usecols (single label or list-like, optional): Column name(s) to keep.\n            All others are dropped.\n        dropcols (single label or list-like, optional): Column name(s) to drop.\n        numeric_only (bool): Drop all non-numeric feature columns.\n        dropna (bool): Drop rows with NAs. Note: this is False by default for\n            this dataset.\n\n    Returns:\n        namedtuple: Tuple containing X and y for the Bank dataset accessible by\n        index or name.\n\n    See also:\n        :func:`sklearn.datasets.fetch_openml`\n\n    Examples:\n        >>> bank = fetch_bank()\n        >>> bank.X.shape\n        (45211, 15)\n\n        >>> bank_nona = fetch_bank(dropna=True)\n        >>> bank_nona.X.shape\n        (7842, 15)\n\n        >>> bank_num = fetch_bank(numeric_only=True)\n        >>> bank_num.X.shape\n        (45211, 6)\n    \"\"\"", "\n", "# TODO: this seems to be an old version", "\n", "df", "=", "to_dataframe", "(", "fetch_openml", "(", "data_id", "=", "1558", "if", "percent10", "else", "1461", ",", "\n", "data_home", "=", "data_home", "or", "DATA_HOME_DEFAULT", ",", "\n", "target_column", "=", "None", ",", "as_frame", "=", "False", ")", ")", "\n", "df", ".", "columns", "=", "[", "'age'", ",", "'job'", ",", "'marital'", ",", "'education'", ",", "'default'", ",", "'balance'", ",", "\n", "'housing'", ",", "'loan'", ",", "'contact'", ",", "'day'", ",", "'month'", ",", "'duration'", ",", "\n", "'campaign'", ",", "'pdays'", ",", "'previous'", ",", "'poutcome'", ",", "'deposit'", "]", "\n", "# remap target", "\n", "df", ".", "deposit", "=", "df", ".", "deposit", ".", "map", "(", "{", "'1'", ":", "'no'", ",", "'2'", ":", "'yes'", "}", ")", ".", "astype", "(", "'category'", ")", "\n", "df", ".", "deposit", "=", "df", ".", "deposit", ".", "cat", ".", "as_ordered", "(", ")", "# 'no' < 'yes'", "\n", "# replace 'unknown' marker with NaN", "\n", "df", ".", "apply", "(", "lambda", "s", ":", "s", ".", "cat", ".", "remove_categories", "(", "'unknown'", ",", "inplace", "=", "True", ")", "\n", "if", "hasattr", "(", "s", ",", "'cat'", ")", "and", "'unknown'", "in", "s", ".", "cat", ".", "categories", "else", "s", ")", "\n", "# 'primary' < 'secondary' < 'tertiary'", "\n", "df", ".", "education", "=", "df", ".", "education", ".", "astype", "(", "'category'", ")", ".", "cat", ".", "as_ordered", "(", ")", "\n", "\n", "return", "standardize_dataset", "(", "df", ",", "prot_attr", "=", "'age'", ",", "target", "=", "'deposit'", ",", "\n", "usecols", "=", "usecols", ",", "dropcols", "=", "dropcols", ",", "\n", "numeric_only", "=", "numeric_only", ",", "dropna", "=", "dropna", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.check_already_dropped": [[12, 47], ["isinstance", "dropped_cols.intersection", "isinstance", "any", "warnings.warn", "pandas.core.dtypes.common.is_list_like", "TypeError", "isinstance", "dropped_cols.intersection.tolist", "isinstance", "type"], "function", ["None"], ["\n", "if", "ensure_2d", "and", "X", ".", "ndim", "!=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Expected X to be 2D, got ndim == {} instead.\"", ".", "format", "(", "\n", "X", ".", "ndim", ")", ")", "\n", "", "if", "not", "isinstance", "(", "y", ",", "pd", ".", "Series", ")", ":", "# don't cast Series -> ndarray", "\n", "        ", "y", "=", "column_or_1d", "(", "y", ")", "\n", "", "if", "sample_weight", "is", "not", "None", ":", "\n", "        ", "sample_weight", "=", "column_or_1d", "(", "sample_weight", ")", "\n", "", "else", ":", "\n", "        ", "sample_weight", "=", "np", ".", "ones", "(", "X", ".", "shape", "[", "0", "]", ")", "\n", "", "check_consistent_length", "(", "X", ",", "y", ",", "sample_weight", ")", "\n", "return", "X", ",", "y", ",", "sample_weight", "\n", "\n", "", "def", "check_groups", "(", "arr", ",", "prot_attr", ",", "ensure_binary", "=", "False", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.standardize_dataset": [[48, 146], ["orig_cols.difference", "utils.check_already_dropped", "df.select_dtypes.set_index", "utils.check_already_dropped", "pandas.concat", "y.squeeze.squeeze", "orig_cols.difference", "utils.check_already_dropped", "utils.check_already_dropped", "df.select_dtypes.drop", "df.select_dtypes.select_dtypes", "df.select_dtypes.select_dtypes", "len", "ValueError", "len", "ValueError", "utils.check_already_dropped", "collections.namedtuple", "df.select_dtypes.notna().all", "y.squeeze.notna", "collections.namedtuple", "df.select_dtypes.pop().rename", "df[].replace", "df.select_dtypes.pop", "t.set_axis", "df[].factorize", "isinstance", "df.select_dtypes.notna", "df.select_dtypes.pop"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.check_already_dropped", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.check_already_dropped", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.check_already_dropped", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.check_already_dropped", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.utils.check_already_dropped"], ["\n", "if", "not", "hasattr", "(", "arr", ",", "'index'", ")", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "\"Expected `Series` or `DataFrame`, got {} instead.\"", ".", "format", "(", "\n", "type", "(", "arr", ")", ".", "__name__", ")", ")", "\n", "\n", "", "all_prot_attrs", "=", "[", "name", "for", "name", "in", "arr", ".", "index", ".", "names", "if", "name", "]", "# not None or ''", "\n", "if", "prot_attr", "is", "None", ":", "\n", "        ", "prot_attr", "=", "all_prot_attrs", "\n", "", "elif", "not", "is_list_like", "(", "prot_attr", ")", ":", "\n", "        ", "prot_attr", "=", "[", "prot_attr", "]", "\n", "\n", "", "if", "any", "(", "p", "not", "in", "arr", ".", "index", ".", "names", "for", "p", "in", "prot_attr", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Some of the attributes provided are not present \"", "\n", "\"in the dataset. Expected a subset of:\\n{}\\nGot:\\n\"", "\n", "\"{}\"", ".", "format", "(", "all_prot_attrs", ",", "prot_attr", ")", ")", "\n", "\n", "", "groups", "=", "arr", ".", "index", ".", "droplevel", "(", "list", "(", "set", "(", "arr", ".", "index", ".", "names", ")", "-", "set", "(", "prot_attr", ")", ")", ")", "\n", "groups", "=", "groups", ".", "to_flat_index", "(", ")", "\n", "\n", "n_unique", "=", "groups", ".", "nunique", "(", ")", "\n", "if", "ensure_binary", "and", "n_unique", "!=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Expected 2 protected attribute groups, got {}\"", ".", "format", "(", "\n", "groups", ".", "unique", "(", ")", "if", "n_unique", ">", "5", "else", "n_unique", ")", ")", "\n", "\n", "", "return", "groups", ",", "prot_attr", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.algorithms.transformer.Transformer.__init__": [[49, 56], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialize a Transformer object.\n\n        Algorithm-specific configuration parameters should be passed here.\n        \"\"\"", "\n", "self", ".", "_params", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.algorithms.transformer.Transformer.fit": [[57, 67], ["None"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Train a model on the input.\n\n        Args:\n            dataset (Dataset): Input dataset.\n\n        Returns:\n            Transformer: Returns self.\n        \"\"\"", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.algorithms.transformer.Transformer.predict": [[68, 80], ["NotImplementedError"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Return a new dataset with labels predicted by running this\n        Transformer on the input.\n\n        Args:\n            dataset (Dataset): Input dataset.\n\n        Returns:\n            Dataset: Output dataset. `metadata` should reflect the details of\n            this transformation.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"'predict' is not supported for this class. \"", "\n", "\"Perhaps you meant 'transform' or 'fit_predict' instead?\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.algorithms.transformer.Transformer.transform": [[82, 97], ["NotImplementedError"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Return a new dataset generated by running this Transformer on the\n        input.\n\n        This function could return different `dataset.features`,\n        `dataset.labels`, or both.\n\n        Args:\n            dataset (Dataset): Input dataset.\n\n        Returns:\n            Dataset: Output dataset. `metadata` should reflect the details of\n            this transformation.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"'transform' is not supported for this class.\"", "\n", "\" Perhaps you meant 'predict' or 'fit_transform' instead?\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.algorithms.transformer.Transformer.fit_predict": [[99, 112], ["transformer.Transformer.fit().predict", "transformer.Transformer.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "fit_predict", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Train a model on the input and predict the labels.\n\n        Equivalent to calling `fit(dataset)` followed by `predict(dataset)`.\n\n        Args:\n            dataset (Dataset): Input dataset.\n\n        Returns:\n            Dataset: Output dataset. `metadata` should reflect the details of\n            this transformation.\n        \"\"\"", "\n", "return", "self", ".", "fit", "(", "dataset", ")", ".", "predict", "(", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.algorithms.transformer.Transformer.fit_transform": [[113, 126], ["transformer.Transformer.fit().transform", "transformer.Transformer.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "fit_transform", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Train a model on the input and transform the dataset accordingly.\n\n        Equivalent to calling `fit(dataset)` followed by `transform(dataset)`.\n\n        Args:\n            dataset (Dataset): Input dataset.\n\n        Returns:\n            Dataset: Output dataset. `metadata` should reflect the details of\n            this transformation.\n        \"\"\"", "\n", "return", "self", ".", "fit", "(", "dataset", ")", ".", "transform", "(", "dataset", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.algorithms.transformer.addmetadata": [[12, 37], ["functools.wraps", "func", "isinstance", "func.metadata.copy", "func.metadata.update", "type", "isinstance"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "addmetadata", "(", "func", ")", ":", "\n", "    ", "\"\"\"Decorator for instance methods which perform a transformation and return\n    a new dataset.\n\n    Automatically populates the `metadata` field of the new dataset to reflect\n    details of the transformation that occurred, e.g.::\n\n        {\n            'transformer': 'TransformerClass.function_name',\n            'params': kwargs_from_init,\n            'previous': [all_datasets_used_by_func]\n        }\n    \"\"\"", "\n", "@", "wraps", "(", "func", ")", "\n", "def", "wrapper", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "new_dataset", "=", "func", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "if", "isinstance", "(", "new_dataset", ",", "Dataset", ")", ":", "\n", "            ", "new_dataset", ".", "metadata", "=", "new_dataset", ".", "metadata", ".", "copy", "(", ")", "\n", "new_dataset", ".", "metadata", ".", "update", "(", "{", "\n", "'transformer'", ":", "'{}.{}'", ".", "format", "(", "type", "(", "self", ")", ".", "__name__", ",", "func", ".", "__name__", ")", ",", "\n", "'params'", ":", "self", ".", "_params", ",", "\n", "'previous'", ":", "[", "a", "for", "a", "in", "args", "if", "isinstance", "(", "a", ",", "Dataset", ")", "]", "\n", "}", ")", "\n", "", "return", "new_dataset", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.lfr.LFR.__init__": [[19, 68], ["aif360.algorithms.Transformer.__init__", "ValueError", "list", "len", "len", "lfr.LFR.unprivileged_groups[].keys"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "unprivileged_groups", ",", "\n", "privileged_groups", ",", "\n", "k", "=", "5", ",", "\n", "Ax", "=", "0.01", ",", "\n", "Ay", "=", "1.0", ",", "\n", "Az", "=", "50.0", ",", "\n", "print_interval", "=", "250", ",", "\n", "verbose", "=", "0", ",", "\n", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            unprivileged_groups (tuple): Representation for unprivileged group.\n            privileged_groups (tuple): Representation for privileged group.\n            k (int, optional): Number of prototypes.\n            Ax (float, optional): Input recontruction quality term weight.\n            Az (float, optional): Fairness constraint term weight.\n            Ay (float, optional): Output prediction error.\n            print_interval (int, optional): Print optimization objective value\n                every print_interval iterations.\n            verbose (int, optional): If zero, then no output.\n            seed (int, optional): Seed to make `predict` repeatable.\n        \"\"\"", "\n", "\n", "super", "(", "LFR", ",", "self", ")", ".", "__init__", "(", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ")", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "\n", "self", ".", "unprivileged_groups", "=", "unprivileged_groups", "\n", "self", ".", "privileged_groups", "=", "privileged_groups", "\n", "if", "len", "(", "self", ".", "unprivileged_groups", ")", ">", "1", "or", "len", "(", "self", ".", "privileged_groups", ")", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only one unprivileged_group or privileged_group supported.\"", ")", "\n", "", "self", ".", "protected_attribute_name", "=", "list", "(", "self", ".", "unprivileged_groups", "[", "0", "]", ".", "keys", "(", ")", ")", "[", "0", "]", "\n", "self", ".", "unprivileged_group_protected_attribute_value", "=", "self", ".", "unprivileged_groups", "[", "0", "]", "[", "self", ".", "protected_attribute_name", "]", "\n", "self", ".", "privileged_group_protected_attribute_value", "=", "self", ".", "privileged_groups", "[", "0", "]", "[", "self", ".", "protected_attribute_name", "]", "\n", "\n", "self", ".", "k", "=", "k", "\n", "self", ".", "Ax", "=", "Ax", "\n", "self", ".", "Ay", "=", "Ay", "\n", "self", ".", "Az", "=", "Az", "\n", "\n", "self", ".", "print_interval", "=", "print_interval", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "w", "=", "None", "\n", "self", ".", "prototypes", "=", "None", "\n", "self", ".", "learned_model", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.lfr.LFR.fit": [[69, 108], ["numpy.shape", "numpy.reshape", "[].flatten", "[].flatten", "numpy.random.uniform", "lfr.LFR.learned_model[].reshape", "numpy.random.seed", "scipy.fmin_l_bfgs_b", "numpy.array", "numpy.array", "dataset.protected_attribute_names.index", "numpy.where", "numpy.where"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "dataset", ",", "maxiter", "=", "5000", ",", "maxfun", "=", "5000", ")", ":", "\n", "        ", "\"\"\"Compute the transformation parameters that leads to fair representations.\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing true labels.\n            maxiter (int): Maximum number of iterations.\n            maxfun (int): Maxinum number of function evaluations.\n        Returns:\n            LFR: Returns self.\n        \"\"\"", "\n", "if", "self", ".", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "\n", "", "num_train_samples", ",", "self", ".", "features_dim", "=", "np", ".", "shape", "(", "dataset", ".", "features", ")", "\n", "\n", "protected_attributes", "=", "np", ".", "reshape", "(", "\n", "dataset", ".", "protected_attributes", "[", ":", ",", "dataset", ".", "protected_attribute_names", ".", "index", "(", "self", ".", "protected_attribute_name", ")", "]", ",", "\n", "[", "-", "1", ",", "1", "]", ")", "\n", "unprivileged_sample_ids", "=", "np", ".", "array", "(", "np", ".", "where", "(", "protected_attributes", "==", "self", ".", "unprivileged_group_protected_attribute_value", ")", ")", "[", "0", "]", ".", "flatten", "(", ")", "\n", "privileged_sample_ids", "=", "np", ".", "array", "(", "np", ".", "where", "(", "protected_attributes", "==", "self", ".", "privileged_group_protected_attribute_value", ")", ")", "[", "0", "]", ".", "flatten", "(", ")", "\n", "features_unprivileged", "=", "dataset", ".", "features", "[", "unprivileged_sample_ids", "]", "\n", "features_privileged", "=", "dataset", ".", "features", "[", "privileged_sample_ids", "]", "\n", "labels_unprivileged", "=", "dataset", ".", "labels", "[", "unprivileged_sample_ids", "]", "\n", "labels_privileged", "=", "dataset", ".", "labels", "[", "privileged_sample_ids", "]", "\n", "\n", "# Initialize the LFR optim objective parameters", "\n", "parameters_initialization", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "self", ".", "k", "+", "self", ".", "features_dim", "*", "self", ".", "k", ")", "\n", "bnd", "=", "[", "(", "0", ",", "1", ")", "]", "*", "self", ".", "k", "+", "[", "(", "None", ",", "None", ")", "]", "*", "self", ".", "features_dim", "*", "self", ".", "k", "\n", "lfr_helpers", ".", "LFR_optim_objective", ".", "steps", "=", "0", "\n", "\n", "self", ".", "learned_model", "=", "optim", ".", "fmin_l_bfgs_b", "(", "lfr_helpers", ".", "LFR_optim_objective", ",", "x0", "=", "parameters_initialization", ",", "epsilon", "=", "1e-5", ",", "\n", "args", "=", "(", "features_unprivileged", ",", "features_privileged", ",", "\n", "labels_unprivileged", "[", ":", ",", "0", "]", ",", "labels_privileged", "[", ":", ",", "0", "]", ",", "self", ".", "k", ",", "self", ".", "Ax", ",", "\n", "self", ".", "Ay", ",", "self", ".", "Az", ",", "self", ".", "print_interval", ",", "self", ".", "verbose", ")", ",", "\n", "bounds", "=", "bnd", ",", "approx_grad", "=", "True", ",", "maxfun", "=", "maxfun", ",", "\n", "maxiter", "=", "maxiter", ",", "disp", "=", "self", ".", "verbose", ")", "[", "0", "]", "\n", "self", ".", "w", "=", "self", ".", "learned_model", "[", ":", "self", ".", "k", "]", "\n", "self", ".", "prototypes", "=", "self", ".", "learned_model", "[", "self", ".", "k", ":", "]", ".", "reshape", "(", "(", "self", ".", "k", ",", "self", ".", "features_dim", ")", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.lfr.LFR.transform": [[109, 149], ["numpy.reshape", "[].flatten", "[].flatten", "aif360.algorithms.preprocessing.lfr_helpers.helpers.get_xhat_y_hat", "aif360.algorithms.preprocessing.lfr_helpers.helpers.get_xhat_y_hat", "numpy.zeros", "numpy.zeros", "numpy.reshape", "numpy.reshape", "dataset.copy", "numpy.array", "numpy.random.seed", "numpy.shape", "numpy.shape", "numpy.array", "numpy.array", "numpy.array", "dataset.protected_attribute_names.index", "numpy.where", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lfr_helpers.helpers.get_xhat_y_hat", "home.repos.pwc.inspect_result.IBM_AIF360.lfr_helpers.helpers.get_xhat_y_hat", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "transform", "(", "self", ",", "dataset", ",", "threshold", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"Transform the dataset using learned model parameters.\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing labels that needs to be transformed.\n            threshold(float, optional): threshold parameter used for binary label prediction.\n        Returns:\n            dataset (BinaryLabelDataset): Transformed Dataset.\n        \"\"\"", "\n", "if", "self", ".", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "\n", "", "protected_attributes", "=", "np", ".", "reshape", "(", "\n", "dataset", ".", "protected_attributes", "[", ":", ",", "dataset", ".", "protected_attribute_names", ".", "index", "(", "self", ".", "protected_attribute_name", ")", "]", ",", "\n", "[", "-", "1", ",", "1", "]", ")", "\n", "unprivileged_sample_ids", "=", "np", ".", "array", "(", "np", ".", "where", "(", "protected_attributes", "==", "self", ".", "unprivileged_group_protected_attribute_value", ")", ")", "[", "0", "]", ".", "flatten", "(", ")", "\n", "privileged_sample_ids", "=", "np", ".", "array", "(", "np", ".", "where", "(", "protected_attributes", "==", "self", ".", "privileged_group_protected_attribute_value", ")", ")", "[", "0", "]", ".", "flatten", "(", ")", "\n", "features_unprivileged", "=", "dataset", ".", "features", "[", "unprivileged_sample_ids", "]", "\n", "features_privileged", "=", "dataset", ".", "features", "[", "privileged_sample_ids", "]", "\n", "\n", "_", ",", "features_hat_unprivileged", ",", "labels_hat_unprivileged", "=", "lfr_helpers", ".", "get_xhat_y_hat", "(", "self", ".", "prototypes", ",", "self", ".", "w", ",", "features_unprivileged", ")", "\n", "\n", "_", ",", "features_hat_privileged", ",", "labels_hat_privileged", "=", "lfr_helpers", ".", "get_xhat_y_hat", "(", "self", ".", "prototypes", ",", "self", ".", "w", ",", "features_privileged", ")", "\n", "\n", "transformed_features", "=", "np", ".", "zeros", "(", "shape", "=", "np", ".", "shape", "(", "dataset", ".", "features", ")", ")", "\n", "transformed_labels", "=", "np", ".", "zeros", "(", "shape", "=", "np", ".", "shape", "(", "dataset", ".", "labels", ")", ")", "\n", "transformed_features", "[", "unprivileged_sample_ids", "]", "=", "features_hat_unprivileged", "\n", "transformed_features", "[", "privileged_sample_ids", "]", "=", "features_hat_privileged", "\n", "transformed_labels", "[", "unprivileged_sample_ids", "]", "=", "np", ".", "reshape", "(", "labels_hat_unprivileged", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "transformed_labels", "[", "privileged_sample_ids", "]", "=", "np", ".", "reshape", "(", "labels_hat_privileged", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "transformed_bin_labels", "=", "(", "np", ".", "array", "(", "transformed_labels", ")", ">", "threshold", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "\n", "# Mutated, fairer dataset with new labels", "\n", "dataset_new", "=", "dataset", ".", "copy", "(", "deepcopy", "=", "True", ")", "\n", "dataset_new", ".", "features", "=", "transformed_features", "\n", "dataset_new", ".", "labels", "=", "transformed_bin_labels", "\n", "dataset_new", ".", "scores", "=", "np", ".", "array", "(", "transformed_labels", ")", "\n", "\n", "return", "dataset_new", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.lfr.LFR.fit_transform": [[150, 163], ["lfr.LFR.fit().transform", "lfr.LFR.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "fit_transform", "(", "self", ",", "dataset", ",", "maxiter", "=", "5000", ",", "maxfun", "=", "5000", ",", "threshold", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"Fit and transform methods sequentially.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing labels that needs to be transformed.\n            maxiter (int): Maximum number of iterations.\n            maxfun (int): Maxinum number of function evaluations.\n            threshold(float, optional): threshold parameter used for binary label prediction.\n        Returns:\n            dataset (BinaryLabelDataset): Transformed Dataset.\n        \"\"\"", "\n", "\n", "return", "self", ".", "fit", "(", "dataset", ",", "maxiter", "=", "maxiter", ",", "maxfun", "=", "maxfun", ")", ".", "transform", "(", "dataset", ",", "threshold", "=", "threshold", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.disparate_impact_remover.DisparateImpactRemover.__init__": [[18, 37], ["aif360.algorithms.Transformer.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "repair_level", "=", "1.0", ",", "sensitive_attribute", "=", "''", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            repair_level (float): Repair amount. 0.0 is no repair while 1.0 is\n                full repair.\n            sensitive_attribute (str): Single protected attribute with which to\n                do repair.\n        \"\"\"", "\n", "super", "(", "DisparateImpactRemover", ",", "self", ")", ".", "__init__", "(", "repair_level", "=", "repair_level", ")", "\n", "# avoid importing early since this package can throw warnings in some", "\n", "# jupyter notebooks", "\n", "from", "BlackBoxAuditing", ".", "repairers", ".", "GeneralRepairer", "import", "Repairer", "\n", "self", ".", "Repairer", "=", "Repairer", "\n", "\n", "if", "not", "0.0", "<=", "repair_level", "<=", "1.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"'repair_level' must be between 0.0 and 1.0.\"", ")", "\n", "", "self", ".", "repair_level", "=", "repair_level", "\n", "\n", "self", ".", "sensitive_attribute", "=", "sensitive_attribute", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.disparate_impact_remover.DisparateImpactRemover.fit_transform": [[38, 66], ["dataset.features.tolist", "dataset.feature_names.index", "disparate_impact_remover.DisparateImpactRemover.Repairer", "dataset.copy", "disparate_impact_remover.DisparateImpactRemover.repair", "numpy.array", "dataset.copy.protected_attribute_names.index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "fit_transform", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Run a repairer on the non-protected features and return the\n        transformed dataset.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset that needs repair.\n        Returns:\n            dataset (BinaryLabelDataset): Transformed Dataset.\n\n        Note:\n            In order to transform test data in the same manner as training data,\n            the distributions of attributes conditioned on the protected\n            attribute must be the same.\n        \"\"\"", "\n", "if", "not", "self", ".", "sensitive_attribute", ":", "\n", "            ", "self", ".", "sensitive_attribute", "=", "dataset", ".", "protected_attribute_names", "[", "0", "]", "\n", "\n", "", "features", "=", "dataset", ".", "features", ".", "tolist", "(", ")", "\n", "index", "=", "dataset", ".", "feature_names", ".", "index", "(", "self", ".", "sensitive_attribute", ")", "\n", "repairer", "=", "self", ".", "Repairer", "(", "features", ",", "index", ",", "self", ".", "repair_level", ",", "False", ")", "\n", "\n", "repaired", "=", "dataset", ".", "copy", "(", ")", "\n", "repaired_features", "=", "repairer", ".", "repair", "(", "features", ")", "\n", "repaired", ".", "features", "=", "np", ".", "array", "(", "repaired_features", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "# protected attribute shouldn't change", "\n", "repaired", ".", "features", "[", ":", ",", "index", "]", "=", "repaired", ".", "protected_attributes", "[", ":", ",", "repaired", ".", "protected_attribute_names", ".", "index", "(", "self", ".", "sensitive_attribute", ")", "]", "\n", "\n", "return", "repaired", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.optim_preproc.OptimPreproc.__init__": [[36, 69], ["aif360.algorithms.Transformer.__init__", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "optimizer", ",", "optim_options", ",", "unprivileged_groups", "=", "None", ",", "\n", "privileged_groups", "=", "None", ",", "verbose", "=", "False", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            optimizer (class): Optimizer class.\n            optim_options (dict): Options for optimization to estimate the\n                transformation.\n            unprivileged_groups (dict): Representation for unprivileged group.\n            privileged_groups (dict): Representation for privileged group.\n            verbose (bool, optional): Verbosity flag for optimization.\n            seed (int, optional): Seed to make `fit` and `predict` repeatable.\n\n        Note:\n            This algorithm does not use the privileged and unprivileged groups\n            that are specified during initialization yet. Instead, it\n            automatically attempts to reduce statistical parity difference\n            between all possible combinations of groups in the dataset.\n        \"\"\"", "\n", "\n", "super", "(", "OptimPreproc", ",", "self", ")", ".", "__init__", "(", "optimizer", "=", "optimizer", ",", "\n", "optim_options", "=", "optim_options", ",", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ",", "verbose", "=", "verbose", ",", "seed", "=", "seed", ")", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "optim_options", "=", "optim_options", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "unprivileged_groups", "=", "unprivileged_groups", "\n", "self", ".", "privileged_groups", "=", "privileged_groups", "\n", "if", "unprivileged_groups", "or", "privileged_groups", ":", "\n", "            ", "warn", "(", "\"Privileged and unprivileged groups specified will not be \"", "\n", "\"used. The protected attributes are directly specified in the \"", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.optim_preproc.OptimPreproc.fit": [[74, 127], ["dataset.convert_to_dataframe", "optim_preproc.OptimPreproc.optimizer", "optim_preproc.OptimPreproc.OpT.set_features", "optim_preproc.OptimPreproc.OpT.set_distortion", "optim_preproc.OptimPreproc.OpT.optimize", "optim_preproc.OptimPreproc.OpT.compute_marginals", "len", "warnings.warn", "numpy.unique", "df.columns.tolist"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.convert_to_dataframe", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.set_features", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.set_distortion", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.optimize", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.compute_marginals"], ["", "", "def", "fit", "(", "self", ",", "dataset", ",", "sep", "=", "'='", ")", ":", "\n", "        ", "\"\"\"Compute optimal pre-processing transformation based on distortion\n        constraint.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing true labels.\n            sep (str, optional): Separator for converting one-hot labels to\n                categorical.\n        Returns:\n            OptimPreproc: Returns self.\n        \"\"\"", "\n", "if", "len", "(", "np", ".", "unique", "(", "dataset", ".", "instance_weights", ")", ")", ">", "1", ":", "\n", "            ", "warn", "(", "\"Optimized pre-processing will ignore instance_weights in \"", "\n", "\"the dataset during fit.\"", ")", "\n", "# Convert the dataset to a dataframe and preprocess", "\n", "", "df", ",", "_", "=", "dataset", ".", "convert_to_dataframe", "(", "de_dummy_code", "=", "True", ",", "sep", "=", "sep", ",", "\n", "set_category", "=", "True", ")", "\n", "\n", "# Subset the protected attribute names and attribute values from", "\n", "# input parameters", "\n", "self", ".", "protected_attribute_names", "=", "dataset", ".", "protected_attribute_names", "\n", "self", ".", "privileged_protected_attributes", "=", "dataset", ".", "privileged_protected_attributes", "\n", "self", ".", "unprivileged_protected_attributes", "=", "dataset", ".", "unprivileged_protected_attributes", "\n", "\n", "# Feature names", "\n", "self", ".", "Y_feature_names", "=", "dataset", ".", "label_names", "\n", "self", ".", "X_feature_names", "=", "[", "n", "for", "n", "in", "df", ".", "columns", ".", "tolist", "(", ")", "\n", "if", "n", "not", "in", "self", ".", "Y_feature_names", "\n", "and", "n", "not", "in", "self", ".", "protected_attribute_names", "]", "\n", "self", ".", "feature_names", "=", "(", "self", ".", "X_feature_names", "+", "self", ".", "Y_feature_names", "\n", "+", "self", ".", "protected_attribute_names", ")", "\n", "\n", "# initialize a new OptTools object", "\n", "self", ".", "OpT", "=", "self", ".", "optimizer", "(", "df", "=", "df", ",", "features", "=", "self", ".", "feature_names", ")", "\n", "\n", "# Set features", "\n", "self", ".", "OpT", ".", "set_features", "(", "D", "=", "self", ".", "protected_attribute_names", ",", "\n", "X", "=", "self", ".", "X_feature_names", ",", "\n", "Y", "=", "self", ".", "Y_feature_names", ")", "\n", "\n", "# Set Distortion", "\n", "self", ".", "OpT", ".", "set_distortion", "(", "self", ".", "optim_options", "[", "'distortion_fun'", "]", ",", "\n", "clist", "=", "self", ".", "optim_options", "[", "'clist'", "]", ")", "\n", "\n", "# solve optimization for previous parameters", "\n", "self", ".", "OpT", ".", "optimize", "(", "epsilon", "=", "self", ".", "optim_options", "[", "'epsilon'", "]", ",", "\n", "dlist", "=", "self", ".", "optim_options", "[", "'dlist'", "]", ",", "\n", "verbose", "=", "self", ".", "verbose", ")", "\n", "\n", "# Compute marginals", "\n", "self", ".", "OpT", ".", "compute_marginals", "(", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.optim_preproc.OptimPreproc.transform": [[128, 218], ["dataset.convert_to_dataframe", "enumerate", "enumerate", "pandas.concat", "aif360.datasets.BinaryLabelDataset", "len", "warnings.warn", "ValueError", "ValueError", "optim_preproc.OptimPreproc.OpT.dfP.applymap", "dfP_withY.divide.divide.divide", "optim_preproc._apply_randomized_mapping", "optim_preproc.OptimPreproc.OpT.dfFull.reset_index().groupby().sum", "optim_preproc.OptimPreproc.transpose().reset_index().groupby().sum", "optim_preproc.OptimPreproc.transpose().reset_index().groupby().sum.transpose", "dfP_noY.divide.divide.drop", "dfP_noY.divide.divide.applymap", "dfP_noY.divide.divide.divide", "optim_preproc._apply_randomized_mapping", "dict", "df_transformed[].replace", "dict", "df_transformed[].replace", "numpy.unique", "df.columns.tolist", "dfP_withY.divide.divide.sum", "dfP_noY.divide.divide.sum", "dfP_noY.divide.divide.sum", "zip", "zip", "pandas.get_dummies", "optim_preproc.OptimPreproc.OpT.dfFull.reset_index().groupby", "optim_preproc.OptimPreproc.transpose().reset_index().groupby", "pmap.values", "pmap.keys", "pmap.values", "pmap.keys", "optim_preproc.OptimPreproc.OpT.dfFull.reset_index", "optim_preproc.OptimPreproc.transpose().reset_index", "optim_preproc.OptimPreproc.transpose"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.convert_to_dataframe", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.optim_preproc._apply_randomized_mapping", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.optim_preproc._apply_randomized_mapping"], ["", "def", "transform", "(", "self", ",", "dataset", ",", "sep", "=", "'='", ",", "transform_Y", "=", "True", ")", ":", "\n", "        ", "\"\"\"Transform the dataset to a new dataset based on the estimated\n        transformation.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing labels that needs\n                to be transformed.\n            transform_Y (bool): Flag that mandates transformation of Y (labels).\n        \"\"\"", "\n", "\n", "if", "len", "(", "np", ".", "unique", "(", "dataset", ".", "instance_weights", ")", ")", ">", "1", ":", "\n", "            ", "warn", "(", "\"Optimized pre-processing will ignore instance_weights in \"", "\n", "\"the dataset during predict. The transformed dataset will \"", "\n", "\"have all instance weights set to 1.\"", ")", "\n", "\n", "# Convert the dataset to a dataframe and preprocess", "\n", "", "df", ",", "_", "=", "dataset", ".", "convert_to_dataframe", "(", "de_dummy_code", "=", "True", ",", "sep", "=", "sep", ",", "\n", "set_category", "=", "True", ")", "\n", "\n", "# Feature names", "\n", "Y_feature_names", "=", "dataset", ".", "label_names", "\n", "D_feature_names", "=", "self", ".", "protected_attribute_names", "\n", "X_feature_names", "=", "[", "n", "for", "n", "in", "df", ".", "columns", ".", "tolist", "(", ")", "\n", "if", "n", "not", "in", "self", ".", "Y_feature_names", "\n", "and", "n", "not", "in", "self", ".", "protected_attribute_names", "]", "\n", "\n", "if", "(", "X_feature_names", "!=", "self", ".", "X_feature_names", "or", "\n", "D_feature_names", "!=", "self", ".", "protected_attribute_names", ")", ":", "\n", "\n", "           ", "raise", "ValueError", "(", "\"The feature names of inputs and protected \"", "\n", "\"attributes must match with the training dataset.\"", ")", "\n", "\n", "", "if", "transform_Y", "and", "(", "Y_feature_names", "!=", "self", ".", "Y_feature_names", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"The label names must match with that in the training dataset\"", ")", "\n", "\n", "", "if", "transform_Y", ":", "\n", "# randomized mapping when Y is requested to be transformed", "\n", "            ", "dfP_withY", "=", "self", ".", "OpT", ".", "dfP", ".", "applymap", "(", "lambda", "x", ":", "0", "if", "x", "<", "1e-8", "else", "x", ")", "\n", "dfP_withY", "=", "dfP_withY", ".", "divide", "(", "dfP_withY", ".", "sum", "(", "axis", "=", "1", ")", ",", "axis", "=", "0", ")", "\n", "\n", "df_transformed", "=", "_apply_randomized_mapping", "(", "df", ",", "dfP_withY", ",", "\n", "features", "=", "D_feature_names", "+", "X_feature_names", "+", "Y_feature_names", ",", "\n", "random_seed", "=", "self", ".", "seed", ")", "\n", "", "else", ":", "\n", "# randomized mapping when Y is not requested to be transformed", "\n", "            ", "d1", "=", "self", ".", "OpT", ".", "dfFull", ".", "reset_index", "(", ")", ".", "groupby", "(", "\n", "D_feature_names", "+", "X_feature_names", ")", ".", "sum", "(", ")", "\n", "d2", "=", "d1", ".", "transpose", "(", ")", ".", "reset_index", "(", ")", ".", "groupby", "(", "X_feature_names", ")", ".", "sum", "(", ")", "\n", "dfP_noY", "=", "d2", ".", "transpose", "(", ")", "\n", "dfP_noY", "=", "dfP_noY", ".", "drop", "(", "Y_feature_names", ",", "1", ")", "\n", "dfP_noY", "=", "dfP_noY", ".", "applymap", "(", "lambda", "x", ":", "x", "if", "x", ">", "1e-8", "else", "0", ")", "\n", "dfP_noY", "=", "dfP_noY", "/", "dfP_noY", ".", "sum", "(", ")", "\n", "\n", "dfP_noY", "=", "dfP_noY", ".", "divide", "(", "dfP_noY", ".", "sum", "(", "axis", "=", "1", ")", ",", "axis", "=", "0", ")", "\n", "\n", "df_transformed", "=", "_apply_randomized_mapping", "(", "\n", "df", ",", "dfP_noY", ",", "\n", "features", "=", "D_feature_names", "+", "X_feature_names", ",", "\n", "random_seed", "=", "self", ".", "seed", ")", "\n", "\n", "# Map the protected attributes to numeric values", "\n", "", "for", "idx", ",", "p", "in", "enumerate", "(", "self", ".", "protected_attribute_names", ")", ":", "\n", "            ", "pmap", "=", "dataset", ".", "metadata", "[", "\"protected_attribute_maps\"", "]", "[", "idx", "]", "\n", "pmap_rev", "=", "dict", "(", "zip", "(", "pmap", ".", "values", "(", ")", ",", "pmap", ".", "keys", "(", ")", ")", ")", "\n", "df_transformed", "[", "p", "]", "=", "df_transformed", "[", "p", "]", ".", "replace", "(", "pmap_rev", ")", "\n", "\n", "# Map the labels to numeric values", "\n", "", "for", "idx", ",", "p", "in", "enumerate", "(", "Y_feature_names", ")", ":", "\n", "            ", "pmap", "=", "dataset", ".", "metadata", "[", "\"label_maps\"", "]", "[", "idx", "]", "\n", "pmap_rev", "=", "dict", "(", "zip", "(", "pmap", ".", "values", "(", ")", ",", "pmap", ".", "keys", "(", ")", ")", ")", "\n", "df_transformed", "[", "p", "]", "=", "df_transformed", "[", "p", "]", ".", "replace", "(", "pmap_rev", ")", "\n", "\n", "# Dummy code and convert to a dataset", "\n", "", "df_dum", "=", "pd", ".", "concat", "(", "[", "pd", ".", "get_dummies", "(", "df_transformed", ".", "loc", "[", ":", ",", "X_feature_names", "]", ",", "\n", "prefix_sep", "=", "\"=\"", ")", ",", "\n", "df_transformed", ".", "loc", "[", ":", ",", "Y_feature_names", "+", "D_feature_names", "]", "]", ",", "\n", "axis", "=", "1", ")", "\n", "\n", "# Create a dataset out of df_dum", "\n", "dataset_transformed", "=", "BinaryLabelDataset", "(", "\n", "df", "=", "df_dum", ",", "\n", "label_names", "=", "Y_feature_names", ",", "\n", "protected_attribute_names", "=", "self", ".", "protected_attribute_names", ",", "\n", "privileged_protected_attributes", "=", "self", ".", "privileged_protected_attributes", ",", "\n", "unprivileged_protected_attributes", "=", "self", ".", "unprivileged_protected_attributes", ",", "\n", "favorable_label", "=", "dataset", ".", "favorable_label", ",", "\n", "unfavorable_label", "=", "dataset", ".", "unfavorable_label", ",", "\n", "metadata", "=", "dataset", ".", "metadata", ")", "\n", "\n", "return", "dataset_transformed", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.optim_preproc.OptimPreproc.fit_transform": [[219, 224], ["optim_preproc.OptimPreproc.fit().transform", "optim_preproc.OptimPreproc.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "fit_transform", "(", "self", ",", "dataset", ",", "sep", "=", "'='", ",", "transform_Y", "=", "True", ")", ":", "\n", "        ", "\"\"\"Perfom :meth:`fit` and :meth:`transform` sequentially.\"\"\"", "\n", "\n", "return", "self", ".", "fit", "(", "dataset", ",", "sep", "=", "sep", ")", ".", "transform", "(", "dataset", ",", "sep", "=", "sep", ",", "\n", "transform_Y", "=", "transform_Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.optim_preproc._apply_randomized_mapping": [[228, 267], ["df[].copy", "draw_probs.columns.tolist", "numpy.random.seed", "df[].copy", "tuple", "numpy.random.choice", "optim_preproc._apply_randomized_mapping.draw_ind"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "", "def", "_apply_randomized_mapping", "(", "df", ",", "dfMap", ",", "\n", "features", "=", "[", "]", ",", "random_seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply Randomized mapping to create a new dataframe\n\n    Args:\n        df (DataFrame): Input dataframe\n        dfMap (DataFrame): Mapping parameters\n        features (list): Feature names for which the mapping needs to be applied\n        random_seed (int): Random seed\n\n    Returns:\n        Perturbed version of df according to the randomizedmapping\n    \"\"\"", "\n", "\n", "if", "random_seed", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "seed", "=", "random_seed", ")", "\n", "\n", "", "df2", "=", "df", "[", "features", "]", ".", "copy", "(", ")", "\n", "rem_cols", "=", "[", "l", "for", "l", "in", "df", ".", "columns", "\n", "if", "l", "not", "in", "features", "]", "\n", "if", "rem_cols", "!=", "[", "]", ":", "\n", "        ", "df3", "=", "df", "[", "rem_cols", "]", ".", "copy", "(", ")", "\n", "\n", "", "idx_list", "=", "[", "tuple", "(", "i", ")", "for", "i", "in", "df2", ".", "itertuples", "(", "index", "=", "False", ")", "]", "\n", "\n", "draw_probs", "=", "dfMap", ".", "loc", "[", "idx_list", "]", "\n", "draws_possible", "=", "draw_probs", ".", "columns", ".", "tolist", "(", ")", "\n", "\n", "# Make random draws - as part of randomizing transformation", "\n", "def", "draw_ind", "(", "x", ")", ":", "return", "np", ".", "random", ".", "choice", "(", "range", "(", "len", "(", "draws_possible", ")", ")", ",", "p", "=", "x", ")", "\n", "\n", "draw_inds", "=", "[", "draw_ind", "(", "x", ")", "for", "x", "in", "draw_probs", ".", "values", "]", "\n", "\n", "df2", ".", "loc", "[", ":", ",", "dfMap", ".", "columns", ".", "names", "]", "=", "[", "draws_possible", "[", "x", "]", "for", "x", "in", "draw_inds", "]", "\n", "\n", "if", "rem_cols", "!=", "[", "]", ":", "\n", "        ", "return", "pd", ".", "concat", "(", "[", "df2", ",", "df3", "]", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "        ", "return", "df2", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.Reweighing.__init__": [[42, 52], ["None"], "methods", ["None"], ["\n", "\n", "(", "priv_cond", ",", "unpriv_cond", ",", "fav_cond", ",", "unfav_cond", ",", "\n", "cond_p_fav", ",", "cond_p_unfav", ",", "cond_up_fav", ",", "cond_up_unfav", ")", "=", "self", ".", "_obtain_conditionings", "(", "dataset", ")", "\n", "\n", "n", "=", "np", ".", "sum", "(", "dataset", ".", "instance_weights", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "n_p", "=", "np", ".", "sum", "(", "dataset", ".", "instance_weights", "[", "priv_cond", "]", ",", "dtype", "=", "np", ".", "float64", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.Reweighing.fit": [[53, 57], ["reweighing.Reweighing.fit_transform"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform"], ["n_up", "=", "np", ".", "sum", "(", "dataset", ".", "instance_weights", "[", "unpriv_cond", "]", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "n_fav", "=", "np", ".", "sum", "(", "dataset", ".", "instance_weights", "[", "fav_cond", "]", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "n_unfav", "=", "np", ".", "sum", "(", "dataset", ".", "instance_weights", "[", "unfav_cond", "]", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "n_p_fav", "=", "np", ".", "sum", "(", "dataset", ".", "instance_weights", "[", "cond_p_fav", "]", ",", "dtype", "=", "np", ".", "float64", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.Reweighing.transform": [[73, 96], ["dataset.copy", "reweighing.Reweighing._obtain_conditionings"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.Reweighing._obtain_conditionings"], ["", "def", "transform", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Transform the dataset to a new dataset based on the estimated\n        transformation.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset that needs to be transformed.\n        Returns:\n            dataset (BinaryLabelDataset): Dataset with transformed\n                instance_weights attribute.\n        \"\"\"", "\n", "\n", "dataset_transformed", "=", "dataset", ".", "copy", "(", "deepcopy", "=", "True", ")", "\n", "\n", "(", "_", ",", "_", ",", "_", ",", "_", ",", "cond_p_fav", ",", "cond_p_unfav", ",", "cond_up_fav", ",", "cond_up_unfav", ")", "=", "self", ".", "_obtain_conditionings", "(", "dataset", ")", "\n", "\n", "# apply reweighing", "\n", "dataset_transformed", ".", "instance_weights", "[", "cond_p_fav", "]", "*=", "self", ".", "w_p_fav", "\n", "dataset_transformed", ".", "instance_weights", "[", "cond_p_unfav", "]", "*=", "self", ".", "w_p_unfav", "\n", "dataset_transformed", ".", "instance_weights", "[", "cond_up_fav", "]", "*=", "self", ".", "w_up_fav", "\n", "dataset_transformed", ".", "instance_weights", "[", "cond_up_unfav", "]", "*=", "self", ".", "w_up_unfav", "\n", "\n", "return", "dataset_transformed", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.Reweighing._obtain_conditionings": [[100, 124], ["aif360.metrics.utils.compute_boolean_conditioning_vector", "aif360.metrics.utils.compute_boolean_conditioning_vector", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "dataset.labels.ravel", "dataset.labels.ravel"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector"], ["", "def", "_obtain_conditionings", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Obtain the necessary conditioning boolean vectors to compute\n        instance level weights.\n        \"\"\"", "\n", "# conditioning", "\n", "priv_cond", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "\n", "condition", "=", "self", ".", "privileged_groups", ")", "\n", "unpriv_cond", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "\n", "condition", "=", "self", ".", "unprivileged_groups", ")", "\n", "fav_cond", "=", "dataset", ".", "labels", ".", "ravel", "(", ")", "==", "dataset", ".", "favorable_label", "\n", "unfav_cond", "=", "dataset", ".", "labels", ".", "ravel", "(", ")", "==", "dataset", ".", "unfavorable_label", "\n", "\n", "# combination of label and privileged/unpriv. groups", "\n", "cond_p_fav", "=", "np", ".", "logical_and", "(", "fav_cond", ",", "priv_cond", ")", "\n", "cond_p_unfav", "=", "np", ".", "logical_and", "(", "unfav_cond", ",", "priv_cond", ")", "\n", "cond_up_fav", "=", "np", ".", "logical_and", "(", "fav_cond", ",", "unpriv_cond", ")", "\n", "cond_up_unfav", "=", "np", ".", "logical_and", "(", "unfav_cond", ",", "unpriv_cond", ")", "\n", "\n", "return", "(", "priv_cond", ",", "unpriv_cond", ",", "fav_cond", ",", "unfav_cond", ",", "\n", "cond_p_fav", ",", "cond_p_unfav", ",", "cond_up_fav", ",", "cond_up_unfav", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.__init__": [[50, 84], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "prot_attr", "=", "None", ",", "n_prototypes", "=", "5", ",", "reconstruct_weight", "=", "0.01", ",", "\n", "target_weight", "=", "1.", ",", "fairness_weight", "=", "50.", ",", "tol", "=", "1e-4", ",", "max_iter", "=", "200", ",", "\n", "verbose", "=", "0", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            prot_attr (single label or list-like, optional): Protected\n                attribute(s) to use in the reweighing process. If more than one\n                attribute, all combinations of values (intersections) are\n                considered. Default is ``None`` meaning all protected attributes\n                from the dataset are used.\n            n_prototypes (int, optional): Size of the set of \"prototypes,\" Z.\n            reconstruct_weight (float, optional): Weight coefficient on the L_x\n                loss term, A_x.\n            target_weight (float, optional): Weight coefficient on the L_y loss\n                term, A_y.\n            fairness_weight (float, optional): Weight coefficient on the L_z\n                loss term, A_z.\n            tol (float, optional): Tolerance for stopping criteria.\n            max_iter (int, optional): Maximum number of iterations taken for the\n                solver to converge.\n            verbose (int, optional): Verbosity. 0 = silent, 1 = final loss only,\n                2 = print loss every 50 iterations.\n            random_state (int or numpy.RandomState, optional): Seed of pseudo-\n                random number generator for shuffling data and seeding weights.\n        \"\"\"", "\n", "self", ".", "prot_attr", "=", "prot_attr", "\n", "self", ".", "n_prototypes", "=", "n_prototypes", "\n", "self", ".", "reconstruct_weight", "=", "reconstruct_weight", "\n", "self", ".", "target_weight", "=", "target_weight", "\n", "self", ".", "fairness_weight", "=", "fairness_weight", "\n", "self", ".", "tol", "=", "tol", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "random_state", "=", "random_state", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.fit": [[85, 164], ["aif360.sklearn.utils.check_inputs", "sklearn.utils.check_random_state", "aif360.sklearn.utils.check_groups", "numpy.unique", "sklearn.preprocessing.LabelEncoder", "sklearn.preprocessing.LabelEncoder.fit_transform", "len", "sklearn.utils.check_random_state.random", "scipy.minimize", "scipy.minimize.x[].reshape", "scipy.minimize.x[].reshape", "numpy.finfo", "torch.as_tensor().requires_grad_", "torch.as_tensor().requires_grad_", "torch.as_tensor().requires_grad_", "torch.as_tensor().requires_grad_", "x[].view", "x[].view", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax.matmul().squeeze", "torch.softmax.matmul().squeeze", "torch.mse_loss", "torch.mse_loss", "torch.l1_loss", "torch.l1_loss", "loss.backward", "print", "torch.softmax.matmul", "torch.softmax.matmul", "torch.cross_entropy", "torch.cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "print", "loss.item", "torch.as_tensor().requires_grad_.grad.numpy", "torch.as_tensor().requires_grad_.grad.numpy", "warnings.warn", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.cdist", "torch.cdist", "torch.cdist", "torch.cdist", "torch.softmax.matmul", "torch.softmax.matmul", "torch.softmax.matmul().squeeze.clamp", "sklearn.preprocessing.LabelEncoder.fit_transform.type_as", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "warnings.warn", "int", "X.to_numpy", "scipy.minimize.message.decode", "numpy.log10"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_inputs", "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", ",", "priv_group", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute the transformation parameters that lead to fair\n        representations.\n\n        Args:\n            X (pandas.DataFrame): Training samples.\n            y (array-like): Training labels.\n            priv_group (scalar, optional): The label of the privileged group.\n            sample_weight (array-like, optional): Sample weights.\n\n        Returns:\n            self\n        \"\"\"", "\n", "X", ",", "y", ",", "sample_weight", "=", "check_inputs", "(", "X", ",", "y", ",", "sample_weight", ")", "\n", "rng", "=", "check_random_state", "(", "self", ".", "random_state", ")", "\n", "\n", "groups", ",", "self", ".", "prot_attr_", "=", "check_groups", "(", "X", ",", "self", ".", "prot_attr", ")", "\n", "priv", "=", "(", "groups", "==", "priv_group", ")", "\n", "self", ".", "priv_group_", "=", "priv_group", "\n", "self", ".", "groups_", "=", "np", ".", "unique", "(", "groups", ")", "\n", "\n", "le", "=", "LabelEncoder", "(", ")", "\n", "y", "=", "le", ".", "fit_transform", "(", "y", ")", "\n", "self", ".", "classes_", "=", "le", ".", "classes_", "\n", "n_classes", "=", "len", "(", "self", ".", "classes_", ")", "\n", "if", "n_classes", "==", "2", ":", "\n", "            ", "n_classes", "=", "1", "# XXX", "\n", "", "n_feat", "=", "X", ".", "shape", "[", "1", "]", "\n", "w_size", "=", "self", ".", "n_prototypes", "*", "n_classes", "\n", "\n", "i", "=", "0", "\n", "eps", "=", "np", ".", "finfo", "(", "np", ".", "float64", ")", ".", "eps", "\n", "\n", "def", "LFR_optim_objective", "(", "x", ",", "X", ",", "y", ",", "priv", ")", ":", "\n", "            ", "nonlocal", "i", "\n", "x", "=", "torch", ".", "as_tensor", "(", "x", ")", ".", "requires_grad_", "(", ")", "\n", "w", "=", "x", "[", ":", "w_size", "]", ".", "view", "(", "-", "1", ",", "n_classes", ")", "\n", "v", "=", "x", "[", "w_size", ":", "]", ".", "view", "(", "-", "1", ",", "n_feat", ")", "\n", "\n", "M", "=", "torch", ".", "softmax", "(", "-", "torch", ".", "cdist", "(", "X", ",", "v", ")", ",", "dim", "=", "1", ")", "\n", "y_pred", "=", "M", ".", "matmul", "(", "w", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "L_x", "=", "F", ".", "mse_loss", "(", "M", ".", "matmul", "(", "v", ")", ",", "X", ")", "\n", "L_y", "=", "F", ".", "cross_entropy", "(", "y_pred", ",", "y", ")", "if", "n_classes", ">", "1", "else", "F", ".", "binary_cross_entropy", "(", "y_pred", ".", "clamp", "(", "eps", ",", "1", "-", "eps", ")", ",", "y", ".", "type_as", "(", "w", ")", ")", "\n", "L_z", "=", "F", ".", "l1_loss", "(", "torch", ".", "mean", "(", "M", "[", "priv", "]", ",", "0", ")", ",", "torch", ".", "mean", "(", "M", "[", "~", "priv", "]", ",", "0", ")", ")", "\n", "loss", "=", "(", "self", ".", "reconstruct_weight", "*", "L_x", "+", "self", ".", "target_weight", "*", "L_y", "\n", "+", "self", ".", "fairness_weight", "*", "L_z", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "if", "self", ".", "verbose", ">", "1", "and", "i", "%", "50", "==", "0", ":", "\n", "                ", "print", "(", "\"iter: {:{}d}, loss: {:7.3f}, A_x*L_x: {:7.3f}, A_y*L_y: \"", "\n", "\"{:7.3f}, A_z*L_z: {:7.3f}\"", ".", "format", "(", "i", ",", "\n", "int", "(", "np", ".", "log10", "(", "self", ".", "max_iter", ")", "+", "1", ")", ",", "loss", ",", "\n", "self", ".", "reconstruct_weight", "*", "L_x", ",", "self", ".", "target_weight", "*", "L_y", ",", "\n", "self", ".", "fairness_weight", "*", "L_z", ")", ")", "\n", "", "i", "+=", "1", "\n", "return", "loss", ".", "item", "(", ")", ",", "x", ".", "grad", ".", "numpy", "(", ")", "\n", "\n", "", "x0", "=", "rng", ".", "random", "(", "w_size", "+", "self", ".", "n_prototypes", "*", "n_feat", ")", "\n", "bounds", "=", "[", "(", "0", ",", "1", ")", "]", "*", "w_size", "+", "[", "(", "None", ",", "None", ")", "]", "*", "self", ".", "n_prototypes", "*", "n_feat", "\n", "res", "=", "optim", ".", "minimize", "(", "LFR_optim_objective", ",", "x0", "=", "x0", ",", "method", "=", "'L-BFGS-B'", ",", "\n", "args", "=", "(", "torch", ".", "tensor", "(", "X", ".", "to_numpy", "(", ")", ")", ",", "torch", ".", "as_tensor", "(", "y", ")", ",", "priv", ")", ",", "\n", "jac", "=", "True", ",", "bounds", "=", "bounds", ",", "options", "=", "{", "'gtol'", ":", "self", ".", "tol", ",", "\n", "'maxiter'", ":", "self", ".", "max_iter", "}", ")", "\n", "\n", "self", ".", "coef_", "=", "res", ".", "x", "[", ":", "w_size", "]", ".", "reshape", "(", "-", "1", ",", "n_classes", ")", "\n", "self", ".", "prototypes_", "=", "res", ".", "x", "[", "w_size", ":", "]", ".", "reshape", "(", "-", "1", ",", "n_feat", ")", "\n", "self", ".", "n_iter_", "=", "res", ".", "nit", "\n", "\n", "if", "res", ".", "status", "==", "0", "and", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"Converged! iter: {}, loss: {:.3f}\"", ".", "format", "(", "res", ".", "nit", ",", "res", ".", "fun", ")", ")", "\n", "", "elif", "res", ".", "status", "==", "1", ":", "\n", "            ", "warnings", ".", "warn", "(", "'lbfgs failed to converge. Increase the number of '", "\n", "'iterations.'", ",", "ConvergenceWarning", ")", "\n", "", "elif", "res", ".", "status", "==", "2", ":", "\n", "            ", "warnings", ".", "warn", "(", "'lbfgs failed to converge: {}'", ".", "format", "(", "\n", "res", ".", "message", ".", "decode", "(", ")", ")", ",", "ConvergenceWarning", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform": [[165, 177], ["scipy.special.softmax", "scipy.special.softmax.dot", "pandas.DataFrame", "scipy.spatial.distance.cdist"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Transform the dataset using the learned model parameters.\n\n        Args:\n            X (pandas.DataFrame): Training samples.\n\n        Returns:\n            pandas.DataFrame: Transformed samples.\n        \"\"\"", "\n", "M", "=", "softmax", "(", "-", "cdist", "(", "X", ",", "self", ".", "prototypes_", ")", ",", "axis", "=", "1", ")", "\n", "Xt", "=", "M", ".", "dot", "(", "self", ".", "prototypes_", ")", "\n", "return", "pd", ".", "DataFrame", "(", "Xt", ",", "columns", "=", "X", ".", "columns", ",", "index", "=", "X", ".", "index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.predict_proba": [[178, 196], ["scipy.special.softmax", "scipy.special.softmax.dot", "scipy.special.softmax", "scipy.spatial.distance.cdist"], "methods", ["None"], ["", "def", "predict_proba", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Transform the targets using the learned model parameters.\n\n        Args:\n            X (pandas.DataFrame): Training samples.\n\n        Returns:\n            numpy.ndarray: Transformed targets. Returns the probability of the\n            sample for each class in the model, where classes are ordered as\n            they are in ``self.classes_``.\n        \"\"\"", "\n", "M", "=", "softmax", "(", "-", "cdist", "(", "X", ",", "self", ".", "prototypes_", ")", ",", "axis", "=", "1", ")", "\n", "yt", "=", "M", ".", "dot", "(", "self", ".", "coef_", ")", "\n", "if", "yt", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "            ", "yt", "=", "np", ".", "c_", "[", "1", "-", "yt", ",", "yt", "]", "\n", "", "else", ":", "\n", "            ", "yt", "=", "softmax", "(", "yt", ",", "axis", "=", "1", ")", "\n", "", "return", "yt", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.predict": [[197, 208], ["learning_fair_representations.LearnedFairRepresentations.predict_proba", "learning_fair_representations.LearnedFairRepresentations.argmax"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Transform the targets using the learned model parameters.\n\n        Args:\n            X (pandas.DataFrame): Training samples.\n\n        Returns:\n            numpy.ndarray: Transformed targets.\n        \"\"\"", "\n", "probas", "=", "self", ".", "predict_proba", "(", "X", ")", "\n", "return", "self", ".", "classes_", "[", "probas", ".", "argmax", "(", "axis", "=", "1", ")", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.Reweighing.fit_transform": [[58, 95], ["aif360.sklearn.utils.check_inputs", "numpy.empty_like", "aif360.sklearn.utils.check_groups", "numpy.unique", "numpy.unique", "len", "len", "numpy.full", "sample_weight.sum", "enumerate", "sample_weight[].sum", "enumerate", "numpy.any", "reweighing.Reweighing.fit_transform.N_"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_inputs", "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups"], ["n_p_unfav", "=", "np", ".", "sum", "(", "dataset", ".", "instance_weights", "[", "cond_p_unfav", "]", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "n_up_fav", "=", "np", ".", "sum", "(", "dataset", ".", "instance_weights", "[", "cond_up_fav", "]", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "n_up_unfav", "=", "np", ".", "sum", "(", "dataset", ".", "instance_weights", "[", "cond_up_unfav", "]", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "# reweighing weights", "\n", "self", ".", "w_p_fav", "=", "n_fav", "*", "n_p", "/", "(", "n", "*", "n_p_fav", ")", "\n", "self", ".", "w_p_unfav", "=", "n_unfav", "*", "n_p", "/", "(", "n", "*", "n_p_unfav", ")", "\n", "self", ".", "w_up_fav", "=", "n_fav", "*", "n_up", "/", "(", "n", "*", "n_up_fav", ")", "\n", "self", ".", "w_up_unfav", "=", "n_unfav", "*", "n_up", "/", "(", "n", "*", "n_up_unfav", ")", "\n", "\n", "return", "self", "\n", "\n", "", "def", "transform", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Transform the dataset to a new dataset based on the estimated\n        transformation.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset that needs to be transformed.\n        Returns:\n            dataset (BinaryLabelDataset): Dataset with transformed\n                instance_weights attribute.\n        \"\"\"", "\n", "\n", "dataset_transformed", "=", "dataset", ".", "copy", "(", "deepcopy", "=", "True", ")", "\n", "\n", "(", "_", ",", "_", ",", "_", ",", "_", ",", "cond_p_fav", ",", "cond_p_unfav", ",", "cond_up_fav", ",", "cond_up_unfav", ")", "=", "self", ".", "_obtain_conditionings", "(", "dataset", ")", "\n", "\n", "# apply reweighing", "\n", "dataset_transformed", ".", "instance_weights", "[", "cond_p_fav", "]", "*=", "self", ".", "w_p_fav", "\n", "dataset_transformed", ".", "instance_weights", "[", "cond_p_unfav", "]", "*=", "self", ".", "w_p_unfav", "\n", "dataset_transformed", ".", "instance_weights", "[", "cond_up_fav", "]", "*=", "self", ".", "w_up_fav", "\n", "dataset_transformed", ".", "instance_weights", "[", "cond_up_unfav", "]", "*=", "self", ".", "w_up_unfav", "\n", "\n", "return", "dataset_transformed", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.ReweighingMeta.__init__": [[108, 118], ["None"], "methods", ["None"], ["condition", "=", "self", ".", "privileged_groups", ")", "\n", "unpriv_cond", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "\n", "condition", "=", "self", ".", "unprivileged_groups", ")", "\n", "fav_cond", "=", "dataset", ".", "labels", ".", "ravel", "(", ")", "==", "dataset", ".", "favorable_label", "\n", "unfav_cond", "=", "dataset", ".", "labels", ".", "ravel", "(", ")", "==", "dataset", ".", "unfavorable_label", "\n", "\n", "# combination of label and privileged/unpriv. groups", "\n", "cond_p_fav", "=", "np", ".", "logical_and", "(", "fav_cond", ",", "priv_cond", ")", "\n", "cond_p_unfav", "=", "np", ".", "logical_and", "(", "unfav_cond", ",", "priv_cond", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.ReweighingMeta._estimator_type": [[119, 122], ["None"], "methods", ["None"], ["cond_up_fav", "=", "np", ".", "logical_and", "(", "fav_cond", ",", "unpriv_cond", ")", "\n", "cond_up_unfav", "=", "np", ".", "logical_and", "(", "unfav_cond", ",", "unpriv_cond", ")", "\n", "\n", "return", "(", "priv_cond", ",", "unpriv_cond", ",", "fav_cond", ",", "unfav_cond", ",", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.ReweighingMeta.classes_": [[123, 127], ["None"], "methods", ["None"], ["cond_p_fav", ",", "cond_p_unfav", ",", "cond_up_fav", ",", "cond_up_unfav", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.ReweighingMeta.fit": [[128, 155], ["sklearn.base.clone", "reweighing.ReweighingMeta.reweigher_.fit_transform", "reweighing.ReweighingMeta.estimator_.fit", "sklearn.utils.validation.has_fit_parameter", "TypeError", "reweighing.Reweighing", "sklearn.base.clone", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], []], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.ReweighingMeta.predict": [[156, 167], ["sklearn.utils.metaestimators.if_delegate_has_method", "reweighing.ReweighingMeta.estimator_.predict"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], []], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.ReweighingMeta.predict_proba": [[168, 183], ["sklearn.utils.metaestimators.if_delegate_has_method", "reweighing.ReweighingMeta.estimator_.predict_proba"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba"], []], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.ReweighingMeta.predict_log_proba": [[184, 200], ["sklearn.utils.metaestimators.if_delegate_has_method", "reweighing.ReweighingMeta.estimator_.predict_log_proba"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta.predict_log_proba"], []], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.reweighing.ReweighingMeta.score": [[201, 215], ["sklearn.utils.metaestimators.if_delegate_has_method", "reweighing.ReweighingMeta.estimator_.score"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score"], []], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.__init__": [[39, 59], ["len", "rpy2.robjects.packages.importr", "rpy2.robjects.packages.importr.chooseCRANmirror", "rpy2.robjects.packages.importr.install_packages", "rpy2.robjects.vectors.StrVector", "rpy2.robjects.packages.isinstalled"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "prot_attr", ",", "adj_mat", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            prot_attr (single label): Name of the protected attribute. Must be\n                binary.\n            adj_mat (array-like): A 2-dimensional array representing the\n                adjacency matrix of the causal diagram of the data generating\n                process. Row/column order must match `X_train`.\n        \"\"\"", "\n", "self", ".", "prot_attr", "=", "prot_attr", "\n", "self", ".", "adj_mat", "=", "adj_mat", "\n", "\n", "# R packages need to run FairAdapt", "\n", "pkgs", "=", "(", "'ranger'", ",", "'fairadapt'", ")", "\n", "# selectively install the missing packages", "\n", "pkgs", "=", "[", "p", "for", "p", "in", "pkgs", "if", "not", "robjects", ".", "packages", ".", "isinstalled", "(", "p", ")", "]", "\n", "if", "len", "(", "pkgs", ")", ">", "0", ":", "\n", "            ", "utls", "=", "robjects", ".", "packages", ".", "importr", "(", "'utils'", ")", "\n", "utls", ".", "chooseCRANmirror", "(", "ind", "=", "1", ")", "\n", "utls", ".", "install_packages", "(", "StrVector", "(", "pkgs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform": [[60, 111], ["pandas.concat", "aif360.sklearn.utils.check_groups", "numpy.unique", "os.join", "rpy2.robjects.r.source", "FairAdapt_R", "rpy2.robjects.conversion.rpy2py.pop", "os.dirname", "rpy2.robjects.conversion.localconverter", "rpy2.robjects.conversion.py2rpy", "rpy2.robjects.conversion.py2rpy", "rpy2.robjects.conversion.py2rpy", "rpy2.robjects.conversion.localconverter", "rpy2.robjects.conversion.rpy2py", "rpy2.robjects.conversion.rpy2py", "X_train.columns.tolist", "os.abspath", "FairAdapt_R.rx2", "FairAdapt_R.rx2"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups"], ["", "", "def", "fit_transform", "(", "self", ",", "X_train", ",", "y_train", ",", "X_test", ")", ":", "\n", "        ", "\"\"\"Remove bias from the given dataset by fair adaptation.\n\n        Args:\n            X_train (pandas.DataFrame): Training data frame (including the\n                protected attribute).\n            y_train (pandas.Series): Training labels.\n            X_test (pandas.DataFrame): Test data frame (including the protected\n                attribute).\n\n        Returns:\n            tuple:\n                Transformed inputs.\n\n                * **X_fair_train** (pandas.DataFrame) -- Transformed training\n                  data.\n                * **y_fair_train** (array-like) -- Transformed training labels.\n                * **X_fair_test** (pandas.DataFrame) -- Transformed test data.\n\n        \"\"\"", "\n", "# merge X_train and y_train", "\n", "df_train", "=", "pd", ".", "concat", "(", "[", "X_train", ",", "y_train", "]", ",", "axis", "=", "1", ")", "\n", "groups", ",", "self", ".", "prot_attr_", "=", "check_groups", "(", "X_train", ",", "self", ".", "prot_attr", ",", "ensure_binary", "=", "True", ")", "\n", "self", ".", "groups_", "=", "np", ".", "unique", "(", "groups", ")", "\n", "\n", "wrapper", "=", "osp", ".", "join", "(", "osp", ".", "dirname", "(", "osp", ".", "abspath", "(", "__file__", ")", ")", ",", "'fairadapt.R'", ")", "\n", "robjects", ".", "r", ".", "source", "(", "wrapper", ")", "\n", "FairAdapt_R", "=", "robjects", ".", "r", "[", "'wrapper'", "]", "\n", "# convert to Pandas with a local converter", "\n", "with", "localconverter", "(", "robjects", ".", "default_converter", "+", "pandas2ri", ".", "converter", ")", ":", "\n", "            ", "train_data", "=", "robjects", ".", "conversion", ".", "py2rpy", "(", "df_train", ")", "\n", "test_data", "=", "robjects", ".", "conversion", ".", "py2rpy", "(", "X_test", ")", "\n", "adj_mat", "=", "robjects", ".", "conversion", ".", "py2rpy", "(", "self", ".", "adj_mat", ")", "\n", "\n", "# run FairAdapt in R", "\n", "", "res", "=", "FairAdapt_R", "(", "\n", "train_data", "=", "train_data", ",", "\n", "test_data", "=", "test_data", ",", "\n", "adj_mat", "=", "adj_mat", ",", "\n", "prot_attr", "=", "self", ".", "prot_attr_", ",", "\n", "outcome", "=", "y_train", ".", "name", "\n", ")", "\n", "\n", "with", "localconverter", "(", "robjects", ".", "default_converter", "+", "pandas2ri", ".", "converter", ")", ":", "\n", "            ", "X_fair_train", "=", "robjects", ".", "conversion", ".", "rpy2py", "(", "res", ".", "rx2", "(", "'train'", ")", ")", "\n", "X_fair_test", "=", "robjects", ".", "conversion", ".", "rpy2py", "(", "res", ".", "rx2", "(", "'test'", ")", ")", "\n", "", "X_fair_train", ".", "columns", "=", "[", "y_train", ".", "name", "]", "+", "X_train", ".", "columns", ".", "tolist", "(", ")", "\n", "y_fair_train", "=", "X_fair_train", ".", "pop", "(", "y_train", ".", "name", ")", "\n", "X_fair_test", ".", "columns", "=", "X_test", ".", "columns", "\n", "\n", "return", "X_fair_train", ",", "y_fair_train", ",", "X_fair_test", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.lfr_helpers.helpers.LFR_optim_objective": [[8, 36], ["parameters[].reshape", "helpers.get_xhat_y_hat", "helpers.get_xhat_y_hat", "numpy.concatenate", "numpy.concatenate", "numpy.mean", "numpy.mean", "numpy.mean", "abs", "numpy.mean", "print", "y_unprivileged.reshape", "y_privileged.reshape", "numpy.mean", "numpy.mean", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lfr_helpers.helpers.get_xhat_y_hat", "home.repos.pwc.inspect_result.IBM_AIF360.lfr_helpers.helpers.get_xhat_y_hat"], ["def", "LFR_optim_objective", "(", "parameters", ",", "x_unprivileged", ",", "x_privileged", ",", "y_unprivileged", ",", "\n", "y_privileged", ",", "k", "=", "10", ",", "A_x", "=", "0.01", ",", "A_y", "=", "0.1", ",", "A_z", "=", "0.5", ",", "print_interval", "=", "250", ",", "verbose", "=", "1", ")", ":", "\n", "\n", "    ", "num_unprivileged", ",", "features_dim", "=", "x_unprivileged", ".", "shape", "\n", "num_privileged", ",", "_", "=", "x_privileged", ".", "shape", "\n", "\n", "w", "=", "parameters", "[", ":", "k", "]", "\n", "prototypes", "=", "parameters", "[", "k", ":", "]", ".", "reshape", "(", "(", "k", ",", "features_dim", ")", ")", "\n", "\n", "M_unprivileged", ",", "x_hat_unprivileged", ",", "y_hat_unprivileged", "=", "get_xhat_y_hat", "(", "prototypes", ",", "w", ",", "x_unprivileged", ")", "\n", "\n", "M_privileged", ",", "x_hat_privileged", ",", "y_hat_privileged", "=", "get_xhat_y_hat", "(", "prototypes", ",", "w", ",", "x_privileged", ")", "\n", "\n", "y_hat", "=", "np", ".", "concatenate", "(", "[", "y_hat_unprivileged", ",", "y_hat_privileged", "]", ",", "axis", "=", "0", ")", "\n", "y", "=", "np", ".", "concatenate", "(", "[", "y_unprivileged", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "y_privileged", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "]", ",", "axis", "=", "0", ")", "\n", "\n", "L_x", "=", "np", ".", "mean", "(", "(", "x_hat_unprivileged", "-", "x_unprivileged", ")", "**", "2", ")", "+", "np", ".", "mean", "(", "(", "x_hat_privileged", "-", "x_privileged", ")", "**", "2", ")", "\n", "L_z", "=", "np", ".", "mean", "(", "abs", "(", "np", ".", "mean", "(", "M_unprivileged", ",", "axis", "=", "0", ")", "-", "np", ".", "mean", "(", "M_privileged", ",", "axis", "=", "0", ")", ")", ")", "\n", "L_y", "=", "-", "np", ".", "mean", "(", "y", "*", "np", ".", "log", "(", "y_hat", ")", "+", "(", "1.", "-", "y", ")", "*", "np", ".", "log", "(", "1.", "-", "y_hat", ")", ")", "\n", "\n", "total_loss", "=", "A_x", "*", "L_x", "+", "A_y", "*", "L_y", "+", "A_z", "*", "L_z", "\n", "\n", "if", "verbose", "and", "LFR_optim_objective", ".", "steps", "%", "print_interval", "==", "0", ":", "\n", "        ", "print", "(", "\"step: {}, loss: {}, L_x: {},  L_y: {},  L_z: {}\"", ".", "format", "(", "\n", "LFR_optim_objective", ".", "steps", ",", "total_loss", ",", "L_x", ",", "L_y", ",", "L_z", ")", ")", "\n", "", "LFR_optim_objective", ".", "steps", "+=", "1", "\n", "\n", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lfr_helpers.helpers.get_xhat_y_hat": [[38, 47], ["scipy.special.softmax", "numpy.matmul", "numpy.clip", "numpy.matmul", "scipy.spatial.distance.cdist", "w.reshape", "numpy.finfo", "numpy.finfo"], "function", ["None"], ["", "def", "get_xhat_y_hat", "(", "prototypes", ",", "w", ",", "x", ")", ":", "\n", "    ", "M", "=", "softmax", "(", "-", "cdist", "(", "x", ",", "prototypes", ")", ",", "axis", "=", "1", ")", "\n", "x_hat", "=", "np", ".", "matmul", "(", "M", ",", "prototypes", ")", "\n", "y_hat", "=", "np", ".", "clip", "(", "\n", "np", ".", "matmul", "(", "M", ",", "w", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ")", ",", "\n", "np", ".", "finfo", "(", "float", ")", ".", "eps", ",", "\n", "1.0", "-", "np", ".", "finfo", "(", "float", ")", ".", "eps", "\n", ")", "\n", "return", "M", ",", "x_hat", ",", "y_hat", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.distortion_functions.get_distortion_adult": [[6, 78], ["distortion_functions.get_distortion_adult.adjustEdu"], "function", ["None"], ["def", "get_distortion_adult", "(", "vold", ",", "vnew", ")", ":", "\n", "    ", "\"\"\"Distortion function for the adult dataset. We set the distortion\n    metric here. See section 4.3 in supplementary material of\n    http://papers.nips.cc/paper/6988-optimized-pre-processing-for-discrimination-prevention\n    for an example\n\n    Note:\n        Users can use this as templates to create other distortion functions.\n\n    Args:\n        vold (dict) : {attr:value} with old values\n        vnew (dict) : dictionary of the form {attr:value} with new values\n\n    Returns:\n        d (value) : distortion value\n    \"\"\"", "\n", "\n", "# Define local functions to adjust education and age", "\n", "def", "adjustEdu", "(", "v", ")", ":", "\n", "        ", "if", "v", "==", "'>12'", ":", "\n", "            ", "return", "13", "\n", "", "elif", "v", "==", "'<6'", ":", "\n", "            ", "return", "5", "\n", "", "else", ":", "\n", "            ", "return", "int", "(", "v", ")", "\n", "\n", "", "", "def", "adjustAge", "(", "a", ")", ":", "\n", "        ", "if", "a", "==", "'>=70'", ":", "\n", "            ", "return", "70.0", "\n", "", "else", ":", "\n", "            ", "return", "float", "(", "a", ")", "\n", "\n", "", "", "def", "adjustInc", "(", "a", ")", ":", "\n", "        ", "if", "a", "==", "\"<=50K\"", ":", "\n", "            ", "return", "0", "\n", "", "elif", "a", "==", "\">50K\"", ":", "\n", "            ", "return", "1", "\n", "", "else", ":", "\n", "            ", "return", "int", "(", "a", ")", "\n", "\n", "# value that will be returned for events that should not occur", "\n", "", "", "bad_val", "=", "3.0", "\n", "\n", "# Adjust education years", "\n", "eOld", "=", "adjustEdu", "(", "vold", "[", "'Education Years'", "]", ")", "\n", "eNew", "=", "adjustEdu", "(", "vnew", "[", "'Education Years'", "]", ")", "\n", "\n", "# Education cannot be lowered or increased in more than 1 year", "\n", "if", "(", "eNew", "<", "eOld", ")", "|", "(", "eNew", ">", "eOld", "+", "1", ")", ":", "\n", "        ", "return", "bad_val", "\n", "\n", "# adjust age", "\n", "", "aOld", "=", "adjustAge", "(", "vold", "[", "'Age (decade)'", "]", ")", "\n", "aNew", "=", "adjustAge", "(", "vnew", "[", "'Age (decade)'", "]", ")", "\n", "\n", "# Age cannot be increased or decreased in more than a decade", "\n", "if", "np", ".", "abs", "(", "aOld", "-", "aNew", ")", ">", "10.0", ":", "\n", "        ", "return", "bad_val", "\n", "\n", "# Penalty of 2 if age is decreased or increased", "\n", "", "if", "np", ".", "abs", "(", "aOld", "-", "aNew", ")", ">", "0", ":", "\n", "        ", "return", "2.0", "\n", "\n", "# Adjust income", "\n", "", "incOld", "=", "adjustInc", "(", "vold", "[", "'Income Binary'", "]", ")", "\n", "incNew", "=", "adjustInc", "(", "vnew", "[", "'Income Binary'", "]", ")", "\n", "\n", "# final penalty according to income", "\n", "if", "incOld", ">", "incNew", ":", "\n", "        ", "return", "1.0", "\n", "", "else", ":", "\n", "        ", "return", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.distortion_functions.get_distortion_german": [[80, 138], ["pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame"], "function", ["None"], ["", "", "def", "get_distortion_german", "(", "vold", ",", "vnew", ")", ":", "\n", "    ", "\"\"\"Distortion function for the german dataset. We set the distortion\n    metric here. See section 4.3 in supplementary material of\n    http://papers.nips.cc/paper/6988-optimized-pre-processing-for-discrimination-prevention\n    for an example\n\n    Note:\n        Users can use this as templates to create other distortion functions.\n\n    Args:\n        vold (dict) : {attr:value} with old values\n        vnew (dict) : dictionary of the form {attr:value} with new values\n\n    Returns:\n        d (value) : distortion value\n    \"\"\"", "\n", "\n", "# Distortion cost", "\n", "distort", "=", "{", "}", "\n", "distort", "[", "'credit_history'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'None/Paid'", ":", "[", "0.", ",", "1.", ",", "2.", "]", ",", "\n", "'Delay'", ":", "[", "1.", ",", "0.", ",", "1.", "]", ",", "\n", "'Other'", ":", "[", "2.", ",", "1.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "'None/Paid'", ",", "'Delay'", ",", "'Other'", "]", ")", "\n", "distort", "[", "'employment'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'Unemployed'", ":", "[", "0.", ",", "1.", ",", "2.", "]", ",", "\n", "'1-4 years'", ":", "[", "1.", ",", "0.", ",", "1.", "]", ",", "\n", "'4+ years'", ":", "[", "2.", ",", "1.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "'Unemployed'", ",", "'1-4 years'", ",", "'4+ years'", "]", ")", "\n", "distort", "[", "'savings'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'Unknown/None'", ":", "[", "0.", ",", "1.", ",", "2.", "]", ",", "\n", "'<500'", ":", "[", "1.", ",", "0.", ",", "1.", "]", ",", "\n", "'500+'", ":", "[", "2.", ",", "1.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "'Unknown/None'", ",", "'<500'", ",", "'500+'", "]", ")", "\n", "distort", "[", "'status'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'None'", ":", "[", "0.", ",", "1.", ",", "2.", "]", ",", "\n", "'<200'", ":", "[", "1.", ",", "0.", ",", "1.", "]", ",", "\n", "'200+'", ":", "[", "2.", ",", "1.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "'None'", ",", "'<200'", ",", "'200+'", "]", ")", "\n", "distort", "[", "'credit'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'Bad Credit'", ":", "[", "0.", ",", "1.", "]", ",", "\n", "'Good Credit'", ":", "[", "2.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "'Bad Credit'", ",", "'Good Credit'", "]", ")", "\n", "distort", "[", "'sex'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "0.0", ":", "[", "0.", ",", "2.", "]", ",", "\n", "1.0", ":", "[", "2.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "0.0", ",", "1.0", "]", ")", "\n", "distort", "[", "'age'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "0.0", ":", "[", "0.", ",", "2.", "]", ",", "\n", "1.0", ":", "[", "2.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "0.0", ",", "1.0", "]", ")", "\n", "\n", "total_cost", "=", "0.0", "\n", "for", "k", "in", "vold", ":", "\n", "        ", "if", "k", "in", "vnew", ":", "\n", "            ", "total_cost", "+=", "distort", "[", "k", "]", ".", "loc", "[", "vnew", "[", "k", "]", ",", "vold", "[", "k", "]", "]", "\n", "\n", "", "", "return", "total_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.distortion_functions.get_distortion_compas": [[139, 190], ["pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame"], "function", ["None"], ["", "def", "get_distortion_compas", "(", "vold", ",", "vnew", ")", ":", "\n", "    ", "\"\"\"Distortion function for the compas dataset. We set the distortion\n    metric here. See section 4.3 in supplementary material of\n    http://papers.nips.cc/paper/6988-optimized-pre-processing-for-discrimination-prevention\n    for an example\n\n    Note:\n        Users can use this as templates to create other distortion functions.\n\n    Args:\n        vold (dict) : {attr:value} with old values\n        vnew (dict) : dictionary of the form {attr:value} with new values\n\n    Returns:\n        d (value) : distortion value\n    \"\"\"", "\n", "# Distortion cost", "\n", "distort", "=", "{", "}", "\n", "distort", "[", "'two_year_recid'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'No recid.'", ":", "[", "0.", ",", "2.", "]", ",", "\n", "'Did recid.'", ":", "[", "2.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "'No recid.'", ",", "'Did recid.'", "]", ")", "\n", "distort", "[", "'age_cat'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'Less than 25'", ":", "[", "0.", ",", "1.", ",", "2.", "]", ",", "\n", "'25 to 45'", ":", "[", "1.", ",", "0.", ",", "1.", "]", ",", "\n", "'Greater than 45'", ":", "[", "2.", ",", "1.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "'Less than 25'", ",", "'25 to 45'", ",", "'Greater than 45'", "]", ")", "\n", "distort", "[", "'c_charge_degree'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'M'", ":", "[", "0.", ",", "2.", "]", ",", "\n", "'F'", ":", "[", "1.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "'M'", ",", "'F'", "]", ")", "\n", "distort", "[", "'priors_count'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "'0'", ":", "[", "0.", ",", "1.", ",", "2.", "]", ",", "\n", "'1 to 3'", ":", "[", "1.", ",", "0.", ",", "1.", "]", ",", "\n", "'More than 3'", ":", "[", "2.", ",", "1.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "'0'", ",", "'1 to 3'", ",", "'More than 3'", "]", ")", "\n", "distort", "[", "'sex'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "0.0", ":", "[", "0.", ",", "2.", "]", ",", "\n", "1.0", ":", "[", "2.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "0.0", ",", "1.0", "]", ")", "\n", "distort", "[", "'race'", "]", "=", "pd", ".", "DataFrame", "(", "\n", "{", "0.0", ":", "[", "0.", ",", "2.", "]", ",", "\n", "1.0", ":", "[", "2.", ",", "0.", "]", "}", ",", "\n", "index", "=", "[", "0.0", ",", "1.0", "]", ")", "\n", "\n", "total_cost", "=", "0.0", "\n", "for", "k", "in", "vold", ":", "\n", "        ", "if", "k", "in", "vnew", ":", "\n", "            ", "total_cost", "+=", "distort", "[", "k", "]", ".", "loc", "[", "vnew", "[", "k", "]", ",", "vold", "[", "k", "]", "]", "\n", "\n", "", "", "return", "total_cost", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.__init__": [[78, 123], ["df.copy", "opt_tools.OptTools.df.groupby().size().reset_index", "opt_tools.OptTools.dfJoint.rename", "opt_tools.OptTools.dfJoint[].apply", "pandas.DataFrame", "pandas.DataFrame", "isinstance", "TypeError", "list", "opt_tools.OptTools.df.groupby().size", "float", "opt_tools.OptTools.df.groupby", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["def", "__init__", "(", "self", ",", "df", "=", "None", ",", "features", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the problem. Not all attributes are initialized when\n        creating the object.\n\n        Args:\n            df (DataFrame): Input dataframe\n            features (list): Optional features to subset the dataframe\n        \"\"\"", "\n", "\n", "self", ".", "df", "=", "df", ".", "copy", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "df", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"`df` must be a pandas DataFrame\"", ")", "\n", "\n", "", "if", "not", "features", ":", "\n", "            ", "self", ".", "features", "=", "list", "(", "df", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "features", "=", "features", "\n", "\n", "# build joint distribution", "\n", "", "self", ".", "dfJoint", "=", "self", ".", "df", ".", "groupby", "(", "self", ".", "features", ")", ".", "size", "(", ")", ".", "reset_index", "(", ")", "\n", "self", ".", "dfJoint", ".", "rename", "(", "columns", "=", "{", "0", ":", "'Count'", "}", ",", "inplace", "=", "True", ")", "\n", "self", ".", "dfJoint", "[", "'Frequency'", "]", "=", "self", ".", "dfJoint", "[", "'Count'", "]", ".", "apply", "(", "\n", "lambda", "x", ":", "x", "/", "float", "(", "len", "(", "self", ".", "df", ")", ")", ")", "\n", "\n", "# initialize the features that will be used for optimization", "\n", "self", ".", "D_features", "=", "[", "]", "# discriminatory features", "\n", "self", ".", "Y_features", "=", "[", "]", "# binary decision variable", "\n", "self", ".", "X_features", "=", "[", "]", "# variables used for decision making", "\n", "\n", "# values that each feature can assume", "\n", "self", ".", "D_values", "=", "[", "]", "\n", "self", ".", "Y_values", "=", "[", "]", "\n", "\n", "# place holder for mapping dataframe", "\n", "self", ".", "dfP", "=", "pd", ".", "DataFrame", "(", ")", "# this will hold the conditional mappings", "\n", "\n", "# place holder for the distortion mapping", "\n", "self", ".", "dfD", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "# excess distortion constraint placeholder", "\n", "self", ".", "clist", "=", "[", "]", "\n", "\n", "# excess distortion matrices", "\n", "self", ".", "CMlist", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.get_mask": [[124, 146], ["list", "range", "range", "pandas.DataFrame().reset_index", "pandas.DataFrame().reset_index", "numpy.all", "pandas.DataFrame", "pandas.DataFrame"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "get_mask", "(", "self", ",", "dfRef", ")", ":", "\n", "        ", "\"\"\"Create a mask assuming the multindex column is a subset of the\n        multindex rows. This mask will be used for marginalizing distributions.\n\n        Args:\n            dfRef (DataFrame): Reference data frame\n        \"\"\"", "\n", "\n", "# generates a mask assuming the multindex column is a subset of the", "\n", "# multindex rows", "\n", "target_ix", "=", "list", "(", "dfRef", ".", "columns", ".", "names", ")", "\n", "dfRows", "=", "pd", ".", "DataFrame", "(", "index", "=", "dfRef", ".", "index", ")", ".", "reset_index", "(", ")", "[", "target_ix", "]", ".", "values", "\n", "dfCols", "=", "pd", ".", "DataFrame", "(", "index", "=", "dfRef", ".", "columns", ")", ".", "reset_index", "(", ")", "[", "target_ix", "]", ".", "values", "\n", "\n", "for", "i", "in", "range", "(", "dfRef", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "val1", "=", "dfRows", "[", "i", ",", ":", "]", "\n", "for", "j", "in", "range", "(", "dfRef", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "val2", "=", "dfCols", "[", "j", ",", ":", "]", "\n", "if", "np", ".", "all", "(", "val1", "==", "val2", ")", ":", "\n", "                    ", "dfRef", ".", "iat", "[", "i", ",", "j", "]", "=", "1.0", "\n", "\n", "", "", "", "return", "dfRef", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.set_features": [[148, 252], ["pandas.MultiIndex.from_product", "pandas.MultiIndex.from_product", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "opt_tools.OptTools.dfJoint[].values.tolist", "pandas.DataFrame", "opt_tools.OptTools.get_mask", "pandas.DataFrame", "opt_tools.OptTools.get_mask", "pandas.Series", "pandas.pivot_table", "pandas.DataFrame", "opt_tools.OptTools.get_mask", "pandas.DataFrame", "opt_tools.OptTools.get_mask", "pandas.DataFrame", "opt_tools.OptTools.get_mask", "opt_tools.OptTools.dfJoint[].unique().tolist", "opt_tools.OptTools.dfJoint[].unique().tolist", "opt_tools.OptTools.dfJoint[].unique().tolist", "numpy.zeros", "numpy.zeros", "list", "index_list.index", "numpy.zeros", "[].sum", "numpy.zeros", "range", "opt_tools.OptTools.dfD_to_Y_address.reset_index", "numpy.zeros", "numpy.zeros", "numpy.zeros", "opt_tools.OptTools.XY_index.copy", "opt_tools.OptTools.XY_index.copy", "opt_tools.OptTools.dfPxyd.index.tolist", "len", "opt_tools.OptTools.dfJoint[].unique", "opt_tools.OptTools.dfJoint[].unique", "opt_tools.OptTools.dfJoint[].unique", "len", "len", "len", "len", "len", "len", "len", "len", "list", "len", "len", "len", "len", "len", "opt_tools.OptTools.dfJoint.groupby", "list"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.get_mask", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.get_mask", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.get_mask", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.get_mask", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.get_mask", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "set_features", "(", "self", ",", "D", "=", "[", "]", ",", "X", "=", "[", "]", ",", "Y", "=", "[", "]", ")", ":", "\n", "        ", "\"\"\"Set many features for the class\n\n        Args:\n            D (list): names of D features\n            X (list): names of X features\n            Y (list): names of Y features\n        \"\"\"", "\n", "\n", "self", ".", "D_features", "=", "D", "\n", "self", ".", "Y_features", "=", "Y", "\n", "self", ".", "X_features", "=", "X", "\n", "\n", "# Get values for Pandas multindex", "\n", "self", ".", "D_values", "=", "[", "self", ".", "dfJoint", "[", "feature", "]", ".", "unique", "(", ")", ".", "tolist", "(", ")", "\n", "for", "feature", "in", "self", ".", "D_features", "]", "\n", "self", ".", "Y_values", "=", "[", "self", ".", "dfJoint", "[", "feature", "]", ".", "unique", "(", ")", ".", "tolist", "(", ")", "\n", "for", "feature", "in", "self", ".", "Y_features", "]", "\n", "self", ".", "X_values", "=", "[", "self", ".", "dfJoint", "[", "feature", "]", ".", "unique", "(", ")", ".", "tolist", "(", ")", "\n", "for", "feature", "in", "self", ".", "X_features", "]", "\n", "\n", "# Create multindex for mapping dataframe", "\n", "self", ".", "DXY_features", "=", "self", ".", "D_features", "+", "self", ".", "X_features", "+", "self", ".", "Y_features", "\n", "self", ".", "DXY_values", "=", "self", ".", "D_values", "+", "self", ".", "X_values", "+", "self", ".", "Y_values", "\n", "self", ".", "DXY_index", "=", "pd", ".", "MultiIndex", ".", "from_product", "(", "self", ".", "DXY_values", ",", "\n", "names", "=", "self", ".", "DXY_features", ")", "\n", "\n", "# Create multindex for distortion dataframe", "\n", "self", ".", "XY_features", "=", "self", ".", "X_features", "+", "self", ".", "Y_features", "\n", "self", ".", "XY_values", "=", "self", ".", "X_values", "+", "self", ".", "Y_values", "\n", "self", ".", "XY_index", "=", "pd", ".", "MultiIndex", ".", "from_product", "(", "self", ".", "XY_values", ",", "\n", "names", "=", "self", ".", "XY_features", ")", "\n", "\n", "# Initialize mapping dataframe", "\n", "self", ".", "dfP", "=", "pd", ".", "DataFrame", "(", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "DXY_index", ")", ",", "\n", "len", "(", "self", ".", "XY_index", ")", ")", ")", ",", "\n", "index", "=", "self", ".", "DXY_index", ",", "columns", "=", "self", ".", "XY_index", ")", "\n", "\n", "# Initialize distortion dataframe", "\n", "self", ".", "dfD", "=", "pd", ".", "DataFrame", "(", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "XY_index", ")", ",", "\n", "len", "(", "self", ".", "XY_index", ")", ")", ")", ",", "\n", "index", "=", "self", ".", "XY_index", ".", "copy", "(", ")", ",", "\n", "columns", "=", "self", ".", "XY_index", ".", "copy", "(", ")", ")", "\n", "\n", "###", "\n", "# Generate masks for recovering marginals", "\n", "###", "\n", "self", ".", "dfPxyd", "=", "pd", ".", "DataFrame", "(", "index", "=", "self", ".", "dfP", ".", "index", ",", "columns", "=", "[", "'Frequency'", "]", ")", "\n", "index_list", "=", "[", "list", "(", "x", ")", "for", "x", "in", "self", ".", "dfPxyd", ".", "index", ".", "tolist", "(", ")", "]", "\n", "\n", "# find corresponding frequency value", "\n", "i", "=", "0", "\n", "for", "comb", "in", "self", ".", "dfJoint", "[", "self", ".", "DXY_features", "]", ".", "values", ".", "tolist", "(", ")", ":", "\n", "# get the entry corresponding to the combination", "\n", "            ", "idx", "=", "index_list", ".", "index", "(", "comb", ")", "\n", "# add marginal to list", "\n", "self", ".", "dfPxyd", ".", "iloc", "[", "idx", ",", "0", "]", "=", "self", ".", "dfJoint", ".", "loc", "[", "i", ",", "'Frequency'", "]", "\n", "i", "+=", "1", "\n", "\n", "# create mask that reduces Pxyd to Pxy", "\n", "# so Pxyd.dot(dfMask1) = Pxy", "\n", "", "self", ".", "dfMask_Pxyd_to_Pxy", "=", "pd", ".", "DataFrame", "(", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "dfP", ")", ",", "\n", "len", "(", "self", ".", "dfD", ")", ")", ")", ",", "\n", "index", "=", "self", ".", "dfP", ".", "index", ",", "\n", "columns", "=", "self", ".", "dfD", ".", "index", ")", "\n", "self", ".", "dfMask_Pxyd_to_Pxy", "=", "self", ".", "get_mask", "(", "self", ".", "dfMask_Pxyd_to_Pxy", ")", "\n", "\n", "# compute mask that reduces Pxyd to Pyd", "\n", "self", ".", "YD_features_index", "=", "self", ".", "dfJoint", ".", "groupby", "(", "\n", "self", ".", "Y_features", "+", "self", ".", "D_features", ")", "[", "'Frequency'", "]", ".", "sum", "(", ")", ".", "index", "\n", "self", ".", "dfMask_Pxyd_to_Pyd", "=", "pd", ".", "DataFrame", "(", "\n", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "dfP", ")", ",", "len", "(", "self", ".", "YD_features_index", ")", ")", ")", ",", "\n", "index", "=", "self", ".", "dfP", ".", "index", ",", "columns", "=", "self", ".", "YD_features_index", ")", "\n", "self", ".", "dfMask_Pxyd_to_Pyd", "=", "self", ".", "get_mask", "(", "self", ".", "dfMask_Pxyd_to_Pyd", ")", "\n", "\n", "# get  matrix for p_yd, with y varying in the columns", "\n", "self", ".", "dfD_to_Y_address", "=", "pd", ".", "Series", "(", "\n", "range", "(", "len", "(", "list", "(", "self", ".", "dfMask_Pxyd_to_Pyd", ")", ")", ")", ",", "\n", "index", "=", "self", ".", "dfMask_Pxyd_to_Pyd", ".", "columns", ")", "\n", "# print(self.dfD_to_Y_address, self.dfD_to_Y_address.shape)", "\n", "self", ".", "dfD_to_Y_address", "=", "pd", ".", "pivot_table", "(", "\n", "self", ".", "dfD_to_Y_address", ".", "reset_index", "(", ")", ",", "columns", "=", "self", ".", "D_features", ",", "\n", "index", "=", "self", ".", "Y_features", ",", "values", "=", "0", ")", "\n", "\n", "# compute mask that reduces Pxyd to Py", "\n", "self", ".", "y_index", "=", "self", ".", "dfD_to_Y_address", ".", "index", "\n", "self", ".", "dfMask_Pxyd_to_Py", "=", "pd", ".", "DataFrame", "(", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "dfP", ")", ",", "\n", "len", "(", "self", ".", "y_index", ")", ")", ")", ",", "\n", "index", "=", "self", ".", "dfP", ".", "index", ",", "\n", "columns", "=", "self", ".", "y_index", ")", "\n", "self", ".", "dfMask_Pxyd_to_Py", "=", "self", ".", "get_mask", "(", "self", ".", "dfMask_Pxyd_to_Py", ")", "\n", "\n", "# compute mask that reduces Pxy to Py", "\n", "self", ".", "dfMask_Pxy_to_Py", "=", "pd", ".", "DataFrame", "(", "np", ".", "zeros", "(", "(", "len", "(", "list", "(", "self", ".", "dfP", ")", ")", ",", "\n", "len", "(", "self", ".", "y_index", ")", ")", ")", ",", "\n", "index", "=", "self", ".", "dfP", ".", "columns", ",", "\n", "columns", "=", "self", ".", "y_index", ")", "\n", "self", ".", "dfMask_Pxy_to_Py", "=", "self", ".", "get_mask", "(", "self", ".", "dfMask_Pxy_to_Py", ")", "\n", "\n", "# compute mask that reduces Pxyd to Pd", "\n", "self", ".", "dfMask_Pxyd_to_Pd", "=", "pd", ".", "DataFrame", "(", "\n", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "dfP", ")", ",", "self", ".", "dfD_to_Y_address", ".", "shape", "[", "1", "]", ")", ")", ",", "\n", "index", "=", "self", ".", "dfP", ".", "index", ",", "columns", "=", "self", ".", "dfD_to_Y_address", ".", "columns", ")", "\n", "self", ".", "dfMask_Pxyd_to_Pd", "=", "self", ".", "get_mask", "(", "self", ".", "dfMask_Pxyd_to_Pd", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.set_distortion": [[253, 296], ["opt_tools.OptTools.dfD.index.tolist", "opt_tools.OptTools.dfD.columns.tolist", "range", "range", "range", "numpy.zeros", "len", "range", "get_distortion", "range", "range", "range", "range", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "set_distortion", "(", "self", ",", "get_distortion", ",", "clist", "=", "[", "]", ")", ":", "\n", "        ", "\"\"\"Create distortion and constraint matrices\n        Args:\n            get_distortion (function): Distortion function name\n                (See optim_preproc_helper.get_distortion for an example)\n            clist (list): Distance thresholds for individual distortion\n        \"\"\"", "\n", "\n", "# set constraint list", "\n", "self", ".", "clist", "=", "clist", "\n", "\n", "# create row dictionay (rows represent old values)", "\n", "# this will make it easier to compute distrotion metric", "\n", "rows_tuple", "=", "self", ".", "dfD", ".", "index", ".", "tolist", "(", ")", "\n", "rows_dict", "=", "[", "{", "self", ".", "XY_features", "[", "i", "]", ":", "t", "[", "i", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "XY_features", ")", ")", "}", "for", "t", "in", "rows_tuple", "]", "\n", "\n", "# create columns dictionay (columns represent new values)", "\n", "cols_tuple", "=", "self", ".", "dfD", ".", "columns", ".", "tolist", "(", ")", "\n", "cols_dict", "=", "[", "{", "self", ".", "XY_features", "[", "i", "]", ":", "t", "[", "i", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "XY_features", ")", ")", "}", "for", "t", "in", "cols_tuple", "]", "\n", "\n", "# Create distortion matrix", "\n", "for", "i", "in", "range", "(", "self", ".", "dfD", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "old_values", "=", "rows_dict", "[", "i", "]", "\n", "for", "j", "in", "range", "(", "self", ".", "dfD", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "new_values", "=", "cols_dict", "[", "j", "]", "\n", "self", ".", "dfD", ".", "iat", "[", "i", ",", "j", "]", "=", "get_distortion", "(", "old_values", ",", "new_values", ")", "\n", "\n", "", "", "Dmatrix", "=", "self", ".", "dfD", ".", "values", "\n", "\n", "# Create constraint matrix list for excess distortion", "\n", "# since old values index the rows, we go through the D matrix line by", "\n", "# line, marking as 1 events where the threshold is violated. This will", "\n", "# be multiplied by the probability matrix, resulting in the excess", "\n", "# distortion metric", "\n", "self", ".", "CMlist", "=", "[", "np", ".", "zeros", "(", "Dmatrix", ".", "shape", ")", "for", "i", "in", "range", "(", "len", "(", "self", ".", "clist", ")", ")", "]", "\n", "for", "x", "in", "range", "(", "len", "(", "self", ".", "CMlist", ")", ")", ":", "\n", "            ", "c", "=", "self", ".", "clist", "[", "x", "]", "\n", "for", "i", "in", "range", "(", "Dmatrix", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "Dmatrix", ".", "shape", "[", "1", "]", ")", ":", "\n", "                    ", "if", "Dmatrix", "[", "i", ",", "j", "]", ">=", "c", ":", "\n", "                        ", "self", ".", "CMlist", "[", "x", "]", "[", "i", ",", "j", "]", "=", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.optimize": [[297, 398], ["cvxpy.Variable", "cvxpy.Variable", "cvxpy.Variable", "[].sum", "constraints.append", "constraints.append", "constraints.append", "range", "range", "cvxpy.Minimize", "cvxpy.Problem", "cvxpy.Problem.solve", "range", "PxydMarginal.dot", "PxydMarginal.dot", "numpy.nan_to_num().dot().dot", "len", "constraints.append", "range", "print", "RuntimeError", "len", "opt_tools.OptTools.const.append", "pandas.concat().fillna", "cvxpy.sum", "numpy.diag", "constraints.append", "constraints.append", "cvxpy.norm", "cvxpy.sum().value.max", "opt_tools.OptTools.dfJoint.groupby", "cvxpy.sum", "numpy.nan_to_num().dot", "cvxpy.sum", "pandas.concat", "numpy.diag().dot().dot", "cvxpy.multiply", "numpy.diag", "numpy.diag", "numpy.nan_to_num", "cvxpy.sum", "numpy.diag().dot", "numpy.diag", "cvxpy.multiply", "numpy.diag", "numpy.ravel"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "", "", "", "", "def", "optimize", "(", "self", ",", "epsilon", "=", "1.", ",", "dlist", "=", "[", "]", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"Main optimization routine to estimate the pre-processing\n        transformation.\n\n        The particular formulation implemented here is:\n        1. l1 distance between input and transformed distributions\n        2. \"Excess distortion constraint\" - eqn 5 in paper.\n        3. Discrimination constraints for all combinations of groups specified\n           (there is no distinction between protected and unprotected groups).\n           The constraints are given in eqn 2, 3 in the paper. We use a single\n           /\\epsilon value for all combinations of y and d values\n\n        See section 4.3 in supplementary material of the paper for an example\n\n        Args:\n            epsilon (float): Distance thresholds for individual distortion\n            dlist (list): Probability bounds given in eq. 5 of the paper for\n                each threshold in clist\n            verbose (bool): Verbosity flag\n        \"\"\"", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "dlist", "=", "dlist", "\n", "\n", "# main conditional map", "\n", "Pmap", "=", "Variable", "(", "(", "self", ".", "dfP", ".", "shape", "[", "0", "]", ",", "self", ".", "dfP", ".", "shape", "[", "1", "]", ")", ")", "\n", "# marginal distribution of (Xh Yh)", "\n", "PXhYh", "=", "Variable", "(", "(", "self", ".", "dfMask_Pxyd_to_Pxy", ".", "shape", "[", "1", "]", ",", ")", ")", "\n", "# rows represent p_(y|D)", "\n", "PYhgD", "=", "Variable", "(", "(", "self", ".", "dfD_to_Y_address", ".", "shape", "[", "1", "]", ",", "\n", "self", ".", "dfD_to_Y_address", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "# marginal distribution", "\n", "dfMarginal", "=", "self", ".", "dfJoint", ".", "groupby", "(", "self", ".", "DXY_features", ")", "[", "'Frequency'", "]", ".", "sum", "(", ")", "\n", "PxydMarginal", "=", "pd", ".", "concat", "(", "[", "self", ".", "dfP", ",", "dfMarginal", "]", ",", "\n", "axis", "=", "1", ")", ".", "fillna", "(", "0", ")", "[", "'Frequency'", "]", ".", "values", "\n", "self", ".", "PxydMarginal", "=", "PxydMarginal", "\n", "PdMarginal", "=", "PxydMarginal", ".", "dot", "(", "self", ".", "dfMask_Pxyd_to_Pd", ")", ".", "T", "\n", "PxyMarginal", "=", "PxydMarginal", ".", "dot", "(", "self", ".", "dfMask_Pxyd_to_Pxy", ")", ".", "T", "\n", "\n", "# add constraints", "\n", "# 1. valid distribution", "\n", "constraints", "=", "[", "cp", ".", "sum", "(", "Pmap", ",", "axis", "=", "1", ")", "==", "1", "]", "\n", "constraints", ".", "append", "(", "Pmap", ">=", "0", ")", "\n", "\n", "# 2. definition of marginal PxhYh", "\n", "constraints", ".", "append", "(", "PXhYh", "==", "cp", ".", "sum", "(", "np", ".", "diag", "(", "PxydMarginal", ")", "*", "Pmap", ",", "\n", "axis", "=", "0", ")", ".", "T", ")", "\n", "\n", "# add the conditional mapping", "\n", "constraints", ".", "append", "(", "\n", "PYhgD", "==", "np", ".", "diag", "(", "np", ".", "ravel", "(", "PdMarginal", ")", "**", "(", "-", "1", ")", ")", ".", "dot", "(", "\n", "self", ".", "dfMask_Pxyd_to_Pd", ".", "values", ".", "T", ")", ".", "dot", "(", "\n", "np", ".", "diag", "(", "PxydMarginal", ")", ")", "*", "\n", "Pmap", "*", "self", ".", "dfMask_Pxy_to_Py", ".", "values", ")", "\n", "\n", "# 3. add excess distorion", "\n", "# print(PxyMarginal)", "\n", "# Pxy_xhyh = np.nan_to_num(np.diag(PxyMarginal**(-1))).dot(self.dfMask_Pxyd_to_Pxy.values.T).dot(np.diag(PxydMarginal))*Pmap", "\n", "Pxy_xhyh", "=", "np", ".", "nan_to_num", "(", "np", ".", "diag", "(", "(", "PxyMarginal", "+", "1e-10", ")", "**", "(", "-", "1", ")", ")", ")", ".", "dot", "(", "\n", "self", ".", "dfMask_Pxyd_to_Pxy", ".", "values", ".", "T", ")", ".", "dot", "(", "\n", "np", ".", "diag", "(", "PxydMarginal", "+", "1e-10", ")", ")", "*", "Pmap", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "CMlist", ")", ")", ":", "\n", "            ", "constraints", ".", "append", "(", "\n", "cp", ".", "sum", "(", "cp", ".", "multiply", "(", "self", ".", "CMlist", "[", "i", "]", ",", "Pxy_xhyh", ")", ",", "axis", "=", "1", ")", "<=", "\n", "self", ".", "dlist", "[", "i", "]", ")", "\n", "\n", "# 4. Discrimination control", "\n", "", "for", "d", "in", "range", "(", "self", ".", "dfMask_Pxyd_to_Pd", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "for", "d2", "in", "range", "(", "self", ".", "dfMask_Pxyd_to_Pd", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "if", "d", ">", "d2", ":", "\n", "                    ", "continue", "\n", "# constraints.append(PYhgD[d,:].T<=PYhgD[d2,:].T*(1+self.epsilon))", "\n", "# constraints.append(PYhgD[d2,:].T<=PYhgD[d,:].T*(1+self.epsilon))", "\n", "", "constraints", ".", "append", "(", "\n", "PYhgD", "[", "d", ",", ":", "]", ".", "T", "-", "PYhgD", "[", "d2", ",", ":", "]", ".", "T", "<=", "self", ".", "epsilon", ")", "\n", "constraints", ".", "append", "(", "\n", "PYhgD", "[", "d2", ",", ":", "]", ".", "T", "-", "PYhgD", "[", "d", ",", ":", "]", ".", "T", "<=", "self", ".", "epsilon", ")", "\n", "\n", "# 5. Objective is l1 distance between the original", "\n", "# and perturbed distributions", "\n", "", "", "obj", "=", "Minimize", "(", "cp", ".", "norm", "(", "PXhYh", "-", "PxyMarginal", ",", "1", ")", "/", "2", ")", "\n", "\n", "prob", "=", "Problem", "(", "obj", ",", "constraints", ")", "\n", "prob", ".", "solve", "(", "verbose", "=", "verbose", ")", "\n", "\n", "if", "prob", ".", "status", "in", "[", "\"optimal\"", ",", "\"optimal_inaccurate\"", "]", ":", "\n", "            ", "print", "(", "\"Optimized Preprocessing: Objective converged to %f\"", "\n", "%", "(", "prob", ".", "value", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Optimized Preprocessing: Optimization did not \"", "\n", "\"converge\"", ")", "\n", "\n", "", "self", ".", "dfP", ".", "loc", "[", ":", ",", ":", "]", "=", "Pmap", ".", "value", "\n", "self", ".", "optimum", "=", "prob", ".", "value", "\n", "self", ".", "const", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "CMlist", ")", ")", ":", "\n", "            ", "self", ".", "const", ".", "append", "(", "\n", "cp", ".", "sum", "(", "cp", ".", "multiply", "(", "self", ".", "CMlist", "[", "i", "]", ",", "Pxy_xhyh", ")", ",", "\n", "axis", "=", "1", ")", ".", "value", ".", "max", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.opt_tools.OptTools.compute_marginals": [[399, 431], ["pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "[].sum().unstack", "opt_tools.OptTools.dfPxygdPrior.div", "numpy.diag().dot", "numpy.diag().dot().dot().dot", "opt_tools.OptTools.dfPxygdPrior.sum", "opt_tools.OptTools.PxydMarginal.dot", "opt_tools.OptTools.PxydMarginal.dot", "opt_tools.OptTools.PxydMarginal.dot", "[].sum", "numpy.diag", "numpy.diag().dot().dot", "numpy.diag().dot", "opt_tools.OptTools.dfPxydMarginal.reset_index().groupby", "numpy.diag", "opt_tools.OptTools.dfPxydMarginal.reset_index", "numpy.ravel"], "methods", ["None"], ["", "", "def", "compute_marginals", "(", "self", ")", ":", "\n", "        ", "\"\"\"Compute a bunch of required marginal distributions.\"\"\"", "\n", "\n", "self", ".", "dfFull", "=", "pd", ".", "DataFrame", "(", "\n", "(", "np", ".", "diag", "(", "self", ".", "PxydMarginal", ")", ")", ".", "dot", "(", "self", ".", "dfP", ".", "values", ")", ",", "\n", "index", "=", "self", ".", "dfP", ".", "index", ",", "columns", "=", "self", ".", "dfP", ".", "columns", ")", "\n", "\n", "self", ".", "dfPyMarginal", "=", "pd", ".", "DataFrame", "(", "\n", "self", ".", "PxydMarginal", ".", "dot", "(", "self", ".", "dfMask_Pxyd_to_Py", ")", ".", "T", ",", "\n", "index", "=", "self", ".", "dfMask_Pxyd_to_Py", ".", "columns", ")", "\n", "self", ".", "dfPdMarginal", "=", "pd", ".", "DataFrame", "(", "\n", "self", ".", "PxydMarginal", ".", "dot", "(", "self", ".", "dfMask_Pxyd_to_Pd", ")", ".", "T", ",", "\n", "index", "=", "self", ".", "dfMask_Pxyd_to_Pd", ".", "columns", ")", "\n", "self", ".", "dfPxyMarginal", "=", "pd", ".", "DataFrame", "(", "\n", "self", ".", "PxydMarginal", ".", "dot", "(", "self", ".", "dfMask_Pxyd_to_Pxy", ")", ".", "T", ",", "\n", "index", "=", "self", ".", "dfMask_Pxyd_to_Pxy", ".", "columns", ")", "\n", "\n", "self", ".", "dfPyhgD", "=", "pd", ".", "DataFrame", "(", "\n", "np", ".", "diag", "(", "np", ".", "ravel", "(", "self", ".", "dfPdMarginal", ".", "values", ")", "**", "(", "-", "1", ")", ")", ".", "dot", "(", "\n", "self", ".", "dfMask_Pxyd_to_Pd", ".", "values", ".", "T", ")", ".", "dot", "(", "\n", "self", ".", "dfFull", ".", "values", ")", ".", "dot", "(", "\n", "self", ".", "dfMask_Pxy_to_Py", ".", "values", ")", ",", "\n", "index", "=", "self", ".", "dfPdMarginal", ".", "index", ",", "\n", "columns", "=", "self", ".", "dfMask_Pxy_to_Py", ".", "columns", ")", "\n", "\n", "self", ".", "dfPxydMarginal", "=", "pd", ".", "DataFrame", "(", "self", ".", "PxydMarginal", ",", "\n", "index", "=", "self", ".", "dfMask_Pxyd_to_Pxy", ".", "index", ")", "\n", "\n", "self", ".", "dfPxygdPrior", "=", "self", ".", "dfPxydMarginal", ".", "reset_index", "(", ")", ".", "groupby", "(", "\n", "self", ".", "D_features", "+", "self", ".", "Y_features", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "unstack", "(", "self", ".", "Y_features", ")", "\n", "self", ".", "dfPxygdPrior", "=", "self", ".", "dfPxygdPrior", ".", "div", "(", "self", ".", "dfPxygdPrior", ".", "sum", "(", "axis", "=", "1", ")", ",", "\n", "axis", "=", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.data_preproc_functions.load_preproc_data_adult": [[5, 90], ["list", "aif360.datasets.AdultDataset", "df[].apply", "df[].apply", "df[].astype", "df[].apply", "df[].replace", "df[].replace", "df[].replace", "df[].apply", "pd.concat.sample", "df_0.sample.sample", "df_1.sample.sample", "pandas.concat", "set", "set", "group_edu"], "function", ["None"], ["def", "load_preproc_data_adult", "(", "protected_attributes", "=", "None", ",", "sub_samp", "=", "False", ",", "balance", "=", "False", ")", ":", "\n", "    ", "def", "custom_preprocessing", "(", "df", ")", ":", "\n", "        ", "\"\"\"The custom pre-processing function is adapted from\n            https://github.com/fair-preprocessing/nips2017/blob/master/Adult/code/Generate_Adult_Data.ipynb\n            If sub_samp != False, then return smaller version of dataset truncated to tiny_test data points.\n        \"\"\"", "\n", "\n", "# Group age by decade", "\n", "df", "[", "'Age (decade)'", "]", "=", "df", "[", "'age'", "]", ".", "apply", "(", "lambda", "x", ":", "x", "//", "10", "*", "10", ")", "\n", "# df['Age (decade)'] = df['age'].apply(lambda x: np.floor(x/10.0)*10.0)", "\n", "\n", "def", "group_edu", "(", "x", ")", ":", "\n", "            ", "if", "x", "<=", "5", ":", "\n", "                ", "return", "'<6'", "\n", "", "elif", "x", ">=", "13", ":", "\n", "                ", "return", "'>12'", "\n", "", "else", ":", "\n", "                ", "return", "x", "\n", "\n", "", "", "def", "age_cut", "(", "x", ")", ":", "\n", "            ", "if", "x", ">=", "70", ":", "\n", "                ", "return", "'>=70'", "\n", "", "else", ":", "\n", "                ", "return", "x", "\n", "\n", "", "", "def", "group_race", "(", "x", ")", ":", "\n", "            ", "if", "x", "==", "\"White\"", ":", "\n", "                ", "return", "1.0", "\n", "", "else", ":", "\n", "                ", "return", "0.0", "\n", "\n", "# Cluster education and age attributes.", "\n", "# Limit education range", "\n", "", "", "df", "[", "'Education Years'", "]", "=", "df", "[", "'education-num'", "]", ".", "apply", "(", "lambda", "x", ":", "group_edu", "(", "x", ")", ")", "\n", "df", "[", "'Education Years'", "]", "=", "df", "[", "'Education Years'", "]", ".", "astype", "(", "'category'", ")", "\n", "\n", "# Limit age range", "\n", "df", "[", "'Age (decade)'", "]", "=", "df", "[", "'Age (decade)'", "]", ".", "apply", "(", "lambda", "x", ":", "age_cut", "(", "x", ")", ")", "\n", "\n", "# Rename income variable", "\n", "df", "[", "'Income Binary'", "]", "=", "df", "[", "'income-per-year'", "]", "\n", "df", "[", "'Income Binary'", "]", "=", "df", "[", "'Income Binary'", "]", ".", "replace", "(", "to_replace", "=", "'>50K.'", ",", "value", "=", "'>50K'", ",", "regex", "=", "True", ")", "\n", "df", "[", "'Income Binary'", "]", "=", "df", "[", "'Income Binary'", "]", ".", "replace", "(", "to_replace", "=", "'<=50K.'", ",", "value", "=", "'<=50K'", ",", "regex", "=", "True", ")", "\n", "\n", "# Recode sex and race", "\n", "df", "[", "'sex'", "]", "=", "df", "[", "'sex'", "]", ".", "replace", "(", "{", "'Female'", ":", "0.0", ",", "'Male'", ":", "1.0", "}", ")", "\n", "df", "[", "'race'", "]", "=", "df", "[", "'race'", "]", ".", "apply", "(", "lambda", "x", ":", "group_race", "(", "x", ")", ")", "\n", "\n", "if", "sub_samp", "and", "not", "balance", ":", "\n", "            ", "df", "=", "df", ".", "sample", "(", "sub_samp", ")", "\n", "", "if", "sub_samp", "and", "balance", ":", "\n", "            ", "df_0", "=", "df", "[", "df", "[", "'Income Binary'", "]", "==", "'<=50K'", "]", "\n", "df_1", "=", "df", "[", "df", "[", "'Income Binary'", "]", "==", "'>50K'", "]", "\n", "df_0", "=", "df_0", ".", "sample", "(", "int", "(", "sub_samp", "/", "2", ")", ")", "\n", "df_1", "=", "df_1", ".", "sample", "(", "int", "(", "sub_samp", "/", "2", ")", ")", "\n", "df", "=", "pd", ".", "concat", "(", "[", "df_0", ",", "df_1", "]", ")", "\n", "", "return", "df", "\n", "\n", "", "XD_features", "=", "[", "'Age (decade)'", ",", "'Education Years'", ",", "'sex'", ",", "'race'", "]", "\n", "D_features", "=", "[", "'sex'", ",", "'race'", "]", "if", "protected_attributes", "is", "None", "else", "protected_attributes", "\n", "Y_features", "=", "[", "'Income Binary'", "]", "\n", "X_features", "=", "list", "(", "set", "(", "XD_features", ")", "-", "set", "(", "D_features", ")", ")", "\n", "categorical_features", "=", "[", "'Age (decade)'", ",", "'Education Years'", "]", "\n", "\n", "# privileged classes", "\n", "all_privileged_classes", "=", "{", "\"sex\"", ":", "[", "1.0", "]", ",", "\n", "\"race\"", ":", "[", "1.0", "]", "}", "\n", "\n", "# protected attribute maps", "\n", "all_protected_attribute_maps", "=", "{", "\"sex\"", ":", "{", "1.0", ":", "'Male'", ",", "0.0", ":", "'Female'", "}", ",", "\n", "\"race\"", ":", "{", "1.0", ":", "'White'", ",", "0.0", ":", "'Non-white'", "}", "}", "\n", "\n", "return", "AdultDataset", "(", "\n", "label_name", "=", "Y_features", "[", "0", "]", ",", "\n", "favorable_classes", "=", "[", "'>50K'", ",", "'>50K.'", "]", ",", "\n", "protected_attribute_names", "=", "D_features", ",", "\n", "privileged_classes", "=", "[", "all_privileged_classes", "[", "x", "]", "for", "x", "in", "D_features", "]", ",", "\n", "instance_weights_name", "=", "None", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "X_features", "+", "Y_features", "+", "D_features", ",", "\n", "na_values", "=", "[", "'?'", "]", ",", "\n", "metadata", "=", "{", "'label_maps'", ":", "[", "{", "1.0", ":", "'>50K'", ",", "0.0", ":", "'<=50K'", "}", "]", ",", "\n", "'protected_attribute_maps'", ":", "[", "all_protected_attribute_maps", "[", "x", "]", "\n", "for", "x", "in", "D_features", "]", "}", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.data_preproc_functions.load_preproc_data_compas": [[91, 203], ["list", "aif360.datasets.CompasDataset", "dfcut[].copy", "dfcutQ[].apply", "dfcutQ[].apply", "dfcutQ[].apply", "dfcutQ[].apply", "dfcutQ[].replace", "dfcutQ[].apply", "set", "set", "quantizePrior"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "load_preproc_data_compas", "(", "protected_attributes", "=", "None", ")", ":", "\n", "    ", "def", "custom_preprocessing", "(", "df", ")", ":", "\n", "        ", "\"\"\"The custom pre-processing function is adapted from\n            https://github.com/fair-preprocessing/nips2017/blob/master/compas/code/Generate_Compas_Data.ipynb\n        \"\"\"", "\n", "\n", "df", "=", "df", "[", "[", "'age'", ",", "'c_charge_degree'", ",", "'race'", ",", "'age_cat'", ",", "'score_text'", ",", "\n", "'sex'", ",", "'priors_count'", ",", "'days_b_screening_arrest'", ",", "'decile_score'", ",", "\n", "'is_recid'", ",", "'two_year_recid'", ",", "'c_jail_in'", ",", "'c_jail_out'", "]", "]", "\n", "\n", "# Indices of data samples to keep", "\n", "ix", "=", "df", "[", "'days_b_screening_arrest'", "]", "<=", "30", "\n", "ix", "=", "(", "df", "[", "'days_b_screening_arrest'", "]", ">=", "-", "30", ")", "&", "ix", "\n", "ix", "=", "(", "df", "[", "'is_recid'", "]", "!=", "-", "1", ")", "&", "ix", "\n", "ix", "=", "(", "df", "[", "'c_charge_degree'", "]", "!=", "\"O\"", ")", "&", "ix", "\n", "ix", "=", "(", "df", "[", "'score_text'", "]", "!=", "'N/A'", ")", "&", "ix", "\n", "df", "=", "df", ".", "loc", "[", "ix", ",", ":", "]", "\n", "df", "[", "'length_of_stay'", "]", "=", "(", "pd", ".", "to_datetime", "(", "df", "[", "'c_jail_out'", "]", ")", "-", "\n", "pd", ".", "to_datetime", "(", "df", "[", "'c_jail_in'", "]", ")", ")", ".", "apply", "(", "\n", "lambda", "x", ":", "x", ".", "days", ")", "\n", "\n", "# Restrict races to African-American and Caucasian", "\n", "dfcut", "=", "df", ".", "loc", "[", "~", "df", "[", "'race'", "]", ".", "isin", "(", "[", "'Native American'", ",", "'Hispanic'", ",", "'Asian'", ",", "'Other'", "]", ")", ",", ":", "]", "\n", "\n", "# Restrict the features to use", "\n", "dfcutQ", "=", "dfcut", "[", "[", "'sex'", ",", "'race'", ",", "'age_cat'", ",", "'c_charge_degree'", ",", "'score_text'", ",", "'priors_count'", ",", "'is_recid'", ",", "\n", "'two_year_recid'", ",", "'length_of_stay'", "]", "]", ".", "copy", "(", ")", "\n", "\n", "# Quantize priors count between 0, 1-3, and >3", "\n", "def", "quantizePrior", "(", "x", ")", ":", "\n", "            ", "if", "x", "<=", "0", ":", "\n", "                ", "return", "'0'", "\n", "", "elif", "1", "<=", "x", "<=", "3", ":", "\n", "                ", "return", "'1 to 3'", "\n", "", "else", ":", "\n", "                ", "return", "'More than 3'", "\n", "\n", "# Quantize length of stay", "\n", "", "", "def", "quantizeLOS", "(", "x", ")", ":", "\n", "            ", "if", "x", "<=", "7", ":", "\n", "                ", "return", "'<week'", "\n", "", "if", "8", "<", "x", "<=", "93", ":", "\n", "                ", "return", "'<3months'", "\n", "", "else", ":", "\n", "                ", "return", "'>3 months'", "\n", "\n", "# Quantize length of stay", "\n", "", "", "def", "adjustAge", "(", "x", ")", ":", "\n", "            ", "if", "x", "==", "'25 - 45'", ":", "\n", "                ", "return", "'25 to 45'", "\n", "", "else", ":", "\n", "                ", "return", "x", "\n", "\n", "# Quantize score_text to MediumHigh", "\n", "", "", "def", "quantizeScore", "(", "x", ")", ":", "\n", "            ", "if", "(", "x", "==", "'High'", ")", "|", "(", "x", "==", "'Medium'", ")", ":", "\n", "                ", "return", "'MediumHigh'", "\n", "", "else", ":", "\n", "                ", "return", "x", "\n", "\n", "", "", "def", "group_race", "(", "x", ")", ":", "\n", "            ", "if", "x", "==", "\"Caucasian\"", ":", "\n", "                ", "return", "1.0", "\n", "", "else", ":", "\n", "                ", "return", "0.0", "\n", "\n", "", "", "dfcutQ", "[", "'priors_count'", "]", "=", "dfcutQ", "[", "'priors_count'", "]", ".", "apply", "(", "lambda", "x", ":", "quantizePrior", "(", "x", ")", ")", "\n", "dfcutQ", "[", "'length_of_stay'", "]", "=", "dfcutQ", "[", "'length_of_stay'", "]", ".", "apply", "(", "lambda", "x", ":", "quantizeLOS", "(", "x", ")", ")", "\n", "dfcutQ", "[", "'score_text'", "]", "=", "dfcutQ", "[", "'score_text'", "]", ".", "apply", "(", "lambda", "x", ":", "quantizeScore", "(", "x", ")", ")", "\n", "dfcutQ", "[", "'age_cat'", "]", "=", "dfcutQ", "[", "'age_cat'", "]", ".", "apply", "(", "lambda", "x", ":", "adjustAge", "(", "x", ")", ")", "\n", "\n", "# Recode sex and race", "\n", "dfcutQ", "[", "'sex'", "]", "=", "dfcutQ", "[", "'sex'", "]", ".", "replace", "(", "{", "'Female'", ":", "1.0", ",", "'Male'", ":", "0.0", "}", ")", "\n", "dfcutQ", "[", "'race'", "]", "=", "dfcutQ", "[", "'race'", "]", ".", "apply", "(", "lambda", "x", ":", "group_race", "(", "x", ")", ")", "\n", "\n", "features", "=", "[", "'two_year_recid'", ",", "\n", "'sex'", ",", "'race'", ",", "\n", "'age_cat'", ",", "'priors_count'", ",", "'c_charge_degree'", "]", "\n", "\n", "# Pass vallue to df", "\n", "df", "=", "dfcutQ", "[", "features", "]", "\n", "\n", "return", "df", "\n", "\n", "", "XD_features", "=", "[", "'age_cat'", ",", "'c_charge_degree'", ",", "'priors_count'", ",", "'sex'", ",", "'race'", "]", "\n", "D_features", "=", "[", "'sex'", ",", "'race'", "]", "if", "protected_attributes", "is", "None", "else", "protected_attributes", "\n", "Y_features", "=", "[", "'two_year_recid'", "]", "\n", "X_features", "=", "list", "(", "set", "(", "XD_features", ")", "-", "set", "(", "D_features", ")", ")", "\n", "categorical_features", "=", "[", "'age_cat'", ",", "'priors_count'", ",", "'c_charge_degree'", "]", "\n", "\n", "# privileged classes", "\n", "all_privileged_classes", "=", "{", "\"sex\"", ":", "[", "1.0", "]", ",", "\n", "\"race\"", ":", "[", "1.0", "]", "}", "\n", "\n", "# protected attribute maps", "\n", "all_protected_attribute_maps", "=", "{", "\"sex\"", ":", "{", "0.0", ":", "'Male'", ",", "1.0", ":", "'Female'", "}", ",", "\n", "\"race\"", ":", "{", "1.0", ":", "'Caucasian'", ",", "0.0", ":", "'Not Caucasian'", "}", "}", "\n", "\n", "\n", "return", "CompasDataset", "(", "\n", "label_name", "=", "Y_features", "[", "0", "]", ",", "\n", "favorable_classes", "=", "[", "0", "]", ",", "\n", "protected_attribute_names", "=", "D_features", ",", "\n", "privileged_classes", "=", "[", "all_privileged_classes", "[", "x", "]", "for", "x", "in", "D_features", "]", ",", "\n", "instance_weights_name", "=", "None", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "X_features", "+", "Y_features", "+", "D_features", ",", "\n", "na_values", "=", "[", "]", ",", "\n", "metadata", "=", "{", "'label_maps'", ":", "[", "{", "1.0", ":", "'Did recid.'", ",", "0.0", ":", "'No recid.'", "}", "]", ",", "\n", "'protected_attribute_maps'", ":", "[", "all_protected_attribute_maps", "[", "x", "]", "\n", "for", "x", "in", "D_features", "]", "}", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.data_preproc_functions.load_preproc_data_german": [[204, 300], ["list", "aif360.datasets.GermanDataset", "df[].replace", "df[].apply", "df[].apply", "df[].apply", "df[].apply", "df[].apply", "set", "set", "group_credit_hist"], "function", ["None"], ["", "def", "load_preproc_data_german", "(", "protected_attributes", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Load and pre-process german credit dataset.\n    Args:\n        protected_attributes(list or None): If None use all possible protected\n            attributes, else subset the protected attributes to the list.\n\n    Returns:\n        GermanDataset: An instance of GermanDataset with required pre-processing.\n\n    \"\"\"", "\n", "def", "custom_preprocessing", "(", "df", ")", ":", "\n", "        ", "\"\"\" Custom pre-processing for German Credit Data\n        \"\"\"", "\n", "\n", "def", "group_credit_hist", "(", "x", ")", ":", "\n", "            ", "if", "x", "in", "[", "'A30'", ",", "'A31'", ",", "'A32'", "]", ":", "\n", "                ", "return", "'None/Paid'", "\n", "", "elif", "x", "==", "'A33'", ":", "\n", "                ", "return", "'Delay'", "\n", "", "elif", "x", "==", "'A34'", ":", "\n", "                ", "return", "'Other'", "\n", "", "else", ":", "\n", "                ", "return", "'NA'", "\n", "\n", "", "", "def", "group_employ", "(", "x", ")", ":", "\n", "            ", "if", "x", "==", "'A71'", ":", "\n", "                ", "return", "'Unemployed'", "\n", "", "elif", "x", "in", "[", "'A72'", ",", "'A73'", "]", ":", "\n", "                ", "return", "'1-4 years'", "\n", "", "elif", "x", "in", "[", "'A74'", ",", "'A75'", "]", ":", "\n", "                ", "return", "'4+ years'", "\n", "", "else", ":", "\n", "                ", "return", "'NA'", "\n", "\n", "", "", "def", "group_savings", "(", "x", ")", ":", "\n", "            ", "if", "x", "in", "[", "'A61'", ",", "'A62'", "]", ":", "\n", "                ", "return", "'<500'", "\n", "", "elif", "x", "in", "[", "'A63'", ",", "'A64'", "]", ":", "\n", "                ", "return", "'500+'", "\n", "", "elif", "x", "==", "'A65'", ":", "\n", "                ", "return", "'Unknown/None'", "\n", "", "else", ":", "\n", "                ", "return", "'NA'", "\n", "\n", "", "", "def", "group_status", "(", "x", ")", ":", "\n", "            ", "if", "x", "in", "[", "'A11'", ",", "'A12'", "]", ":", "\n", "                ", "return", "'<200'", "\n", "", "elif", "x", "in", "[", "'A13'", "]", ":", "\n", "                ", "return", "'200+'", "\n", "", "elif", "x", "==", "'A14'", ":", "\n", "                ", "return", "'None'", "\n", "", "else", ":", "\n", "                ", "return", "'NA'", "\n", "\n", "", "", "status_map", "=", "{", "'A91'", ":", "1.0", ",", "'A93'", ":", "1.0", ",", "'A94'", ":", "1.0", ",", "\n", "'A92'", ":", "0.0", ",", "'A95'", ":", "0.0", "}", "\n", "df", "[", "'sex'", "]", "=", "df", "[", "'personal_status'", "]", ".", "replace", "(", "status_map", ")", "\n", "\n", "\n", "# group credit history, savings, and employment", "\n", "df", "[", "'credit_history'", "]", "=", "df", "[", "'credit_history'", "]", ".", "apply", "(", "lambda", "x", ":", "group_credit_hist", "(", "x", ")", ")", "\n", "df", "[", "'savings'", "]", "=", "df", "[", "'savings'", "]", ".", "apply", "(", "lambda", "x", ":", "group_savings", "(", "x", ")", ")", "\n", "df", "[", "'employment'", "]", "=", "df", "[", "'employment'", "]", ".", "apply", "(", "lambda", "x", ":", "group_employ", "(", "x", ")", ")", "\n", "df", "[", "'age'", "]", "=", "df", "[", "'age'", "]", ".", "apply", "(", "lambda", "x", ":", "np", ".", "float", "(", "x", ">=", "26", ")", ")", "\n", "df", "[", "'status'", "]", "=", "df", "[", "'status'", "]", ".", "apply", "(", "lambda", "x", ":", "group_status", "(", "x", ")", ")", "\n", "\n", "return", "df", "\n", "\n", "# Feature partitions", "\n", "", "XD_features", "=", "[", "'credit_history'", ",", "'savings'", ",", "'employment'", ",", "'sex'", ",", "'age'", "]", "\n", "D_features", "=", "[", "'sex'", ",", "'age'", "]", "if", "protected_attributes", "is", "None", "else", "protected_attributes", "\n", "Y_features", "=", "[", "'credit'", "]", "\n", "X_features", "=", "list", "(", "set", "(", "XD_features", ")", "-", "set", "(", "D_features", ")", ")", "\n", "categorical_features", "=", "[", "'credit_history'", ",", "'savings'", ",", "'employment'", "]", "\n", "\n", "# privileged classes", "\n", "all_privileged_classes", "=", "{", "\"sex\"", ":", "[", "1.0", "]", ",", "\n", "\"age\"", ":", "[", "1.0", "]", "}", "\n", "\n", "# protected attribute maps", "\n", "all_protected_attribute_maps", "=", "{", "\"sex\"", ":", "{", "1.0", ":", "'Male'", ",", "0.0", ":", "'Female'", "}", ",", "\n", "\"age\"", ":", "{", "1.0", ":", "'Old'", ",", "0.0", ":", "'Young'", "}", "}", "\n", "\n", "return", "GermanDataset", "(", "\n", "label_name", "=", "Y_features", "[", "0", "]", ",", "\n", "favorable_classes", "=", "[", "1", "]", ",", "\n", "protected_attribute_names", "=", "D_features", ",", "\n", "privileged_classes", "=", "[", "all_privileged_classes", "[", "x", "]", "for", "x", "in", "D_features", "]", ",", "\n", "instance_weights_name", "=", "None", ",", "\n", "categorical_features", "=", "categorical_features", ",", "\n", "features_to_keep", "=", "X_features", "+", "Y_features", "+", "D_features", ",", "\n", "metadata", "=", "{", "'label_maps'", ":", "[", "{", "1.0", ":", "'Good Credit'", ",", "2.0", ":", "'Bad Credit'", "}", "]", ",", "\n", "'protected_attribute_maps'", ":", "[", "all_protected_attribute_maps", "[", "x", "]", "\n", "for", "x", "in", "D_features", "]", "}", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.eq_odds_postprocessing.EqOddsPostprocessing.__init__": [[52, 70], ["aif360.algorithms.Transformer.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "unprivileged_groups", ",", "privileged_groups", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            unprivileged_groups (list(dict)): Representation for unprivileged\n                group.\n            privileged_groups (list(dict)): Representation for privileged\n                group.\n            seed (int, optional): Seed to make `predict` repeatable.\n        \"\"\"", "\n", "super", "(", "EqOddsPostprocessing", ",", "self", ")", ".", "__init__", "(", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ",", "\n", "seed", "=", "seed", ")", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "model_params", "=", "None", "\n", "self", ".", "unprivileged_groups", "=", "unprivileged_groups", "\n", "self", ".", "privileged_groups", "=", "privileged_groups", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.eq_odds_postprocessing.EqOddsPostprocessing.fit": [[71, 193], ["aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.base_rate", "aif360.metrics.ClassificationMetric.base_rate", "aif360.metrics.ClassificationMetric.false_positive_rate", "aif360.metrics.ClassificationMetric.false_positive_rate", "aif360.metrics.ClassificationMetric.false_negative_rate", "aif360.metrics.ClassificationMetric.false_negative_rate", "aif360.metrics.ClassificationMetric.true_positive_rate", "aif360.metrics.ClassificationMetric.true_positive_rate", "aif360.metrics.ClassificationMetric.true_negative_rate", "aif360.metrics.ClassificationMetric.true_negative_rate", "numpy.array", "numpy.array", "numpy.array", "aif360.metrics.utils.compute_boolean_conditioning_vector", "aif360.metrics.utils.compute_boolean_conditioning_vector", "numpy.ravel", "numpy.ravel", "numpy.ravel", "numpy.ravel", "dataset_true.labels.ravel", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "scipy.optimize.linprog", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector"], ["", "def", "fit", "(", "self", ",", "dataset_true", ",", "dataset_pred", ")", ":", "\n", "        ", "\"\"\"Compute parameters for equalizing odds using true and predicted\n        labels.\n\n        Args:\n            true_dataset (BinaryLabelDataset): Dataset containing true labels.\n            pred_dataset (BinaryLabelDataset): Dataset containing predicted\n                labels.\n\n        Returns:\n            EqOddsPostprocessing: Returns self.\n        \"\"\"", "\n", "metric", "=", "ClassificationMetric", "(", "dataset_true", ",", "dataset_pred", ",", "\n", "unprivileged_groups", "=", "self", ".", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "self", ".", "privileged_groups", ")", "\n", "\n", "# compute basic statistics", "\n", "sbr", "=", "metric", ".", "base_rate", "(", "privileged", "=", "True", ")", "\n", "obr", "=", "metric", ".", "base_rate", "(", "privileged", "=", "False", ")", "\n", "\n", "fpr0", "=", "metric", ".", "false_positive_rate", "(", "privileged", "=", "True", ")", "\n", "fpr1", "=", "metric", ".", "false_positive_rate", "(", "privileged", "=", "False", ")", "\n", "fnr0", "=", "metric", ".", "false_negative_rate", "(", "privileged", "=", "True", ")", "\n", "fnr1", "=", "metric", ".", "false_negative_rate", "(", "privileged", "=", "False", ")", "\n", "tpr0", "=", "metric", ".", "true_positive_rate", "(", "privileged", "=", "True", ")", "\n", "tpr1", "=", "metric", ".", "true_positive_rate", "(", "privileged", "=", "False", ")", "\n", "tnr0", "=", "metric", ".", "true_negative_rate", "(", "privileged", "=", "True", ")", "\n", "tnr1", "=", "metric", ".", "true_negative_rate", "(", "privileged", "=", "False", ")", "\n", "\n", "# linear program has 4 decision variables:", "\n", "# [Pr[label_tilde = 1 | label_hat = 1, protected_attributes = 0];", "\n", "#  Pr[label_tilde = 1 | label_hat = 0, protected_attributes = 0];", "\n", "#  Pr[label_tilde = 1 | label_hat = 1, protected_attributes = 1];", "\n", "#  Pr[label_tilde = 1 | label_hat = 0, protected_attributes = 1]]", "\n", "# Coefficients of the linear objective function to be minimized.", "\n", "c", "=", "np", ".", "array", "(", "[", "fpr0", "-", "tpr0", ",", "tnr0", "-", "fnr0", ",", "fpr1", "-", "tpr1", ",", "tnr1", "-", "fnr1", "]", ")", "\n", "\n", "# A_ub - 2-D array which, when matrix-multiplied by x, gives the values", "\n", "# of the upper-bound inequality constraints at x", "\n", "# b_ub - 1-D array of values representing the upper-bound of each", "\n", "# inequality constraint (row) in A_ub.", "\n", "# Just to keep these between zero and one", "\n", "A_ub", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "-", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "-", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "-", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "-", "1", "]", "]", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "b_ub", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "1", ",", "0", ",", "1", ",", "0", ",", "1", ",", "0", "]", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "# Create boolean conditioning vectors for protected groups", "\n", "cond_vec_priv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset_pred", ".", "protected_attributes", ",", "\n", "dataset_pred", ".", "protected_attribute_names", ",", "\n", "self", ".", "privileged_groups", ")", "\n", "cond_vec_unpriv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset_pred", ".", "protected_attributes", ",", "\n", "dataset_pred", ".", "protected_attribute_names", ",", "\n", "self", ".", "unprivileged_groups", ")", "\n", "\n", "sconst", "=", "np", ".", "ravel", "(", "\n", "dataset_pred", ".", "labels", "[", "cond_vec_priv", "]", "==", "dataset_pred", ".", "favorable_label", ")", "\n", "sflip", "=", "np", ".", "ravel", "(", "\n", "dataset_pred", ".", "labels", "[", "cond_vec_priv", "]", "==", "dataset_pred", ".", "unfavorable_label", ")", "\n", "oconst", "=", "np", ".", "ravel", "(", "\n", "dataset_pred", ".", "labels", "[", "cond_vec_unpriv", "]", "==", "dataset_pred", ".", "favorable_label", ")", "\n", "oflip", "=", "np", ".", "ravel", "(", "\n", "dataset_pred", ".", "labels", "[", "cond_vec_unpriv", "]", "==", "dataset_pred", ".", "unfavorable_label", ")", "\n", "\n", "y_true", "=", "dataset_true", ".", "labels", ".", "ravel", "(", ")", "\n", "\n", "sm_tn", "=", "np", ".", "logical_and", "(", "sflip", ",", "\n", "y_true", "[", "cond_vec_priv", "]", "==", "dataset_true", ".", "unfavorable_label", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "sm_fn", "=", "np", ".", "logical_and", "(", "sflip", ",", "\n", "y_true", "[", "cond_vec_priv", "]", "==", "dataset_true", ".", "favorable_label", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "sm_fp", "=", "np", ".", "logical_and", "(", "sconst", ",", "\n", "y_true", "[", "cond_vec_priv", "]", "==", "dataset_true", ".", "unfavorable_label", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "sm_tp", "=", "np", ".", "logical_and", "(", "sconst", ",", "\n", "y_true", "[", "cond_vec_priv", "]", "==", "dataset_true", ".", "favorable_label", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "om_tn", "=", "np", ".", "logical_and", "(", "oflip", ",", "\n", "y_true", "[", "cond_vec_unpriv", "]", "==", "dataset_true", ".", "unfavorable_label", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "om_fn", "=", "np", ".", "logical_and", "(", "oflip", ",", "\n", "y_true", "[", "cond_vec_unpriv", "]", "==", "dataset_true", ".", "favorable_label", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "om_fp", "=", "np", ".", "logical_and", "(", "oconst", ",", "\n", "y_true", "[", "cond_vec_unpriv", "]", "==", "dataset_true", ".", "unfavorable_label", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "om_tp", "=", "np", ".", "logical_and", "(", "oconst", ",", "\n", "y_true", "[", "cond_vec_unpriv", "]", "==", "dataset_true", ".", "favorable_label", ",", "\n", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "# A_eq - 2-D array which, when matrix-multiplied by x,", "\n", "# gives the values of the equality constraints at x", "\n", "# b_eq - 1-D array of values representing the RHS of each equality", "\n", "# constraint (row) in A_eq.", "\n", "# Used to impose equality of odds constraint", "\n", "A_eq", "=", "[", "[", "(", "np", ".", "mean", "(", "sconst", "*", "sm_tp", ")", "-", "np", ".", "mean", "(", "sflip", "*", "sm_tp", ")", ")", "/", "sbr", ",", "\n", "(", "np", ".", "mean", "(", "sflip", "*", "sm_fn", ")", "-", "np", ".", "mean", "(", "sconst", "*", "sm_fn", ")", ")", "/", "sbr", ",", "\n", "(", "np", ".", "mean", "(", "oflip", "*", "om_tp", ")", "-", "np", ".", "mean", "(", "oconst", "*", "om_tp", ")", ")", "/", "obr", ",", "\n", "(", "np", ".", "mean", "(", "oconst", "*", "om_fn", ")", "-", "np", ".", "mean", "(", "oflip", "*", "om_fn", ")", ")", "/", "obr", "]", ",", "\n", "[", "(", "np", ".", "mean", "(", "sconst", "*", "sm_fp", ")", "-", "np", ".", "mean", "(", "sflip", "*", "sm_fp", ")", ")", "/", "(", "1", "-", "sbr", ")", ",", "\n", "(", "np", ".", "mean", "(", "sflip", "*", "sm_tn", ")", "-", "np", ".", "mean", "(", "sconst", "*", "sm_tn", ")", ")", "/", "(", "1", "-", "sbr", ")", ",", "\n", "(", "np", ".", "mean", "(", "oflip", "*", "om_fp", ")", "-", "np", ".", "mean", "(", "oconst", "*", "om_fp", ")", ")", "/", "(", "1", "-", "obr", ")", ",", "\n", "(", "np", ".", "mean", "(", "oconst", "*", "om_tn", ")", "-", "np", ".", "mean", "(", "oflip", "*", "om_tn", ")", ")", "/", "(", "1", "-", "obr", ")", "]", "]", "\n", "\n", "b_eq", "=", "[", "(", "np", ".", "mean", "(", "oflip", "*", "om_tp", ")", "+", "np", ".", "mean", "(", "oconst", "*", "om_fn", ")", ")", "/", "obr", "\n", "-", "(", "np", ".", "mean", "(", "sflip", "*", "sm_tp", ")", "+", "np", ".", "mean", "(", "sconst", "*", "sm_fn", ")", ")", "/", "sbr", ",", "\n", "(", "np", ".", "mean", "(", "oflip", "*", "om_fp", ")", "+", "np", ".", "mean", "(", "oconst", "*", "om_tn", ")", ")", "/", "(", "1", "-", "obr", ")", "\n", "-", "(", "np", ".", "mean", "(", "sflip", "*", "sm_fp", ")", "+", "np", ".", "mean", "(", "sconst", "*", "sm_tn", ")", ")", "/", "(", "1", "-", "sbr", ")", "]", "\n", "\n", "# Linear program", "\n", "self", ".", "model_params", "=", "linprog", "(", "c", ",", "A_ub", "=", "A_ub", ",", "b_ub", "=", "b_ub", ",", "A_eq", "=", "A_eq", ",", "b_eq", "=", "b_eq", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.eq_odds_postprocessing.EqOddsPostprocessing.predict": [[194, 254], ["aif360.metrics.utils.compute_boolean_conditioning_vector", "aif360.metrics.utils.compute_boolean_conditioning_vector", "dataset.labels[].copy", "numpy.nonzero", "numpy.nonzero", "numpy.random.shuffle", "numpy.random.shuffle", "dataset.labels[].copy", "numpy.nonzero", "numpy.nonzero", "numpy.random.shuffle", "numpy.random.shuffle", "dataset.copy", "numpy.zeros_like", "numpy.random.seed", "int", "int", "int", "int", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "predict", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Perturb the predicted labels to obtain new labels that satisfy\n        equalized odds constraints.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing labels that needs\n                to be transformed.\n            dataset (BinaryLabelDataset): Transformed dataset.\n        \"\"\"", "\n", "if", "self", ".", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "\n", "# Get the model parameters output from fit", "\n", "", "sp2p", ",", "sn2p", ",", "op2p", ",", "on2p", "=", "self", ".", "model_params", ".", "x", "\n", "\n", "# Create boolean conditioning vectors for protected groups", "\n", "cond_vec_priv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "privileged_groups", ")", "\n", "cond_vec_unpriv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "unprivileged_groups", ")", "\n", "\n", "# Randomly flip labels according to the probabilities in model_params", "\n", "self_fair_pred", "=", "dataset", ".", "labels", "[", "cond_vec_priv", "]", ".", "copy", "(", ")", "\n", "self_pp_indices", ",", "_", "=", "np", ".", "nonzero", "(", "\n", "dataset", ".", "labels", "[", "cond_vec_priv", "]", "==", "dataset", ".", "favorable_label", ")", "\n", "self_pn_indices", ",", "_", "=", "np", ".", "nonzero", "(", "\n", "dataset", ".", "labels", "[", "cond_vec_priv", "]", "==", "dataset", ".", "unfavorable_label", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "self_pp_indices", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "self_pn_indices", ")", "\n", "\n", "n2p_indices", "=", "self_pn_indices", "[", ":", "int", "(", "len", "(", "self_pn_indices", ")", "*", "sn2p", ")", "]", "\n", "self_fair_pred", "[", "n2p_indices", "]", "=", "dataset", ".", "favorable_label", "\n", "p2n_indices", "=", "self_pp_indices", "[", ":", "int", "(", "len", "(", "self_pp_indices", ")", "*", "(", "1", "-", "sp2p", ")", ")", "]", "\n", "self_fair_pred", "[", "p2n_indices", "]", "=", "dataset", ".", "unfavorable_label", "\n", "\n", "othr_fair_pred", "=", "dataset", ".", "labels", "[", "cond_vec_unpriv", "]", ".", "copy", "(", ")", "\n", "othr_pp_indices", ",", "_", "=", "np", ".", "nonzero", "(", "\n", "dataset", ".", "labels", "[", "cond_vec_unpriv", "]", "==", "dataset", ".", "favorable_label", ")", "\n", "othr_pn_indices", ",", "_", "=", "np", ".", "nonzero", "(", "\n", "dataset", ".", "labels", "[", "cond_vec_unpriv", "]", "==", "dataset", ".", "unfavorable_label", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "othr_pp_indices", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "othr_pn_indices", ")", "\n", "\n", "n2p_indices", "=", "othr_pn_indices", "[", ":", "int", "(", "len", "(", "othr_pn_indices", ")", "*", "on2p", ")", "]", "\n", "othr_fair_pred", "[", "n2p_indices", "]", "=", "dataset", ".", "favorable_label", "\n", "p2n_indices", "=", "othr_pp_indices", "[", ":", "int", "(", "len", "(", "othr_pp_indices", ")", "*", "(", "1", "-", "op2p", ")", ")", "]", "\n", "othr_fair_pred", "[", "p2n_indices", "]", "=", "dataset", ".", "unfavorable_label", "\n", "\n", "# Mutated, fairer dataset with new labels", "\n", "dataset_new", "=", "dataset", ".", "copy", "(", ")", "\n", "\n", "new_labels", "=", "np", ".", "zeros_like", "(", "dataset", ".", "labels", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "new_labels", "[", "cond_vec_priv", "]", "=", "self_fair_pred", "\n", "new_labels", "[", "cond_vec_unpriv", "]", "=", "othr_fair_pred", "\n", "\n", "dataset_new", ".", "labels", "=", "new_labels", "\n", "\n", "return", "dataset_new", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.eq_odds_postprocessing.EqOddsPostprocessing.fit_predict": [[255, 258], ["eq_odds_postprocessing.EqOddsPostprocessing.fit().predict", "eq_odds_postprocessing.EqOddsPostprocessing.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "fit_predict", "(", "self", ",", "dataset_true", ",", "dataset_pred", ")", ":", "\n", "        ", "\"\"\"fit and predict methods sequentially.\"\"\"", "\n", "return", "self", ".", "fit", "(", "dataset_true", ",", "dataset_pred", ")", ".", "predict", "(", "dataset_pred", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_eq_odds_postprocessing.CalibratedEqOddsPostprocessing.__init__": [[52, 87], ["aif360.algorithms.Transformer.__init__", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "unprivileged_groups", ",", "privileged_groups", ",", "\n", "cost_constraint", "=", "'weighted'", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            unprivileged_groups (dict or list(dict)): Representation for\n                unprivileged group.\n            privileged_groups (dict or list(dict)): Representation for\n                privileged group.\n            cost_contraint: fpr, fnr or weighted\n            seed (int, optional): Seed to make `predict` repeatable.\n        \"\"\"", "\n", "super", "(", "CalibratedEqOddsPostprocessing", ",", "self", ")", ".", "__init__", "(", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ",", "\n", "seed", "=", "seed", ")", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "model_params", "=", "None", "\n", "self", ".", "unprivileged_groups", "=", "[", "unprivileged_groups", "]", "if", "isinstance", "(", "unprivileged_groups", ",", "dict", ")", "else", "unprivileged_groups", "\n", "self", ".", "privileged_groups", "=", "[", "privileged_groups", "]", "if", "isinstance", "(", "privileged_groups", ",", "dict", ")", "else", "privileged_groups", "\n", "self", ".", "cost_constraint", "=", "cost_constraint", "\n", "if", "self", ".", "cost_constraint", "==", "'fnr'", ":", "\n", "            ", "self", ".", "fn_rate", "=", "1", "\n", "self", ".", "fp_rate", "=", "0", "\n", "", "elif", "self", ".", "cost_constraint", "==", "'fpr'", ":", "\n", "            ", "self", ".", "fn_rate", "=", "0", "\n", "self", ".", "fp_rate", "=", "1", "\n", "", "elif", "self", ".", "cost_constraint", "==", "'weighted'", ":", "\n", "            ", "self", ".", "fn_rate", "=", "1", "\n", "self", ".", "fp_rate", "=", "1", "\n", "\n", "", "self", ".", "base_rate_priv", "=", "0.0", "\n", "self", ".", "base_rate_unpriv", "=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_eq_odds_postprocessing.CalibratedEqOddsPostprocessing.fit": [[88, 148], ["aif360.metrics.utils.compute_boolean_conditioning_vector", "aif360.metrics.utils.compute_boolean_conditioning_vector", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.base_rate", "aif360.metrics.ClassificationMetric.base_rate", "dataset_pred.copy", "aif360.metrics.ClassificationMetric.base_rate", "aif360.metrics.ClassificationMetric.base_rate", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.generalized_false_positive_rate", "aif360.metrics.ClassificationMetric.generalized_false_positive_rate", "aif360.metrics.ClassificationMetric.generalized_false_positive_rate", "aif360.metrics.ClassificationMetric.generalized_false_positive_rate", "aif360.metrics.ClassificationMetric.generalized_false_negative_rate", "aif360.metrics.ClassificationMetric.generalized_false_negative_rate", "aif360.metrics.ClassificationMetric.generalized_false_negative_rate", "aif360.metrics.ClassificationMetric.generalized_false_negative_rate", "calibrated_eq_odds_postprocessing.weighted_cost", "calibrated_eq_odds_postprocessing.weighted_cost", "calibrated_eq_odds_postprocessing.weighted_cost", "calibrated_eq_odds_postprocessing.weighted_cost"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_eq_odds_postprocessing.weighted_cost", "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_eq_odds_postprocessing.weighted_cost", "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_eq_odds_postprocessing.weighted_cost", "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_eq_odds_postprocessing.weighted_cost"], ["", "def", "fit", "(", "self", ",", "dataset_true", ",", "dataset_pred", ")", ":", "\n", "        ", "\"\"\"Compute parameters for equalizing generalized odds using true and\n        predicted scores, while preserving calibration.\n\n        Args:\n            dataset_true (BinaryLabelDataset): Dataset containing true `labels`.\n            dataset_pred (BinaryLabelDataset): Dataset containing predicted\n                `scores`.\n\n        Returns:\n            CalibratedEqOddsPostprocessing: Returns self.\n        \"\"\"", "\n", "\n", "# Create boolean conditioning vectors for protected groups", "\n", "cond_vec_priv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset_pred", ".", "protected_attributes", ",", "\n", "dataset_pred", ".", "protected_attribute_names", ",", "\n", "self", ".", "privileged_groups", ")", "\n", "cond_vec_unpriv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset_pred", ".", "protected_attributes", ",", "\n", "dataset_pred", ".", "protected_attribute_names", ",", "\n", "self", ".", "unprivileged_groups", ")", "\n", "\n", "cm", "=", "ClassificationMetric", "(", "dataset_true", ",", "dataset_pred", ",", "\n", "unprivileged_groups", "=", "self", ".", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "self", ".", "privileged_groups", ")", "\n", "self", ".", "base_rate_priv", "=", "cm", ".", "base_rate", "(", "privileged", "=", "True", ")", "\n", "self", ".", "base_rate_unpriv", "=", "cm", ".", "base_rate", "(", "privileged", "=", "False", ")", "\n", "\n", "# Create a dataset with \"trivial\" predictions", "\n", "dataset_trivial", "=", "dataset_pred", ".", "copy", "(", "deepcopy", "=", "True", ")", "\n", "dataset_trivial", ".", "scores", "[", "cond_vec_priv", "]", "=", "cm", ".", "base_rate", "(", "privileged", "=", "True", ")", "\n", "dataset_trivial", ".", "scores", "[", "cond_vec_unpriv", "]", "=", "cm", ".", "base_rate", "(", "privileged", "=", "False", ")", "\n", "cm_triv", "=", "ClassificationMetric", "(", "dataset_true", ",", "dataset_trivial", ",", "\n", "unprivileged_groups", "=", "self", ".", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "self", ".", "privileged_groups", ")", "\n", "\n", "if", "self", ".", "fn_rate", "==", "0", ":", "\n", "            ", "priv_cost", "=", "cm", ".", "generalized_false_positive_rate", "(", "privileged", "=", "True", ")", "\n", "unpriv_cost", "=", "cm", ".", "generalized_false_positive_rate", "(", "privileged", "=", "False", ")", "\n", "priv_trivial_cost", "=", "cm_triv", ".", "generalized_false_positive_rate", "(", "privileged", "=", "True", ")", "\n", "unpriv_trivial_cost", "=", "cm_triv", ".", "generalized_false_positive_rate", "(", "privileged", "=", "False", ")", "\n", "\n", "", "elif", "self", ".", "fp_rate", "==", "0", ":", "\n", "            ", "priv_cost", "=", "cm", ".", "generalized_false_negative_rate", "(", "privileged", "=", "True", ")", "\n", "unpriv_cost", "=", "cm", ".", "generalized_false_negative_rate", "(", "privileged", "=", "False", ")", "\n", "priv_trivial_cost", "=", "cm_triv", ".", "generalized_false_negative_rate", "(", "privileged", "=", "True", ")", "\n", "unpriv_trivial_cost", "=", "cm_triv", ".", "generalized_false_negative_rate", "(", "privileged", "=", "False", ")", "\n", "\n", "", "else", ":", "\n", "            ", "priv_cost", "=", "weighted_cost", "(", "self", ".", "fp_rate", ",", "self", ".", "fn_rate", ",", "cm", ",", "privileged", "=", "True", ")", "\n", "unpriv_cost", "=", "weighted_cost", "(", "self", ".", "fp_rate", ",", "self", ".", "fn_rate", ",", "cm", ",", "privileged", "=", "False", ")", "\n", "priv_trivial_cost", "=", "weighted_cost", "(", "self", ".", "fp_rate", ",", "self", ".", "fn_rate", ",", "cm_triv", ",", "privileged", "=", "True", ")", "\n", "unpriv_trivial_cost", "=", "weighted_cost", "(", "self", ".", "fp_rate", ",", "self", ".", "fn_rate", ",", "cm_triv", ",", "privileged", "=", "False", ")", "\n", "\n", "", "unpriv_costs_more", "=", "unpriv_cost", ">", "priv_cost", "\n", "self", ".", "priv_mix_rate", "=", "(", "unpriv_cost", "-", "priv_cost", ")", "/", "(", "priv_trivial_cost", "-", "priv_cost", ")", "if", "unpriv_costs_more", "else", "0", "\n", "self", ".", "unpriv_mix_rate", "=", "0", "if", "unpriv_costs_more", "else", "(", "priv_cost", "-", "unpriv_cost", ")", "/", "(", "unpriv_trivial_cost", "-", "unpriv_cost", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_eq_odds_postprocessing.CalibratedEqOddsPostprocessing.predict": [[149, 195], ["aif360.metrics.utils.compute_boolean_conditioning_vector", "aif360.metrics.utils.compute_boolean_conditioning_vector", "dataset.scores[].copy", "dataset.scores[].copy", "dataset.copy", "numpy.zeros_like", "numpy.where", "numpy.random.seed", "numpy.random.random", "numpy.random.random", "sum", "sum"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "predict", "(", "self", ",", "dataset", ",", "threshold", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"Perturb the predicted scores to obtain new labels that satisfy\n        equalized odds constraints, while preserving calibration.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing `scores` that needs\n                to be transformed.\n            threshold (float): Threshold for converting `scores` to `labels`.\n                Values greater than or equal to this threshold are predicted to\n                be the `favorable_label`. Default is 0.5.\n        Returns:\n            dataset (BinaryLabelDataset): transformed dataset.\n        \"\"\"", "\n", "if", "self", ".", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "\n", "", "cond_vec_priv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "privileged_groups", ")", "\n", "cond_vec_unpriv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "unprivileged_groups", ")", "\n", "\n", "unpriv_indices", "=", "(", "np", ".", "random", ".", "random", "(", "sum", "(", "cond_vec_unpriv", ")", ")", "\n", "<=", "self", ".", "unpriv_mix_rate", ")", "\n", "unpriv_new_pred", "=", "dataset", ".", "scores", "[", "cond_vec_unpriv", "]", ".", "copy", "(", ")", "\n", "unpriv_new_pred", "[", "unpriv_indices", "]", "=", "self", ".", "base_rate_unpriv", "\n", "\n", "priv_indices", "=", "(", "np", ".", "random", ".", "random", "(", "sum", "(", "cond_vec_priv", ")", ")", "\n", "<=", "self", ".", "priv_mix_rate", ")", "\n", "priv_new_pred", "=", "dataset", ".", "scores", "[", "cond_vec_priv", "]", ".", "copy", "(", ")", "\n", "priv_new_pred", "[", "priv_indices", "]", "=", "self", ".", "base_rate_priv", "\n", "\n", "dataset_new", "=", "dataset", ".", "copy", "(", "deepcopy", "=", "True", ")", "\n", "\n", "dataset_new", ".", "scores", "=", "np", ".", "zeros_like", "(", "dataset", ".", "scores", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "dataset_new", ".", "scores", "[", "cond_vec_priv", "]", "=", "priv_new_pred", "\n", "dataset_new", ".", "scores", "[", "cond_vec_unpriv", "]", "=", "unpriv_new_pred", "\n", "\n", "# Create labels from scores using a default threshold", "\n", "dataset_new", ".", "labels", "=", "np", ".", "where", "(", "dataset_new", ".", "scores", ">=", "threshold", ",", "\n", "dataset_new", ".", "favorable_label", ",", "\n", "dataset_new", ".", "unfavorable_label", ")", "\n", "return", "dataset_new", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_eq_odds_postprocessing.CalibratedEqOddsPostprocessing.fit_predict": [[196, 200], ["calibrated_eq_odds_postprocessing.CalibratedEqOddsPostprocessing.fit().predict", "calibrated_eq_odds_postprocessing.CalibratedEqOddsPostprocessing.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "fit_predict", "(", "self", ",", "dataset_true", ",", "dataset_pred", ",", "threshold", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"fit and predict methods sequentially.\"\"\"", "\n", "return", "self", ".", "fit", "(", "dataset_true", ",", "dataset_pred", ")", ".", "predict", "(", "\n", "dataset_pred", ",", "threshold", "=", "threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_eq_odds_postprocessing.weighted_cost": [[203, 212], ["float", "cm.base_rate", "cm.generalized_false_positive_rate", "cm.base_rate", "cm.generalized_false_negative_rate"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_negative_rate"], ["", "", "def", "weighted_cost", "(", "fp_rate", ",", "fn_rate", ",", "cm", ",", "privileged", ")", ":", "\n", "    ", "norm_const", "=", "float", "(", "fp_rate", "+", "fn_rate", ")", "if", "(", "fp_rate", "!=", "0", "and", "fn_rate", "!=", "0", ")", "else", "1", "\n", "return", "(", "(", "fp_rate", "/", "norm_const", "\n", "*", "cm", ".", "generalized_false_positive_rate", "(", "privileged", "=", "privileged", ")", "\n", "*", "(", "1", "-", "cm", ".", "base_rate", "(", "privileged", "=", "privileged", ")", ")", ")", "+", "\n", "(", "fn_rate", "/", "norm_const", "\n", "*", "cm", ".", "generalized_false_negative_rate", "(", "privileged", "=", "privileged", ")", "\n", "*", "cm", ".", "base_rate", "(", "privileged", "=", "privileged", ")", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassification.__init__": [[22, 82], ["aif360.algorithms.Transformer.__init__", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "unprivileged_groups", ",", "privileged_groups", ",", "\n", "low_class_thresh", "=", "0.01", ",", "high_class_thresh", "=", "0.99", ",", "\n", "num_class_thresh", "=", "100", ",", "num_ROC_margin", "=", "50", ",", "\n", "metric_name", "=", "\"Statistical parity difference\"", ",", "\n", "metric_ub", "=", "0.05", ",", "metric_lb", "=", "-", "0.05", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            unprivileged_groups (dict or list(dict)): Representation for\n                unprivileged group.\n            privileged_groups (dict or list(dict)): Representation for\n                privileged group.\n            low_class_thresh (float): Smallest classification threshold to use\n                in the optimization. Should be between 0. and 1.\n            high_class_thresh (float): Highest classification threshold to use\n                in the optimization. Should be between 0. and 1.\n            num_class_thresh (int): Number of classification thresholds between\n                low_class_thresh and high_class_thresh for the optimization\n                search. Should be > 0.\n            num_ROC_margin (int): Number of relevant ROC margins to be used in\n                the optimization search. Should be > 0.\n            metric_name (str): Name of the metric to use for the optimization.\n                Allowed options are \"Statistical parity difference\",\n                \"Average odds difference\", \"Equal opportunity difference\".\n            metric_ub (float): Upper bound of constraint on the metric value\n            metric_lb (float): Lower bound of constraint on the metric value\n        \"\"\"", "\n", "super", "(", "RejectOptionClassification", ",", "self", ")", ".", "__init__", "(", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ",", "\n", "low_class_thresh", "=", "low_class_thresh", ",", "high_class_thresh", "=", "high_class_thresh", ",", "\n", "num_class_thresh", "=", "num_class_thresh", ",", "num_ROC_margin", "=", "num_ROC_margin", ",", "\n", "metric_name", "=", "metric_name", ")", "\n", "\n", "allowed_metrics", "=", "[", "\"Statistical parity difference\"", ",", "\n", "\"Average odds difference\"", ",", "\n", "\"Equal opportunity difference\"", "]", "\n", "\n", "self", ".", "unprivileged_groups", "=", "unprivileged_groups", "\n", "self", ".", "privileged_groups", "=", "privileged_groups", "\n", "\n", "self", ".", "low_class_thresh", "=", "low_class_thresh", "\n", "self", ".", "high_class_thresh", "=", "high_class_thresh", "\n", "self", ".", "num_class_thresh", "=", "num_class_thresh", "\n", "self", ".", "num_ROC_margin", "=", "num_ROC_margin", "\n", "self", ".", "metric_name", "=", "metric_name", "\n", "self", ".", "metric_ub", "=", "metric_ub", "\n", "self", ".", "metric_lb", "=", "metric_lb", "\n", "\n", "self", ".", "classification_threshold", "=", "None", "\n", "self", ".", "ROC_margin", "=", "None", "\n", "\n", "if", "(", "(", "self", ".", "low_class_thresh", "<", "0.0", ")", "or", "(", "self", ".", "low_class_thresh", ">", "1.0", ")", "or", "(", "self", ".", "high_class_thresh", "<", "0.0", ")", "or", "(", "self", ".", "high_class_thresh", ">", "1.0", ")", "or", "(", "self", ".", "low_class_thresh", ">=", "self", ".", "high_class_thresh", ")", "or", "(", "self", ".", "num_class_thresh", "<", "1", ")", "or", "(", "self", ".", "num_ROC_margin", "<", "1", ")", ")", ":", "\n", "\n", "            ", "raise", "ValueError", "(", "\"Input parameter values out of bounds\"", ")", "\n", "\n", "", "if", "metric_name", "not", "in", "allowed_metrics", ":", "\n", "            ", "raise", "ValueError", "(", "\"metric name not in the list of allowed metrics\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassification.fit": [[83, 169], ["numpy.zeros", "numpy.zeros_like", "numpy.zeros_like", "numpy.zeros_like", "numpy.linspace", "numpy.logical_and", "any", "numpy.linspace", "warnings.warn", "numpy.ones", "reject_option_classification.RejectOptionClassification.predict", "aif360.metrics.BinaryLabelDatasetMetric", "aif360.metrics.ClassificationMetric", "len", "aif360.metrics.BinaryLabelDatasetMetric.mean_difference", "numpy.where", "numpy.where", "aif360.metrics.ClassificationMetric.true_positive_rate", "aif360.metrics.ClassificationMetric.true_negative_rate", "aif360.metrics.ClassificationMetric.average_odds_difference", "aif360.metrics.ClassificationMetric.equal_opportunity_difference", "numpy.max", "numpy.min"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.mean_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_odds_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.equal_opportunity_difference"], ["", "", "def", "fit", "(", "self", ",", "dataset_true", ",", "dataset_pred", ")", ":", "\n", "        ", "\"\"\"Estimates the optimal classification threshold and margin for reject\n        option classification that optimizes the metric provided.\n\n        Note:\n            The `fit` function is a no-op for this algorithm.\n\n        Args:\n            dataset_true (BinaryLabelDataset): Dataset containing the true\n                `labels`.\n            dataset_pred (BinaryLabelDataset): Dataset containing the predicted\n                `scores`.\n\n        Returns:\n            RejectOptionClassification: Returns self.\n        \"\"\"", "\n", "\n", "fair_metric_arr", "=", "np", ".", "zeros", "(", "self", ".", "num_class_thresh", "*", "self", ".", "num_ROC_margin", ")", "\n", "balanced_acc_arr", "=", "np", ".", "zeros_like", "(", "fair_metric_arr", ")", "\n", "ROC_margin_arr", "=", "np", ".", "zeros_like", "(", "fair_metric_arr", ")", "\n", "class_thresh_arr", "=", "np", ".", "zeros_like", "(", "fair_metric_arr", ")", "\n", "\n", "cnt", "=", "0", "\n", "# Iterate through class thresholds", "\n", "for", "class_thresh", "in", "np", ".", "linspace", "(", "self", ".", "low_class_thresh", ",", "\n", "self", ".", "high_class_thresh", ",", "\n", "self", ".", "num_class_thresh", ")", ":", "\n", "\n", "            ", "self", ".", "classification_threshold", "=", "class_thresh", "\n", "if", "class_thresh", "<=", "0.5", ":", "\n", "                ", "low_ROC_margin", "=", "0.0", "\n", "high_ROC_margin", "=", "class_thresh", "\n", "", "else", ":", "\n", "                ", "low_ROC_margin", "=", "0.0", "\n", "high_ROC_margin", "=", "(", "1.0", "-", "class_thresh", ")", "\n", "\n", "# Iterate through ROC margins", "\n", "", "for", "ROC_margin", "in", "np", ".", "linspace", "(", "\n", "low_ROC_margin", ",", "\n", "high_ROC_margin", ",", "\n", "self", ".", "num_ROC_margin", ")", ":", "\n", "                ", "self", ".", "ROC_margin", "=", "ROC_margin", "\n", "\n", "# Predict using the current threshold and margin", "\n", "dataset_transf_pred", "=", "self", ".", "predict", "(", "dataset_pred", ")", "\n", "\n", "dataset_transf_metric_pred", "=", "BinaryLabelDatasetMetric", "(", "\n", "dataset_transf_pred", ",", "\n", "unprivileged_groups", "=", "self", ".", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "self", ".", "privileged_groups", ")", "\n", "classified_transf_metric", "=", "ClassificationMetric", "(", "\n", "dataset_true", ",", "\n", "dataset_transf_pred", ",", "\n", "unprivileged_groups", "=", "self", ".", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "self", ".", "privileged_groups", ")", "\n", "\n", "ROC_margin_arr", "[", "cnt", "]", "=", "self", ".", "ROC_margin", "\n", "class_thresh_arr", "[", "cnt", "]", "=", "self", ".", "classification_threshold", "\n", "\n", "# Balanced accuracy and fairness metric computations", "\n", "balanced_acc_arr", "[", "cnt", "]", "=", "0.5", "*", "(", "classified_transf_metric", ".", "true_positive_rate", "(", ")", "+", "classified_transf_metric", ".", "true_negative_rate", "(", ")", ")", "\n", "if", "self", ".", "metric_name", "==", "\"Statistical parity difference\"", ":", "\n", "                    ", "fair_metric_arr", "[", "cnt", "]", "=", "dataset_transf_metric_pred", ".", "mean_difference", "(", ")", "\n", "", "elif", "self", ".", "metric_name", "==", "\"Average odds difference\"", ":", "\n", "                    ", "fair_metric_arr", "[", "cnt", "]", "=", "classified_transf_metric", ".", "average_odds_difference", "(", ")", "\n", "", "elif", "self", ".", "metric_name", "==", "\"Equal opportunity difference\"", ":", "\n", "                    ", "fair_metric_arr", "[", "cnt", "]", "=", "classified_transf_metric", ".", "equal_opportunity_difference", "(", ")", "\n", "\n", "", "cnt", "+=", "1", "\n", "\n", "", "", "rel_inds", "=", "np", ".", "logical_and", "(", "fair_metric_arr", ">=", "self", ".", "metric_lb", ",", "\n", "fair_metric_arr", "<=", "self", ".", "metric_ub", ")", "\n", "if", "any", "(", "rel_inds", ")", ":", "\n", "            ", "best_ind", "=", "np", ".", "where", "(", "balanced_acc_arr", "[", "rel_inds", "]", "\n", "==", "np", ".", "max", "(", "balanced_acc_arr", "[", "rel_inds", "]", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "warn", "(", "\"Unable to satisy fairness constraints\"", ")", "\n", "rel_inds", "=", "np", ".", "ones", "(", "len", "(", "fair_metric_arr", ")", ",", "dtype", "=", "bool", ")", "\n", "best_ind", "=", "np", ".", "where", "(", "fair_metric_arr", "[", "rel_inds", "]", "\n", "==", "np", ".", "min", "(", "fair_metric_arr", "[", "rel_inds", "]", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "\n", "", "self", ".", "ROC_margin", "=", "ROC_margin_arr", "[", "rel_inds", "]", "[", "best_ind", "]", "\n", "self", ".", "classification_threshold", "=", "class_thresh_arr", "[", "rel_inds", "]", "[", "best_ind", "]", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassification.predict": [[170, 213], ["dataset.copy", "numpy.zeros", "numpy.logical_and", "aif360.metrics.utils.compute_boolean_conditioning_vector", "aif360.metrics.utils.compute_boolean_conditioning_vector", "numpy.logical_and", "numpy.logical_and", "aif360.metrics.utils.compute_boolean_conditioning_vector.reshape", "aif360.metrics.utils.compute_boolean_conditioning_vector.reshape"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector"], ["", "def", "predict", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Obtain fair predictions using the ROC method.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing scores that will\n                be used to compute predicted labels.\n\n        Returns:\n            dataset_pred (BinaryLabelDataset): Output dataset with potentially\n            fair predictions obtain using the ROC method.\n        \"\"\"", "\n", "dataset_new", "=", "dataset", ".", "copy", "(", "deepcopy", "=", "False", ")", "\n", "\n", "fav_pred_inds", "=", "(", "dataset", ".", "scores", ">", "self", ".", "classification_threshold", ")", "\n", "unfav_pred_inds", "=", "~", "fav_pred_inds", "\n", "\n", "y_pred", "=", "np", ".", "zeros", "(", "dataset", ".", "scores", ".", "shape", ")", "\n", "y_pred", "[", "fav_pred_inds", "]", "=", "dataset", ".", "favorable_label", "\n", "y_pred", "[", "unfav_pred_inds", "]", "=", "dataset", ".", "unfavorable_label", "\n", "\n", "# Indices of critical region around the classification boundary", "\n", "crit_region_inds", "=", "np", ".", "logical_and", "(", "\n", "dataset", ".", "scores", "<=", "self", ".", "classification_threshold", "+", "self", ".", "ROC_margin", ",", "\n", "dataset", ".", "scores", ">", "self", ".", "classification_threshold", "-", "self", ".", "ROC_margin", ")", "\n", "\n", "# Indices of privileged and unprivileged groups", "\n", "cond_priv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "privileged_groups", ")", "\n", "cond_unpriv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "unprivileged_groups", ")", "\n", "\n", "# New, fairer labels", "\n", "dataset_new", ".", "labels", "=", "y_pred", "\n", "dataset_new", ".", "labels", "[", "np", ".", "logical_and", "(", "crit_region_inds", ",", "\n", "cond_priv", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "]", "=", "dataset", ".", "unfavorable_label", "\n", "dataset_new", ".", "labels", "[", "np", ".", "logical_and", "(", "crit_region_inds", ",", "\n", "cond_unpriv", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "]", "=", "dataset", ".", "favorable_label", "\n", "\n", "return", "dataset_new", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassification.fit_predict": [[214, 217], ["reject_option_classification.RejectOptionClassification.fit().predict", "reject_option_classification.RejectOptionClassification.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "fit_predict", "(", "self", ",", "dataset_true", ",", "dataset_pred", ")", ":", "\n", "        ", "\"\"\"fit and predict methods sequentially.\"\"\"", "\n", "return", "self", ".", "fit", "(", "dataset_true", ",", "dataset_pred", ")", ".", "predict", "(", "dataset_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification._get_pareto_frontier": [[219, 245], ["numpy.arange", "len", "numpy.any", "numpy.zeros", "numpy.sum"], "function", ["None"], ["", "", "def", "_get_pareto_frontier", "(", "scores", ",", "return_mask", "=", "True", ")", ":", "# <- Fastest for many points", "\n", "    ", "\"\"\"\n    :param scores: An (n_points, n_scores) array\n    :param return_mask: True to return a mask, False to return integer indices of efficient points.\n    :return: An array of indices of pareto-efficient points.\n        If return_mask is True, this will be an (n_points, ) boolean array\n        Otherwise it will be a (n_efficient_points, ) integer array of indices.\n\n    adapted from: https://stackoverflow.com/questions/32791911/fast-calculation-of-pareto-front-in-python\n    \"\"\"", "\n", "is_efficient", "=", "np", ".", "arange", "(", "scores", ".", "shape", "[", "0", "]", ")", "\n", "n_points", "=", "scores", ".", "shape", "[", "0", "]", "\n", "next_point_index", "=", "0", "# Next index in the is_efficient array to search for", "\n", "\n", "while", "next_point_index", "<", "len", "(", "scores", ")", ":", "\n", "        ", "nondominated_point_mask", "=", "np", ".", "any", "(", "scores", ">=", "scores", "[", "next_point_index", "]", ",", "axis", "=", "1", ")", "\n", "is_efficient", "=", "is_efficient", "[", "nondominated_point_mask", "]", "# Remove dominated points", "\n", "scores", "=", "scores", "[", "nondominated_point_mask", "]", "\n", "next_point_index", "=", "np", ".", "sum", "(", "nondominated_point_mask", "[", ":", "next_point_index", "]", ")", "+", "1", "\n", "\n", "", "if", "return_mask", ":", "\n", "        ", "is_efficient_mask", "=", "np", ".", "zeros", "(", "n_points", ",", "dtype", "=", "bool", ")", "\n", "is_efficient_mask", "[", "is_efficient", "]", "=", "True", "\n", "return", "is_efficient_mask", "\n", "", "else", ":", "\n", "        ", "return", "is_efficient", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_equalized_odds.CalibratedEqualizedOdds.__init__": [[49, 69], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "prot_attr", "=", "None", ",", "cost_constraint", "=", "'weighted'", ",", "\n", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            prot_attr (single label or list-like, optional): Protected\n                attribute(s) to use in the post-processing. If more than one\n                attribute, all combinations of values (intersections) are\n                considered. Default is ``None`` meaning all protected attributes\n                from the dataset are used. Note: This algorithm requires there\n                be exactly 2 groups (privileged and unprivileged).\n            cost_constraint ('fpr', 'fnr', or 'weighted'): Which equal-cost\n                constraint to satisfy: generalized false positive rate ('fpr'),\n                generalized false negative rate ('fnr'), or a weighted\n                combination of both ('weighted').\n            random_state (int or numpy.RandomState, optional): Seed of pseudo-\n                random number generator for sampling from the mix rates.\n        \"\"\"", "\n", "self", ".", "prot_attr", "=", "prot_attr", "\n", "self", ".", "cost_constraint", "=", "cost_constraint", "\n", "self", ".", "random_state", "=", "random_state", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_equalized_odds.CalibratedEqualizedOdds._more_tags": [[70, 72], ["None"], "methods", ["None"], ["", "def", "_more_tags", "(", "self", ")", ":", "\n", "        ", "return", "{", "'requires_proba'", ":", "True", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_equalized_odds.CalibratedEqualizedOdds._weighted_cost": [[73, 87], ["aif360.sklearn.metrics.generalized_fpr", "aif360.sklearn.metrics.generalized_fnr", "aif360.sklearn.metrics.generalized_fpr", "aif360.sklearn.metrics.generalized_fnr", "aif360.sklearn.metrics.base_rate", "ValueError"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_fpr", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_fnr", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_fpr", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_fnr", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate"], ["", "def", "_weighted_cost", "(", "self", ",", "y_true", ",", "probas_pred", ",", "pos_label", "=", "1", ",", "\n", "sample_weight", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluates the cost function specified by ``self.cost_constraint``.\"\"\"", "\n", "if", "self", ".", "cost_constraint", "==", "'fpr'", ":", "\n", "            ", "return", "generalized_fpr", "(", "y_true", ",", "probas_pred", ",", "pos_label", ",", "sample_weight", ")", "\n", "", "elif", "self", ".", "cost_constraint", "==", "'fnr'", ":", "\n", "            ", "return", "generalized_fnr", "(", "y_true", ",", "probas_pred", ",", "pos_label", ",", "sample_weight", ")", "\n", "", "elif", "self", ".", "cost_constraint", "==", "'weighted'", ":", "\n", "            ", "fpr", "=", "generalized_fpr", "(", "y_true", ",", "probas_pred", ",", "pos_label", ",", "sample_weight", ")", "\n", "fnr", "=", "generalized_fnr", "(", "y_true", ",", "probas_pred", ",", "pos_label", ",", "sample_weight", ")", "\n", "br", "=", "base_rate", "(", "y_true", ",", "probas_pred", ",", "pos_label", ",", "sample_weight", ")", "\n", "return", "fpr", "*", "(", "1", "-", "br", ")", "+", "fnr", "*", "br", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"`cost_constraint` must be one of: 'fpr', 'fnr', \"", "\n", "\"or 'weighted'\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_equalized_odds.CalibratedEqualizedOdds.fit": [[89, 145], ["aif360.sklearn.utils.check_inputs", "aif360.sklearn.utils.check_groups", "numpy.unique", "numpy.array", "numpy.array", "numpy.unique", "len", "ValueError", "len", "ValueError", "ValueError", "func", "calibrated_equalized_odds.CalibratedEqualizedOdds.fit._eval"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_inputs", "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups"], ["", "", "def", "fit", "(", "self", ",", "X", ",", "y", ",", "labels", "=", "None", ",", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute the mixing rates required to satisfy the cost constraint.\n\n        Args:\n            X (array-like): Probability estimates of the targets as returned by\n                a ``predict_proba()`` call or equivalent.\n            y (pandas.Series): Ground-truth (correct) target values.\n            labels (list, optional): The ordered set of labels values. Must\n                match the order of columns in X if provided. By default,\n                all labels in y are used in sorted order.\n            pos_label (scalar, optional): The label of the positive class.\n            sample_weight (array-like, optional): Sample weights.\n\n        Returns:\n            self\n        \"\"\"", "\n", "X", ",", "y", ",", "sample_weight", "=", "check_inputs", "(", "X", ",", "y", ",", "sample_weight", ")", "\n", "groups", ",", "self", ".", "prot_attr_", "=", "check_groups", "(", "y", ",", "self", ".", "prot_attr", ",", "\n", "ensure_binary", "=", "True", ")", "\n", "self", ".", "classes_", "=", "np", ".", "array", "(", "labels", ")", "if", "labels", "is", "not", "None", "else", "np", ".", "unique", "(", "y", ")", "\n", "self", ".", "groups_", "=", "np", ".", "unique", "(", "groups", ")", "\n", "self", ".", "pos_label_", "=", "pos_label", "\n", "\n", "if", "len", "(", "self", ".", "classes_", ")", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "'Only binary classification is supported.'", ")", "\n", "", "if", "len", "(", "self", ".", "classes_", ")", "!=", "X", ".", "shape", "[", "1", "]", ":", "\n", "            ", "raise", "ValueError", "(", "'Only binary classification is supported. X should'", "\n", "' contain one column per class. Got: {} columns.'", ".", "format", "(", "\n", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "if", "pos_label", "not", "in", "self", ".", "classes_", ":", "\n", "            ", "raise", "ValueError", "(", "'pos_label={} is not in the set of labels. The '", "\n", "'valid values are:\\n{}'", ".", "format", "(", "pos_label", ",", "self", ".", "classes_", ")", ")", "\n", "\n", "", "pos_idx", "=", "np", ".", "nonzero", "(", "self", ".", "classes_", "==", "self", ".", "pos_label_", ")", "[", "0", "]", "[", "0", "]", "\n", "try", ":", "\n", "            ", "X", "=", "X", ".", "iloc", "[", ":", ",", "pos_idx", "]", "\n", "", "except", "AttributeError", ":", "\n", "            ", "X", "=", "X", "[", ":", ",", "pos_idx", "]", "\n", "\n", "# local function to evaluate corresponding metric", "\n", "", "def", "_eval", "(", "func", ",", "grp_idx", ",", "trivial", "=", "False", ")", ":", "\n", "            ", "idx", "=", "(", "groups", "==", "self", ".", "groups_", "[", "grp_idx", "]", ")", "\n", "pred", "=", "np", ".", "full_like", "(", "X", ",", "self", ".", "base_rates_", "[", "grp_idx", "]", ")", "if", "trivial", "else", "X", "\n", "return", "func", "(", "y", "[", "idx", "]", ",", "pred", "[", "idx", "]", ",", "pos_label", ",", "sample_weight", "[", "idx", "]", ")", "\n", "\n", "", "self", ".", "base_rates_", "=", "[", "_eval", "(", "base_rate", ",", "i", ")", "for", "i", "in", "range", "(", "2", ")", "]", "\n", "\n", "costs", "=", "np", ".", "array", "(", "[", "[", "_eval", "(", "self", ".", "_weighted_cost", ",", "i", ",", "t", ")", "for", "i", "in", "range", "(", "2", ")", "]", "\n", "for", "t", "in", "(", "False", ",", "True", ")", "]", ")", "\n", "self", ".", "mix_rates_", "=", "[", "\n", "(", "costs", "[", "0", ",", "1", "]", "-", "costs", "[", "0", ",", "0", "]", ")", "/", "(", "costs", "[", "1", ",", "0", "]", "-", "costs", "[", "0", ",", "0", "]", ")", ",", "\n", "(", "costs", "[", "0", ",", "0", "]", "-", "costs", "[", "0", ",", "1", "]", ")", "/", "(", "costs", "[", "1", ",", "1", "]", "-", "costs", "[", "0", ",", "1", "]", ")", "]", "\n", "self", ".", "mix_rates_", "[", "np", ".", "argmax", "(", "costs", "[", "0", "]", ")", "]", "=", "0", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_equalized_odds.CalibratedEqualizedOdds.predict_proba": [[146, 181], ["sklearn.utils.validation.check_is_fitted", "sklearn.utils.check_random_state", "aif360.sklearn.utils.check_groups", "numpy.empty_like", "range", "ValueError", "X[].copy", "set", "set", "numpy.nonzero", "sklearn.utils.check_random_state.rand", "numpy.unique", "numpy.unique", "sum"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "predict_proba", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"The returned estimates for all classes are ordered by the label of\n        classes.\n\n        Args:\n            X (pandas.DataFrame): Probability estimates of the targets as\n                returned by a ``predict_proba()`` call or equivalent. Note: must\n                include protected attributes in the index.\n\n        Returns:\n            numpy.ndarray: Returns the probability of the sample for each class\n            in the model, where classes are ordered as they are in\n            ``self.classes_``.\n        \"\"\"", "\n", "check_is_fitted", "(", "self", ",", "'mix_rates_'", ")", "\n", "rng", "=", "check_random_state", "(", "self", ".", "random_state", ")", "\n", "\n", "groups", ",", "_", "=", "check_groups", "(", "X", ",", "self", ".", "prot_attr_", ")", "\n", "if", "not", "set", "(", "np", ".", "unique", "(", "groups", ")", ")", "<=", "set", "(", "self", ".", "groups_", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'The protected groups from X:\\n{}\\ndo not '", "\n", "'match those from the training set:\\n{}'", ".", "format", "(", "\n", "np", ".", "unique", "(", "groups", ")", ",", "self", ".", "groups_", ")", ")", "\n", "\n", "", "pos_idx", "=", "np", ".", "nonzero", "(", "self", ".", "classes_", "==", "self", ".", "pos_label_", ")", "[", "0", "]", "[", "0", "]", "\n", "X", "=", "X", ".", "iloc", "[", ":", ",", "pos_idx", "]", "\n", "\n", "yt", "=", "np", ".", "empty_like", "(", "X", ")", "\n", "for", "grp_idx", "in", "range", "(", "2", ")", ":", "\n", "            ", "i", "=", "(", "groups", "==", "self", ".", "groups_", "[", "grp_idx", "]", ")", "\n", "to_replace", "=", "(", "rng", ".", "rand", "(", "sum", "(", "i", ")", ")", "<", "self", ".", "mix_rates_", "[", "grp_idx", "]", ")", "\n", "new_preds", "=", "X", "[", "i", "]", ".", "copy", "(", ")", "\n", "new_preds", "[", "to_replace", "]", "=", "self", ".", "base_rates_", "[", "grp_idx", "]", "\n", "yt", "[", "i", "]", "=", "new_preds", "\n", "\n", "", "return", "np", ".", "c_", "[", "1", "-", "yt", ",", "yt", "]", "if", "pos_idx", "==", "1", "else", "np", ".", "c_", "[", "yt", ",", "1", "-", "yt", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_equalized_odds.CalibratedEqualizedOdds.predict": [[182, 195], ["calibrated_equalized_odds.CalibratedEqualizedOdds.predict_proba", "calibrated_equalized_odds.CalibratedEqualizedOdds.argmax"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Predict class labels for the given scores.\n\n        Args:\n            X (pandas.DataFrame): Probability estimates of the targets as\n                returned by a ``predict_proba()`` call or equivalent. Note: must\n                include protected attributes in the index.\n\n        Returns:\n            numpy.ndarray: Predicted class label per sample.\n        \"\"\"", "\n", "scores", "=", "self", ".", "predict_proba", "(", "X", ")", "\n", "return", "self", ".", "classes_", "[", "scores", ".", "argmax", "(", "axis", "=", "1", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.calibrated_equalized_odds.CalibratedEqualizedOdds.score": [[196, 218], ["sklearn.utils.validation.check_is_fitted", "abs", "calibrated_equalized_odds.CalibratedEqualizedOdds.predict_proba", "aif360.sklearn.metrics.difference", "numpy.nonzero"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "score", "(", "self", ",", "X", ",", "y", ",", "sample_weight", "=", "None", ")", ":", "\n", "        ", "\"\"\"Score the predictions according to the cost constraint specified.\n\n        Args:\n            X (pandas.DataFrame): Probability estimates of the targets as\n                returned by a ``predict_proba()`` call or equivalent. Note: must\n                include protected attributes in the index.\n            y (array-like): Ground-truth (correct) target values.\n            sample_weight (array-like, optional): Sample weights.\n\n        Returns:\n            float: Absolute value of the difference in cost function for the two\n            groups (e.g. :func:`~aif360.sklearn.metrics.generalized_fpr` if\n            ``self.cost_constraint`` is 'fpr')\n        \"\"\"", "\n", "check_is_fitted", "(", "self", ",", "[", "'classes_'", ",", "'pos_label_'", "]", ")", "\n", "pos_idx", "=", "np", ".", "nonzero", "(", "self", ".", "classes_", "==", "self", ".", "pos_label_", ")", "[", "0", "]", "[", "0", "]", "\n", "probas_pred", "=", "self", ".", "predict_proba", "(", "X", ")", "[", ":", ",", "pos_idx", "]", "\n", "\n", "return", "abs", "(", "difference", "(", "self", ".", "_weighted_cost", ",", "y", ",", "probas_pred", ",", "\n", "prot_attr", "=", "self", ".", "prot_attr_", ",", "priv_group", "=", "self", ".", "groups_", "[", "1", "]", ",", "\n", "pos_label", "=", "self", ".", "pos_label_", ",", "sample_weight", "=", "sample_weight", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta.__init__": [[33, 56], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta._estimator_type": [[57, 60], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta.classes_": [[61, 65], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta.fit": [[66, 134], ["sklearn.base.clone", "__init__.PostProcessingMeta.options.copy", "pandas.DataFrame().squeeze", "fit_params.copy.copy.copy", "fit_params.copy.copy.update", "__init__.PostProcessingMeta.postprocessor_.fit", "sklearn.base.clone", "TypeError", "len", "pandas.DataFrame().squeeze", "fit_params.copy.copy.copy", "fit_params.copy.copy.update", "__init__.PostProcessingMeta.postprocessor_.fit", "logging.warning", "sklearn.model_selection.train_test_split", "__init__.PostProcessingMeta.estimator_.fit", "sklearn.model_selection.train_test_split", "__init__.PostProcessingMeta.estimator_.fit", "__init__.PostProcessingMeta.estimator_.predict_proba", "__init__.PostProcessingMeta.estimator_.predict", "__init__.PostProcessingMeta.postprocessor._get_tags", "TypeError", "hasattr", "logging.warning", "__init__.PostProcessingMeta.estimator_.predict_proba", "__init__.PostProcessingMeta.estimator_.predict", "pandas.DataFrame", "type", "pandas.DataFrame", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta.predict": [[135, 153], ["sklearn.utils.metaestimators.if_delegate_has_method", "pandas.DataFrame().squeeze", "__init__.PostProcessingMeta.postprocessor_.predict", "__init__.PostProcessingMeta.postprocessor_._get_tags", "__init__.PostProcessingMeta.estimator_.predict_proba", "__init__.PostProcessingMeta.estimator_.predict", "pandas.DataFrame"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta.predict_proba": [[154, 177], ["sklearn.utils.metaestimators.if_delegate_has_method", "pandas.DataFrame().squeeze", "__init__.PostProcessingMeta.postprocessor_.predict_proba", "__init__.PostProcessingMeta.postprocessor_._get_tags", "__init__.PostProcessingMeta.estimator_.predict_proba", "__init__.PostProcessingMeta.estimator_.predict", "pandas.DataFrame"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta.predict_log_proba": [[178, 201], ["sklearn.utils.metaestimators.if_delegate_has_method", "pandas.DataFrame().squeeze", "__init__.PostProcessingMeta.postprocessor_.predict_log_proba", "__init__.PostProcessingMeta.postprocessor_._get_tags", "__init__.PostProcessingMeta.estimator_.predict_proba", "__init__.PostProcessingMeta.estimator_.predict", "pandas.DataFrame"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta.predict_log_proba", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.__init__.PostProcessingMeta.score": [[202, 227], ["sklearn.utils.metaestimators.if_delegate_has_method", "pandas.DataFrame().squeeze", "__init__.PostProcessingMeta.postprocessor_.score", "__init__.PostProcessingMeta.postprocessor_._get_tags", "__init__.PostProcessingMeta.estimator_.predict_proba", "__init__.PostProcessingMeta.estimator_.predict", "__init__.PostProcessingMeta.postprocessor_.score", "pandas.DataFrame"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier.__init__": [[73, 94], ["None"], "methods", ["None"], ["if", "(", "(", "self", ".", "low_class_thresh", "<", "0.0", ")", "or", "(", "self", ".", "low_class_thresh", ">", "1.0", ")", "or", "(", "self", ".", "high_class_thresh", "<", "0.0", ")", "or", "(", "self", ".", "high_class_thresh", ">", "1.0", ")", "or", "(", "self", ".", "low_class_thresh", ">=", "self", ".", "high_class_thresh", ")", "or", "(", "self", ".", "num_class_thresh", "<", "1", ")", "or", "(", "self", ".", "num_ROC_margin", "<", "1", ")", ")", ":", "\n", "\n", "            ", "raise", "ValueError", "(", "\"Input parameter values out of bounds\"", ")", "\n", "\n", "", "if", "metric_name", "not", "in", "allowed_metrics", ":", "\n", "            ", "raise", "ValueError", "(", "\"metric name not in the list of allowed metrics\"", ")", "\n", "\n", "", "", "def", "fit", "(", "self", ",", "dataset_true", ",", "dataset_pred", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier._more_tags": [[95, 97], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier.fit": [[98, 149], ["numpy.unique", "aif360.sklearn.utils.check_groups", "numpy.array", "numpy.unique", "len", "ValueError", "ValueError", "ValueError", "ValueError", "ValueError", "aif360.sklearn.utils.check_groups", "min", "min"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups", "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups"], ["\n", "\n", "fair_metric_arr", "=", "np", ".", "zeros", "(", "self", ".", "num_class_thresh", "*", "self", ".", "num_ROC_margin", ")", "\n", "balanced_acc_arr", "=", "np", ".", "zeros_like", "(", "fair_metric_arr", ")", "\n", "ROC_margin_arr", "=", "np", ".", "zeros_like", "(", "fair_metric_arr", ")", "\n", "class_thresh_arr", "=", "np", ".", "zeros_like", "(", "fair_metric_arr", ")", "\n", "\n", "cnt", "=", "0", "\n", "# Iterate through class thresholds", "\n", "for", "class_thresh", "in", "np", ".", "linspace", "(", "self", ".", "low_class_thresh", ",", "\n", "self", ".", "high_class_thresh", ",", "\n", "self", ".", "num_class_thresh", ")", ":", "\n", "\n", "            ", "self", ".", "classification_threshold", "=", "class_thresh", "\n", "if", "class_thresh", "<=", "0.5", ":", "\n", "                ", "low_ROC_margin", "=", "0.0", "\n", "high_ROC_margin", "=", "class_thresh", "\n", "", "else", ":", "\n", "                ", "low_ROC_margin", "=", "0.0", "\n", "high_ROC_margin", "=", "(", "1.0", "-", "class_thresh", ")", "\n", "\n", "# Iterate through ROC margins", "\n", "", "for", "ROC_margin", "in", "np", ".", "linspace", "(", "\n", "low_ROC_margin", ",", "\n", "high_ROC_margin", ",", "\n", "self", ".", "num_ROC_margin", ")", ":", "\n", "                ", "self", ".", "ROC_margin", "=", "ROC_margin", "\n", "\n", "# Predict using the current threshold and margin", "\n", "dataset_transf_pred", "=", "self", ".", "predict", "(", "dataset_pred", ")", "\n", "\n", "dataset_transf_metric_pred", "=", "BinaryLabelDatasetMetric", "(", "\n", "dataset_transf_pred", ",", "\n", "unprivileged_groups", "=", "self", ".", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "self", ".", "privileged_groups", ")", "\n", "classified_transf_metric", "=", "ClassificationMetric", "(", "\n", "dataset_true", ",", "\n", "dataset_transf_pred", ",", "\n", "unprivileged_groups", "=", "self", ".", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "self", ".", "privileged_groups", ")", "\n", "\n", "ROC_margin_arr", "[", "cnt", "]", "=", "self", ".", "ROC_margin", "\n", "class_thresh_arr", "[", "cnt", "]", "=", "self", ".", "classification_threshold", "\n", "\n", "# Balanced accuracy and fairness metric computations", "\n", "balanced_acc_arr", "[", "cnt", "]", "=", "0.5", "*", "(", "classified_transf_metric", ".", "true_positive_rate", "(", ")", "+", "classified_transf_metric", ".", "true_negative_rate", "(", ")", ")", "\n", "if", "self", ".", "metric_name", "==", "\"Statistical parity difference\"", ":", "\n", "                    ", "fair_metric_arr", "[", "cnt", "]", "=", "dataset_transf_metric_pred", ".", "mean_difference", "(", ")", "\n", "", "elif", "self", ".", "metric_name", "==", "\"Average odds difference\"", ":", "\n", "                    ", "fair_metric_arr", "[", "cnt", "]", "=", "classified_transf_metric", ".", "average_odds_difference", "(", ")", "\n", "", "elif", "self", ".", "metric_name", "==", "\"Equal opportunity difference\"", ":", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier.predict": [[150, 183], ["sklearn.utils.validation.check_is_fitted", "aif360.sklearn.utils.check_groups", "X.iloc[].to_numpy.iloc[].to_numpy.iloc[].to_numpy", "len", "ValueError", "abs", "numpy.nonzero"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups"], ["                    ", "fair_metric_arr", "[", "cnt", "]", "=", "classified_transf_metric", ".", "equal_opportunity_difference", "(", ")", "\n", "\n", "", "cnt", "+=", "1", "\n", "\n", "", "", "rel_inds", "=", "np", ".", "logical_and", "(", "fair_metric_arr", ">=", "self", ".", "metric_lb", ",", "\n", "fair_metric_arr", "<=", "self", ".", "metric_ub", ")", "\n", "if", "any", "(", "rel_inds", ")", ":", "\n", "            ", "best_ind", "=", "np", ".", "where", "(", "balanced_acc_arr", "[", "rel_inds", "]", "\n", "==", "np", ".", "max", "(", "balanced_acc_arr", "[", "rel_inds", "]", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "warn", "(", "\"Unable to satisy fairness constraints\"", ")", "\n", "rel_inds", "=", "np", ".", "ones", "(", "len", "(", "fair_metric_arr", ")", ",", "dtype", "=", "bool", ")", "\n", "best_ind", "=", "np", ".", "where", "(", "fair_metric_arr", "[", "rel_inds", "]", "\n", "==", "np", ".", "min", "(", "fair_metric_arr", "[", "rel_inds", "]", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "\n", "", "self", ".", "ROC_margin", "=", "ROC_margin_arr", "[", "rel_inds", "]", "[", "best_ind", "]", "\n", "self", ".", "classification_threshold", "=", "class_thresh_arr", "[", "rel_inds", "]", "[", "best_ind", "]", "\n", "\n", "return", "self", "\n", "\n", "", "def", "predict", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Obtain fair predictions using the ROC method.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing scores that will\n                be used to compute predicted labels.\n\n        Returns:\n            dataset_pred (BinaryLabelDataset): Output dataset with potentially\n            fair predictions obtain using the ROC method.\n        \"\"\"", "\n", "dataset_new", "=", "dataset", ".", "copy", "(", "deepcopy", "=", "False", ")", "\n", "\n", "fav_pred_inds", "=", "(", "dataset", ".", "scores", ">", "self", ".", "classification_threshold", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier.fit_predict": [[184, 204], ["reject_option_classification.RejectOptionClassifier.fit().predict", "reject_option_classification.RejectOptionClassifier.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["unfav_pred_inds", "=", "~", "fav_pred_inds", "\n", "\n", "y_pred", "=", "np", ".", "zeros", "(", "dataset", ".", "scores", ".", "shape", ")", "\n", "y_pred", "[", "fav_pred_inds", "]", "=", "dataset", ".", "favorable_label", "\n", "y_pred", "[", "unfav_pred_inds", "]", "=", "dataset", ".", "unfavorable_label", "\n", "\n", "# Indices of critical region around the classification boundary", "\n", "crit_region_inds", "=", "np", ".", "logical_and", "(", "\n", "dataset", ".", "scores", "<=", "self", ".", "classification_threshold", "+", "self", ".", "ROC_margin", ",", "\n", "dataset", ".", "scores", ">", "self", ".", "classification_threshold", "-", "self", ".", "ROC_margin", ")", "\n", "\n", "# Indices of privileged and unprivileged groups", "\n", "cond_priv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "privileged_groups", ")", "\n", "cond_unpriv", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "dataset", ".", "protected_attributes", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "unprivileged_groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifierCV.__init__": [[235, 270], ["sklearn.model_selection.GridSearchCV.__init__", "reject_option_classification.RejectOptionClassifier"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["is_efficient", "=", "is_efficient", "[", "nondominated_point_mask", "]", "# Remove dominated points", "\n", "scores", "=", "scores", "[", "nondominated_point_mask", "]", "\n", "next_point_index", "=", "np", ".", "sum", "(", "nondominated_point_mask", "[", ":", "next_point_index", "]", ")", "+", "1", "\n", "\n", "", "if", "return_mask", ":", "\n", "        ", "is_efficient_mask", "=", "np", ".", "zeros", "(", "n_points", ",", "dtype", "=", "bool", ")", "\n", "is_efficient_mask", "[", "is_efficient", "]", "=", "True", "\n", "return", "is_efficient_mask", "\n", "", "else", ":", "\n", "        ", "return", "is_efficient", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifierCV._more_tags": [[271, 273], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifierCV.fit": [[274, 344], ["numpy.arange", "enumerate", "NoSplit", "super().fit", "min", "numpy.linspace", "reject_option_classification.RejectOptionClassifierCV.param_grid.append", "fit_params.get", "warnings.warn", "isinstance", "min", "min", "aif360.sklearn.metrics.make_scorer", "len", "min", "aif360.sklearn.metrics.make_scorer", "numpy.ma.array().argmax", "numpy.ma.array().argmax", "aif360.sklearn.metrics.make_scorer", "numpy.arange", "numpy.arange", "aif360.sklearn.metrics.make_scorer", "numpy.ma.array", "numpy.ma.array", "len", "len", "callable", "ValueError"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer"], []], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.adversarial_debiasing.AdversarialDebiasing.__init__": [[44, 82], ["None"], "methods", ["None"], ["\n", "super", "(", "AdversarialDebiasing", ",", "self", ")", ".", "__init__", "(", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ")", "\n", "\n", "self", ".", "scope_name", "=", "scope_name", "\n", "self", ".", "seed", "=", "seed", "\n", "\n", "self", ".", "unprivileged_groups", "=", "unprivileged_groups", "\n", "self", ".", "privileged_groups", "=", "privileged_groups", "\n", "if", "len", "(", "self", ".", "unprivileged_groups", ")", ">", "1", "or", "len", "(", "self", ".", "privileged_groups", ")", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only one unprivileged_group or privileged_group supported.\"", ")", "\n", "", "self", ".", "protected_attribute_name", "=", "list", "(", "self", ".", "unprivileged_groups", "[", "0", "]", ".", "keys", "(", ")", ")", "[", "0", "]", "\n", "\n", "self", ".", "sess", "=", "sess", "\n", "self", ".", "adversary_loss_weight", "=", "adversary_loss_weight", "\n", "self", ".", "num_epochs", "=", "num_epochs", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "classifier_num_hidden_units", "=", "classifier_num_hidden_units", "\n", "self", ".", "debias", "=", "debias", "\n", "\n", "self", ".", "features_dim", "=", "None", "\n", "self", ".", "features_ph", "=", "None", "\n", "self", ".", "protected_attributes_ph", "=", "None", "\n", "self", ".", "true_labels_ph", "=", "None", "\n", "self", ".", "pred_labels", "=", "None", "\n", "\n", "", "def", "_classifier_model", "(", "self", ",", "features", ",", "features_dim", ",", "keep_prob", ")", ":", "\n", "        ", "\"\"\"Compute the classifier predictions for the outcome variable.\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.adversarial_debiasing.AdversarialDebiasing._classifier_model": [[80, 99], ["tf.variable_scope", "tf.get_variable", "tf.Variable", "tf.nn.relu", "tf.nn.dropout", "tf.get_variable", "tf.Variable", "tf.sigmoid", "tf.zeros", "tf.zeros", "tf.matmul", "tf.initializers.glorot_uniform", "tf.matmul", "tf.initializers.glorot_uniform"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.sigmoid"], ["", "def", "_classifier_model", "(", "self", ",", "features", ",", "features_dim", ",", "keep_prob", ")", ":", "\n", "        ", "\"\"\"Compute the classifier predictions for the outcome variable.\n        \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "\"classifier_model\"", ")", ":", "\n", "            ", "W1", "=", "tf", ".", "get_variable", "(", "'W1'", ",", "[", "features_dim", ",", "self", ".", "classifier_num_hidden_units", "]", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "glorot_uniform", "(", "seed", "=", "self", ".", "seed1", ")", ")", "\n", "b1", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "shape", "=", "[", "self", ".", "classifier_num_hidden_units", "]", ")", ",", "name", "=", "'b1'", ")", "\n", "\n", "h1", "=", "tf", ".", "nn", ".", "relu", "(", "tf", ".", "matmul", "(", "features", ",", "W1", ")", "+", "b1", ")", "\n", "h1", "=", "tf", ".", "nn", ".", "dropout", "(", "h1", ",", "keep_prob", "=", "keep_prob", ",", "seed", "=", "self", ".", "seed2", ")", "\n", "\n", "W2", "=", "tf", ".", "get_variable", "(", "'W2'", ",", "[", "self", ".", "classifier_num_hidden_units", ",", "1", "]", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "glorot_uniform", "(", "seed", "=", "self", ".", "seed3", ")", ")", "\n", "b2", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "shape", "=", "[", "1", "]", ")", ",", "name", "=", "'b2'", ")", "\n", "\n", "pred_logit", "=", "tf", ".", "matmul", "(", "h1", ",", "W2", ")", "+", "b2", "\n", "pred_label", "=", "tf", ".", "sigmoid", "(", "pred_logit", ")", "\n", "\n", "", "return", "pred_label", ",", "pred_logit", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.adversarial_debiasing.AdversarialDebiasing._adversary_model": [[100, 115], ["tf.variable_scope", "tf.get_variable", "tf.sigmoid", "tf.get_variable", "tf.Variable", "tf.sigmoid", "tf.zeros", "tf.matmul", "tf.constant", "tf.initializers.glorot_uniform", "tf.concat", "tf.abs"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.sigmoid", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.sigmoid"], ["", "def", "_adversary_model", "(", "self", ",", "pred_logits", ",", "true_labels", ")", ":", "\n", "        ", "\"\"\"Compute the adversary predictions for the protected attribute.\n        \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "\"adversary_model\"", ")", ":", "\n", "            ", "c", "=", "tf", ".", "get_variable", "(", "'c'", ",", "initializer", "=", "tf", ".", "constant", "(", "1.0", ")", ")", "\n", "s", "=", "tf", ".", "sigmoid", "(", "(", "1", "+", "tf", ".", "abs", "(", "c", ")", ")", "*", "pred_logits", ")", "\n", "\n", "W2", "=", "tf", ".", "get_variable", "(", "'W2'", ",", "[", "3", ",", "1", "]", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "glorot_uniform", "(", "seed", "=", "self", ".", "seed4", ")", ")", "\n", "b2", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "shape", "=", "[", "1", "]", ")", ",", "name", "=", "'b2'", ")", "\n", "\n", "pred_protected_attribute_logit", "=", "tf", ".", "matmul", "(", "tf", ".", "concat", "(", "[", "s", ",", "s", "*", "true_labels", ",", "s", "*", "(", "1.0", "-", "true_labels", ")", "]", ",", "axis", "=", "1", ")", ",", "W2", ")", "+", "b2", "\n", "pred_protected_attribute_label", "=", "tf", ".", "sigmoid", "(", "pred_protected_attribute_logit", ")", "\n", "\n", "", "return", "pred_protected_attribute_label", ",", "pred_protected_attribute_logit", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.adversarial_debiasing.AdversarialDebiasing.fit": [[83, 271], ["tensorflow.executing_eagerly", "aif360.sklearn.utils.check_inputs", "sklearn.utils.check_random_state", "numpy.iinfo", "sklearn.utils.check_random_state.randint", "tensorflow.reset_default_graph", "tensorflow.Session", "aif360.sklearn.utils.check_groups", "sklearn.preprocessing.LabelEncoder", "sklearn.preprocessing.LabelEncoder.fit_transform", "sklearn.preprocessing.LabelEncoder.fit_transform.map", "sklearn.preprocessing.LabelEncoder.fit_transform", "len", "len", "RuntimeError", "tensorflow.variable_scope", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.Variable", "tensorflow.train.AdamOptimizer", "tensorflow.train.AdamOptimizer.compute_gradients", "tensorflow.train.AdamOptimizer.apply_gradients", "adversarial_debiasing.AdversarialDebiasing.sess_.run", "range", "tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.Variable", "tensorflow.nn.relu", "tensorflow.nn.dropout", "tensorflow.get_variable", "tensorflow.Variable", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.train.exponential_decay", "tensorflow.train.inverse_time_decay", "tensorflow.train.AdamOptimizer", "clf_grads.append", "tensorflow.global_variables_initializer", "sklearn.utils.check_random_state.permutation", "range", "tensorflow.zeros", "tensorflow.zeros", "tensorflow.matmul", "tensorflow.nn.sigmoid_cross_entropy_with_logits", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.sigmoid", "tensorflow.get_variable", "tensorflow.Variable", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.trainable_variables", "normalize", "tensorflow.control_dependencies", "tensorflow.train.AdamOptimizer.minimize", "tensorflow.initializers.glorot_uniform", "tensorflow.matmul", "tensorflow.initializers.glorot_uniform", "tensorflow.zeros", "tensorflow.matmul", "tensorflow.nn.sigmoid_cross_entropy_with_logits", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "tensorflow.trainable_variables", "tensorflow.train.AdamOptimizer.compute_gradients", "tensorflow.norm", "tensorflow.reduce_sum", "adversarial_debiasing.AdversarialDebiasing.sess_.run", "adversarial_debiasing.AdversarialDebiasing.sess_.run", "tensorflow.squeeze", "tensorflow.constant", "tensorflow.initializers.glorot_uniform", "tensorflow.concat", "numpy.finfo", "tensorflow.sqrt", "print", "print", "tensorflow.cast", "tensorflow.abs", "tensorflow.squeeze", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_inputs", "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.sigmoid"], ["with", "tf", ".", "variable_scope", "(", "\"classifier_model\"", ")", ":", "\n", "            ", "W1", "=", "tf", ".", "get_variable", "(", "'W1'", ",", "[", "features_dim", ",", "self", ".", "classifier_num_hidden_units", "]", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "glorot_uniform", "(", "seed", "=", "self", ".", "seed1", ")", ")", "\n", "b1", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "shape", "=", "[", "self", ".", "classifier_num_hidden_units", "]", ")", ",", "name", "=", "'b1'", ")", "\n", "\n", "h1", "=", "tf", ".", "nn", ".", "relu", "(", "tf", ".", "matmul", "(", "features", ",", "W1", ")", "+", "b1", ")", "\n", "h1", "=", "tf", ".", "nn", ".", "dropout", "(", "h1", ",", "keep_prob", "=", "keep_prob", ",", "seed", "=", "self", ".", "seed2", ")", "\n", "\n", "W2", "=", "tf", ".", "get_variable", "(", "'W2'", ",", "[", "self", ".", "classifier_num_hidden_units", ",", "1", "]", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "glorot_uniform", "(", "seed", "=", "self", ".", "seed3", ")", ")", "\n", "b2", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "shape", "=", "[", "1", "]", ")", ",", "name", "=", "'b2'", ")", "\n", "\n", "pred_logit", "=", "tf", ".", "matmul", "(", "h1", ",", "W2", ")", "+", "b2", "\n", "pred_label", "=", "tf", ".", "sigmoid", "(", "pred_logit", ")", "\n", "\n", "", "return", "pred_label", ",", "pred_logit", "\n", "\n", "", "def", "_adversary_model", "(", "self", ",", "pred_logits", ",", "true_labels", ")", ":", "\n", "        ", "\"\"\"Compute the adversary predictions for the protected attribute.\n        \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "\"adversary_model\"", ")", ":", "\n", "            ", "c", "=", "tf", ".", "get_variable", "(", "'c'", ",", "initializer", "=", "tf", ".", "constant", "(", "1.0", ")", ")", "\n", "s", "=", "tf", ".", "sigmoid", "(", "(", "1", "+", "tf", ".", "abs", "(", "c", ")", ")", "*", "pred_logits", ")", "\n", "\n", "W2", "=", "tf", ".", "get_variable", "(", "'W2'", ",", "[", "3", ",", "1", "]", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "glorot_uniform", "(", "seed", "=", "self", ".", "seed4", ")", ")", "\n", "b2", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "shape", "=", "[", "1", "]", ")", ",", "name", "=", "'b2'", ")", "\n", "\n", "pred_protected_attribute_logit", "=", "tf", ".", "matmul", "(", "tf", ".", "concat", "(", "[", "s", ",", "s", "*", "true_labels", ",", "s", "*", "(", "1.0", "-", "true_labels", ")", "]", ",", "axis", "=", "1", ")", ",", "W2", ")", "+", "b2", "\n", "pred_protected_attribute_label", "=", "tf", ".", "sigmoid", "(", "pred_protected_attribute_logit", ")", "\n", "\n", "", "return", "pred_protected_attribute_label", ",", "pred_protected_attribute_logit", "\n", "\n", "", "def", "fit", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Compute the model parameters of the fair classifier using gradient\n        descent.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing true labels.\n\n        Returns:\n            AdversarialDebiasing: Returns self.\n        \"\"\"", "\n", "if", "tf", ".", "executing_eagerly", "(", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"AdversarialDebiasing does not work in eager \"", "\n", "\"execution mode. To fix, add `tf.disable_eager_execution()`\"", "\n", "\" to the top of the calling script.\"", ")", "\n", "\n", "", "if", "self", ".", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "", "ii32", "=", "np", ".", "iinfo", "(", "np", ".", "int32", ")", "\n", "self", ".", "seed1", ",", "self", ".", "seed2", ",", "self", ".", "seed3", ",", "self", ".", "seed4", "=", "np", ".", "random", ".", "randint", "(", "ii32", ".", "min", ",", "ii32", ".", "max", ",", "size", "=", "4", ")", "\n", "\n", "# Map the dataset labels to 0 and 1.", "\n", "temp_labels", "=", "dataset", ".", "labels", ".", "copy", "(", ")", "\n", "\n", "temp_labels", "[", "(", "dataset", ".", "labels", "==", "dataset", ".", "favorable_label", ")", ".", "ravel", "(", ")", ",", "0", "]", "=", "1.0", "\n", "temp_labels", "[", "(", "dataset", ".", "labels", "==", "dataset", ".", "unfavorable_label", ")", ".", "ravel", "(", ")", ",", "0", "]", "=", "0.0", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope_name", ")", ":", "\n", "            ", "num_train_samples", ",", "self", ".", "features_dim", "=", "np", ".", "shape", "(", "dataset", ".", "features", ")", "\n", "\n", "# Setup placeholders", "\n", "self", ".", "features_ph", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "[", "None", ",", "self", ".", "features_dim", "]", ")", "\n", "self", ".", "protected_attributes_ph", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "[", "None", ",", "1", "]", ")", "\n", "self", ".", "true_labels_ph", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "[", "None", ",", "1", "]", ")", "\n", "self", ".", "keep_prob", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ")", "\n", "\n", "# Obtain classifier predictions and classifier loss", "\n", "self", ".", "pred_labels", ",", "pred_logits", "=", "self", ".", "_classifier_model", "(", "self", ".", "features_ph", ",", "self", ".", "features_dim", ",", "self", ".", "keep_prob", ")", "\n", "pred_labels_loss", "=", "tf", ".", "reduce_mean", "(", "tf", ".", "nn", ".", "sigmoid_cross_entropy_with_logits", "(", "labels", "=", "self", ".", "true_labels_ph", ",", "logits", "=", "pred_logits", ")", ")", "\n", "\n", "if", "self", ".", "debias", ":", "\n", "# Obtain adversary predictions and adversary loss", "\n", "                ", "pred_protected_attributes_labels", ",", "pred_protected_attributes_logits", "=", "self", ".", "_adversary_model", "(", "pred_logits", ",", "self", ".", "true_labels_ph", ")", "\n", "pred_protected_attributes_loss", "=", "tf", ".", "reduce_mean", "(", "\n", "tf", ".", "nn", ".", "sigmoid_cross_entropy_with_logits", "(", "labels", "=", "self", ".", "protected_attributes_ph", ",", "logits", "=", "pred_protected_attributes_logits", ")", ")", "\n", "\n", "# Setup optimizers with learning rates", "\n", "", "global_step", "=", "tf", ".", "Variable", "(", "0", ",", "trainable", "=", "False", ")", "\n", "starter_learning_rate", "=", "0.001", "\n", "learning_rate", "=", "tf", ".", "train", ".", "exponential_decay", "(", "starter_learning_rate", ",", "global_step", ",", "\n", "1000", ",", "0.96", ",", "staircase", "=", "True", ")", "\n", "classifier_opt", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", ")", "\n", "if", "self", ".", "debias", ":", "\n", "                ", "adversary_opt", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", ")", "\n", "\n", "", "classifier_vars", "=", "[", "var", "for", "var", "in", "tf", ".", "trainable_variables", "(", ")", "if", "'classifier_model'", "in", "var", ".", "name", "]", "\n", "if", "self", ".", "debias", ":", "\n", "                ", "adversary_vars", "=", "[", "var", "for", "var", "in", "tf", ".", "trainable_variables", "(", ")", "if", "'adversary_model'", "in", "var", ".", "name", "]", "\n", "# Update classifier parameters", "\n", "adversary_grads", "=", "{", "var", ":", "grad", "for", "(", "grad", ",", "var", ")", "in", "adversary_opt", ".", "compute_gradients", "(", "pred_protected_attributes_loss", ",", "\n", "var_list", "=", "classifier_vars", ")", "}", "\n", "", "normalize", "=", "lambda", "x", ":", "x", "/", "(", "tf", ".", "norm", "(", "x", ")", "+", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "tiny", ")", "\n", "\n", "classifier_grads", "=", "[", "]", "\n", "for", "(", "grad", ",", "var", ")", "in", "classifier_opt", ".", "compute_gradients", "(", "pred_labels_loss", ",", "var_list", "=", "classifier_vars", ")", ":", "\n", "                ", "if", "self", ".", "debias", ":", "\n", "                    ", "unit_adversary_grad", "=", "normalize", "(", "adversary_grads", "[", "var", "]", ")", "\n", "grad", "-=", "tf", ".", "reduce_sum", "(", "grad", "*", "unit_adversary_grad", ")", "*", "unit_adversary_grad", "\n", "grad", "-=", "self", ".", "adversary_loss_weight", "*", "adversary_grads", "[", "var", "]", "\n", "", "classifier_grads", ".", "append", "(", "(", "grad", ",", "var", ")", ")", "\n", "", "classifier_minimizer", "=", "classifier_opt", ".", "apply_gradients", "(", "classifier_grads", ",", "global_step", "=", "global_step", ")", "\n", "\n", "if", "self", ".", "debias", ":", "\n", "# Update adversary parameters", "\n", "                ", "with", "tf", ".", "control_dependencies", "(", "[", "classifier_minimizer", "]", ")", ":", "\n", "                    ", "adversary_minimizer", "=", "adversary_opt", ".", "minimize", "(", "pred_protected_attributes_loss", ",", "var_list", "=", "adversary_vars", ")", "#, global_step=global_step)", "\n", "\n", "", "", "self", ".", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "self", ".", "sess", ".", "run", "(", "tf", ".", "local_variables_initializer", "(", ")", ")", "\n", "\n", "# Begin training", "\n", "for", "epoch", "in", "range", "(", "self", ".", "num_epochs", ")", ":", "\n", "                ", "shuffled_ids", "=", "np", ".", "random", ".", "choice", "(", "num_train_samples", ",", "num_train_samples", ",", "replace", "=", "False", ")", "\n", "for", "i", "in", "range", "(", "num_train_samples", "//", "self", ".", "batch_size", ")", ":", "\n", "                    ", "batch_ids", "=", "shuffled_ids", "[", "self", ".", "batch_size", "*", "i", ":", "self", ".", "batch_size", "*", "(", "i", "+", "1", ")", "]", "\n", "batch_features", "=", "dataset", ".", "features", "[", "batch_ids", "]", "\n", "batch_labels", "=", "np", ".", "reshape", "(", "temp_labels", "[", "batch_ids", "]", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "batch_protected_attributes", "=", "np", ".", "reshape", "(", "dataset", ".", "protected_attributes", "[", "batch_ids", "]", "[", ":", ",", "\n", "dataset", ".", "protected_attribute_names", ".", "index", "(", "self", ".", "protected_attribute_name", ")", "]", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "\n", "batch_feed_dict", "=", "{", "self", ".", "features_ph", ":", "batch_features", ",", "\n", "self", ".", "true_labels_ph", ":", "batch_labels", ",", "\n", "self", ".", "protected_attributes_ph", ":", "batch_protected_attributes", ",", "\n", "self", ".", "keep_prob", ":", "0.8", "}", "\n", "if", "self", ".", "debias", ":", "\n", "                        ", "_", ",", "_", ",", "pred_labels_loss_value", ",", "pred_protected_attributes_loss_vale", "=", "self", ".", "sess", ".", "run", "(", "[", "classifier_minimizer", ",", "\n", "adversary_minimizer", ",", "\n", "pred_labels_loss", ",", "\n", "pred_protected_attributes_loss", "]", ",", "feed_dict", "=", "batch_feed_dict", ")", "\n", "if", "i", "%", "200", "==", "0", ":", "\n", "                            ", "print", "(", "\"epoch %d; iter: %d; batch classifier loss: %f; batch adversarial loss: %f\"", "%", "(", "epoch", ",", "i", ",", "pred_labels_loss_value", ",", "\n", "pred_protected_attributes_loss_vale", ")", ")", "\n", "", "", "else", ":", "\n", "                        ", "_", ",", "pred_labels_loss_value", "=", "self", ".", "sess", ".", "run", "(", "\n", "[", "classifier_minimizer", ",", "\n", "pred_labels_loss", "]", ",", "feed_dict", "=", "batch_feed_dict", ")", "\n", "if", "i", "%", "200", "==", "0", ":", "\n", "                            ", "print", "(", "\"epoch %d; iter: %d; batch classifier loss: %f\"", "%", "(", "\n", "epoch", ",", "i", ",", "pred_labels_loss_value", ")", ")", "\n", "", "", "", "", "", "return", "self", "\n", "\n", "", "def", "predict", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Obtain the predictions for the provided dataset using the fair\n        classifier learned.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing labels that needs\n                to be transformed.\n        Returns:\n            dataset (BinaryLabelDataset): Transformed dataset.\n        \"\"\"", "\n", "\n", "if", "self", ".", "seed", "is", "not", "None", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "self", ".", "seed", ")", "\n", "\n", "", "num_test_samples", ",", "_", "=", "np", ".", "shape", "(", "dataset", ".", "features", ")", "\n", "\n", "samples_covered", "=", "0", "\n", "pred_labels", "=", "[", "]", "\n", "while", "samples_covered", "<", "num_test_samples", ":", "\n", "            ", "start", "=", "samples_covered", "\n", "end", "=", "samples_covered", "+", "self", ".", "batch_size", "\n", "if", "end", ">", "num_test_samples", ":", "\n", "                ", "end", "=", "num_test_samples", "\n", "", "batch_ids", "=", "np", ".", "arange", "(", "start", ",", "end", ")", "\n", "batch_features", "=", "dataset", ".", "features", "[", "batch_ids", "]", "\n", "batch_labels", "=", "np", ".", "reshape", "(", "dataset", ".", "labels", "[", "batch_ids", "]", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "batch_protected_attributes", "=", "np", ".", "reshape", "(", "dataset", ".", "protected_attributes", "[", "batch_ids", "]", "[", ":", ",", "\n", "dataset", ".", "protected_attribute_names", ".", "index", "(", "self", ".", "protected_attribute_name", ")", "]", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "\n", "batch_feed_dict", "=", "{", "self", ".", "features_ph", ":", "batch_features", ",", "\n", "self", ".", "true_labels_ph", ":", "batch_labels", ",", "\n", "self", ".", "protected_attributes_ph", ":", "batch_protected_attributes", ",", "\n", "self", ".", "keep_prob", ":", "1.0", "}", "\n", "\n", "pred_labels", "+=", "self", ".", "sess", ".", "run", "(", "self", ".", "pred_labels", ",", "feed_dict", "=", "batch_feed_dict", ")", "[", ":", ",", "0", "]", ".", "tolist", "(", ")", "\n", "samples_covered", "+=", "len", "(", "batch_features", ")", "\n", "\n", "# Mutated, fairer dataset with new labels", "\n", "", "dataset_new", "=", "dataset", ".", "copy", "(", "deepcopy", "=", "True", ")", "\n", "dataset_new", ".", "scores", "=", "np", ".", "array", "(", "pred_labels", ",", "dtype", "=", "np", ".", "float64", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "dataset_new", ".", "labels", "=", "(", "np", ".", "array", "(", "pred_labels", ")", ">", "0.5", ")", ".", "astype", "(", "np", ".", "float64", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "\n", "# Map the dataset labels to back to their original values.", "\n", "temp_labels", "=", "dataset_new", ".", "labels", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.adversarial_debiasing.AdversarialDebiasing.predict": [[332, 347], ["adversarial_debiasing.AdversarialDebiasing.decision_function", "adversarial_debiasing.AdversarialDebiasing.argmax"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.adversarial_debiasing.AdversarialDebiasing.decision_function"], []], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.grid_search_reduction.GridSearchReduction.__init__": [[35, 132], ["isinstance", "fairlearn.GridSearch", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["\n", "def", "__init__", "(", "self", ",", "\n", "estimator", ",", "\n", "constraints", ",", "\n", "prot_attr", "=", "None", ",", "\n", "constraint_weight", "=", "0.5", ",", "\n", "grid_size", "=", "10", ",", "\n", "grid_limit", "=", "2.0", ",", "\n", "grid", "=", "None", ",", "\n", "drop_prot_attr", "=", "True", ",", "\n", "loss", "=", "\"ZeroOne\"", ",", "\n", "min_val", "=", "None", ",", "\n", "max_val", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            estimator: An estimator implementing methods ``fit(X, y,\n                sample_weight)`` and ``predict(X)``, where ``X`` is the matrix\n                of features, ``y`` is the vector of labels, and\n                ``sample_weight`` is a vector of weights; labels ``y`` and\n                predictions returned by ``predict(X)`` are either 0 or 1 -- e.g.\n                scikit-learn classifiers/regressors.\n            constraints (str or fairlearn.reductions.Moment): If string, keyword\n                denoting the :class:`fairlearn.reductions.Moment` object\n                defining the disparity constraints -- e.g., \"DemographicParity\"\n                or \"EqualizedOdds\". For a full list of possible options see\n                `self.model.moments`. Otherwise, provide the desired\n                :class:`~fairlearn.reductions.Moment` object defining the\n                disparity constraints.\n            prot_attr: String or array-like column indices or column names\n                of protected attributes.\n            constraint_weight: When the ``selection_rule`` is\n                \"tradeoff_optimization\" (default, no other option currently)\n                this float specifies the relative weight put on the constraint\n                violation when selecting the best model. The weight placed on\n                the error rate will be ``1-constraint_weight``.\n            grid_size (int): The number of Lagrange multipliers to generate in\n                the grid.\n            grid_limit (float): The largest Lagrange multiplier to generate. The\n                grid will contain values distributed between ``-grid_limit`` and\n                ``grid_limit`` by default.\n            grid (pandas.DataFrame): Instead of supplying a size and limit for\n                the grid, users may specify the exact set of Lagrange\n                multipliers they desire using this argument in a DataFrame.\n            drop_prot_attr (bool): Flag indicating whether to drop protected\n                attributes from training data.\n            loss (str): String identifying loss function for constraints.\n                Options include \"ZeroOne\", \"Square\", and \"Absolute.\"\n            min_val: Loss function parameter for \"Square\" and \"Absolute,\"\n                typically the minimum of the range of y values.\n            max_val: Loss function parameter for \"Square\" and \"Absolute,\"\n                typically the maximum of the range of y values.\n        \"\"\"", "\n", "super", "(", "GridSearchReduction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "#init model, set prot_attr during fit", "\n", "if", "prot_attr", "is", "None", ":", "\n", "            ", "prot_attr", "=", "[", "]", "\n", "", "self", ".", "model", "=", "skGridSearchRed", "(", "prot_attr", ",", "estimator", ",", "constraints", ",", "\n", "constraint_weight", ",", "grid_size", ",", "grid_limit", ",", "grid", ",", "drop_prot_attr", ",", "\n", "loss", ",", "min_val", ",", "max_val", ")", "\n", "\n", "\n", "", "def", "fit", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Learns model with less bias\n\n        Args:\n            dataset : Dataset containing true output.\n\n        Returns:\n            GridSearchReduction: Returns self.\n        \"\"\"", "\n", "#set prot_attr", "\n", "if", "len", "(", "self", ".", "model", ".", "prot_attr", ")", "==", "0", ":", "\n", "            ", "self", ".", "model", ".", "prot_attr", "=", "dataset", ".", "protected_attribute_names", "\n", "\n", "", "X_df", "=", "pd", ".", "DataFrame", "(", "dataset", ".", "features", ",", "columns", "=", "dataset", ".", "feature_names", ")", "\n", "Y", "=", "dataset", ".", "labels", "\n", "\n", "self", ".", "model", ".", "fit", "(", "X_df", ",", "Y", ")", "\n", "\n", "return", "self", "\n", "\n", "\n", "", "def", "predict", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Obtain the predictions for the provided dataset using the model\n        learned.\n\n        Args:\n            dataset: Dataset containing output values that need to be\n                transformed.\n\n        Returns:\n            dataset: Transformed dataset.\n        \"\"\"", "\n", "X_df", "=", "pd", ".", "DataFrame", "(", "dataset", ".", "features", ",", "columns", "=", "dataset", ".", "feature_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.grid_search_reduction.GridSearchReduction.fit": [[133, 152], ["grid_search_reduction.GridSearchReduction.model.fit", "X.drop.drop.drop"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["dataset_new", "=", "dataset", ".", "copy", "(", ")", "\n", "dataset_new", ".", "labels", "=", "self", ".", "model", ".", "predict", "(", "X_df", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "if", "isinstance", "(", "self", ".", "model", ".", "moment", ",", "red", ".", "ClassificationMoment", ")", ":", "\n", "            ", "fav", "=", "int", "(", "dataset", ".", "favorable_label", ")", "\n", "try", ":", "\n", "# Probability of favorable label", "\n", "                ", "scores", "=", "self", ".", "model", ".", "predict_proba", "(", "X_df", ")", "[", ":", ",", "fav", "]", "\n", "dataset_new", ".", "scores", "=", "scores", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "", "except", "(", "AttributeError", ",", "NotImplementedError", ")", ":", "\n", "                ", "warning", "(", "\"dataset.scores not updated, underlying model does not \"", "\n", "\"support predict_proba\"", ")", "\n", "\n", "", "", "return", "dataset_new", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.grid_search_reduction.GridSearchReduction.predict": [[153, 166], ["grid_search_reduction.GridSearchReduction.model.predict", "X.drop.drop.drop"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], []], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.gerryfair_classifier.GerryFairClassifier.__init__": [[50, 87], ["linear_model.LinearRegression", "aif360.algorithms.Transformer.__init__", "Exception"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "C", "=", "10", ",", "printflag", "=", "False", ",", "heatmapflag", "=", "False", ",", "\n", "heatmap_iter", "=", "10", ",", "heatmap_path", "=", "'.'", ",", "max_iters", "=", "10", ",", "gamma", "=", "0.01", ",", "\n", "fairness_def", "=", "'FP'", ",", "predictor", "=", "linear_model", ".", "LinearRegression", "(", ")", ")", ":", "\n", "        ", "\"\"\"Initialize Model Object and set hyperparameters.\n\n        Args:\n            C: Maximum L1 Norm for the Dual Variables (hyperparameter)\n            printflag: Print Output Flag\n            heatmapflag: Save Heatmaps every heatmap_iter Flag\n            heatmap_iter: Save Heatmaps every heatmap_iter\n            heatmap_path: Save Heatmaps path\n            max_iters: Time Horizon for the fictitious play dynamic.\n            gamma: Fairness Approximation Paramater\n            fairness_def: Fairness notion, FP, FN, SP.\n            errors: see fit()\n            fairness_violations: see fit()\n            predictor: Hypothesis class for the Learner. Supports LR, SVM, KR,\n                Trees.\n        \"\"\"", "\n", "\n", "super", "(", "GerryFairClassifier", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "C", "=", "C", "\n", "self", ".", "printflag", "=", "printflag", "\n", "self", ".", "heatmapflag", "=", "heatmapflag", "\n", "self", ".", "heatmap_iter", "=", "heatmap_iter", "\n", "self", ".", "heatmap_path", "=", "heatmap_path", "\n", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "fairness_def", "=", "fairness_def", "\n", "self", ".", "predictor", "=", "predictor", "\n", "self", ".", "classifiers", "=", "None", "\n", "self", ".", "errors", "=", "None", "\n", "self", ".", "fairness_violations", "=", "None", "\n", "if", "self", ".", "fairness_def", "not", "in", "[", "'FP'", ",", "'FN'", "]", ":", "\n", "            ", "raise", "Exception", "(", "\n", "'This metric is not yet supported for learning. Metric specified: {}.'", "\n", ".", "format", "(", "self", ".", "fairness_def", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.gerryfair_classifier.GerryFairClassifier.fit": [[88, 152], ["clean.extract_df_from_ds", "aif360.algorithms.inprocessing.gerryfair.learner.Learner", "Auditor", "aif360.algorithms.inprocessing.gerryfair.classifier_history.ClassifierHistory", "Auditor.initialize_costs", "aif360.algorithms.inprocessing.gerryfair.classifier_history.ClassifierHistory.append_classifier", "aif360.algorithms.inprocessing.gerryfair.learner.Learner.generate_predictions", "Auditor.get_baseline", "Auditor.get_group", "Auditor.update_costs", "errors.append", "fairness_violations.append", "gerryfair_classifier.GerryFairClassifier.print_outputs", "gerryfair_classifier.GerryFairClassifier.save_heatmap", "aif360.algorithms.inprocessing.gerryfair.learner.Learner.best_response", "aif360.algorithms.inprocessing.gerryfair.classifier_history.ClassifierHistory.get_most_recent", "aif360.algorithms.inprocessing.gerryfair.classifier_history.ClassifierHistory.get_most_recent().predict", "len", "aif360.algorithms.inprocessing.gerryfair.classifier_history.ClassifierHistory.get_most_recent"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.extract_df_from_ds", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.initialize_costs", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.classifier_history.ClassifierHistory.append_classifier", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.learner.Learner.generate_predictions", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_baseline", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_group", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.update_costs", "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.gerryfair_classifier.GerryFairClassifier.print_outputs", "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.gerryfair_classifier.GerryFairClassifier.save_heatmap", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.learner.Learner.best_response", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.classifier_history.ClassifierHistory.get_most_recent", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.classifier_history.ClassifierHistory.get_most_recent"], ["", "", "def", "fit", "(", "self", ",", "dataset", ",", "early_termination", "=", "True", ")", ":", "\n", "        ", "\"\"\"Run Fictitious play to compute the approximately fair classifier.\n\n        Args:\n            dataset: dataset object with its own class definition in datasets\n                folder inherits from class StandardDataset.\n            early_termination: Terminate Early if Auditor can't find fairness\n                violation of more than gamma.\n        Returns:\n            Self\n        \"\"\"", "\n", "\n", "# defining variables and data structures for algorithm", "\n", "X", ",", "X_prime", ",", "y", "=", "clean", ".", "extract_df_from_ds", "(", "dataset", ")", "\n", "learner", "=", "Learner", "(", "X", ",", "y", ",", "self", ".", "predictor", ")", "\n", "auditor", "=", "Auditor", "(", "dataset", ",", "self", ".", "fairness_def", ")", "\n", "history", "=", "ClassifierHistory", "(", ")", "\n", "\n", "# initialize variables", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "costs_0", ",", "costs_1", ",", "X_0", "=", "auditor", ".", "initialize_costs", "(", "n", ")", "\n", "metric_baseline", "=", "0", "\n", "predictions", "=", "[", "0.0", "]", "*", "n", "\n", "\n", "# scaling variables for heatmap", "\n", "vmin", "=", "None", "\n", "vmax", "=", "None", "\n", "\n", "# print output variables", "\n", "errors", "=", "[", "]", "\n", "fairness_violations", "=", "[", "]", "\n", "\n", "iteration", "=", "1", "\n", "while", "iteration", "<", "self", ".", "max_iters", ":", "\n", "# learner's best response: solve the CSC problem, get mixture decisions on X to update prediction probabilities", "\n", "            ", "history", ".", "append_classifier", "(", "learner", ".", "best_response", "(", "costs_0", ",", "costs_1", ")", ")", "\n", "error", ",", "predictions", "=", "learner", ".", "generate_predictions", "(", "\n", "history", ".", "get_most_recent", "(", ")", ",", "predictions", ",", "iteration", ")", "\n", "# auditor's best response: find group, update costs", "\n", "metric_baseline", "=", "auditor", ".", "get_baseline", "(", "y", ",", "predictions", ")", "\n", "group", "=", "auditor", ".", "get_group", "(", "predictions", ",", "metric_baseline", ")", "\n", "costs_0", ",", "costs_1", "=", "auditor", ".", "update_costs", "(", "costs_0", ",", "costs_1", ",", "group", ",", "\n", "self", ".", "C", ",", "iteration", ",", "\n", "self", ".", "gamma", ")", "\n", "\n", "# outputs", "\n", "errors", ".", "append", "(", "error", ")", "\n", "fairness_violations", ".", "append", "(", "group", ".", "weighted_disparity", ")", "\n", "self", ".", "print_outputs", "(", "iteration", ",", "error", ",", "group", ")", "\n", "vmin", ",", "vmax", "=", "self", ".", "save_heatmap", "(", "\n", "iteration", ",", "dataset", ",", "\n", "history", ".", "get_most_recent", "(", ")", ".", "predict", "(", "X", ")", ",", "vmin", ",", "vmax", ")", "\n", "iteration", "+=", "1", "\n", "\n", "# early termination:", "\n", "if", "early_termination", "and", "(", "len", "(", "errors", ")", ">=", "5", ")", "and", "(", "\n", "(", "errors", "[", "-", "1", "]", "==", "errors", "[", "-", "2", "]", ")", "or", "fairness_violations", "[", "-", "1", "]", "==", "fairness_violations", "[", "-", "2", "]", ")", "and", "fairness_violations", "[", "-", "1", "]", "<", "self", ".", "gamma", ":", "\n", "                ", "iteration", "=", "self", ".", "max_iters", "\n", "\n", "", "", "self", ".", "classifiers", "=", "history", ".", "classifiers", "\n", "self", ".", "errors", "=", "errors", "\n", "self", ".", "fairness_violations", "=", "fairness_violations", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.gerryfair_classifier.GerryFairClassifier.predict": [[153, 186], ["copy.deepcopy", "clean.extract_df_from_ds", "len", "copy.deepcopy.labels.resize", "np.asarray", "np.asarray", "hyp.predict", "np.add"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.extract_df_from_ds", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["", "def", "predict", "(", "self", ",", "dataset", ",", "threshold", "=", ".5", ")", ":", "\n", "        ", "\"\"\"Return dataset object where labels are the predictions returned by\n        the fitted model.\n\n        Args:\n            dataset: dataset object with its own class definition in datasets\n                folder inherits from class StandardDataset.\n            threshold: The positive prediction cutoff for the soft-classifier.\n\n        Returns:\n            dataset_new: modified dataset object where the labels attribute are\n            the predictions returned by the self model\n        \"\"\"", "\n", "\n", "# Generates predictions.", "\n", "dataset_new", "=", "copy", ".", "deepcopy", "(", "dataset", ")", "\n", "data", ",", "_", ",", "_", "=", "clean", ".", "extract_df_from_ds", "(", "dataset_new", ")", "\n", "num_classifiers", "=", "len", "(", "self", ".", "classifiers", ")", "\n", "y_hat", "=", "None", "\n", "for", "hyp", "in", "self", ".", "classifiers", ":", "\n", "            ", "new_predictions", "=", "hyp", ".", "predict", "(", "data", ")", "/", "num_classifiers", "\n", "if", "y_hat", "is", "None", ":", "\n", "                ", "y_hat", "=", "new_predictions", "\n", "", "else", ":", "\n", "                ", "y_hat", "=", "np", ".", "add", "(", "y_hat", ",", "new_predictions", ")", "\n", "", "", "if", "threshold", ":", "\n", "            ", "dataset_new", ".", "labels", "=", "np", ".", "asarray", "(", "\n", "[", "1", "if", "y", ">=", "threshold", "else", "0", "for", "y", "in", "y_hat", "]", ")", "\n", "", "else", ":", "\n", "            ", "dataset_new", ".", "labels", "=", "np", ".", "asarray", "(", "[", "y", "for", "y", "in", "y_hat", "]", ")", "\n", "# ensure ndarray is formatted correctly", "\n", "", "dataset_new", ".", "labels", ".", "resize", "(", "dataset", ".", "labels", ".", "shape", ",", "refcheck", "=", "True", ")", "\n", "return", "dataset_new", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.gerryfair_classifier.GerryFairClassifier.print_outputs": [[187, 201], ["print", "int"], "methods", ["None"], ["", "def", "print_outputs", "(", "self", ",", "iteration", ",", "error", ",", "group", ")", ":", "\n", "        ", "\"\"\"Helper function to print outputs at each iteration of fit.\n\n        Args:\n            iteration: current iter\n            error: most recent error\n            group: most recent group found by the auditor\n        \"\"\"", "\n", "\n", "if", "self", ".", "printflag", ":", "\n", "            ", "print", "(", "\n", "'iteration: {}, error: {}, fairness violation: {}, violated group size: {}'", "\n", ".", "format", "(", "int", "(", "iteration", ")", ",", "error", ",", "group", ".", "weighted_disparity", ",", "\n", "group", ".", "group_size", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.gerryfair_classifier.GerryFairClassifier.save_heatmap": [[202, 231], ["clean.extract_df_from_ds", "aif360.algorithms.inprocessing.gerryfair.heatmap.heat_map"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.extract_df_from_ds", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.heatmap.heat_map"], ["", "", "def", "save_heatmap", "(", "self", ",", "iteration", ",", "dataset", ",", "predictions", ",", "vmin", ",", "vmax", ")", ":", "\n", "        ", "\"\"\"Helper Function to save the heatmap.\n\n        Args:\n            iteration: current iteration\n            dataset: dataset object with its own class definition in datasets\n                folder inherits from class StandardDataset.\n            predictions: predictions of the model self on dataset.\n            vmin: see documentation of heatmap.py heat_map function\n            vmax: see documentation of heatmap.py heat_map function\n\n        Returns:\n            (vmin, vmax)\n        \"\"\"", "\n", "\n", "X", ",", "X_prime", ",", "y", "=", "clean", ".", "extract_df_from_ds", "(", "dataset", ")", "\n", "# save heatmap every heatmap_iter iterations or the last iteration", "\n", "if", "(", "self", ".", "heatmapflag", "and", "(", "iteration", "%", "self", ".", "heatmap_iter", ")", "==", "0", ")", ":", "\n", "# initial heat map", "\n", "            ", "X_prime_heat", "=", "X_prime", ".", "iloc", "[", ":", ",", "0", ":", "2", "]", "\n", "eta", "=", "0.1", "\n", "minmax", "=", "heatmap", ".", "heat_map", "(", "\n", "X", ",", "X_prime_heat", ",", "y", ",", "predictions", ",", "eta", ",", "\n", "self", ".", "heatmap_path", "+", "'/heatmap_iteration_{}'", ".", "format", "(", "iteration", ")", ",", "\n", "vmin", ",", "vmax", ")", "\n", "if", "iteration", "==", "1", ":", "\n", "                ", "vmin", "=", "minmax", "[", "0", "]", "\n", "vmax", "=", "minmax", "[", "1", "]", "\n", "", "", "return", "vmin", ",", "vmax", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.gerryfair_classifier.GerryFairClassifier.generate_heatmap": [[232, 255], ["clean.extract_df_from_ds", "aif360.algorithms.inprocessing.gerryfair.heatmap.heat_map"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.extract_df_from_ds", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.heatmap.heat_map"], ["", "def", "generate_heatmap", "(", "self", ",", "\n", "dataset", ",", "\n", "predictions", ",", "\n", "vmin", "=", "None", ",", "\n", "vmax", "=", "None", ",", "\n", "cols_index", "=", "[", "0", ",", "1", "]", ",", "\n", "eta", "=", ".1", ")", ":", "\n", "        ", "\"\"\"Helper Function to generate the heatmap at the current time.\n\n        Args:\n            iteration:current iteration\n            dataset: dataset object with its own class definition in datasets\n                folder inherits from class StandardDataset.\n            predictions: predictions of the model self on dataset.\n            vmin: see documentation of heatmap.py heat_map function\n            vmax: see documentation of heatmap.py heat_map function\n        \"\"\"", "\n", "\n", "X", ",", "X_prime", ",", "y", "=", "clean", ".", "extract_df_from_ds", "(", "dataset", ")", "\n", "# save heatmap every heatmap_iter iterations or the last iteration", "\n", "X_prime_heat", "=", "X_prime", ".", "iloc", "[", ":", ",", "cols_index", "]", "\n", "minmax", "=", "heatmap", ".", "heat_map", "(", "X", ",", "X_prime_heat", ",", "y", ",", "predictions", ",", "eta", ",", "\n", "self", ".", "heatmap_path", ",", "vmin", ",", "vmax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.gerryfair_classifier.GerryFairClassifier.pareto": [[256, 294], ["Auditor", "gerryfair_classifier.GerryFairClassifier.fit", "aif360.algorithms.inprocessing.gerryfair.clean.array_to_tuple", "Auditor.audit", "all_errors.append", "all_fp_violations.append", "all_fn_violations.append", "gerryfair_classifier.GerryFairClassifier.predict"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.array_to_tuple", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.audit", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["", "def", "pareto", "(", "self", ",", "dataset", ",", "gamma_list", ")", ":", "\n", "        ", "\"\"\"Assumes Model has FP specified for metric. Trains for each value of\n        gamma, returns error, FP (via training), and FN (via auditing) values.\n\n        Args:\n            dataset: dataset object with its own class definition in datasets\n                folder inherits from class StandardDataset.\n            gamma_list: the list of gamma values to generate the pareto curve\n\n        Returns:\n            list of errors, list of fp violations of those models, list of fn\n            violations of those models\n        \"\"\"", "\n", "\n", "C", "=", "self", ".", "C", "\n", "max_iters", "=", "self", ".", "max_iters", "\n", "\n", "# Store errors and fp over time for each gamma", "\n", "\n", "# change var names, but no real dependence on FP logic", "\n", "all_errors", "=", "[", "]", "\n", "all_fp_violations", "=", "[", "]", "\n", "all_fn_violations", "=", "[", "]", "\n", "self", ".", "C", "=", "C", "\n", "self", ".", "max_iters", "=", "max_iters", "\n", "\n", "auditor", "=", "Auditor", "(", "dataset", ",", "'FN'", ")", "\n", "for", "g", "in", "gamma_list", ":", "\n", "            ", "self", ".", "gamma", "=", "g", "\n", "fitted_model", "=", "self", ".", "fit", "(", "dataset", ",", "early_termination", "=", "True", ")", "\n", "errors", ",", "fairness_violations", "=", "fitted_model", ".", "errors", ",", "fitted_model", ".", "fairness_violations", "\n", "predictions", "=", "array_to_tuple", "(", "(", "self", ".", "predict", "(", "dataset", ")", ")", ".", "labels", ")", "\n", "_", ",", "fn_violation", "=", "auditor", ".", "audit", "(", "predictions", ")", "\n", "all_errors", ".", "append", "(", "errors", "[", "-", "1", "]", ")", "\n", "all_fp_violations", ".", "append", "(", "fairness_violations", "[", "-", "1", "]", ")", "\n", "all_fn_violations", ".", "append", "(", "fn_violation", ")", "\n", "\n", "", "return", "all_errors", ",", "all_fp_violations", ",", "all_fn_violations", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.art_classifier.ARTClassifier.__init__": [[12, 24], ["aif360.algorithms.Transformer.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "art_classifier", ")", ":", "\n", "        ", "\"\"\"Initialize ARTClassifier.\n\n        Args:\n            art_classifier (art.classifier.Classifier): A Classifier\n                object from the `adversarial-robustness-toolbox`_.\n\n        .. _adversarial-robustness-toolbox:\n           https://github.com/Trusted-AI/adversarial-robustness-toolbox\n        \"\"\"", "\n", "super", "(", "ARTClassifier", ",", "self", ")", ".", "__init__", "(", "art_classifier", "=", "art_classifier", ")", "\n", "self", ".", "_art_classifier", "=", "art_classifier", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.art_classifier.ARTClassifier.fit": [[25, 40], ["art_classifier.ARTClassifier._art_classifier.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "fit", "(", "self", ",", "dataset", ",", "batch_size", "=", "128", ",", "nb_epochs", "=", "20", ")", ":", "\n", "        ", "\"\"\"Train a classifer on the input.\n\n        Args:\n            dataset (Dataset): Training dataset.\n            batch_size (int): Size of batches (passed through to ART).\n            nb_epochs (int): Number of epochs to use for training (passed\n                through to ART).\n\n        Returns:\n            ARTClassifier: Returns self.\n        \"\"\"", "\n", "self", ".", "_art_classifier", ".", "fit", "(", "dataset", ".", "features", ",", "dataset", ".", "labels", ",", "\n", "batch_size", "=", "batch_size", ",", "nb_epochs", "=", "nb_epochs", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.art_classifier.ARTClassifier.predict": [[41, 62], ["art_classifier.ARTClassifier._art_classifier.predict", "isinstance", "dataset.copy", "numpy.argmax().reshape", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "predict", "(", "self", ",", "dataset", ",", "logits", "=", "False", ")", ":", "\n", "        ", "\"\"\"Perform prediction for the input.\n\n        Args:\n            dataset (Dataset): Test dataset.\n            logits (bool, optional): True is prediction should be done at the\n                logits layer (passed through to ART).\n\n        Returns:\n            Dataset: Dataset with predicted labels in the `labels` field.\n        \"\"\"", "\n", "pred_labels", "=", "self", ".", "_art_classifier", ".", "predict", "(", "dataset", ".", "features", ",", "\n", "dataset", ".", "labels", ",", "logits", "=", "logits", ")", "\n", "\n", "if", "isinstance", "(", "dataset", ",", "BinaryLabelDataset", ")", ":", "\n", "            ", "pred_labels", "=", "np", ".", "argmax", "(", "pred_labels", ",", "axis", "=", "1", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "", "pred_dataset", "=", "dataset", ".", "copy", "(", ")", "\n", "pred_dataset", ".", "labels", "=", "pred_labels", "\n", "\n", "return", "pred_dataset", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.exponentiated_gradient_reduction.ExponentiatedGradientReduction.__init__": [[29, 94], ["isinstance", "fairlearn.ExponentiatedGradient", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "estimator", ",", "\n", "constraints", ",", "\n", "eps", "=", "0.01", ",", "\n", "T", "=", "50", ",", "\n", "nu", "=", "None", ",", "\n", "eta_mul", "=", "2.0", ",", "\n", "drop_prot_attr", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            estimator: An estimator implementing methods ``fit(X, y,\n                sample_weight)`` and ``predict(X)``, where ``X`` is the matrix\n                of features, ``y`` is the vector of labels, and\n                ``sample_weight`` is a vector of weights; labels ``y`` and\n                predictions returned by ``predict(X)`` are either 0 or 1 -- e.g.\n                scikit-learn classifiers.\n            constraints (str or fairlearn.reductions.Moment): If string, keyword\n                denoting the :class:`fairlearn.reductions.Moment` object\n                defining the disparity constraints -- e.g., \"DemographicParity\"\n                or \"EqualizedOdds\". For a full list of possible options see\n                `self.model.moments`. Otherwise, provide the desired\n                :class:`~fairlearn.reductions.Moment` object defining the\n                disparity constraints.\n            eps: Allowed fairness constraint violation; the solution is\n                guaranteed to have the error within ``2*best_gap`` of the best\n                error under constraint eps; the constraint violation is at most\n                ``2*(eps+best_gap)``.\n            T: Maximum number of iterations.\n            nu: Convergence threshold for the duality gap, corresponding to a\n                conservative automatic setting based on the statistical\n                uncertainty in measuring classification error.\n            eta_mul: Initial setting of the learning rate.\n            drop_prot_attr: Boolean flag indicating whether to drop protected\n                attributes from training data.\n\n        \"\"\"", "\n", "super", "(", "ExponentiatedGradientReduction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "#init model, set prot_attr during fit", "\n", "prot_attr", "=", "[", "]", "\n", "self", ".", "model", "=", "skExpGradRed", "(", "prot_attr", "=", "prot_attr", ",", "estimator", "=", "estimator", ",", "\n", "constraints", "=", "constraints", ",", "eps", "=", "eps", ",", "T", "=", "T", ",", "nu", "=", "nu", ",", "eta_mul", "=", "eta_mul", ",", "\n", "drop_prot_attr", "=", "drop_prot_attr", ")", "\n", "\n", "\n", "", "def", "fit", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Learns randomized model with less bias\n\n        Args:\n            dataset: (Binary label) Dataset containing true labels.\n\n        Returns:\n            ExponentiatedGradientReduction: Returns self.\n        \"\"\"", "\n", "#set prot_attr", "\n", "self", ".", "model", ".", "prot_attr", "=", "dataset", ".", "protected_attribute_names", "\n", "\n", "X_df", "=", "pd", ".", "DataFrame", "(", "dataset", ".", "features", ",", "columns", "=", "dataset", ".", "feature_names", ")", "\n", "Y", "=", "dataset", ".", "labels", "\n", "\n", "self", ".", "model", ".", "fit", "(", "X_df", ",", "Y", ")", "\n", "\n", "return", "self", "\n", "\n", "\n", "", "def", "predict", "(", "self", ",", "dataset", ")", ":", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.exponentiated_gradient_reduction.ExponentiatedGradientReduction.fit": [[95, 117], ["sklearn.preprocessing.LabelEncoder", "sklearn.preprocessing.LabelEncoder.fit_transform", "exponentiated_gradient_reduction.ExponentiatedGradientReduction.model.fit", "X.drop.drop.drop"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["        ", "\"\"\"Obtain the predictions for the provided dataset using the randomized\n        model learned.\n\n        Args:\n            dataset: (Binary label) Dataset containing labels that needs to be\n                transformed.\n\n        Returns:\n            dataset: Transformed (Binary label) dataset.\n        \"\"\"", "\n", "X_df", "=", "pd", ".", "DataFrame", "(", "dataset", ".", "features", ",", "columns", "=", "dataset", ".", "feature_names", ")", "\n", "\n", "dataset_new", "=", "dataset", ".", "copy", "(", ")", "\n", "dataset_new", ".", "labels", "=", "self", ".", "model", ".", "predict", "(", "X_df", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "fav", "=", "int", "(", "dataset", ".", "favorable_label", ")", "\n", "try", ":", "\n", "# Probability of favorable label", "\n", "            ", "scores", "=", "self", ".", "model", ".", "predict_proba", "(", "X_df", ")", "[", ":", ",", "fav", "]", "\n", "dataset_new", ".", "scores", "=", "scores", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "", "except", "(", "AttributeError", ",", "NotImplementedError", ")", ":", "\n", "            ", "warning", "(", "\"dataset.scores not updated, underlying model does not \"", "\n", "\"support predict_proba\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.exponentiated_gradient_reduction.ExponentiatedGradientReduction.predict": [[119, 130], ["X.drop.drop.drop", "exponentiated_gradient_reduction.ExponentiatedGradientReduction.model.predict"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["", "return", "dataset_new", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.meta_fair_classifier.MetaFairClassifier.__init__": [[20, 44], ["aif360.algorithms.Transformer.__init__", "aif360.algorithms.inprocessing.celisMeta.FalseDiscovery", "aif360.algorithms.inprocessing.celisMeta.StatisticalRate", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "tau", "=", "0.8", ",", "sensitive_attr", "=", "\"\"", ",", "type", "=", "\"fdr\"", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tau (double, optional): Fairness penalty parameter.\n            sensitive_attr (str, optional): Name of protected attribute.\n            type (str, optional): The type of fairness metric to be used.\n                Currently \"fdr\" (false discovery rate ratio) and \"sr\"\n                (statistical rate/disparate impact) are supported. To use\n                another type, the corresponding optimization class has to be\n                implemented.\n            seed (int, optional): Random seed.\n        \"\"\"", "\n", "super", "(", "MetaFairClassifier", ",", "self", ")", ".", "__init__", "(", "tau", "=", "tau", ",", "\n", "sensitive_attr", "=", "sensitive_attr", ",", "type", "=", "type", ",", "seed", "=", "seed", ")", "\n", "\n", "self", ".", "tau", "=", "tau", "\n", "self", ".", "sensitive_attr", "=", "sensitive_attr", "\n", "if", "type", "==", "\"fdr\"", ":", "\n", "            ", "self", ".", "obj", "=", "FalseDiscovery", "(", ")", "\n", "", "elif", "type", "==", "\"sr\"", ":", "\n", "            ", "self", ".", "obj", "=", "StatisticalRate", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Only 'fdr' and 'sr' are supported yet.\"", ")", "\n", "", "self", ".", "seed", "=", "seed", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.meta_fair_classifier.MetaFairClassifier.fit": [[45, 70], ["dataset.protected_attribute_names.index", "numpy.where", "numpy.where", "meta_fair_classifier.MetaFairClassifier.obj.getModel", "numpy.isin", "dataset.labels.flatten"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.getModel"], ["", "def", "fit", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Learns the fair classifier.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing true labels.\n\n        Returns:\n            MetaFairClassifier: Returns self.\n        \"\"\"", "\n", "if", "not", "self", ".", "sensitive_attr", ":", "\n", "            ", "self", ".", "sensitive_attr", "=", "dataset", ".", "protected_attribute_names", "[", "0", "]", "\n", "", "sens_idx", "=", "dataset", ".", "protected_attribute_names", ".", "index", "(", "self", ".", "sensitive_attr", ")", "\n", "\n", "x_train", "=", "dataset", ".", "features", "\n", "y_train", "=", "np", ".", "where", "(", "dataset", ".", "labels", ".", "flatten", "(", ")", "==", "dataset", ".", "favorable_label", ",", "\n", "1", ",", "-", "1", ")", "\n", "x_control_train", "=", "np", ".", "where", "(", "\n", "np", ".", "isin", "(", "dataset", ".", "protected_attributes", "[", ":", ",", "sens_idx", "]", ",", "\n", "dataset", ".", "privileged_protected_attributes", "[", "sens_idx", "]", ")", ",", "\n", "1", ",", "0", ")", "\n", "\n", "self", ".", "model", "=", "self", ".", "obj", ".", "getModel", "(", "self", ".", "tau", ",", "x_train", ",", "y_train", ",", "\n", "x_control_train", ",", "self", ".", "seed", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.meta_fair_classifier.MetaFairClassifier.predict": [[71, 89], ["meta_fair_classifier.MetaFairClassifier.model", "dataset.copy"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "predict", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Obtain the predictions for the provided dataset using the learned\n        classifier model.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing labels that needs\n                to be transformed.\n\n        Returns:\n            BinaryLabelDataset: Transformed dataset.\n        \"\"\"", "\n", "t", "=", "self", ".", "model", "(", "dataset", ".", "features", ")", "\n", "\n", "pred_dataset", "=", "dataset", ".", "copy", "(", ")", "\n", "pred_dataset", ".", "labels", "=", "(", "t", ">", "0", ")", ".", "astype", "(", "int", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "pred_dataset", ".", "scores", "=", "(", "(", "t", "+", "1", ")", "/", "2", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "return", "pred_dataset", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.prejudice_remover.PrejudiceRemover.__init__": [[90, 102], ["aif360.algorithms.Transformer.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "eta", "=", "1.0", ",", "sensitive_attr", "=", "\"\"", ",", "class_attr", "=", "\"\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            eta (double, optional): fairness penalty parameter\n            sensitive_attr (str, optional): name of protected attribute\n            class_attr (str, optional): label name\n        \"\"\"", "\n", "super", "(", "PrejudiceRemover", ",", "self", ")", ".", "__init__", "(", "eta", "=", "eta", ",", "\n", "sensitive_attr", "=", "sensitive_attr", ",", "class_attr", "=", "class_attr", ")", "\n", "self", ".", "eta", "=", "eta", "\n", "self", ".", "sensitive_attr", "=", "sensitive_attr", "\n", "self", ".", "class_attr", "=", "class_attr", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.prejudice_remover.PrejudiceRemover._create_file_in_kamishima_format": [[103, 120], ["x.append", "x.append", "tempfile.mkstemp", "os.close", "numpy.savetxt", "numpy.array", "numpy.array", "x.append", "single_sensitive.isin", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "_create_file_in_kamishima_format", "(", "self", ",", "df", ",", "class_attr", ",", "\n", "positive_class_val", ",", "sensitive_attrs", ",", "\n", "single_sensitive", ",", "privileged_vals", ")", ":", "\n", "        ", "\"\"\"Format the data for the Kamishima code and save it.\"\"\"", "\n", "x", "=", "[", "]", "\n", "for", "col", "in", "df", ":", "\n", "            ", "if", "col", "!=", "class_attr", "and", "col", "not", "in", "sensitive_attrs", ":", "\n", "                ", "x", ".", "append", "(", "np", ".", "array", "(", "df", "[", "col", "]", ".", "values", ",", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "", "", "x", ".", "append", "(", "np", ".", "array", "(", "single_sensitive", ".", "isin", "(", "privileged_vals", ")", ",", "\n", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "x", ".", "append", "(", "np", ".", "array", "(", "df", "[", "class_attr", "]", "==", "positive_class_val", ",", "\n", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "\n", "fd", ",", "name", "=", "tempfile", ".", "mkstemp", "(", ")", "\n", "os", ".", "close", "(", "fd", ")", "\n", "np", ".", "savetxt", "(", "name", ",", "np", ".", "array", "(", "x", ")", ".", "T", ")", "\n", "return", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.prejudice_remover.PrejudiceRemover.fit": [[121, 169], ["numpy.column_stack", "pandas.DataFrame", "all_sensitive_attributes.index", "pandas.Series", "tempfile.mkstemp", "os.close", "prejudice_remover.PrejudiceRemover._create_file_in_kamishima_format", "os.path.dirname", "os.path.join", "subprocess.call", "os.unlink", "os.path.abspath", "str"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.prejudice_remover.PrejudiceRemover._create_file_in_kamishima_format"], ["", "def", "fit", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Learns the regularized logistic regression model.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing true labels.\n\n        Returns:\n            PrejudiceRemover: Returns self.\n        \"\"\"", "\n", "data", "=", "np", ".", "column_stack", "(", "[", "dataset", ".", "features", ",", "dataset", ".", "labels", "]", ")", "\n", "columns", "=", "dataset", ".", "feature_names", "+", "dataset", ".", "label_names", "\n", "train_df", "=", "pd", ".", "DataFrame", "(", "data", "=", "data", ",", "columns", "=", "columns", ")", "\n", "\n", "all_sensitive_attributes", "=", "dataset", ".", "protected_attribute_names", "\n", "\n", "if", "not", "self", ".", "sensitive_attr", ":", "\n", "            ", "self", ".", "sensitive_attr", "=", "all_sensitive_attributes", "[", "0", "]", "\n", "", "self", ".", "sensitive_ind", "=", "all_sensitive_attributes", ".", "index", "(", "self", ".", "sensitive_attr", ")", "\n", "\n", "sens_df", "=", "pd", ".", "Series", "(", "dataset", ".", "protected_attributes", "[", ":", ",", "self", ".", "sensitive_ind", "]", ",", "\n", "name", "=", "self", ".", "sensitive_attr", ")", "\n", "\n", "if", "not", "self", ".", "class_attr", ":", "\n", "            ", "self", ".", "class_attr", "=", "dataset", ".", "label_names", "[", "0", "]", "\n", "\n", "", "fd", ",", "model_name", "=", "tempfile", ".", "mkstemp", "(", ")", "\n", "os", ".", "close", "(", "fd", ")", "\n", "train_name", "=", "self", ".", "_create_file_in_kamishima_format", "(", "train_df", ",", "\n", "self", ".", "class_attr", ",", "dataset", ".", "favorable_label", ",", "\n", "all_sensitive_attributes", ",", "sens_df", ",", "\n", "dataset", ".", "privileged_protected_attributes", "[", "self", ".", "sensitive_ind", "]", ")", "\n", "# ADDED FOLLOWING LINE to get absolute path of this file, i.e.", "\n", "# prejudice_remover.py", "\n", "k_path", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "train_pr", "=", "os", ".", "path", ".", "join", "(", "k_path", ",", "'kamfadm-2012ecmlpkdd'", ",", "'train_pr.py'", ")", "\n", "# changed paths in the calls below to (a) specify path of train_pr,", "\n", "# predict_lr RELATIVE to this file, and (b) compute & use absolute path", "\n", "#  and (c) replace python3 with python", "\n", "subprocess", ".", "call", "(", "[", "'python'", ",", "train_pr", ",", "\n", "'-e'", ",", "str", "(", "self", ".", "eta", ")", ",", "\n", "'-i'", ",", "train_name", ",", "\n", "'-o'", ",", "model_name", ",", "\n", "'--quiet'", "]", ")", "\n", "os", ".", "unlink", "(", "train_name", ")", "\n", "\n", "self", ".", "model_name", "=", "model_name", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.prejudice_remover.PrejudiceRemover.predict": [[170, 221], ["numpy.column_stack", "pandas.DataFrame", "pandas.Series", "tempfile.mkstemp", "os.close", "prejudice_remover.PrejudiceRemover._create_file_in_kamishima_format", "os.path.dirname", "os.path.join", "subprocess.call", "os.unlink", "numpy.loadtxt", "os.unlink", "dataset.copy", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.prejudice_remover.PrejudiceRemover._create_file_in_kamishima_format", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "predict", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Obtain the predictions for the provided dataset using the learned\n        prejudice remover model.\n\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing labels that needs\n                to be transformed.\n        Returns:\n            dataset (BinaryLabelDataset): Transformed dataset.\n        \"\"\"", "\n", "data", "=", "np", ".", "column_stack", "(", "[", "dataset", ".", "features", ",", "dataset", ".", "labels", "]", ")", "\n", "columns", "=", "dataset", ".", "feature_names", "+", "dataset", ".", "label_names", "\n", "test_df", "=", "pd", ".", "DataFrame", "(", "data", "=", "data", ",", "columns", "=", "columns", ")", "\n", "sens_df", "=", "pd", ".", "Series", "(", "dataset", ".", "protected_attributes", "[", ":", ",", "self", ".", "sensitive_ind", "]", ",", "\n", "name", "=", "self", ".", "sensitive_attr", ")", "\n", "\n", "fd", ",", "output_name", "=", "tempfile", ".", "mkstemp", "(", ")", "\n", "os", ".", "close", "(", "fd", ")", "\n", "\n", "test_name", "=", "self", ".", "_create_file_in_kamishima_format", "(", "test_df", ",", "\n", "self", ".", "class_attr", ",", "dataset", ".", "favorable_label", ",", "\n", "dataset", ".", "protected_attribute_names", ",", "sens_df", ",", "\n", "dataset", ".", "privileged_protected_attributes", "[", "self", ".", "sensitive_ind", "]", ")", "\n", "\n", "# ADDED FOLLOWING LINE to get absolute path of this file, i.e.", "\n", "# prejudice_remover.py", "\n", "k_path", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "predict_lr", "=", "os", ".", "path", ".", "join", "(", "k_path", ",", "'kamfadm-2012ecmlpkdd'", ",", "'predict_lr.py'", ")", "\n", "# changed paths in the calls below to (a) specify path of train_pr,", "\n", "# predict_lr RELATIVE to this file, and (b) compute & use absolute path,", "\n", "# and (c) replace python3 with python", "\n", "subprocess", ".", "call", "(", "[", "'python'", ",", "predict_lr", ",", "\n", "'-i'", ",", "test_name", ",", "\n", "'-m'", ",", "self", ".", "model_name", ",", "\n", "'-o'", ",", "output_name", ",", "\n", "'--quiet'", "]", ")", "\n", "os", ".", "unlink", "(", "test_name", ")", "\n", "m", "=", "np", ".", "loadtxt", "(", "output_name", ")", "\n", "os", ".", "unlink", "(", "output_name", ")", "\n", "\n", "pred_dataset", "=", "dataset", ".", "copy", "(", ")", "\n", "# Columns of Outputs: (as per Kamishima implementation predict_lr.py)", "\n", "# 0. true sample class number", "\n", "# 1. predicted class number", "\n", "# 2. sensitive feature", "\n", "# 3. class 0 probability", "\n", "# 4. class 1 probability", "\n", "pred_dataset", ".", "labels", "=", "m", "[", ":", ",", "[", "1", "]", "]", "\n", "pred_dataset", ".", "scores", "=", "m", "[", ":", ",", "[", "4", "]", "]", "\n", "\n", "return", "pred_dataset", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.adversarial_debiasing.AdversarialDebiasing.decision_function": [[272, 309], ["sklearn.utils.validation.check_is_fitted", "len", "numpy.empty", "numpy.arange", "adversarial_debiasing.AdversarialDebiasing.sess_.run", "len", "numpy.empty.ravel"], "methods", ["None"], ["temp_labels", "[", "(", "dataset_new", ".", "labels", "==", "1.0", ")", ".", "ravel", "(", ")", ",", "0", "]", "=", "dataset", ".", "favorable_label", "\n", "temp_labels", "[", "(", "dataset_new", ".", "labels", "==", "0.0", ")", ".", "ravel", "(", ")", ",", "0", "]", "=", "dataset", ".", "unfavorable_label", "\n", "\n", "dataset_new", ".", "labels", "=", "temp_labels", ".", "copy", "(", ")", "\n", "\n", "return", "dataset_new", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.adversarial_debiasing.AdversarialDebiasing.predict_proba": [[310, 331], ["adversarial_debiasing.AdversarialDebiasing.decision_function", "scipy.special.softmax", "numpy.zeros_like"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.adversarial_debiasing.AdversarialDebiasing.decision_function"], []], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.grid_search_reduction.GridSearchReduction.predict_proba": [[168, 189], ["isinstance", "NotImplementedError", "X.drop.drop.drop", "grid_search_reduction.GridSearchReduction.model.predict_proba"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba"], []], "home.repos.pwc.inspect_result.IBM_AIF360.inprocessing.exponentiated_gradient_reduction.ExponentiatedGradientReduction.predict_proba": [[132, 150], ["exponentiated_gradient_reduction.ExponentiatedGradientReduction.model._pmf_predict", "X.drop.drop.drop"], "methods", ["None"], []], "home.repos.pwc.inspect_result.IBM_AIF360.kamfadm-2012ecmlpkdd.predict_lr.main": [[103, 192], ["pickle.load", "pickle.load", "numpy.loadtxt", "numpy.array", "numpy.atleast_2d", "datetime.datetime.now", "datetime.datetime.now.isoformat", "logger.info", "pickle.load.predict_proba", "range", "datetime.datetime.now", "logger.info", "datetime.datetime.now.isoformat", "logger.info", "str", "logger.info", "str", "logger.info", "logger.info", "logger.info", "numpy.mean", "logger.info", "numpy.mean", "logger.info", "sys.exit", "fadm.util.fill_missing_with_mean", "fadm.util.fill_missing_with_mean", "os.times", "numpy.argmax", "opt.outfile.write", "opt.outfile.write", "opt.outfile.write", "os.times", "float", "pickle.load.keys", "vars().items", "opt.infile.close", "opt.outfile.close", "opt.model.close", "datetime.datetime.now.isoformat", "datetime.datetime.now.isoformat", "str", "str", "str", "str", "str", "str", "str", "opt.outfile.write", "opt.outfile.write", "vars", "S[].astype", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.util._base.fill_missing_with_mean", "home.repos.pwc.inspect_result.IBM_AIF360.util._base.fill_missing_with_mean"], ["def", "main", "(", "opt", ")", ":", "\n", "    ", "\"\"\" Main routine that exits with status code 0\n    \"\"\"", "\n", "\n", "### pre process", "\n", "\n", "# load model file", "\n", "clr", "=", "pickle", ".", "load", "(", "opt", ".", "model", ")", "\n", "clr_info", "=", "pickle", ".", "load", "(", "opt", ".", "model", ")", "\n", "\n", "# read data", "\n", "D", "=", "np", ".", "loadtxt", "(", "opt", ".", "infile", ")", "\n", "\n", "# split data and process missing values", "\n", "y", "=", "np", ".", "array", "(", "D", "[", ":", ",", "-", "1", "]", ")", "\n", "if", "opt", ".", "ns", ":", "\n", "        ", "X", "=", "fill_missing_with_mean", "(", "D", "[", ":", ",", ":", "-", "(", "1", "+", "N_NS", ")", "]", ")", "\n", "", "else", ":", "\n", "        ", "X", "=", "fill_missing_with_mean", "(", "D", "[", ":", ",", ":", "-", "1", "]", ")", "\n", "", "S", "=", "np", ".", "atleast_2d", "(", "D", "[", ":", ",", "-", "(", "1", "+", "N_NS", ")", ":", "-", "1", "]", ")", "\n", "\n", "### main process", "\n", "\n", "# set starting time", "\n", "start_time", "=", "datetime", ".", "datetime", ".", "now", "(", ")", "\n", "start_utime", "=", "os", ".", "times", "(", ")", "[", "0", "]", "\n", "opt", ".", "start_time", "=", "start_time", ".", "isoformat", "(", ")", "\n", "logger", ".", "info", "(", "\"start time = \"", "+", "start_time", ".", "isoformat", "(", ")", ")", "\n", "\n", "# prediction and write results", "\n", "p", "=", "clr", ".", "predict_proba", "(", "X", ")", "\n", "\n", "# output prediction", "\n", "n", "=", "0", "\n", "m", "=", "0", "\n", "for", "i", "in", "range", "(", "p", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "c", "=", "np", ".", "argmax", "(", "p", "[", "i", ",", ":", "]", ")", "\n", "opt", ".", "outfile", ".", "write", "(", "\"%d %d \"", "%", "(", "y", "[", "i", "]", ",", "c", ")", ")", "\n", "opt", ".", "outfile", ".", "write", "(", "\" \"", ".", "join", "(", "S", "[", "i", ",", ":", "]", ".", "astype", "(", "str", ")", ")", "+", "\" \"", ")", "\n", "opt", ".", "outfile", ".", "write", "(", "str", "(", "p", "[", "i", ",", "0", "]", ")", "+", "\" \"", "+", "str", "(", "p", "[", "i", ",", "1", "]", ")", "+", "\"\\n\"", ")", "\n", "n", "+=", "1", "\n", "m", "+=", "1", "if", "c", "==", "y", "[", "i", "]", "else", "0", "\n", "\n", "# set end and elapsed time", "\n", "", "end_time", "=", "datetime", ".", "datetime", ".", "now", "(", ")", "\n", "end_utime", "=", "os", ".", "times", "(", ")", "[", "0", "]", "\n", "logger", ".", "info", "(", "\"end time = \"", "+", "end_time", ".", "isoformat", "(", ")", ")", "\n", "opt", ".", "end_time", "=", "end_time", ".", "isoformat", "(", ")", "\n", "logger", ".", "info", "(", "\"elapsed_time = \"", "+", "str", "(", "(", "end_time", "-", "start_time", ")", ")", ")", "\n", "opt", ".", "elapsed_time", "=", "str", "(", "(", "end_time", "-", "start_time", ")", ")", "\n", "logger", ".", "info", "(", "\"elapsed_utime = \"", "+", "str", "(", "(", "end_utime", "-", "start_utime", ")", ")", ")", "\n", "opt", ".", "elapsed_utime", "=", "str", "(", "(", "end_utime", "-", "start_utime", ")", ")", "\n", "\n", "### output", "\n", "\n", "# add meta info", "\n", "opt", ".", "nos_samples", "=", "n", "\n", "logger", ".", "info", "(", "'nos_samples = '", "+", "str", "(", "opt", ".", "nos_samples", ")", ")", "\n", "opt", ".", "nos_correct_samples", "=", "m", "\n", "logger", ".", "info", "(", "'nos_correct_samples = '", "+", "str", "(", "opt", ".", "nos_correct_samples", ")", ")", "\n", "opt", ".", "accuracy", "=", "m", "/", "float", "(", "n", ")", "\n", "logger", ".", "info", "(", "'accuracy = '", "+", "str", "(", "opt", ".", "accuracy", ")", ")", "\n", "opt", ".", "negative_mean_prob", "=", "np", ".", "mean", "(", "p", "[", ":", ",", "0", "]", ")", "\n", "logger", ".", "info", "(", "'negative_mean_prob = '", "+", "str", "(", "opt", ".", "negative_mean_prob", ")", ")", "\n", "opt", ".", "positive_mean_prob", "=", "np", ".", "mean", "(", "p", "[", ":", ",", "1", "]", ")", "\n", "logger", ".", "info", "(", "'positive_mean_prob = '", "+", "str", "(", "opt", ".", "positive_mean_prob", ")", ")", "\n", "\n", "# output meta information", "\n", "if", "opt", ".", "info", ":", "\n", "        ", "for", "key", "in", "clr_info", ".", "keys", "(", ")", ":", "\n", "            ", "opt", ".", "outfile", ".", "write", "(", "\"#classifier_%s=%s\\n\"", "%", "\n", "(", "key", ",", "str", "(", "clr_info", "[", "key", "]", ")", ")", ")", "\n", "\n", "", "for", "key", ",", "key_val", "in", "vars", "(", "opt", ")", ".", "items", "(", ")", ":", "\n", "            ", "opt", ".", "outfile", ".", "write", "(", "\"#%s=%s\\n\"", "%", "(", "key", ",", "str", "(", "key_val", ")", ")", ")", "\n", "\n", "### post process", "\n", "\n", "# close file", "\n", "", "", "if", "opt", ".", "infile", "!=", "sys", ".", "stdin", ":", "\n", "        ", "opt", ".", "infile", ".", "close", "(", ")", "\n", "\n", "", "if", "opt", ".", "outfile", "!=", "sys", ".", "stdout", ":", "\n", "        ", "opt", ".", "outfile", ".", "close", "(", ")", "\n", "\n", "", "if", "opt", ".", "model", "!=", "sys", ".", "stdout", ":", "\n", "        ", "opt", ".", "model", ".", "close", "(", ")", "\n", "\n", "", "sys", ".", "exit", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.kamfadm-2012ecmlpkdd.train_pr.train": [[107, 133], ["fadm.lr.pr.LRwPRType4", "fadm.lr.pr.LRwPRType4.fit", "sys.exit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["def", "train", "(", "X", ",", "y", ",", "ns", ",", "opt", ")", ":", "\n", "    ", "\"\"\" train model\n\n    Parameters\n    ----------\n    X : ary, shape=(n_samples, n_features)\n        features\n    y : ary, shape=(n_samples)\n        classes\n    ns : int\n        the number of sensitive features\n    opt : object\n        options\n\n    Returns\n    -------\n    clr : classifier object\n        trained classifier\n    \"\"\"", "\n", "if", "opt", ".", "ltype", "==", "4", ":", "\n", "        ", "clr", "=", "LRwPRType4", "(", "eta", "=", "opt", ".", "eta", ",", "C", "=", "opt", ".", "C", ")", "\n", "clr", ".", "fit", "(", "X", ",", "y", ",", "ns", ",", "itype", "=", "opt", ".", "itype", ")", "\n", "", "else", ":", "\n", "        ", "sys", ".", "exit", "(", "\"Illegal likelihood fitting type\"", ")", "\n", "\n", "", "return", "clr", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.kamfadm-2012ecmlpkdd.train_pr.main": [[138, 230], ["numpy.loadtxt", "numpy.array", "fadm.util.fill_missing_with_mean", "datetime.datetime.now", "datetime.datetime.now.isoformat", "logger.info", "datetime.datetime.now", "logger.info", "datetime.datetime.now.isoformat", "logger.info", "str", "logger.info", "str", "logger.info", "logger.info", "logger.info", "logger.info", "logger.info", "pickle.dump", "vars().items", "pickle.dump", "sys.exit", "os.times", "train_pr.train", "logger.info", "range", "logger.info", "logger.info", "os.times", "str", "opt.infile.close", "opt.outfile.close", "datetime.datetime.now.isoformat", "logger.info", "train_pr.train", "logger.info", "datetime.datetime.now.isoformat", "str", "str", "str", "str", "vars", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.util._base.fill_missing_with_mean", "home.repos.pwc.inspect_result.IBM_AIF360.kamfadm-2012ecmlpkdd.train_pr.train", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.kamfadm-2012ecmlpkdd.train_pr.train"], ["", "def", "main", "(", "opt", ")", ":", "\n", "    ", "\"\"\" Main routine that exits with status code 0\n    \"\"\"", "\n", "\n", "### pre process", "\n", "\n", "# read data", "\n", "D", "=", "np", ".", "loadtxt", "(", "opt", ".", "infile", ")", "\n", "\n", "# split data and process missing values", "\n", "y", "=", "np", ".", "array", "(", "D", "[", ":", ",", "-", "1", "]", ")", "\n", "X", "=", "fill_missing_with_mean", "(", "D", "[", ":", ",", ":", "-", "1", "]", ")", "\n", "del", "D", "\n", "\n", "### main process", "\n", "\n", "# set starting time", "\n", "start_time", "=", "datetime", ".", "datetime", ".", "now", "(", ")", "\n", "start_utime", "=", "os", ".", "times", "(", ")", "[", "0", "]", "\n", "opt", ".", "start_time", "=", "start_time", ".", "isoformat", "(", ")", "\n", "logger", ".", "info", "(", "\"start time = \"", "+", "start_time", ".", "isoformat", "(", ")", ")", "\n", "\n", "# init constants", "\n", "ns", "=", "1", "\n", "\n", "# train", "\n", "if", "opt", ".", "ntry", "<=", "0", ":", "\n", "# train only once with zero coefficients", "\n", "        ", "clr", "=", "train", "(", "X", ",", "y", ",", "ns", ",", "opt", ")", "\n", "opt", ".", "final_loss", "=", "clr", ".", "f_loss_", "\n", "logger", ".", "info", "(", "'final_loss = '", "+", "str", "(", "opt", ".", "final_loss", ")", ")", "\n", "", "else", ":", "\n", "# train multiple times with random restarts", "\n", "        ", "clr", "=", "None", "\n", "best_loss", "=", "np", ".", "inf", "\n", "best_trial", "=", "0", "\n", "for", "trial", "in", "range", "(", "opt", ".", "ntry", ")", ":", "\n", "            ", "logger", ".", "info", "(", "\"Trial No. \"", "+", "str", "(", "trial", "+", "1", ")", ")", "\n", "tmp_clr", "=", "train", "(", "X", ",", "y", ",", "ns", ",", "opt", ")", "\n", "logger", ".", "info", "(", "\"loss = \"", "+", "str", "(", "tmp_clr", ".", "f_loss_", ")", ")", "\n", "if", "tmp_clr", ".", "f_loss_", "<", "best_loss", ":", "\n", "                ", "clr", "=", "tmp_clr", "\n", "best_loss", "=", "clr", ".", "f_loss_", "\n", "best_trial", "=", "trial", "+", "1", "\n", "", "", "opt", ".", "final_loss", "=", "best_loss", "\n", "logger", ".", "info", "(", "'final_loss = '", "+", "str", "(", "opt", ".", "final_loss", ")", ")", "\n", "opt", ".", "best_trial", "=", "best_trial", "\n", "logger", ".", "info", "(", "'best_trial = '", "+", "str", "(", "opt", ".", "best_trial", ")", ")", "\n", "\n", "# set end and elapsed time", "\n", "", "end_time", "=", "datetime", ".", "datetime", ".", "now", "(", ")", "\n", "end_utime", "=", "os", ".", "times", "(", ")", "[", "0", "]", "\n", "logger", ".", "info", "(", "\"end time = \"", "+", "end_time", ".", "isoformat", "(", ")", ")", "\n", "opt", ".", "end_time", "=", "end_time", ".", "isoformat", "(", ")", "\n", "logger", ".", "info", "(", "\"elapsed_time = \"", "+", "str", "(", "(", "end_time", "-", "start_time", ")", ")", ")", "\n", "opt", ".", "elapsed_time", "=", "str", "(", "(", "end_time", "-", "start_time", ")", ")", "\n", "logger", ".", "info", "(", "\"elapsed_utime = \"", "+", "str", "(", "(", "end_utime", "-", "start_utime", ")", ")", ")", "\n", "opt", ".", "elapsed_utime", "=", "str", "(", "(", "end_utime", "-", "start_utime", ")", ")", "\n", "\n", "### output", "\n", "\n", "# add info", "\n", "opt", ".", "nos_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "logger", ".", "info", "(", "'nos_samples = '", "+", "str", "(", "opt", ".", "nos_samples", ")", ")", "\n", "opt", ".", "nos_features", "=", "X", ".", "shape", "[", "1", "]", "\n", "logger", ".", "info", "(", "'nos_features = '", "+", "str", "(", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "opt", ".", "classifier", "=", "clr", ".", "__class__", ".", "__name__", "\n", "logger", ".", "info", "(", "'classifier = '", "+", "opt", ".", "classifier", ")", "\n", "opt", ".", "fadm_version", "=", "fadm_version", "\n", "logger", ".", "info", "(", "'fadm_version = '", "+", "opt", ".", "fadm_version", ")", "\n", "opt", ".", "sklearn_version", "=", "sklearn_version", "\n", "logger", ".", "info", "(", "'sklearn_version = '", "+", "opt", ".", "sklearn_version", ")", "\n", "#    opt.training_score = clr.score(X, y)", "\n", "#    logger.info('training_score = ' + str(opt.training_score))", "\n", "\n", "# write file", "\n", "pickle", ".", "dump", "(", "clr", ",", "opt", ".", "outfile", ")", "\n", "info", "=", "{", "}", "\n", "for", "key", ",", "key_val", "in", "vars", "(", "opt", ")", ".", "items", "(", ")", ":", "\n", "        ", "info", "[", "key", "]", "=", "str", "(", "key_val", ")", "\n", "", "pickle", ".", "dump", "(", "info", ",", "opt", ".", "outfile", ")", "\n", "\n", "### post process", "\n", "\n", "# close file", "\n", "if", "opt", ".", "infile", "is", "not", "sys", ".", "stdin", ":", "\n", "        ", "opt", ".", "infile", ".", "close", "(", ")", "\n", "\n", "", "if", "opt", ".", "outfile", "is", "not", "sys", ".", "stdout", ":", "\n", "        ", "opt", ".", "outfile", ".", "close", "(", ")", "\n", "\n", "", "sys", ".", "exit", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.fadm.__init__._test": [[60, 71], ["doctest.testmod", "sys.exit"], "function", ["None"], []], "home.repos.pwc.inspect_result.IBM_AIF360.util._base.add_constant_feature": [[45, 60], ["numpy.ones"], "function", ["None"], ["def", "add_constant_feature", "(", "D", ")", ":", "\n", "    ", "\"\"\" add ones at the first column of the matrix\n\n    Parameters\n    __________\n    D : array, shape(n, m)\n        raw data matrix\n\n    Returns\n    -------\n    D : array, shape((n + 1, m)\n        data matrix with constant terms\n    \"\"\"", "\n", "\n", "return", "np", ".", "c_", "[", "np", ".", "ones", "(", "D", ".", "shape", "[", "0", "]", ")", ",", "D", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.util._base.fill_missing_with_mean": [[61, 85], ["range", "numpy.any", "numpy.isnan", "numpy.mean", "numpy.isnan", "numpy.isnan", "numpy.isfinite"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "fill_missing_with_mean", "(", "D", ",", "default", "=", "0.0", ")", ":", "\n", "    ", "\"\"\" fill missing value with the means of non-missing values in the column\n\n    Parameters\n    ----------\n    D : array, shape(n, m)\n        raw data matrix\n    default : float\n        default value if all values are NaN\n\n    Returns\n    -------\n    D : array, shape(n, m)\n        a data matrix whose missing values are filled\n    \"\"\"", "\n", "\n", "for", "i", "in", "range", "(", "D", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "D", "[", ":", ",", "i", "]", ")", ")", ":", "\n", "            ", "v", "=", "np", ".", "mean", "(", "D", "[", "np", ".", "isfinite", "(", "D", "[", ":", ",", "i", "]", ")", ",", "i", "]", ")", "\n", "if", "np", ".", "isnan", "(", "v", ")", ":", "\n", "                ", "v", "=", "default", "\n", "", "D", "[", "np", ".", "isnan", "(", "D", "[", ":", ",", "i", "]", ")", ",", "i", "]", "=", "v", "\n", "\n", "", "", "return", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.util._base.decode_nfv": [[86, 120], ["numpy.fromstring", "len", "numpy.any", "numpy.any", "sys.exit", "len"], "function", ["None"], ["", "def", "decode_nfv", "(", "nfvstr", ",", "nf", ")", ":", "\n", "    ", "\"\"\" parse the string for a list of feature domain sizes\n    \n    Parameters\n    ----------\n    nfvstr : str\n        string specified in a command-line option\n    nf : int\n        the number of features\n\n    Returns\n    -------\n     nfv : array, dtype=int, shape=(n_features)\n        array of sizes of feature domain\n\n    Raises\n    ------\n    ValueError\n        uninterpretable inputs\n    \"\"\"", "\n", "\n", "try", ":", "\n", "        ", "nfv", "=", "np", ".", "fromstring", "(", "nfvstr", ",", "dtype", "=", "int", ",", "sep", "=", "':'", ")", "\n", "\n", "if", "len", "(", "nfv", ")", "==", "1", ":", "\n", "            ", "nfv", "=", "nfv", "*", "nf", "\n", "", "elif", "len", "(", "nfv", ")", "!=", "nf", ":", "\n", "            ", "raise", "ValueError", "\n", "", "if", "np", ".", "any", "(", "nfv", "<", "0", ")", "or", "np", ".", "any", "(", "nfv", "==", "1", ")", ":", "\n", "            ", "raise", "ValueError", "\n", "", "", "except", "ValueError", ":", "\n", "        ", "sys", ".", "exit", "(", "\"Illegal specfication of the numbers of feature values\"", ")", "\n", "\n", "", "return", "nfv", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.util._base._test": [[135, 146], ["doctest.testmod", "sys.exit"], "function", ["None"], ["", "def", "_test", "(", ")", ":", "\n", "    ", "\"\"\" test function for this module\n    \"\"\"", "\n", "\n", "# perform doctest", "\n", "import", "sys", "\n", "import", "doctest", "\n", "\n", "doctest", ".", "testmod", "(", ")", "\n", "\n", "sys", ".", "exit", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPR.__init__": [[122, 132], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "C", "=", "1.0", ",", "eta", "=", "1.0", ",", "fit_intercept", "=", "True", ",", "penalty", "=", "'l2'", ")", ":", "\n", "\n", "        ", "if", "C", "<", "0.0", ":", "\n", "            ", "raise", "TypeError", "\n", "", "self", ".", "fit_intercept", "=", "fit_intercept", "\n", "self", ".", "penalty", "=", "penalty", "\n", "self", ".", "C", "=", "C", "\n", "self", ".", "eta", "=", "eta", "\n", "self", ".", "minor_type", "=", "0", "\n", "self", ".", "f_loss_", "=", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPR.predict": [[133, 148], ["numpy.argmax", "pr.LRwPR.predict_proba"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\" predict classes\n\n        Parameters\n        ----------\n        X : array, shape=(n_samples, n_features)\n            feature vectors of samples\n\n        Returns\n        -------\n        y : array, shape=(n_samples), dtype=int\n            array of predicted class\n        \"\"\"", "\n", "\n", "return", "np", ".", "argmax", "(", "self", ".", "predict_proba", "(", "X", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba": [[153, 185], ["numpy.atleast_1d", "pr.LRwPRPredictProbaType2Mixin.coef_.reshape", "numpy.empty", "numpy.squeeze().astype", "pr.sigmoid", "numpy.atleast_2d", "range", "numpy.squeeze", "numpy.ones", "numpy.array", "numpy.atleast_2d"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.sigmoid", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["def", "predict_proba", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\" predict probabilities\n\n        a set of weight vectors, whose size if the same as the number of the\n        sensitive features, are available and these weights are selected\n        according to the value of a sensitive feature\n\n        Parameters\n        ----------\n        X : array, shape=(n_samples, n_features)\n            feature vectors of samples\n\n        Returns\n        -------\n        y_proba : array, shape=(n_samples, n_classes), dtype=float\n            array of predicted class\n        \"\"\"", "\n", "\n", "# add a constanet term", "\n", "s", "=", "np", ".", "atleast_1d", "(", "np", ".", "squeeze", "(", "np", ".", "array", "(", "X", ")", "[", ":", ",", "-", "self", ".", "n_s_", "]", ")", ".", "astype", "(", "int", ")", ")", "\n", "if", "self", ".", "fit_intercept", ":", "\n", "            ", "X", "=", "np", ".", "c_", "[", "np", ".", "atleast_2d", "(", "X", ")", "[", ":", ",", ":", "-", "self", ".", "n_s_", "]", ",", "np", ".", "ones", "(", "X", ".", "shape", "[", "0", "]", ")", "]", "\n", "", "else", ":", "\n", "            ", "X", "=", "np", ".", "atleast_2d", "(", "X", ")", "[", ":", ",", ":", "-", "self", ".", "n_s_", "]", "\n", "", "coef", "=", "self", ".", "coef_", ".", "reshape", "(", "self", ".", "n_sfv_", ",", "self", ".", "n_features_", ")", "\n", "\n", "proba", "=", "np", ".", "empty", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "N_CLASSES", ")", ")", "\n", "proba", "[", ":", ",", "1", "]", "=", "[", "sigmoid", "(", "X", "[", "i", ",", ":", "]", ",", "coef", "[", "s", "[", "i", "]", ",", ":", "]", ")", "\n", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "0", "]", ")", "]", "\n", "proba", "[", ":", ",", "0", "]", "=", "1.0", "-", "proba", "[", ":", ",", "1", "]", "\n", "\n", "return", "proba", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.init_coef": [[190, 245], ["numpy.zeros", "numpy.random.randn", "numpy.empty", "pr.LRwPRFittingType1Mixin.coef_.reshape", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit", "numpy.empty", "pr.LRwPRFittingType1Mixin.coef_.reshape", "range", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["def", "init_coef", "(", "self", ",", "itype", ",", "X", ",", "y", ",", "s", ")", ":", "\n", "        ", "\"\"\" set initial weight\n\n        initialization methods are specified by `itype`\n\n        * 0: cleared by 0\n        * 1: follows standard normal distribution\n        * 2: learned by standard logistic regression\n        * 3: learned by standard logistic regression separately according to\n          the value of sensitve feature\n\n        Parameters\n        ----------\n        itype : int\n            type of initialization method\n        X : array, shape=(n_samples, n_features)\n            feature vectors of samples\n        y : array, shape=(n_samples)\n            target class of samples\n        s : array, shape=(n_samples)\n            values of sensitive features\n        \"\"\"", "\n", "\n", "if", "itype", "==", "0", ":", "\n", "# clear by zeros", "\n", "            ", "self", ".", "coef_", "=", "np", ".", "zeros", "(", "self", ".", "n_sfv_", "*", "self", ".", "n_features_", ",", "\n", "dtype", "=", "np", ".", "float", ")", "\n", "", "elif", "itype", "==", "1", ":", "\n", "# at random", "\n", "            ", "self", ".", "coef_", "=", "np", ".", "random", ".", "randn", "(", "self", ".", "n_sfv_", "*", "self", ".", "n_features_", ")", "\n", "\n", "", "elif", "itype", "==", "2", ":", "\n", "# learned by standard LR", "\n", "            ", "self", ".", "coef_", "=", "np", ".", "empty", "(", "self", ".", "n_sfv_", "*", "self", ".", "n_features_", ",", "\n", "dtype", "=", "np", ".", "float", ")", "\n", "coef", "=", "self", ".", "coef_", ".", "reshape", "(", "self", ".", "n_sfv_", ",", "self", ".", "n_features_", ")", "\n", "\n", "clr", "=", "LogisticRegression", "(", "C", "=", "self", ".", "C", ",", "penalty", "=", "'l2'", ",", "\n", "fit_intercept", "=", "False", ")", "\n", "clr", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n", "coef", "[", ":", ",", ":", "]", "=", "clr", ".", "coef_", "\n", "", "elif", "itype", "==", "3", ":", "\n", "# learned by standard LR", "\n", "            ", "self", ".", "coef_", "=", "np", ".", "empty", "(", "self", ".", "n_sfv_", "*", "self", ".", "n_features_", ",", "\n", "dtype", "=", "np", ".", "float", ")", "\n", "coef", "=", "self", ".", "coef_", ".", "reshape", "(", "self", ".", "n_sfv_", ",", "self", ".", "n_features_", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "n_sfv_", ")", ":", "\n", "                ", "clr", "=", "LogisticRegression", "(", "C", "=", "self", ".", "C", ",", "penalty", "=", "'l2'", ",", "\n", "fit_intercept", "=", "False", ")", "\n", "clr", ".", "fit", "(", "X", "[", "s", "==", "i", ",", ":", "]", ",", "y", "[", "s", "==", "i", "]", ")", "\n", "coef", "[", "i", ",", ":", "]", "=", "clr", ".", "coef_", "\n", "", "", "else", ":", "\n", "            ", "raise", "TypeError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit": [[246, 294], ["numpy.atleast_1d", "numpy.array", "pr.LRwPRFittingType1Mixin.init_coef", "scipy.optimize.fmin_cg", "pr.LRwPRFittingType1Mixin.loss", "numpy.squeeze().astype", "numpy.max", "numpy.atleast_2d", "numpy.sum().astype", "numpy.squeeze", "range", "numpy.ones", "numpy.sum", "numpy.array", "numpy.atleast_2d"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.init_coef", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRObjetiveType4Mixin.loss", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "", "def", "fit", "(", "self", ",", "X", ",", "y", ",", "ns", "=", "N_S", ",", "itype", "=", "0", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" train this model\n\n        Parameters\n        ----------\n        X : array, shape = (n_samples, n_features)\n            feature vectors of samples\n        y : array, shape = (n_samples)\n            target class of samples\n        ns : int\n            number of sensitive features. currently fixed to N_S\n        itype : int\n            type of initialization method\n        kwargs : any\n            arguments to optmizer\n        \"\"\"", "\n", "\n", "# rearrange input arguments", "\n", "s", "=", "np", ".", "atleast_1d", "(", "np", ".", "squeeze", "(", "np", ".", "array", "(", "X", ")", "[", ":", ",", "-", "ns", "]", ")", ".", "astype", "(", "int", ")", ")", "\n", "if", "self", ".", "fit_intercept", ":", "\n", "            ", "X", "=", "np", ".", "c_", "[", "np", ".", "atleast_2d", "(", "X", ")", "[", ":", ",", ":", "-", "ns", "]", ",", "np", ".", "ones", "(", "X", ".", "shape", "[", "0", "]", ")", "]", "\n", "", "else", ":", "\n", "            ", "X", "=", "np", ".", "atleast_2d", "(", "X", ")", "[", ":", ",", ":", "-", "ns", "]", "\n", "\n", "# check optimization parameters", "\n", "", "if", "not", "'disp'", "in", "kwargs", ":", "\n", "            ", "kwargs", "[", "'disp'", "]", "=", "False", "\n", "", "if", "not", "'maxiter'", "in", "kwargs", ":", "\n", "            ", "kwargs", "[", "'maxiter'", "]", "=", "100", "\n", "\n", "# set instance variables", "\n", "", "self", ".", "n_s_", "=", "ns", "\n", "self", ".", "n_sfv_", "=", "np", ".", "max", "(", "s", ")", "+", "1", "\n", "self", ".", "c_s_", "=", "np", ".", "array", "(", "[", "np", ".", "sum", "(", "s", "==", "si", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "for", "si", "in", "range", "(", "self", ".", "n_sfv_", ")", "]", ")", "\n", "self", ".", "n_features_", "=", "X", ".", "shape", "[", "1", "]", "\n", "self", ".", "n_samples_", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "# optimization", "\n", "self", ".", "init_coef", "(", "itype", ",", "X", ",", "y", ",", "s", ")", "\n", "self", ".", "coef_", "=", "fmin_cg", "(", "self", ".", "loss", ",", "\n", "self", ".", "coef_", ",", "\n", "fprime", "=", "self", ".", "grad_loss", ",", "\n", "args", "=", "(", "X", ",", "y", ",", "s", ")", ",", "\n", "**", "kwargs", ")", "\n", "\n", "# get final loss", "\n", "self", ".", "f_loss_", "=", "self", ".", "loss", "(", "self", ".", "coef_", ",", "X", ",", "y", ",", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRObjetiveType4Mixin.loss": [[303, 360], ["coef_.reshape", "numpy.array", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.array", "numpy.sum", "pr.sigmoid", "range", "numpy.sum", "numpy.log", "numpy.log", "range", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.sigmoid", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["def", "loss", "(", "self", ",", "coef_", ",", "X", ",", "y", ",", "s", ")", ":", "\n", "        ", "\"\"\" loss function: negative log - likelihood with l2 regularizer\n        To suppress the warnings at np.log, do \"np.seterr(all='ignore')\"\n\n        Parameters\n        ----------\n        `coef_` : array, shape=(`n_sfv_` * n_features)\n            coefficients of model\n        X : array, shape=(n_samples, n_features)\n            feature vectors of samples\n        y : array, shape=(n_samples)\n            target class of samples\n        s : array, shape=(n_samples)\n            values of sensitive features\n\n        Returns\n        -------\n        loss : float\n            loss function value\n        \"\"\"", "\n", "\n", "coef", "=", "coef_", ".", "reshape", "(", "self", ".", "n_sfv_", ",", "self", ".", "n_features_", ")", "\n", "\n", "#        print >> sys.stderr, \"loss:\", coef[0, :], coef[1, :]", "\n", "\n", "### constants", "\n", "\n", "# sigma = Pr[y=0|x,s] = sigmoid(w(s)^T x)", "\n", "p", "=", "np", ".", "array", "(", "[", "sigmoid", "(", "X", "[", "i", ",", ":", "]", ",", "coef", "[", "s", "[", "i", "]", ",", ":", "]", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_samples_", ")", "]", ")", "\n", "\n", "# rho(s) = Pr[y=0|s] = \\sum_{(xi,si)in D st si=s} sigma(xi,si) / #D[s]", "\n", "q", "=", "np", ".", "array", "(", "[", "np", ".", "sum", "(", "p", "[", "s", "==", "si", "]", ")", "\n", "for", "si", "in", "range", "(", "self", ".", "n_sfv_", ")", "]", ")", "/", "self", ".", "c_s_", "\n", "\n", "# pi = Pr[y=0] = \\sum_{(xi,si)in D} sigma(xi,si)", "\n", "r", "=", "np", ".", "sum", "(", "p", ")", "/", "self", ".", "n_samples_", "\n", "\n", "### loss function", "\n", "\n", "# likelihood", "\n", "# \\sum_{x,s,y in D} y log(sigma) + (1 - y) log(1 - sigma)", "\n", "l", "=", "np", ".", "sum", "(", "y", "*", "np", ".", "log", "(", "p", ")", "+", "(", "1.0", "-", "y", ")", "*", "np", ".", "log", "(", "1.0", "-", "p", ")", ")", "\n", "\n", "# fairness-aware regularizer", "\n", "# \\sum_{x,s in D} \\", "\n", "#    sigma(x,x)       [log(rho(s))     - log(pi)    ] + \\", "\n", "#    (1 - sigma(x,s)) [log(1 - rho(s)) - log(1 - pi)]", "\n", "f", "=", "np", ".", "sum", "(", "p", "*", "(", "np", ".", "log", "(", "q", "[", "s", "]", ")", "-", "np", ".", "log", "(", "r", ")", ")", "\n", "+", "(", "1.0", "-", "p", ")", "*", "(", "np", ".", "log", "(", "1.0", "-", "q", "[", "s", "]", ")", "-", "np", ".", "log", "(", "1.0", "-", "r", ")", ")", ")", "\n", "\n", "# l2 regularizer", "\n", "reg", "=", "np", ".", "sum", "(", "coef", "*", "coef", ")", "\n", "\n", "l", "=", "-", "l", "+", "self", ".", "eta", "*", "f", "+", "0.5", "*", "self", ".", "C", "*", "reg", "\n", "#        print >> sys.stderr, l", "\n", "return", "l", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRObjetiveType4Mixin.grad_loss": [[361, 443], ["coef_.reshape", "numpy.empty", "numpy.empty.reshape", "numpy.array", "range", "numpy.array", "numpy.array", "numpy.array", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.outer", "pr.sigmoid", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.sum", "range", "numpy.sum", "numpy.sum", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.sigmoid", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "grad_loss", "(", "self", ",", "coef_", ",", "X", ",", "y", ",", "s", ")", ":", "\n", "        ", "\"\"\" first derivative of loss function\n\n        Parameters\n        ----------\n        `coef_` : array, shape=(`n_sfv_` * n_features)\n            coefficients of model\n        X : array, shape=(n_samples, n_features)\n            feature vectors of samples\n        y : array, shape=(n_samples)\n            target class of samples\n        s : array, shape=(n_samples)\n            values of sensitive features\n\n        Returns\n        grad_loss : float\n            first derivative of loss function\n        \"\"\"", "\n", "\n", "coef", "=", "coef_", ".", "reshape", "(", "self", ".", "n_sfv_", ",", "self", ".", "n_features_", ")", "\n", "l_", "=", "np", ".", "empty", "(", "self", ".", "n_sfv_", "*", "self", ".", "n_features_", ")", "\n", "l", "=", "l_", ".", "reshape", "(", "self", ".", "n_sfv_", ",", "self", ".", "n_features_", ")", "\n", "#        print >> sys.stderr, \"grad_loss:\", coef[0, :], coef[1, :]", "\n", "\n", "### constants", "\n", "# prefix \"d_\": derivertive by w(s)", "\n", "\n", "# sigma = Pr[y=0|x,s] = sigmoid(w(s)^T x)", "\n", "# d_sigma(x,s) = d sigma / d w(s) = sigma (1 - sigma) x", "\n", "p", "=", "np", ".", "array", "(", "[", "sigmoid", "(", "X", "[", "i", ",", ":", "]", ",", "coef", "[", "s", "[", "i", "]", ",", ":", "]", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_samples_", ")", "]", ")", "\n", "dp", "=", "(", "p", "*", "(", "1.0", "-", "p", ")", ")", "[", ":", ",", "np", ".", "newaxis", "]", "*", "X", "\n", "\n", "# rho(s) = Pr[y=0|s] = \\sum_{(xi,si)in D st si=s} sigma(xi,si) / #D[s]", "\n", "# d_rho(s) = \\sum_{(xi,si)in D st si=s} d_sigma(xi,si) / #D[s]", "\n", "q", "=", "np", ".", "array", "(", "[", "np", ".", "sum", "(", "p", "[", "s", "==", "si", "]", ")", "\n", "for", "si", "in", "range", "(", "self", ".", "n_sfv_", ")", "]", ")", "/", "self", ".", "c_s_", "\n", "dq", "=", "np", ".", "array", "(", "[", "np", ".", "sum", "(", "dp", "[", "s", "==", "si", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "for", "si", "in", "range", "(", "self", ".", "n_sfv_", ")", "]", ")", "/", "self", ".", "c_s_", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "# pi = Pr[y=0] = \\sum_{(xi,si)in D} sigma(xi,si) / #D", "\n", "# d_pi = \\sum_{(xi,si)in D} d_sigma(xi,si) / #D", "\n", "r", "=", "np", ".", "sum", "(", "p", ")", "/", "self", ".", "n_samples_", "\n", "dr", "=", "np", ".", "sum", "(", "dp", ",", "axis", "=", "0", ")", "/", "self", ".", "n_samples_", "\n", "\n", "# likelihood", "\n", "# l(si) = \\sum_{x,y in D st s=si} (y - sigma(x, si)) x", "\n", "for", "si", "in", "range", "(", "self", ".", "n_sfv_", ")", ":", "\n", "            ", "l", "[", "si", ",", ":", "]", "=", "np", ".", "sum", "(", "(", "y", "-", "p", ")", "[", "s", "==", "si", "]", "[", ":", ",", "np", ".", "newaxis", "]", "*", "X", "[", "s", "==", "si", ",", ":", "]", ",", "\n", "axis", "=", "0", ")", "\n", "\n", "# fairness-aware regularizer", "\n", "# differentialy by w(s)", "\n", "# \\sum_{x,s in {D st s=si} \\", "\n", "#     [(log(rho(si)) - log(pi)) - (log(1 - rho(si)) - log(1 - pi))] \\", "\n", "#     * d_sigma", "\n", "# + \\sum_{x,s in {D st s=si} \\", "\n", "#     [ {sigma(xi, si) - rho(si)} / {rho(si) (1 - rho(si))} ] \\", "\n", "#     * d_rho", "\n", "# - \\sum_{x,s in {D st s=si} \\", "\n", "#     [ {sigma(xi, si) - pi} / {pi (1 - pi)} ] \\", "\n", "#     * d_pi", "\n", "\n", "", "f1", "=", "(", "np", ".", "log", "(", "q", "[", "s", "]", ")", "-", "np", ".", "log", "(", "r", ")", ")", "-", "(", "np", ".", "log", "(", "1.0", "-", "q", "[", "s", "]", ")", "-", "np", ".", "log", "(", "1.0", "-", "r", ")", ")", "\n", "f2", "=", "(", "p", "-", "q", "[", "s", "]", ")", "/", "(", "q", "[", "s", "]", "*", "(", "1.0", "-", "q", "[", "s", "]", ")", ")", "\n", "f3", "=", "(", "p", "-", "r", ")", "/", "(", "r", "*", "(", "1.0", "-", "r", ")", ")", "\n", "f4", "=", "f1", "[", ":", ",", "np", ".", "newaxis", "]", "*", "dp", "+", "f2", "[", ":", ",", "np", ".", "newaxis", "]", "*", "dq", "[", "s", ",", ":", "]", "-", "np", ".", "outer", "(", "f3", ",", "dr", ")", "\n", "f", "=", "np", ".", "array", "(", "[", "np", ".", "sum", "(", "f4", "[", "s", "==", "si", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "for", "si", "in", "range", "(", "self", ".", "n_sfv_", ")", "]", ")", "\n", "\n", "# l2 regularizer", "\n", "reg", "=", "coef", "\n", "\n", "# sum", "\n", "l", "[", ":", ",", ":", "]", "=", "-", "l", "+", "self", ".", "eta", "*", "f", "+", "self", ".", "C", "*", "reg", "\n", "#        print >> sys.stderr, \"l =\", l", "\n", "\n", "return", "l_", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRType4.__init__": [[462, 473], ["pr.LRwPR.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "C", "=", "1.0", ",", "eta", "=", "1.0", ",", "fit_intercept", "=", "True", ",", "penalty", "=", "'l2'", ")", ":", "\n", "\n", "        ", "super", "(", "LRwPRType4", ",", "self", ")", ".", "__init__", "(", "C", "=", "C", ",", "eta", "=", "eta", ",", "\n", "fit_intercept", "=", "fit_intercept", ",", "penalty", "=", "penalty", ")", "\n", "\n", "self", ".", "coef_", "=", "None", "\n", "self", ".", "mx_", "=", "None", "\n", "self", ".", "n_s_", "=", "0", "\n", "self", ".", "n_sfv_", "=", "0", "\n", "self", ".", "minor_type", "=", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.sigmoid": [[60, 79], ["numpy.clip", "numpy.dot", "numpy.exp"], "function", ["None"], ["def", "sigmoid", "(", "x", ",", "w", ")", ":", "\n", "    ", "\"\"\" sigmoid(w^T x)\n    To suppress the warnings at np.exp, do \"np.seterr(all='ignore')\"\n\n    Parameters\n    ----------\n    x : array, shape=(d)\n        input vector\n    w : array, shape=(d)\n        weight\n\n    -------\n    sigmoid : float\n        sigmoid(w^T x)\n    \"\"\"", "\n", "\n", "s", "=", "np", ".", "clip", "(", "np", ".", "dot", "(", "w", ",", "x", ")", ",", "-", "SIGMOID_RANGE", ",", "SIGMOID_RANGE", ")", "\n", "\n", "return", "1.0", "/", "(", "1.0", "+", "np", ".", "exp", "(", "-", "s", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr._test": [[488, 499], ["doctest.testmod", "sys.exit"], "function", ["None"], ["", "def", "_test", "(", ")", ":", "\n", "    ", "\"\"\" test function for this module\n    \"\"\"", "\n", "\n", "# perform doctest", "\n", "import", "sys", "\n", "import", "doctest", "\n", "\n", "doctest", ".", "testmod", "(", ")", "\n", "\n", "sys", ".", "exit", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.FalseDiscovery.FalseDiscovery.getExpectedGrad": [[7, 16], ["FalseDiscovery.FalseDiscovery.getValueForX", "numpy.vstack", "numpy.mean", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.getValueForX"], ["    ", "def", "getExpectedGrad", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "params", ",", "samples", ",", "mu", ",", "z_prior", ")", ":", "\n", "        ", "t", ",", "probc_m1_0", ",", "probc_m1_1", ",", "prob_z_0", ",", "prob_z_1", "=", "self", ".", "getValueForX", "(", "dist", ",", "\n", "a", ",", "b", ",", "params", ",", "z_prior", ",", "samples", ",", "return_probs", "=", "True", ")", "\n", "res", "=", "np", ".", "vstack", "(", "[", "probc_m1_0", "-", "a", "*", "prob_z_0", ",", "\n", "probc_m1_1", "-", "a", "*", "prob_z_1", ",", "\n", "-", "probc_m1_0", "+", "b", "*", "prob_z_0", ",", "\n", "-", "probc_m1_1", "+", "b", "*", "prob_z_1", "]", ")", "\n", "res", "*=", "t", "/", "np", ".", "sqrt", "(", "t", "**", "2", "+", "mu", "**", "2", ")", "\n", "return", "np", ".", "mean", "(", "res", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.FalseDiscovery.FalseDiscovery.getValueForX": [[17, 46], ["numpy.ones", "FalseDiscovery.FalseDiscovery.prob", "FalseDiscovery.FalseDiscovery.prob", "FalseDiscovery.FalseDiscovery.prob", "FalseDiscovery.FalseDiscovery.prob", "len", "numpy.zeros", "numpy.zeros", "len", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.prob", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.prob", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.prob", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.prob"], ["", "def", "getValueForX", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "params", ",", "z_prior", ",", "x", ",", "return_probs", "=", "False", ")", ":", "\n", "        ", "u_1", ",", "u_2", ",", "l_1", ",", "l_2", "=", "params", "\n", "z_0", ",", "z_1", "=", "1", "-", "z_prior", ",", "z_prior", "\n", "\n", "pos", "=", "np", ".", "ones", "(", "len", "(", "x", ")", ")", "\n", "prob_1_1", "=", "self", ".", "prob", "(", "dist", ",", "np", ".", "c_", "[", "x", ",", "pos", ",", "pos", "]", ")", "\n", "prob_m1_1", "=", "self", ".", "prob", "(", "dist", ",", "np", ".", "c_", "[", "x", ",", "-", "pos", ",", "pos", "]", ")", "\n", "prob_1_0", "=", "self", ".", "prob", "(", "dist", ",", "np", ".", "c_", "[", "x", ",", "pos", ",", "np", ".", "zeros", "(", "len", "(", "x", ")", ")", "]", ")", "\n", "prob_m1_0", "=", "self", ".", "prob", "(", "dist", ",", "np", ".", "c_", "[", "x", ",", "-", "pos", ",", "np", ".", "zeros", "(", "len", "(", "x", ")", ")", "]", ")", "\n", "\n", "total", "=", "prob_1_1", "+", "prob_1_0", "+", "prob_m1_0", "+", "prob_m1_1", "\n", "# if total == 0:", "\n", "#     return 0", "\n", "\n", "prob_y_1", "=", "(", "prob_1_1", "+", "prob_1_0", ")", "/", "total", "\n", "prob_z_0", "=", "(", "prob_m1_0", "+", "prob_1_0", ")", "/", "total", "\n", "prob_z_1", "=", "(", "prob_m1_1", "+", "prob_1_1", ")", "/", "total", "\n", "\n", "probc_m1_0", "=", "prob_m1_0", "/", "total", "\n", "probc_m1_1", "=", "prob_m1_1", "/", "total", "\n", "\n", "c_0", "=", "prob_y_1", "-", "0.5", "\n", "c_1", "=", "u_1", "*", "(", "probc_m1_0", "-", "a", "*", "prob_z_0", ")", "+", "u_2", "*", "(", "probc_m1_1", "-", "a", "*", "prob_z_1", ")", "\n", "c_2", "=", "l_1", "*", "(", "-", "probc_m1_0", "+", "b", "*", "prob_z_0", ")", "+", "l_2", "*", "(", "-", "probc_m1_1", "+", "b", "*", "prob_z_1", ")", "\n", "\n", "t", "=", "c_0", "+", "c_1", "+", "c_2", "\n", "if", "return_probs", ":", "\n", "            ", "return", "t", ",", "probc_m1_0", ",", "probc_m1_1", ",", "prob_z_0", ",", "prob_z_1", "\n", "", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.FalseDiscovery.FalseDiscovery.getFuncValue": [[47, 50], ["numpy.mean", "numpy.abs", "FalseDiscovery.FalseDiscovery.getValueForX"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.getValueForX"], ["", "def", "getFuncValue", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "params", ",", "samples", ",", "z_prior", ")", ":", "\n", "        ", "return", "np", ".", "mean", "(", "np", ".", "abs", "(", "self", ".", "getValueForX", "(", "dist", ",", "a", ",", "b", ",", "params", ",", "z_prior", ",", "\n", "samples", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.FalseDiscovery.FalseDiscovery.num_params": [[51, 54], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_params", "(", "self", ")", ":", "\n", "        ", "return", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.FalseDiscovery.FalseDiscovery.gamma": [[55, 65], ["min", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum"], "methods", ["None"], ["", "def", "gamma", "(", "self", ",", "y_true", ",", "y_pred", ",", "sens", ")", ":", "\n", "        ", "pos_0", "=", "y_pred", "[", "sens", "==", "0", "]", "==", "1", "\n", "pos_1", "=", "y_pred", "[", "sens", "==", "1", "]", "==", "1", "\n", "if", "np", ".", "sum", "(", "pos_0", ")", "==", "0", "or", "np", ".", "sum", "(", "pos_1", ")", "==", "0", ":", "\n", "            ", "return", "0", "\n", "", "fdr_0", "=", "np", ".", "sum", "(", "pos_0", "&", "(", "y_true", "[", "sens", "==", "0", "]", "==", "-", "1", ")", ")", "/", "np", ".", "sum", "(", "pos_0", ")", "\n", "fdr_1", "=", "np", ".", "sum", "(", "pos_1", "&", "(", "y_true", "[", "sens", "==", "1", "]", "==", "-", "1", ")", ")", "/", "np", ".", "sum", "(", "pos_1", ")", "\n", "if", "fdr_0", "==", "0", "or", "fdr_1", "==", "0", ":", "\n", "            ", "return", "0", "\n", "", "return", "min", "(", "fdr_0", "/", "fdr_1", ",", "fdr_1", "/", "fdr_0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.getExpectedGrad": [[17, 23], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "getExpectedGrad", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "params", ",", "samples", ",", "mu", ",", "z_prior", ")", ":", "\n", "        ", "\"\"\"Used in gradient descent algorithm. Returns the value of gradient at\n        any step.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.getValueForX": [[24, 28], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "getValueForX", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "params", ",", "z_prior", ",", "x", ")", ":", "\n", "        ", "\"\"\"Returns the threshold value at any point.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.getFuncValue": [[29, 33], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "getFuncValue", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "params", ",", "samples", ",", "z_prior", ")", ":", "\n", "        ", "\"\"\"Returns the value of the objective function for given parameters.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.num_params": [[34, 38], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "num_params", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range": [[39, 44], ["numpy.minimum", "numpy.arange", "numpy.ceil"], "methods", ["None"], ["", "def", "range", "(", "self", ",", "eps", ",", "tau", ")", ":", "\n", "        ", "a", "=", "np", ".", "arange", "(", "np", ".", "ceil", "(", "tau", "/", "eps", ")", ",", "step", "=", "10", ")", "*", "eps", "\n", "b", "=", "(", "a", "+", "eps", ")", "/", "tau", "\n", "b", "=", "np", ".", "minimum", "(", "b", ",", "1", ")", "\n", "return", "np", ".", "c_", "[", "a", ",", "b", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.gamma": [[45, 48], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "gamma", "(", "self", ",", "y_true", ",", "y_pred", ",", "sens", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.init_params": [[49, 51], ["None"], "methods", ["None"], ["", "def", "init_params", "(", "self", ",", "i", ")", ":", "\n", "        ", "return", "[", "i", "]", "*", "self", ".", "num_params", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.gradientDescent": [[52, 73], ["General.General.range"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "gradientDescent", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "samples", ",", "z_prior", ")", ":", "\n", "        ", "\"\"\"Gradient Descent implementation for the optimizing the objective\n        function.\n\n        Note that one can alternately also use packages like CVXPY here.\n        Here we use decaying step size. For certain objectives, constant step\n        size might be better.\n        \"\"\"", "\n", "min_val", "=", "np", ".", "inf", "# 1e8", "\n", "min_param", "=", "None", "\n", "for", "i", "in", "range", "(", "1", ",", "10", ")", ":", "\n", "            ", "params", "=", "self", ".", "init_params", "(", "i", ")", "\n", "for", "k", "in", "range", "(", "1", ",", "50", ")", ":", "\n", "                ", "grad", "=", "self", ".", "getExpectedGrad", "(", "dist", ",", "a", ",", "b", ",", "params", ",", "samples", ",", "0.01", ",", "\n", "z_prior", ")", "\n", "for", "j", "in", "range", "(", "self", ".", "num_params", ")", ":", "\n", "                    ", "params", "[", "j", "]", "=", "params", "[", "j", "]", "-", "1", "/", "k", "*", "grad", "[", "j", "]", "\n", "", "f_val", "=", "self", ".", "getFuncValue", "(", "dist", ",", "a", ",", "b", ",", "params", ",", "samples", ",", "z_prior", ")", "\n", "if", "f_val", "<", "min_val", ":", "\n", "                    ", "min_val", ",", "min_param", "=", "f_val", ",", "params", "\n", "", "", "", "return", "min_param", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.prob": [[74, 76], ["dist.pdf"], "methods", ["None"], ["", "def", "prob", "(", "self", ",", "dist", ",", "x", ")", ":", "\n", "        ", "return", "dist", ".", "pdf", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.getModel": [[77, 110], ["numpy.mean", "numpy.cov", "scipy.stats.multivariate_normal", "scipy.stats.multivariate_normal", "numpy.mean", "functools.partial", "General.General.range", "scipy.stats.multivariate_normal.rvs", "General.General.gradientDescent", "General.General.getValueForX", "numpy.where", "sklearn.metrics.accuracy_score", "General.General.gamma"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.gradientDescent", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.getValueForX", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.gamma"], ["", "def", "getModel", "(", "self", ",", "tau", ",", "X", ",", "y", ",", "sens", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"Returns the model given the training data and input tau.\"\"\"", "\n", "train", "=", "np", ".", "c_", "[", "X", ",", "y", ",", "sens", "]", "\n", "mean", "=", "np", ".", "mean", "(", "train", ",", "axis", "=", "0", ")", "\n", "cov", "=", "np", ".", "cov", "(", "train", ",", "rowvar", "=", "False", ")", "\n", "dist", "=", "multivariate_normal", "(", "mean", ",", "cov", ",", "allow_singular", "=", "True", ",", "\n", "seed", "=", "random_state", ")", "\n", "n", "=", "X", ".", "shape", "[", "1", "]", "\n", "dist_x", "=", "multivariate_normal", "(", "mean", "[", ":", "n", "]", ",", "cov", "[", ":", "n", ",", ":", "n", "]", ",", "allow_singular", "=", "True", ",", "\n", "seed", "=", "random_state", ")", "\n", "\n", "eps", "=", "0.01", "\n", "z_1", "=", "np", ".", "mean", "(", "sens", ")", "\n", "params_opt", "=", "[", "0", "]", "*", "self", ".", "num_params", "\n", "max_acc", "=", "0", "\n", "p", ",", "q", "=", "0", ",", "0", "\n", "\n", "if", "tau", "!=", "0", ":", "\n", "            ", "for", "a", ",", "b", "in", "self", ".", "range", "(", "eps", ",", "tau", ")", ":", "\n", "                ", "samples", "=", "dist_x", ".", "rvs", "(", "size", "=", "20", ")", "# TODO: why 20?", "\n", "params", "=", "self", ".", "gradientDescent", "(", "dist", ",", "a", ",", "b", ",", "samples", ",", "z_1", ")", "\n", "\n", "t", "=", "self", ".", "getValueForX", "(", "dist", ",", "a", ",", "b", ",", "params", ",", "z_1", ",", "X", ")", "\n", "y_pred", "=", "np", ".", "where", "(", "t", ">", "0", ",", "1", ",", "-", "1", ")", "\n", "\n", "acc", "=", "accuracy_score", "(", "y", ",", "y_pred", ")", "\n", "gamma", "=", "self", ".", "gamma", "(", "y", ",", "y_pred", ",", "sens", ")", "\n", "\n", "if", "max_acc", "<", "acc", "and", "gamma", ">=", "tau", "-", "0.2", ":", "# TODO: why - 0.2?", "\n", "                    ", "max_acc", "=", "acc", "\n", "params_opt", "=", "params", "\n", "p", ",", "q", "=", "a", ",", "b", "\n", "", "", "", "return", "partial", "(", "self", ".", "getValueForX", ",", "dist", ",", "p", ",", "q", ",", "params_opt", ",", "z_1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.getExpectedGrad": [[7, 21], ["StatisticalRate.StatisticalRate.getValueForX", "numpy.mean", "numpy.mean", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.getValueForX"], ["    ", "def", "getExpectedGrad", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "params", ",", "samples", ",", "mu", ",", "z_prior", ")", ":", "\n", "        ", "l_1", ",", "l_2", "=", "params", "\n", "\n", "t", ",", "c_1", ",", "c_2", "=", "self", ".", "getValueForX", "(", "dist", ",", "a", ",", "b", ",", "params", ",", "z_prior", ",", "samples", ",", "\n", "return_cs", "=", "True", ")", "\n", "\n", "t1", "=", "t", "*", "c_1", "/", "np", ".", "sqrt", "(", "t", "**", "2", "+", "mu", "**", "2", ")", "\n", "t2", "=", "t", "*", "c_2", "/", "np", ".", "sqrt", "(", "t", "**", "2", "+", "mu", "**", "2", ")", "\n", "\n", "exp1", "=", "np", ".", "mean", "(", "t1", ")", "\n", "exp2", "=", "np", ".", "mean", "(", "t2", ")", "\n", "dl1", "=", "exp1", "-", "b", "+", "(", "b", "-", "a", ")", "/", "2", "+", "(", "b", "-", "a", ")", "*", "l_1", "/", "(", "2", "*", "np", ".", "sqrt", "(", "l_1", "**", "2", "+", "mu", "**", "2", ")", ")", "\n", "dl2", "=", "exp2", "-", "b", "+", "(", "b", "-", "a", ")", "/", "2", "+", "(", "b", "-", "a", ")", "*", "l_2", "/", "(", "2", "*", "np", ".", "sqrt", "(", "l_2", "**", "2", "+", "mu", "**", "2", ")", ")", "\n", "return", "dl1", ",", "dl2", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.getValueForX": [[22, 49], ["numpy.ones", "StatisticalRate.StatisticalRate.prob", "StatisticalRate.StatisticalRate.prob", "StatisticalRate.StatisticalRate.prob", "StatisticalRate.StatisticalRate.prob", "len", "numpy.zeros", "numpy.zeros", "len", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.prob", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.prob", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.prob", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.prob"], ["", "def", "getValueForX", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "params", ",", "z_prior", ",", "x", ",", "return_cs", "=", "False", ")", ":", "\n", "        ", "l_1", ",", "l_2", "=", "params", "\n", "z_0", ",", "z_1", "=", "1", "-", "z_prior", ",", "z_prior", "\n", "\n", "pos", "=", "np", ".", "ones", "(", "len", "(", "x", ")", ")", "\n", "prob_1_1", "=", "self", ".", "prob", "(", "dist", ",", "np", ".", "c_", "[", "x", ",", "pos", ",", "pos", "]", ")", "\n", "prob_m1_1", "=", "self", ".", "prob", "(", "dist", ",", "np", ".", "c_", "[", "x", ",", "-", "pos", ",", "pos", "]", ")", "\n", "prob_1_0", "=", "self", ".", "prob", "(", "dist", ",", "np", ".", "c_", "[", "x", ",", "pos", ",", "np", ".", "zeros", "(", "len", "(", "x", ")", ")", "]", ")", "\n", "prob_m1_0", "=", "self", ".", "prob", "(", "dist", ",", "np", ".", "c_", "[", "x", ",", "-", "pos", ",", "np", ".", "zeros", "(", "len", "(", "x", ")", ")", "]", ")", "\n", "\n", "total", "=", "prob_1_1", "+", "prob_1_0", "+", "prob_m1_0", "+", "prob_m1_1", "\n", "# if total == 0:", "\n", "#     return 0", "\n", "\n", "prob_y_1", "=", "(", "prob_1_1", "+", "prob_1_0", ")", "/", "total", "\n", "prob_z_0", "=", "(", "prob_m1_0", "+", "prob_1_0", ")", "/", "total", "\n", "prob_z_1", "=", "(", "prob_m1_1", "+", "prob_1_1", ")", "/", "total", "\n", "\n", "c_0", "=", "prob_y_1", "-", "0.5", "\n", "c_1", "=", "prob_z_0", "/", "z_0", "\n", "c_2", "=", "prob_z_1", "/", "z_1", "\n", "\n", "t", "=", "c_0", "+", "c_1", "*", "l_1", "+", "c_2", "*", "l_2", "\n", "if", "return_cs", ":", "\n", "            ", "return", "t", ",", "c_1", ",", "c_2", "\n", "", "else", ":", "\n", "            ", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.getFuncValue": [[50, 62], ["numpy.mean", "numpy.abs", "StatisticalRate.StatisticalRate.getValueForX"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.getValueForX"], ["", "", "def", "getFuncValue", "(", "self", ",", "dist", ",", "a", ",", "b", ",", "params", ",", "samples", ",", "z_prior", ")", ":", "\n", "        ", "l_1", ",", "l_2", "=", "params", "\n", "\n", "exp", "=", "np", ".", "mean", "(", "np", ".", "abs", "(", "self", ".", "getValueForX", "(", "dist", ",", "a", ",", "b", ",", "params", ",", "z_prior", ",", "\n", "samples", ")", ")", ")", "\n", "result", "=", "exp", "-", "b", "*", "l_1", "-", "b", "*", "l_2", "\n", "if", "l_1", ">", "0", ":", "\n", "            ", "result", "+=", "(", "b", "-", "a", ")", "*", "l_1", "\n", "", "if", "l_2", ">", "0", ":", "\n", "            ", "result", "+=", "(", "b", "-", "a", ")", "*", "l_2", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.num_params": [[63, 66], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_params", "(", "self", ")", ":", "\n", "        ", "return", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.init_params": [[67, 69], ["None"], "methods", ["None"], ["", "def", "init_params", "(", "self", ",", "i", ")", ":", "\n", "        ", "return", "[", "i", "-", "5", "]", "*", "self", ".", "num_params", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.StatisticalRate.StatisticalRate.gamma": [[70, 76], ["numpy.mean", "numpy.mean", "min"], "methods", ["None"], ["", "def", "gamma", "(", "self", ",", "y_true", ",", "y_pred", ",", "sens", ")", ":", "\n", "        ", "pos_0", "=", "np", ".", "mean", "(", "y_pred", "[", "sens", "==", "0", "]", "==", "1", ")", "\n", "pos_1", "=", "np", ".", "mean", "(", "y_pred", "[", "sens", "==", "1", "]", "==", "1", ")", "\n", "if", "pos_0", "==", "0", "or", "pos_1", "==", "0", ":", "\n", "            ", "return", "0", "\n", "", "return", "min", "(", "pos_0", "/", "pos_1", ",", "pos_1", "/", "pos_0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Group.__init__": [[32, 50], ["object.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ",", "func", ",", "group_size", ",", "weighted_disparity", ",", "disparity", ",", "\n", "disparity_direction", ",", "group_rate", ")", ":", "\n", "        ", "\"\"\"Constructor for Group Class.\n\n        :param func: the linear function that defines the group\n        :param group_size: the proportion of the dataset in the group\n        :param weighted_disparity: group_size*FP or FN disparity\n        :param disparity: FN or FP disparity (absolute value)\n        :param disparity_direction: indicator whether fp in group > fp_baseline, returns {1, -1}\n        :param group_rate: FN or FN rate in the group\n        \"\"\"", "\n", "super", "(", "Group", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "func", "=", "func", "\n", "self", ".", "group_size", "=", "group_size", "\n", "self", ".", "weighted_disparity", "=", "weighted_disparity", "\n", "self", ".", "disparity", "=", "disparity", "\n", "self", ".", "disparity_direction", "=", "disparity_direction", "\n", "self", ".", "group_rate", "=", "group_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Group.return_f": [[51, 55], ["None"], "methods", ["None"], ["", "def", "return_f", "(", "self", ")", ":", "\n", "        ", "return", "[", "\n", "self", ".", "func", ",", "self", ".", "group_size", ",", "self", ".", "weighted_disparity", ",", "\n", "self", ".", "disparity", ",", "self", ".", "disparity_direction", ",", "self", ".", "group_rate", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.__init__": [[61, 84], ["aif360.algorithms.inprocessing.gerryfair.clean.extract_df_from_ds", "numpy.array", "pandas.DataFrame", "Exception", "abs", "enumerate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.extract_df_from_ds"], ["def", "__init__", "(", "self", ",", "dataset", ",", "fairness_def", ")", ":", "\n", "        ", "\"\"\"Auditor constructor.\n\n        Args:\n            :param dataset: dataset object subclassing StandardDataset.\n            :param fairness_def: 'FP' or 'FN'\n        \"\"\"", "\n", "X", ",", "X_prime", ",", "y", "=", "clean", ".", "extract_df_from_ds", "(", "dataset", ")", "\n", "self", ".", "X_prime", "=", "X_prime", "\n", "self", ".", "y_input", "=", "y", "\n", "self", ".", "y_inverse", "=", "np", ".", "array", "(", "\n", "[", "abs", "(", "1", "-", "y_value", ")", "for", "y_value", "in", "self", ".", "y_input", "]", ")", "\n", "self", ".", "fairness_def", "=", "fairness_def", "\n", "if", "self", ".", "fairness_def", "not", "in", "[", "'FP'", ",", "'FN'", "]", ":", "\n", "            ", "raise", "Exception", "(", "\n", "'Invalid fairness metric specified: {}. Please choose \\'FP\\' or \\'FN\\'.'", "\n", ".", "format", "(", "self", ".", "fairness_def", ")", ")", "\n", "", "self", ".", "y", "=", "self", ".", "y_input", "\n", "# flip the labels for FN rate auditing", "\n", "if", "self", ".", "fairness_def", "==", "'FN'", ":", "\n", "            ", "self", ".", "y", "=", "self", ".", "y_inverse", "\n", "", "self", ".", "X_prime_0", "=", "pd", ".", "DataFrame", "(", "\n", "[", "self", ".", "X_prime", ".", "iloc", "[", "u", ",", ":", "]", "for", "u", ",", "s", "in", "enumerate", "(", "self", ".", "y", ")", "if", "s", "==", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.initialize_costs": [[85, 105], ["tuple", "tuple"], "methods", ["None"], ["", "def", "initialize_costs", "(", "self", ",", "n", ")", ":", "\n", "        ", "\"\"\"Initialize the costs for CSC problem that corresponds to auditing. See paper for details.\n\n        Args:\n            :param self: object of class Auditor\n            :param n: size of the dataset\n\n        Return:\n            :return The costs for labeling a point 0, for labeling a point 1, as tuples.\n        \"\"\"", "\n", "costs_0", "=", "None", "\n", "costs_1", "=", "None", "\n", "if", "self", ".", "fairness_def", "==", "'FP'", ":", "\n", "            ", "costs_0", "=", "[", "0.0", "]", "*", "n", "\n", "costs_1", "=", "[", "-", "1.0", "/", "n", "*", "(", "2", "*", "i", "-", "1", ")", "for", "i", "in", "self", ".", "y_input", "]", "\n", "\n", "", "elif", "self", ".", "fairness_def", "==", "'FN'", ":", "\n", "            ", "costs_1", "=", "[", "0.0", "]", "*", "n", "\n", "costs_0", "=", "[", "1.0", "/", "n", "*", "(", "2", "*", "i", "-", "1", ")", "for", "i", "in", "self", ".", "y_input", "]", "\n", "", "return", "tuple", "(", "costs_0", ")", ",", "tuple", "(", "costs_1", ")", ",", "self", ".", "X_prime_0", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_baseline": [[106, 121], ["numpy.mean", "numpy.mean", "enumerate", "enumerate"], "methods", ["None"], ["", "def", "get_baseline", "(", "self", ",", "y", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"Return the baseline FP or FN rate of the classifier predictions.\n\n        Args:\n            :param y: true labels (binary)\n            :param predictions: predictions of classifier (soft predictions)\n\n        Returns:\n            :return: The baseline FP or FN rate of the classifier predictions\n        \"\"\"", "\n", "if", "self", ".", "fairness_def", "==", "'FP'", ":", "\n", "            ", "return", "np", ".", "mean", "(", "[", "predictions", "[", "i", "]", "for", "i", ",", "c", "in", "enumerate", "(", "y", ")", "if", "c", "==", "0", "]", ")", "\n", "", "elif", "self", ".", "fairness_def", "==", "'FN'", ":", "\n", "            ", "return", "np", ".", "mean", "(", "[", "(", "1", "-", "predictions", "[", "i", "]", ")", "for", "i", ",", "c", "in", "enumerate", "(", "y", ")", "\n", "if", "c", "==", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.update_costs": [[122, 171], ["list", "list", "len", "group.func.predict", "range", "numpy.sum", "tuple", "tuple", "float", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "", "def", "update_costs", "(", "self", ",", "c_0", ",", "c_1", ",", "group", ",", "C", ",", "iteration", ",", "gamma", ")", ":", "\n", "        ", "\"\"\"Recursively update the costs from incorrectly predicting 1 for the learner.\n\n        Args:\n            :param c_0: current costs for predicting 0\n            :param c_1: current costs for predicting 1\n            :param group: last group found by the auditor, object of class Group.\n            :param C: see Model class for details.\n            :param iteration: current iteration\n            :param gamma: target disparity\n\n        Returns:\n            :return c_0, c_1: tuples of new costs for CSC problem of learner\n        \"\"\"", "\n", "\n", "# make costs mutable type", "\n", "c_0", "=", "list", "(", "c_0", ")", "\n", "c_1", "=", "list", "(", "c_1", ")", "\n", "\n", "pos_neg", "=", "group", ".", "disparity_direction", "\n", "n", "=", "len", "(", "self", ".", "y", ")", "\n", "\n", "g_members", "=", "group", ".", "func", ".", "predict", "(", "self", ".", "X_prime_0", ")", "\n", "m", "=", "self", ".", "X_prime_0", ".", "shape", "[", "0", "]", "\n", "g_weight", "=", "np", ".", "sum", "(", "g_members", ")", "*", "(", "1.0", "/", "float", "(", "m", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "X_prime_0_index", "=", "0", "\n", "if", "self", ".", "y", "[", "i", "]", "==", "0", ":", "\n", "                ", "new_group_cost", "=", "(", "1.0", "/", "n", ")", "*", "pos_neg", "*", "C", "*", "(", "\n", "1.0", "/", "iteration", ")", "*", "(", "g_weight", "-", "g_members", "[", "X_prime_0_index", "]", ")", "\n", "if", "np", ".", "abs", "(", "group", ".", "weighted_disparity", ")", "<", "gamma", ":", "\n", "                    ", "new_group_cost", "=", "0", "\n", "\n", "", "if", "self", ".", "fairness_def", "==", "'FP'", ":", "\n", "                    ", "c_1", "[", "i", "]", "=", "(", "c_1", "[", "i", "]", "-", "1.0", "/", "n", ")", "*", "(", "\n", "(", "iteration", "-", "1.0", ")", "/", "\n", "iteration", ")", "+", "new_group_cost", "+", "1.0", "/", "n", "\n", "", "elif", "self", ".", "fairness_def", "==", "'FN'", ":", "\n", "                    ", "c_0", "[", "i", "]", "=", "(", "c_0", "[", "i", "]", "-", "1.0", "/", "n", ")", "*", "(", "\n", "(", "iteration", "-", "1.0", ")", "/", "\n", "iteration", ")", "+", "new_group_cost", "+", "1.0", "/", "n", "\n", "\n", "", "X_prime_0_index", "+=", "1", "\n", "", "else", ":", "\n", "                ", "if", "self", ".", "fairness_def", "==", "'FP'", ":", "\n", "                    ", "c_1", "[", "i", "]", "=", "-", "1.0", "/", "n", "\n", "", "elif", "self", ".", "fairness_def", "==", "'FN'", ":", "\n", "                    ", "c_0", "[", "i", "]", "=", "-", "1.0", "/", "n", "\n", "", "", "", "return", "tuple", "(", "c_0", ")", ",", "tuple", "(", "c_1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_subset": [[172, 190], ["enumerate", "enumerate"], "methods", ["None"], ["", "def", "get_subset", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"Returns subset of dataset with y = 0 for FP and labels, or subset with y = 0 with flipped labels\n        if the fairness_def is FN.\n\n        Args:\n            :param predictions: soft predictions of the classifier\n        Returns:\n            :return: X_prime_0: subset of features with y = 0\n            :return: labels: the labels on y = 0 if FP else 1-labels.\n        \"\"\"", "\n", "if", "self", ".", "fairness_def", "==", "'FP'", ":", "\n", "            ", "return", "self", ".", "X_prime_0", ",", "[", "\n", "a", "for", "u", ",", "a", "in", "enumerate", "(", "predictions", ")", "if", "self", ".", "y", "[", "u", "]", "==", "0", "\n", "]", "\n", "# handles FN rate by flipping labels", "\n", "", "elif", "self", ".", "fairness_def", "==", "'FN'", ":", "\n", "            ", "return", "self", ".", "X_prime_0", ",", "[", "(", "1", "-", "a", ")", "for", "u", ",", "a", "in", "enumerate", "(", "predictions", ")", "\n", "if", "self", ".", "y", "[", "u", "]", "==", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_group": [[191, 263], ["auditor.Auditor.get_subset", "len", "float", "sklearn.linear_model.LinearRegression", "sklearn.linear_model.LinearRegression.fit", "sklearn.linear_model.LinearRegression", "sklearn.linear_model.LinearRegression.fit", "aif360.algorithms.inprocessing.gerryfair.reg_oracle_class.RegOracle", "aif360.algorithms.inprocessing.gerryfair.reg_oracle_class.RegOracle.predict", "numpy.abs", "sklearn.linear_model.LinearRegression", "sklearn.linear_model.LinearRegression.fit", "sklearn.linear_model.LinearRegression", "sklearn.linear_model.LinearRegression.fit", "aif360.algorithms.inprocessing.gerryfair.reg_oracle_class.RegOracle", "aif360.algorithms.inprocessing.gerryfair.reg_oracle_class.RegOracle.predict", "numpy.abs", "len", "sum", "numpy.mean", "sum", "numpy.mean", "auditor.Group", "auditor.Group", "numpy.sum", "numpy.sum", "enumerate", "enumerate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_subset", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["", "", "def", "get_group", "(", "self", ",", "predictions", ",", "metric_baseline", ")", ":", "\n", "        ", "\"\"\"Given decisions on sensitive attributes, labels, and FP rate audit wrt\n            to gamma unfairness. Return the group found, the gamma unfairness, fp disparity, and sign(fp disparity).\n\n        Args:\n            :param predictions: soft predictions of the classifier\n            :param metric_baseline: see function get_baseline\n\n        Returns:\n            :return func: object of type RegOracle defining the group\n            :return g_size_0: the size of the group divided by n\n            :return fp_disp: |group_rate-baseline|\n            :return fp_disp_w: fp_disp*group_size_0\n            :return sgn(fp_disp): sgn(group_rate-baseline)\n            :return fp_group_rate_neg:\n        \"\"\"", "\n", "\n", "X_subset", ",", "predictions_subset", "=", "self", ".", "get_subset", "(", "predictions", ")", "\n", "\n", "m", "=", "len", "(", "predictions_subset", ")", "\n", "n", "=", "float", "(", "len", "(", "self", ".", "y", ")", ")", "\n", "\n", "cost_0", "=", "[", "0.0", "]", "*", "m", "\n", "cost_1", "=", "-", "1.0", "/", "n", "*", "(", "metric_baseline", "-", "predictions_subset", ")", "\n", "\n", "reg0", "=", "linear_model", ".", "LinearRegression", "(", ")", "\n", "reg0", ".", "fit", "(", "X_subset", ",", "cost_0", ")", "\n", "reg1", "=", "linear_model", ".", "LinearRegression", "(", ")", "\n", "reg1", ".", "fit", "(", "X_subset", ",", "cost_1", ")", "\n", "func", "=", "RegOracle", "(", "reg0", ",", "reg1", ")", "\n", "group_members_0", "=", "func", ".", "predict", "(", "X_subset", ")", "\n", "\n", "# get the false positive rate in group", "\n", "if", "sum", "(", "group_members_0", ")", "==", "0", ":", "\n", "            ", "fp_group_rate", "=", "0", "\n", "", "else", ":", "\n", "            ", "fp_group_rate", "=", "np", ".", "mean", "(", "[", "\n", "r", "for", "t", ",", "r", "in", "enumerate", "(", "predictions_subset", ")", "\n", "if", "group_members_0", "[", "t", "]", "==", "1", "\n", "]", ")", "\n", "", "g_size_0", "=", "np", ".", "sum", "(", "group_members_0", ")", "*", "1.0", "/", "n", "\n", "fp_disp", "=", "np", ".", "abs", "(", "fp_group_rate", "-", "metric_baseline", ")", "\n", "fp_disp_w", "=", "fp_disp", "*", "g_size_0", "\n", "\n", "cost_0_neg", "=", "[", "0.0", "]", "*", "m", "\n", "cost_1_neg", "=", "-", "1.0", "/", "n", "*", "(", "predictions_subset", "-", "metric_baseline", ")", "\n", "\n", "reg0_neg", "=", "linear_model", ".", "LinearRegression", "(", ")", "\n", "reg0_neg", ".", "fit", "(", "X_subset", ",", "cost_0_neg", ")", "\n", "reg1_neg", "=", "linear_model", ".", "LinearRegression", "(", ")", "\n", "reg1_neg", ".", "fit", "(", "X_subset", ",", "cost_1_neg", ")", "\n", "func_neg", "=", "RegOracle", "(", "reg0_neg", ",", "reg1_neg", ")", "\n", "group_members_0_neg", "=", "func_neg", ".", "predict", "(", "X_subset", ")", "\n", "\n", "if", "sum", "(", "group_members_0_neg", ")", "==", "0", ":", "\n", "            ", "fp_group_rate_neg", "=", "0", "\n", "", "else", ":", "\n", "            ", "fp_group_rate_neg", "=", "np", ".", "mean", "(", "[", "\n", "r", "for", "t", ",", "r", "in", "enumerate", "(", "predictions_subset", ")", "\n", "if", "group_members_0", "[", "t", "]", "==", "0", "\n", "]", ")", "\n", "", "g_size_0_neg", "=", "np", ".", "sum", "(", "group_members_0_neg", ")", "*", "1.0", "/", "n", "\n", "fp_disp_neg", "=", "np", ".", "abs", "(", "fp_group_rate_neg", "-", "metric_baseline", ")", "\n", "fp_disp_w_neg", "=", "fp_disp_neg", "*", "g_size_0_neg", "\n", "\n", "# return group", "\n", "if", "(", "fp_disp_w_neg", ">", "fp_disp_w", ")", ":", "\n", "            ", "return", "Group", "(", "func_neg", ",", "g_size_0_neg", ",", "fp_disp_w_neg", ",", "fp_disp_neg", ",", "\n", "-", "1", ",", "fp_group_rate", ")", "\n", "", "else", ":", "\n", "            ", "return", "Group", "(", "func", ",", "g_size_0", ",", "fp_disp_w", ",", "fp_disp", ",", "1", ",", "\n", "fp_group_rate_neg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.audit": [[264, 276], ["isinstance", "auditor.Auditor.get_baseline", "auditor.Auditor.get_group", "auditor.Auditor.func.predict"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_baseline", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_group", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["", "", "def", "audit", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"Takes in predictions on dataset (X',y) and returns:\n            a membership vector which represents the group that violates the fairness metric,\n            along with the gamma disparity.\n        \"\"\"", "\n", "if", "isinstance", "(", "predictions", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "predictions", "=", "predictions", ".", "values", "\n", "\n", "", "metric_baseline", "=", "self", ".", "get_baseline", "(", "self", ".", "y_input", ",", "predictions", ")", "\n", "group", "=", "self", ".", "get_group", "(", "predictions", ",", "metric_baseline", ")", "\n", "\n", "return", "group", ".", "func", ".", "predict", "(", "self", ".", "X_prime", ")", ",", "group", ".", "weighted_disparity", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.classifier_history.ClassifierHistory.__init__": [[15, 19], ["object.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "ClassifierHistory", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "classifiers", "=", "[", "]", "\n", "self", ".", "predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.classifier_history.ClassifierHistory.append_classifier": [[20, 22], ["classifier_history.ClassifierHistory.classifiers.append"], "methods", ["None"], ["", "def", "append_classifier", "(", "self", ",", "classifier", ")", ":", "\n", "        ", "self", ".", "classifiers", ".", "append", "(", "classifier", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.classifier_history.ClassifierHistory.get_most_recent": [[23, 25], ["None"], "methods", ["None"], ["", "def", "get_most_recent", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "classifiers", "[", "-", "1", "]", "", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.RegOracle.__init__": [[16, 19], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "b0", ",", "b1", ")", ":", "\n", "        ", "self", ".", "b0", "=", "b0", "\n", "self", ".", "b1", "=", "b1", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.RegOracle.predict": [[20, 26], ["reg_oracle_class.RegOracle.b0.predict", "reg_oracle_class.RegOracle.b1.predict"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Predict labels on data set X.\"\"\"", "\n", "c_0", "=", "self", ".", "b0", ".", "predict", "(", "X", ")", "\n", "c_1", "=", "self", ".", "b1", ".", "predict", "(", "X", ")", "\n", "y", "=", "(", "c_1", "<", "c_0", ")", ".", "astype", "(", "'int'", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.RandomLinearThresh.__init__": [[30, 32], ["numpy.random.uniform", "range"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["def", "__init__", "(", "self", ",", "d", ")", ":", "\n", "        ", "self", ".", "coefficient", "=", "[", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ")", "for", "_", "in", "range", "(", "d", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.RandomLinearThresh.predict": [[33, 44], ["range", "numpy.dot", "int", "y.append"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Predict labels on data set X.\"\"\"", "\n", "beta", "=", "self", ".", "coefficient", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "y", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "x_i", "=", "X", ".", "iloc", "[", "i", ",", ":", "]", "\n", "c_1", "=", "np", ".", "dot", "(", "beta", ",", "x_i", ")", "\n", "y_i", "=", "int", "(", "c_1", "<", "0", ")", "\n", "y", ".", "append", "(", "y_i", ")", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.__init__": [[48, 50], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "d", ")", ":", "\n", "        ", "self", ".", "coefficient", "=", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict": [[51, 62], ["range", "numpy.dot", "int", "y.append"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Predict labels on data set X.\"\"\"", "\n", "beta", "=", "self", ".", "coefficient", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "y", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "x_i", "=", "X", ".", "iloc", "[", "i", ",", ":", "]", "\n", "c_1", "=", "np", ".", "dot", "(", "beta", ",", "x_i", ")", "\n", "y_i", "=", "int", "(", "c_1", "<", "0", ")", "\n", "y", ".", "append", "(", "y_i", ")", "\n", "", "return", "y", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.fairness_plots.plot_single": [[15, 46], ["range", "matplotlib.pyplot.figure", "plt.figure.add_subplot", "fig1.add_subplot.plot", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.title", "matplotlib.pyplot.show", "range", "matplotlib.pyplot.figure", "plt.figure.add_subplot", "fig2.add_subplot.plot", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.title", "fig2.add_subplot.plot", "matplotlib.pyplot.show", "len"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["def", "plot_single", "(", "errors_t", ",", "fp_diff_t", ",", "max_iters", ",", "gamma", ",", "C", ")", ":", "\n", "    ", "\"\"\"Plot the errors and false positive rate disparity over time.\n\n    :param errors_t: list of errors at each iteration\n    :param fp_diff_t: list of fp rate disparity at each iteration\n    :param max_iters: time horizon T of the algorithm\n    :param gamma: input gamma disparity\n    :param C: input C parameter - see gerryfair_classifier.py\n    \"\"\"", "\n", "# plot errors", "\n", "x", "=", "range", "(", "max_iters", "-", "1", ")", "\n", "y_t", "=", "errors_t", "\n", "fig1", "=", "plt", ".", "figure", "(", ")", "\n", "ax1", "=", "fig1", ".", "add_subplot", "(", "111", ")", "\n", "ax1", ".", "plot", "(", "x", ",", "y_t", ")", "\n", "plt", ".", "ylabel", "(", "'average error of mixture'", ")", "\n", "plt", ".", "xlabel", "(", "'iterations'", ")", "\n", "plt", ".", "title", "(", "'error vs. time: C: {}, gamma: {}'", ".", "format", "(", "C", ",", "gamma", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "# plot fp disparity", "\n", "x", "=", "range", "(", "max_iters", "-", "1", ")", "\n", "y_t", "=", "fp_diff_t", "\n", "fig2", "=", "plt", ".", "figure", "(", ")", "\n", "ax2", "=", "fig2", ".", "add_subplot", "(", "111", ")", "\n", "ax2", ".", "plot", "(", "x", ",", "y_t", ")", "\n", "plt", ".", "ylabel", "(", "'fp_diff*group_size'", ")", "\n", "plt", ".", "xlabel", "(", "'iterations'", ")", "\n", "plt", ".", "title", "(", "'fp_diff*size vs. time: C: {}, gamma: {}'", ".", "format", "(", "C", ",", "gamma", ")", ")", "\n", "ax2", ".", "plot", "(", "x", ",", "[", "gamma", "]", "*", "len", "(", "y_t", ")", ")", "\n", "plt", ".", "show", "(", ")", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.learner.Learner.__init__": [[20, 30], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "X", ",", "y", ",", "predictor", ")", ":", "\n", "        ", "\"\"\"Constructor the class\n\n        :param X: pandas dataframe of attributes\n        :param y: tuple of predictions\n        :param predictor: regressor with sklearn api (e.g. fit(), predict() methods). ex: LinearRegression()\n        \"\"\"", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "predictor", "=", "predictor", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.learner.Learner.best_response": [[31, 47], ["copy.deepcopy", "copy.deepcopy.fit", "copy.deepcopy", "copy.deepcopy.fit", "aif360.algorithms.inprocessing.gerryfair.reg_oracle_class.RegOracle"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "best_response", "(", "self", ",", "costs_0", ",", "costs_1", ")", ":", "\n", "        ", "\"\"\"Return a RegOracle solving a CSC problem.\n\n        Args:\n            :param costs_0: costs for labeling points 0 in the CSC problem of the learner\n            :param costs_1: costs for labeling points 1 in the CSC problem of the learner\n\n        Returns:\n            :return: object of class RegOracle solving the CSC problem\n        \"\"\"", "\n", "reg0", "=", "copy", ".", "deepcopy", "(", "self", ".", "predictor", ")", "\n", "reg0", ".", "fit", "(", "self", ".", "X", ",", "costs_0", ")", "\n", "reg1", "=", "copy", ".", "deepcopy", "(", "self", ".", "predictor", ")", "\n", "reg1", ".", "fit", "(", "self", ".", "X", ",", "costs_1", ")", "\n", "func", "=", "RegOracle", "(", "reg0", ",", "reg1", ")", "\n", "return", "func", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.learner.Learner.generate_predictions": [[48, 67], ["numpy.multiply", "numpy.multiply", "numpy.mean", "tuple", "q.predict", "numpy.abs", "range", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "generate_predictions", "(", "self", ",", "q", ",", "predictions", ",", "iteration", ")", ":", "\n", "        ", "\"\"\"Return the classifications of the average classifier at time iter.\n\n        Args:\n            :param q: the most recent classifier found\n            :param predictions: the previous set of decisions (probabilities) up to time iter - 1\n            :param iteration: the number of the current iteration\n\n        Returns:\n            :return error: the error of the average classifier found thus far (incorporating q)\n        \"\"\"", "\n", "\n", "new_predictions", "=", "np", ".", "multiply", "(", "1.0", "/", "iteration", ",", "q", ".", "predict", "(", "self", ".", "X", ")", ")", "\n", "ds", "=", "np", ".", "multiply", "(", "(", "iteration", "-", "1.0", ")", "/", "iteration", ",", "predictions", ")", "\n", "ds", "+=", "new_predictions", "\n", "error", "=", "np", ".", "mean", "(", "\n", "[", "np", ".", "abs", "(", "ds", "[", "k", "]", "-", "self", ".", "y", "[", "k", "]", ")", "for", "k", "in", "range", "(", "len", "(", "self", ".", "y", ")", ")", "]", ")", "\n", "ds", "=", "tuple", "(", "ds", ")", "\n", "return", "error", ",", "ds", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.heatmap.calc_disp": [[27, 55], ["pandas.DataFrame", "group.predict", "len", "np.mean", "group.predict", "np.mean", "len", "np.sum", "enumerate", "enumerate", "enumerate"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["def", "calc_disp", "(", "predictions", ",", "X", ",", "group_labels", ",", "X_prime", ",", "group", ")", ":", "\n", "    ", "\"\"\"Return the fp disparity in a group g - helper function for heat_map.\n\n    Args:\n        :param predictions: dataframe of predictions of the classifier\n        :param X: dataframe of covariates\n        :param group_labels: dataframe of group labels\n        :param X_prime: sensitive covariates\n        :param group: object of class Group(), see auditor.py\n    Returns:\n        :return: weighted disparity on the group g\n    \"\"\"", "\n", "X_0", "=", "pd", ".", "DataFrame", "(", "\n", "[", "X_prime", ".", "iloc", "[", "u", ",", ":", "]", "for", "u", ",", "s", "in", "enumerate", "(", "group_labels", ")", "if", "s", "==", "0", "]", ")", "\n", "group_0", "=", "group", ".", "predict", "(", "X_0", ")", "\n", "n", "=", "len", "(", "group_labels", ")", "\n", "g_size_0", "=", "np", ".", "sum", "(", "group_0", ")", "*", "1.0", "/", "n", "\n", "FP", "=", "[", "predictions", "[", "i", "]", "for", "i", ",", "c", "in", "enumerate", "(", "group_labels", ")", "if", "c", "==", "0", "]", "\n", "FP", "=", "np", ".", "mean", "(", "FP", ")", "\n", "group_members", "=", "group", ".", "predict", "(", "X_prime", ")", "\n", "fp_g", "=", "[", "\n", "predictions", "[", "i", "]", "for", "i", ",", "c", "in", "enumerate", "(", "group_labels", ")", "\n", "if", "group_members", "[", "i", "]", "==", "1", "and", "c", "==", "0", "\n", "]", "\n", "if", "len", "(", "fp_g", ")", "==", "0", ":", "\n", "        ", "return", "0", "\n", "", "fp_g", "=", "np", ".", "mean", "(", "fp_g", ")", "\n", "return", "(", "FP", "-", "fp_g", ")", "*", "g_size_0", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.heatmap.heat_map": [[57, 102], ["matplotlib.figure", "plt.figure.add_subplot", "np.zeros", "np.zeros", "np.zeros", "range", "np.meshgrid", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.set_zlabel", "fig.add_subplot.set_zlim3d", "fig.add_subplot.plot_surface", "str", "int", "int", "int", "range", "plt.figure.savefig", "matplotlib.close", "np.min", "np.max", "int", "int", "int", "LinearThresh", "heatmap.calc_disp", "np.min", "np.max"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.heatmap.calc_disp"], ["", "def", "heat_map", "(", "X", ",", "X_prime", ",", "y", ",", "predictions", ",", "eta", ",", "plot_path", ",", "vmin", "=", "None", ",", "vmax", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generate 3-d heatmap and save it at plot_path.\n    Args:\n        :param eta: discretization parameter of coefficients defining subgroups\n        :param plot_path: the path to save the heatmap at\n        :param vmin: Min  value to map: see plot_surface documentation in matplotlib\n        :param vmax: Max value to map\n\n    Returns:\n        :return: the min and max gamma disparities on groups in the plot\n    \"\"\"", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "1", ",", "1", ",", "1", ",", "projection", "=", "'3d'", ")", "\n", "columns", "=", "[", "str", "(", "c", ")", "for", "c", "in", "X_prime", ".", "columns", "]", "\n", "attribute_1", "=", "np", ".", "zeros", "(", "int", "(", "1", "/", "eta", ")", ")", "\n", "attribute_2", "=", "np", ".", "zeros", "(", "int", "(", "1", "/", "eta", ")", ")", "\n", "disparity", "=", "np", ".", "zeros", "(", "(", "int", "(", "1", "/", "eta", ")", ",", "int", "(", "1", "/", "eta", ")", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "int", "(", "1", "/", "eta", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "int", "(", "1", "/", "eta", ")", ")", ":", "\n", "            ", "beta", "=", "[", "-", "1", "+", "2", "*", "eta", "*", "i", ",", "-", "1", "+", "2", "*", "eta", "*", "j", "]", "\n", "group", "=", "LinearThresh", "(", "beta", ")", "\n", "\n", "attribute_1", "[", "i", "]", "=", "beta", "[", "0", "]", "\n", "attribute_2", "[", "j", "]", "=", "beta", "[", "1", "]", "\n", "disparity", "[", "i", ",", "j", "]", "=", "calc_disp", "(", "predictions", ",", "X", ",", "y", ",", "X_prime", ",", "group", ")", "\n", "\n", "", "", "X_plot", ",", "Y_plot", "=", "np", ".", "meshgrid", "(", "attribute_1", ",", "attribute_2", ")", "\n", "\n", "ax", ".", "set_xlabel", "(", "columns", "[", "0", "]", "+", "' coefficient'", ")", "\n", "ax", ".", "set_ylabel", "(", "columns", "[", "1", "]", "+", "' coefficient'", ")", "\n", "ax", ".", "set_zlabel", "(", "'gamma disparity'", ")", "\n", "ax", ".", "set_zlim3d", "(", "[", "np", ".", "min", "(", "disparity", ")", ",", "np", ".", "max", "(", "disparity", ")", "]", ")", "\n", "surface", "=", "ax", ".", "plot_surface", "(", "X_plot", ",", "\n", "Y_plot", ",", "\n", "disparity", ",", "\n", "cmap", "=", "cm", ".", "coolwarm", ",", "\n", "linewidth", "=", "0", ",", "\n", "antialiased", "=", "False", ",", "\n", "vmin", "=", "vmin", ",", "\n", "vmax", "=", "vmax", ")", "\n", "if", "plot_path", "!=", "'.'", ":", "\n", "        ", "fig", ".", "savefig", "(", "'{}.png'", ".", "format", "(", "plot_path", ")", ")", "\n", "plt", ".", "close", "(", ")", "\n", "", "return", "[", "np", ".", "min", "(", "disparity", ")", ",", "np", ".", "max", "(", "disparity", ")", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.setup": [[17, 44], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "setup", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Fairness Data Cleaning'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'-n'", ",", "\n", "'--name'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'name of the to store the new datasets (Required)'", ")", "\n", "parser", ".", "add_argument", "(", "'-d'", ",", "\n", "'--dataset'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'name of the original dataset file (Required)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'-a'", ",", "\n", "'--attributes'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "\n", "'name of the file representing which attributes are protected (unprotected = 0, protected = 1, label = 2) (Required)'", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'-c'", ",", "\n", "'--centered'", ",", "\n", "default", "=", "False", ",", "\n", "action", "=", "'store_true'", ",", "\n", "required", "=", "False", ",", "\n", "help", "=", "'Include this flag to determine whether data should be centered'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "[", "args", ".", "name", ",", "args", ".", "dataset", ",", "args", ".", "attributes", ",", "args", ".", "centered", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.clean_dataset": [[46, 90], ["pandas.read_csv", "pandas.read_csv", "print", "print", "clean.one_hot_code", "print", "str", "len", "ValueError", "len", "ValueError", "str", "clean.center", "clean.center", "sens_dict.keys", "len"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.one_hot_code", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.center", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.center"], ["", "def", "clean_dataset", "(", "dataset", ",", "attributes", ",", "centered", ")", ":", "\n", "    ", "\"\"\"Clean a dataset, given the filename for the dataset and the filename for the attributes.\n\n    Args:\n        :param dataset: Filename for dataset. The dataset should be formatted such that categorical\n        variables use one-hot encoding\n    and the label should be 0/1\n        :param attributes: Filename for the attributes of the dataset. The file should have each column name in a list,\n         and under this list should have 0 for an unprotected attribute, 1 for a protected attribute, and 2 for the\n          attribute of the label.\n        :param centered: boolean flag that determines whether to center the input covariates.\n        :return X, X_prime, y: pandas dataframes of attributes, sensitive attributes, labels\n    \"\"\"", "\n", "\n", "df", "=", "pd", ".", "read_csv", "(", "dataset", ")", "\n", "sens_df", "=", "pd", ".", "read_csv", "(", "attributes", ")", "\n", "\n", "## Get and remove label Y", "\n", "y_col", "=", "[", "str", "(", "c", ")", "for", "c", "in", "sens_df", ".", "columns", "if", "sens_df", "[", "c", "]", "[", "0", "]", "==", "2", "]", "\n", "print", "(", "'label feature: {}'", ".", "format", "(", "y_col", ")", ")", "\n", "if", "(", "len", "(", "y_col", ")", ">", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'More than 1 label column used'", ")", "\n", "", "if", "(", "len", "(", "y_col", ")", "<", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'No label column used'", ")", "\n", "\n", "", "y", "=", "df", "[", "y_col", "[", "0", "]", "]", "\n", "\n", "## Do not use labels in rest of data", "\n", "X", "=", "df", ".", "loc", "[", ":", ",", "df", ".", "columns", "!=", "y_col", "[", "0", "]", "]", "\n", "X", "=", "X", ".", "loc", "[", ":", ",", "X", ".", "columns", "!=", "'Unnamed: 0'", "]", "\n", "## Create X_prime, by getting protected attributes", "\n", "sens_cols", "=", "[", "str", "(", "c", ")", "for", "c", "in", "sens_df", ".", "columns", "if", "sens_df", "[", "c", "]", "[", "0", "]", "==", "1", "]", "\n", "print", "(", "'sensitive features: {}'", ".", "format", "(", "sens_cols", ")", ")", "\n", "sens_dict", "=", "{", "c", ":", "1", "if", "c", "in", "sens_cols", "else", "0", "for", "c", "in", "df", ".", "columns", "}", "\n", "X", ",", "sens_dict", "=", "one_hot_code", "(", "X", ",", "sens_dict", ")", "\n", "sens_names", "=", "[", "key", "for", "key", "in", "sens_dict", ".", "keys", "(", ")", "if", "sens_dict", "[", "key", "]", "==", "1", "]", "\n", "print", "(", "\n", "'there are {} sensitive features including derivative features'", ".", "format", "(", "\n", "len", "(", "sens_names", ")", ")", ")", "\n", "X_prime", "=", "X", "[", "sens_names", "]", "\n", "if", "centered", ":", "\n", "        ", "X", "=", "center", "(", "X", ")", "\n", "X_prime", "=", "center", "(", "X_prime", ")", "\n", "", "return", "X", ",", "X_prime", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.center": [[92, 96], ["numpy.mean"], "function", ["None"], ["", "def", "center", "(", "X", ")", ":", "\n", "    ", "for", "col", "in", "X", ".", "columns", ":", "\n", "        ", "X", ".", "loc", "[", ":", ",", "col", "]", "=", "X", ".", "loc", "[", ":", ",", "col", "]", "-", "np", ".", "mean", "(", "X", ".", "loc", "[", ":", ",", "col", "]", ")", "\n", "", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.array_to_tuple": [[98, 102], ["tuple"], "function", ["None"], ["", "def", "array_to_tuple", "(", "x", ")", ":", "\n", "# have to cast ndarray to hashable type in get_baseline()", "\n", "    ", "x", "=", "tuple", "(", "[", "el", "[", "0", "]", "for", "el", "in", "x", "]", ")", "if", "x", ".", "__class__", ".", "__name__", "==", "'ndarray'", "else", "x", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.one_hot_code": [[104, 126], ["isinstance", "df1.drop.drop", "list", "len", "set", "range"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "one_hot_code", "(", "df1", ",", "sens_dict", ")", ":", "\n", "    ", "cols", "=", "df1", ".", "columns", "\n", "for", "c", "in", "cols", ":", "\n", "        ", "if", "isinstance", "(", "df1", "[", "c", "]", "[", "0", "]", ",", "str", ")", ":", "\n", "            ", "column", "=", "df1", "[", "c", "]", "\n", "df1", "=", "df1", ".", "drop", "(", "c", ",", "1", ")", "\n", "unique_values", "=", "list", "(", "set", "(", "column", ")", ")", "\n", "n", "=", "len", "(", "unique_values", ")", "\n", "if", "n", ">", "2", ":", "\n", "                ", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "                    ", "col_name", "=", "'{}.{}'", ".", "format", "(", "c", ",", "i", ")", "\n", "col_i", "=", "[", "\n", "1", "if", "el", "==", "unique_values", "[", "i", "]", "else", "0", "for", "el", "in", "column", "\n", "]", "\n", "df1", "[", "col_name", "]", "=", "col_i", "\n", "sens_dict", "[", "col_name", "]", "=", "sens_dict", "[", "c", "]", "\n", "", "del", "sens_dict", "[", "c", "]", "\n", "", "else", ":", "\n", "                ", "col_name", "=", "c", "\n", "col", "=", "[", "1", "if", "el", "==", "unique_values", "[", "0", "]", "else", "0", "for", "el", "in", "column", "]", "\n", "df1", "[", "col_name", "]", "=", "col", "\n", "", "", "", "return", "df1", ",", "sens_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.extract_df_from_ds": [[128, 145], ["pandas.DataFrame", "X.drop.drop", "tuple", "dataset.convert_to_dataframe"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.convert_to_dataframe"], ["", "def", "extract_df_from_ds", "(", "dataset", ")", ":", "\n", "    ", "\"\"\"Extract data frames from Transformer Data set\n\n    Args:\n         :param dataset: aif360 dataset\n\n    Returns:\n         :return X, X_prime, y: pandas dataframes of attributes, sensitive attributes, labels\n    \"\"\"", "\n", "\n", "X", "=", "pd", ".", "DataFrame", "(", "dataset", ".", "convert_to_dataframe", "(", ")", "[", "0", "]", ")", "\n", "# remove labels", "\n", "X", "=", "X", ".", "drop", "(", "columns", "=", "dataset", ".", "label_names", ")", "\n", "# get sensitive attributes", "\n", "X_prime", "=", "X", "[", "dataset", ".", "protected_attribute_names", "]", "\n", "y", "=", "tuple", "(", "dataset", ".", "labels", "[", ":", ",", "0", "]", ")", "\n", "return", "X", ",", "X_prime", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.get_data": [[147, 159], ["pandas.read_csv", "pandas.read_csv", "pandas.read_csv"], "function", ["None"], ["", "def", "get_data", "(", "dataset", ")", ":", "\n", "# Helper for main method", "\n", "    ", "\"\"\"Given name of dataset, load in the three datasets associated from the clean.py file\n    :param dataset:\n    :return:\n    \"\"\"", "\n", "X", "=", "pd", ".", "read_csv", "(", "'dataset/'", "+", "dataset", "+", "'_features.csv'", ")", "\n", "X_prime", "=", "pd", ".", "read_csv", "(", "'dataset/'", "+", "dataset", "+", "'_protectedfeatures.csv'", ")", "\n", "y", "=", "pd", ".", "read_csv", "(", "'dataset/'", "+", "dataset", "+", "'_labels.csv'", ",", "\n", "names", "=", "[", "'index'", ",", "'label'", "]", ")", "\n", "y", "=", "y", "[", "'label'", "]", "\n", "return", "X", ",", "X_prime", ",", "y", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_inputs": [[8, 43], ["sklearn.utils.check_consistent_length", "ValueError", "isinstance", "sklearn.utils.validation.column_or_1d", "sklearn.utils.validation.column_or_1d", "numpy.ones"], "function", ["None"], ["def", "check_inputs", "(", "X", ",", "y", ",", "sample_weight", "=", "None", ",", "ensure_2d", "=", "True", ")", ":", "\n", "    ", "\"\"\"Input validation for debiasing algorithms.\n\n    Checks all inputs for consistent length, validates shapes (optional for X),\n    and returns an array of all ones if sample_weight is ``None``.\n\n    Args:\n        X (array-like): Input data.\n        y (array-like, shape = (n_samples,)): Target values.\n        sample_weight (array-like, optional): Sample weights.\n        ensure_2d (bool, optional): Whether to raise a ValueError if X is not\n            2D.\n\n    Returns:\n        tuple:\n\n            * **X** (`array-like`) -- Validated X. Unchanged.\n\n            * **y** (`array-like`) -- Validated y. Possibly converted to 1D if\n              not a :class:`pandas.Series`.\n            * **sample_weight** (`array-like`) -- Validated sample_weight. If no\n              sample_weight is provided, returns a consistent-length array of\n              ones.\n    \"\"\"", "\n", "if", "ensure_2d", "and", "X", ".", "ndim", "!=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Expected X to be 2D, got ndim == {} instead.\"", ".", "format", "(", "\n", "X", ".", "ndim", ")", ")", "\n", "", "if", "not", "isinstance", "(", "y", ",", "pd", ".", "Series", ")", ":", "# don't cast Series -> ndarray", "\n", "        ", "y", "=", "column_or_1d", "(", "y", ")", "\n", "", "if", "sample_weight", "is", "not", "None", ":", "\n", "        ", "sample_weight", "=", "column_or_1d", "(", "sample_weight", ")", "\n", "", "else", ":", "\n", "        ", "sample_weight", "=", "np", ".", "ones", "(", "X", ".", "shape", "[", "0", "]", ")", "\n", "", "check_consistent_length", "(", "X", ",", "y", ",", "sample_weight", ")", "\n", "return", "X", ",", "y", ",", "sample_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups": [[44, 94], ["any", "arr.index.droplevel", "groups.to_flat_index.to_flat_index", "groups.to_flat_index.nunique", "hasattr", "TypeError", "ValueError", "list", "ValueError", "pandas.core.dtypes.common.is_list_like", "set", "set", "type", "groups.to_flat_index.unique"], "function", ["None"], ["", "def", "check_groups", "(", "arr", ",", "prot_attr", ",", "ensure_binary", "=", "False", ")", ":", "\n", "    ", "\"\"\"Get groups from the index of arr.\n\n    If there are multiple protected attributes provided, the index is flattened\n    to be a 1-D Index of tuples. If ensure_binary is ``True``, raises a\n    ValueError if there are not exactly two unique groups. Also checks that all\n    provided protected attributes are in the index.\n\n    Args:\n        arr (:class:`pandas.Series` or :class:`pandas.DataFrame`): A Pandas\n            object containing protected attribute information in the index.\n        prot_attr (single label or list-like): Protected attribute(s). If\n            ``None``, all protected attributes in arr are used.\n        ensure_binary (bool): Raise an error if the resultant groups are not\n            binary.\n\n    Returns:\n        tuple:\n\n            * **groups** (:class:`pandas.Index`) -- Label (or tuple of labels)\n              of protected attribute for each sample in arr.\n            * **prot_attr** (`list-like`) -- Modified input. If input is a\n              single label, returns single-item list. If input is ``None``\n              returns list of all protected attributes.\n    \"\"\"", "\n", "if", "not", "hasattr", "(", "arr", ",", "'index'", ")", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "\"Expected `Series` or `DataFrame`, got {} instead.\"", ".", "format", "(", "\n", "type", "(", "arr", ")", ".", "__name__", ")", ")", "\n", "\n", "", "all_prot_attrs", "=", "[", "name", "for", "name", "in", "arr", ".", "index", ".", "names", "if", "name", "]", "# not None or ''", "\n", "if", "prot_attr", "is", "None", ":", "\n", "        ", "prot_attr", "=", "all_prot_attrs", "\n", "", "elif", "not", "is_list_like", "(", "prot_attr", ")", ":", "\n", "        ", "prot_attr", "=", "[", "prot_attr", "]", "\n", "\n", "", "if", "any", "(", "p", "not", "in", "arr", ".", "index", ".", "names", "for", "p", "in", "prot_attr", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Some of the attributes provided are not present \"", "\n", "\"in the dataset. Expected a subset of:\\n{}\\nGot:\\n\"", "\n", "\"{}\"", ".", "format", "(", "all_prot_attrs", ",", "prot_attr", ")", ")", "\n", "\n", "", "groups", "=", "arr", ".", "index", ".", "droplevel", "(", "list", "(", "set", "(", "arr", ".", "index", ".", "names", ")", "-", "set", "(", "prot_attr", ")", ")", ")", "\n", "groups", "=", "groups", ".", "to_flat_index", "(", ")", "\n", "\n", "n_unique", "=", "groups", ".", "nunique", "(", ")", "\n", "if", "ensure_binary", "and", "n_unique", "!=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Expected 2 protected attribute groups, got {}\"", ".", "format", "(", "\n", "groups", ".", "unique", "(", ")", "if", "n_unique", ">", "5", "else", "n_unique", ")", ")", "\n", "\n", "", "return", "groups", ",", "prot_attr", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_adversarial_debiasing.test_adv_debias_old_reproduce": [[11, 30], ["tensorflow.Session", "aif360.algorithms.inprocessing.AdversarialDebiasing", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit_predict", "tf.Session.close", "tensorflow.reset_default_graph", "tensorflow.Session", "aif360.algorithms.inprocessing.AdversarialDebiasing", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit_predict", "tf.Session.close", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier.fit_predict", "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier.fit_predict"], ["def", "test_adv_debias_old_reproduce", "(", "old_adult", ")", ":", "\n", "    ", "\"\"\"Test that the old AdversarialDebiasing is reproducible.\"\"\"", "\n", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "old_adv_deb", "=", "OldAdversarialDebiasing", "(", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ",", "\n", "scope_name", "=", "'old_classifier'", ",", "\n", "sess", "=", "sess", ",", "num_epochs", "=", "5", ",", "seed", "=", "123", ")", "\n", "old_preds", "=", "old_adv_deb", ".", "fit_predict", "(", "old_adult", ")", "\n", "sess", ".", "close", "(", ")", "\n", "tf", ".", "reset_default_graph", "(", ")", "\n", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "old_adv_deb2", "=", "OldAdversarialDebiasing", "(", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ",", "\n", "scope_name", "=", "'old_classifier'", ",", "\n", "sess", "=", "sess", ",", "num_epochs", "=", "5", ",", "seed", "=", "123", ")", "\n", "old_preds2", "=", "old_adv_deb2", ".", "fit_predict", "(", "old_adult", ")", "\n", "sess", ".", "close", "(", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "old_preds", ".", "labels", ",", "old_preds2", ".", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_adversarial_debiasing.test_adv_debias_old": [[31, 47], ["tensorflow.reset_default_graph", "tensorflow.Session", "aif360.algorithms.inprocessing.AdversarialDebiasing", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit_predict", "tf.Session.close", "aif360.algorithms.inprocessing.AdversarialDebiasing", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit().predict", "aif360.algorithms.inprocessing.AdversarialDebiasing.sess_.close", "numpy.allclose", "old_adv_deb.fit_predict.labels.flatten", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier.fit_predict", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "test_adv_debias_old", "(", "old_adult", ",", "new_adult", ")", ":", "\n", "    ", "\"\"\"Test that the predictions of the old and new AdversarialDebiasing match.\n    \"\"\"", "\n", "X", ",", "y", ",", "_", "=", "new_adult", "\n", "tf", ".", "reset_default_graph", "(", ")", "\n", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "old_adv_deb", "=", "OldAdversarialDebiasing", "(", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ",", "\n", "scope_name", "=", "'old_classifier'", ",", "\n", "sess", "=", "sess", ",", "num_epochs", "=", "5", ",", "seed", "=", "123", ")", "\n", "old_preds", "=", "old_adv_deb", ".", "fit_predict", "(", "old_adult", ")", "\n", "sess", ".", "close", "(", ")", "\n", "adv_deb", "=", "AdversarialDebiasing", "(", "'sex'", ",", "num_epochs", "=", "5", ",", "random_state", "=", "123", ")", "\n", "new_preds", "=", "adv_deb", ".", "fit", "(", "X", ",", "y", ")", ".", "predict", "(", "X", ")", "\n", "adv_deb", ".", "sess_", ".", "close", "(", ")", "\n", "assert", "np", ".", "allclose", "(", "old_preds", ".", "labels", ".", "flatten", "(", ")", ",", "new_preds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_adversarial_debiasing.test_adv_debias_reproduce": [[48, 61], ["aif360.algorithms.inprocessing.AdversarialDebiasing", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit().predict", "aif360.algorithms.inprocessing.AdversarialDebiasing.sess_.close", "sklearn.metrics.accuracy_score", "aif360.algorithms.inprocessing.AdversarialDebiasing", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit().predict", "aif360.algorithms.inprocessing.AdversarialDebiasing.sess_.close", "sklearn.metrics.accuracy_score", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "test_adv_debias_reproduce", "(", "new_adult", ")", ":", "\n", "    ", "\"\"\"Test that the new AdversarialDebiasing is reproducible.\"\"\"", "\n", "X", ",", "y", ",", "_", "=", "new_adult", "\n", "adv_deb", "=", "AdversarialDebiasing", "(", "'sex'", ",", "num_epochs", "=", "5", ",", "random_state", "=", "123", ")", "\n", "new_preds", "=", "adv_deb", ".", "fit", "(", "X", ",", "y", ")", ".", "predict", "(", "X", ")", "\n", "adv_deb", ".", "sess_", ".", "close", "(", ")", "\n", "new_acc", "=", "accuracy_score", "(", "y", ",", "new_preds", ")", "\n", "\n", "adv_deb2", "=", "AdversarialDebiasing", "(", "'sex'", ",", "num_epochs", "=", "5", ",", "random_state", "=", "123", ")", "\n", "new_preds", "=", "adv_deb2", ".", "fit", "(", "X", ",", "y", ")", ".", "predict", "(", "X", ")", "\n", "adv_deb", ".", "sess_", ".", "close", "(", ")", "\n", "\n", "assert", "new_acc", "==", "accuracy_score", "(", "y", ",", "new_preds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_adversarial_debiasing.test_adv_debias_intersection": [[62, 69], ["aif360.algorithms.inprocessing.AdversarialDebiasing", "aif360.algorithms.inprocessing.AdversarialDebiasing.fit", "aif360.algorithms.inprocessing.AdversarialDebiasing.sess_.close"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "test_adv_debias_intersection", "(", "new_adult", ")", ":", "\n", "    ", "\"\"\"Test that the new AdversarialDebiasing runs with >2 protected groups.\"\"\"", "\n", "X", ",", "y", ",", "_", "=", "new_adult", "\n", "adv_deb", "=", "AdversarialDebiasing", "(", "scope_name", "=", "'intersect'", ",", "num_epochs", "=", "5", ")", "\n", "adv_deb", ".", "fit", "(", "X", ",", "y", ")", "\n", "adv_deb", ".", "sess_", ".", "close", "(", ")", "\n", "assert", "adv_deb", ".", "adversary_logits_", ".", "shape", "[", "1", "]", "==", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_adversarial_debiasing.test_adv_debias_grid": [[70, 84], ["aif360.algorithms.inprocessing.AdversarialDebiasing", "sklearn.model_selection.GridSearchCV", "sklearn.model_selection.GridSearchCV.fit", "sklearn.model_selection.GridSearchCV.best_estimator_.sess_.close"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "test_adv_debias_grid", "(", "new_adult", ")", ":", "\n", "    ", "\"\"\"Test that the new AdversarialDebiasing works in a grid search (and that\n    debiasing results in reduced accuracy).\n    \"\"\"", "\n", "X", ",", "y", ",", "_", "=", "new_adult", "\n", "adv_deb", "=", "AdversarialDebiasing", "(", "'sex'", ",", "num_epochs", "=", "10", ",", "random_state", "=", "123", ")", "\n", "\n", "params", "=", "{", "'debias'", ":", "[", "True", ",", "False", "]", "}", "\n", "\n", "clf", "=", "GridSearchCV", "(", "adv_deb", ",", "params", ",", "cv", "=", "3", ")", "\n", "clf", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n", "clf", ".", "best_estimator_", ".", "sess_", ".", "close", "(", ")", "\n", "assert", "clf", ".", "best_params_", "==", "{", "'debias'", ":", "False", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reject_option_classification.log_reg_probs": [[15, 22], ["pytest.fixture", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit", "sklearn.linear_model.LogisticRegression.predict_proba"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba"], ["@", "pytest", ".", "fixture", "(", "scope", "=", "'module'", ")", "\n", "def", "log_reg_probs", "(", "new_adult", ")", ":", "\n", "    ", "\"\"\"Train a LogisticRegression model and return val and test pred probs.\"\"\"", "\n", "X", ",", "y", ",", "sample_weight", "=", "new_adult", "\n", "lr", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "500", ")", "\n", "lr", ".", "fit", "(", "X", ",", "y", ",", "sample_weight", "=", "sample_weight", ")", "\n", "return", "lr", ".", "predict_proba", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reject_option_classification.old_ROC": [[23, 35], ["pytest.fixture", "old_adult.copy", "aif360.algorithms.postprocessing.RejectOptionClassification", "aif360.algorithms.postprocessing.RejectOptionClassification.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "@", "pytest", ".", "fixture", "(", "scope", "=", "'module'", ")", "\n", "def", "old_ROC", "(", "old_adult", ",", "log_reg_probs", ")", ":", "\n", "    ", "\"\"\"Fit old ROC on test.\"\"\"", "\n", "old_adult_pred", "=", "old_adult", ".", "copy", "(", ")", "\n", "old_adult_pred", ".", "scores", "=", "log_reg_probs", "[", ":", ",", "[", "1", "]", "]", "\n", "\n", "ROC", "=", "RejectOptionClassification", "(", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ",", "low_class_thresh", "=", "0.1", ",", "\n", "high_class_thresh", "=", "0.9", ",", "num_class_thresh", "=", "9", ",", "num_ROC_margin", "=", "9", ",", "\n", "metric_name", "=", "'Statistical parity difference'", ",", "metric_ub", "=", "0.1", ",", "\n", "metric_lb", "=", "-", "0.1", ")", "\n", "return", "ROC", ".", "fit", "(", "old_adult", ",", "old_adult_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reject_option_classification.new_ROC": [[36, 44], ["pytest.fixture", "pandas.DataFrame", "aif360.sklearn.postprocessing.RejectOptionClassifierCV", "aif360.sklearn.postprocessing.RejectOptionClassifierCV.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "@", "pytest", ".", "fixture", "(", "scope", "=", "'module'", ")", "\n", "def", "new_ROC", "(", "new_adult", ",", "log_reg_probs", ")", ":", "\n", "    ", "_", ",", "y", ",", "_", "=", "new_adult", "\n", "y_pred", "=", "pd", ".", "DataFrame", "(", "log_reg_probs", ",", "index", "=", "y", ".", "index", ")", "\n", "\n", "ROC", "=", "RejectOptionClassifierCV", "(", "'sex'", ",", "scoring", "=", "'statistical_parity'", ",", "\n", "step", "=", "0.1", ",", "n_jobs", "=", "-", "1", ")", "\n", "return", "ROC", ".", "fit", "(", "y_pred", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reject_option_classification.test_rej_opt_clf_fit": [[45, 50], ["numpy.isclose", "numpy.isclose"], "function", ["None"], ["", "def", "test_rej_opt_clf_fit", "(", "new_ROC", ",", "old_ROC", ")", ":", "\n", "    ", "\"\"\"Test RejectOptionClassifierCV fit matches old.\"\"\"", "\n", "assert", "np", ".", "isclose", "(", "new_ROC", ".", "best_estimator_", ".", "threshold", ",", "\n", "old_ROC", ".", "classification_threshold", ",", "atol", "=", "0.05", ")", "\n", "assert", "np", ".", "isclose", "(", "new_ROC", ".", "best_estimator_", ".", "margin", ",", "old_ROC", ".", "ROC_margin", ",", "atol", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reject_option_classification.test_rej_opt_clf_predict": [[51, 64], ["old_adult.copy", "aif360.sklearn.postprocessing.RejectOptionClassifier", "pandas.DataFrame", "aif360.sklearn.postprocessing.RejectOptionClassifier.fit_predict", "numpy.allclose", "old_ROC.predict().labels.ravel", "old_ROC.predict"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier.fit_predict", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["", "def", "test_rej_opt_clf_predict", "(", "new_adult", ",", "old_adult", ",", "log_reg_probs", ",", "old_ROC", ")", ":", "\n", "    ", "\"\"\"Test RejectOptionClassifier predict matches old.\"\"\"", "\n", "_", ",", "y", ",", "_", "=", "new_adult", "\n", "old_adult_pred", "=", "old_adult", ".", "copy", "(", ")", "\n", "old_adult_pred", ".", "scores", "=", "log_reg_probs", "[", ":", ",", "[", "1", "]", "]", "\n", "\n", "threshold", "=", "old_ROC", ".", "classification_threshold", "\n", "margin", "=", "old_ROC", ".", "ROC_margin", "\n", "ROC", "=", "RejectOptionClassifier", "(", "'sex'", ",", "threshold", "=", "threshold", ",", "margin", "=", "margin", ")", "\n", "y_pred", "=", "pd", ".", "DataFrame", "(", "log_reg_probs", ",", "index", "=", "y", ".", "index", ")", "\n", "y_postpred", "=", "ROC", ".", "fit_predict", "(", "y_pred", ",", "y", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "y_postpred", ",", "old_ROC", ".", "predict", "(", "old_adult_pred", ")", ".", "labels", ".", "ravel", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reject_option_classification.test_rej_opt_clf_errors": [[65, 84], ["pytest.mark.filterwarnings", "numpy.array", "pandas.DataFrame", "y_true.set_index().squeeze.set_index().squeeze", "aif360.sklearn.postprocessing.RejectOptionClassifier", "pandas.DataFrame", "aif360.sklearn.postprocessing.RejectOptionClassifier.fit_predict", "aif360.sklearn.postprocessing.RejectOptionClassifierCV", "pytest.raises", "aif360.sklearn.postprocessing.RejectOptionClassifier.fit", "pytest.raises", "aif360.sklearn.postprocessing.RejectOptionClassifier.fit().predict", "pytest.raises", "aif360.sklearn.postprocessing.RejectOptionClassifierCV.fit", "y_true.set_index().squeeze.set_index", "aif360.sklearn.postprocessing.RejectOptionClassifier.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.postprocessing.reject_option_classification.RejectOptionClassifier.fit_predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "@", "pytest", ".", "mark", ".", "filterwarnings", "(", "'error'", ",", "category", "=", "RuntimeWarning", ")", "\n", "def", "test_rej_opt_clf_errors", "(", ")", ":", "\n", "    ", "y_proba", "=", "np", ".", "array", "(", "[", "[", "0.5", ",", "0.5", "]", ",", "[", "0.3", ",", "0.7", "]", ",", "[", "0.55", ",", "0.45", "]", "]", ")", "\n", "# y_true = pd.Series([0, 0, 0], index=[1, 1, 0]).rename_axis(index='prot')", "\n", "y_true", "=", "pd", ".", "DataFrame", "(", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "columns", "=", "[", "'feat'", ",", "'prot'", "]", ")", "\n", "y_true", "=", "y_true", ".", "set_index", "(", "'prot'", ",", "append", "=", "True", ")", ".", "squeeze", "(", ")", "\n", "roc", "=", "RejectOptionClassifier", "(", "'prot'", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# binary classification", "\n", "        ", "roc", ".", "fit", "(", "y_proba", ",", "y_true", ")", "\n", "", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "# missing prot attr", "\n", "        ", "roc", ".", "fit", "(", "y_proba", ",", "y_true", ",", "labels", "=", "[", "0", ",", "1", "]", ")", ".", "predict", "(", "y_proba", ")", "\n", "", "y_proba", "=", "pd", ".", "DataFrame", "(", "y_proba", ",", "index", "=", "y_true", ".", "index", ")", "\n", "y_postpred", "=", "roc", ".", "fit_predict", "(", "y_proba", ",", "labels", "=", "[", "0", ",", "1", "]", ")", "\n", "assert", "(", "y_postpred", "==", "[", "0", ",", "1", ",", "1", "]", ")", ".", "all", "(", ")", "\n", "\n", "cv", "=", "RejectOptionClassifierCV", "(", "'prot'", ",", "scoring", "=", "'statistical_parity'", ",", "\n", "step", "=", "0.1", ",", "cv", "=", "3", ")", "\n", "with", "pytest", ".", "raises", "(", "RuntimeWarning", ")", ":", "# sample_weight ignored warning", "\n", "        ", "cv", ".", "fit", "(", "y_proba", ",", "y_true", ",", "sample_weight", "=", "[", "10", ",", "1", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reject_option_classification.test_rej_opt_clf_postproc_meta": [[85, 110], ["sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit", "aif360.sklearn.postprocessing.PostProcessingMeta", "aif360.sklearn.postprocessing.PostProcessingMeta.fit", "aif360.sklearn.postprocessing.PostProcessingMeta.set_params().fit", "sklearn.model_selection.train_test_split", "sklearn.linear_model.LogisticRegression.fit", "pandas.DataFrame", "new_ROC.fit", "aif360.sklearn.postprocessing.RejectOptionClassifierCV", "sklearn.linear_model.LogisticRegression.predict_proba", "aif360.sklearn.postprocessing.PostProcessingMeta.set_params"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba"], ["", "", "def", "test_rej_opt_clf_postproc_meta", "(", "new_adult", ",", "new_ROC", ")", ":", "\n", "    ", "\"\"\"Test PostProcessingMeta pipeline with RejectOptionClassifierCV.\"\"\"", "\n", "X", ",", "y", ",", "sample_weight", "=", "new_adult", "\n", "lr", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "500", ")", "\n", "lr", ".", "fit", "(", "X", ",", "y", ",", "sample_weight", "=", "sample_weight", ")", "\n", "pp", "=", "PostProcessingMeta", "(", "lr", ",", "\n", "RejectOptionClassifierCV", "(", "'sex'", ",", "scoring", "=", "'statistical_parity'", ",", "\n", "step", "=", "0.1", ",", "n_jobs", "=", "-", "1", ")", ",", "\n", "prefit", "=", "True", ",", "random_state", "=", "1234", ")", "\n", "pp", ".", "fit", "(", "X", ",", "y", ")", "\n", "assert", "pp", ".", "postprocessor_", ".", "best_params_", "==", "new_ROC", ".", "best_params_", "\n", "assert", "(", "pp", ".", "postprocessor_", ".", "cv_results_", "[", "'mean_test_bal_acc'", "]", "\n", "==", "new_ROC", ".", "cv_results_", "[", "'mean_test_bal_acc'", "]", ")", ".", "all", "(", ")", "\n", "\n", "pp", ".", "set_params", "(", "prefit", "=", "False", ")", ".", "fit", "(", "X", ",", "y", ",", "sample_weight", "=", "sample_weight", ")", "\n", "\n", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", ",", "sw_train", ",", "sw_test", "=", "train_test_split", "(", "X", ",", "y", ",", "\n", "sample_weight", ",", "train_size", "=", "0.75", ",", "random_state", "=", "1234", ")", "\n", "lr", ".", "fit", "(", "X_train", ",", "y_train", ",", "sample_weight", "=", "sw_train", ")", "\n", "y_pred", "=", "pd", ".", "DataFrame", "(", "lr", ".", "predict_proba", "(", "X_test", ")", ",", "index", "=", "y_test", ".", "index", ")", "\n", "new_ROC", ".", "fit", "(", "y_pred", ",", "y_test", ")", "\n", "assert", "(", "lr", ".", "coef_", "==", "pp", ".", "estimator_", ".", "coef_", ")", ".", "all", "(", ")", "\n", "assert", "pp", ".", "postprocessor_", ".", "best_params_", "==", "new_ROC", ".", "best_params_", "\n", "assert", "(", "pp", ".", "postprocessor_", ".", "cv_results_", "[", "'mean_test_bal_acc'", "]", "\n", "==", "new_ROC", ".", "cv_results_", "[", "'mean_test_bal_acc'", "]", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reject_option_classification.test_rej_opt_clf_scoring": [[111, 128], ["pytest.mark.parametrize", "aif360.sklearn.postprocessing.PostProcessingMeta", "aif360.sklearn.postprocessing.PostProcessingMeta.fit", "itertools.product", "sklearn.linear_model.LogisticRegression", "aif360.sklearn.postprocessing.RejectOptionClassifierCV", "aif360.sklearn.postprocessing.PostProcessingMeta.score", "aif360.sklearn.postprocessing.PostProcessingMeta.score"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"prot_attr, scoring\"", ",", "\n", "product", "(", "[", "'race'", ",", "'sex'", "]", ",", "[", "'statistical_parity'", ",", "'average_odds'", ",", "\n", "'equal_opportunity'", ",", "'disparate_impact'", "]", ")", "\n", ")", "\n", "def", "test_rej_opt_clf_scoring", "(", "prot_attr", ",", "scoring", ",", "new_adult", ")", ":", "\n", "    ", "\"\"\"Test all scoring options work.\"\"\"", "\n", "X", ",", "y", ",", "sample_weight", "=", "new_adult", "\n", "pp", "=", "PostProcessingMeta", "(", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "500", ")", ",", "\n", "RejectOptionClassifierCV", "(", "prot_attr", ",", "scoring", "=", "scoring", ",", "step", "=", "0.1", ",", "\n", "refit", "=", "scoring", ",", "n_jobs", "=", "-", "1", ")", ")", "\n", "pp", ".", "fit", "(", "X", ",", "y", ",", "sample_weight", "=", "sample_weight", ")", "\n", "\n", "if", "scoring", "==", "'disparate_impact'", ":", "\n", "        ", "assert", "pp", ".", "score", "(", "X", ",", "y", ")", ">=", "0.8", "\n", "", "else", ":", "\n", "        ", "assert", "pp", ".", "score", "(", "X", ",", "y", ")", ">=", "-", "0.1", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reject_option_classification.test_rej_opt_clf_custom_scoring": [[129, 138], ["sklearn.metrics.make_scorer", "aif360.sklearn.postprocessing.PostProcessingMeta", "aif360.sklearn.postprocessing.PostProcessingMeta.fit", "pandas.DataFrame", "sklearn.linear_model.LogisticRegression", "aif360.sklearn.postprocessing.RejectOptionClassifierCV", "pd.DataFrame.isna().any", "pd.DataFrame.isna"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "", "def", "test_rej_opt_clf_custom_scoring", "(", "new_adult", ")", ":", "\n", "    ", "X", ",", "y", ",", "sample_weight", "=", "new_adult", "\n", "scoring", "=", "make_scorer", "(", "generalized_entropy_error", ",", "greater_is_better", "=", "False", ")", "\n", "pp", "=", "PostProcessingMeta", "(", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "500", ")", ",", "\n", "RejectOptionClassifierCV", "(", "'sex'", ",", "scoring", "=", "scoring", ",", "step", "=", "0.1", ",", "\n", "refit", "=", "False", ",", "n_jobs", "=", "-", "1", ")", ")", "\n", "pp", ".", "fit", "(", "X", ",", "y", ",", "sample_weight", "=", "sample_weight", ")", "\n", "res", "=", "pd", ".", "DataFrame", "(", "pp", ".", "postprocessor_", ".", "cv_results_", ")", "\n", "assert", "not", "res", ".", "isna", "(", ")", ".", "any", "(", "axis", "=", "None", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_standardize_dataset_basic": [[17, 30], ["basic", "isinstance", "isinstance", "X.index.equals", "pytest.raises", "pytest.raises"], "function", ["None"], ["def", "test_standardize_dataset_basic", "(", ")", ":", "\n", "    ", "\"\"\"Tests standardize_dataset on a toy example.\"\"\"", "\n", "dataset", "=", "basic", "(", ")", "\n", "X", ",", "y", "=", "dataset", "\n", "X", ",", "y", "=", "dataset", ".", "X", ",", "dataset", ".", "y", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "X", ",", "y", ",", "sample_weight", "=", "dataset", "\n", "", "with", "pytest", ".", "raises", "(", "AttributeError", ")", ":", "\n", "        ", "dataset", ".", "sample_weight", "\n", "", "assert", "isinstance", "(", "X", ",", "pd", ".", "DataFrame", ")", "\n", "assert", "isinstance", "(", "y", ",", "pd", ".", "Series", ")", "\n", "assert", "X", ".", "index", ".", "equals", "(", "y", ".", "index", ")", "\n", "assert", "X", ".", "shape", "==", "(", "3", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_multilabel_basic": [[31, 38], ["basic", "isinstance", "isinstance"], "function", ["None"], ["", "def", "test_multilabel_basic", "(", ")", ":", "\n", "    ", "\"\"\"Tests returning a multilabel target on a toy example.\"\"\"", "\n", "multilabel", "=", "basic", "(", "target", "=", "[", "'X2'", ",", "'y'", "]", ")", "\n", "assert", "isinstance", "(", "multilabel", ".", "y", ",", "pd", ".", "DataFrame", ")", "\n", "assert", "isinstance", "(", "multilabel", ".", "X", ",", "pd", ".", "DataFrame", ")", "\n", "assert", "multilabel", ".", "y", ".", "shape", "==", "(", "3", ",", "2", ")", "\n", "assert", "multilabel", ".", "X", ".", "shape", "==", "(", "3", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_series_input_basic": [[39, 53], ["pandas.Series", "basic", "basic", "pandas.DataFrame", "pytest.raises", "basic", "pytest.raises", "basic", "basic.X.index.droplevel", "basic.X.index.droplevel().to_frame", "pd.DataFrame.to_numpy", "pd.Series.to_numpy", "pd.Series.to_numpy", "basic.X.index.droplevel"], "function", ["None"], ["", "def", "test_series_input_basic", "(", ")", ":", "\n", "    ", "prot_attr", "=", "pd", ".", "Series", "(", "[", "'c'", ",", "'b'", ",", "'a'", "]", ",", "name", "=", "'Z2'", ")", "\n", "custom", "=", "basic", "(", "prot_attr", "=", "prot_attr", ")", "\n", "assert", "(", "custom", ".", "X", ".", "index", ".", "droplevel", "(", ")", "==", "prot_attr", ")", ".", "all", "(", ")", "\n", "\n", "custom2", "=", "basic", "(", "prot_attr", "=", "[", "prot_attr", ",", "'Z'", "]", ")", "\n", "ix", "=", "pd", ".", "DataFrame", "(", "[", "[", "'c'", ",", "'a'", "]", ",", "[", "'b'", ",", "'b'", "]", ",", "[", "'a'", ",", "'c'", "]", "]", ",", "columns", "=", "[", "'Z2'", ",", "'Z'", "]", ")", "\n", "assert", "(", "custom2", ".", "X", ".", "index", ".", "droplevel", "(", ")", ".", "to_frame", "(", ")", "==", "ix", ".", "to_numpy", "(", ")", ")", ".", "all", "(", "None", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "        ", "basic", "(", "prot_attr", "=", "[", "prot_attr", ".", "to_numpy", "(", ")", "]", ")", "# list of arrays is not allowed", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "        ", "basic", "(", "prot_attr", "=", "prot_attr", ".", "to_numpy", "(", ")", ")", "# ['c', 'b', 'a'] are not labels", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_series_target_basic": [[54, 62], ["pandas.Series", "basic", "pandas.DataFrame", "basic", "basic.y.to_numpy", "basic.y.to_numpy"], "function", ["None"], ["", "", "def", "test_series_target_basic", "(", ")", ":", "\n", "    ", "target", "=", "pd", ".", "Series", "(", "[", "3", ",", "4", ",", "5", "]", ",", "name", "=", "'y2'", ")", "\n", "custom", "=", "basic", "(", "target", "=", "target", ")", "\n", "assert", "(", "custom", ".", "y", ".", "to_numpy", "(", ")", "==", "target", ")", ".", "all", "(", ")", "\n", "\n", "Y", "=", "pd", ".", "DataFrame", "(", "[", "[", "3", ",", "3", "]", ",", "[", "4", ",", "7", "]", ",", "[", "5", ",", "11", "]", "]", ",", "columns", "=", "[", "'y2'", ",", "'y'", "]", ")", "\n", "custom2", "=", "basic", "(", "target", "=", "[", "target", ",", "'y'", "]", ")", "\n", "assert", "(", "custom2", ".", "y", ".", "to_numpy", "(", ")", "==", "Y", ")", ".", "all", "(", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_sample_weight_basic": [[63, 68], ["basic", "len"], "function", ["None"], ["", "def", "test_sample_weight_basic", "(", ")", ":", "\n", "    ", "\"\"\"Tests returning sample_weight on a toy example.\"\"\"", "\n", "with_weights", "=", "basic", "(", "sample_weight", "=", "'X2'", ")", "\n", "assert", "len", "(", "with_weights", ")", "==", "3", "\n", "assert", "with_weights", ".", "X", ".", "shape", "==", "(", "3", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_usecols_dropcols_basic": [[69, 80], ["isinstance", "basic().X.columns.tolist", "basic().X.columns.tolist", "basic().X.columns.tolist", "basic().X.columns.tolist", "basic().X.columns.tolist", "basic", "basic", "basic", "basic", "basic", "basic"], "function", ["None"], ["", "def", "test_usecols_dropcols_basic", "(", ")", ":", "\n", "    ", "\"\"\"Tests various combinations of usecols and dropcols on a toy example.\"\"\"", "\n", "assert", "basic", "(", "usecols", "=", "'X1'", ")", ".", "X", ".", "columns", ".", "tolist", "(", ")", "==", "[", "'X1'", "]", "\n", "assert", "basic", "(", "usecols", "=", "[", "'X1'", ",", "'Z'", "]", ")", ".", "X", ".", "columns", ".", "tolist", "(", ")", "==", "[", "'X1'", ",", "'Z'", "]", "\n", "\n", "assert", "basic", "(", "dropcols", "=", "'X1'", ")", ".", "X", ".", "columns", ".", "tolist", "(", ")", "==", "[", "'X2'", ",", "'Z'", "]", "\n", "assert", "basic", "(", "dropcols", "=", "[", "'X1'", ",", "'Z'", "]", ")", ".", "X", ".", "columns", ".", "tolist", "(", ")", "==", "[", "'X2'", "]", "\n", "\n", "assert", "basic", "(", "usecols", "=", "'X1'", ",", "dropcols", "=", "[", "'X2'", "]", ")", ".", "X", ".", "columns", ".", "tolist", "(", ")", "==", "[", "'X1'", "]", "\n", "assert", "isinstance", "(", "basic", "(", "usecols", "=", "'X2'", ",", "dropcols", "=", "[", "'X1'", ",", "'X2'", "]", ")", "[", "0", "]", ",", "\n", "pd", ".", "DataFrame", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_dropna_basic": [[81, 87], ["functools.partial", "functools.partial.", "basic"], "function", ["None"], ["", "def", "test_dropna_basic", "(", ")", ":", "\n", "    ", "\"\"\"Tests dropna on a toy example.\"\"\"", "\n", "basic_dropna", "=", "partial", "(", "standardize_dataset", ",", "df", "=", "df", ",", "prot_attr", "=", "'Z'", ",", "\n", "target", "=", "'y'", ",", "dropna", "=", "True", ")", "\n", "assert", "basic_dropna", "(", ")", ".", "X", ".", "shape", "==", "(", "2", ",", "3", ")", "\n", "assert", "basic", "(", "dropcols", "=", "'X1'", ")", ".", "X", ".", "shape", "==", "(", "3", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_numeric_only_basic": [[88, 93], ["basic", "basic"], "function", ["None"], ["", "def", "test_numeric_only_basic", "(", ")", ":", "\n", "    ", "\"\"\"Tests numeric_only on a toy example.\"\"\"", "\n", "assert", "basic", "(", "prot_attr", "=", "'X2'", ",", "numeric_only", "=", "True", ")", ".", "X", ".", "shape", "==", "(", "3", ",", "2", ")", "\n", "assert", "(", "basic", "(", "prot_attr", "=", "'X2'", ",", "dropcols", "=", "'Z'", ",", "numeric_only", "=", "True", ")", ".", "X", ".", "shape", "\n", "==", "(", "3", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_fetch_adult": [[94, 101], ["aif360.sklearn.datasets.fetch_adult", "len", "aif360.sklearn.datasets.fetch_adult", "aif360.sklearn.datasets.fetch_adult"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_adult", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_adult", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_adult"], ["", "def", "test_fetch_adult", "(", ")", ":", "\n", "    ", "\"\"\"Tests Adult Income dataset shapes with various options.\"\"\"", "\n", "adult", "=", "fetch_adult", "(", ")", "\n", "assert", "len", "(", "adult", ")", "==", "3", "\n", "assert", "adult", ".", "X", ".", "shape", "==", "(", "45222", ",", "13", ")", "\n", "assert", "fetch_adult", "(", "dropna", "=", "False", ")", ".", "X", ".", "shape", "==", "(", "48842", ",", "13", ")", "\n", "assert", "fetch_adult", "(", "numeric_only", "=", "True", ")", ".", "X", ".", "shape", "==", "(", "48842", ",", "7", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_fetch_german": [[102, 108], ["aif360.sklearn.datasets.fetch_german", "len", "aif360.sklearn.datasets.fetch_german"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_german", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_german"], ["", "def", "test_fetch_german", "(", ")", ":", "\n", "    ", "\"\"\"Tests German Credit dataset shapes with various options.\"\"\"", "\n", "german", "=", "fetch_german", "(", ")", "\n", "assert", "len", "(", "german", ")", "==", "2", "\n", "assert", "german", ".", "X", ".", "shape", "==", "(", "1000", ",", "21", ")", "\n", "assert", "fetch_german", "(", "numeric_only", "=", "True", ")", ".", "X", ".", "shape", "==", "(", "1000", ",", "9", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_fetch_bank": [[109, 116], ["aif360.sklearn.datasets.fetch_bank", "len", "aif360.sklearn.datasets.fetch_bank", "aif360.sklearn.datasets.fetch_bank"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_bank", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_bank", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_bank"], ["", "def", "test_fetch_bank", "(", ")", ":", "\n", "    ", "\"\"\"Tests Bank Marketing dataset shapes with various options.\"\"\"", "\n", "bank", "=", "fetch_bank", "(", ")", "\n", "assert", "len", "(", "bank", ")", "==", "2", "\n", "assert", "bank", ".", "X", ".", "shape", "==", "(", "45211", ",", "15", ")", "\n", "assert", "fetch_bank", "(", "dropcols", "=", "[", "]", ")", ".", "X", ".", "shape", "==", "(", "45211", ",", "16", ")", "\n", "assert", "fetch_bank", "(", "numeric_only", "=", "True", ")", ".", "X", ".", "shape", "==", "(", "45211", ",", "7", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_fetch_compas": [[117, 126], ["pytest.mark.filterwarnings", "aif360.sklearn.datasets.fetch_compas", "len", "pytest.raises", "aif360.sklearn.datasets.fetch_compas", "aif360.sklearn.datasets.fetch_compas"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.compas_dataset.fetch_compas", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.compas_dataset.fetch_compas", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.compas_dataset.fetch_compas"], ["", "@", "pytest", ".", "mark", ".", "filterwarnings", "(", "'error'", ",", "category", "=", "ColumnAlreadyDroppedWarning", ")", "\n", "def", "test_fetch_compas", "(", ")", ":", "\n", "    ", "\"\"\"Tests COMPAS Recidivism dataset shapes with various options.\"\"\"", "\n", "compas", "=", "fetch_compas", "(", ")", "\n", "assert", "len", "(", "compas", ")", "==", "2", "\n", "assert", "compas", ".", "X", ".", "shape", "==", "(", "6167", ",", "10", ")", "\n", "assert", "fetch_compas", "(", "binary_race", "=", "True", ")", ".", "X", ".", "shape", "==", "(", "5273", ",", "10", ")", "\n", "with", "pytest", ".", "raises", "(", "ColumnAlreadyDroppedWarning", ")", ":", "\n", "        ", "assert", "fetch_compas", "(", "numeric_only", "=", "True", ")", ".", "X", ".", "shape", "==", "(", "6172", ",", "6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_datasets.test_onehot_transformer": [[127, 131], ["aif360.sklearn.datasets.fetch_german", "len", "pandas.get_dummies"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_german"], ["", "", "def", "test_onehot_transformer", "(", ")", ":", "\n", "    ", "\"\"\"Tests that categorical features can be correctly one-hot encoded.\"\"\"", "\n", "X", ",", "y", "=", "fetch_german", "(", ")", "\n", "assert", "len", "(", "pd", ".", "get_dummies", "(", "X", ")", ".", "columns", ")", "==", "63", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_demo_mdss_classifier_metric_sklearn.test_demo_mdss_classifier_metric_sklearn": [[4, 15], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_demo_mdss_classifier_metric_sklearn", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'..'", ",", "'examples'", ",", "'sklearn'", ",", "\n", "'demo_mdss_classifier_metric_sklearn.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_demo_exp_grad_red_sklearn.test_demo_exp_grad_red_sklearn": [[5, 16], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_demo_exp_grad_red_sklearn", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'..'", ",", "'examples'", ",", "'sklearn'", ",", "\n", "'demo_exponentiated_gradient_reduction_sklearn.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_demo_grid_search_red_sklearn.test_demo_grid_search_classification": [[5, 16], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_demo_grid_search_classification", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'..'", ",", "'examples'", ",", "'sklearn'", ",", "\n", "'demo_grid_search_reduction_classification_sklearn.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_demo_grid_search_red_sklearn.test_demo_grid_search_regression": [[17, 28], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["", "", "def", "test_demo_grid_search_regression", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'..'", ",", "'examples'", ",", "'sklearn'", ",", "\n", "'demo_grid_search_reduction_regression_sklearn.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.old_lfr": [[14, 19], ["aif360.algorithms.preprocessing.LFR", "aif360.algorithms.preprocessing.LFR.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["@", "pytest", ".", "fixture", "\n", "def", "old_lfr", "(", "old_german", ")", ":", "\n", "    ", "lfr", "=", "LFR", "(", "unprivileged_groups", "=", "[", "{", "'age'", ":", "0", "}", "]", ",", "privileged_groups", "=", "[", "{", "'age'", ":", "1", "}", "]", ",", "\n", "seed", "=", "123", ")", "\n", "return", "lfr", ".", "fit", "(", "old_german", ",", "maxfun", "=", "3e4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.old_lfr2": [[20, 25], ["aif360.algorithms.preprocessing.LFR", "aif360.algorithms.preprocessing.LFR.fit_transform"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform"], ["", "@", "pytest", ".", "fixture", "\n", "def", "old_lfr2", "(", "old_german", ")", ":", "\n", "    ", "lfr", "=", "LFR", "(", "unprivileged_groups", "=", "[", "{", "'age'", ":", "0", "}", "]", ",", "privileged_groups", "=", "[", "{", "'age'", ":", "1", "}", "]", ",", "\n", "seed", "=", "123", ")", "\n", "return", "lfr", ".", "fit_transform", "(", "old_german", ",", "maxfun", "=", "3e4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.new_lfr": [[26, 30], ["aif360.sklearn.preprocessing.LearnedFairRepresentations", "aif360.sklearn.preprocessing.LearnedFairRepresentations.fit", "new_german._asdict"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "@", "pytest", ".", "fixture", "\n", "def", "new_lfr", "(", "new_german", ")", ":", "\n", "    ", "lfr", "=", "LearnedFairRepresentations", "(", "'age'", ",", "random_state", "=", "123", ")", "\n", "return", "lfr", ".", "fit", "(", "**", "new_german", ".", "_asdict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.new_lfr2": [[31, 38], ["aif360.sklearn.preprocessing.LearnedFairRepresentations", "aif360.sklearn.preprocessing.LearnedFairRepresentations.fit_transform", "aif360.sklearn.preprocessing.LearnedFairRepresentations.predict"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["", "@", "pytest", ".", "fixture", "\n", "def", "new_lfr2", "(", "new_german", ")", ":", "\n", "    ", "lfr", "=", "LearnedFairRepresentations", "(", "'age'", ",", "random_state", "=", "123", ")", "\n", "X", ",", "y", "=", "new_german", "\n", "Xt", "=", "lfr", ".", "fit_transform", "(", "X", ",", "y", ")", "\n", "yt", "=", "lfr", ".", "predict", "(", "X", ")", "\n", "return", "Xt", ",", "yt", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.test_data_old_new": [[40, 44], ["old_german.labels.flatten"], "function", ["None"], ["", "def", "test_data_old_new", "(", "old_german", ",", "new_german", ")", ":", "\n", "    ", "\"\"\"Test that the old and new versions of the dataset match.\"\"\"", "\n", "assert", "(", "old_german", ".", "features", "==", "new_german", ".", "X", ")", ".", "all", "(", "None", ")", "\n", "assert", "(", "old_german", ".", "labels", ".", "flatten", "(", ")", "==", "new_german", ".", "y", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.test_lfr_old_reproduce": [[45, 50], ["old_lfr.transform.transform", "numpy.allclose", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform"], ["", "def", "test_lfr_old_reproduce", "(", "old_lfr", ",", "old_lfr2", ",", "old_german", ")", ":", "\n", "    ", "\"\"\"Test that the old LFR is reproducible.\"\"\"", "\n", "old_lfr", "=", "old_lfr", ".", "transform", "(", "old_german", ")", "\n", "assert", "np", ".", "allclose", "(", "old_lfr", ".", "features", ",", "old_lfr2", ".", "features", ")", "\n", "assert", "np", ".", "allclose", "(", "old_lfr", ".", "labels", ",", "old_lfr2", ".", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.test_lfr_new_reproduce": [[51, 59], ["new_lfr.transform", "new_lfr.predict", "numpy.allclose", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict"], ["", "def", "test_lfr_new_reproduce", "(", "new_lfr", ",", "new_lfr2", ",", "new_german", ")", ":", "\n", "    ", "\"\"\"Test that the new LearnedFairRepresentation is reproducible.\"\"\"", "\n", "Xt", "=", "new_lfr", ".", "transform", "(", "new_german", ".", "X", ")", "\n", "yt", "=", "new_lfr", ".", "predict", "(", "new_german", ".", "X", ")", "\n", "Xt2", ",", "yt2", "=", "new_lfr2", "\n", "\n", "assert", "np", ".", "allclose", "(", "Xt", ",", "Xt2", ")", "\n", "assert", "np", ".", "allclose", "(", "yt", ",", "yt2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.test_lfr_models": [[60, 65], ["pytest.mark.skip", "numpy.allclose", "numpy.allclose", "new_lfr.coef_.flatten"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "skip", "(", ")", "\n", "def", "test_lfr_models", "(", "old_lfr", ",", "new_lfr", ")", ":", "\n", "    ", "\"\"\"Test that the learned model parameters of the old and new LFR match.\"\"\"", "\n", "assert", "np", ".", "allclose", "(", "old_lfr", ".", "w", ",", "new_lfr", ".", "coef_", ".", "flatten", "(", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "old_lfr", ".", "prototypes", ",", "new_lfr", ".", "prototypes_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.test_lfr_old_new": [[66, 72], ["pytest.mark.skip", "numpy.allclose", "numpy.allclose", "old_lfr2.labels.flatten"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "skip", "(", ")", "\n", "def", "test_lfr_old_new", "(", "old_lfr2", ",", "new_lfr2", ")", ":", "\n", "    ", "\"\"\"Test that the transformations of the old and new LFR match.\"\"\"", "\n", "Xt", ",", "yt", "=", "new_lfr2", "\n", "assert", "np", ".", "allclose", "(", "old_lfr2", ".", "features", ",", "Xt", ")", "\n", "assert", "np", ".", "allclose", "(", "old_lfr2", ".", "labels", ".", "flatten", "(", ")", ",", "yt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.test_lfr_multiclass": [[73, 81], ["sklearn.datasets.make_classification", "numpy.random.randint", "pandas.DataFrame", "aif360.sklearn.preprocessing.LearnedFairRepresentations", "aif360.sklearn.preprocessing.LearnedFairRepresentations.fit", "pandas.Series"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "test_lfr_multiclass", "(", ")", ":", "\n", "    ", "\"\"\"Test that the new LFR runs with >2 classes.\"\"\"", "\n", "X", ",", "y", "=", "make_classification", "(", "n_informative", "=", "3", ",", "n_classes", "=", "4", ")", "\n", "prot_attr", "=", "np", ".", "random", ".", "randint", "(", "2", ",", "size", "=", "X", ".", "shape", "[", ":", "1", "]", ")", "\n", "X", "=", "pd", ".", "DataFrame", "(", "X", ",", "index", "=", "pd", ".", "Series", "(", "prot_attr", ",", "name", "=", "'prot_attr'", ")", ")", "\n", "lfr", "=", "LearnedFairRepresentations", "(", ")", "\n", "lfr", ".", "fit", "(", "X", ",", "y", ")", "\n", "assert", "lfr", ".", "coef_", ".", "shape", "[", "1", "]", "==", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.test_lfr_grid": [[82, 94], ["aif360.sklearn.preprocessing.LearnedFairRepresentations", "aif360.sklearn.metrics.make_scorer", "sklearn.model_selection.GridSearchCV", "sklearn.model_selection.GridSearchCV.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "test_lfr_grid", "(", "new_german", ")", ":", "\n", "    ", "\"\"\"Test that the new LFR works in a grid search (and that debiasing\n    results in improved statistical parity difference).\n    \"\"\"", "\n", "X", ",", "y", "=", "new_german", "\n", "lfr", "=", "LearnedFairRepresentations", "(", "'age'", ",", "reconstruct_weight", "=", "0", ",", "max_iter", "=", "1000", ")", "\n", "params", "=", "{", "'fairness_weight'", ":", "[", "50", ",", "0", "]", "}", "\n", "min_disc", "=", "make_scorer", "(", "statistical_parity_difference", ",", "prot_attr", "=", "'age'", ")", "\n", "clf", "=", "GridSearchCV", "(", "lfr", ",", "params", ",", "scoring", "=", "min_disc", ",", "cv", "=", "2", ")", "\n", "clf", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n", "assert", "clf", ".", "best_params_", "==", "{", "'fairness_weight'", ":", "50", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_learning_fair_representations.test_lfr_pipe": [[95, 103], ["aif360.sklearn.preprocessing.LearnedFairRepresentations", "sklearn.linear_model.LogisticRegression", "sklearn.pipeline.make_pipeline", "sklearn.pipeline.make_pipeline.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "test_lfr_pipe", "(", "new_german", ")", ":", "\n", "    ", "\"\"\"Test that the new LFR works as a pre-processing step in a pipeline.\"\"\"", "\n", "X", ",", "y", "=", "new_german", "\n", "lfr", "=", "LearnedFairRepresentations", "(", "'age'", ",", "random_state", "=", "123", ")", "\n", "lr", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "random_state", "=", "123", ")", "\n", "pipe", "=", "make_pipeline", "(", "lfr", ",", "lr", ")", "\n", "\n", "pipe", ".", "fit", "(", "X", ",", "y", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_fairadapt.test_fairadapt_adult": [[17, 62], ["pandas.concat", "pandas.DataFrame", "aif360.sklearn.preprocessing.fairadapt.FairAdapt", "fairadapt.FairAdapt.fit_transform", "aif360.sklearn.metrics.statistical_parity_difference", "aif360.sklearn.metrics.statistical_parity_difference", "isinstance", "isinstance", "isinstance", "all", "numpy.zeros", "abs", "abs", "len", "len"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference"], ["def", "test_fairadapt_adult", "(", ")", ":", "\n", "    ", "\"\"\"Test that FairAdapt works when applied to Adult dataset.\"\"\"", "\n", "train_df", "=", "pd", ".", "concat", "(", "[", "X_train", ",", "y_train", "]", ",", "axis", "=", "1", ")", "\n", "adj_mat", "=", "pd", ".", "DataFrame", "(", "\n", "np", ".", "zeros", "(", "(", "len", "(", "train_df", ".", "columns", ")", ",", "len", "(", "train_df", ".", "columns", ")", ")", ",", "dtype", "=", "int", ")", ",", "\n", "index", "=", "train_df", ".", "columns", ".", "values", ",", "\n", "columns", "=", "train_df", ".", "columns", ".", "values", "\n", ")", "\n", "\n", "# Construct the adjacency matrix of the causal graph", "\n", "adj_mat", ".", "loc", "[", "\n", "[", "\"sex\"", ",", "\"age\"", ",", "\"native-country\"", "]", ",", "\n", "[", "\"marital-status\"", ",", "\"education-num\"", ",", "\"workclass\"", ",", "\"hours-per-week\"", ",", "\n", "\"occupation\"", ",", "\"annual-income\"", "]", "\n", "]", "=", "1", "\n", "adj_mat", ".", "loc", "[", "\n", "\"marital-status\"", ",", "\n", "[", "\"education-num\"", ",", "\"workclass\"", ",", "\"hours-per-week\"", ",", "\"occupation\"", ",", "\n", "\"annual-income\"", "]", "\n", "]", "=", "1", "\n", "adj_mat", ".", "loc", "[", "\n", "\"education-num\"", ",", "\n", "[", "\"workclass\"", ",", "\"hours-per-week\"", ",", "\"occupation\"", ",", "\"annual-income\"", "]", "\n", "]", "=", "1", "\n", "adj_mat", ".", "loc", "[", "\n", "[", "\"workclass\"", ",", "\"hours-per-week\"", ",", "\"occupation\"", "]", ",", "\n", "\"annual-income\"", "\n", "]", "=", "1", "\n", "\n", "FA", "=", "fairadapt", ".", "FairAdapt", "(", "prot_attr", "=", "\"sex\"", ",", "adj_mat", "=", "adj_mat", ")", "\n", "Xf_train", ",", "yf_train", ",", "Xf_test", "=", "FA", ".", "fit_transform", "(", "X_train", ",", "y_train", ",", "X_test", ")", "\n", "\n", "# gap before adaptation", "\n", "gap", "=", "statistical_parity_difference", "(", "y_train", ",", "prot_attr", "=", "\"sex\"", ",", "\n", "priv_group", "=", "\"Male\"", ",", "pos_label", "=", "\">50K\"", ")", "\n", "\n", "# gap after adaptation", "\n", "fair_gap", "=", "statistical_parity_difference", "(", "y_train", ",", "yf_train", ",", "prot_attr", "=", "\"sex\"", ",", "\n", "priv_group", "=", "\"Male\"", ",", "pos_label", "=", "\">50K\"", ")", "\n", "\n", "assert", "isinstance", "(", "Xf_train", ",", "pd", ".", "DataFrame", ")", "\n", "assert", "isinstance", "(", "Xf_test", ",", "pd", ".", "DataFrame", ")", "\n", "assert", "isinstance", "(", "yf_train", ",", "pd", ".", "Series", ")", "\n", "assert", "all", "(", "Xf_train", "[", "FA", ".", "prot_attr", "]", "==", "\"Female\"", ")", "\n", "assert", "abs", "(", "fair_gap", ")", "<=", "abs", "(", "gap", ")", "# assert that discrimination was reduced", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_dataset_equality": [[33, 37], ["adult.labels.ravel"], "function", ["None"], ["def", "test_dataset_equality", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new datasets match exactly.\"\"\"", "\n", "assert", "(", "adult", ".", "features", "==", "X", ".", "values", ")", ".", "all", "(", ")", "\n", "assert", "(", "adult", ".", "labels", ".", "ravel", "(", ")", "==", "y", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_consistency": [[38, 41], ["numpy.isclose", "aif360.sklearn.metrics.consistency_score", "cm.consistency"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.consistency_score", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.consistency"], ["", "def", "test_consistency", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new consistency_score matches exactly.\"\"\"", "\n", "assert", "np", ".", "isclose", "(", "consistency_score", "(", "X", ",", "y", ")", ",", "cm", ".", "consistency", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_specificity": [[42, 46], ["aif360.sklearn.metrics.specificity_score", "cm.specificity"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.specificity_score", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.specificity"], ["", "def", "test_specificity", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new specificity_score matches exactly.\"\"\"", "\n", "spec", "=", "specificity_score", "(", "y", ",", "y_pred", ",", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "spec", "==", "cm", ".", "specificity", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_base_rate": [[47, 51], ["aif360.sklearn.metrics.base_rate", "cm.base_rate"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate"], ["", "def", "test_base_rate", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new base_rate matches exactly.\"\"\"", "\n", "base", "=", "base_rate", "(", "y", ",", "y_pred", ",", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "base", "==", "cm", ".", "base_rate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_selection_rate": [[52, 56], ["aif360.sklearn.metrics.selection_rate", "cm.selection_rate"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.selection_rate", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.selection_rate"], ["", "def", "test_selection_rate", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new selection_rate matches exactly.\"\"\"", "\n", "select", "=", "selection_rate", "(", "y", ",", "y_pred", ",", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "select", "==", "cm", ".", "selection_rate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_generalized_fpr": [[57, 61], ["aif360.sklearn.metrics.generalized_fpr", "numpy.isclose", "cm.generalized_false_positive_rate"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_fpr", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_positive_rate"], ["", "def", "test_generalized_fpr", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new generalized_fpr matches exactly.\"\"\"", "\n", "gfpr", "=", "generalized_fpr", "(", "y", ",", "y_proba", ",", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "np", ".", "isclose", "(", "gfpr", ",", "cm", ".", "generalized_false_positive_rate", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_generalized_fnr": [[62, 66], ["aif360.sklearn.metrics.generalized_fnr", "numpy.isclose", "cm.generalized_false_negative_rate"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_fnr", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_negative_rate"], ["", "def", "test_generalized_fnr", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new generalized_fnr matches exactly.\"\"\"", "\n", "gfnr", "=", "generalized_fnr", "(", "y", ",", "y_proba", ",", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "np", ".", "isclose", "(", "gfnr", ",", "cm", ".", "generalized_false_negative_rate", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_disparate_impact": [[67, 72], ["aif360.sklearn.metrics.disparate_impact_ratio", "cm.disparate_impact"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.disparate_impact_ratio", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact"], ["", "def", "test_disparate_impact", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new disparate_impact matches exactly.\"\"\"", "\n", "di", "=", "disparate_impact_ratio", "(", "y", ",", "y_pred", ",", "prot_attr", "=", "'sex'", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "di", "==", "cm", ".", "disparate_impact", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_statistical_parity": [[73, 78], ["aif360.sklearn.metrics.statistical_parity_difference", "cm.statistical_parity_difference"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference"], ["", "def", "test_statistical_parity", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new statistical_parity matches exactly.\"\"\"", "\n", "stat", "=", "statistical_parity_difference", "(", "y", ",", "y_pred", ",", "prot_attr", "=", "'sex'", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "stat", "==", "cm", ".", "statistical_parity_difference", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_equal_opportunity": [[79, 84], ["aif360.sklearn.metrics.equal_opportunity_difference", "cm.equal_opportunity_difference"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.equal_opportunity_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.equal_opportunity_difference"], ["", "def", "test_equal_opportunity", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new equal_opportunity matches exactly.\"\"\"", "\n", "eopp", "=", "equal_opportunity_difference", "(", "y", ",", "y_pred", ",", "prot_attr", "=", "'sex'", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "eopp", "==", "cm", ".", "equal_opportunity_difference", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_average_odds_difference": [[85, 90], ["aif360.sklearn.metrics.average_odds_difference", "numpy.isclose", "cm.average_odds_difference"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_odds_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_odds_difference"], ["", "def", "test_average_odds_difference", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new average_odds_difference matches exactly.\"\"\"", "\n", "aod", "=", "average_odds_difference", "(", "y", ",", "y_pred", ",", "prot_attr", "=", "'sex'", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "np", ".", "isclose", "(", "aod", ",", "cm", ".", "average_odds_difference", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_average_odds_error": [[91, 96], ["aif360.sklearn.metrics.average_odds_error", "numpy.isclose", "cm.average_abs_odds_difference"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.average_odds_error", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_abs_odds_difference"], ["", "def", "test_average_odds_error", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new average_odds_error matches exactly.\"\"\"", "\n", "aoe", "=", "average_odds_error", "(", "y", ",", "y_pred", ",", "prot_attr", "=", "'sex'", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "assert", "np", ".", "isclose", "(", "aoe", ",", "cm", ".", "average_abs_odds_difference", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_generalized_entropy_index": [[97, 101], ["aif360.sklearn.metrics.generalized_entropy_error", "numpy.isclose", "cm.generalized_entropy_index"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_entropy_error", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["", "def", "test_generalized_entropy_index", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new generalized_entropy_index matches exactly.\"\"\"", "\n", "gei", "=", "generalized_entropy_error", "(", "y", ",", "y_pred", ")", "\n", "assert", "np", ".", "isclose", "(", "gei", ",", "cm", ".", "generalized_entropy_index", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_between_group_generalized_entropy_index": [[102, 106], ["aif360.sklearn.metrics.between_group_generalized_entropy_error", "cm.between_group_generalized_entropy_index"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.between_group_generalized_entropy_error", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_generalized_entropy_index"], ["", "def", "test_between_group_generalized_entropy_index", "(", ")", ":", "\n", "    ", "\"\"\"Tests that the old and new between_group_GEI matches exactly.\"\"\"", "\n", "bggei", "=", "between_group_generalized_entropy_error", "(", "y", ",", "y_pred", ",", "prot_attr", "=", "'sex'", ")", "\n", "assert", "bggei", "==", "cm", ".", "between_group_generalized_entropy_index", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_metrics.test_make_scorer": [[107, 128], ["pytest.mark.parametrize", "func", "func", "aif360.sklearn.metrics.make_scorer", "aif360.sklearn.metrics.make_scorer.", "min", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"func, is_ratio\"", ",", "\n", "[", "\n", "(", "statistical_parity_difference", ",", "False", ")", ",", "\n", "(", "disparate_impact_ratio", ",", "True", ")", ",", "\n", "(", "equal_opportunity_difference", ",", "False", ")", ",", "\n", "(", "average_odds_difference", ",", "False", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_make_scorer", "(", "func", ",", "is_ratio", ")", ":", "\n", "    ", "actual", "=", "func", "(", "y", ",", "y_pred", ",", "prot_attr", "=", "\"sex\"", ",", "priv_group", "=", "1", ")", "\n", "actual_fliped", "=", "func", "(", "y", ",", "y_pred", ",", "prot_attr", "=", "\"sex\"", ",", "priv_group", "=", "0", ")", "\n", "scorer", "=", "make_scorer", "(", "func", ",", "is_ratio", "=", "is_ratio", ",", "prot_attr", "=", "\"sex\"", ",", "priv_group", "=", "1", ")", "\n", "expected", "=", "scorer", "(", "lr", ",", "X", ",", "y", ")", "\n", "if", "is_ratio", ":", "\n", "        ", "ret", "=", "min", "(", "actual", ",", "actual_fliped", ")", "\n", "assert_almost_equal", "(", "ret", ",", "expected", ",", "3", ")", "\n", "", "else", ":", "\n", "# The lower the better", "\n", "        ", "assert_almost_equal", "(", "-", "abs", "(", "actual", ")", ",", "expected", ",", "3", ")", "\n", "assert_almost_equal", "(", "-", "abs", "(", "actual_fliped", ")", ",", "expected", ",", "3", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_calibrated_equalized_odds.test_calib_eq_odds_sex_weighted": [[11, 28], ["sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit().predict_proba", "old_adult.copy", "aif360.algorithms.postprocessing.CalibratedEqOddsPostprocessing", "aif360.algorithms.postprocessing.CalibratedEqOddsPostprocessing.fit", "aif360.sklearn.postprocessing.CalibratedEqualizedOdds", "aif360.sklearn.postprocessing.CalibratedEqualizedOdds.fit", "numpy.isclose", "numpy.isclose", "sklearn.linear_model.LogisticRegression.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["def", "test_calib_eq_odds_sex_weighted", "(", "old_adult", ",", "new_adult", ")", ":", "\n", "    ", "\"\"\"Test that the old and new CalibratedEqualizedOdds produce the same mix\n    rates.\n    \"\"\"", "\n", "X", ",", "y", ",", "sample_weight", "=", "new_adult", "\n", "logreg", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "500", ")", "\n", "y_pred", "=", "logreg", ".", "fit", "(", "X", ",", "y", ",", "sample_weight", "=", "sample_weight", ")", ".", "predict_proba", "(", "X", ")", "\n", "adult_pred", "=", "old_adult", ".", "copy", "(", ")", "\n", "adult_pred", ".", "scores", "=", "y_pred", "[", ":", ",", "1", "]", "\n", "orig_cal_eq_odds", "=", "CalibratedEqOddsPostprocessing", "(", "\n", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ")", "\n", "orig_cal_eq_odds", ".", "fit", "(", "old_adult", ",", "adult_pred", ")", "\n", "cal_eq_odds", "=", "CalibratedEqualizedOdds", "(", "'sex'", ")", "\n", "cal_eq_odds", ".", "fit", "(", "y_pred", ",", "y", ",", "sample_weight", "=", "sample_weight", ")", "\n", "\n", "assert", "np", ".", "isclose", "(", "orig_cal_eq_odds", ".", "priv_mix_rate", ",", "cal_eq_odds", ".", "mix_rates_", "[", "1", "]", ")", "\n", "assert", "np", ".", "isclose", "(", "orig_cal_eq_odds", ".", "unpriv_mix_rate", ",", "cal_eq_odds", ".", "mix_rates_", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_calibrated_equalized_odds.test_postprocessingmeta_fnr": [[29, 79], ["old_adult.split", "sklearn.model_selection.train_test_split", "numpy.all", "numpy.all", "numpy.all", "adult_train.split", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit", "adult_post.copy", "aif360.algorithms.postprocessing.CalibratedEqOddsPostprocessing", "aif360.algorithms.postprocessing.CalibratedEqOddsPostprocessing.fit", "aif360.sklearn.postprocessing.PostProcessingMeta", "aif360.sklearn.postprocessing.PostProcessingMeta.fit", "numpy.allclose", "numpy.allclose", "adult_test.copy", "aif360.algorithms.postprocessing.CalibratedEqOddsPostprocessing.predict", "aif360.sklearn.postprocessing.PostProcessingMeta.predict_proba", "numpy.allclose", "adult_est.labels.ravel", "sklearn.linear_model.LogisticRegression.predict_proba", "sklearn.linear_model.LogisticRegression.predict_proba", "adult_train.labels.ravel", "aif360.sklearn.postprocessing.CalibratedEqualizedOdds"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRPredictProbaType2Mixin.predict_proba"], ["", "def", "test_postprocessingmeta_fnr", "(", "old_adult", ",", "new_adult", ")", ":", "\n", "    ", "\"\"\"Test that the old and new CalibratedEqualizedOdds produce the same\n    probability predictions.\n\n    This tests the whole \"pipeline\": splitting the data the same way, training a\n    LogisticRegression classifier, and training the post-processor the same way.\n    \"\"\"", "\n", "X", ",", "y", ",", "sample_weight", "=", "new_adult", "\n", "adult_train", ",", "adult_test", "=", "old_adult", ".", "split", "(", "[", "0.9", "]", ",", "shuffle", "=", "False", ")", "\n", "X_tr", ",", "X_te", ",", "y_tr", ",", "_", ",", "sw_tr", ",", "_", "=", "train_test_split", "(", "X", ",", "y", ",", "sample_weight", ",", "\n", "train_size", "=", "0.9", ",", "shuffle", "=", "False", ")", "\n", "\n", "assert", "np", ".", "all", "(", "adult_train", ".", "features", "==", "X_tr", ")", "\n", "assert", "np", ".", "all", "(", "adult_test", ".", "features", "==", "X_te", ")", "\n", "assert", "np", ".", "all", "(", "adult_train", ".", "labels", ".", "ravel", "(", ")", "==", "y_tr", ")", "\n", "\n", "adult_est", ",", "adult_post", "=", "adult_train", ".", "split", "(", "[", "0.75", "]", ",", "shuffle", "=", "False", ")", "\n", "\n", "logreg", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "500", ")", "\n", "logreg", ".", "fit", "(", "adult_est", ".", "features", ",", "adult_est", ".", "labels", ".", "ravel", "(", ")", ",", "\n", "sample_weight", "=", "adult_est", ".", "instance_weights", ")", "\n", "probas_pred", "=", "logreg", ".", "predict_proba", "(", "adult_post", ".", "features", ")", "[", ":", ",", "1", "]", "\n", "\n", "adult_pred", "=", "adult_post", ".", "copy", "(", ")", "\n", "adult_pred", ".", "scores", "=", "probas_pred", "\n", "\n", "orig_cal_eq_odds", "=", "CalibratedEqOddsPostprocessing", "(", "\n", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ",", "\n", "cost_constraint", "=", "'fnr'", ",", "seed", "=", "0", ")", "\n", "orig_cal_eq_odds", ".", "fit", "(", "adult_post", ",", "adult_pred", ")", "\n", "\n", "cal_eq_odds", "=", "PostProcessingMeta", "(", "estimator", "=", "logreg", ",", "\n", "postprocessor", "=", "CalibratedEqualizedOdds", "(", "'sex'", ",", "cost_constraint", "=", "'fnr'", ",", "\n", "random_state", "=", "0", ")", ",", "\n", "shuffle", "=", "False", ")", "\n", "cal_eq_odds", ".", "fit", "(", "X_tr", ",", "y_tr", ",", "sample_weight", "=", "sw_tr", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "logreg", ".", "coef_", ",", "cal_eq_odds", ".", "estimator_", ".", "coef_", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "[", "orig_cal_eq_odds", ".", "unpriv_mix_rate", ",", "\n", "orig_cal_eq_odds", ".", "priv_mix_rate", "]", ",", "\n", "cal_eq_odds", ".", "postprocessor_", ".", "mix_rates_", ")", "\n", "\n", "adult_test_pred", "=", "adult_test", ".", "copy", "(", ")", "\n", "adult_test_pred", ".", "scores", "=", "logreg", ".", "predict_proba", "(", "adult_test", ".", "features", ")", "[", ":", ",", "1", "]", "\n", "adult_test_pred", "=", "orig_cal_eq_odds", ".", "predict", "(", "adult_test_pred", ")", "\n", "\n", "y_test_pred", "=", "cal_eq_odds", ".", "predict_proba", "(", "X_te", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "adult_test_pred", ".", "scores", ",", "y_test_pred", "[", ":", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_calibrated_equalized_odds.test_calib_eq_odds_prefit": [[80, 98], ["sklearn.linear_model.LogisticRegression", "aif360.sklearn.postprocessing.CalibratedEqualizedOdds", "aif360.sklearn.postprocessing.PostProcessingMeta", "aif360.sklearn.postprocessing.PostProcessingMeta", "aif360.sklearn.postprocessing.PostProcessingMeta.fit", "sklearn.model_selection.train_test_split", "aif360.sklearn.postprocessing.PostProcessingMeta", "aif360.sklearn.postprocessing.PostProcessingMeta.fit", "numpy.allclose", "pytest.raises", "aif360.sklearn.postprocessing.PostProcessingMeta.fit"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "test_calib_eq_odds_prefit", "(", "new_adult", ")", ":", "\n", "    ", "\"\"\"Test the 'prefit' option in PostProcessingMeta.\"\"\"", "\n", "X", ",", "y", ",", "sample_weight", "=", "new_adult", "\n", "\n", "logreg", "=", "LogisticRegression", "(", "solver", "=", "'lbfgs'", ",", "max_iter", "=", "500", ")", "\n", "cal_eq_odds", "=", "CalibratedEqualizedOdds", "(", "'sex'", ")", "\n", "pp", "=", "PostProcessingMeta", "(", "logreg", ",", "cal_eq_odds", ",", "prefit", "=", "True", ")", "\n", "with", "pytest", ".", "raises", "(", "sklearn", ".", "exceptions", ".", "NotFittedError", ")", ":", "\n", "        ", "pp", ".", "fit", "(", "X", ",", "y", ",", "sample_weight", "=", "sample_weight", ")", "\n", "\n", "", "pp", "=", "PostProcessingMeta", "(", "logreg", ",", "cal_eq_odds", ",", "random_state", "=", "1234", ")", "\n", "pp", ".", "fit", "(", "X", ",", "y", ",", "sample_weight", "=", "sample_weight", ")", "\n", "\n", "_", ",", "X_pp", ",", "_", ",", "y_pp", ",", "_", ",", "sw_pp", "=", "train_test_split", "(", "X", ",", "y", ",", "sample_weight", ",", "random_state", "=", "1234", ")", "\n", "pp_prefit", "=", "PostProcessingMeta", "(", "pp", ".", "estimator_", ",", "cal_eq_odds", ",", "prefit", "=", "True", ")", "\n", "pp_prefit", ".", "fit", "(", "X_pp", ",", "y_pp", ",", "sample_weight", "=", "sw_pp", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "pp", ".", "postprocessor_", ".", "mix_rates_", ",", "pp_prefit", ".", "postprocessor_", ".", "mix_rates_", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.conftest.old_german": [[8, 19], ["pytest.fixture", "aif360.datasets.GermanDataset", "numpy.concatenate"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", "scope", "=", "'module'", ")", "\n", "def", "old_german", "(", ")", ":", "\n", "    ", "german", "=", "GermanDataset", "(", "categorical_features", "=", "[", "'foreign_worker'", "]", ",", "\n", "features_to_keep", "=", "[", "'month'", ",", "'credit_amount'", ",", "\n", "'investment_as_income_percentage'", ",", "'residence_since'", ",", "'age'", ",", "\n", "'number_of_credits'", ",", "'people_liable_for'", ",", "'sex'", "]", ")", "\n", "german", ".", "features", "=", "np", ".", "concatenate", "(", "\n", "(", "german", ".", "features", "[", ":", ",", ":", "-", "3", "]", ",", "german", ".", "features", "[", ":", ",", "-", "2", ":", "-", "4", ":", "-", "1", "]", ")", ",", "axis", "=", "1", ")", "\n", "german", ".", "feature_names", "=", "german", ".", "feature_names", "[", ":", "-", "3", "]", "+", "[", "'foreign_worker'", ",", "'sex'", "]", "\n", "german", ".", "labels", "[", "german", ".", "labels", "==", "2", "]", "=", "0", "\n", "return", "german", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.conftest.old_adult": [[20, 26], ["pytest.fixture", "aif360.datasets.AdultDataset"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", "scope", "=", "'module'", ")", "\n", "def", "old_adult", "(", ")", ":", "\n", "    ", "return", "AdultDataset", "(", "instance_weights_name", "=", "'fnlwgt'", ",", "categorical_features", "=", "[", "]", ",", "\n", "features_to_keep", "=", "[", "'age'", ",", "'education-num'", ",", "'capital-gain'", ",", "\n", "'capital-loss'", ",", "'hours-per-week'", "]", ",", "\n", "features_to_drop", "=", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.conftest.new_german": [[28, 33], ["pytest.fixture", "aif360.sklearn.datasets.fetch_german", "aif360.sklearn.datasets.fetch_german.X.age.apply"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_german"], ["", "@", "pytest", ".", "fixture", "(", "scope", "=", "'module'", ")", "\n", "def", "new_german", "(", ")", ":", "\n", "    ", "german", "=", "fetch_german", "(", "numeric_only", "=", "True", ")", "\n", "german", ".", "X", ".", "age", "=", "german", ".", "X", ".", "age", ".", "apply", "(", "lambda", "a", ":", "1", "if", "a", ">", "25", "else", "0", ")", "\n", "return", "german", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.conftest.new_adult": [[34, 37], ["pytest.fixture", "aif360.sklearn.datasets.fetch_adult"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.openml_datasets.fetch_adult"], ["", "@", "pytest", ".", "fixture", "(", "scope", "=", "'module'", ")", "\n", "def", "new_adult", "(", ")", ":", "\n", "    ", "return", "fetch_adult", "(", "numeric_only", "=", "True", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reweighing.test_reweighing_sex": [[10, 23], ["aif360.algorithms.preprocessing.Reweighing", "aif360.algorithms.preprocessing.Reweighing.fit_transform", "aif360.algorithms.preprocessing.Reweighing", "aif360.algorithms.preprocessing.Reweighing.fit_transform", "numpy.allclose", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform"], ["rw", "=", "Reweighing", "(", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ")", "\n", "transf", "=", "rw", ".", "fit_transform", "(", "ad", ")", "\n", "print", "(", "transf", ".", "instance_weights", ".", "sum", "(", ")", ")", "\n", "assert", "np", ".", "isclose", "(", "ad", ".", "instance_weights", ".", "sum", "(", ")", ",", "transf", ".", "instance_weights", ".", "sum", "(", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reweighing.test_reweighing_intersection": [[24, 30], ["aif360.algorithms.preprocessing.Reweighing", "aif360.algorithms.preprocessing.Reweighing.fit_transform"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform"], []], "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.test_reweighing.test_gridsearch": [[31, 46], ["aif360.sklearn.preprocessing.ReweighingMeta", "sklearn.metrics.make_scorer", "sklearn.model_selection.GridSearchCV", "sklearn.model_selection.GridSearchCV.fit", "sklearn.linear_model.LogisticRegression", "aif360.algorithms.preprocessing.Reweighing", "y_true.index.to_flat_index", "sklearn.metrics.accuracy_score"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], []], "home.repos.pwc.inspect_result.IBM_AIF360.detectors.detectors.bias_scan": [[9, 64], ["aif360.detectors.bias_scan"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.mdss_classification_metric.MDSSClassificationMetric.bias_scan"], ["def", "bias_scan", "(", "\n", "X", ":", "pd", ".", "DataFrame", ",", "\n", "y_true", ":", "pd", ".", "Series", ",", "\n", "y_pred", ":", "Union", "[", "pd", ".", "Series", ",", "pd", ".", "DataFrame", "]", "=", "None", ",", "\n", "pos_label", ":", "Union", "[", "str", ",", "float", "]", "=", "None", ",", "\n", "overpredicted", ":", "bool", "=", "True", ",", "\n", "scoring", ":", "Union", "[", "str", ",", "ScoringFunction", "]", "=", "\"Bernoulli\"", ",", "\n", "num_iters", ":", "int", "=", "10", ",", "\n", "penalty", ":", "float", "=", "1e-17", ",", "\n", "mode", ":", "str", "=", "\"binary\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    scan to find the highest scoring subset of records (see demo_mdss_detector.ipynb for example usage)\n\n    :param X (dataframe): the dataset (containing the features) the model was trained on\n    :param y_true (series): ground truth (correct) target values\n    :param y_pred (series,  dataframe, optional): pandas series estimated targets\n        as returned by a model for binary, continuous and ordinal modes.\n        If mode is nominal, this is a dataframe with columns containing expectations/predictions for each nominal class.\n        If None, model is assumed to be a dumb model that predicts the mean of the targets\n                or 1/(num of categories) for nominal mode.\n    :param pos_label (str, float, optional): Should be high or low or float if the mode in [binary, ordinal, or continuous].\n            If float, value has to be minimum or maximum in the y_true column. Defaults to high if None for these modes.\n            Support for float left in to keep the intuition clear in binary classification tasks.\n            If mode is nominal, favorable values should be one of the unique categories in the y_true column.\n            Defaults to a one-vs-all scan if None for nominal mode.\n    :param overpredicted (bool, optional): flag for group to scan for.\n        True means we scan for a group whose expectations/predictions are systematically higher than observed.\n        In other words, True means we scan for a group whose observeed is systematically lower than the expectations.\n        False means we scan for a group whose expectations/predictions are systematically lower than observed.\n        In other words, False means we scan for a group whose observed is systematically higher than the expectations.\n    :param scoring (str or class): One of 'Bernoulli', 'Gaussian', 'Poisson', or 'BerkJones' or subclass of\n            :class:`aif360.metrics.mdss.ScoringFunctions.ScoringFunction`.\n    :param num_iters (int, optional): number of iterations (random restarts). Should be positive.\n    :param penalty (float,optional): penalty term. Should be positive. The penalty term as with any regularization parameter may need to be\n        tuned for ones use case. The higher the penalty, the less complex (number of features and feature values) the\n        highest scoring subset that gets returned is.\n    :param mode: one of ['binary', 'continuous', 'nominal', 'ordinal']. Defaults to binary.\n            In nominal mode, up to 10 categories are supported by default.\n            To increase this, pass in keyword argument max_nominal = integer value.\n\n     :returns: the highest scoring subset and the score or dict of the highest scoring subset and the score for each category in nominal mode\n    \"\"\"", "\n", "return", "bias_scan", "(", "\n", "data", "=", "X", ",", "\n", "observations", "=", "y_true", ",", "\n", "expectations", "=", "y_pred", ",", "\n", "favorable_value", "=", "pos_label", ",", "\n", "overpredicted", "=", "overpredicted", ",", "\n", "scoring", "=", "scoring", ",", "\n", "num_iters", "=", "num_iters", ",", "\n", "penalty", "=", "penalty", ",", "\n", "mode", "=", "mode", ",", "\n", "kwargs", "=", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.detectors.mdss_detector.bias_scan": [[15, 158], ["list", "aif360.detectors.mdss.MDSS.MDSS", "aif360.detectors.mdss.MDSS.MDSS.scan", "observations.fillna.min", "observations.fillna.max", "observations.fillna.unique", "pandas.Series", "aif360.detectors.mdss.ScoringFunctions.Bernoulli", "pandas.Series", "observations.fillna.mean", "aif360.detectors.mdss.ScoringFunctions.BerkJones", "set", "len", "kwargs.get", "aif360.detectors.mdss.ScoringFunctions.Gaussian", "sorted", "set", "pandas.Series", "observations.fillna.map", "observations.fillna.fillna", "isinstance", "observations.fillna.copy", "pd.Series.copy", "aif360.detectors.mdss.ScoringFunctions.Poisson", "scoring.", "observations.fillna.unique", "sorted", "observations.copy.map", "observations.fillna.fillna", "isinstance", "aif360.detectors.mdss.MDSS.MDSS", "aif360.detectors.mdss.MDSS.MDSS.scan", "observations.fillna.nunique"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.scan", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.scan"], ["def", "bias_scan", "(", "\n", "data", ":", "pd", ".", "DataFrame", ",", "\n", "observations", ":", "pd", ".", "Series", ",", "\n", "expectations", ":", "Union", "[", "pd", ".", "Series", ",", "pd", ".", "DataFrame", "]", "=", "None", ",", "\n", "favorable_value", ":", "Union", "[", "str", ",", "float", "]", "=", "None", ",", "\n", "overpredicted", ":", "bool", "=", "True", ",", "\n", "scoring", ":", "Union", "[", "str", ",", "ScoringFunction", "]", "=", "\"Bernoulli\"", ",", "\n", "num_iters", ":", "int", "=", "10", ",", "\n", "penalty", ":", "float", "=", "1e-17", ",", "\n", "mode", ":", "str", "=", "\"binary\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    scan to find the highest scoring subset of records\n\n    :param data (dataframe): the dataset (containing the features) the model was trained on\n    :param observations (series): ground truth (correct) target values\n    :param expectations (series,  dataframe, optional): pandas series estimated targets\n        as returned by a model for binary, continuous and ordinal modes.\n        If mode is nominal, this is a dataframe with columns containing expectations for each nominal class.\n        If None, model is assumed to be a dumb model that predicts the mean of the targets\n                or 1/(num of categories) for nominal mode.\n    :param favorable_value(str, float, optional): Should be high or low or float if the mode in [binary, ordinal, or continuous].\n            If float, value has to be minimum or maximum in the observations column. Defaults to high if None for these modes.\n            Support for float left in to keep the intuition clear in binary classification tasks.\n            If mode is nominal, favorable values should be one of the unique categories in the observations.\n            Defaults to a one-vs-all scan if None for nominal mode.\n    :param overpredicted (bool, optional): flag for group to scan for.\n        True means we scan for a group whose expectations/predictions are systematically higher than observed.\n        In other words, True means we scan for a group whose observeed is systematically lower than the expectations.\n        False means we scan for a group whose expectations/predictions are systematically lower than observed.\n        In other words, False means we scan for a group whose observed is systematically higher than the expectations.\n    :param scoring (str or class): One of 'Bernoulli', 'Gaussian', 'Poisson', or 'BerkJones' or subclass of\n            :class:`aif360.metrics.mdss.ScoringFunctions.ScoringFunction`.\n    :param num_iters (int, optional): number of iterations (random restarts). Should be positive.\n    :param penalty (float,optional): penalty term. Should be positive. The penalty term as with any regularization parameter may need to be\n        tuned for ones use case. The higher the penalty, the less complex (number of features and feature values) the\n        highest scoring subset that gets returned is.\n    :param mode: one of ['binary', 'continuous', 'nominal', 'ordinal']. Defaults to binary.\n            In nominal mode, up to 10 categories are supported by default.\n            To increase this, pass in keyword argument max_nominal = integer value.\n\n    :returns: the highest scoring subset and the score or dict of the highest scoring subset and the score for each category in nominal mode\n    \"\"\"", "\n", "# Ensure correct mode is passed in.", "\n", "modes", "=", "[", "\"binary\"", ",", "\"continuous\"", ",", "\"nominal\"", ",", "\"ordinal\"", "]", "\n", "assert", "mode", "in", "modes", ",", "f\"Expected one of {modes}, got {mode}.\"", "\n", "\n", "# Set correct favorable value (this tells us if higher or lower is better)", "\n", "min_val", ",", "max_val", "=", "observations", ".", "min", "(", ")", ",", "observations", ".", "max", "(", ")", "\n", "uniques", "=", "list", "(", "observations", ".", "unique", "(", ")", ")", "\n", "\n", "if", "favorable_value", "==", "'high'", ":", "\n", "        ", "favorable_value", "=", "max_val", "\n", "", "elif", "favorable_value", "==", "'low'", ":", "\n", "        ", "favorable_value", "=", "min_val", "\n", "", "elif", "favorable_value", "is", "None", ":", "\n", "        ", "if", "mode", "in", "[", "\"binary\"", ",", "\"ordinal\"", ",", "\"continuous\"", "]", ":", "\n", "            ", "favorable_value", "=", "max_val", "# Default to higher is better", "\n", "", "elif", "mode", "==", "\"nominal\"", ":", "\n", "            ", "favorable_value", "=", "\"flag-all\"", "# Default to scan through all categories", "\n", "assert", "favorable_value", "in", "[", "\n", "\"flag-all\"", ",", "\n", "*", "uniques", ",", "\n", "]", ",", "f\"Expected one of {uniques}, got {favorable_value}.\"", "\n", "\n", "", "", "assert", "favorable_value", "in", "[", "\n", "min_val", ",", "\n", "max_val", ",", "\n", "\"flag-all\"", ",", "\n", "*", "uniques", ",", "\n", "]", ",", "f\"Favorable_value should be high, low, or one of categories {uniques}, got {favorable_value}.\"", "\n", "\n", "# Set appropriate direction for scanner depending on mode and overppredicted flag", "\n", "if", "mode", "in", "[", "\"ordinal\"", ",", "\"continuous\"", "]", ":", "\n", "        ", "if", "favorable_value", "==", "max_val", ":", "\n", "            ", "kwargs", "[", "\"direction\"", "]", "=", "\"negative\"", "if", "overpredicted", "else", "\"positive\"", "\n", "", "else", ":", "\n", "            ", "kwargs", "[", "\"direction\"", "]", "=", "\"positive\"", "if", "overpredicted", "else", "\"negative\"", "\n", "", "", "else", ":", "\n", "        ", "kwargs", "[", "\"direction\"", "]", "=", "\"negative\"", "if", "overpredicted", "else", "\"positive\"", "\n", "\n", "# Set expectations to mean targets for non-nominal modes", "\n", "", "if", "expectations", "is", "None", "and", "mode", "!=", "\"nominal\"", ":", "\n", "        ", "expectations", "=", "pd", ".", "Series", "(", "observations", ".", "mean", "(", ")", ",", "index", "=", "observations", ".", "index", ")", "\n", "\n", "# Set appropriate scoring function", "\n", "", "if", "scoring", "==", "\"Bernoulli\"", ":", "\n", "        ", "scoring", "=", "Bernoulli", "(", "**", "kwargs", ")", "\n", "", "elif", "scoring", "==", "\"BerkJones\"", ":", "\n", "        ", "scoring", "=", "BerkJones", "(", "**", "kwargs", ")", "\n", "", "elif", "scoring", "==", "\"Gaussian\"", ":", "\n", "        ", "scoring", "=", "Gaussian", "(", "**", "kwargs", ")", "\n", "", "elif", "scoring", "==", "\"Poisson\"", ":", "\n", "        ", "scoring", "=", "Poisson", "(", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "scoring", "=", "scoring", "(", "**", "kwargs", ")", "\n", "\n", "", "if", "mode", "==", "\"binary\"", ":", "# Flip observations if favorable_value is 0 in binary mode.", "\n", "        ", "observations", "=", "pd", ".", "Series", "(", "observations", "==", "favorable_value", ",", "dtype", "=", "int", ")", "\n", "", "elif", "mode", "==", "\"nominal\"", ":", "\n", "        ", "unique_outs", "=", "set", "(", "sorted", "(", "observations", ".", "unique", "(", ")", ")", ")", "\n", "size_unique_outs", "=", "len", "(", "unique_outs", ")", "\n", "if", "expectations", "is", "not", "None", ":", "# Set expectations to 1/(num of categories) for nominal mode", "\n", "            ", "expectations_cols", "=", "set", "(", "sorted", "(", "expectations", ".", "columns", ")", ")", "\n", "assert", "(", "\n", "unique_outs", "==", "expectations_cols", "\n", ")", ",", "f\"Expected {unique_outs} in expectation columns, got {expectations_cols}\"", "\n", "", "else", ":", "\n", "            ", "expectations", "=", "pd", ".", "Series", "(", "\n", "1", "/", "observations", ".", "nunique", "(", ")", ",", "index", "=", "observations", ".", "index", "\n", ")", "\n", "", "max_nominal", "=", "kwargs", ".", "get", "(", "\"max_nominal\"", ",", "10", ")", "\n", "\n", "assert", "(", "\n", "size_unique_outs", "<=", "max_nominal", "\n", ")", ",", "f\"Nominal mode only support up to {max_nominal} labels, got {size_unique_outs}. Use keyword argument max_nominal to increase the limit.\"", "\n", "\n", "if", "favorable_value", "!=", "\"flag-all\"", ":", "# If favorable flag is set, use one-vs-others strategy to scan, else use one-vs-all strategy", "\n", "            ", "observations", "=", "observations", ".", "map", "(", "{", "favorable_value", ":", "1", "}", ")", "\n", "observations", "=", "observations", ".", "fillna", "(", "0", ")", "\n", "if", "isinstance", "(", "expectations", ",", "pd", ".", "DataFrame", ")", ":", "\n", "                ", "expectations", "=", "expectations", "[", "favorable_value", "]", "\n", "", "", "else", ":", "\n", "            ", "results", "=", "{", "}", "\n", "orig_observations", "=", "observations", ".", "copy", "(", ")", "\n", "orig_expectations", "=", "expectations", ".", "copy", "(", ")", "\n", "for", "unique", "in", "uniques", ":", "\n", "                ", "observations", "=", "orig_observations", ".", "map", "(", "{", "unique", ":", "1", "}", ")", "\n", "observations", "=", "observations", ".", "fillna", "(", "0", ")", "\n", "\n", "if", "isinstance", "(", "expectations", ",", "pd", ".", "DataFrame", ")", ":", "\n", "                    ", "expectations", "=", "orig_expectations", "[", "unique", "]", "\n", "\n", "", "scanner", "=", "MDSS", "(", "scoring", ")", "\n", "result", "=", "scanner", ".", "scan", "(", "\n", "data", ",", "expectations", ",", "observations", ",", "penalty", ",", "num_iters", ",", "mode", "=", "mode", "\n", ")", "\n", "results", "[", "unique", "]", "=", "result", "\n", "", "return", "results", "\n", "\n", "", "", "scanner", "=", "MDSS", "(", "scoring", ")", "\n", "return", "scanner", ".", "scan", "(", "data", ",", "expectations", ",", "observations", ",", "penalty", ",", "num_iters", ",", "mode", "=", "mode", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.difference": [[37, 78], ["aif360.sklearn.utils.check_groups", "map", "map", "sklearn.metrics.recall_score", "sklearn.metrics.recall_score", "metrics.specificity_score", "sklearn.metrics.recall_score", "metrics.specificity_score"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.specificity_score", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.specificity_score"], ["def", "difference", "(", "func", ",", "y", ",", "*", "args", ",", "prot_attr", "=", "None", ",", "priv_group", "=", "1", ",", "sample_weight", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Compute the difference between unprivileged and privileged subsets for an\n    arbitrary metric.\n\n    Note: The optimal value of a difference is 0. To make it a scorer, one must\n    take the absolute value and set greater_is_better to False.\n\n    Unprivileged group is taken to be the inverse of the privileged group.\n\n    Args:\n        func (function): A metric function from :mod:`sklearn.metrics` or\n            :mod:`aif360.sklearn.metrics.metrics`.\n        y (pandas.Series): Outcome vector with protected attributes as index.\n        *args: Additional positional args to be passed through to func.\n        prot_attr (array-like, keyword-only): Protected attribute(s). If\n            ``None``, all protected attributes in y are used.\n        priv_group (scalar, optional): The label of the privileged group.\n        sample_weight (array-like, optional): Sample weights passed through to\n            func.\n        **kwargs: Additional keyword args to be passed through to func.\n\n    Returns:\n        scalar: Difference in metric value for unprivileged and privileged\n        groups.\n\n    Examples:\n        >>> X, y = fetch_german(numeric_only=True)\n        >>> y_pred = LogisticRegression().fit(X, y).predict(X)\n        >>> difference(precision_score, y, y_pred, prot_attr='sex',\n        ... priv_group='male')\n        -0.06955430006277463\n    \"\"\"", "\n", "groups", ",", "_", "=", "check_groups", "(", "y", ",", "prot_attr", ")", "\n", "idx", "=", "(", "groups", "==", "priv_group", ")", "\n", "unpriv", "=", "map", "(", "lambda", "a", ":", "a", "[", "~", "idx", "]", ",", "(", "y", ",", ")", "+", "args", ")", "\n", "priv", "=", "map", "(", "lambda", "a", ":", "a", "[", "idx", "]", ",", "(", "y", ",", ")", "+", "args", ")", "\n", "if", "sample_weight", "is", "not", "None", ":", "\n", "        ", "return", "(", "func", "(", "*", "unpriv", ",", "sample_weight", "=", "sample_weight", "[", "~", "idx", "]", ",", "**", "kwargs", ")", "\n", "-", "func", "(", "*", "priv", ",", "sample_weight", "=", "sample_weight", "[", "idx", "]", ",", "**", "kwargs", ")", ")", "\n", "", "return", "func", "(", "*", "unpriv", ",", "**", "kwargs", ")", "-", "func", "(", "*", "priv", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.ratio": [[79, 127], ["sklearn.metrics._classification._check_zero_division", "aif360.sklearn.utils.check_groups", "map", "map", "sklearn.metrics._classification._prf_divide().item", "func", "func", "func", "func", "sklearn.metrics._classification._prf_divide", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups"], ["", "def", "ratio", "(", "func", ",", "y", ",", "*", "args", ",", "prot_attr", "=", "None", ",", "priv_group", "=", "1", ",", "sample_weight", "=", "None", ",", "\n", "zero_division", "=", "'warn'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Compute the ratio between unprivileged and privileged subsets for an\n    arbitrary metric.\n\n    Note: The optimal value of a ratio is 1. To make it a scorer, one must\n    take the minimum of the ratio and its inverse.\n\n    Unprivileged group is taken to be the inverse of the privileged group.\n\n    Args:\n        func (function): A metric function from :mod:`sklearn.metrics` or\n            :mod:`aif360.sklearn.metrics.metrics`.\n        y (pandas.Series): Outcome vector with protected attributes as index.\n        *args: Additional positional args to be passed through to func.\n        prot_attr (array-like, keyword-only): Protected attribute(s). If\n            ``None``, all protected attributes in y are used.\n        priv_group (scalar, optional): The label of the privileged group.\n        sample_weight (array-like, optional): Sample weights passed through to\n            func.\n        zero_division ('warn', 0 or 1): Sets the value to return when there is a\n            zero division. If set to \u201cwarn\u201d, this acts as 0, but warnings are\n            also raised.\n        **kwargs: Additional keyword args to be passed through to func.\n\n    Returns:\n        scalar: Ratio of metric values for unprivileged and privileged groups.\n    \"\"\"", "\n", "_check_zero_division", "(", "zero_division", ")", "\n", "groups", ",", "_", "=", "check_groups", "(", "y", ",", "prot_attr", ")", "\n", "idx", "=", "(", "groups", "==", "priv_group", ")", "\n", "unpriv", "=", "map", "(", "lambda", "a", ":", "a", "[", "~", "idx", "]", ",", "(", "y", ",", ")", "+", "args", ")", "\n", "priv", "=", "map", "(", "lambda", "a", ":", "a", "[", "idx", "]", ",", "(", "y", ",", ")", "+", "args", ")", "\n", "if", "sample_weight", "is", "not", "None", ":", "\n", "        ", "numerator", "=", "func", "(", "*", "unpriv", ",", "sample_weight", "=", "sample_weight", "[", "~", "idx", "]", ",", "**", "kwargs", ")", "\n", "denominator", "=", "func", "(", "*", "priv", ",", "sample_weight", "=", "sample_weight", "[", "idx", "]", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "numerator", "=", "func", "(", "*", "unpriv", ",", "**", "kwargs", ")", "\n", "denominator", "=", "func", "(", "*", "priv", ",", "**", "kwargs", ")", "\n", "\n", "", "if", "func", "==", "base_rate", ":", "\n", "        ", "modifier", "=", "'positive privileged'", "\n", "", "elif", "func", "==", "selection_rate", ":", "\n", "        ", "modifier", "=", "'predicted privileged'", "\n", "", "else", ":", "\n", "        ", "modifier", "=", "f'value for {func.__name__} on privileged'", "\n", "", "return", "_prf_divide", "(", "np", ".", "array", "(", "[", "numerator", "]", ")", ",", "np", ".", "array", "(", "[", "denominator", "]", ")", ",", "'ratio'", ",", "\n", "modifier", ",", "None", ",", "(", "'ratio'", ",", ")", ",", "zero_division", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer": [[130, 157], ["sklearn.metrics.make_scorer", "sklearn.metrics.make_scorer", "score_func", "min", "score_func", "abs", "numpy.finfo"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.make_scorer"], ["", "def", "make_scorer", "(", "score_func", ",", "is_ratio", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Make a scorer from a 'difference' or 'ratio' metric (e.g.\n    :func:`statistical_parity_difference`).\n\n    Args:\n        score_func (callable): A ratio/difference metric with signature\n            ``score_func(y, y_pred, **kwargs)``.\n        is_ratio (boolean, optional): Indicates if the metric is ratio or\n        difference based.\n    \"\"\"", "\n", "if", "is_ratio", ":", "\n", "\n", "        ", "def", "score", "(", "y", ",", "y_pred", ",", "**", "kwargs", ")", ":", "\n", "            ", "ratio", "=", "score_func", "(", "y", ",", "y_pred", ",", "**", "kwargs", ")", "\n", "eps", "=", "np", ".", "finfo", "(", "float", ")", ".", "eps", "\n", "ratio_inverse", "=", "1", "/", "ratio", "if", "ratio", ">", "eps", "else", "eps", "\n", "return", "min", "(", "ratio", ",", "ratio_inverse", ")", "\n", "\n", "", "scorer", "=", "_make_scorer", "(", "score", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "\n", "        ", "def", "score", "(", "y", ",", "y_pred", ",", "**", "kwargs", ")", ":", "\n", "            ", "diff", "=", "score_func", "(", "y", ",", "y_pred", ",", "**", "kwargs", ")", "\n", "return", "abs", "(", "diff", ")", "\n", "\n", "", "scorer", "=", "_make_scorer", "(", "score", ",", "greater_is_better", "=", "False", ",", "**", "kwargs", ")", "\n", "", "return", "scorer", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.specificity_score": [[159, 179], ["sklearn.metrics._classification._check_zero_division", "sklearn.metrics.multilabel_confusion_matrix", "sklearn.metrics._classification._prf_divide().item", "sklearn.metrics._classification._prf_divide"], "function", ["None"], ["", "def", "specificity_score", "(", "y_true", ",", "y_pred", ",", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ",", "\n", "zero_division", "=", "'warn'", ")", ":", "\n", "    ", "\"\"\"Compute the specificity or true negative rate.\n\n    Args:\n        y_true (array-like): Ground truth (correct) target values.\n        y_pred (array-like): Estimated targets as returned by a classifier.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n        zero_division ('warn', 0 or 1): Sets the value to return when there is a\n            zero division. If set to \u201cwarn\u201d, this acts as 0, but warnings are\n            also raised.\n    \"\"\"", "\n", "_check_zero_division", "(", "zero_division", ")", "\n", "MCM", "=", "multilabel_confusion_matrix", "(", "y_true", ",", "y_pred", ",", "labels", "=", "[", "pos_label", "]", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "tn", ",", "fp", "=", "MCM", "[", ":", ",", "0", ",", "0", "]", ",", "MCM", "[", ":", ",", "0", ",", "1", "]", "\n", "negs", "=", "tn", "+", "fp", "\n", "return", "_prf_divide", "(", "tn", ",", "negs", ",", "'specificity'", ",", "'negative'", ",", "None", ",", "\n", "(", "'specificity'", ",", ")", ",", "zero_division", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.base_rate": [[180, 194], ["numpy.average"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "base_rate", "(", "y_true", ",", "y_pred", "=", "None", ",", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "    ", "r\"\"\"Compute the base rate, :math:`Pr(Y = \\text{pos_label}) = \\frac{P}{P+N}`.\n\n    Args:\n        y_true (array-like): Ground truth (correct) target values.\n        y_pred (array-like, optional): Estimated targets. Ignored.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n\n    Returns:\n        float: Base rate.\n    \"\"\"", "\n", "idx", "=", "(", "y_true", "==", "pos_label", ")", "\n", "return", "np", ".", "average", "(", "idx", ",", "weights", "=", "sample_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.selection_rate": [[195, 209], ["metrics.base_rate"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate"], ["", "def", "selection_rate", "(", "y_true", ",", "y_pred", ",", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "    ", "r\"\"\"Compute the selection rate, :math:`Pr(\\hat{Y} = \\text{pos_label}) =\n    \\frac{TP + FP}{P + N}`.\n\n    Args:\n        y_true (array-like): Ground truth (correct) target values. Ignored.\n        y_pred (array-like): Estimated targets as returned by a classifier.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n\n    Returns:\n        float: Selection rate.\n    \"\"\"", "\n", "return", "base_rate", "(", "y_pred", ",", "pos_label", "=", "pos_label", ",", "sample_weight", "=", "sample_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_fpr": [[210, 243], ["sklearn.metrics._classification._check_zero_division", "sklearn.metrics._classification._prf_divide().item", "sklearn.utils.validation.column_or_1d", "sklearn.utils.validation.column_or_1d", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "sklearn.metrics._classification._prf_divide", "gfps.sum", "len", "numpy.dot", "sample_weight[].sum"], "function", ["None"], ["", "def", "generalized_fpr", "(", "y_true", ",", "probas_pred", ",", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ",", "\n", "zero_division", "=", "'warn'", ")", ":", "\n", "    ", "r\"\"\"Return the ratio of generalized false positives to negative examples in\n    the dataset, :math:`GFPR = \\tfrac{GFP}{N}`.\n\n    Generalized confusion matrix measures such as this are calculated by summing\n    the probabilities of the positive class instead of the hard predictions.\n\n    Args:\n        y_true (array-like): Ground-truth (correct) target values.\n        probas_pred (array-like): Probability estimates of the positive class.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n        zero_division ('warn', 0 or 1): Sets the value to return when there is a\n            zero division. If set to \u201cwarn\u201d, this acts as 0, but warnings are\n            also raised.\n\n    Returns:\n        float: Generalized false positive rate.\n    \"\"\"", "\n", "_check_zero_division", "(", "zero_division", ")", "\n", "y_true", ",", "probas_pred", "=", "column_or_1d", "(", "y_true", ")", ",", "column_or_1d", "(", "probas_pred", ")", "\n", "\n", "idx", "=", "(", "y_true", "!=", "pos_label", ")", "\n", "gfps", "=", "probas_pred", "[", "idx", "]", "\n", "if", "sample_weight", "is", "None", ":", "\n", "        ", "gfp", "=", "np", ".", "array", "(", "[", "gfps", ".", "sum", "(", ")", "]", ")", "\n", "neg", "=", "np", ".", "array", "(", "[", "len", "(", "gfps", ")", "]", ")", "\n", "", "else", ":", "\n", "        ", "gfp", "=", "np", ".", "array", "(", "[", "np", ".", "dot", "(", "gfps", ",", "sample_weight", "[", "idx", "]", ")", "]", ")", "\n", "neg", "=", "np", ".", "array", "(", "[", "sample_weight", "[", "idx", "]", ".", "sum", "(", ")", "]", ")", "\n", "", "return", "_prf_divide", "(", "gfp", ",", "neg", ",", "'generalized FPR'", ",", "'negative'", ",", "None", ",", "\n", "(", "'generalized FPR'", ",", ")", ",", "zero_division", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_fnr": [[244, 277], ["sklearn.metrics._classification._check_zero_division", "sklearn.metrics._classification._prf_divide().item", "sklearn.utils.validation.column_or_1d", "sklearn.utils.validation.column_or_1d", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "sklearn.metrics._classification._prf_divide", "gfns.sum", "len", "numpy.dot", "sample_weight[].sum"], "function", ["None"], ["", "def", "generalized_fnr", "(", "y_true", ",", "probas_pred", ",", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ",", "\n", "zero_division", "=", "'warn'", ")", ":", "\n", "    ", "r\"\"\"Return the ratio of generalized false negatives to positive examples in\n    the dataset, :math:`GFNR = \\tfrac{GFN}{P}`.\n\n    Generalized confusion matrix measures such as this are calculated by summing\n    the probabilities of the positive class instead of the hard predictions.\n\n    Args:\n        y_true (array-like): Ground-truth (correct) target values.\n        probas_pred (array-like): Probability estimates of the positive class.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n        zero_division ('warn', 0 or 1): Sets the value to return when there is a\n            zero division. If set to \u201cwarn\u201d, this acts as 0, but warnings are\n            also raised.\n\n    Returns:\n        float: Generalized false negative rate.\n    \"\"\"", "\n", "_check_zero_division", "(", "zero_division", ")", "\n", "y_true", ",", "probas_pred", "=", "column_or_1d", "(", "y_true", ")", ",", "column_or_1d", "(", "probas_pred", ")", "\n", "\n", "idx", "=", "(", "y_true", "==", "pos_label", ")", "\n", "gfns", "=", "1", "-", "probas_pred", "[", "idx", "]", "\n", "if", "sample_weight", "is", "None", ":", "\n", "        ", "gfn", "=", "np", ".", "array", "(", "[", "gfns", ".", "sum", "(", ")", "]", ")", "\n", "pos", "=", "np", ".", "array", "(", "[", "len", "(", "gfns", ")", "]", ")", "\n", "", "else", ":", "\n", "        ", "gfn", "=", "np", ".", "array", "(", "[", "np", ".", "dot", "(", "gfns", ",", "sample_weight", "[", "idx", "]", ")", "]", ")", "\n", "pos", "=", "np", ".", "array", "(", "[", "sample_weight", "[", "idx", "]", ".", "sum", "(", ")", "]", ")", "\n", "", "return", "_prf_divide", "(", "gfn", ",", "pos", ",", "'generalized FNR'", ",", "'positive'", ",", "None", ",", "\n", "(", "'generalized FNR'", ",", ")", ",", "zero_division", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.statistical_parity_difference": [[280, 313], ["metrics.difference", "len"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "statistical_parity_difference", "(", "*", "y", ",", "prot_attr", "=", "None", ",", "priv_group", "=", "1", ",", "pos_label", "=", "1", ",", "\n", "sample_weight", "=", "None", ")", ":", "\n", "    ", "r\"\"\"Difference in selection rates.\n\n    .. math::\n        Pr(\\hat{Y} = \\text{pos_label} | D = \\text{unprivileged})\n        - Pr(\\hat{Y} = \\text{pos_label} | D = \\text{privileged})\n\n    Note:\n        If only y_true is provided, this will return the difference in base\n        rates (statistical parity difference of the original dataset). If both\n        y_true and y_pred are provided, only y_pred is used.\n\n    Args:\n        y_true (pandas.Series): Ground truth (correct) target values. If y_pred\n            is provided, this is ignored.\n        y_pred (array-like, optional): Estimated targets as returned by a\n            classifier.\n        prot_attr (array-like, keyword-only): Protected attribute(s). If\n            ``None``, all protected attributes in y_true are used.\n        priv_group (scalar, optional): The label of the privileged group.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n\n    Returns:\n        float: Statistical parity difference.\n\n    See also:\n        :func:`selection_rate`, :func:`base_rate`\n    \"\"\"", "\n", "rate", "=", "base_rate", "if", "len", "(", "y", ")", "==", "1", "or", "y", "[", "1", "]", "is", "None", "else", "selection_rate", "\n", "return", "difference", "(", "rate", ",", "*", "y", ",", "prot_attr", "=", "prot_attr", ",", "priv_group", "=", "priv_group", ",", "\n", "pos_label", "=", "pos_label", ",", "sample_weight", "=", "sample_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.disparate_impact_ratio": [[314, 351], ["metrics.ratio", "len"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio"], ["", "def", "disparate_impact_ratio", "(", "*", "y", ",", "prot_attr", "=", "None", ",", "priv_group", "=", "1", ",", "pos_label", "=", "1", ",", "\n", "sample_weight", "=", "None", ",", "zero_division", "=", "'warn'", ")", ":", "\n", "    ", "r\"\"\"Ratio of selection rates.\n\n    .. math::\n        \\frac{Pr(\\hat{Y} = \\text{pos_label} | D = \\text{unprivileged})}\n        {Pr(\\hat{Y} = \\text{pos_label} | D = \\text{privileged})}\n\n    Note:\n        If only y_true is provided, this will return the ratio of base rates\n        (disparate impact of the original dataset). If both y_true and y_pred\n        are provided, only y_pred is used.\n\n    Args:\n        y_true (pandas.Series): Ground truth (correct) target values. If y_pred\n            is provided, this is ignored.\n        y_pred (array-like, optional): Estimated targets as returned by a\n            classifier.\n        prot_attr (array-like, keyword-only): Protected attribute(s). If\n            ``None``, all protected attributes in y_true are used.\n        priv_group (scalar, optional): The label of the privileged group.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n        zero_division ('warn', 0 or 1): Sets the value to return when there is a\n            zero division. If set to \u201cwarn\u201d, this acts as 0, but warnings are\n            also raised.\n\n    Returns:\n        float: Disparate impact.\n\n    See also:\n        :func:`selection_rate`, :func:`base_rate`\n    \"\"\"", "\n", "rate", "=", "base_rate", "if", "len", "(", "y", ")", "==", "1", "or", "y", "[", "1", "]", "is", "None", "else", "selection_rate", "\n", "return", "ratio", "(", "rate", ",", "*", "y", ",", "prot_attr", "=", "prot_attr", ",", "priv_group", "=", "priv_group", ",", "\n", "pos_label", "=", "pos_label", ",", "sample_weight", "=", "sample_weight", ",", "\n", "zero_division", "=", "zero_division", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.equal_opportunity_difference": [[352, 377], ["metrics.difference"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "equal_opportunity_difference", "(", "y_true", ",", "y_pred", ",", "prot_attr", "=", "None", ",", "priv_group", "=", "1", ",", "\n", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "    ", "r\"\"\"A relaxed version of equality of opportunity.\n\n    Returns the difference in recall scores (TPR) between the unprivileged and\n    privileged groups. A value of 0 indicates equality of opportunity.\n\n    Args:\n        y_true (pandas.Series): Ground truth (correct) target values.\n        y_pred (array-like): Estimated targets as returned by a classifier.\n        prot_attr (array-like, keyword-only): Protected attribute(s). If\n            ``None``, all protected attributes in y_true are used.\n        priv_group (scalar, optional): The label of the privileged group.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n\n    Returns:\n        float: Equal opportunity difference.\n\n    See also:\n        :func:`~sklearn.metrics.recall_score`\n    \"\"\"", "\n", "return", "difference", "(", "recall_score", ",", "y_true", ",", "y_pred", ",", "prot_attr", "=", "prot_attr", ",", "\n", "priv_group", "=", "priv_group", ",", "pos_label", "=", "pos_label", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.average_odds_difference": [[378, 411], ["metrics.difference", "metrics.difference"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "average_odds_difference", "(", "y_true", ",", "y_pred", ",", "prot_attr", "=", "None", ",", "priv_group", "=", "1", ",", "\n", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "    ", "r\"\"\"A relaxed version of equality of odds.\n\n    Returns the average of the difference in FPR and TPR for the unprivileged\n    and privileged groups:\n\n    .. math::\n\n        \\dfrac{(FPR_{D = \\text{unprivileged}} - FPR_{D = \\text{privileged}})\n        + (TPR_{D = \\text{unprivileged}} - TPR_{D = \\text{privileged}})}{2}\n\n    A value of 0 indicates equality of odds.\n\n    Args:\n        y_true (pandas.Series): Ground truth (correct) target values.\n        y_pred (array-like): Estimated targets as returned by a classifier.\n        prot_attr (array-like, keyword-only): Protected attribute(s). If\n            ``None``, all protected attributes in y_true are used.\n        priv_group (scalar, optional): The label of the privileged group.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n\n    Returns:\n        float: Average odds difference.\n    \"\"\"", "\n", "fpr_diff", "=", "-", "difference", "(", "specificity_score", ",", "y_true", ",", "y_pred", ",", "\n", "prot_attr", "=", "prot_attr", ",", "priv_group", "=", "priv_group", ",", "\n", "pos_label", "=", "pos_label", ",", "sample_weight", "=", "sample_weight", ")", "\n", "tpr_diff", "=", "difference", "(", "recall_score", ",", "y_true", ",", "y_pred", ",", "prot_attr", "=", "prot_attr", ",", "\n", "priv_group", "=", "priv_group", ",", "pos_label", "=", "pos_label", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "return", "(", "tpr_diff", "+", "fpr_diff", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.average_odds_error": [[412, 449], ["metrics.difference", "metrics.difference", "abs", "abs", "aif360.sklearn.utils.check_groups"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups"], ["", "def", "average_odds_error", "(", "y_true", ",", "y_pred", ",", "prot_attr", "=", "None", ",", "priv_group", "=", "None", ",", "\n", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "    ", "r\"\"\"A relaxed version of equality of odds.\n\n    Returns the average of the absolute difference in FPR and TPR for the\n    unprivileged and privileged groups:\n\n    .. math::\n\n        \\dfrac{|FPR_{D = \\text{unprivileged}} - FPR_{D = \\text{privileged}}|\n        + |TPR_{D = \\text{unprivileged}} - TPR_{D = \\text{privileged}}|}{2}\n\n    A value of 0 indicates equality of odds.\n\n    Args:\n        y_true (pandas.Series): Ground truth (correct) target values.\n        y_pred (array-like): Estimated targets as returned by a classifier.\n        prot_attr (array-like, keyword-only): Protected attribute(s). If\n            ``None``, all protected attributes in y_true are used.\n        priv_group (scalar, optional): The label of the privileged group. If\n            prot_attr is binary, this may be ``None``.\n        pos_label (scalar, optional): The label of the positive class.\n        sample_weight (array-like, optional): Sample weights.\n\n    Returns:\n        float: Average odds error.\n    \"\"\"", "\n", "if", "priv_group", "is", "None", ":", "\n", "        ", "priv_group", "=", "check_groups", "(", "y_true", ",", "prot_attr", "=", "prot_attr", ",", "\n", "ensure_binary", "=", "True", ")", "[", "0", "]", "[", "0", "]", "\n", "", "fpr_diff", "=", "-", "difference", "(", "specificity_score", ",", "y_true", ",", "y_pred", ",", "\n", "prot_attr", "=", "prot_attr", ",", "priv_group", "=", "priv_group", ",", "\n", "pos_label", "=", "pos_label", ",", "sample_weight", "=", "sample_weight", ")", "\n", "tpr_diff", "=", "difference", "(", "recall_score", ",", "y_true", ",", "y_pred", ",", "prot_attr", "=", "prot_attr", ",", "\n", "priv_group", "=", "priv_group", ",", "pos_label", "=", "pos_label", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "return", "(", "abs", "(", "tpr_diff", ")", "+", "abs", "(", "fpr_diff", ")", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.mdss_bias_score": [[451, 507], ["pandas.Series().reset_index", "pandas.Series().reset_index", "aif360.detectors.mdss.MDSS.MDSS", "aif360.detectors.mdss.MDSS.MDSS.score_current_subset", "pandas.DataFrame", "X.reset_index.reset_index", "aif360.detectors.mdss.ScoringFunctions.Bernoulli", "pandas.Series", "pandas.Series", "aif360.detectors.mdss.ScoringFunctions.BerkJones", "scoring", "range", "len"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.score_current_subset", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "mdss_bias_score", "(", "y_true", ",", "probas_pred", ",", "X", "=", "None", ",", "subset", "=", "None", ",", "*", ",", "pos_label", "=", "1", ",", "\n", "scoring", "=", "'Bernoulli'", ",", "privileged", "=", "True", ",", "penalty", "=", "1e-17", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Compute the bias score for a prespecified group of records using a\n    given scoring function.\n\n    Args:\n        y_true (array-like): Ground truth (correct) target values.\n        probas_pred (array-like): Probability estimates of the positive class.\n        X (DataFrame, optional): The dataset (containing the features) that was\n            used to predict `probas_pred`. If not specified, the subset is\n            returned as indices.\n        subset (dict, optional): Mapping of column names to list of values.\n            Samples are included in the subset if they match any value in each\n            of the columns provided. If `X` is not specified, `subset` may\n            be of the form `{'index': [0, 1, ...]}` or `None`. If `None`, score\n            over the full set (note: `penalty` is irrelevant in this case).\n        pos_label (scalar, optional): Label of the positive class.\n        scoring (str or class): One of 'Bernoulli' or 'BerkJones' or\n            subclass of\n            :class:`aif360.metrics.mdss.ScoringFunctions.ScoringFunction`.\n        privileged (bool): Flag for which direction to scan: privileged\n            (``True``) implies negative (observed worse than predicted outcomes)\n            while unprivileged (``False``) implies positive (observed better\n            than predicted outcomes).\n        penalty (scalar): Penalty coefficient. Should be positive. The higher\n            the penalty, the less complex (number of features and feature\n            values) the highest scoring subset that gets returned is.\n        **kwargs: Additional kwargs to be passed to `scoring` (not including\n            `direction`).\n    Returns:\n        float: Bias score for the given group.\n    See also:\n        :func:`mdss_bias_scan`\n    \"\"\"", "\n", "\n", "if", "X", "is", "None", ":", "\n", "        ", "X", "=", "pd", ".", "DataFrame", "(", "{", "'index'", ":", "range", "(", "len", "(", "y_true", ")", ")", "}", ")", "\n", "", "else", ":", "\n", "        ", "X", "=", "X", ".", "reset_index", "(", "drop", "=", "True", ")", "# match all indices", "\n", "\n", "", "expected", "=", "pd", ".", "Series", "(", "probas_pred", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "outcomes", "=", "pd", ".", "Series", "(", "y_true", "==", "pos_label", ",", "dtype", "=", "int", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "\n", "direction", "=", "'negative'", "if", "privileged", "else", "'positive'", "\n", "kwargs", "[", "'direction'", "]", "=", "direction", "\n", "\n", "if", "scoring", "==", "'Bernoulli'", ":", "\n", "        ", "scoring_function", "=", "Bernoulli", "(", "**", "kwargs", ")", "\n", "", "elif", "scoring", "==", "'BerkJones'", ":", "\n", "        ", "scoring_function", "=", "BerkJones", "(", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "scoring_function", "=", "scoring", "(", "**", "kwargs", ")", "\n", "", "scanner", "=", "MDSS", "(", "scoring_function", ")", "\n", "\n", "return", "scanner", ".", "score_current_subset", "(", "X", ",", "expected", ",", "outcomes", ",", "subset", "or", "{", "}", ",", "penalty", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.mdss_bias_scan": [[508, 568], ["sklearn.exceptions.deprecated", "pandas.Series().reset_index", "pandas.Series().reset_index", "aif360.detectors.mdss.MDSS.MDSS", "aif360.detectors.mdss.MDSS.MDSS.scan", "pandas.DataFrame", "X.reset_index.reset_index", "aif360.detectors.mdss.ScoringFunctions.Bernoulli", "pandas.Series", "pandas.Series", "aif360.detectors.mdss.ScoringFunctions.BerkJones", "scoring", "range", "len"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.scan", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "@", "deprecated", "(", "'Change to new interface - aif360.sklearn.detectors.mdss_detector.bias_scan by version 0.5.0.'", ")", "\n", "def", "mdss_bias_scan", "(", "y_true", ",", "probas_pred", ",", "X", "=", "None", ",", "*", ",", "pos_label", "=", "1", ",", "\n", "scoring", "=", "'Bernoulli'", ",", "privileged", "=", "True", ",", "n_iter", "=", "10", ",", "\n", "penalty", "=", "1e-17", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Scan to find the highest scoring subset of records.\n\n    Bias scan is a technique to identify bias in predictive models using subset\n    scanning [#zhang16]_.\n    Args:\n        y_true (array-like): Ground truth (correct) target values.\n        probas_pred (array-like): Probability estimates of the positive class.\n        X (dataframe, optional): The dataset (containing the features) that was\n            used to predict `probas_pred`. If not specified, the subset is\n            returned as indices.\n        pos_label (scalar): Label of the positive class.\n        scoring (str or class): One of 'Bernoulli' or 'BerkJones' or\n            subclass of\n            :class:`aif360.metrics.mdss.ScoringFunctions.ScoringFunction`.\n        privileged (bool): Flag for which direction to scan: privileged\n            (``True``) implies negative (observed worse than predicted outcomes)\n            while unprivileged (``False``) implies positive (observed better\n            than predicted outcomes).\n        n_iter (scalar): Number of iterations (random restarts).\n        penalty (scalar): Penalty coefficient. Should be positive. The higher\n            the penalty, the less complex (number of features and feature\n            values) the highest scoring subset that gets returned is.\n        **kwargs: Additional kwargs to be passed to `scoring` (not including\n            `direction`).\n    Returns:\n        tuple:\n            Highest scoring subset and its bias score\n            * **subset** (dict) -- Mapping of features to values defining the\n              highest scoring subset.\n            * **score** (float) -- Bias score for that group.\n    See also:\n        :func:`mdss_bias_score`\n    References:\n        .. [#zhang16] `Zhang, Z. and Neill, D. B., \"Identifying significant\n           predictive bias in classifiers,\" arXiv preprint, 2016.\n           <https://arxiv.org/abs/1611.08292>`_\n    \"\"\"", "\n", "if", "X", "is", "None", ":", "\n", "        ", "X", "=", "pd", ".", "DataFrame", "(", "{", "'index'", ":", "range", "(", "len", "(", "y_true", ")", ")", "}", ")", "\n", "", "else", ":", "\n", "        ", "X", "=", "X", ".", "reset_index", "(", "drop", "=", "True", ")", "# match all indices", "\n", "\n", "", "expected", "=", "pd", ".", "Series", "(", "probas_pred", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "outcomes", "=", "pd", ".", "Series", "(", "y_true", "==", "pos_label", ",", "dtype", "=", "int", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "\n", "direction", "=", "'negative'", "if", "privileged", "else", "'positive'", "\n", "kwargs", "[", "'direction'", "]", "=", "direction", "\n", "if", "scoring", "==", "'Bernoulli'", ":", "\n", "        ", "scoring_function", "=", "Bernoulli", "(", "**", "kwargs", ")", "\n", "", "elif", "scoring", "==", "'BerkJones'", ":", "\n", "        ", "scoring_function", "=", "BerkJones", "(", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "scoring_function", "=", "scoring", "(", "**", "kwargs", ")", "\n", "", "scanner", "=", "MDSS", "(", "scoring_function", ")", "\n", "\n", "return", "scanner", ".", "scan", "(", "X", ",", "expected", ",", "outcomes", ",", "penalty", ",", "n_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_entropy_index": [[571, 596], ["numpy.log", "b.mean", "numpy.log", "b.mean", "b.mean", "b.mean", "b.mean"], "function", ["None"], ["", "def", "generalized_entropy_index", "(", "b", ",", "alpha", "=", "2", ")", ":", "\n", "    ", "r\"\"\"Generalized entropy index measures inequality over a population.\n\n    .. math::\n\n        \\mathcal{E}(\\alpha) = \\begin{cases}\n            \\frac{1}{n \\alpha (\\alpha-1)}\\sum_{i=1}^n\\left[\\left(\\frac{b_i}{\\mu}\\right)^\\alpha - 1\\right],& \\alpha \\ne 0, 1,\\\\\n            \\frac{1}{n}\\sum_{i=1}^n\\frac{b_{i}}{\\mu}\\ln\\frac{b_{i}}{\\mu},& \\alpha=1,\\\\\n            -\\frac{1}{n}\\sum_{i=1}^n\\ln\\frac{b_{i}}{\\mu},& \\alpha=0.\n        \\end{cases}\n\n    Args:\n        b (array-like): Parameter over which to calculate the entropy index.\n        alpha (scalar): Parameter that regulates the weight given to distances\n            between values at different parts of the distribution. A value of 0\n            is equivalent to the mean log deviation, 1 is the Theil index, and 2\n            is half the squared coefficient of variation.\n    \"\"\"", "\n", "if", "alpha", "==", "0", ":", "\n", "        ", "return", "-", "(", "np", ".", "log", "(", "b", "/", "b", ".", "mean", "(", ")", ")", "/", "b", ".", "mean", "(", ")", ")", ".", "mean", "(", ")", "\n", "", "elif", "alpha", "==", "1", ":", "\n", "# moving the b inside the log allows for 0 values", "\n", "        ", "return", "(", "np", ".", "log", "(", "(", "b", "/", "b", ".", "mean", "(", ")", ")", "**", "b", ")", "/", "b", ".", "mean", "(", ")", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "(", "b", "/", "b", ".", "mean", "(", ")", ")", "**", "alpha", "-", "1", ")", ".", "mean", "(", ")", "/", "(", "alpha", "*", "(", "alpha", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.generalized_entropy_error": [[597, 629], ["metrics.generalized_entropy_index"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["", "", "def", "generalized_entropy_error", "(", "y_true", ",", "y_pred", ",", "alpha", "=", "2", ",", "pos_label", "=", "1", ")", ":", "\n", "#                           sample_weight=None):", "\n", "    ", "r\"\"\"Compute the generalized entropy.\n\n    Generalized entropy index is proposed as a unified individual and\n    group fairness measure in [#speicher18]_.\n\n    Uses :math:`b_i = \\hat{y}_i - y_i + 1`. See\n    :func:`generalized_entropy_index` for details.\n\n    Args:\n        y_true (array-like): Ground truth (correct) target values.\n        y_pred (array-like): Estimated targets as returned by a classifier.\n        alpha (scalar, optional): Parameter that regulates the weight given to\n            distances between values at different parts of the distribution. A\n            value of 0 is equivalent to the mean log deviation, 1 is the Theil\n            index, and 2 is half the squared coefficient of variation.\n        pos_label (scalar, optional): The label of the positive class.\n\n    See also:\n        :func:`generalized_entropy_index`\n\n    References:\n        .. [#speicher18] `T. Speicher, H. Heidari, N. Grgic-Hlaca,\n           K. P. Gummadi, A. Singla, A. Weller, and M. B. Zafar, \"A Unified\n           Approach to Quantifying Algorithmic Unfairness: Measuring Individual\n           and Group Unfairness via Inequality Indices,\" ACM SIGKDD\n           International Conference on Knowledge Discovery and Data Mining,\n           2018. <https://dl.acm.org/citation.cfm?id=3220046>`_\n    \"\"\"", "\n", "b", "=", "1", "+", "(", "y_pred", "==", "pos_label", ")", "-", "(", "y_true", "==", "pos_label", ")", "\n", "return", "generalized_entropy_index", "(", "b", ",", "alpha", "=", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.between_group_generalized_entropy_error": [[630, 672], ["aif360.sklearn.utils.check_groups", "numpy.empty_like", "numpy.unique", "metrics.generalized_entropy_index"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.sklearn.utils.check_groups", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["", "def", "between_group_generalized_entropy_error", "(", "y_true", ",", "y_pred", ",", "prot_attr", "=", "None", ",", "\n", "priv_group", "=", "None", ",", "alpha", "=", "2", ",", "pos_label", "=", "1", ")", ":", "\n", "    ", "r\"\"\"Compute the between-group generalized entropy.\n\n    Between-group generalized entropy index is proposed as a group\n    fairness measure in [#speicher18]_ and is one of two terms that the\n    generalized entropy index decomposes to.\n\n    Args:\n        y_true (pandas.Series): Ground truth (correct) target values.\n        y_pred (array-like): Estimated targets as returned by a classifier.\n        prot_attr (array-like, optional): Protected attribute(s). If ``None``,\n            all protected attributes in y_true are used.\n        priv_group (scalar, optional): The label of the privileged group. If\n            provided, the index will be computed between only the privileged and\n            unprivileged groups. Otherwise, the index will be computed between\n            all groups defined by the prot_attr.\n        alpha (scalar, optional): Parameter that regulates the weight given to\n            distances between values at different parts of the distribution. A\n            value of 0 is equivalent to the mean log deviation, 1 is the Theil\n            index, and 2 is half the squared coefficient of variation.\n        pos_label (scalar, optional): The label of the positive class.\n\n    See also:\n        :func:`generalized_entropy_index`\n\n    References:\n        .. [#speicher18] `T. Speicher, H. Heidari, N. Grgic-Hlaca,\n           K. P. Gummadi, A. Singla, A. Weller, and M. B. Zafar, \"A Unified\n           Approach to Quantifying Algorithmic Unfairness: Measuring Individual\n           and Group Unfairness via Inequality Indices,\" ACM SIGKDD\n           International Conference on Knowledge Discovery and Data Mining,\n           2018. <https://dl.acm.org/citation.cfm?id=3220046>`_\n    \"\"\"", "\n", "groups", ",", "_", "=", "check_groups", "(", "y_true", ",", "prot_attr", ")", "\n", "b", "=", "np", ".", "empty_like", "(", "y_true", ",", "dtype", "=", "'float'", ")", "\n", "if", "priv_group", "is", "not", "None", ":", "\n", "        ", "groups", "=", "[", "1", "if", "g", "==", "priv_group", "else", "0", "for", "g", "in", "groups", "]", "\n", "", "for", "g", "in", "np", ".", "unique", "(", "groups", ")", ":", "\n", "        ", "b", "[", "groups", "==", "g", "]", "=", "(", "1", "+", "(", "y_pred", "[", "groups", "==", "g", "]", "==", "pos_label", ")", "\n", "-", "(", "y_true", "[", "groups", "==", "g", "]", "==", "pos_label", ")", ")", ".", "mean", "(", ")", "\n", "", "return", "generalized_entropy_index", "(", "b", ",", "alpha", "=", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.theil_index": [[673, 684], ["metrics.generalized_entropy_index"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["", "def", "theil_index", "(", "b", ")", ":", "\n", "    ", "r\"\"\"The Theil index is the :func:`generalized_entropy_index` with\n    :math:`\\alpha = 1`.\n\n    Args:\n        b (array-like): Parameter over which to calculate the entropy index.\n\n    See also:\n        :func:`generalized_entropy_index`\n    \"\"\"", "\n", "return", "generalized_entropy_index", "(", "b", ",", "alpha", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.coefficient_of_variation": [[685, 696], ["numpy.sqrt", "metrics.generalized_entropy_index"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["", "def", "coefficient_of_variation", "(", "b", ")", ":", "\n", "    ", "r\"\"\"The coefficient of variation is the square root of two times the\n    :func:`generalized_entropy_index` with :math:`\\alpha = 2`.\n\n    Args:\n        b (array-like): Parameter over which to calculate the entropy index.\n\n    See also:\n        :func:`generalized_entropy_index`\n    \"\"\"", "\n", "return", "np", ".", "sqrt", "(", "2", "*", "generalized_entropy_index", "(", "b", ",", "alpha", "=", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.consistency_score": [[699, 729], ["sklearn.utils.check_X_y", "sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors.fit", "sklearn.neighbors.NearestNeighbors.kneighbors", "abs().mean", "abs", "y[].mean"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit"], ["", "def", "consistency_score", "(", "X", ",", "y", ",", "n_neighbors", "=", "5", ")", ":", "\n", "    ", "r\"\"\"Compute the consistency score.\n\n    Individual fairness metric from [#zemel13]_ that measures how similar the\n    labels are for similar instances.\n\n    .. math::\n        1 - \\frac{1}{n}\\sum_{i=1}^n |\\hat{y}_i -\n        \\frac{1}{\\text{n_neighbors}} \\sum_{j\\in\\mathcal{N}_{\\text{n_neighbors}}(x_i)} \\hat{y}_j|\n\n    Args:\n        X (array-like): Sample features.\n        y (array-like): Sample targets.\n        n_neighbors (int, optional): Number of neighbors for the knn\n            computation.\n\n    References:\n        .. [#zemel13] `R. Zemel, Y. Wu, K. Swersky, T. Pitassi, and C. Dwork,\n           \"Learning Fair Representations,\" International Conference on Machine\n           Learning, 2013. <http://proceedings.mlr.press/v28/zemel13.html>`_\n    \"\"\"", "\n", "# cast as ndarrays", "\n", "X", ",", "y", "=", "check_X_y", "(", "X", ",", "y", ")", "\n", "# learn a KNN on the features", "\n", "nbrs", "=", "NearestNeighbors", "(", "n_neighbors", "=", "n_neighbors", ",", "algorithm", "=", "'ball_tree'", ")", "\n", "nbrs", ".", "fit", "(", "X", ")", "\n", "indices", "=", "nbrs", ".", "kneighbors", "(", "X", ",", "return_distance", "=", "False", ")", "\n", "\n", "# compute consistency score", "\n", "return", "1", "-", "abs", "(", "y", "-", "y", "[", "indices", "]", ".", "mean", "(", "axis", "=", "1", ")", ")", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.sensitivity_score": [[732, 736], ["sklearn.metrics.recall_score"], "function", ["None"], ["", "def", "sensitivity_score", "(", "y_true", ",", "y_pred", ",", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "    ", "\"\"\"Alias of :func:`sklearn.metrics.recall_score` for binary classes only.\"\"\"", "\n", "return", "recall_score", "(", "y_true", ",", "y_pred", ",", "pos_label", "=", "pos_label", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.false_negative_rate_error": [[737, 740], ["sklearn.metrics.recall_score"], "function", ["None"], ["", "def", "false_negative_rate_error", "(", "y_true", ",", "y_pred", ",", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "    ", "return", "1", "-", "recall_score", "(", "y_true", ",", "y_pred", ",", "pos_label", "=", "pos_label", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.false_positive_rate_error": [[741, 744], ["metrics.specificity_score"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.specificity_score"], ["", "def", "false_positive_rate_error", "(", "y_true", ",", "y_pred", ",", "pos_label", "=", "1", ",", "sample_weight", "=", "None", ")", ":", "\n", "    ", "return", "1", "-", "specificity_score", "(", "y_true", ",", "y_pred", ",", "pos_label", "=", "pos_label", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metrics.mean_difference": [[745, 751], ["metrics.statistical_parity_difference"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference"], ["", "def", "mean_difference", "(", "*", "y", ",", "prot_attr", "=", "None", ",", "priv_group", "=", "1", ",", "pos_label", "=", "1", ",", "\n", "sample_weight", "=", "None", ")", ":", "\n", "    ", "\"\"\"Alias of :func:`statistical_parity_difference`.\"\"\"", "\n", "return", "statistical_parity_difference", "(", "*", "y", ",", "prot_attr", "=", "prot_attr", ",", "\n", "priv_group", "=", "priv_group", ",", "pos_label", "=", "pos_label", ",", "\n", "sample_weight", "=", "sample_weight", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.__init__": [[12, 42], ["aif360.metrics.DatasetMetric.__init__", "isinstance", "TypeError", "dataset.temporarily_ignore", "ValueError"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.temporarily_ignore"], ["def", "__init__", "(", "self", ",", "dataset", ",", "distorted_dataset", ",", "unprivileged_groups", "=", "None", ",", "\n", "privileged_groups", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset (StructuredDataset): A StructuredDataset.\n            distorted_dataset (StructuredDataset): A StructuredDataset.\n            privileged_groups (list(dict)): Privileged groups. Format is a list\n                of `dicts` where the keys are `protected_attribute_names` and\n                the values are values in `protected_attributes`. Each `dict`\n                element describes a single group. See examples for more details.\n            unprivileged_groups (list(dict)): Unprivileged groups in the same\n                format as `privileged_groups`.\n\n        Raises:\n            TypeError: `dataset` and `distorted_dataset` must be\n                :obj:`~aif360.datasets.StructuredDataset` types.\n        \"\"\"", "\n", "# sets self.dataset, self.unprivileged_groups, self.privileged_groups", "\n", "super", "(", "SampleDistortionMetric", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ")", "\n", "\n", "if", "isinstance", "(", "distorted_dataset", ",", "StructuredDataset", ")", ":", "\n", "            ", "self", ".", "distorted_dataset", "=", "distorted_dataset", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\"'distorted_dataset' should be a StructuredDataset\"", ")", "\n", "\n", "", "with", "dataset", ".", "temporarily_ignore", "(", "'features'", ",", "'labels'", ",", "'scores'", ")", ":", "\n", "            ", "if", "dataset", "!=", "distorted_dataset", ":", "\n", "                ", "raise", "ValueError", "(", "\"The two datasets may differ in features and \"", "\n", "\"labels/scores only.\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total": [[44, 47], ["dist", "numpy.sum"], "methods", ["None"], ["", "", "", "def", "total", "(", "self", ",", "dist", ",", "privileged", ")", ":", "\n", "        ", "distance", ",", "weights", "=", "dist", "(", "privileged", "=", "privileged", ",", "returned", "=", "True", ")", "\n", "return", "np", ".", "sum", "(", "distance", "*", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average": [[48, 51], ["dist", "numpy.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "average", "(", "self", ",", "dist", ",", "privileged", ")", ":", "\n", "        ", "distance", ",", "weights", "=", "dist", "(", "privileged", "=", "privileged", ",", "returned", "=", "True", ")", "\n", "return", "np", ".", "average", "(", "distance", ",", "weights", "=", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.maximum": [[52, 54], ["numpy.max", "dist"], "methods", ["None"], ["", "def", "maximum", "(", "self", ",", "dist", ",", "privileged", ")", ":", "\n", "        ", "return", "np", ".", "max", "(", "dist", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.euclidean_distance": [[55, 67], ["sample_distortion_metric.SampleDistortionMetric._to_condition", "aif360.metrics.utils.compute_distance"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_distance"], ["", "def", "euclidean_distance", "(", "self", ",", "privileged", "=", "None", ",", "returned", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute the average Euclidean distance between the samples from the\n        two datasets.\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "distance", ",", "mask", "=", "utils", ".", "compute_distance", "(", "self", ".", "dataset", ".", "features", ",", "\n", "self", ".", "distorted_dataset", ".", "features", ",", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "dist_fun", "=", "scdist", ".", "euclidean", ",", "\n", "condition", "=", "condition", ")", "\n", "if", "returned", ":", "\n", "            ", "return", "distance", ",", "self", ".", "dataset", ".", "instance_weights", "[", "mask", "]", "\n", "", "return", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.manhattan_distance": [[68, 80], ["sample_distortion_metric.SampleDistortionMetric._to_condition", "aif360.metrics.utils.compute_distance"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_distance"], ["", "def", "manhattan_distance", "(", "self", ",", "privileged", "=", "None", ",", "returned", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute the average Manhattan distance between the samples from the\n        two datasets.\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "distance", ",", "mask", "=", "utils", ".", "compute_distance", "(", "self", ".", "dataset", ".", "features", ",", "\n", "self", ".", "distorted_dataset", ".", "features", ",", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "dist_fun", "=", "scdist", ".", "cityblock", ",", "\n", "condition", "=", "condition", ")", "\n", "if", "returned", ":", "\n", "            ", "return", "distance", ",", "self", ".", "dataset", ".", "instance_weights", "[", "mask", "]", "\n", "", "return", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.mahalanobis_distance": [[81, 97], ["sample_distortion_metric.SampleDistortionMetric._to_condition", "functools.partial", "aif360.metrics.utils.compute_distance", "numpy.linalg.inv", "numpy.cov", "numpy.vstack"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_distance"], ["", "def", "mahalanobis_distance", "(", "self", ",", "privileged", "=", "None", ",", "returned", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute the average Mahalanobis distance between the samples from the\n        two datasets.\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "X_orig", "=", "self", ".", "dataset", ".", "features", "\n", "X_distort", "=", "self", ".", "distorted_dataset", ".", "features", "\n", "dist_fun", "=", "partial", "(", "scdist", ".", "mahalanobis", ",", "\n", "VI", "=", "np", ".", "linalg", ".", "inv", "(", "np", ".", "cov", "(", "np", ".", "vstack", "(", "[", "X_orig", ",", "X_distort", "]", ")", ".", "T", ")", ")", ".", "T", ")", "\n", "distance", ",", "mask", "=", "utils", ".", "compute_distance", "(", "X_orig", ",", "X_distort", ",", "\n", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "dist_fun", "=", "dist_fun", ",", "\n", "condition", "=", "condition", ")", "\n", "if", "returned", ":", "\n", "            ", "return", "distance", ",", "self", ".", "dataset", ".", "instance_weights", "[", "mask", "]", "\n", "", "return", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total_euclidean_distance": [[98, 100], ["sample_distortion_metric.SampleDistortionMetric.total"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total"], ["", "def", "total_euclidean_distance", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "total", "(", "self", ".", "euclidean_distance", ",", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total_manhattan_distance": [[101, 103], ["sample_distortion_metric.SampleDistortionMetric.total"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total"], ["", "def", "total_manhattan_distance", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "total", "(", "self", ".", "manhattan_distance", ",", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total_mahalanobis_distance": [[104, 106], ["sample_distortion_metric.SampleDistortionMetric.total"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total"], ["", "def", "total_mahalanobis_distance", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "total", "(", "self", ".", "mahalanobis_distance", ",", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average_euclidean_distance": [[107, 109], ["sample_distortion_metric.SampleDistortionMetric.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "average_euclidean_distance", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "average", "(", "self", ".", "euclidean_distance", ",", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average_manhattan_distance": [[110, 112], ["sample_distortion_metric.SampleDistortionMetric.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "average_manhattan_distance", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "average", "(", "self", ".", "manhattan_distance", ",", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average_mahalanobis_distance": [[113, 115], ["sample_distortion_metric.SampleDistortionMetric.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "average_mahalanobis_distance", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "average", "(", "self", ".", "mahalanobis_distance", ",", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.maximum_euclidean_distance": [[116, 118], ["sample_distortion_metric.SampleDistortionMetric.maximum"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.maximum"], ["", "def", "maximum_euclidean_distance", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "maximum", "(", "self", ".", "euclidean_distance", ",", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.maximum_manhattan_distance": [[119, 121], ["sample_distortion_metric.SampleDistortionMetric.maximum"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.maximum"], ["", "def", "maximum_manhattan_distance", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "maximum", "(", "self", ".", "manhattan_distance", ",", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.maximum_mahalanobis_distance": [[122, 124], ["sample_distortion_metric.SampleDistortionMetric.maximum"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.maximum"], ["", "def", "maximum_mahalanobis_distance", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "maximum", "(", "self", ".", "mahalanobis_distance", ",", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.mean_euclidean_distance_difference": [[125, 129], ["sample_distortion_metric.SampleDistortionMetric.difference", "sample_distortion_metric.SampleDistortionMetric.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "mean_euclidean_distance_difference", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Difference of the averages.\"\"\"", "\n", "return", "self", ".", "difference", "(", "\n", "self", ".", "average", "(", "self", ".", "euclidean_distance", ",", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.mean_manhattan_distance_difference": [[130, 134], ["sample_distortion_metric.SampleDistortionMetric.difference", "sample_distortion_metric.SampleDistortionMetric.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "mean_manhattan_distance_difference", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Difference of the averages.\"\"\"", "\n", "return", "self", ".", "difference", "(", "\n", "self", ".", "average", "(", "self", ".", "manhattan_distance", ",", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.mean_mahalanobis_distance_difference": [[135, 139], ["sample_distortion_metric.SampleDistortionMetric.difference", "sample_distortion_metric.SampleDistortionMetric.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "mean_mahalanobis_distance_difference", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Difference of the averages.\"\"\"", "\n", "return", "self", ".", "difference", "(", "\n", "self", ".", "average", "(", "self", ".", "mahalanobis_distance", ",", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.mean_euclidean_distance_ratio": [[140, 144], ["sample_distortion_metric.SampleDistortionMetric.ratio", "sample_distortion_metric.SampleDistortionMetric.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "mean_euclidean_distance_ratio", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Ratio of the averages.\"\"\"", "\n", "return", "self", ".", "ratio", "(", "\n", "self", ".", "average", "(", "self", ".", "euclidean_distance", ",", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.mean_manhattan_distance_ratio": [[145, 149], ["sample_distortion_metric.SampleDistortionMetric.ratio", "sample_distortion_metric.SampleDistortionMetric.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "mean_manhattan_distance_ratio", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Ratio of the averages.\"\"\"", "\n", "return", "self", ".", "ratio", "(", "\n", "self", ".", "average", "(", "self", ".", "manhattan_distance", ",", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.mean_mahalanobis_distance_ratio": [[150, 154], ["sample_distortion_metric.SampleDistortionMetric.ratio", "sample_distortion_metric.SampleDistortionMetric.average"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average"], ["", "def", "mean_mahalanobis_distance_ratio", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Ratio of the averages.\"\"\"", "\n", "return", "self", ".", "ratio", "(", "\n", "self", ".", "average", "(", "self", ".", "mahalanobis_distance", ",", "privileged", "=", "privileged", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.__init__": [[10, 56], ["aif360.metrics.Metric.__init__", "aif360.metrics.utils.compute_boolean_conditioning_vector", "aif360.metrics.utils.compute_boolean_conditioning_vector", "numpy.any", "isinstance", "TypeError", "numpy.logical_and", "ValueError"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector"], ["def", "__init__", "(", "self", ",", "dataset", ",", "unprivileged_groups", "=", "None", ",", "privileged_groups", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset (StructuredDataset): A StructuredDataset.\n            privileged_groups (list(dict)): Privileged groups. Format is a list\n                of `dicts` where the keys are `protected_attribute_names` and\n                the values are values in `protected_attributes`. Each `dict`\n                element describes a single group. See examples for more details.\n            unprivileged_groups (list(dict)): Unprivileged groups in the same\n                format as `privileged_groups`.\n\n        Raises:\n            TypeError: `dataset` must be a\n                :obj:`~aif360.datasets.StructuredDataset` type.\n            ValueError: `privileged_groups` and `unprivileged_groups` must be\n                disjoint.\n\n        Examples:\n            >>> from aif360.datasets import GermanDataset\n            >>> german = GermanDataset()\n            >>> u = [{'sex': 1, 'age': 1}, {'sex': 0}]\n            >>> p = [{'sex': 1, 'age': 0}]\n            >>> dm = DatasetMetric(german, unprivileged_groups=u, privileged_groups=p)\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "dataset", ",", "StructuredDataset", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"'dataset' should be a StructuredDataset\"", ")", "\n", "\n", "# sets self.dataset", "\n", "", "super", "(", "DatasetMetric", ",", "self", ")", ".", "__init__", "(", "dataset", ")", "\n", "\n", "# TODO: should this deepcopy?", "\n", "self", ".", "privileged_groups", "=", "privileged_groups", "\n", "self", ".", "unprivileged_groups", "=", "unprivileged_groups", "\n", "\n", "# don't check if nothing was provided", "\n", "if", "not", "self", ".", "privileged_groups", "or", "not", "self", ".", "unprivileged_groups", ":", "\n", "            ", "return", "\n", "\n", "", "priv_mask", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "self", ".", "privileged_groups", ")", "\n", "unpriv_mask", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "self", ".", "unprivileged_groups", ")", "\n", "if", "np", ".", "any", "(", "np", ".", "logical_and", "(", "priv_mask", ",", "unpriv_mask", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"'privileged_groups' and 'unprivileged_groups'\"", "\n", "\" must be disjoint.\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition": [[58, 72], ["AttributeError", "AttributeError"], "methods", ["None"], ["", "", "def", "_to_condition", "(", "self", ",", "privileged", ")", ":", "\n", "        ", "\"\"\"Converts a boolean condition to a group-specifying format that can be\n        used to create a conditioning vector.\n        \"\"\"", "\n", "if", "privileged", "is", "True", "and", "self", ".", "privileged_groups", "is", "None", ":", "\n", "            ", "raise", "AttributeError", "(", "\"'privileged_groups' was not provided when \"", "\n", "\"this object was initialized.\"", ")", "\n", "", "if", "privileged", "is", "False", "and", "self", ".", "unprivileged_groups", "is", "None", ":", "\n", "            ", "raise", "AttributeError", "(", "\"'unprivileged_groups' was not provided when \"", "\n", "\"this object was initialized.\"", ")", "\n", "\n", "", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "return", "self", ".", "privileged_groups", "if", "privileged", "else", "self", ".", "unprivileged_groups", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference": [[73, 78], ["metric_fun", "metric_fun"], "methods", ["None"], ["", "def", "difference", "(", "self", ",", "metric_fun", ")", ":", "\n", "        ", "\"\"\"Compute difference of the metric for unprivileged and privileged\n        groups.\n        \"\"\"", "\n", "return", "metric_fun", "(", "privileged", "=", "False", ")", "-", "metric_fun", "(", "privileged", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio": [[79, 83], ["metric_fun", "metric_fun"], "methods", ["None"], ["", "def", "ratio", "(", "self", ",", "metric_fun", ")", ":", "\n", "        ", "\"\"\"Compute ratio of the metric for unprivileged and privileged groups.\n        \"\"\"", "\n", "return", "metric_fun", "(", "privileged", "=", "False", ")", "/", "metric_fun", "(", "privileged", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.num_instances": [[84, 102], ["dataset_metric.DatasetMetric._to_condition", "aif360.metrics.utils.compute_num_instances"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_instances"], ["", "def", "num_instances", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute the number of instances, :math:`n`, in the dataset conditioned\n        on protected attributes if necessary.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` must be\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "return", "utils", ".", "compute_num_instances", "(", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "instance_weights", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "condition", "=", "condition", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.__init__": [[15, 50], ["aif360.metrics.DatasetMetric.__init__", "isinstance", "TypeError", "binary_label_dataset_metric.BinaryLabelDatasetMetric.dataset.copy", "numpy.logical_or.reduce", "numpy.where", "float", "float", "isinstance", "isinstance", "numpy.equal.outer"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["def", "__init__", "(", "self", ",", "dataset", ",", "unprivileged_groups", "=", "None", ",", "privileged_groups", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset (BinaryLabelDataset): A BinaryLabelDataset.\n            privileged_groups (list(dict)): Privileged groups. Format is a list\n                of `dicts` where the keys are `protected_attribute_names` and\n                the values are values in `protected_attributes`. Each `dict`\n                element describes a single group. See examples for more details.\n            unprivileged_groups (list(dict)): Unprivileged groups in the same\n                format as `privileged_groups`.\n\n        Raises:\n            TypeError: `dataset` must be a\n                :obj:`~aif360.datasets.BinaryLabelDataset` type.\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "dataset", ",", "BinaryLabelDataset", ")", "and", "not", "isinstance", "(", "dataset", ",", "MulticlassLabelDataset", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"'dataset' should be a BinaryLabelDataset or a MulticlassLabelDataset\"", ")", "\n", "\n", "# sets self.dataset, self.unprivileged_groups, self.privileged_groups", "\n", "", "super", "(", "BinaryLabelDatasetMetric", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ")", "\n", "\n", "if", "isinstance", "(", "dataset", ",", "MulticlassLabelDataset", ")", ":", "\n", "            ", "fav_label_value", "=", "1.", "\n", "unfav_label_value", "=", "0.", "\n", "\n", "self", ".", "dataset", "=", "self", ".", "dataset", ".", "copy", "(", ")", "\n", "# Find all labels which match any of the favorable labels", "\n", "fav_idx", "=", "np", ".", "logical_or", ".", "reduce", "(", "np", ".", "equal", ".", "outer", "(", "self", ".", "dataset", ".", "favorable_label", ",", "self", ".", "dataset", ".", "labels", ")", ")", "\n", "# Replace labels with corresponding values", "\n", "self", ".", "dataset", ".", "labels", "=", "np", ".", "where", "(", "fav_idx", ",", "fav_label_value", ",", "unfav_label_value", ")", "\n", "\n", "self", ".", "dataset", ".", "favorable_label", "=", "float", "(", "fav_label_value", ")", "\n", "self", ".", "dataset", ".", "unfavorable_label", "=", "float", "(", "unfav_label_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.num_positives": [[51, 71], ["binary_label_dataset_metric.BinaryLabelDatasetMetric._to_condition", "aif360.metrics.utils.compute_num_pos_neg"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_pos_neg"], ["", "", "def", "num_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Compute the number of positives,\n        :math:`P = \\sum_{i=1}^n \\mathbb{1}[y_i = 1]`,\n        optionally conditioned on protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` must be\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "return", "utils", ".", "compute_num_pos_neg", "(", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "labels", ",", "self", ".", "dataset", ".", "instance_weights", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "dataset", ".", "favorable_label", ",", "condition", "=", "condition", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.num_negatives": [[72, 92], ["binary_label_dataset_metric.BinaryLabelDatasetMetric._to_condition", "aif360.metrics.utils.compute_num_pos_neg"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_pos_neg"], ["", "def", "num_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Compute the number of negatives,\n        :math:`N = \\sum_{i=1}^n \\mathbb{1}[y_i = 0]`, optionally conditioned on\n        protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` must be\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "return", "utils", ".", "compute_num_pos_neg", "(", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "labels", ",", "self", ".", "dataset", ".", "instance_weights", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "dataset", ".", "unfavorable_label", ",", "condition", "=", "condition", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.base_rate": [[93, 107], ["binary_label_dataset_metric.BinaryLabelDatasetMetric.num_positives", "binary_label_dataset_metric.BinaryLabelDatasetMetric.num_instances"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "base_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute the base rate, :math:`Pr(Y = 1) = P/(P+N)`, optionally\n        conditioned on protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n        Returns:\n            float: Base rate (optionally conditioned).\n        \"\"\"", "\n", "return", "(", "self", ".", "num_positives", "(", "privileged", "=", "privileged", ")", "\n", "/", "self", ".", "num_instances", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.disparate_impact": [[108, 115], ["binary_label_dataset_metric.BinaryLabelDatasetMetric.ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio"], ["", "def", "disparate_impact", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n        .. math::\n           \\frac{Pr(Y = 1 | D = \\text{unprivileged})}\n           {Pr(Y = 1 | D = \\text{privileged})}\n        \"\"\"", "\n", "return", "self", ".", "ratio", "(", "self", ".", "base_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.statistical_parity_difference": [[116, 123], ["binary_label_dataset_metric.BinaryLabelDatasetMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "statistical_parity_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n        .. math::\n           Pr(Y = 1 | D = \\text{unprivileged})\n           - Pr(Y = 1 | D = \\text{privileged})\n        \"\"\"", "\n", "return", "self", ".", "difference", "(", "self", ".", "base_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.consistency": [[124, 158], ["sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors.fit", "sklearn.neighbors.NearestNeighbors.kneighbors", "range", "numpy.abs", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], ["", "def", "consistency", "(", "self", ",", "n_neighbors", "=", "5", ")", ":", "\n", "        ", "r\"\"\"Individual fairness metric from [1]_ that measures how similar the\n        labels are for similar instances.\n\n        .. math::\n           1 - \\frac{1}{n}\\sum_{i=1}^n |\\hat{y}_i -\n           \\frac{1}{\\text{n_neighbors}} \\sum_{j\\in\\mathcal{N}_{\\text{n_neighbors}}(x_i)} \\hat{y}_j|\n\n        Args:\n            n_neighbors (int, optional): Number of neighbors for the knn\n                computation.\n\n        References:\n            .. [1] R. Zemel, Y. Wu, K. Swersky, T. Pitassi, and C. Dwork,\n               \"Learning Fair Representations,\"\n               International Conference on Machine Learning, 2013.\n        \"\"\"", "\n", "\n", "X", "=", "self", ".", "dataset", ".", "features", "\n", "num_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "y", "=", "self", ".", "dataset", ".", "labels", "\n", "\n", "# learn a KNN on the features", "\n", "nbrs", "=", "NearestNeighbors", "(", "n_neighbors", "=", "n_neighbors", ",", "algorithm", "=", "'ball_tree'", ")", "\n", "nbrs", ".", "fit", "(", "X", ")", "\n", "_", ",", "indices", "=", "nbrs", ".", "kneighbors", "(", "X", ")", "\n", "\n", "# compute consistency score", "\n", "consistency", "=", "0.0", "\n", "for", "i", "in", "range", "(", "num_samples", ")", ":", "\n", "            ", "consistency", "+=", "np", ".", "abs", "(", "y", "[", "i", "]", "-", "np", ".", "mean", "(", "y", "[", "indices", "[", "i", "]", "]", ")", ")", "\n", "", "consistency", "=", "1.0", "-", "consistency", "/", "num_samples", "\n", "\n", "return", "consistency", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric._smoothed_base_rates": [[159, 189], ["numpy.unique", "len", "numpy.zeros", "numpy.zeros", "range", "ValueError", "aif360.metrics.utils.compute_num_instances", "aif360.metrics.utils.compute_num_pos_neg", "dict", "zip"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_pos_neg"], ["", "def", "_smoothed_base_rates", "(", "self", ",", "labels", ",", "concentration", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"Dirichlet-smoothed base rates for each intersecting group in the\n        dataset.\n        \"\"\"", "\n", "# Dirichlet smoothing parameters", "\n", "if", "concentration", "<", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Concentration parameter must be non-negative.\"", ")", "\n", "", "num_classes", "=", "2", "# binary label dataset", "\n", "dirichlet_alpha", "=", "concentration", "/", "num_classes", "\n", "\n", "# compute counts for all intersecting groups, e.g. black-women, white-man, etc", "\n", "intersect_groups", "=", "np", ".", "unique", "(", "self", ".", "dataset", ".", "protected_attributes", ",", "axis", "=", "0", ")", "\n", "num_intersects", "=", "len", "(", "intersect_groups", ")", "\n", "counts_pos", "=", "np", ".", "zeros", "(", "num_intersects", ")", "\n", "counts_total", "=", "np", ".", "zeros", "(", "num_intersects", ")", "\n", "for", "i", "in", "range", "(", "num_intersects", ")", ":", "\n", "            ", "condition", "=", "[", "dict", "(", "zip", "(", "self", ".", "dataset", ".", "protected_attribute_names", ",", "\n", "intersect_groups", "[", "i", "]", ")", ")", "]", "\n", "counts_total", "[", "i", "]", "=", "utils", ".", "compute_num_instances", "(", "\n", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "instance_weights", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "condition", "=", "condition", ")", "\n", "counts_pos", "[", "i", "]", "=", "utils", ".", "compute_num_pos_neg", "(", "\n", "self", ".", "dataset", ".", "protected_attributes", ",", "labels", ",", "\n", "self", ".", "dataset", ".", "instance_weights", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "dataset", ".", "favorable_label", ",", "condition", "=", "condition", ")", "\n", "\n", "# probability of y given S (p(y=1|S))", "\n", "", "return", "(", "counts_pos", "+", "dirichlet_alpha", ")", "/", "(", "counts_total", "+", "concentration", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.smoothed_empirical_differential_fairness": [[190, 232], ["binary_label_dataset_metric.BinaryLabelDatasetMetric._smoothed_base_rates", "max", "abs", "abs", "max", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "binary_label_dataset_metric.BinaryLabelDatasetMetric.smoothed_empirical_differential_fairness.pos_ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric._smoothed_base_rates"], ["", "def", "smoothed_empirical_differential_fairness", "(", "self", ",", "concentration", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"Smoothed EDF from [#foulds18]_.\n\n        Args:\n            concentration (float, optional): Concentration parameter for\n                Dirichlet smoothing. Must be non-negative.\n\n        Examples:\n            To use with non-binary protected attributes, the column must be\n            converted to ordinal:\n\n            >>> mapping = {'Black': 0, 'White': 1, 'Asian-Pac-Islander': 2,\n            ... 'Amer-Indian-Eskimo': 3, 'Other': 4}\n            >>> def map_race(df):\n            ...     df['race-num'] = df.race.map(mapping)\n            ...     return df\n            ...\n            >>> adult = AdultDataset(protected_attribute_names=['sex',\n            ... 'race-num'], privileged_classes=[['Male'], [1]],\n            ... categorical_features=['workclass', 'education',\n            ... 'marital-status', 'occupation', 'relationship',\n            ... 'native-country', 'race'], custom_preprocessing=map_race)\n            >>> metric = BinaryLabelDatasetMetric(adult)\n            >>> metric.smoothed_empirical_differential_fairness()\n            1.7547611985549287\n\n        References:\n            .. [#foulds18] J. R. Foulds, R. Islam, K. N. Keya, and S. Pan,\n               \"An Intersectional Definition of Fairness,\" arXiv preprint\n               arXiv:1807.08362, 2018.\n        \"\"\"", "\n", "sbr", "=", "self", ".", "_smoothed_base_rates", "(", "self", ".", "dataset", ".", "labels", ",", "concentration", ")", "\n", "\n", "def", "pos_ratio", "(", "i", ",", "j", ")", ":", "\n", "            ", "return", "abs", "(", "np", ".", "log", "(", "sbr", "[", "i", "]", ")", "-", "np", ".", "log", "(", "sbr", "[", "j", "]", ")", ")", "\n", "\n", "", "def", "neg_ratio", "(", "i", ",", "j", ")", ":", "\n", "            ", "return", "abs", "(", "np", ".", "log", "(", "1", "-", "sbr", "[", "i", "]", ")", "-", "np", ".", "log", "(", "1", "-", "sbr", "[", "j", "]", ")", ")", "\n", "\n", "# overall DF of the mechanism", "\n", "", "return", "max", "(", "max", "(", "pos_ratio", "(", "i", ",", "j", ")", ",", "neg_ratio", "(", "i", ",", "j", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "sbr", ")", ")", "for", "j", "in", "range", "(", "len", "(", "sbr", ")", ")", "if", "i", "!=", "j", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.mean_difference": [[234, 237], ["binary_label_dataset_metric.BinaryLabelDatasetMetric.statistical_parity_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference"], ["", "def", "mean_difference", "(", "self", ")", ":", "\n", "        ", "\"\"\"Alias of :meth:`statistical_parity_difference`.\"\"\"", "\n", "return", "self", ".", "statistical_parity_difference", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.rich_subgroup": [[239, 263], ["aif360.algorithms.inprocessing.gerryfair.auditor.Auditor", "array_to_tuple", "array_to_tuple", "aif360.algorithms.inprocessing.gerryfair.auditor.Auditor.get_baseline", "aif360.algorithms.inprocessing.gerryfair.auditor.Auditor.get_group"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.array_to_tuple", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.clean.array_to_tuple", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_baseline", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.auditor.Auditor.get_group"], ["", "def", "rich_subgroup", "(", "self", ",", "predictions", ",", "fairness_def", "=", "'FP'", ")", ":", "\n", "        ", "\"\"\"Audit dataset with respect to rich subgroups defined by linear thresholds of sensitive attributes\n\n            Args: fairness_def is 'FP' or 'FN' for rich subgroup wrt to false positive or false negative rate.\n                  predictions is a hashable tuple of predictions. Typically the labels attribute of a GerryFairClassifier\n\n            Returns: the gamma disparity with respect to the fairness_def.\n\n            Examples: see examples/gerry_plots.ipynb\n        \"\"\"", "\n", "\n", "auditor", "=", "Auditor", "(", "self", ".", "dataset", ",", "fairness_def", ")", "\n", "\n", "# make hashable type", "\n", "y", "=", "array_to_tuple", "(", "self", ".", "dataset", ".", "labels", ")", "\n", "predictions", "=", "array_to_tuple", "(", "predictions", ")", "\n", "\n", "# returns mean(predictions | y = 0) if 'FP' 1-mean(predictions | y = 1) if FN", "\n", "metric_baseline", "=", "auditor", ".", "get_baseline", "(", "y", ",", "predictions", ")", "\n", "\n", "# return the group with the largest disparity", "\n", "group", "=", "auditor", ".", "get_group", "(", "predictions", ",", "metric_baseline", ")", "\n", "\n", "return", "group", ".", "weighted_disparity", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.mdss_classification_metric.MDSSClassificationMetric.__init__": [[26, 61], ["aif360.metrics.ClassificationMetric.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dataset", ":", "BinaryLabelDataset", ",", "\n", "classified_dataset", ":", "BinaryLabelDataset", ",", "\n", "scoring", ":", "Union", "[", "str", ",", "ScoringFunction", "]", "=", "'Bernoulli'", ",", "\n", "unprivileged_groups", ":", "dict", "=", "None", ",", "\n", "privileged_groups", ":", "dict", "=", "None", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing ground-truth\n                labels.\n            classified_dataset (BinaryLabelDataset): Dataset containing\n                predictions.\n            scoring (str or ScoringFunction): One of 'Bernoulli' (parametric), or 'BerkJones' (non-parametric)\n                        or subclass of :class:`aif360.metrics.mdss.ScoringFunctions.ScoringFunction`.\n                        Defaults to Bernoulli.\n            privileged_groups (list(dict)): Privileged groups. Format is a list\n                of `dicts` where the keys are `protected_attribute_names` and\n                the values are values in `protected_attributes`. Each `dict`\n                element describes a single group. See examples for more details.\n            unprivileged_groups (list(dict)): Unprivileged groups in the same\n                format as `privileged_groups`.\n        \"\"\"", "\n", "\n", "super", "(", "MDSSClassificationMetric", ",", "self", ")", ".", "__init__", "(", "\n", "dataset", ",", "\n", "classified_dataset", ",", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ",", "\n", ")", "\n", "\n", "self", ".", "scoring", "=", "scoring", "\n", "self", ".", "kwargs", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.mdss_classification_metric.MDSSClassificationMetric.score_groups": [[62, 118], ["dict", "pandas.DataFrame", "pandas.Series", "pandas.Series", "aif360.detectors.mdss.MDSS.MDSS", "aif360.detectors.mdss.MDSS.MDSS.score_current_subset", "g.items", "mdss_classification_metric.MDSSClassificationMetric.classified_dataset.scores.flatten", "aif360.detectors.mdss.ScoringFunctions.Bernoulli", "dict", "mdss_classification_metric.MDSSClassificationMetric.dataset.labels.flatten", "aif360.detectors.mdss.ScoringFunctions.BerkJones", "mdss_classification_metric.MDSSClassificationMetric.scoring", "dict.keys", "subset[].append"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.score_current_subset"], ["", "def", "score_groups", "(", "self", ",", "privileged", "=", "True", ",", "penalty", "=", "1e-17", ")", ":", "\n", "        ", "\"\"\"Compute the bias score for a prespecified group of records.\n\n        Args:\n            privileged (bool): Flag for which direction to scan: privileged\n                (``True``) implies negative (observed worse than predicted\n                outcomes) while unprivileged (``False``) implies positive\n                (observed better than predicted outcomes).\n\n        Returns:\n            float: Bias score for the given group. \n                The higher the score, the evidence for bias.\n        \"\"\"", "\n", "groups", "=", "self", ".", "privileged_groups", "if", "privileged", "else", "self", ".", "unprivileged_groups", "\n", "subset", "=", "dict", "(", ")", "\n", "\n", "for", "g", "in", "groups", ":", "\n", "            ", "for", "k", ",", "v", "in", "g", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", "in", "subset", ".", "keys", "(", ")", ":", "\n", "                    ", "subset", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "", "else", ":", "\n", "                    ", "subset", "[", "k", "]", "=", "[", "v", "]", "\n", "\n", "", "", "", "coordinates", "=", "pd", ".", "DataFrame", "(", "\n", "self", ".", "dataset", ".", "features", ",", "columns", "=", "self", ".", "dataset", ".", "feature_names", "\n", ")", "\n", "expected", "=", "pd", ".", "Series", "(", "self", ".", "classified_dataset", ".", "scores", ".", "flatten", "(", ")", ")", "\n", "outcomes", "=", "pd", ".", "Series", "(", "self", ".", "dataset", ".", "labels", ".", "flatten", "(", ")", "==", "self", ".", "dataset", ".", "favorable_label", ",", "dtype", "=", "int", ")", "\n", "\n", "# In MDSS, we look for subset whose observations systematically deviates from expectations.", "\n", "# Positive direction means observations are systematically higher than expectations ", "\n", "# (or expectations are systematically higher than observations) while ", "\n", "# Negative direction means observatons are systematically lower than expectations", "\n", "# (or expectations are systematically higher than observations)", "\n", "\n", "# For a privileged group, we are looking for a subset whose expectations ", "\n", "# (where expectations is obtained from a model) is systematically higher than the observations.", "\n", "# This means we scan in the negative direction.", "\n", "\n", "# For an uprivileged group, we are looking for a subset whose expectations ", "\n", "# (where expectations is obtained from a model) is systematically lower the observations.", "\n", "# This means we scan in the position direction.", "\n", "\n", "self", ".", "kwargs", "[", "'direction'", "]", "=", "\"negative\"", "if", "privileged", "else", "\"positive\"", "\n", "\n", "if", "self", ".", "scoring", "==", "\"Bernoulli\"", ":", "\n", "            ", "scoring_function", "=", "Bernoulli", "(", "**", "self", ".", "kwargs", ")", "\n", "", "elif", "self", ".", "scoring", "==", "\"BerkJones\"", ":", "\n", "            ", "scoring_function", "=", "BerkJones", "(", "**", "self", ".", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "scoring_function", "=", "self", ".", "scoring", "(", "**", "self", ".", "kwargs", ")", "\n", "\n", "", "scanner", "=", "MDSS", "(", "scoring_function", ")", "\n", "\n", "return", "scanner", ".", "score_current_subset", "(", "\n", "coordinates", ",", "expected", ",", "outcomes", ",", "dict", "(", "subset", ")", ",", "penalty", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.mdss_classification_metric.MDSSClassificationMetric.bias_scan": [[120, 168], ["sklearn.exceptions.deprecated", "pandas.DataFrame", "pandas.Series", "pandas.Series", "aif360.detectors.mdss.MDSS.MDSS", "aif360.detectors.mdss.MDSS.MDSS.scan", "mdss_classification_metric.MDSSClassificationMetric.classified_dataset.scores.flatten", "aif360.detectors.mdss.ScoringFunctions.Bernoulli", "mdss_classification_metric.MDSSClassificationMetric.dataset.labels.flatten", "aif360.detectors.mdss.ScoringFunctions.BerkJones", "mdss_classification_metric.MDSSClassificationMetric.scoring"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.scan"], ["", "@", "deprecated", "(", "'Change to new interface - aif360.detectors.mdss_detector.bias_scan by version 0.5.0.'", ")", "\n", "def", "bias_scan", "(", "self", ",", "privileged", "=", "True", ",", "num_iters", "=", "10", ",", "penalty", "=", "1e-17", ")", ":", "\n", "        ", "\"\"\"\n        scan to find the highest scoring subset of records\n\n        :param privileged: flag for group to scan for - privileged group (True) or unprivileged group (False).\n        This abstract the need to explicitly specify the direction of bias to scan for which depends on what the favourable label is.\n        :param num_iters: number of iterations (random restarts)\n        :param penalty: penalty term. Should be positive. The penalty term as with any regularization parameter may need to be\n        tuned for ones use case. The higher the penalty, the less complex (number of features and feature values) the highest scoring\n        subset that gets returned is.\n\n        :returns: the highest scoring subset and the score\n        \"\"\"", "\n", "\n", "coordinates", "=", "pd", ".", "DataFrame", "(", "\n", "self", ".", "classified_dataset", ".", "features", ",", "\n", "columns", "=", "self", ".", "classified_dataset", ".", "feature_names", ",", "\n", ")", "\n", "\n", "expected", "=", "pd", ".", "Series", "(", "self", ".", "classified_dataset", ".", "scores", ".", "flatten", "(", ")", ")", "\n", "outcomes", "=", "pd", ".", "Series", "(", "self", ".", "dataset", ".", "labels", ".", "flatten", "(", ")", "==", "self", ".", "dataset", ".", "favorable_label", ",", "dtype", "=", "int", ")", "\n", "\n", "# In MDSS, we look for subset whose observations systematically deviates from expectations.", "\n", "# Positive direction means observations are systematically higher than expectations ", "\n", "# (or expectations are systematically lower than observations) while ", "\n", "# Negative direction means observatons are systematically lower than expectations", "\n", "# (or expectations are systematically higher than observations)", "\n", "\n", "# For a privileged group, we are looking for a subset whose expectations ", "\n", "# (where expectations is obtained from a model) is systematically higher than the observations.", "\n", "# This means we scan in the negative direction.", "\n", "\n", "# For an uprivileged group, we are looking for a subset whose expectations ", "\n", "# (where expectations is obtained from a model) is systematically lower the observations.", "\n", "# This means we scan in the position direction.", "\n", "\n", "self", ".", "kwargs", "[", "'direction'", "]", "=", "\"negative\"", "if", "privileged", "else", "\"positive\"", "\n", "\n", "if", "self", ".", "scoring", "==", "\"Bernoulli\"", ":", "\n", "            ", "scoring_function", "=", "Bernoulli", "(", "**", "self", ".", "kwargs", ")", "\n", "", "elif", "self", ".", "scoring", "==", "\"BerkJones\"", ":", "\n", "            ", "scoring_function", "=", "BerkJones", "(", "**", "self", ".", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "scoring_function", "=", "self", ".", "scoring", "(", "**", "self", ".", "kwargs", ")", "\n", "\n", "", "scanner", "=", "MDSS", "(", "scoring_function", ")", "\n", "return", "scanner", ".", "scan", "(", "coordinates", ",", "expected", ",", "outcomes", ",", "penalty", ",", "num_iters", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.__init__": [[17, 68], ["aif360.metrics.BinaryLabelDatasetMetric.__init__", "isinstance", "TypeError", "isinstance", "isinstance", "TypeError", "classification_metric.ClassificationMetric.classified_dataset.copy", "numpy.logical_or.reduce", "numpy.where", "float", "float", "classification_metric.ClassificationMetric.dataset.temporarily_ignore", "isinstance", "isinstance", "numpy.equal.outer", "ValueError"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.temporarily_ignore"], ["def", "__init__", "(", "self", ",", "dataset", ",", "classified_dataset", ",", "\n", "unprivileged_groups", "=", "None", ",", "privileged_groups", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset (BinaryLabelDataset): Dataset containing ground-truth\n                labels.\n            classified_dataset (BinaryLabelDataset): Dataset containing\n                predictions.\n            privileged_groups (list(dict)): Privileged groups. Format is a list\n                of `dicts` where the keys are `protected_attribute_names` and\n                the values are values in `protected_attributes`. Each `dict`\n                element describes a single group. See examples for more details.\n            unprivileged_groups (list(dict)): Unprivileged groups in the same\n                format as `privileged_groups`.\n\n        Raises:\n            TypeError: `dataset` and `classified_dataset` must be\n                :obj:`~aif360.datasets.BinaryLabelDataset` types.\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "dataset", ",", "BinaryLabelDataset", ")", "and", "not", "isinstance", "(", "dataset", ",", "MulticlassLabelDataset", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"'dataset' should be a BinaryLabelDataset or a MulticlassLabelDataset\"", ")", "\n", "\n", "# sets self.dataset, self.unprivileged_groups, self.privileged_groups", "\n", "", "super", "(", "ClassificationMetric", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ")", "\n", "\n", "if", "isinstance", "(", "classified_dataset", ",", "BinaryLabelDataset", ")", "or", "isinstance", "(", "classified_dataset", ",", "MulticlassLabelDataset", ")", ":", "\n", "            ", "self", ".", "classified_dataset", "=", "classified_dataset", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\"'classified_dataset' should be a \"", "\n", "\"BinaryLabelDataset or a MulticlassLabelDataset.\"", ")", "\n", "\n", "", "if", "isinstance", "(", "self", ".", "classified_dataset", ",", "MulticlassLabelDataset", ")", ":", "\n", "            ", "fav_label_value", "=", "1.", "\n", "unfav_label_value", "=", "0.", "\n", "\n", "self", ".", "classified_dataset", "=", "self", ".", "classified_dataset", ".", "copy", "(", ")", "\n", "# Find all the labels which match any of the favorable labels", "\n", "fav_idx", "=", "np", ".", "logical_or", ".", "reduce", "(", "np", ".", "equal", ".", "outer", "(", "self", ".", "classified_dataset", ".", "favorable_label", ",", "self", ".", "classified_dataset", ".", "labels", ")", ")", "\n", "# Replace labels with corresponding values", "\n", "self", ".", "classified_dataset", ".", "labels", "=", "np", ".", "where", "(", "fav_idx", ",", "fav_label_value", ",", "unfav_label_value", ")", "\n", "\n", "self", ".", "classified_dataset", ".", "favorable_label", "=", "float", "(", "fav_label_value", ")", "\n", "self", ".", "classified_dataset", ".", "unfavorable_label", "=", "float", "(", "unfav_label_value", ")", "\n", "\n", "# Verify if everything except the predictions and metadata are the same", "\n", "# for the two datasets", "\n", "", "with", "self", ".", "dataset", ".", "temporarily_ignore", "(", "'labels'", ",", "'scores'", ")", ":", "\n", "            ", "if", "self", ".", "dataset", "!=", "self", ".", "classified_dataset", ":", "\n", "                ", "raise", "ValueError", "(", "\"The two datasets are expected to differ only \"", "\n", "\"in 'labels' or 'scores'.\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.binary_confusion_matrix": [[70, 91], ["classification_metric.ClassificationMetric._to_condition", "aif360.metrics.utils.compute_num_TF_PN"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_TF_PN"], ["", "", "", "def", "binary_confusion_matrix", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute the number of true/false positives/negatives, optionally\n        conditioned on protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n        Returns:\n            dict: Number of true positives, false positives, true negatives,\n            false negatives (optionally conditioned).\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "\n", "return", "utils", ".", "compute_num_TF_PN", "(", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "labels", ",", "self", ".", "classified_dataset", ".", "labels", ",", "\n", "self", ".", "dataset", ".", "instance_weights", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "dataset", ".", "favorable_label", ",", "self", ".", "dataset", ".", "unfavorable_label", ",", "\n", "condition", "=", "condition", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_binary_confusion_matrix": [[92, 115], ["classification_metric.ClassificationMetric._to_condition", "aif360.metrics.utils.compute_num_gen_TF_PN"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_gen_TF_PN"], ["", "def", "generalized_binary_confusion_matrix", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute the number of generalized true/false positives/negatives,\n        optionally conditioned on protected attributes. Generalized counts are\n        based on scores and not on the hard predictions.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n        Returns:\n            dict: Number of generalized true positives, generalized false\n            positives, generalized true negatives, generalized false negatives\n            (optionally conditioned).\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "\n", "return", "utils", ".", "compute_num_gen_TF_PN", "(", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "labels", ",", "self", ".", "classified_dataset", ".", "scores", ",", "\n", "self", ".", "dataset", ".", "instance_weights", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "dataset", ".", "favorable_label", ",", "self", ".", "dataset", ".", "unfavorable_label", ",", "\n", "condition", "=", "condition", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_true_positives": [[116, 133], ["classification_metric.ClassificationMetric.binary_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.binary_confusion_matrix"], ["", "def", "num_true_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "r\"\"\"Return the number of instances in the dataset where both the\n        predicted and true labels are 'favorable',\n        :math:`TP = \\sum_{i=1}^n \\mathbb{1}[y_i = \\text{favorable}]\\mathbb{1}[\\hat{y}_i = \\text{favorable}]`,\n        optionally conditioned on protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups`\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "binary_confusion_matrix", "(", "privileged", "=", "privileged", ")", "[", "'TP'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_false_positives": [[134, 148], ["classification_metric.ClassificationMetric.binary_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.binary_confusion_matrix"], ["", "def", "num_false_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "r\"\"\":math:`FP = \\sum_{i=1}^n \\mathbb{1}[y_i = \\text{unfavorable}]\\mathbb{1}[\\hat{y}_i = \\text{favorable}]`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "binary_confusion_matrix", "(", "privileged", "=", "privileged", ")", "[", "'FP'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_false_negatives": [[149, 163], ["classification_metric.ClassificationMetric.binary_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.binary_confusion_matrix"], ["", "def", "num_false_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "r\"\"\":math:`FN = \\sum_{i=1}^n \\mathbb{1}[y_i = \\text{favorable}]\\mathbb{1}[\\hat{y}_i = \\text{unfavorable}]`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups`\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "binary_confusion_matrix", "(", "privileged", "=", "privileged", ")", "[", "'FN'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_true_negatives": [[164, 178], ["classification_metric.ClassificationMetric.binary_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.binary_confusion_matrix"], ["", "def", "num_true_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "r\"\"\":math:`TN = \\sum_{i=1}^n \\mathbb{1}[y_i = \\text{unfavorable}]\\mathbb{1}[\\hat{y}_i = \\text{unfavorable}]`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups`\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "binary_confusion_matrix", "(", "privileged", "=", "privileged", ")", "[", "'TN'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_true_positives": [[179, 196], ["classification_metric.ClassificationMetric.generalized_binary_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_binary_confusion_matrix"], ["", "def", "num_generalized_true_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the generalized number of true positives, :math:`GTP`, the\n        weighted sum of predicted scores where true labels are 'favorable',\n        optionally conditioned on protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "generalized_binary_confusion_matrix", "(", "\n", "privileged", "=", "privileged", ")", "[", "'GTP'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_false_positives": [[197, 214], ["classification_metric.ClassificationMetric.generalized_binary_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_binary_confusion_matrix"], ["", "def", "num_generalized_false_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the generalized number of false positives, :math:`GFP`, the\n        weighted sum of predicted scores where true labels are 'unfavorable',\n        optionally conditioned on protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` must be\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "generalized_binary_confusion_matrix", "(", "\n", "privileged", "=", "privileged", ")", "[", "'GFP'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_false_negatives": [[215, 232], ["classification_metric.ClassificationMetric.generalized_binary_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_binary_confusion_matrix"], ["", "def", "num_generalized_false_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the generalized number of false negatives, :math:`GFN`, the\n        weighted sum of 1 - predicted scores where true labels are 'favorable',\n        optionally conditioned on protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups`\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "generalized_binary_confusion_matrix", "(", "\n", "privileged", "=", "privileged", ")", "[", "'GFN'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_true_negatives": [[233, 250], ["classification_metric.ClassificationMetric.generalized_binary_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_binary_confusion_matrix"], ["", "def", "num_generalized_true_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the generalized number of true negatives, :math:`GTN`, the\n        weighted sum of 1 - predicted scores where true labels are 'unfavorable',\n        optionally conditioned on protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "generalized_binary_confusion_matrix", "(", "\n", "privileged", "=", "privileged", ")", "[", "'GTN'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures": [[251, 285], ["classification_metric.ClassificationMetric.num_true_positives", "classification_metric.ClassificationMetric.num_false_positives", "classification_metric.ClassificationMetric.num_false_negatives", "classification_metric.ClassificationMetric.num_true_negatives", "classification_metric.ClassificationMetric.num_generalized_true_positives", "classification_metric.ClassificationMetric.num_generalized_false_positives", "classification_metric.ClassificationMetric.num_generalized_false_negatives", "classification_metric.ClassificationMetric.num_generalized_true_negatives", "classification_metric.ClassificationMetric.num_positives", "classification_metric.ClassificationMetric.num_negatives", "dict", "numpy.float64", "numpy.float64", "numpy.float64", "numpy.float64", "numpy.float64"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "performance_measures", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute various performance measures on the dataset, optionally\n        conditioned on protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n        Returns:\n            dict: True positive rate, true negative rate, false positive rate,\n            false negative rate, positive predictive value, negative predictive\n            value, false discover rate, false omission rate, and accuracy\n            (optionally conditioned).\n        \"\"\"", "\n", "TP", "=", "self", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", "\n", "FP", "=", "self", ".", "num_false_positives", "(", "privileged", "=", "privileged", ")", "\n", "FN", "=", "self", ".", "num_false_negatives", "(", "privileged", "=", "privileged", ")", "\n", "TN", "=", "self", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", "\n", "GTP", "=", "self", ".", "num_generalized_true_positives", "(", "privileged", "=", "privileged", ")", "\n", "GFP", "=", "self", ".", "num_generalized_false_positives", "(", "privileged", "=", "privileged", ")", "\n", "GFN", "=", "self", ".", "num_generalized_false_negatives", "(", "privileged", "=", "privileged", ")", "\n", "GTN", "=", "self", ".", "num_generalized_true_negatives", "(", "privileged", "=", "privileged", ")", "\n", "P", "=", "self", ".", "num_positives", "(", "privileged", "=", "privileged", ")", "\n", "N", "=", "self", ".", "num_negatives", "(", "privileged", "=", "privileged", ")", "\n", "\n", "return", "dict", "(", "\n", "TPR", "=", "TP", "/", "P", ",", "TNR", "=", "TN", "/", "N", ",", "FPR", "=", "FP", "/", "N", ",", "FNR", "=", "FN", "/", "P", ",", "\n", "GTPR", "=", "GTP", "/", "P", ",", "GTNR", "=", "GTN", "/", "N", ",", "GFPR", "=", "GFP", "/", "N", ",", "GFNR", "=", "GFN", "/", "P", ",", "\n", "PPV", "=", "TP", "/", "(", "TP", "+", "FP", ")", "if", "(", "TP", "+", "FP", ")", ">", "0.0", "else", "np", ".", "float64", "(", "0.0", ")", ",", "\n", "NPV", "=", "TN", "/", "(", "TN", "+", "FN", ")", "if", "(", "TN", "+", "FN", ")", ">", "0.0", "else", "np", ".", "float64", "(", "0.0", ")", ",", "\n", "FDR", "=", "FP", "/", "(", "FP", "+", "TP", ")", "if", "(", "FP", "+", "TP", ")", ">", "0.0", "else", "np", ".", "float64", "(", "0.0", ")", ",", "\n", "FOR", "=", "FN", "/", "(", "FN", "+", "TN", ")", "if", "(", "FN", "+", "TN", ")", ">", "0.0", "else", "np", ".", "float64", "(", "0.0", ")", ",", "\n", "ACC", "=", "(", "TP", "+", "TN", ")", "/", "(", "P", "+", "N", ")", "if", "(", "P", "+", "N", ")", ">", "0.0", "else", "np", ".", "float64", "(", "0.0", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.true_positive_rate": [[287, 303], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "true_positive_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the ratio of true positives to positive examples in the\n        dataset, :math:`TPR = TP/P`, optionally conditioned on protected\n        attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'TPR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_positive_rate": [[304, 318], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "false_positive_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`FPR = FP/N`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'FPR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_negative_rate": [[319, 333], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "false_negative_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`FNR = FN/P`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups`\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'FNR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.true_negative_rate": [[334, 348], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "true_negative_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`TNR = TN/N`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'TNR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_true_positive_rate": [[349, 365], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "generalized_true_positive_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the ratio of generalized true positives to positive examples\n        in the dataset, :math:`GTPR = GTP/P`, optionally conditioned on\n        protected attributes.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'GTPR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_positive_rate": [[366, 380], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "generalized_false_positive_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`GFPR = GFP/N`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'GFPR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_false_negative_rate": [[381, 395], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "generalized_false_negative_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`GFNR = GFN/P`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups`\n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'GFNR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_true_negative_rate": [[396, 410], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "generalized_true_negative_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`GTNR = GTN/N`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'GTNR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.positive_predictive_value": [[411, 425], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "positive_predictive_value", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`PPV = TP/(TP + FP)`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'PPV'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_discovery_rate": [[426, 440], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "false_discovery_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`FDR = FP/(TP + FP)`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'FDR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_omission_rate": [[441, 455], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "false_omission_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`FOR = FN/(TN + FN)`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'FOR'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.negative_predictive_value": [[456, 470], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "negative_predictive_value", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`NPV = TN/(TN + FN)`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'NPV'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.accuracy": [[471, 485], ["classification_metric.ClassificationMetric.performance_measures"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.performance_measures"], ["", "def", "accuracy", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`ACC = (TP + TN)/(P + N)`.\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "self", ".", "performance_measures", "(", "privileged", "=", "privileged", ")", "[", "'ACC'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.error_rate": [[486, 500], ["classification_metric.ClassificationMetric.accuracy"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy"], ["", "def", "error_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\":math:`ERR = (FP + FN)/(P + N)`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "1.", "-", "self", ".", "accuracy", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.true_positive_rate_difference": [[501, 505], ["classification_metric.ClassificationMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "true_positive_rate_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\":math:`TPR_{D = \\text{unprivileged}} - TPR_{D = \\text{privileged}}`\n        \"\"\"", "\n", "return", "self", ".", "difference", "(", "self", ".", "true_positive_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_positive_rate_difference": [[506, 510], ["classification_metric.ClassificationMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "false_positive_rate_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\":math:`FPR_{D = \\text{unprivileged}} - FPR_{D = \\text{privileged}}`\n        \"\"\"", "\n", "return", "self", ".", "difference", "(", "self", ".", "false_positive_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_negative_rate_difference": [[511, 515], ["classification_metric.ClassificationMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "false_negative_rate_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\":math:`FNR_{D = \\text{unprivileged}} - FNR_{D = \\text{privileged}}`\n        \"\"\"", "\n", "return", "self", ".", "difference", "(", "self", ".", "false_negative_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_omission_rate_difference": [[516, 520], ["classification_metric.ClassificationMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "false_omission_rate_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\":math:`FOR_{D = \\text{unprivileged}} - FOR_{D = \\text{privileged}}`\n        \"\"\"", "\n", "return", "self", ".", "difference", "(", "self", ".", "false_omission_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_discovery_rate_difference": [[521, 525], ["classification_metric.ClassificationMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "false_discovery_rate_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\":math:`FDR_{D = \\text{unprivileged}} - FDR_{D = \\text{privileged}}`\n        \"\"\"", "\n", "return", "self", ".", "difference", "(", "self", ".", "false_discovery_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_positive_rate_ratio": [[526, 530], ["classification_metric.ClassificationMetric.ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio"], ["", "def", "false_positive_rate_ratio", "(", "self", ")", ":", "\n", "        ", "r\"\"\":math:`\\frac{FPR_{D = \\text{unprivileged}}}{FPR_{D = \\text{privileged}}}`\n        \"\"\"", "\n", "return", "self", ".", "ratio", "(", "self", ".", "false_positive_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_negative_rate_ratio": [[531, 535], ["classification_metric.ClassificationMetric.ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio"], ["", "def", "false_negative_rate_ratio", "(", "self", ")", ":", "\n", "        ", "r\"\"\":math:`\\frac{FNR_{D = \\text{unprivileged}}}{FNR_{D = \\text{privileged}}}`\n        \"\"\"", "\n", "return", "self", ".", "ratio", "(", "self", ".", "false_negative_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_omission_rate_ratio": [[536, 540], ["classification_metric.ClassificationMetric.ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio"], ["", "def", "false_omission_rate_ratio", "(", "self", ")", ":", "\n", "        ", "r\"\"\":math:`\\frac{FOR_{D = \\text{unprivileged}}}{FOR_{D = \\text{privileged}}}`\n        \"\"\"", "\n", "return", "self", ".", "ratio", "(", "self", ".", "false_omission_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.false_discovery_rate_ratio": [[541, 545], ["classification_metric.ClassificationMetric.ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio"], ["", "def", "false_discovery_rate_ratio", "(", "self", ")", ":", "\n", "        ", "r\"\"\":math:`\\frac{FDR_{D = \\text{unprivileged}}}{FDR_{D = \\text{privileged}}}`\n        \"\"\"", "\n", "return", "self", ".", "ratio", "(", "self", ".", "false_discovery_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.average_odds_difference": [[546, 559], ["classification_metric.ClassificationMetric.difference", "classification_metric.ClassificationMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "average_odds_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\"Average of difference in FPR and TPR for unprivileged and privileged\n        groups:\n\n        .. math::\n\n           \\tfrac{1}{2}\\left[(FPR_{D = \\text{unprivileged}} - FPR_{D = \\text{privileged}})\n           + (TPR_{D = \\text{unprivileged}} - TPR_{D = \\text{privileged}}))\\right]\n\n        A value of 0 indicates equality of odds.\n        \"\"\"", "\n", "return", "0.5", "*", "(", "self", ".", "difference", "(", "self", ".", "false_positive_rate", ")", "\n", "+", "self", ".", "difference", "(", "self", ".", "true_positive_rate", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.average_abs_odds_difference": [[560, 573], ["numpy.abs", "numpy.abs", "classification_metric.ClassificationMetric.difference", "classification_metric.ClassificationMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "average_abs_odds_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\"Average of absolute difference in FPR and TPR for unprivileged and\n        privileged groups:\n\n        .. math::\n\n           \\tfrac{1}{2}\\left[|FPR_{D = \\text{unprivileged}} - FPR_{D = \\text{privileged}}|\n           + |TPR_{D = \\text{unprivileged}} - TPR_{D = \\text{privileged}}|\\right]\n\n        A value of 0 indicates equality of odds.\n        \"\"\"", "\n", "return", "0.5", "*", "(", "np", ".", "abs", "(", "self", ".", "difference", "(", "self", ".", "false_positive_rate", ")", ")", "\n", "+", "np", ".", "abs", "(", "self", ".", "difference", "(", "self", ".", "true_positive_rate", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.error_rate_difference": [[574, 579], ["classification_metric.ClassificationMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "error_rate_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\"Difference in error rates for unprivileged and privileged groups,\n        :math:`ERR_{D = \\text{unprivileged}} - ERR_{D = \\text{privileged}}`.\n        \"\"\"", "\n", "return", "self", ".", "difference", "(", "self", ".", "error_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.error_rate_ratio": [[580, 585], ["classification_metric.ClassificationMetric.ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio"], ["", "def", "error_rate_ratio", "(", "self", ")", ":", "\n", "        ", "r\"\"\"Ratio of error rates for unprivileged and privileged groups,\n        :math:`\\frac{ERR_{D = \\text{unprivileged}}}{ERR_{D = \\text{privileged}}}`.\n        \"\"\"", "\n", "return", "self", ".", "ratio", "(", "self", ".", "error_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_pred_positives": [[586, 608], ["classification_metric.ClassificationMetric._to_condition", "aif360.metrics.utils.compute_num_pos_neg"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_pos_neg"], ["", "def", "num_pred_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "r\"\"\":math:`\\sum_{i=1}^n \\mathbb{1}[\\hat{y}_i = \\text{favorable}]`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "\n", "return", "utils", ".", "compute_num_pos_neg", "(", "\n", "self", ".", "classified_dataset", ".", "protected_attributes", ",", "\n", "self", ".", "classified_dataset", ".", "labels", ",", "\n", "self", ".", "classified_dataset", ".", "instance_weights", ",", "\n", "self", ".", "classified_dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "classified_dataset", ".", "favorable_label", ",", "\n", "condition", "=", "condition", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_pred_negatives": [[609, 631], ["classification_metric.ClassificationMetric._to_condition", "aif360.metrics.utils.compute_num_pos_neg"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_pos_neg"], ["", "def", "num_pred_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "r\"\"\":math:`\\sum_{i=1}^n \\mathbb{1}[\\hat{y}_i = \\text{unfavorable}]`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "condition", "=", "self", ".", "_to_condition", "(", "privileged", ")", "\n", "\n", "return", "utils", ".", "compute_num_pos_neg", "(", "\n", "self", ".", "classified_dataset", ".", "protected_attributes", ",", "\n", "self", ".", "classified_dataset", ".", "labels", ",", "\n", "self", ".", "classified_dataset", ".", "instance_weights", ",", "\n", "self", ".", "classified_dataset", ".", "protected_attribute_names", ",", "\n", "self", ".", "classified_dataset", ".", "unfavorable_label", ",", "\n", "condition", "=", "condition", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.selection_rate": [[632, 647], ["classification_metric.ClassificationMetric.num_pred_positives", "classification_metric.ClassificationMetric.num_instances"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "selection_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "r\"\"\":math:`Pr(\\hat{Y} = \\text{favorable})`\n\n        Args:\n            privileged (bool, optional): Boolean prescribing whether to\n                condition this metric on the `privileged_groups`, if `True`, or\n                the `unprivileged_groups`, if `False`. Defaults to `None`\n                meaning this metric is computed over the entire dataset.\n\n        Raises:\n            AttributeError: `privileged_groups` or `unprivileged_groups` \n                must be provided at initialization to condition on them.\n        \"\"\"", "\n", "return", "(", "self", ".", "num_pred_positives", "(", "privileged", "=", "privileged", ")", "\n", "/", "self", ".", "num_instances", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.disparate_impact": [[648, 655], ["classification_metric.ClassificationMetric.ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.ratio"], ["", "def", "disparate_impact", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n        .. math::\n           \\frac{Pr(\\hat{Y} = 1 | D = \\text{unprivileged})}\n           {Pr(\\hat{Y} = 1 | D = \\text{privileged})}\n        \"\"\"", "\n", "return", "self", ".", "ratio", "(", "self", ".", "selection_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.statistical_parity_difference": [[656, 663], ["classification_metric.ClassificationMetric.difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference"], ["", "def", "statistical_parity_difference", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n        .. math::\n           Pr(\\hat{Y} = 1 | D = \\text{unprivileged})\n           - Pr(\\hat{Y} = 1 | D = \\text{privileged})\n        \"\"\"", "\n", "return", "self", ".", "difference", "(", "self", ".", "selection_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_entropy_index": [[664, 699], ["classification_metric.ClassificationMetric.classified_dataset.labels.ravel", "classification_metric.ClassificationMetric.dataset.labels.ravel", "numpy.mean", "numpy.log", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.log", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean"], "methods", ["None"], ["", "def", "generalized_entropy_index", "(", "self", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "r\"\"\"Generalized entropy index is proposed as a unified individual and\n        group fairness measure in [3]_.  With :math:`b_i = \\hat{y}_i - y_i + 1`:\n\n        .. math::\n\n           \\mathcal{E}(\\alpha) = \\begin{cases}\n               \\frac{1}{n \\alpha (\\alpha-1)}\\sum_{i=1}^n\\left[\\left(\\frac{b_i}{\\mu}\\right)^\\alpha - 1\\right],& \\alpha \\ne 0, 1,\\\\\n               \\frac{1}{n}\\sum_{i=1}^n\\frac{b_{i}}{\\mu}\\ln\\frac{b_{i}}{\\mu},& \\alpha=1,\\\\\n               -\\frac{1}{n}\\sum_{i=1}^n\\ln\\frac{b_{i}}{\\mu},& \\alpha=0.\n           \\end{cases}\n\n        Args:\n            alpha (int): Parameter that regulates the weight given to distances\n                between values at different parts of the distribution.\n\n        References:\n            .. [3] T. Speicher, H. Heidari, N. Grgic-Hlaca, K. P. Gummadi, A. Singla, A. Weller, and M. B. Zafar,\n               \"A Unified Approach to Quantifying Algorithmic Unfairness: Measuring Individual and Group Unfairness via Inequality Indices,\"\n               ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2018.\n        \"\"\"", "\n", "y_pred", "=", "self", ".", "classified_dataset", ".", "labels", ".", "ravel", "(", ")", "\n", "y_true", "=", "self", ".", "dataset", ".", "labels", ".", "ravel", "(", ")", "\n", "y_pred", "=", "(", "y_pred", "==", "self", ".", "classified_dataset", ".", "favorable_label", ")", ".", "astype", "(", "\n", "np", ".", "float64", ")", "\n", "y_true", "=", "(", "y_true", "==", "self", ".", "dataset", ".", "favorable_label", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "b", "=", "1", "+", "y_pred", "-", "y_true", "\n", "\n", "if", "alpha", "==", "1", ":", "\n", "# moving the b inside the log allows for 0 values", "\n", "            ", "return", "np", ".", "mean", "(", "np", ".", "log", "(", "(", "b", "/", "np", ".", "mean", "(", "b", ")", ")", "**", "b", ")", "/", "np", ".", "mean", "(", "b", ")", ")", "\n", "", "elif", "alpha", "==", "0", ":", "\n", "            ", "return", "-", "np", ".", "mean", "(", "np", ".", "log", "(", "b", "/", "np", ".", "mean", "(", "b", ")", ")", "/", "np", ".", "mean", "(", "b", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "mean", "(", "(", "b", "/", "np", ".", "mean", "(", "b", ")", ")", "**", "alpha", "-", "1", ")", "/", "(", "alpha", "*", "(", "alpha", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric._between_group_generalized_entropy_index": [[700, 744], ["numpy.zeros", "aif360.metrics.utils.compute_boolean_conditioning_vector", "aif360.metrics.utils.compute_boolean_conditioning_vector", "classification_metric.ClassificationMetric.classified_dataset.labels[].ravel", "classification_metric.ClassificationMetric.dataset.labels[].ravel", "numpy.mean", "numpy.mean", "numpy.any", "numpy.log", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.log", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector"], ["", "", "def", "_between_group_generalized_entropy_index", "(", "self", ",", "groups", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "r\"\"\"Between-group generalized entropy index is proposed as a group\n        fairness measure in [2]_ and is one of two terms that the generalized\n        entropy index decomposes to.\n\n        Args:\n            groups (list): A list of groups over which to calculate this metric.\n                Groups should be disjoint. By default, this will use the\n                `privileged_groups` and `unprivileged_groups` as the only two\n                groups.\n            alpha (int): See :meth:`generalized_entropy_index`.\n\n        References:\n            .. [2] T. Speicher, H. Heidari, N. Grgic-Hlaca, K. P. Gummadi, A. Singla, A. Weller, and M. B. Zafar,\n               \"A Unified Approach to Quantifying Algorithmic Unfairness: Measuring Individual and Group Unfairness via Inequality Indices,\"\n               ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2018.\n        \"\"\"", "\n", "b", "=", "np", ".", "zeros", "(", "self", ".", "dataset", ".", "labels", ".", "size", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "for", "group", "in", "groups", ":", "\n", "            ", "classified_group", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "self", ".", "classified_dataset", ".", "protected_attributes", ",", "\n", "self", ".", "classified_dataset", ".", "protected_attribute_names", ",", "\n", "condition", "=", "group", ")", "\n", "true_group", "=", "utils", ".", "compute_boolean_conditioning_vector", "(", "\n", "self", ".", "dataset", ".", "protected_attributes", ",", "\n", "self", ".", "dataset", ".", "protected_attribute_names", ",", "\n", "condition", "=", "group", ")", "\n", "# ignore if there are no members of this group present", "\n", "if", "not", "np", ".", "any", "(", "true_group", ")", ":", "\n", "                ", "continue", "\n", "", "y_pred", "=", "self", ".", "classified_dataset", ".", "labels", "[", "classified_group", "]", ".", "ravel", "(", ")", "\n", "y_true", "=", "self", ".", "dataset", ".", "labels", "[", "true_group", "]", ".", "ravel", "(", ")", "\n", "y_pred", "=", "(", "y_pred", "==", "self", ".", "classified_dataset", ".", "favorable_label", ")", ".", "astype", "(", "\n", "np", ".", "float64", ")", "\n", "y_true", "=", "(", "y_true", "==", "self", ".", "dataset", ".", "favorable_label", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "b", "[", "true_group", "]", "=", "np", ".", "mean", "(", "1", "+", "y_pred", "-", "y_true", ")", "\n", "\n", "", "if", "alpha", "==", "1", ":", "\n", "            ", "return", "np", ".", "mean", "(", "np", ".", "log", "(", "(", "b", "/", "np", ".", "mean", "(", "b", ")", ")", "**", "b", ")", "/", "np", ".", "mean", "(", "b", ")", ")", "\n", "", "elif", "alpha", "==", "0", ":", "\n", "            ", "return", "-", "np", ".", "mean", "(", "np", ".", "log", "(", "b", "/", "np", ".", "mean", "(", "b", ")", ")", "/", "np", ".", "mean", "(", "b", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "mean", "(", "(", "b", "/", "np", ".", "mean", "(", "b", ")", ")", "**", "alpha", "-", "1", ")", "/", "(", "alpha", "*", "(", "alpha", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.between_all_groups_generalized_entropy_index": [[745, 760], ["list", "classification_metric.ClassificationMetric._between_group_generalized_entropy_index", "map", "zip", "dict", "itertools.product", "zip"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric._between_group_generalized_entropy_index"], ["", "", "def", "between_all_groups_generalized_entropy_index", "(", "self", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "\"\"\"Between-group generalized entropy index that uses all combinations of\n        groups based on `self.dataset.protected_attributes`. See\n        :meth:`_between_group_generalized_entropy_index`.\n\n        Args:\n            alpha (int): See :meth:`generalized_entropy_index`.\n        \"\"\"", "\n", "all_values", "=", "list", "(", "map", "(", "np", ".", "concatenate", ",", "zip", "(", "\n", "self", ".", "dataset", ".", "privileged_protected_attributes", ",", "\n", "self", ".", "dataset", ".", "unprivileged_protected_attributes", ")", ")", ")", "\n", "groups", "=", "[", "[", "dict", "(", "zip", "(", "self", ".", "dataset", ".", "protected_attribute_names", ",", "vals", ")", ")", "]", "\n", "for", "vals", "in", "product", "(", "*", "all_values", ")", "]", "\n", "return", "self", ".", "_between_group_generalized_entropy_index", "(", "groups", "=", "groups", ",", "\n", "alpha", "=", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.between_group_generalized_entropy_index": [[761, 772], ["classification_metric.ClassificationMetric._between_group_generalized_entropy_index", "classification_metric.ClassificationMetric._to_condition", "classification_metric.ClassificationMetric._to_condition"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric._between_group_generalized_entropy_index", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric._to_condition"], ["", "def", "between_group_generalized_entropy_index", "(", "self", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "\"\"\"Between-group generalized entropy index that uses\n        `self.privileged_groups` and `self.unprivileged_groups` as the only two\n        groups. See :meth:`_between_group_generalized_entropy_index`.\n\n        Args:\n            alpha (int): See :meth:`generalized_entropy_index`.\n        \"\"\"", "\n", "groups", "=", "[", "self", ".", "_to_condition", "(", "False", ")", ",", "self", ".", "_to_condition", "(", "True", ")", "]", "\n", "return", "self", ".", "_between_group_generalized_entropy_index", "(", "groups", "=", "groups", ",", "\n", "alpha", "=", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.theil_index": [[773, 778], ["classification_metric.ClassificationMetric.generalized_entropy_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["", "def", "theil_index", "(", "self", ")", ":", "\n", "        ", "r\"\"\"The Theil index is the :meth:`generalized_entropy_index` with\n        :math:`\\alpha = 1`.\n        \"\"\"", "\n", "return", "self", ".", "generalized_entropy_index", "(", "alpha", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.coefficient_of_variation": [[779, 784], ["numpy.sqrt", "classification_metric.ClassificationMetric.generalized_entropy_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["", "def", "coefficient_of_variation", "(", "self", ")", ":", "\n", "        ", "r\"\"\"The coefficient of variation is the square root of two times the\n        :meth:`generalized_entropy_index` with :math:`\\alpha = 2`.\n        \"\"\"", "\n", "return", "np", ".", "sqrt", "(", "2", "*", "self", ".", "generalized_entropy_index", "(", "alpha", "=", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.between_group_theil_index": [[785, 790], ["classification_metric.ClassificationMetric.between_group_generalized_entropy_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_generalized_entropy_index"], ["", "def", "between_group_theil_index", "(", "self", ")", ":", "\n", "        ", "r\"\"\"The between-group Theil index is the\n        :meth:`between_group_generalized_entropy_index` with :math:`\\alpha = 1`.\n        \"\"\"", "\n", "return", "self", ".", "between_group_generalized_entropy_index", "(", "alpha", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.between_group_coefficient_of_variation": [[791, 797], ["numpy.sqrt", "classification_metric.ClassificationMetric.between_group_generalized_entropy_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_generalized_entropy_index"], ["", "def", "between_group_coefficient_of_variation", "(", "self", ")", ":", "\n", "        ", "r\"\"\"The between-group coefficient of variation is the square\n        root of two times the :meth:`between_group_generalized_entropy_index` with\n        :math:`\\alpha = 2`.\n        \"\"\"", "\n", "return", "np", ".", "sqrt", "(", "2", "*", "self", ".", "between_group_generalized_entropy_index", "(", "alpha", "=", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.between_all_groups_theil_index": [[798, 804], ["classification_metric.ClassificationMetric.between_all_groups_generalized_entropy_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_generalized_entropy_index"], ["", "def", "between_all_groups_theil_index", "(", "self", ")", ":", "\n", "        ", "r\"\"\"The between-group Theil index is the\n        :meth:`between_all_groups_generalized_entropy_index` with\n        :math:`\\alpha = 1`.\n        \"\"\"", "\n", "return", "self", ".", "between_all_groups_generalized_entropy_index", "(", "alpha", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.between_all_groups_coefficient_of_variation": [[805, 812], ["numpy.sqrt", "classification_metric.ClassificationMetric.between_all_groups_generalized_entropy_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_generalized_entropy_index"], ["", "def", "between_all_groups_coefficient_of_variation", "(", "self", ")", ":", "\n", "        ", "r\"\"\"The between-group coefficient of variation is the square\n        root of two times the :meth:`between_all_groups_generalized_entropy_index` with\n        :math:`\\alpha = 2`.\n        \"\"\"", "\n", "return", "np", ".", "sqrt", "(", "2", "*", "self", ".", "between_all_groups_generalized_entropy_index", "(", "\n", "alpha", "=", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.differential_fairness_bias_amplification": [[813, 836], ["classification_metric.ClassificationMetric._smoothed_base_rates", "max", "classification_metric.ClassificationMetric.smoothed_empirical_differential_fairness", "abs", "abs", "max", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "classification_metric.ClassificationMetric.differential_fairness_bias_amplification.pos_ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric._smoothed_base_rates", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.smoothed_empirical_differential_fairness"], ["", "def", "differential_fairness_bias_amplification", "(", "self", ",", "concentration", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"Bias amplification is the difference in smoothed EDF between the\n        classifier and the original dataset. Positive values mean the bias\n        increased due to the classifier.\n\n        Args:\n            concentration (float, optional): Concentration parameter for\n                Dirichlet smoothing. Must be non-negative.\n        \"\"\"", "\n", "ssr", "=", "self", ".", "_smoothed_base_rates", "(", "self", ".", "classified_dataset", ".", "labels", ",", "\n", "concentration", ")", "\n", "\n", "def", "pos_ratio", "(", "i", ",", "j", ")", ":", "\n", "            ", "return", "abs", "(", "np", ".", "log", "(", "ssr", "[", "i", "]", ")", "-", "np", ".", "log", "(", "ssr", "[", "j", "]", ")", ")", "\n", "\n", "", "def", "neg_ratio", "(", "i", ",", "j", ")", ":", "\n", "            ", "return", "abs", "(", "np", ".", "log", "(", "1", "-", "ssr", "[", "i", "]", ")", "-", "np", ".", "log", "(", "1", "-", "ssr", "[", "j", "]", ")", ")", "\n", "\n", "", "edf_clf", "=", "max", "(", "max", "(", "pos_ratio", "(", "i", ",", "j", ")", ",", "neg_ratio", "(", "i", ",", "j", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "ssr", ")", ")", "for", "j", "in", "range", "(", "len", "(", "ssr", ")", ")", "if", "i", "!=", "j", ")", "\n", "edf_data", "=", "self", ".", "smoothed_empirical_differential_fairness", "(", "concentration", ")", "\n", "\n", "return", "edf_clf", "-", "edf_data", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.equal_opportunity_difference": [[838, 841], ["classification_metric.ClassificationMetric.true_positive_rate_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate_difference"], ["", "def", "equal_opportunity_difference", "(", "self", ")", ":", "\n", "        ", "\"\"\"Alias of :meth:`true_positive_rate_difference`.\"\"\"", "\n", "return", "self", ".", "true_positive_rate_difference", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.power": [[842, 845], ["classification_metric.ClassificationMetric.num_true_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives"], ["", "def", "power", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Alias of :meth:`num_true_positives`.\"\"\"", "\n", "return", "self", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.precision": [[846, 849], ["classification_metric.ClassificationMetric.positive_predictive_value"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.positive_predictive_value"], ["", "def", "precision", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Alias of :meth:`positive_predictive_value`.\"\"\"", "\n", "return", "self", ".", "positive_predictive_value", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.recall": [[850, 853], ["classification_metric.ClassificationMetric.true_positive_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate"], ["", "def", "recall", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Alias of :meth:`true_positive_rate`.\"\"\"", "\n", "return", "self", ".", "true_positive_rate", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.sensitivity": [[854, 857], ["classification_metric.ClassificationMetric.true_positive_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate"], ["", "def", "sensitivity", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Alias of :meth:`true_positive_rate`.\"\"\"", "\n", "return", "self", ".", "true_positive_rate", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.specificity": [[858, 861], ["classification_metric.ClassificationMetric.true_negative_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate"], ["", "def", "specificity", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "\"\"\"Alias of :meth:`true_negative_rate`.\"\"\"", "\n", "return", "self", ".", "true_negative_rate", "(", "privileged", "=", "privileged", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metric.Metric.__init__": [[48, 59], ["isinstance", "TypeError"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "__init__", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "\"\"\"Initialize a `Metrics` object.\n\n        Args:\n            dataset (Dataset): Dataset on which to evaluate metrics.\n        \"\"\"", "\n", "if", "isinstance", "(", "dataset", ",", "Dataset", ")", ":", "\n", "            ", "self", ".", "dataset", "=", "dataset", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\"dataset must be of Dataset class\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metric._make_key": [[9, 19], ["object", "kwargs.items", "isinstance"], "function", ["None"], ["def", "_make_key", "(", "args", ",", "kwargs", ",", "unhashable", ",", "kwd_mark", "=", "(", "object", "(", ")", ",", ")", ")", ":", "\n", "    ", "\"\"\"Simplified version of functools.\"\"\"", "\n", "key", "=", "args", "\n", "if", "kwargs", ":", "\n", "        ", "key", "+=", "kwd_mark", "\n", "for", "item", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "item", "[", "1", "]", ",", "Hashable", ")", ":", "\n", "                ", "return", "unhashable", "\n", "", "key", "+=", "item", "\n", "", "", "return", "key", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.metric.memoize": [[20, 42], ["object", "object", "functools.wraps", "metric._make_key", "cache.get", "func", "func"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.metric._make_key"], ["", "def", "memoize", "(", "func", ")", ":", "\n", "    ", "\"\"\"Based off functools.lru_cache (not available in Python 2).\n\n    A little inefficient but we're just storing floats.\n    \"\"\"", "\n", "sentinal", "=", "object", "(", ")", "\n", "unhashable", "=", "object", "(", ")", "\n", "cache", "=", "{", "}", "\n", "\n", "@", "wraps", "(", "func", ")", "\n", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "key", "=", "_make_key", "(", "args", ",", "kwargs", ",", "unhashable", ")", "\n", "if", "key", "is", "unhashable", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "result", "=", "cache", ".", "get", "(", "key", ",", "sentinal", ")", "\n", "if", "result", "is", "not", "sentinal", ":", "\n", "            ", "return", "result", "\n", "", "result", "=", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "cache", "[", "key", "]", "=", "result", "\n", "return", "result", "\n", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector": [[5, 40], ["numpy.zeros", "numpy.ones", "numpy.ones", "group.items", "numpy.logical_or", "feature_names.index", "numpy.logical_and"], "function", ["None"], ["from", "sklearn", ".", "utils", ".", "validation", "import", "column_or_1d", "\n", "\n", "\n", "def", "check_inputs", "(", "X", ",", "y", ",", "sample_weight", "=", "None", ",", "ensure_2d", "=", "True", ")", ":", "\n", "    ", "\"\"\"Input validation for debiasing algorithms.\n\n    Checks all inputs for consistent length, validates shapes (optional for X),\n    and returns an array of all ones if sample_weight is ``None``.\n\n    Args:\n        X (array-like): Input data.\n        y (array-like, shape = (n_samples,)): Target values.\n        sample_weight (array-like, optional): Sample weights.\n        ensure_2d (bool, optional): Whether to raise a ValueError if X is not\n            2D.\n\n    Returns:\n        tuple:\n\n            * **X** (`array-like`) -- Validated X. Unchanged.\n\n            * **y** (`array-like`) -- Validated y. Possibly converted to 1D if\n              not a :class:`pandas.Series`.\n            * **sample_weight** (`array-like`) -- Validated sample_weight. If no\n              sample_weight is provided, returns a consistent-length array of\n              ones.\n    \"\"\"", "\n", "if", "ensure_2d", "and", "X", ".", "ndim", "!=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Expected X to be 2D, got ndim == {} instead.\"", ".", "format", "(", "\n", "X", ".", "ndim", ")", ")", "\n", "", "if", "not", "isinstance", "(", "y", ",", "pd", ".", "Series", ")", ":", "# don't cast Series -> ndarray", "\n", "        ", "y", "=", "column_or_1d", "(", "y", ")", "\n", "", "if", "sample_weight", "is", "not", "None", ":", "\n", "        ", "sample_weight", "=", "column_or_1d", "(", "sample_weight", ")", "\n", "", "else", ":", "\n", "        ", "sample_weight", "=", "np", ".", "ones", "(", "X", ".", "shape", "[", "0", "]", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_instances": [[41, 60], ["utils.compute_boolean_conditioning_vector", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector"], ["", "check_consistent_length", "(", "X", ",", "y", ",", "sample_weight", ")", "\n", "return", "X", ",", "y", ",", "sample_weight", "\n", "\n", "", "def", "check_groups", "(", "arr", ",", "prot_attr", ",", "ensure_binary", "=", "False", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_pos_neg": [[61, 82], ["y.ravel.ravel", "utils.compute_boolean_conditioning_vector", "numpy.sum", "numpy.logical_and"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector"], ["\n", "if", "not", "hasattr", "(", "arr", ",", "'index'", ")", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "\"Expected `Series` or `DataFrame`, got {} instead.\"", ".", "format", "(", "\n", "type", "(", "arr", ")", ".", "__name__", ")", ")", "\n", "\n", "", "all_prot_attrs", "=", "[", "name", "for", "name", "in", "arr", ".", "index", ".", "names", "if", "name", "]", "# not None or ''", "\n", "if", "prot_attr", "is", "None", ":", "\n", "        ", "prot_attr", "=", "all_prot_attrs", "\n", "", "elif", "not", "is_list_like", "(", "prot_attr", ")", ":", "\n", "        ", "prot_attr", "=", "[", "prot_attr", "]", "\n", "\n", "", "if", "any", "(", "p", "not", "in", "arr", ".", "index", ".", "names", "for", "p", "in", "prot_attr", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Some of the attributes provided are not present \"", "\n", "\"in the dataset. Expected a subset of:\\n{}\\nGot:\\n\"", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_TF_PN": [[83, 122], ["utils.compute_boolean_conditioning_vector", "y_true.ravel.ravel", "y_pred.ravel.ravel", "numpy.logical_and", "numpy.logical_and", "dict", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector"], ["\"{}\"", ".", "format", "(", "all_prot_attrs", ",", "prot_attr", ")", ")", "\n", "\n", "", "groups", "=", "arr", ".", "index", ".", "droplevel", "(", "list", "(", "set", "(", "arr", ".", "index", ".", "names", ")", "-", "set", "(", "prot_attr", ")", ")", ")", "\n", "groups", "=", "groups", ".", "to_flat_index", "(", ")", "\n", "\n", "n_unique", "=", "groups", ".", "nunique", "(", ")", "\n", "if", "ensure_binary", "and", "n_unique", "!=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Expected 2 protected attribute groups, got {}\"", ".", "format", "(", "\n", "groups", ".", "unique", "(", ")", "if", "n_unique", ">", "5", "else", "n_unique", ")", ")", "\n", "\n", "", "return", "groups", ",", "prot_attr", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_num_gen_TF_PN": [[124, 165], ["utils.compute_boolean_conditioning_vector", "y_true.ravel.ravel", "y_score.ravel.ravel", "w.ravel.ravel", "numpy.logical_and", "numpy.logical_and", "dict", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector"], []], "home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_distance": [[167, 198], ["utils.compute_boolean_conditioning_vector", "numpy.zeros", "range", "dist_fun"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.utils.compute_boolean_conditioning_vector", "home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range"], []], "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.__init__": [[19, 21], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "scoring_function", ":", "ScoringFunction", ")", ":", "\n", "        ", "self", ".", "scoring_function", "=", "scoring_function", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.get_aggregates": [[22, 87], ["set", "pandas.concat.groupby", "pandas.concat.iloc[].sum", "coordinates[].isin().all", "pandas.concat", "pandas.concat", "group.iloc[].sum", "scoring_function.compute_qs", "sorted", "set.update", "coordinates[].isin", "current_subset.keys"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.compute_qs"], ["", "def", "get_aggregates", "(", "self", ",", "coordinates", ":", "pd", ".", "DataFrame", ",", "outcomes", ":", "pd", ".", "Series", ",", "expectations", ":", "pd", ".", "Series", ",", "\n", "current_subset", ":", "dict", ",", "column_name", ":", "str", ",", "penalty", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Conditioned on the current subsets of values for all other attributes,\n        compute the summed outcome (observed_sum = \\sum_i y_i) and all expectations p_i\n        for each value of the current attribute.\n        Also use additive linear-time subset scanning to compute the set of distinct thresholds\n        for which different subsets of attribute values have positive scores. Note that the number\n        of such thresholds will be linear rather than exponential in the arity of the attribute.\n\n        :param coordinates: data frame containing having as columns the covariates/features\n        :param expectations: data series containing the expectations/expected outcomes\n        :param outcomes: data series containing the outcomes/observed outcomes\n        :param current_subset: current subset to compute aggregates\n        :param column_name: attribute name to scan over\n        :param penalty: penalty coefficient\n        :return: dictionary of aggregates, sorted thresholds (roots), observed sum of the subset, array of observed\n        expectations\n        \"\"\"", "\n", "\n", "# compute the subset of records matching the current subgroup along all other dimensions", "\n", "# temp_df includes the covariates x_i, outcome y_i, and predicted expectation p_i for each matching record", "\n", "if", "current_subset", ":", "\n", "            ", "to_choose", "=", "coordinates", "[", "current_subset", ".", "keys", "(", ")", "]", ".", "isin", "(", "current_subset", ")", ".", "all", "(", "axis", "=", "1", ")", "\n", "temp_df", "=", "pd", ".", "concat", "(", "[", "coordinates", ".", "loc", "[", "to_choose", "]", ",", "outcomes", "[", "to_choose", "]", ",", "expectations", "[", "to_choose", "]", "]", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "temp_df", "=", "pd", ".", "concat", "(", "[", "coordinates", ",", "outcomes", ",", "expectations", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# these wil be used to keep track of the aggregate values and the distinct thresholds to be considered", "\n", "", "aggregates", "=", "{", "}", "\n", "thresholds", "=", "set", "(", ")", "\n", "\n", "scoring_function", "=", "self", ".", "scoring_function", "\n", "\n", "# consider each distinct value of the given attribute (column_name)", "\n", "for", "name", ",", "group", "in", "temp_df", ".", "groupby", "(", "column_name", ")", ":", "\n", "# compute the sum of outcomes \\sum_i y_i", "\n", "            ", "observed_sum", "=", "group", ".", "iloc", "[", ":", ",", "-", "2", "]", ".", "sum", "(", ")", "\n", "\n", "# all expectations p_i", "\n", "expectations", "=", "group", ".", "iloc", "[", ":", ",", "-", "1", "]", ".", "values", "\n", "\n", "# compute q_min and q_max for the attribute value", "\n", "exist", ",", "q_mle", ",", "q_min", ",", "q_max", "=", "scoring_function", ".", "compute_qs", "(", "observed_sum", ",", "expectations", ",", "penalty", ")", "\n", "\n", "# Add to aggregates, and add q_min and q_max to thresholds.", "\n", "# Note that thresholds is a set so duplicates will be removed automatically.", "\n", "if", "exist", ":", "\n", "                ", "aggregates", "[", "name", "]", "=", "{", "\n", "'q_mle'", ":", "q_mle", ",", "\n", "'q_min'", ":", "q_min", ",", "\n", "'q_max'", ":", "q_max", ",", "\n", "'observed_sum'", ":", "observed_sum", ",", "\n", "'expectations'", ":", "expectations", "\n", "}", "\n", "thresholds", ".", "update", "(", "[", "q_min", ",", "q_max", "]", ")", "\n", "\n", "# We also keep track of the summed outcomes \\sum_i y_i and the expectations p_i for the case where _", "\n", "# all_ values of that attribute are considered (regardless of whether they contribute positively to score).", "\n", "# This is necessary because of the way we compute the penalty term: including all attribute values, equivalent", "\n", "# to ignoring the attribute, has the lowest penalty (of 0) and thus we need to score that subset as well.", "\n", "", "", "all_observed_sum", "=", "temp_df", ".", "iloc", "[", ":", ",", "-", "2", "]", ".", "sum", "(", ")", "\n", "all_expectations", "=", "temp_df", ".", "iloc", "[", ":", ",", "-", "1", "]", ".", "values", "\n", "\n", "return", "[", "aggregates", ",", "sorted", "(", "thresholds", ")", ",", "all_observed_sum", ",", "all_expectations", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.choose_aggregates": [[88, 165], ["range", "scoring_function.qmle", "scoring_function.score", "aggregates.items", "numpy.asarray", "scoring_function.qmle", "scoring_function.score", "len", "len", "names.append", "len", "value[].tolist"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.qmle", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.qmle", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score"], ["", "def", "choose_aggregates", "(", "self", ",", "aggregates", ":", "dict", ",", "thresholds", ":", "list", ",", "penalty", ":", "float", ",", "all_observed_sum", ":", "float", ",", "\n", "all_expectations", ":", "list", ")", ":", "\n", "        ", "\"\"\"\n        Having previously computed the aggregates and the distinct q thresholds\n        to consider in the get_aggregates function,we are now ready to choose the best\n        subset of attribute values for the given attribute.\n        For each range defined by these thresholds, we will choose all of the positive contributions,\n        compute the MLE value of q, and the corresponding score.\n        We then pick the best q and score over all of the ranges considered.\n\n        :param aggregates: dictionary of aggregates. For each feature value, it has q_mle, q_min, q_max, observed_sum,\n        and the expectations\n        :param thresholds: sorted thresholds (roots)\n        :param penalty: penalty coefficient\n        :param all_observed_sum: sum of observed binary outcomes for all i\n        :param all_expectations: data series containing all the expectations/expected outcomes\n        :return:\n        \"\"\"", "\n", "# initialize", "\n", "best_score", "=", "0", "\n", "best_names", "=", "[", "]", "\n", "\n", "scoring_function", "=", "self", ".", "scoring_function", "\n", "\n", "# for each threshold", "\n", "for", "i", "in", "range", "(", "len", "(", "thresholds", ")", "-", "1", ")", ":", "\n", "            ", "threshold", "=", "(", "thresholds", "[", "i", "]", "+", "thresholds", "[", "i", "+", "1", "]", ")", "/", "2", "\n", "observed_sum", "=", "0.0", "\n", "expectations", "=", "[", "]", "\n", "names", "=", "[", "]", "\n", "\n", "# keep only the aggregates which have a positive contribution to the score in that q range", "\n", "# we must keep track of the sum of outcome values as well as all predicted expectations", "\n", "for", "key", ",", "value", "in", "aggregates", ".", "items", "(", ")", ":", "\n", "                ", "if", "(", "value", "[", "'q_min'", "]", "<", "threshold", ")", "&", "(", "value", "[", "'q_max'", "]", ">", "threshold", ")", ":", "\n", "                    ", "names", ".", "append", "(", "key", ")", "\n", "observed_sum", "+=", "value", "[", "'observed_sum'", "]", "\n", "expectations", "=", "expectations", "+", "value", "[", "'expectations'", "]", ".", "tolist", "(", ")", "\n", "\n", "", "", "if", "len", "(", "expectations", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "# compute the MLE value of q, making sure to only consider the desired direction (positive or negative)", "\n", "", "expectations", "=", "np", ".", "asarray", "(", "expectations", ")", "\n", "current_q_mle", "=", "scoring_function", ".", "qmle", "(", "observed_sum", ",", "expectations", ")", "\n", "\n", "# Compute the score for the given subset at the MLE value of q.", "\n", "# Notice that each included value gets a penalty, so the total penalty", "\n", "# is multiplied by the number of included values.", "\n", "current_interval_score", "=", "scoring_function", ".", "score", "(", "observed_sum", ",", "expectations", ",", "penalty", "*", "len", "(", "names", ")", ",", "current_q_mle", ")", "\n", "\n", "# keep track of the best score, best q, and best subset of attribute values found so far", "\n", "if", "current_interval_score", ">", "best_score", ":", "\n", "                ", "best_score", "=", "current_interval_score", "\n", "best_names", "=", "names", "\n", "\n", "# Now we also have to consider the case of including all attribute values,", "\n", "# including those that never make positive contributions to the score.", "\n", "# Note that the penalty term is 0 in this case.  (We are neglecting penalties", "\n", "# from all other attributes, just considering the current attribute.)", "\n", "\n", "# compute the MLE value of q, making sure to only consider the desired direction (positive or negative)", "\n", "", "", "current_q_mle", "=", "scoring_function", ".", "qmle", "(", "all_observed_sum", ",", "all_expectations", ")", "\n", "\n", "# Compute the score for the given subset at the MLE value of q.", "\n", "# Again, the penalty (for that attribute) is 0 when all attribute values are included.", "\n", "\n", "current_score", "=", "scoring_function", ".", "score", "(", "all_observed_sum", ",", "all_expectations", ",", "0", ",", "current_q_mle", ")", "\n", "\n", "# Keep track of the best score, best q, and best subset of attribute values found.", "\n", "# Note that if the best subset contains all values of the given attribute,", "\n", "# we return an empty list for best_names.", "\n", "if", "current_score", ">", "best_score", ":", "\n", "            ", "best_score", "=", "current_score", "\n", "best_names", "=", "[", "]", "\n", "\n", "", "return", "[", "best_names", ",", "best_score", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.score_current_subset": [[166, 207], ["pandas.concat.iloc[].sum", "scoring_function.qmle", "current_subset.items", "scoring_function.score", "numpy.round", "coordinates[].isin().all", "pandas.concat", "pandas.concat", "len", "coordinates[].isin", "current_subset.keys"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.qmle", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score"], ["", "def", "score_current_subset", "(", "self", ",", "coordinates", ":", "pd", ".", "DataFrame", ",", "expectations", ":", "pd", ".", "Series", ",", "outcomes", ":", "pd", ".", "Series", ",", "\n", "current_subset", ":", "dict", ",", "penalty", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Just scores the subset without performing ALTSS.\n        We still need to determine the MLE value of q.\n\n        :param coordinates: data frame containing having as columns the covariates/features\n        :param expectations: data series containing the expectations/expected outcomes\n        :param outcomes: data series containing the outcomes/observed outcomes\n        :param current_subset: current subset to be scored\n        :param penalty: penalty coefficient\n        :return: penalized score of subset\n        \"\"\"", "\n", "\n", "# compute the subset of records matching the current subgroup along all dimensions", "\n", "# temp_df includes the covariates x_i, outcome y_i, and predicted expectation p_i for each matching record", "\n", "if", "current_subset", ":", "\n", "            ", "to_choose", "=", "coordinates", "[", "current_subset", ".", "keys", "(", ")", "]", ".", "isin", "(", "current_subset", ")", ".", "all", "(", "axis", "=", "1", ")", "\n", "temp_df", "=", "pd", ".", "concat", "(", "[", "coordinates", ".", "loc", "[", "to_choose", "]", ",", "outcomes", "[", "to_choose", "]", ",", "expectations", "[", "to_choose", "]", "]", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "temp_df", "=", "pd", ".", "concat", "(", "[", "coordinates", ",", "outcomes", ",", "expectations", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "scoring_function", "=", "self", ".", "scoring_function", "\n", "\n", "# we must keep track of the sum of outcome values as well as all predicted expectations", "\n", "observed_sum", "=", "temp_df", ".", "iloc", "[", ":", ",", "-", "2", "]", ".", "sum", "(", ")", "\n", "expectations", "=", "temp_df", ".", "iloc", "[", ":", ",", "-", "1", "]", ".", "values", "\n", "\n", "# compute the MLE value of q, making sure to only consider the desired direction (positive or negative)", "\n", "current_q_mle", "=", "scoring_function", ".", "qmle", "(", "observed_sum", ",", "expectations", ")", "\n", "\n", "# total_penalty = penalty * sum of list lengths in current_subset", "\n", "total_penalty", "=", "0", "\n", "for", "key", ",", "values", "in", "current_subset", ".", "items", "(", ")", ":", "\n", "            ", "total_penalty", "+=", "len", "(", "values", ")", "\n", "\n", "", "total_penalty", "*=", "penalty", "\n", "\n", "# Compute and return the penalized score    ", "\n", "penalized_score", "=", "scoring_function", ".", "score", "(", "observed_sum", ",", "expectations", ",", "total_penalty", ",", "current_q_mle", ")", "\n", "return", "np", ".", "round", "(", "penalized_score", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.scan": [[208, 375], ["numpy.random.seed", "isinstance", "isinstance", "isinstance", "isinstance", "range", "expectations.unique", "expectations.var", "numpy.empty", "numpy.empty.fill", "MDSS.MDSS.score_current_subset", "best_scores.append", "isinstance", "Exception", "outcomes.quantile", "numpy.abs", "numpy.abs", "len", "aif360.detectors.mdss.generator.get_entire_subset", "aif360.detectors.mdss.generator.get_random_subset", "numpy.empty.sum", "len", "numpy.random.choice", "MDSS.MDSS.get_aggregates", "MDSS.MDSS.choose_aggregates", "current_subset.copy", "MDSS.MDSS.score_current_subset", "print", "print", "current_subset.copy", "len", "expectations.min", "outcomes.min", "numpy.random.rand().item", "len", "numpy.random.choice", "numpy.empty.fill", "print", "print", "len", "isinstance", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.celisMeta.General.General.range", "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.score_current_subset", "home.repos.pwc.inspect_result.IBM_AIF360.mdss.generator.get_entire_subset", "home.repos.pwc.inspect_result.IBM_AIF360.mdss.generator.get_random_subset", "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.get_aggregates", "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.choose_aggregates", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.mdss.MDSS.MDSS.score_current_subset", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "scan", "(", "self", ",", "coordinates", ":", "pd", ".", "DataFrame", ",", "expectations", ":", "pd", ".", "Series", ",", "outcomes", ":", "pd", ".", "Series", ",", "penalty", ":", "float", ",", "\n", "num_iters", ":", "int", ",", "verbose", ":", "bool", "=", "False", ",", "seed", ":", "int", "=", "0", ",", "mode", ":", "str", "=", "'binary'", ")", ":", "\n", "        ", "\"\"\"\n        :param coordinates: data frame containing having as columns the covariates/features\n        :param expectations: data series containing the expectations/expected outcomes\n        :param outcomes: data series containing the outcomes/observed outcomes\n        :param penalty: penalty coefficient\n        :param num_iters: number of iteration\n        :param verbose: logging flag\n        :param seed: numpy seed. Default equals 0\n        :param mode: one of ['binary', 'continuous', 'nominal', 'ordinal']. Defaults to binary.\n        :return: [best subset, best score]\n        \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "# Check that the appropriate scoring function is used", "\n", "\n", "if", "isinstance", "(", "self", ".", "scoring_function", ",", "BerkJones", ")", ":", "\n", "            ", "modes", "=", "[", "\"binary\"", ",", "\"continuous\"", ",", "\"nominal\"", ",", "\"ordinal\"", "]", "\n", "assert", "mode", "in", "modes", ",", "f\"Expected one of {modes} for BerkJones,  got {mode}.\"", "\n", "\n", "# Ensure that BerkJones only work in Autostrat mode", "\n", "unique_expectations", "=", "expectations", ".", "unique", "(", ")", "\n", "if", "isinstance", "(", "self", ".", "scoring_function", ",", "BerkJones", ")", "and", "len", "(", "unique_expectations", ")", "!=", "1", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"BerkJones scorer supports scanning in autostrat mode only.\"", "\n", ")", "\n", "\n", "# Bin the continuous outcomes column for Berk Jones in continuous mode", "\n", "", "alpha", "=", "self", ".", "scoring_function", ".", "alpha", "\n", "direction", "=", "self", ".", "scoring_function", ".", "direction", "\n", "\n", "if", "mode", "==", "\"continuous\"", ":", "\n", "                ", "quantile", "=", "outcomes", ".", "quantile", "(", "alpha", ")", "\n", "outcomes", "=", "(", "outcomes", ">", "quantile", ")", ".", "apply", "(", "int", ")", "\n", "\n", "# Flip outcomes to scan in the negative direction for BerkJones", "\n", "# This is equivalent to switching the p-values", "\n", "", "if", "direction", "==", "\"negative\"", ":", "\n", "                ", "outcomes", "=", "1", "-", "outcomes", "\n", "\n", "", "", "if", "isinstance", "(", "self", ".", "scoring_function", ",", "Bernoulli", ")", ":", "\n", "            ", "modes", "=", "[", "\"binary\"", ",", "\"nominal\"", "]", "\n", "assert", "mode", "in", "modes", ",", "f\"Expected one of {modes} for Bernoulli,  got {mode}.\"", "\n", "\n", "", "if", "isinstance", "(", "self", ".", "scoring_function", ",", "Gaussian", ")", ":", "\n", "            ", "assert", "mode", "==", "'continuous'", ",", "f\"Expected continuous, got {mode}.\"", "\n", "\n", "# Set variance for Gaussian", "\n", "self", ".", "scoring_function", ".", "var", "=", "expectations", ".", "var", "(", ")", "\n", "\n", "# Move entire distribution to the positive axis", "\n", "shift", "=", "np", ".", "abs", "(", "expectations", ".", "min", "(", ")", ")", "+", "np", ".", "abs", "(", "outcomes", ".", "min", "(", ")", ")", "\n", "outcomes", "=", "outcomes", "+", "shift", "\n", "expectations", "=", "expectations", "+", "shift", "\n", "\n", "", "if", "isinstance", "(", "self", ".", "scoring_function", ",", "Poisson", ")", ":", "\n", "            ", "modes", "=", "[", "\"binary\"", ",", "\"ordinal\"", "]", "\n", "assert", "mode", "in", "modes", ",", "f\"Expected one of {modes} for Poisson,  got {mode}.\"", "\n", "\n", "# initialize", "\n", "", "best_subset", "=", "{", "}", "\n", "best_score", "=", "-", "1e10", "\n", "best_scores", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_iters", ")", ":", "\n", "# flags indicates that the method has optimized over subsets for a given attribute.", "\n", "# The iteration ends when it cannot further increase score by optimizing over", "\n", "# subsets of any attribute, i.e., when all flags are 1.", "\n", "            ", "flags", "=", "np", ".", "empty", "(", "len", "(", "coordinates", ".", "columns", ")", ")", "\n", "flags", ".", "fill", "(", "0", ")", "\n", "\n", "# Starting subset. Note that we start with all values for the first iteration", "\n", "# and random values for succeeding iterations.", "\n", "current_subset", "=", "get_entire_subset", "(", ")", "if", "(", "i", "==", "0", ")", "else", "get_random_subset", "(", "coordinates", ",", "np", ".", "random", ".", "rand", "(", "1", ")", ".", "item", "(", ")", ",", "10", ")", "\n", "\n", "# score the entire population", "\n", "current_score", "=", "self", ".", "score_current_subset", "(", "\n", "coordinates", "=", "coordinates", ",", "\n", "expectations", "=", "expectations", ",", "\n", "outcomes", "=", "outcomes", ",", "\n", "penalty", "=", "penalty", ",", "\n", "current_subset", "=", "current_subset", "\n", ")", "\n", "\n", "while", "flags", ".", "sum", "(", ")", "<", "len", "(", "coordinates", ".", "columns", ")", ":", "\n", "\n", "# choose random attribute that we haven't scanned yet", "\n", "                ", "attribute_number_to_scan", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "coordinates", ".", "columns", ")", ")", "\n", "while", "flags", "[", "attribute_number_to_scan", "]", ":", "\n", "                    ", "attribute_number_to_scan", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "coordinates", ".", "columns", ")", ")", "\n", "", "attribute_to_scan", "=", "coordinates", ".", "columns", ".", "values", "[", "attribute_number_to_scan", "]", "\n", "\n", "# clear current subset of attribute values for that subset", "\n", "if", "attribute_to_scan", "in", "current_subset", ":", "\n", "                    ", "del", "current_subset", "[", "attribute_to_scan", "]", "\n", "\n", "# call get_aggregates and choose_aggregates to find best subset of attribute values", "\n", "", "aggregates", ",", "thresholds", ",", "all_observed_sum", ",", "all_expectations", "=", "self", ".", "get_aggregates", "(", "\n", "coordinates", "=", "coordinates", ",", "\n", "outcomes", "=", "outcomes", ",", "\n", "expectations", "=", "expectations", ",", "\n", "current_subset", "=", "current_subset", ",", "\n", "column_name", "=", "attribute_to_scan", ",", "\n", "penalty", "=", "penalty", "\n", ")", "\n", "\n", "temp_names", ",", "temp_score", "=", "self", ".", "choose_aggregates", "(", "\n", "aggregates", "=", "aggregates", ",", "\n", "thresholds", "=", "thresholds", ",", "\n", "penalty", "=", "penalty", ",", "\n", "all_observed_sum", "=", "all_observed_sum", ",", "\n", "all_expectations", "=", "all_expectations", "\n", ")", "\n", "\n", "temp_subset", "=", "current_subset", ".", "copy", "(", ")", "\n", "# if temp_names is not empty (or null)", "\n", "if", "temp_names", ":", "\n", "                    ", "temp_subset", "[", "attribute_to_scan", "]", "=", "temp_names", "\n", "\n", "# Note that this call to score_current_subset ensures that", "\n", "# we are penalizing complexity for all attribute values.", "\n", "# The value of temp_score computed by choose_aggregates", "\n", "# above includes only the penalty for the current attribute.", "\n", "", "temp_score", "=", "self", ".", "score_current_subset", "(", "\n", "coordinates", "=", "coordinates", ",", "\n", "expectations", "=", "expectations", ",", "\n", "outcomes", "=", "outcomes", ",", "\n", "penalty", "=", "penalty", ",", "\n", "current_subset", "=", "temp_subset", "\n", ")", "\n", "\n", "# reset flags to 0 if we have improved score", "\n", "if", "temp_score", ">", "current_score", "+", "1E-6", ":", "\n", "                    ", "flags", ".", "fill", "(", "0", ")", "\n", "\n", "# sanity check to make sure score has not decreased", "\n", "# sanity check may not apply to Gaussian in penalized mode (TODO: to check Maths again)", "\n", "", "if", "not", "isinstance", "(", "self", ".", "scoring_function", ",", "Gaussian", ")", "and", "penalty", ">", "0", ":", "\n", "                    ", "assert", "(", "\n", "temp_score", ">=", "current_score", "-", "1e-6", "\n", ")", ",", "\"WARNING SCORE HAS DECREASED from %.6f to %.6f\"", "%", "(", "\n", "current_score", ",", "\n", "temp_score", ",", "\n", ")", "\n", "\n", "", "flags", "[", "attribute_number_to_scan", "]", "=", "1", "\n", "current_subset", "=", "temp_subset", "\n", "current_score", "=", "temp_score", "\n", "\n", "# print out results for current iteration", "\n", "", "if", "verbose", ":", "\n", "                ", "print", "(", "\"Subset found on iteration\"", ",", "i", "+", "1", ",", "\"of\"", ",", "num_iters", ",", "\"with score\"", ",", "current_score", ",", "\":\"", ")", "\n", "print", "(", "current_subset", ")", "\n", "\n", "# update best_score and best_subset if necessary", "\n", "", "if", "current_score", ">", "best_score", ":", "\n", "                ", "best_subset", "=", "current_subset", ".", "copy", "(", ")", "\n", "best_score", "=", "current_score", "\n", "\n", "if", "verbose", ":", "\n", "                    ", "print", "(", "\"Best score is now\"", ",", "best_score", ")", "\n", "\n", "", "", "elif", "verbose", ":", "\n", "                ", "print", "(", "\"Current score of\"", ",", "current_score", ",", "\"does not beat best score of\"", ",", "best_score", ")", "\n", "", "best_scores", ".", "append", "(", "best_score", ")", "\n", "", "return", "best_subset", ",", "best_score", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.mdss.generator.get_entire_subset": [[5, 11], ["None"], "function", ["None"], ["def", "get_entire_subset", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns the entire subset, which is an empty dictionary\n    :return: empty dictionary\n    \"\"\"", "\n", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.mdss.generator.get_random_subset": [[13, 46], ["numpy.random.permutation", "coordinates[].unique", "numpy.random.rand", "mask_values.sum", "len", "temp[].tolist", "coordinates[].isin().all", "len", "len", "coordinates[].isin", "subset_random_values.keys"], "function", ["None"], ["", "def", "get_random_subset", "(", "coordinates", ":", "pd", ".", "DataFrame", ",", "prob", ":", "float", ",", "min_elements", ":", "int", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Returns a random subset\n    :param coordinates: data frame containing having as columns the features\n    :param prob: probability to select a value of a feature\n    :param min_elements: minimum number of elements to be included in the randomly generated sub-population\n    :return: dictionary representing a random sub-population\n    \"\"\"", "\n", "\n", "subset_random_values", "=", "{", "}", "\n", "shuffled_column_names", "=", "np", ".", "random", ".", "permutation", "(", "coordinates", ".", "columns", ".", "values", ")", "\n", "\n", "# consider each column once, in random order", "\n", "for", "column_name", "in", "shuffled_column_names", ":", "\n", "# get unique values of the current column", "\n", "        ", "temp", "=", "coordinates", "[", "column_name", "]", ".", "unique", "(", ")", "\n", "\n", "# include each attribute value with probability = prob", "\n", "mask_values", "=", "np", ".", "random", ".", "rand", "(", "len", "(", "temp", ")", ")", "<", "prob", "\n", "\n", "if", "mask_values", ".", "sum", "(", ")", "<", "len", "(", "temp", ")", ":", "\n", "# set values for the current column", "\n", "            ", "subset_random_values", "[", "column_name", "]", "=", "temp", "[", "mask_values", "]", ".", "tolist", "(", ")", "\n", "\n", "# compute the remaining records", "\n", "mask_subset", "=", "coordinates", "[", "subset_random_values", ".", "keys", "(", ")", "]", ".", "isin", "(", "subset_random_values", ")", ".", "all", "(", "axis", "=", "1", ")", "\n", "remaining_records", "=", "len", "(", "coordinates", ".", "loc", "[", "mask_subset", "]", ")", "\n", "\n", "# only filter on this attribute if at least min_elements records would be kept", "\n", "if", "remaining_records", "<", "min_elements", ":", "\n", "                ", "del", "subset_random_values", "[", "column_name", "]", "\n", "\n", "", "", "", "return", "subset_random_values", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.BerkJones.BerkJones.__init__": [[8, 30], ["aif360.detectors.mdss.ScoringFunctions.ScoringFunction.ScoringFunction.__init__", "BerkJones.BerkJones.kwargs.get"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Berk-Jones score function is a non parametric expectatation based\n        scan statistic that also satisfies the ALTSS property; Non-parametric scoring functions\n        do not make parametric assumptions about the model or outcome [1].\n\n        kwargs must contain\n        'direction (str)' - direction of the severity; could be higher than expected outcomes ('positive') or lower than expected ('negative')\n        'alpha (float)' - the alpha threshold that will be used to compute the score.\n            In practice, it may be useful to search over a grid of alpha thresholds and select the one with the maximum score.\n\n\n        [1] Neill, D. B., & Lingwall, J. (2007). A nonparametric scan statistic for multivariate disease surveillance. Advances in\n        Disease Surveillance, 4(106), 570\n        \"\"\"", "\n", "\n", "super", "(", "BerkJones", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "alpha", "=", "self", ".", "kwargs", ".", "get", "(", "'alpha'", ")", "\n", "assert", "self", ".", "alpha", "is", "not", "None", ",", "\"Warning: calling Berk Jones without alpha\"", "\n", "\n", "if", "self", ".", "direction", "==", "'negative'", ":", "\n", "            ", "self", ".", "alpha", "=", "1", "-", "self", ".", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.BerkJones.BerkJones.score": [[32, 73], ["tuple", "BerkJones.BerkJones.score_cache.get", "numpy.log", "numpy.log", "len", "len", "len", "numpy.log"], "methods", ["None"], ["", "", "def", "score", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ",", "q", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes berk jones score for given q\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param penalty: penalty term. Should be positive\n        :param q: current value of q\n        :return: berk jones score for the current value of q\n        \"\"\"", "\n", "alpha", "=", "self", ".", "alpha", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "len", "(", "expectations", ")", ",", "penalty", ",", "q", ",", "alpha", "]", ")", "\n", "ans", "=", "self", ".", "score_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'score'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "if", "q", "<", "alpha", ":", "\n", "            ", "q", "=", "alpha", "\n", "\n", "", "assert", "q", ">", "0", ",", "(", "\n", "\"Warning: calling compute_score_given_q with \"", "\n", "\"observed_sum=%.2f, expectations of length=%d, penalty=%.2f, q=%.2f, alpha=%.3f\"", "\n", "%", "(", "observed_sum", ",", "len", "(", "expectations", ")", ",", "penalty", ",", "q", ",", "alpha", ")", "\n", ")", "\n", "if", "q", "==", "1", ":", "\n", "            ", "ans", "=", "observed_sum", "*", "np", ".", "log", "(", "q", "/", "alpha", ")", "-", "penalty", "\n", "self", ".", "score_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "\n", "", "a", "=", "observed_sum", "*", "np", ".", "log", "(", "q", "/", "alpha", ")", "\n", "b", "=", "(", "len", "(", "expectations", ")", "-", "observed_sum", ")", "*", "np", ".", "log", "(", "(", "1", "-", "q", ")", "/", "(", "1", "-", "alpha", ")", ")", "\n", "ans", "=", "(", "\n", "a", "\n", "+", "b", "\n", "-", "penalty", "\n", ")", "\n", "\n", "self", ".", "score_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.BerkJones.BerkJones.qmle": [[74, 103], ["tuple", "BerkJones.BerkJones.qmle_cache.get", "len", "len", "len"], "methods", ["None"], ["", "def", "qmle", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ")", ":", "\n", "        ", "\"\"\"\n        Computes the q which maximizes score (q_mle).\n        for berk jones this is given to be N_a/N\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param direction: direction not considered\n        :return: q MLE\n        \"\"\"", "\n", "alpha", "=", "self", ".", "alpha", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "len", "(", "expectations", ")", ",", "alpha", "]", ")", "\n", "ans", "=", "self", ".", "qmle_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'qmle'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "if", "len", "(", "expectations", ")", "==", "0", ":", "\n", "            ", "self", ".", "qmle_cache", "[", "key", "]", "=", "0", "\n", "return", "0", "\n", "", "else", ":", "\n", "            ", "q", "=", "observed_sum", "/", "len", "(", "expectations", ")", "\n", "\n", "", "if", "(", "q", "<", "alpha", ")", ":", "\n", "            ", "self", ".", "qmle_cache", "[", "key", "]", "=", "alpha", "\n", "return", "alpha", "\n", "\n", "", "self", ".", "qmle_cache", "[", "key", "]", "=", "q", "\n", "return", "q", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.BerkJones.BerkJones.compute_qs": [[104, 139], ["tuple", "BerkJones.BerkJones.compute_qs_cache.get", "BerkJones.BerkJones.qmle", "BerkJones.BerkJones.score", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_min", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_max", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.qmle", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_min", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_max"], ["", "def", "compute_qs", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes roots (qmin and qmax) of the score function for given q\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param penalty: penalty coefficient\n        \"\"\"", "\n", "alpha", "=", "self", ".", "alpha", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "len", "(", "expectations", ")", ",", "penalty", ",", "alpha", "]", ")", "\n", "ans", "=", "self", ".", "compute_qs_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'qs'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "q_mle", "=", "self", ".", "qmle", "(", "observed_sum", ",", "expectations", ")", "\n", "\n", "if", "self", ".", "score", "(", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ")", ">", "0", ":", "\n", "            ", "exist", "=", "1", "\n", "q_min", "=", "optim", ".", "bisection_q_min", "(", "\n", "self", ",", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ",", "temp_min", "=", "alpha", "\n", ")", "\n", "q_max", "=", "optim", ".", "bisection_q_max", "(", "\n", "self", ",", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ",", "temp_max", "=", "1", "\n", ")", "\n", "", "else", ":", "\n", "# there are no roots", "\n", "            ", "exist", "=", "0", "\n", "q_min", "=", "0", "\n", "q_max", "=", "0", "\n", "\n", "", "ans", "=", "[", "exist", ",", "q_mle", ",", "q_min", ",", "q_max", "]", "\n", "self", ".", "compute_qs_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.ScoringFunction.ScoringFunction.__init__": [[5, 23], ["ScoringFunction.ScoringFunction._reset", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.ScoringFunction.ScoringFunction._reset"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        This is an abstract class for Scoring Functions (or expectation-based scan statistics).\n\n        [1] introduces a property of many commonly used log-likelihood ratio scan statistics called\n        Additive linear-time subset scanning (ALTSS) that allows for exact of efficient maximization of these\n        statistics over all subsets of the data, without requiring an exhaustive search over all subsets and\n        allows penalty terms to be included.\n\n        [1] Speakman, S., Somanchi, S., McFowland III, E., & Neill, D. B. (2016). Penalized fast subset scanning.\n        Journal of Computational and Graphical Statistics, 25(2), 382-404.\n        \"\"\"", "\n", "self", ".", "kwargs", "=", "kwargs", "\n", "self", ".", "_reset", "(", ")", "\n", "self", ".", "direction", "=", "kwargs", ".", "get", "(", "'direction'", ")", "\n", "\n", "directions", "=", "[", "'positive'", ",", "'negative'", "]", "\n", "assert", "self", ".", "direction", "in", "directions", ",", "f\"Expected one of {directions}, got {self.direction}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.ScoringFunction.ScoringFunction._reset": [[24, 31], ["None"], "methods", ["None"], ["", "def", "_reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "score_cache", "=", "{", "}", "\n", "self", ".", "dscore_cache", "=", "{", "}", "\n", "self", ".", "qdscore_cache", "=", "{", "}", "\n", "self", ".", "qmle_cache", "=", "{", "}", "\n", "self", ".", "compute_qs_cache", "=", "{", "}", "\n", "self", ".", "cache_counter", "=", "{", "\"score\"", ":", "0", ",", "\"dscore\"", ":", "0", ",", "\"qdscore\"", ":", "0", ",", "\"qmle\"", ":", "0", ",", "\"qs\"", ":", "0", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.ScoringFunction.ScoringFunction.score": [[32, 44], ["None"], "methods", ["None"], ["", "def", "score", "(", "\n", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ",", "q", ":", "float", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Computes the score for the given q. (for the given records).\n\n        The alternative hypothesis of MDSS assumes that there exists some constant multiplicative factor q > 1\n        for the subset of records being scored by the scoring function.\n        q is sometimes refered to as relative risk or severity.\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.ScoringFunction.ScoringFunction.dscore": [[45, 50], ["None"], "methods", ["None"], ["", "def", "dscore", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "q", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes the first derivative of the score function\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.ScoringFunction.ScoringFunction.q_dscore": [[51, 56], ["None"], "methods", ["None"], ["", "def", "q_dscore", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "q", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes the first derivative of the score function multiplied by the given q\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.ScoringFunction.ScoringFunction.qmle": [[57, 62], ["None"], "methods", ["None"], ["", "def", "qmle", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ")", ":", "\n", "        ", "\"\"\"\n        Computes the q which maximizes score (q_mle).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.ScoringFunction.ScoringFunction.compute_qs": [[63, 68], ["None"], "methods", ["None"], ["", "def", "compute_qs", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes roots (qmin and qmax) of the score function (for the given records)\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Bernoulli.Bernoulli.__init__": [[8, 18], ["aif360.detectors.mdss.ScoringFunctions.ScoringFunction.ScoringFunction.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Bernoulli score function. May be appropriate to use when the outcome of\n        interest is assumed to be Bernoulli distributed or Binary.\n\n        kwargs must contain\n        'direction (str)' - direction of the severity; could be higher than expected outcomes ('positive') or lower than expected ('negative')\n        \"\"\"", "\n", "\n", "super", "(", "Bernoulli", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Bernoulli.Bernoulli.score": [[19, 45], ["tuple", "Bernoulli.Bernoulli.score_cache.get", "len", "expectations.tostring", "numpy.log().sum", "numpy.log", "numpy.log"], "methods", ["None"], ["", "def", "score", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ",", "q", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes bernoulli bias score for given q\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param penalty: penalty term. Should be positive\n        :param q: current value of q\n        :return: bias score for the current value of q\n        \"\"\"", "\n", "\n", "assert", "q", ">", "0", ",", "(", "\n", "\"Warning: calling compute_score_given_q with \"", "\n", "\"observed_sum=%.2f, expectations of length=%d, penalty=%.2f, q=%.2f\"", "\n", "%", "(", "observed_sum", ",", "len", "(", "expectations", ")", ",", "penalty", ",", "q", ")", "\n", ")", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "tostring", "(", ")", ",", "penalty", ",", "q", "]", ")", "\n", "ans", "=", "self", ".", "score_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'score'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "ans", "=", "observed_sum", "*", "np", ".", "log", "(", "q", ")", "-", "np", ".", "log", "(", "1", "-", "expectations", "+", "q", "*", "expectations", ")", ".", "sum", "(", ")", "-", "penalty", "\n", "self", ".", "score_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Bernoulli.Bernoulli.qmle": [[46, 64], ["tuple", "Bernoulli.Bernoulli.qmle_cache.get", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_mle", "expectations.tostring"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_mle"], ["", "def", "qmle", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ")", ":", "\n", "        ", "\"\"\"\n        Computes the q which maximizes score (q_mle).\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        \"\"\"", "\n", "direction", "=", "self", ".", "direction", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "tostring", "(", ")", "]", ")", "\n", "ans", "=", "self", ".", "qmle_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'qmle'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "ans", "=", "optim", ".", "bisection_q_mle", "(", "self", ",", "observed_sum", ",", "expectations", ",", "direction", "=", "direction", ")", "\n", "self", ".", "qmle_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Bernoulli.Bernoulli.compute_qs": [[65, 100], ["tuple", "Bernoulli.Bernoulli.compute_qs_cache.get", "Bernoulli.Bernoulli.qmle", "Bernoulli.Bernoulli.score", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_min", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_max", "aif360.detectors.mdss.ScoringFunctions.optim.direction_assertions", "expectations.tostring"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.qmle", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_min", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_max", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.direction_assertions"], ["", "def", "compute_qs", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes roots (qmin and qmax) of the score function for given q\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param penalty: penalty coefficient\n        \"\"\"", "\n", "direction", "=", "self", ".", "direction", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "tostring", "(", ")", ",", "penalty", "]", ")", "\n", "ans", "=", "self", ".", "compute_qs_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'qs'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "q_mle", "=", "self", ".", "qmle", "(", "observed_sum", ",", "expectations", ")", "\n", "\n", "if", "self", ".", "score", "(", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ")", ">", "0", ":", "\n", "            ", "exist", "=", "1", "\n", "q_min", "=", "optim", ".", "bisection_q_min", "(", "self", ",", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ")", "\n", "q_max", "=", "optim", ".", "bisection_q_max", "(", "self", ",", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ")", "\n", "", "else", ":", "\n", "# there are no roots", "\n", "            ", "exist", "=", "0", "\n", "q_min", "=", "0", "\n", "q_max", "=", "0", "\n", "\n", "# only consider the desired direction, positive or negative", "\n", "", "if", "exist", ":", "\n", "            ", "exist", ",", "q_min", ",", "q_max", "=", "optim", ".", "direction_assertions", "(", "direction", ",", "q_min", ",", "q_max", ")", "\n", "\n", "", "ans", "=", "[", "exist", ",", "q_mle", ",", "q_min", ",", "q_max", "]", "\n", "self", ".", "compute_qs_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Bernoulli.Bernoulli.q_dscore": [[101, 122], ["tuple", "Bernoulli.Bernoulli.qdscore_cache.get", "expectations.tostring"], "methods", ["None"], ["", "def", "q_dscore", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "q", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        This actually computes q times the slope, which has the same sign as the slope since q is positive.\n        score = Y log q - \\sum_i log(1-p_i+qp_i)\n        dscore/dq = Y/q - \\sum_i (p_i/(1-p_i+qp_i))\n        q dscore/dq = Y - \\sum_i (qp_i/(1-p_i+qp_i))\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param q: current value of q\n        :return: q dscore/dq\n        \"\"\"", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "tostring", "(", ")", ",", "q", "]", ")", "\n", "ans", "=", "self", ".", "qdscore_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'qdscore'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "ans", "=", "observed_sum", "-", "(", "q", "*", "expectations", "/", "(", "1", "-", "expectations", "+", "q", "*", "expectations", ")", ")", ".", "sum", "(", ")", "\n", "self", ".", "qdscore_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Poisson.Poisson.__init__": [[8, 18], ["aif360.detectors.mdss.ScoringFunctions.ScoringFunction.ScoringFunction.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Poisson score function. May be appropriate to use when the outcome of\n        interest is assumed to be Poisson distributed or Binary.\n\n        kwargs must contain\n        'direction (str)' - direction of the severity; could be higher than expected outcomes ('positive') or lower than expected ('negative')\n        \"\"\"", "\n", "\n", "super", "(", "Poisson", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Poisson.Poisson.score": [[19, 44], ["tuple", "Poisson.Poisson.score_cache.get", "len", "expectations.sum", "numpy.log"], "methods", ["None"], ["", "def", "score", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ",", "q", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes poisson bias score for given q\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param penalty: penalty term. Should be positive\n        :param q: current value of q\n        :return: bias score for the current value of q\n        \"\"\"", "\n", "\n", "assert", "q", ">", "0", ",", "(", "\n", "\"Warning: calling compute_score_given_q with \"", "\n", "\"observed_sum=%.2f, expectations of length=%d, penalty=%.2f, q=%.2f\"", "\n", "%", "(", "observed_sum", ",", "len", "(", "expectations", ")", ",", "penalty", ",", "q", ")", "\n", ")", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "sum", "(", ")", ",", "penalty", ",", "q", "]", ")", "\n", "ans", "=", "self", ".", "score_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'score'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "ans", "=", "observed_sum", "*", "np", ".", "log", "(", "q", ")", "+", "(", "expectations", "-", "q", "*", "expectations", ")", ".", "sum", "(", ")", "-", "penalty", "\n", "self", ".", "score_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Poisson.Poisson.qmle": [[45, 60], ["tuple", "Poisson.Poisson.qmle_cache.get", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_mle", "expectations.sum"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_mle"], ["", "def", "qmle", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ")", ":", "\n", "        ", "\"\"\"\n        Computes the q which maximizes score (q_mle).\n        \"\"\"", "\n", "direction", "=", "self", ".", "direction", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "sum", "(", ")", "]", ")", "\n", "ans", "=", "self", ".", "qmle_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'qmle'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "ans", "=", "optim", ".", "bisection_q_mle", "(", "self", ",", "observed_sum", ",", "expectations", ",", "direction", "=", "direction", ")", "\n", "self", ".", "qmle_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Poisson.Poisson.compute_qs": [[61, 97], ["Poisson.Poisson.qmle", "tuple", "Poisson.Poisson.compute_qs_cache.get", "Poisson.Poisson.score", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_min", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_max", "aif360.detectors.mdss.ScoringFunctions.optim.direction_assertions", "expectations.tostring"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.qmle", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_min", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_max", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.direction_assertions"], ["", "def", "compute_qs", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes roots (qmin and qmax) of the score function for given q\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param penalty: penalty coefficient\n        \"\"\"", "\n", "\n", "direction", "=", "self", ".", "direction", "\n", "\n", "q_mle", "=", "self", ".", "qmle", "(", "observed_sum", ",", "expectations", ")", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "tostring", "(", ")", ",", "penalty", "]", ")", "\n", "ans", "=", "self", ".", "compute_qs_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'qs'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "if", "self", ".", "score", "(", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ")", ">", "0", ":", "\n", "            ", "exist", "=", "1", "\n", "q_min", "=", "optim", ".", "bisection_q_min", "(", "self", ",", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ")", "\n", "q_max", "=", "optim", ".", "bisection_q_max", "(", "self", ",", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ")", "\n", "", "else", ":", "\n", "# there are no roots", "\n", "            ", "exist", "=", "0", "\n", "q_min", "=", "0", "\n", "q_max", "=", "0", "\n", "\n", "# only consider the desired direction, positive or negative", "\n", "", "if", "exist", ":", "\n", "            ", "exist", ",", "q_min", ",", "q_max", "=", "optim", ".", "direction_assertions", "(", "direction", ",", "q_min", ",", "q_max", ")", "\n", "\n", "", "ans", "=", "[", "exist", ",", "q_mle", ",", "q_min", ",", "q_max", "]", "\n", "self", ".", "compute_qs_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Poisson.Poisson.q_dscore": [[98, 119], ["tuple", "Poisson.Poisson.qdscore_cache.get", "expectations.sum"], "methods", ["None"], ["", "def", "q_dscore", "(", "self", ",", "observed_sum", ",", "expectations", ",", "q", ")", ":", "\n", "        ", "\"\"\"\n        This actually computes q times the slope, which has the same sign as the slope since q is positive.\n        score = Y log q + \\sum_i (p_i - qp_i)\n        dscore/dq = Y / q - \\sum_i(p_i)\n        q dscore/dq = q_dscore = Y - (q * \\sum_i(p_i))\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param q: current value of q\n        :return: q dscore/dq\n        \"\"\"", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "sum", "(", ")", ",", "q", "]", ")", "\n", "ans", "=", "self", ".", "qdscore_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "'qdscore'", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "ans", "=", "observed_sum", "-", "(", "q", "*", "expectations", ")", ".", "sum", "(", ")", "\n", "self", ".", "qdscore_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_mle": [[5, 38], ["numpy.abs", "numpy.sign", "score_function.q_dscore"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Poisson.Poisson.q_dscore"], ["def", "bisection_q_mle", "(", "score_function", ":", "ScoringFunction", ",", "observed_sum", ":", "float", ",", "probs", ":", "np", ".", "array", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Computes the q which maximizes score (q_mle).\n    Computes q for which slope dscore/dq = 0, using the fact that slope is monotonically decreasing.\n    q_mle is computed via bisection.\n    This works if the score, as a function of q, is concave.\n    So the slope is monotonically decreasing, and q_mle is the unique value for which slope = 0.\n\n    :param observed_sum: sum of observed binary outcomes for all i\n    :param probs: predicted probabilities p_i for each data element i\n    :return: q MLE\n    \"\"\"", "\n", "q_temp_min", "=", "1e-3", "\n", "q_temp_max", "=", "1e3", "\n", "\n", "while", "np", ".", "abs", "(", "q_temp_max", "-", "q_temp_min", ")", ">", "1e-3", ":", "\n", "        ", "q_temp_mid", "=", "(", "q_temp_min", "+", "q_temp_max", ")", "/", "2", "\n", "\n", "if", "np", ".", "sign", "(", "score_function", ".", "q_dscore", "(", "observed_sum", ",", "probs", ",", "q_temp_mid", ")", ")", ">", "0", ":", "\n", "            ", "q_temp_min", "=", "q_temp_min", "+", "(", "q_temp_max", "-", "q_temp_min", ")", "/", "2", "\n", "", "else", ":", "\n", "            ", "q_temp_max", "=", "q_temp_max", "-", "(", "q_temp_max", "-", "q_temp_min", ")", "/", "2", "\n", "\n", "", "", "q", "=", "(", "q_temp_min", "+", "q_temp_max", ")", "/", "2", "\n", "\n", "direction", "=", "None", "\n", "if", "'direction'", "in", "kwargs", ":", "\n", "        ", "direction", "=", "kwargs", "[", "'direction'", "]", "\n", "\n", "", "if", "(", "(", "direction", "==", "'positive'", ")", "&", "(", "q", "<", "1", ")", ")", "|", "(", "(", "direction", "==", "'negative'", ")", "&", "(", "q", ">", "1", ")", ")", ":", "\n", "        ", "return", "1", "\n", "\n", "", "return", "q", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_min": [[39, 63], ["numpy.abs", "numpy.sign", "score_function.score"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score"], ["", "def", "bisection_q_min", "(", "score_function", ":", "ScoringFunction", ",", "observed_sum", ":", "float", ",", "probs", ":", "np", ".", "array", ",", "penalty", ":", "float", ",", "q_mle", ":", "float", ",", "temp_min", "=", "1e-3", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Compute q for which score = 0, using the fact that score is monotonically increasing for q > q_mle.\n    q_max is computed via binary search.\n    This works because the score, as a function of q, is concave.\n\n    :param observed_sum: sum of observed binary outcomes for all i\n    :param probs: predicted probabilities p_i for each data element i\n    :param penalty: penalty term. should be positive\n    :param q_mle: q maximum likelihood\n    :return: the root on the LHS of qmle\n    \"\"\"", "\n", "q_temp_min", "=", "temp_min", "\n", "q_temp_max", "=", "q_mle", "\n", "\n", "while", "np", ".", "abs", "(", "q_temp_max", "-", "q_temp_min", ")", ">", "1e-3", ":", "\n", "        ", "q_temp_mid", "=", "(", "q_temp_min", "+", "q_temp_max", ")", "/", "2", "\n", "\n", "if", "np", ".", "sign", "(", "score_function", ".", "score", "(", "observed_sum", ",", "probs", ",", "penalty", ",", "q_temp_mid", ")", ")", ">", "0", ":", "\n", "            ", "q_temp_max", "=", "q_temp_max", "-", "(", "q_temp_max", "-", "q_temp_min", ")", "/", "2", "\n", "", "else", ":", "\n", "            ", "q_temp_min", "=", "q_temp_min", "+", "(", "q_temp_max", "-", "q_temp_min", ")", "/", "2", "\n", "\n", "", "", "return", "(", "q_temp_min", "+", "q_temp_max", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_max": [[64, 88], ["numpy.abs", "numpy.sign", "score_function.score"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score"], ["", "def", "bisection_q_max", "(", "score_function", ":", "ScoringFunction", ",", "observed_sum", ":", "float", ",", "probs", ":", "np", ".", "array", ",", "penalty", ":", "float", ",", "q_mle", ":", "float", ",", "temp_max", "=", "1e3", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Compute q for which score = 0, using the fact that score is monotonically decreasing for q > q_mle.\n    q_max is computed via binary search.\n    This works because the score, as a function of q, is concave.\n\n    :param observed_sum: sum of observed binary outcomes for all i\n    :param probs: predicted probabilities p_i for each data element i\n    :param penalty: penalty term. should be positive\n    :param q_mle: q maximum likelihood\n    :return: the root on the RHS of qmle\n    \"\"\"", "\n", "q_temp_min", "=", "q_mle", "\n", "q_temp_max", "=", "temp_max", "\n", "\n", "while", "np", ".", "abs", "(", "q_temp_max", "-", "q_temp_min", ")", ">", "1e-3", ":", "\n", "        ", "q_temp_mid", "=", "(", "q_temp_min", "+", "q_temp_max", ")", "/", "2", "\n", "\n", "if", "np", ".", "sign", "(", "score_function", ".", "score", "(", "observed_sum", ",", "probs", ",", "penalty", ",", "q_temp_mid", ")", ")", ">", "0", ":", "\n", "            ", "q_temp_min", "=", "q_temp_min", "+", "(", "q_temp_max", "-", "q_temp_min", ")", "/", "2", "\n", "", "else", ":", "\n", "            ", "q_temp_max", "=", "q_temp_max", "-", "(", "q_temp_max", "-", "q_temp_min", ")", "/", "2", "\n", "\n", "", "", "return", "(", "q_temp_min", "+", "q_temp_max", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.direction_assertions": [[89, 106], ["None"], "function", ["None"], ["", "def", "direction_assertions", "(", "direction", ":", "str", ",", "q_min", ":", "float", ",", "q_max", ":", "float", ")", ":", "\n", "    ", "\"\"\"\n    Does some sanity checks to see if the q_mle exists for the given direction.\n    \"\"\"", "\n", "exist", "=", "1", "\n", "if", "direction", "==", "'positive'", ":", "\n", "        ", "if", "q_max", "<", "1", ":", "\n", "            ", "exist", "=", "0", "\n", "", "elif", "q_min", "<", "1", ":", "\n", "            ", "q_min", "=", "1", "\n", "", "", "else", ":", "\n", "        ", "if", "q_min", ">", "1", ":", "\n", "            ", "exist", "=", "0", "\n", "", "elif", "q_max", ">", "1", ":", "\n", "            ", "q_max", "=", "1", "\n", "\n", "", "", "return", "exist", ",", "q_min", ",", "q_max", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.__init__": [[9, 19], ["aif360.detectors.mdss.ScoringFunctions.ScoringFunction.ScoringFunction.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Gaussian score function. May be appropriate to use when the outcome of\n        interest is assumed to be normally distributed.\n\n        kwargs must contain\n        'direction (str)' - direction of the severity; could be higher than expected outcomes ('positive') or lower than expected ('negative')\n        \"\"\"", "\n", "\n", "super", "(", "Gaussian", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score": [[20, 62], ["tuple", "Gaussian.Gaussian.score_cache.get", "expectations.sum", "expectations.sum"], "methods", ["None"], ["", "def", "score", "(", "\n", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ",", "q", ":", "float", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Computes gaussian bias score for given q\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param penalty: penalty term. Should be positive\n        :param q: current value of q\n        :return: bias score for the current value of q\n        \"\"\"", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "sum", "(", ")", ",", "penalty", ",", "q", "]", ")", "\n", "ans", "=", "self", ".", "score_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "\"score\"", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "assumed_var", "=", "self", ".", "var", "\n", "expected_sum", "=", "expectations", ".", "sum", "(", ")", "\n", "penalty", "/=", "self", ".", "var", "\n", "\n", "C", "=", "(", "\n", "observed_sum", "*", "expected_sum", "/", "assumed_var", "*", "(", "q", "-", "1", ")", "\n", ")", "\n", "\n", "B", "=", "(", "\n", "expected_sum", "**", "2", "*", "(", "1", "-", "q", "**", "2", ")", "/", "(", "2", "*", "assumed_var", ")", "\n", ")", "\n", "\n", "if", "C", ">", "B", "and", "self", ".", "direction", "==", "'positive'", ":", "\n", "            ", "ans", "=", "C", "+", "B", "\n", "", "elif", "B", ">", "C", "and", "self", ".", "direction", "==", "'negative'", ":", "\n", "            ", "ans", "=", "C", "+", "B", "\n", "", "else", ":", "\n", "            ", "ans", "=", "0", "\n", "\n", "", "ans", "-=", "penalty", "\n", "self", ".", "score_cache", "[", "key", "]", "=", "ans", "\n", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.qmle": [[63, 84], ["tuple", "Gaussian.Gaussian.qmle_cache.get", "expectations.sum", "numpy.isnan", "expectations.sum"], "methods", ["None"], ["", "def", "qmle", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ")", ":", "\n", "        ", "\"\"\"\n        Computes the q which maximizes score (q_mle).\n        \"\"\"", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "sum", "(", ")", "]", ")", "\n", "ans", "=", "self", ".", "qmle_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "\"qmle\"", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "expected_sum", "=", "expectations", ".", "sum", "(", ")", "\n", "\n", "# Deals with case where observed_sum = expected_sum = 0", "\n", "if", "observed_sum", "==", "expected_sum", ":", "\n", "            ", "ans", "=", "1", "\n", "", "else", ":", "\n", "            ", "ans", "=", "observed_sum", "/", "expected_sum", "\n", "\n", "", "assert", "np", ".", "isnan", "(", "ans", ")", "==", "False", ",", "f'{expected_sum}, {observed_sum}, {ans}'", "\n", "self", ".", "qmle_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.compute_qs": [[85, 123], ["Gaussian.Gaussian.qmle", "tuple", "Gaussian.Gaussian.compute_qs_cache.get", "Gaussian.Gaussian.score", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_min", "aif360.detectors.mdss.ScoringFunctions.optim.bisection_q_max", "aif360.detectors.mdss.ScoringFunctions.optim.direction_assertions", "expectations.sum"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.qmle", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.Gaussian.Gaussian.score", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_min", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.bisection_q_max", "home.repos.pwc.inspect_result.IBM_AIF360.ScoringFunctions.optim.direction_assertions"], ["", "def", "compute_qs", "(", "self", ",", "observed_sum", ":", "float", ",", "expectations", ":", "np", ".", "array", ",", "penalty", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Computes roots (qmin and qmax) of the score function for given q\n\n        :param observed_sum: sum of observed binary outcomes for all i\n        :param expectations: predicted outcomes for each data element i\n        :param penalty: penalty coefficient\n        \"\"\"", "\n", "\n", "direction", "=", "self", ".", "direction", "\n", "\n", "q_mle", "=", "self", ".", "qmle", "(", "observed_sum", ",", "expectations", ")", "\n", "\n", "key", "=", "tuple", "(", "[", "observed_sum", ",", "expectations", ".", "sum", "(", ")", ",", "penalty", "]", ")", "\n", "ans", "=", "self", ".", "compute_qs_cache", ".", "get", "(", "key", ")", "\n", "if", "ans", "is", "not", "None", ":", "\n", "            ", "self", ".", "cache_counter", "[", "\"qs\"", "]", "+=", "1", "\n", "return", "ans", "\n", "\n", "", "q_mle_score", "=", "self", ".", "score", "(", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ")", "\n", "\n", "if", "q_mle_score", ">", "0", ":", "\n", "            ", "exist", "=", "1", "\n", "q_min", "=", "optim", ".", "bisection_q_min", "(", "self", ",", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ",", "temp_min", "=", "-", "1e6", ")", "\n", "q_max", "=", "optim", ".", "bisection_q_max", "(", "self", ",", "observed_sum", ",", "expectations", ",", "penalty", ",", "q_mle", ",", "temp_max", "=", "1e6", ")", "\n", "", "else", ":", "\n", "# there are no roots", "\n", "            ", "exist", "=", "0", "\n", "q_min", "=", "0", "\n", "q_max", "=", "0", "\n", "\n", "# only consider the desired direction, positive or negative", "\n", "", "if", "exist", ":", "\n", "            ", "exist", ",", "q_min", ",", "q_max", "=", "optim", ".", "direction_assertions", "(", "direction", ",", "q_min", ",", "q_max", ")", "\n", "\n", "", "ans", "=", "[", "exist", ",", "q_mle", ",", "q_min", ",", "q_max", "]", "\n", "self", ".", "compute_qs_cache", "[", "key", "]", "=", "ans", "\n", "return", "ans", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.explainer.Explainer.__init__": [[7, 10], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.accuracy": [[20, 34], ["super().accuracy", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["def", "accuracy", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "accuracy", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Accuracy\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositives\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numTrueNegatives\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numPositives\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numNegatives\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as (true positive count + \"", "\n", "\"true negative count)/(positive_count + negative_count).\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.average_abs_odds_difference": [[35, 52], ["super().average_abs_odds_difference", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_abs_odds_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives"], ["", "def", "average_abs_odds_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "average_abs_odds_difference", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Average Absolute Odds Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalsePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTruePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numFalsePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numTruePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numPositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as average difference of false positive rate (false positives / actual negatives) and true positive rate (true positives / actual positives) between unprivileged and privileged groups.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0.  A value of < 0 implies higher benefit for the privileged group and a value > 0 implies higher benefit for the unprivileged group.\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.average_odds_difference": [[53, 70], ["super().average_odds_difference", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_odds_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives"], ["", "def", "average_odds_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "average_odds_difference", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Average Odds Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalsePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTruePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numFalsePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numTruePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numPositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as average difference of false positive rate (false positives / negatives) and true positive rate (true positives / positives) between unprivileged and privileged groups.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.  A value of < 0 implies higher benefit for the privileged group and a value > 0 implies higher benefit for the unprivileged group.\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.between_all_groups_coefficient_of_variation": [[71, 80], ["super().between_all_groups_coefficient_of_variation", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_coefficient_of_variation"], ["", "def", "between_all_groups_coefficient_of_variation", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "between_all_groups_coefficient_of_variation", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Between All Groups Coefficient Of Variation\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the square root of twice the pairwise entropy between every pair of privileged and underprivileged groups with alpha = 2.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.\"", ")", "#2.0\"", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.between_all_groups_generalized_entropy_index": [[81, 90], ["super().between_all_groups_generalized_entropy_index", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_generalized_entropy_index"], ["", "def", "between_all_groups_generalized_entropy_index", "(", "self", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "between_all_groups_generalized_entropy_index", "(", "alpha", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Between All Groups Generalized Entropy Index\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the pairwise entropy between every pair of privileged and underprivileged groups.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "#1.0\"", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.between_all_groups_theil_index": [[91, 100], ["super().between_all_groups_theil_index", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_theil_index"], ["", "def", "between_all_groups_theil_index", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "between_all_groups_theil_index", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Between All Groups Theil Index\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the pairwise entropy between every pair of privileged and underprivileged groups with alpha = 1.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "#1.0\"", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.between_group_coefficient_of_variation": [[101, 110], ["super().between_group_coefficient_of_variation", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_coefficient_of_variation"], ["", "def", "between_group_coefficient_of_variation", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "between_group_coefficient_of_variation", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Between Group Coefficient Of Variation\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the square root of twice the pairwise entropy between a given pair of privileged and underprivileged groups with alpha = 2.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "#2.0\"", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.between_group_generalized_entropy_index": [[111, 120], ["super().between_group_generalized_entropy_index", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_generalized_entropy_index"], ["", "def", "between_group_generalized_entropy_index", "(", "self", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "between_group_generalized_entropy_index", "(", "alpha", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Between Group Generalized Entropy Index\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the pairwise entropy between a given pair of privileged and underprivileged groups.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "#1.0\"", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.between_group_theil_index": [[121, 130], ["super().between_group_theil_index", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_theil_index"], ["", "def", "between_group_theil_index", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "between_group_theil_index", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Between Group Theil Index\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the pairwise entropy between a given pair of privileged and underprivileged groups with alpha = 1.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "#1.0\"", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.coefficient_of_variation": [[131, 140], ["super().coefficient_of_variation", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.coefficient_of_variation"], ["", "def", "coefficient_of_variation", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "coefficient_of_variation", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Coefficient Of Variation\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the square root of twice the generalized entropy index with alpha = 2.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "#2.0\"", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.consistency": [[141, 151], ["super().consistency", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.consistency"], ["", "def", "consistency", "(", "self", ",", "n_neighbors", "=", "5", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "consistency", "(", "n_neighbors", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Consistency\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"Individual fairness metric from Zemel, Rich, et al. \\\"Learning fair representations.\\\", ICML 2013. \"", ")", ",", "\n", "(", "\"Measures how similar the labels are for similar instances.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.disparate_impact": [[152, 178], ["super().disparate_impact", "isinstance", "json.dumps", "collections.OrderedDict", "collections.OrderedDict", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances", "metric_json_explainer.MetricJSONExplainer.metric.num_pred_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances", "metric_json_explainer.MetricJSONExplainer.metric.num_pred_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "disparate_impact", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "disparate_impact", "(", ")", "\n", "response", "=", "[", "]", "\n", "if", "isinstance", "(", "self", ".", "metric", ",", "BinaryLabelDatasetMetric", ")", ":", "\n", "            ", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Disparate Impact\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numPositivePredictionsUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numUnprivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivePredictionsPrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numPrivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the ratio of rate of favorable outcome for the unprivileged group to that of the privileged group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0 A value < 1 implies higher benefit for the privileged group and a value >1 implies a higher benefit for the unprivileged group.\"", ")", "\n", ")", ")", "\n", "", "else", ":", "\n", "            ", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Disparate Impact\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numPositivePredictionsUnprivileged\"", ",", "self", ".", "metric", ".", "num_pred_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numUnprivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivePredictionsPrivileged\"", ",", "self", ".", "metric", ".", "num_pred_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numPrivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the ratio of likelihood of favorable outcome for the unprivileged group to that of the privileged group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0\"", ")", "\n", ")", ")", "\n", "", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.error_rate": [[179, 192], ["super().error_rate", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "error_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "error_rate", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Error Rate\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositives\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numTrueNegatives\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numPositives\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numNegatives\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as  (1 -(true positive count + true negative count)/(positive_count + negative_count)). \"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.error_rate_difference": [[193, 211], ["super().error_rate_difference", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "error_rate_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "error_rate_difference", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Error Rate Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTrueNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTruePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numTrueNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numPositivePrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numNegativePrivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Error rate = 1 -(true positive count + true negative count)/(positive_count + negative_count). \"", "\n", "\"This metric is computed as the difference of error rates between unprivileged and privileged groups.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.error_rate_ratio": [[212, 230], ["super().error_rate_ratio", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate_ratio", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "error_rate_ratio", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "error_rate_ratio", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Error Rate Ratio\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTrueNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTruePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numTrueNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numPositivePrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numNegativePrivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Error rate = 1 -(true positive count + true negative count)/(positive_count + negative_count). \"", "\n", "\"This metric is computed as the ratio of error rates between unprivileged and privileged groups.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_discovery_rate": [[231, 242], ["super().false_discovery_rate", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives"], ["", "def", "false_discovery_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_discovery_rate", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Discovery Rate\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositives\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numFalsePositives\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as  (false positive count / (true positive count + false positive count)).\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_discovery_rate_difference": [[243, 257], ["super().false_discovery_rate_difference", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives"], ["", "def", "false_discovery_rate_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_discovery_rate_difference", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Discovery Rate Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numFalsePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTruePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numFalsePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"False discovery rate is computed as  (false positive count / (true positive count + false positive count)). \"", "\n", "\"This metric is computed as the difference of false discovery rate of unprivileged and privileged instances.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_discovery_rate_ratio": [[258, 272], ["super().false_discovery_rate_ratio", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate_ratio", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives"], ["", "def", "false_discovery_rate_ratio", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_discovery_rate_ratio", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Discovery Rate Ratio\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numFalsePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTruePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numFalsePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"False discovery rate is computed as  (false positive count / (true positive count + false positive count)). \"", "\n", "\"This metric is computed as the ratio of false discovery rate of unprivileged and privileged instances.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_negative_rate": [[273, 284], ["super().false_negative_rate", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives"], ["", "def", "false_negative_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_negative_rate", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Negative Rate\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalseNegatives\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numPositives\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as  (false negagive count / total positive count).\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_negative_rate_difference": [[285, 299], ["super().false_negative_rate_difference", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives"], ["", "def", "false_negative_rate_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_negative_rate_difference", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Negative Rate Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalseNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numFalseNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numPositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"False negative rate is computed as  (false negagive count / total positive count). \"", "\n", "\"This metric is computed as the difference of false negative rate between unprivileged and privileged instances.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_negative_rate_ratio": [[300, 314], ["super().false_negative_rate_ratio", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate_ratio", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives"], ["", "def", "false_negative_rate_ratio", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_negative_rate_ratio", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Negative Rate Ratio\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalseNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositiveaUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numFalseNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numPositiveaPrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"False negative rate is computed as  (false negagive count / total positive count). \"", "\n", "\"This metric is computed as the ratio of false negative rate between unprivileged and privileged instances.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_omission_rate": [[315, 326], ["super().false_omission_rate", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_omission_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives"], ["", "def", "false_omission_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_omission_rate", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Omission Rate\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTrueNegatives\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numFalseNegatives\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as  (false negative count / (true negative count + false negative count)).\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_omission_rate_difference": [[327, 341], ["super().falses_omission_rate_difference", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.falses_omission_rate_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives"], ["", "def", "false_omission_rate_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "falses_omission_rate_difference", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Omission Rate Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTrueNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numFalseNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTrueNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numFalseNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"False omission rate is computed as  (false negative count / (true negative count + false negative count)). \"", "\n", "\"This metric is computed as the difference of false omission rate of underprivileged and privileged groups.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_omission_rate_ratio": [[342, 356], ["super().false_omission_rate_ratio", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_omission_rate_ratio", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives"], ["", "def", "false_omission_rate_ratio", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_omission_rate_ratio", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Omission Rate Ratio\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTrueNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numFalseNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTrueNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numFalseNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"False omission rate is computed as  (false negative count / (true negative count + false negative count)). \"", "\n", "\"This metric is computed as the ratio of false omission rate of underprivileged and privileged groups.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_positive_rate": [[357, 368], ["super().false_positive_rate", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "false_positive_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_positive_rate", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Positive Rate\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalsePositives\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numNegatives\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as (false positive count / total negative count).\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_positive_rate_difference": [[369, 383], ["super().false_positive_rate_difference", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "false_positive_rate_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_positive_rate_difference", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Positive Rate Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalsePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"False positive rate is computed as (false positive count / total negative count). \"", "\n", "\"This metric is computed as the difference of false positive rates between the unprivileged and privileged groups\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.false_positive_rate_ratio": [[384, 398], ["super().false_positive_rate_ratio", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate_ratio", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "false_positive_rate_ratio", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "false_positive_rate_ratio", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"False Positive Rate Ratio\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalsePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numNegativesUnprivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numFalsePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numNegativesPrivileged\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"False positive rate is computed as (false positive count / total negative count). \"", "\n", "\"This metric is computed as the ratio of false positive rates between the unprivileged and privileged groups\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.generalized_entropy_index": [[399, 408], ["super().generalized_entropy_index", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["", "def", "generalized_entropy_index", "(", "self", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "generalized_entropy_index", "(", "alpha", "=", "alpha", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Generalized Entropy Index\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"This metric represents the generalized entropy index measured between the predicted and actual favorable outcomes.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.mean_difference": [[409, 422], ["super().mean_difference", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.mean_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "mean_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "mean_difference", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Mean Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numPositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numInstancesUnprivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numInstancesPrivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the difference of the rate of favorable outcomes received by the unprivileged group to the privileged group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.negative_predictive_value": [[423, 434], ["super().negative_predictive_value", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.negative_predictive_value", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives"], ["", "def", "negative_predictive_value", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "negative_predictive_value", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Negative Predictive Value\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTrueNegatives\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numFalseNegatives\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as (number of true negatives / (number of true negatives + number of false negatives)).\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.num_false_negatives": [[435, 445], ["super().num_false_negatives", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives"], ["", "def", "num_false_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "num_false_negatives", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Number Of False Negatives\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalseNegatives\"", ",", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the number of false negative instances for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.num_false_positives": [[446, 456], ["super().num_false_positives", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives"], ["", "def", "num_false_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "num_false_positives", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Number Of False Positives\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numFalsePositives\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the number of false positive instances for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric is 0.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.num_instances": [[457, 467], ["super().num_instances", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_instances"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "num_instances", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "num_instances", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Number Of Instances\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numInstances\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the number of instances for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value is the total number of instances made available\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.num_negatives": [[468, 478], ["super().num_negatives", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "num_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "num_negatives", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Number Of Negatives\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numNegatives\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the number of negative instances for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric lies in the total number of negative instances made available\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.num_positives": [[479, 489], ["super().num_positives", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives"], ["", "def", "num_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "num_positives", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Number Of Positives\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numPositives\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the number of positive instances for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value of this metric lies in the total number of positive instances made available\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.num_pred_negatives": [[490, 500], ["super().num_pred_negatives", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_pred_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_negatives"], ["", "def", "num_pred_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "num_pred_negatives", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Number Of Predicted Negatives\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numPredNegatives\"", ",", "self", ".", "metric", ".", "num_pred_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the number of predicted negative instances for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value is the total number of negative instances made available\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.num_pred_positives": [[501, 511], ["super().num_pred_positives", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_pred_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives"], ["", "def", "num_pred_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "num_pred_positives", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Number Of Predicted Positives\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numPredPositives\"", ",", "self", ".", "metric", ".", "num_pred_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the number of predicted positive instances for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value is the total number of positive instances made available\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.num_true_negatives": [[512, 522], ["super().num_true_negatives", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives"], ["", "def", "num_true_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Number Of True Negatives\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTrueNegatives\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the number of true negative instances for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value is the total number of negative instances made available\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.num_true_positives": [[523, 533], ["super().num_true_positives", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives"], ["", "def", "num_true_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Number Of True Positives\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositives\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the number of true positive instances for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value is the total number of positive instances made available\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.positive_predictive_value": [[534, 545], ["super().positive_predictive_value", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_false_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.positive_predictive_value", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives"], ["", "def", "positive_predictive_value", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "positive_predictive_value", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Positive Predictive Value\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositives\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numFalsePositives\"", ",", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as (true positives / (true positives + false positives)) for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.statistical_parity_difference": [[546, 572], ["super().statistical_parity_difference", "isinstance", "json.dumps", "collections.OrderedDict", "collections.OrderedDict", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances", "metric_json_explainer.MetricJSONExplainer.metric.num_pred_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances", "metric_json_explainer.MetricJSONExplainer.metric.num_pred_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_instances"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "statistical_parity_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "statistical_parity_difference", "(", ")", "\n", "response", "=", "[", "]", "\n", "if", "isinstance", "(", "self", ".", "metric", ",", "BinaryLabelDatasetMetric", ")", ":", "\n", "            ", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Statistical Parity Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numPositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numInstancesUnprivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numInstancesPrivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the difference of the rate of favorable outcomes received by the unprivileged group to the privileged group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\" The ideal value of this metric is 0\"", ")", "\n", ")", ")", "\n", "", "else", ":", "\n", "            ", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Statistical Parity Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numPositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_pred_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numInstancesUnprivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_pred_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numInstancesPrivileged\"", ",", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the difference of the rate of favorable outcomes received by the unprivileged group to the privileged group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\" The ideal value of this metric is 0\"", ")", "\n", ")", ")", "\n", "", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.theil_index": [[573, 582], ["super().theil_index", "collections.OrderedDict", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.theil_index"], ["", "def", "theil_index", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "theil_index", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"Theil Index\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the generalized entropy of benefit for all individuals in the dataset, with alpha = 1. It measures the inequality in benefit allocation for individuals.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"A value of 0 implies perfect fairness.\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.true_negative_rate": [[583, 594], ["super().true_negative_rate", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_negatives", "metric_json_explainer.MetricJSONExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "true_negative_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "true_negative_rate", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"True Negative Rate\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTrueNegatives\"", ",", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numNegatives\"", ",", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the ratio of true negatives to the total number of negatives for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.true_positive_rate": [[595, 606], ["super().true_positive_rate", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives"], ["", "def", "true_positive_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "true_positive_rate", "(", "privileged", "=", "privileged", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"True Positive Rate\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositives\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"numPositives\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "privileged", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"Computed as the ratio of true positives to the total number of positives for the given (privileged or unprivileged) group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value is 1.0\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.true_positive_rate_difference": [[607, 621], ["super().true_positive_rate_difference", "collections.OrderedDict", "json.dumps", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_true_positives", "metric_json_explainer.MetricJSONExplainer.metric.num_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives"], ["", "def", "true_positive_rate_difference", "(", "self", ")", ":", "\n", "        ", "outcome", "=", "super", "(", "MetricJSONExplainer", ",", "self", ")", ".", "true_positive_rate_difference", "(", ")", "\n", "response", "=", "OrderedDict", "(", "(", "\n", "(", "\"metric\"", ",", "\"True Positive Rate Difference\"", ")", ",", "\n", "(", "\"message\"", ",", "outcome", ")", ",", "\n", "(", "\"numTruePositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numPositivesUnprivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "False", ")", ")", ",", "\n", "(", "\"numTruePositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"numPositivesPrivileged\"", ",", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "True", ")", ")", ",", "\n", "(", "\"description\"", ",", "\"This metric is computed as the difference of true positive rates between the unprivileged and the privileged groups. \"", "\n", "\" The true positive rate is the ratio of true positives to the total number of actual positives for a given group.\"", ")", ",", "\n", "(", "\"ideal\"", ",", "\"The ideal value is 0. A value of < 0 implies higher benefit for the privileged group and a value > 0 implies higher benefit for the unprivileged group.\"", ")", "\n", ")", ")", "\n", "return", "json", ".", "dumps", "(", "response", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.equal_opportunity_difference": [[623, 625], ["metric_json_explainer.MetricJSONExplainer.true_positive_rate_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate_difference"], ["", "def", "equal_opportunity_difference", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "true_positive_rate_difference", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.power": [[626, 628], ["metric_json_explainer.MetricJSONExplainer.num_true_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives"], ["", "def", "power", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.precision": [[629, 631], ["metric_json_explainer.MetricJSONExplainer.positive_predictive_value"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.positive_predictive_value"], ["", "def", "precision", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "positive_predictive_value", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.recall": [[632, 634], ["metric_json_explainer.MetricJSONExplainer.true_positive_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate"], ["", "def", "recall", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "true_positive_rate", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.sensitivity": [[635, 637], ["metric_json_explainer.MetricJSONExplainer.true_positive_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate"], ["", "def", "sensitivity", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "true_positive_rate", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_json_explainer.MetricJSONExplainer.specificity": [[638, 640], ["metric_json_explainer.MetricJSONExplainer.true_negative_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate"], ["", "def", "specificity", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "true_negative_rate", "(", "privileged", "=", "privileged", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.__init__": [[17, 27], ["isinstance", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "metric", ")", ":", "\n", "        ", "\"\"\"Initialize a `MetricExplainer` object.\n\n        Args:\n            metric (Metric): The metric to be explained.\n        \"\"\"", "\n", "if", "isinstance", "(", "metric", ",", "Metric", ")", ":", "\n", "            ", "self", ".", "metric", "=", "metric", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\"metric must be a Metric.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy": [[28, 35], ["metric_text_explainer.MetricTextExplainer.metric.accuracy", "metric_text_explainer.MetricTextExplainer.metric.accuracy"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy"], ["", "", "def", "accuracy", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Classification accuracy (ACC): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "accuracy", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Classification accuracy on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "accuracy", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_abs_odds_difference": [[36, 40], ["metric_text_explainer.MetricTextExplainer.metric.average_abs_odds_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_abs_odds_difference"], ["", "def", "average_abs_odds_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"Average absolute odds difference (average of abs(TPR \"", "\n", "\"difference) and abs(FPR difference)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "average_abs_odds_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_odds_difference": [[41, 45], ["metric_text_explainer.MetricTextExplainer.metric.average_odds_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_odds_difference"], ["", "def", "average_odds_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"Average odds difference (average of TPR difference and FPR \"", "\n", "\"difference, 0 = equality of odds): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "average_odds_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_coefficient_of_variation": [[46, 49], ["metric_text_explainer.MetricTextExplainer.metric.between_all_groups_coefficient_of_variation"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_coefficient_of_variation"], ["", "def", "between_all_groups_coefficient_of_variation", "(", "self", ")", ":", "\n", "        ", "return", "\"Between-group coefficient of variation: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "between_all_groups_coefficient_of_variation", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_generalized_entropy_index": [[50, 53], ["metric_text_explainer.MetricTextExplainer.metric.between_all_groups_generalized_entropy_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_generalized_entropy_index"], ["", "def", "between_all_groups_generalized_entropy_index", "(", "self", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "return", "\"Between-group generalized entropy index: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "between_all_groups_generalized_entropy_index", "(", "alpha", "=", "alpha", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_theil_index": [[54, 57], ["metric_text_explainer.MetricTextExplainer.metric.between_all_groups_theil_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_theil_index"], ["", "def", "between_all_groups_theil_index", "(", "self", ")", ":", "\n", "        ", "return", "\"Between-group Theil index: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "between_all_groups_theil_index", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_coefficient_of_variation": [[58, 61], ["metric_text_explainer.MetricTextExplainer.metric.between_group_coefficient_of_variation"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_coefficient_of_variation"], ["", "def", "between_group_coefficient_of_variation", "(", "self", ")", ":", "\n", "        ", "return", "\"Between-group coefficient of variation: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "between_group_coefficient_of_variation", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_generalized_entropy_index": [[62, 65], ["metric_text_explainer.MetricTextExplainer.metric.between_group_generalized_entropy_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_generalized_entropy_index"], ["", "def", "between_group_generalized_entropy_index", "(", "self", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "return", "\"Between-group generalized entropy index: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "between_group_generalized_entropy_index", "(", "alpha", "=", "alpha", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_theil_index": [[66, 69], ["metric_text_explainer.MetricTextExplainer.metric.between_group_theil_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_theil_index"], ["", "def", "between_group_theil_index", "(", "self", ")", ":", "\n", "        ", "return", "\"Between-group Theil index: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "between_group_theil_index", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.coefficient_of_variation": [[70, 73], ["metric_text_explainer.MetricTextExplainer.metric.coefficient_of_variation"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.coefficient_of_variation"], ["", "def", "coefficient_of_variation", "(", "self", ")", ":", "\n", "        ", "return", "\"Coefficient of variation: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "coefficient_of_variation", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.consistency": [[74, 77], ["metric_text_explainer.MetricTextExplainer.metric.consistency"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.consistency"], ["", "def", "consistency", "(", "self", ",", "n_neighbors", "=", "5", ")", ":", "\n", "        ", "return", "\"Consistency (Zemel, et al. 2013): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "consistency", "(", "n_neighbors", "=", "n_neighbors", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact": [[78, 83], ["metric_text_explainer.MetricTextExplainer.metric.disparate_impact"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact"], ["", "def", "disparate_impact", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"Disparate impact (probability of favorable outcome for \"", "\n", "\"unprivileged instances / probability of favorable outcome for \"", "\n", "\"privileged instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "disparate_impact", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate": [[84, 91], ["metric_text_explainer.MetricTextExplainer.metric.error_rate", "metric_text_explainer.MetricTextExplainer.metric.error_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate"], ["", "def", "error_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Error rate (ERR = 1 - ACC): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "error_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Error rate on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "error_rate", "(", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate_difference": [[92, 96], ["metric_text_explainer.MetricTextExplainer.metric.error_rate_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate_difference"], ["", "def", "error_rate_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"Error rate difference (error rate on unprivileged instances - \"", "\n", "\"error rate on privileged instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "error_rate_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate_ratio": [[97, 101], ["metric_text_explainer.MetricTextExplainer.metric.error_rate_ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.error_rate_ratio"], ["", "def", "error_rate_ratio", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"Error rate ratio (error rate on unprivileged instances / \"", "\n", "\"error rate on privileged instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "error_rate_ratio", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate": [[102, 109], ["metric_text_explainer.MetricTextExplainer.metric.false_discovery_rate", "metric_text_explainer.MetricTextExplainer.metric.false_discovery_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate"], ["", "def", "false_discovery_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"False discovery rate (FDR = FP / (FP + TP)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_discovery_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"False discovery rate on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "false_discovery_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate_difference": [[110, 115], ["metric_text_explainer.MetricTextExplainer.metric.false_discovery_rate_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate_difference"], ["", "def", "false_discovery_rate_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"False discovery rate difference (false discovery rate on \"", "\n", "\"unprivileged instances - false discovery rate on privileged \"", "\n", "\"instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_discovery_rate_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate_ratio": [[116, 121], ["metric_text_explainer.MetricTextExplainer.metric.false_discovery_rate_ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate_ratio"], ["", "def", "false_discovery_rate_ratio", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"False discovery rate ratio (false discovery rate on \"", "\n", "\"unprivileged instances - false discovery rate on privileged \"", "\n", "\"instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_discovery_rate_ratio", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate": [[122, 129], ["metric_text_explainer.MetricTextExplainer.metric.false_negative_rate", "metric_text_explainer.MetricTextExplainer.metric.false_negative_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate"], ["", "def", "false_negative_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"False negative rate (FNR = FN / (TP + FN)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_negative_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"False negative rate on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "false_negative_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate_difference": [[130, 135], ["metric_text_explainer.MetricTextExplainer.metric.false_negative_rate_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate_difference"], ["", "def", "false_negative_rate_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"False negative rate difference (false negative rate on \"", "\n", "\"unprivileged instances - false negative rate on privileged \"", "\n", "\"instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_negative_rate_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate_ratio": [[136, 141], ["metric_text_explainer.MetricTextExplainer.metric.false_negative_rate_ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate_ratio"], ["", "def", "false_negative_rate_ratio", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"False negative rate ratio (false negative rate on \"", "\n", "\"unprivileged instances / false negative rate on privileged \"", "\n", "\"instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_negative_rate_ratio", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_omission_rate": [[142, 149], ["metric_text_explainer.MetricTextExplainer.metric.false_omission_rate", "metric_text_explainer.MetricTextExplainer.metric.false_omission_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_omission_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_omission_rate"], ["", "def", "false_omission_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"False omission rate (FOR = FN / (FN + TN)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_omission_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"False omission rate on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "false_omission_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.falses_omission_rate_difference": [[150, 155], ["metric_text_explainer.MetricTextExplainer.metric.falses_omission_rate_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.falses_omission_rate_difference"], ["", "def", "falses_omission_rate_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"False omission rate difference (falses omission rate on \"", "\n", "\"unprivileged instances - falses omission rate on privileged \"", "\n", "\"instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "falses_omission_rate_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_omission_rate_ratio": [[156, 161], ["metric_text_explainer.MetricTextExplainer.metric.false_omission_rate_ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_omission_rate_ratio"], ["", "def", "false_omission_rate_ratio", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"False omission rate ratio (false omission rate on \"", "\n", "\"unprivileged instances - false omission rate on privileged \"", "\n", "\"instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_omission_rate_ratio", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate": [[162, 169], ["metric_text_explainer.MetricTextExplainer.metric.false_positive_rate", "metric_text_explainer.MetricTextExplainer.metric.false_positive_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate"], ["", "def", "false_positive_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"False positive rate (FPR = FP / (FP + TN)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_positive_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"False positive rate on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "false_positive_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate_difference": [[170, 175], ["metric_text_explainer.MetricTextExplainer.metric.false_positive_rate_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate_difference"], ["", "def", "false_positive_rate_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"False positive rate difference (false positive rate on \"", "\n", "\"unprivileged instances - false positive rate on privileged \"", "\n", "\"instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_positive_rate_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate_ratio": [[176, 181], ["metric_text_explainer.MetricTextExplainer.metric.false_positive_rate_ratio"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_positive_rate_ratio"], ["", "def", "false_positive_rate_ratio", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"False positive rate ratio (false positive rate on \"", "\n", "\"unprivileged instances / false positive rate on privileged \"", "\n", "\"instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "false_positive_rate_ratio", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index": [[182, 185], ["metric_text_explainer.MetricTextExplainer.metric.generalized_entropy_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["", "def", "generalized_entropy_index", "(", "self", ",", "alpha", "=", "2", ")", ":", "\n", "        ", "return", "\"Generalized entropy index (GE(alpha)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "generalized_entropy_index", "(", "alpha", "=", "alpha", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.mean_difference": [[186, 190], ["metric_text_explainer.MetricTextExplainer.metric.mean_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.mean_difference"], ["", "def", "mean_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"Mean difference (mean label value on unprivileged instances - \"", "\n", "\"mean label value on privileged instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "mean_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.negative_predictive_value": [[191, 198], ["metric_text_explainer.MetricTextExplainer.metric.negative_predictive_value", "metric_text_explainer.MetricTextExplainer.metric.negative_predictive_value"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.negative_predictive_value", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.negative_predictive_value"], ["", "def", "negative_predictive_value", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Negative predictive value (NPV = TN / (TN + FN)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "negative_predictive_value", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Negative predictive value on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "negative_predictive_value", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives": [[199, 206], ["metric_text_explainer.MetricTextExplainer.metric.num_false_negatives", "metric_text_explainer.MetricTextExplainer.metric.num_false_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_negatives"], ["", "def", "num_false_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Number of false negative instances (FN): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Number of {} false negative instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "num_false_negatives", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives": [[207, 214], ["metric_text_explainer.MetricTextExplainer.metric.num_false_positives", "metric_text_explainer.MetricTextExplainer.metric.num_false_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_false_positives"], ["", "def", "num_false_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Number of false positive instances (FP): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Number of {} false positive instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "num_false_positives", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances": [[215, 222], ["metric_text_explainer.MetricTextExplainer.metric.num_instances", "metric_text_explainer.MetricTextExplainer.metric.num_instances"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "num_instances", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Number of instances: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Number of {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "num_instances", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives": [[223, 230], ["metric_text_explainer.MetricTextExplainer.metric.num_negatives", "metric_text_explainer.MetricTextExplainer.metric.num_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_negatives"], ["", "def", "num_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Number of negative-outcome instances: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Number of {} negative-outcome instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "num_negatives", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives": [[231, 238], ["metric_text_explainer.MetricTextExplainer.metric.num_positives", "metric_text_explainer.MetricTextExplainer.metric.num_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_positives"], ["", "def", "num_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Number of positive-outcome instances: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Number of {} positive-outcome instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "num_positives", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_negatives": [[239, 246], ["metric_text_explainer.MetricTextExplainer.metric.num_pred_negatives", "metric_text_explainer.MetricTextExplainer.metric.num_pred_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_negatives"], ["", "def", "num_pred_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Number of negative-outcome instances predicted: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "num_pred_negatives", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Number of {} negative-outcome instances predicted: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "num_pred_negatives", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives": [[247, 254], ["metric_text_explainer.MetricTextExplainer.metric.num_pred_positives", "metric_text_explainer.MetricTextExplainer.metric.num_pred_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_pred_positives"], ["", "def", "num_pred_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Number of positive-outcome instances predicted: {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "num_pred_positives", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Number of {} positive-outcome instances predicted: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "num_pred_positives", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives": [[255, 262], ["metric_text_explainer.MetricTextExplainer.metric.num_true_negatives", "metric_text_explainer.MetricTextExplainer.metric.num_true_negatives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_negatives"], ["", "def", "num_true_negatives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Number of true negative instances (TN): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Number of {} true negative instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "num_true_negatives", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives": [[263, 270], ["metric_text_explainer.MetricTextExplainer.metric.num_true_positives", "metric_text_explainer.MetricTextExplainer.metric.num_true_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives"], ["", "def", "num_true_positives", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Number of true positive instances (TP): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Number of {} true positive instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.positive_predictive_value": [[271, 278], ["metric_text_explainer.MetricTextExplainer.metric.positive_predictive_value", "metric_text_explainer.MetricTextExplainer.metric.positive_predictive_value"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.positive_predictive_value", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.positive_predictive_value"], ["", "def", "positive_predictive_value", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"Positive predictive value (PPV, precision = TP / (TP + FP)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "positive_predictive_value", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"Positive predictive value on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "positive_predictive_value", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference": [[279, 284], ["metric_text_explainer.MetricTextExplainer.metric.statistical_parity_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference"], ["", "def", "statistical_parity_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"Statistical parity difference (probability of favorable \"", "\n", "\"outcome for unprivileged instances - probability of favorable \"", "\n", "\"outcome for privileged instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "statistical_parity_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.theil_index": [[285, 288], ["metric_text_explainer.MetricTextExplainer.metric.theil_index"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.theil_index"], ["", "def", "theil_index", "(", "self", ")", ":", "\n", "        ", "return", "\"Theil index (generalized entropy index with alpha = 1): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "theil_index", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate": [[289, 296], ["metric_text_explainer.MetricTextExplainer.metric.true_negative_rate", "metric_text_explainer.MetricTextExplainer.metric.true_negative_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate"], ["", "def", "true_negative_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"True negative rate (TNR, specificity = TN / (FP + TN)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "true_negative_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"True negative rate on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "true_negative_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate": [[297, 304], ["metric_text_explainer.MetricTextExplainer.metric.true_positive_rate", "metric_text_explainer.MetricTextExplainer.metric.true_positive_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate"], ["", "def", "true_positive_rate", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "if", "privileged", "is", "None", ":", "\n", "            ", "return", "\"True positive rate (TPR, recall, sensitivity = TP / (TP + FN)): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "true_positive_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "", "return", "\"True positive rate on {} instances: {}\"", ".", "format", "(", "\n", "'privileged'", "if", "privileged", "else", "'unprivileged'", ",", "\n", "self", ".", "metric", ".", "true_positive_rate", "(", "privileged", "=", "privileged", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate_difference": [[305, 310], ["metric_text_explainer.MetricTextExplainer.metric.true_positive_rate_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate_difference"], ["", "def", "true_positive_rate_difference", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"True positive rate difference (true positive rate on \"", "\n", "\"unprivileged instances - true positive rate on privileged \"", "\n", "\"instances): {}\"", ".", "format", "(", "\n", "self", ".", "metric", ".", "true_positive_rate_difference", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.equal_opportunity_difference": [[312, 314], ["metric_text_explainer.MetricTextExplainer.true_positive_rate_difference"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate_difference"], ["", "def", "equal_opportunity_difference", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "true_positive_rate_difference", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.power": [[315, 317], ["metric_text_explainer.MetricTextExplainer.num_true_positives"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_true_positives"], ["", "def", "power", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "num_true_positives", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.precision": [[318, 320], ["metric_text_explainer.MetricTextExplainer.positive_predictive_value"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.positive_predictive_value"], ["", "def", "precision", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "positive_predictive_value", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.recall": [[321, 323], ["metric_text_explainer.MetricTextExplainer.true_positive_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate"], ["", "def", "recall", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "true_positive_rate", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.sensitivity": [[324, 326], ["metric_text_explainer.MetricTextExplainer.true_positive_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate"], ["", "def", "sensitivity", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "true_positive_rate", "(", "privileged", "=", "privileged", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.specificity": [[327, 329], ["metric_text_explainer.MetricTextExplainer.true_negative_rate"], "methods", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate"], ["", "def", "specificity", "(", "self", ",", "privileged", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "true_negative_rate", "(", "privileged", "=", "privileged", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.source.conf.setup": [[142, 144], ["app.add_css_file"], "function", ["None"], ["def", "setup", "(", "app", ")", ":", "\n", "    ", "app", ".", "add_css_file", "(", "'style.css'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.source.conf.linkcode_resolve": [[222, 273], ["sys.modules.get", "fullname.split", "os.path.relpath", "unwrap", "inspect.getsourcefile", "inspect.getsourcelines", "getattr", "os.path.dirname", "len"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split"], ["def", "linkcode_resolve", "(", "domain", ",", "info", ")", ":", "\n", "    ", "\"\"\"\n    Determine the URL corresponding to Python object\n    \"\"\"", "\n", "if", "domain", "!=", "'py'", ":", "\n", "        ", "return", "None", "\n", "\n", "", "modname", "=", "info", "[", "'module'", "]", "\n", "fullname", "=", "info", "[", "'fullname'", "]", "\n", "\n", "submod", "=", "sys", ".", "modules", ".", "get", "(", "modname", ")", "\n", "if", "submod", "is", "None", ":", "\n", "        ", "return", "None", "\n", "\n", "", "obj", "=", "submod", "\n", "for", "part", "in", "fullname", ".", "split", "(", "'.'", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "obj", "=", "getattr", "(", "obj", ",", "part", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "return", "None", "\n", "\n", "# strip decorators, which would resolve to the source of the decorator", "\n", "# possibly an upstream bug in getsourcefile, bpo-1764286", "\n", "", "", "try", ":", "\n", "        ", "unwrap", "=", "inspect", ".", "unwrap", "\n", "", "except", "AttributeError", ":", "\n", "        ", "pass", "\n", "", "else", ":", "\n", "        ", "obj", "=", "unwrap", "(", "obj", ")", "\n", "\n", "", "try", ":", "\n", "        ", "fn", "=", "inspect", ".", "getsourcefile", "(", "obj", ")", "\n", "", "except", "Exception", ":", "\n", "        ", "fn", "=", "None", "\n", "", "if", "not", "fn", ":", "\n", "        ", "return", "None", "\n", "\n", "", "try", ":", "\n", "        ", "source", ",", "lineno", "=", "inspect", ".", "getsourcelines", "(", "obj", ")", "\n", "", "except", "Exception", ":", "\n", "        ", "lineno", "=", "None", "\n", "\n", "", "if", "lineno", ":", "\n", "        ", "linespec", "=", "\"#L%d-L%d\"", "%", "(", "lineno", ",", "lineno", "+", "len", "(", "source", ")", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "linespec", "=", "\"\"", "\n", "\n", "", "fn", "=", "relpath", "(", "fn", ",", "start", "=", "dirname", "(", "aif360", ".", "__file__", ")", ")", "\n", "\n", "return", "\"https://github.com/Trusted-AI/AIF360/blob/master/aif360/%s%s\"", "%", "(", "\n", "fn", ",", "linespec", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.src.fairness.dataset_wrapper": [[29, 43], ["pandas.DataFrame", "aif360.datasets.BinaryLabelDataset"], "function", ["None"], ["def", "dataset_wrapper", "(", "outcome", ",", "protected", ",", "unprivileged_groups", ",", "privileged_groups", ",", "favorable_label", ",", "unfavorable_label", ")", ":", "\n", "    ", "\"\"\" A wrapper function to create aif360 dataset from outcome and protected in numpy array format.\n    \"\"\"", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", "=", "outcome", ",", "\n", "columns", "=", "[", "'outcome'", "]", ")", "\n", "df", "[", "'race'", "]", "=", "protected", "\n", "\n", "dataset", "=", "BinaryLabelDataset", "(", "favorable_label", "=", "favorable_label", ",", "\n", "unfavorable_label", "=", "unfavorable_label", ",", "\n", "df", "=", "df", ",", "\n", "label_names", "=", "[", "'outcome'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'race'", "]", ",", "\n", "unprivileged_protected_attributes", "=", "unprivileged_groups", ")", "\n", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.src.fairness.evaluate": [[45, 65], ["torch.device", "torch.device", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "model.eval", "numpy.array", "torch.autograd.Variable", "torch.autograd.Variable", "torch.no_grad", "torch.no_grad", "torch.cuda.is_available", "torch.cuda.is_available", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "images.to.to", "labels.to.to", "model", "torch.max", "torch.max", "torch.softmax().detach().numpy", "torch.softmax().detach().numpy", "predicted.eq().sum().item", "predicted.tolist", "len", "X_test.astype", "y_test.astype", "torch.softmax().detach", "torch.softmax().detach", "predicted.eq().sum", "torch.softmax", "torch.softmax", "predicted.eq", "labels.to.data.view_as"], "function", ["None"], ["", "def", "evaluate", "(", "model", ",", "X_test", ",", "y_test", ")", ":", "\n", "    ", "device", "=", "torch", ".", "device", "(", "'cuda:0'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "test", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "Variable", "(", "torch", ".", "FloatTensor", "(", "X_test", ".", "astype", "(", "'float32'", ")", ")", ")", ",", "Variable", "(", "torch", ".", "LongTensor", "(", "y_test", ".", "astype", "(", "'float32'", ")", ")", ")", ")", "\n", "test_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "test", ",", "batch_size", "=", "64", ",", "shuffle", "=", "False", ")", "\n", "model", ".", "eval", "(", ")", "\n", "correct", "=", "0", "\n", "accuracy", "=", "0", "\n", "y_pred", "=", "[", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "images", ",", "labels", "in", "test_loader", ":", "\n", "            ", "images", "=", "images", ".", "to", "(", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "device", ")", "\n", "outputs", "=", "model", "(", "images", ")", "\n", "_", ",", "predicted", "=", "torch", ".", "max", "(", "outputs", ".", "data", ",", "1", ")", "\n", "predictions", "=", "torch", ".", "softmax", "(", "outputs", ".", "data", ",", "dim", "=", "1", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "correct", "+=", "predicted", ".", "eq", "(", "labels", ".", "data", ".", "view_as", "(", "predicted", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "y_pred", "+=", "predicted", ".", "tolist", "(", ")", "\n", "", "accuracy", "=", "1.", "*", "correct", "/", "len", "(", "test_loader", ".", "dataset", ")", "\n", "", "y_pred", "=", "np", ".", "array", "(", "y_pred", ")", "\n", "return", "accuracy", ",", "y_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.src.fairness.fairness_check": [[67, 158], ["re.compile", "minio.Minio", "minio.Minio.fget_object", "minio.Minio.fget_object", "minio.Minio.fget_object", "minio.Minio.fget_object", "minio.Minio.fget_object", "zipfile.ZipFile", "zipfile.ZipFile.extractall", "zipfile.ZipFile.close", "getattr", "torch.device", "torch.device", "getattr.to", "model_class().to.load_state_dict", "numpy.load", "numpy.load", "numpy.load", "fairness.evaluate", "fairness.dataset_wrapper", "fairness.dataset_wrapper", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.true_positive_rate", "aif360.metrics.ClassificationMetric.true_negative_rate", "print", "print", "re.compile.sub", "[].replace", "importlib.import_module", "torch.load", "torch.load", "aif360.metrics.ClassificationMetric.accuracy", "aif360.metrics.ClassificationMetric.statistical_parity_difference", "aif360.metrics.ClassificationMetric.disparate_impact", "aif360.metrics.ClassificationMetric.equal_opportunity_difference", "aif360.metrics.ClassificationMetric.average_odds_difference", "aif360.metrics.ClassificationMetric.theil_index", "aif360.metrics.ClassificationMetric.false_negative_rate_difference", "torch.cuda.is_available", "torch.cuda.is_available", "getattr.", "model_class_file.split"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.src.fairness.evaluate", "home.repos.pwc.inspect_result.IBM_AIF360.src.fairness.dataset_wrapper", "home.repos.pwc.inspect_result.IBM_AIF360.src.fairness.dataset_wrapper", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_positive_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.true_negative_rate", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.statistical_parity_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.equal_opportunity_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_odds_difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.theil_index", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate_difference", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split"], ["", "def", "fairness_check", "(", "object_storage_url", ",", "object_storage_username", ",", "object_storage_password", ",", "\n", "data_bucket_name", ",", "result_bucket_name", ",", "model_id", ",", "\n", "feature_testset_path", "=", "'processed_data/X_test.npy'", ",", "\n", "label_testset_path", "=", "'processed_data/y_test.npy'", ",", "\n", "protected_label_testset_path", "=", "'processed_data/p_test.npy'", ",", "\n", "model_class_file", "=", "'model.py'", ",", "\n", "model_class_name", "=", "'model'", ",", "\n", "favorable_label", "=", "0.0", ",", "\n", "unfavorable_label", "=", "1.0", ",", "\n", "privileged_groups", "=", "[", "{", "'race'", ":", "0.0", "}", "]", ",", "\n", "unprivileged_groups", "=", "[", "{", "'race'", ":", "4.0", "}", "]", ")", ":", "\n", "\n", "    ", "url", "=", "re", ".", "compile", "(", "r\"https?://\"", ")", "\n", "cos", "=", "Minio", "(", "url", ".", "sub", "(", "''", ",", "object_storage_url", ")", ",", "\n", "access_key", "=", "object_storage_username", ",", "\n", "secret_key", "=", "object_storage_password", ",", "\n", "secure", "=", "False", ")", "# Local Minio server won't have HTTPS", "\n", "\n", "dataset_filenamex", "=", "\"X_test.npy\"", "\n", "dataset_filenamey", "=", "\"y_test.npy\"", "\n", "dataset_filenamep", "=", "\"p_test.npy\"", "\n", "weights_filename", "=", "\"model.pt\"", "\n", "model_files", "=", "model_id", "+", "'/_submitted_code/model.zip'", "\n", "\n", "cos", ".", "fget_object", "(", "data_bucket_name", ",", "feature_testset_path", ",", "dataset_filenamex", ")", "\n", "cos", ".", "fget_object", "(", "data_bucket_name", ",", "label_testset_path", ",", "dataset_filenamey", ")", "\n", "cos", ".", "fget_object", "(", "data_bucket_name", ",", "protected_label_testset_path", ",", "dataset_filenamep", ")", "\n", "cos", ".", "fget_object", "(", "result_bucket_name", ",", "model_id", "+", "'/'", "+", "weights_filename", ",", "weights_filename", ")", "\n", "cos", ".", "fget_object", "(", "result_bucket_name", ",", "model_files", ",", "'model.zip'", ")", "\n", "\n", "# Load PyTorch model definition from the source code.", "\n", "zip_ref", "=", "zipfile", ".", "ZipFile", "(", "'model.zip'", ",", "'r'", ")", "\n", "zip_ref", ".", "extractall", "(", "'model_files'", ")", "\n", "zip_ref", ".", "close", "(", ")", "\n", "\n", "modulename", "=", "'model_files.'", "+", "model_class_file", ".", "split", "(", "'.'", ")", "[", "0", "]", ".", "replace", "(", "'-'", ",", "'_'", ")", "\n", "\n", "'''\n    We required users to define where the model class is located or follow\n    some naming convention we have provided.\n    '''", "\n", "model_class", "=", "getattr", "(", "importlib", ".", "import_module", "(", "modulename", ")", ",", "model_class_name", ")", "\n", "\n", "# load & compile model", "\n", "device", "=", "torch", ".", "device", "(", "'cuda:0'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "model", "=", "model_class", "(", ")", ".", "to", "(", "device", ")", "\n", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "weights_filename", ",", "map_location", "=", "device", ")", ")", "\n", "\n", "\"\"\"Load the necessary labels and protected features for fairness check\"\"\"", "\n", "\n", "x_test", "=", "np", ".", "load", "(", "dataset_filenamex", ")", "\n", "y_test", "=", "np", ".", "load", "(", "dataset_filenamey", ")", "\n", "p_test", "=", "np", ".", "load", "(", "dataset_filenamep", ")", "\n", "\n", "_", ",", "y_pred", "=", "evaluate", "(", "model", ",", "x_test", ",", "y_test", ")", "\n", "\n", "\"\"\"Calculate the fairness metrics\"\"\"", "\n", "\n", "original_test_dataset", "=", "dataset_wrapper", "(", "outcome", "=", "y_test", ",", "protected", "=", "p_test", ",", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ",", "\n", "favorable_label", "=", "favorable_label", ",", "\n", "unfavorable_label", "=", "unfavorable_label", ")", "\n", "plain_predictions_test_dataset", "=", "dataset_wrapper", "(", "outcome", "=", "y_pred", ",", "protected", "=", "p_test", ",", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ",", "\n", "favorable_label", "=", "favorable_label", ",", "\n", "unfavorable_label", "=", "unfavorable_label", ")", "\n", "\n", "classified_metric_nodebiasing_test", "=", "ClassificationMetric", "(", "original_test_dataset", ",", "\n", "plain_predictions_test_dataset", ",", "\n", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ")", "\n", "TPR", "=", "classified_metric_nodebiasing_test", ".", "true_positive_rate", "(", ")", "\n", "TNR", "=", "classified_metric_nodebiasing_test", ".", "true_negative_rate", "(", ")", "\n", "bal_acc_nodebiasing_test", "=", "0.5", "*", "(", "TPR", "+", "TNR", ")", "\n", "\n", "print", "(", "\"#### Plain model - without debiasing - classification metrics on test set\"", ")", "\n", "\n", "metrics", "=", "{", "\n", "\"Classification accuracy\"", ":", "classified_metric_nodebiasing_test", ".", "accuracy", "(", ")", ",", "\n", "\"Balanced classification accuracy\"", ":", "bal_acc_nodebiasing_test", ",", "\n", "\"Statistical parity difference\"", ":", "classified_metric_nodebiasing_test", ".", "statistical_parity_difference", "(", ")", ",", "\n", "\"Disparate impact\"", ":", "classified_metric_nodebiasing_test", ".", "disparate_impact", "(", ")", ",", "\n", "\"Equal opportunity difference\"", ":", "classified_metric_nodebiasing_test", ".", "equal_opportunity_difference", "(", ")", ",", "\n", "\"Average odds difference\"", ":", "classified_metric_nodebiasing_test", ".", "average_odds_difference", "(", ")", ",", "\n", "\"Theil index\"", ":", "classified_metric_nodebiasing_test", ".", "theil_index", "(", ")", ",", "\n", "\"False negative rate difference\"", ":", "classified_metric_nodebiasing_test", ".", "false_negative_rate_difference", "(", ")", "\n", "}", "\n", "print", "(", "\"metrics: \"", ",", "metrics", ")", "\n", "return", "metrics", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.src.fairness_check.check_fairness": [[19, 31], ["abs", "abs", "abs", "abs", "abs"], "function", ["None"], ["def", "check_fairness", "(", "metrics", ")", ":", "\n", "    ", "if", "abs", "(", "metrics", "[", "'Statistical parity difference'", "]", ")", ">", "0.1", ":", "\n", "        ", "return", "False", "\n", "", "if", "abs", "(", "metrics", "[", "'Disparate impact'", "]", ")", "<", "0.8", ":", "\n", "        ", "return", "False", "\n", "", "if", "abs", "(", "metrics", "[", "'Equal opportunity difference'", "]", ")", ">", "0.1", ":", "\n", "        ", "return", "False", "\n", "", "if", "abs", "(", "metrics", "[", "'Average odds difference'", "]", ")", ">", "0.1", ":", "\n", "        ", "return", "False", "\n", "", "if", "abs", "(", "metrics", "[", "'False negative rate difference'", "]", ")", ">", "0.1", ":", "\n", "        ", "return", "False", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.src.fairness_check.get_secret": [[33, 41], ["f.close", "open", "f.readline().strip", "f.readline"], "function", ["None"], ["", "def", "get_secret", "(", "path", ",", "default", "=", "''", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "with", "open", "(", "path", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "cred", "=", "f", ".", "readline", "(", ")", ".", "strip", "(", "'\\''", ")", "\n", "", "f", ".", "close", "(", ")", "\n", "return", "cred", "\n", "", "except", ":", "\n", "        ", "return", "default", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_demo_adversarial_debiasing.test_demo_adversarial_debiasing": [[8, 18], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_demo_adversarial_debiasing", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'examples'", ",", "'demo_adversarial_debiasing.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.lfrAlgoInstance": [[15, 27], ["pytest.fixture", "aif360.algorithms.preprocessing.LFR"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", "scope", "=", "\"module\"", ")", "\n", "def", "lfrAlgoInstance", "(", ")", ":", "\n", "    ", "\"\"\"This fixture creates two functions with the scope module lfrAlgoInstance creates an instance of the LFR that can\n     used by both fit and transform functions.\n    ad creates a adult data set that will be used by the fit and the transform functions.\n    \"\"\"", "\n", "privileged_groups", "=", "[", "{", "'sex'", ":", "1.0", "}", "]", "\n", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0.0", "}", "]", "\n", "\n", "lfrAlgoInstance", "=", "LFR", "(", "unprivileged_groups", "=", "unprivileged_groups", ",", "privileged_groups", "=", "privileged_groups", ")", "\n", "\n", "return", "lfrAlgoInstance", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.ad": [[29, 32], ["pytest.fixture", "aif360.algorithms.preprocessing.optim_preproc_helpers.data_preproc_functions.load_preproc_data_adult().split", "aif360.algorithms.preprocessing.optim_preproc_helpers.data_preproc_functions.load_preproc_data_adult"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.data_preproc_functions.load_preproc_data_adult"], ["", "@", "pytest", ".", "fixture", "(", "scope", "=", "\"module\"", ")", "\n", "def", "ad", "(", ")", ":", "\n", "    ", "return", "load_preproc_data_adult", "(", ")", ".", "split", "(", "[", "0.7", "]", ",", "shuffle", "=", "True", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.lfrfitmodel": [[34, 44], ["pytest.fixture", "aif360.algorithms.preprocessing.LFR", "aif360.algorithms.preprocessing.LFR.fit", "aif360.algorithms.preprocessing.optim_preproc_helpers.data_preproc_functions.load_preproc_data_adult().split", "aif360.algorithms.preprocessing.optim_preproc_helpers.data_preproc_functions.load_preproc_data_adult", "test_lfr.ad", "test_lfr.ad", "test_lfr.ad"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split", "home.repos.pwc.inspect_result.IBM_AIF360.optim_preproc_helpers.data_preproc_functions.load_preproc_data_adult", "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.ad", "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.ad", "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.ad"], ["", "@", "pytest", ".", "fixture", "(", "scope", "=", "\"module\"", ")", "\n", "def", "lfrfitmodel", "(", ")", ":", "\n", "    ", "privileged_groups", "=", "[", "{", "'sex'", ":", "1.0", "}", "]", "\n", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0.0", "}", "]", "\n", "\n", "lfrAlgoInstance", "=", "LFR", "(", "unprivileged_groups", "=", "unprivileged_groups", ",", "privileged_groups", "=", "privileged_groups", ")", "\n", "ad", "=", "load_preproc_data_adult", "(", ")", ".", "split", "(", "[", "0.7", "]", ",", "shuffle", "=", "True", ")", "[", "0", "]", "\n", "TR", "=", "lfrAlgoInstance", ".", "fit", "(", "ad", ")", "\n", "\n", "return", "TR", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.test_fit_isnumpy": [[46, 55], ["type"], "function", ["None"], ["", "def", "test_fit_isnumpy", "(", "lfrfitmodel", ")", ":", "\n", "    ", "\"\"\"The Fit function returns a numpy and it should asserted whether it really returned a numpy precision 64 bits.\n    \"\"\"", "\n", "expected", "=", "True", "\n", "if", "type", "(", "lfrfitmodel", ".", "learned_model", ")", "is", "np", ".", "ndarray", ":", "\n", "        ", "res", "=", "True", "\n", "", "else", ":", "\n", "        ", "res", "=", "False", "\n", "", "assert", "res", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.test_fit_notnull": [[57, 67], ["print", "str"], "function", ["None"], ["", "def", "test_fit_notnull", "(", "lfrfitmodel", ")", ":", "\n", "    ", "\"\"\"Should not be null.\n    \"\"\"", "\n", "expected", "=", "False", "\n", "if", "lfrfitmodel", ".", "learned_model", "is", "None", ":", "\n", "        ", "res", "=", "True", "\n", "", "else", ":", "\n", "        ", "res", "=", "False", "\n", "", "print", "(", "\"numpy:\"", "+", "str", "(", "res", ")", ")", "\n", "assert", "res", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.test_fit_notallzeros": [[69, 76], ["print", "numpy.any", "str"], "function", ["None"], ["", "def", "test_fit_notallzeros", "(", "lfrfitmodel", ")", ":", "\n", "    ", "\"\"\"Should not be all zeros.\n    \"\"\"", "\n", "expected", "=", "False", "\n", "all_zeros", "=", "not", "np", ".", "any", "(", "lfrfitmodel", ")", "\n", "print", "(", "\"allzeros:\"", "+", "str", "(", "all_zeros", ")", ")", "\n", "assert", "all_zeros", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.test_fit_notNaN": [[78, 85], ["numpy.isnan().any", "print", "numpy.isnan", "str"], "function", ["None"], ["", "def", "test_fit_notNaN", "(", "lfrfitmodel", ")", ":", "\n", "    ", "\"\"\"Should not have nan's in it.\n    \"\"\"", "\n", "expected", "=", "False", "\n", "res", "=", "np", ".", "isnan", "(", "lfrfitmodel", ".", "learned_model", ")", ".", "any", "(", ")", "\n", "print", "(", "\"nan:\"", "+", "str", "(", "res", ")", ")", "\n", "assert", "res", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.test_transform_protecteddataset": [[91, 101], ["lfrfitmodel.transform", "print", "numpy.array_equal", "type"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform"], ["", "def", "test_transform_protecteddataset", "(", "lfrfitmodel", ",", "ad", ")", ":", "\n", "    ", "\"\"\"After transformation - it should not change protected attributes - it should be same as input.\n    \"\"\"", "\n", "lftransformeddataset", "=", "lfrfitmodel", ".", "transform", "(", "ad", ",", "threshold", "=", "0.3", ")", "\n", "# print( ad.protected_attributes)", "\n", "print", "(", "type", "(", "lftransformeddataset", ".", "protected_attributes", ")", ")", "\n", "# print(\"transformeddataset:\" + lfttransformeddataset.protected_attributes)", "\n", "expected", "=", "True", "\n", "res", "=", "np", ".", "array_equal", "(", "lftransformeddataset", ".", "protected_attributes", ",", "ad", ".", "protected_attributes", ")", "\n", "assert", "res", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.test_transform_notNaN": [[103, 113], ["lfrfitmodel.transform", "numpy.sum().tolist", "numpy.sum().tolist", "numpy.any", "numpy.any", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform"], ["", "def", "test_transform_notNaN", "(", "lfrfitmodel", ",", "ad", ")", ":", "\n", "    ", "\"\"\"The transformed data should not have any columns or rows summing upto zero.\n    \"\"\"", "\n", "lftransformeddataset", "=", "lfrfitmodel", ".", "transform", "(", "ad", ",", "threshold", "=", "0.3", ")", "\n", "lstrowsum", "=", "np", ".", "sum", "(", "lftransformeddataset", ".", "features", ",", "axis", "=", "1", ")", ".", "tolist", "(", ")", "\n", "expected", "=", "False", "\n", "allrow_zeros", "=", "not", "np", ".", "any", "(", "lstrowsum", ")", "\n", "lstcolsum", "=", "np", ".", "sum", "(", "lftransformeddataset", ".", "features", ",", "axis", "=", "0", ")", ".", "tolist", "(", ")", "\n", "allcol_zeros", "=", "not", "np", ".", "any", "(", "lstcolsum", ")", "\n", "assert", "(", "allrow_zeros", "and", "allcol_zeros", ")", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_lfr.test_transform_notNaN2": [[115, 122], ["lfrfitmodel.transform", "numpy.isnan().any", "numpy.isnan"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform"], ["", "def", "test_transform_notNaN2", "(", "lfrfitmodel", ",", "ad", ")", ":", "\n", "    ", "\"\"\"The transformed data should not contain nan's. Using the threshold value of 0.3.\n    \"\"\"", "\n", "lftransformeddataset", "=", "lfrfitmodel", ".", "transform", "(", "ad", ",", "threshold", "=", "0.3", ")", "\n", "expected", "=", "False", "\n", "res", "=", "np", ".", "isnan", "(", "lftransformeddataset", ".", "features", ")", ".", "any", "(", ")", "\n", "assert", "res", "==", "expected", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_sample_distortion_metric.test_euclidean_distance": [[34, 37], ["aif360.metrics.SampleDistortionMetric", "aif360.metrics.SampleDistortionMetric.total_euclidean_distance", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total_euclidean_distance"], ["def", "test_euclidean_distance", "(", ")", ":", "\n", "    ", "sdm", "=", "SampleDistortionMetric", "(", "sd", ",", "sd_distorted", ")", "\n", "assert", "sdm", ".", "total_euclidean_distance", "(", ")", "==", "4", "*", "np", ".", "sqrt", "(", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_sample_distortion_metric.test_manhattan_distance": [[38, 41], ["aif360.metrics.SampleDistortionMetric", "aif360.metrics.SampleDistortionMetric.total_manhattan_distance"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total_manhattan_distance"], ["", "def", "test_manhattan_distance", "(", ")", ":", "\n", "    ", "sdm", "=", "SampleDistortionMetric", "(", "sd", ",", "sd_distorted", ")", "\n", "assert", "sdm", ".", "total_manhattan_distance", "(", ")", "==", "12", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_sample_distortion_metric.test_mahalanobis_distance": [[42, 46], ["aif360.metrics.SampleDistortionMetric", "numpy.isclose", "aif360.metrics.SampleDistortionMetric.total_mahalanobis_distance", "numpy.diag().sum", "numpy.diag", "scipy.spatial.distance.cdist"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total_mahalanobis_distance"], ["", "def", "test_mahalanobis_distance", "(", ")", ":", "\n", "    ", "sdm", "=", "SampleDistortionMetric", "(", "sd_rand", ",", "sd_rand2", ")", "\n", "assert", "np", ".", "isclose", "(", "sdm", ".", "total_mahalanobis_distance", "(", ")", ",", "\n", "np", ".", "diag", "(", "cdist", "(", "rand", "[", ":", ",", ":", "3", "]", ",", "rand2", "[", ":", ",", ":", "3", "]", ",", "'mahalanobis'", ")", ")", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_sample_distortion_metric.test_conditional": [[47, 51], ["aif360.metrics.SampleDistortionMetric", "aif360.metrics.SampleDistortionMetric.total_manhattan_distance"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.total_manhattan_distance"], ["", "def", "test_conditional", "(", ")", ":", "\n", "    ", "sdm", "=", "SampleDistortionMetric", "(", "sd", ",", "sd_distorted", ",", "unprivileged_groups", "=", "unpriv", ",", "\n", "privileged_groups", "=", "priv", ")", "\n", "assert", "sdm", ".", "total_manhattan_distance", "(", "privileged", "=", "False", ")", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_sample_distortion_metric.test_average": [[52, 57], ["numpy.array", "aif360.metrics.SampleDistortionMetric", "aif360.metrics.SampleDistortionMetric.average_manhattan_distance"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.sample_distortion_metric.SampleDistortionMetric.average_manhattan_distance"], ["", "def", "test_average", "(", ")", ":", "\n", "    ", "sd_distorted", ".", "features", "[", "-", "1", ",", "-", "1", "]", "+=", "1", "\n", "sd", ".", "instance_weights", "=", "sd_distorted", ".", "instance_weights", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "3", "]", ")", "\n", "sdm", "=", "SampleDistortionMetric", "(", "sd", ",", "sd_distorted", ")", "\n", "assert", "sdm", ".", "average_manhattan_distance", "(", ")", "==", "3.5", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_sample_distortion_metric.test_error": [[58, 64], ["aif360.metrics.SampleDistortionMetric"], "function", ["None"], ["", "def", "test_error", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "sd", ".", "protected_attributes", "-=", "1", "\n", "sdm", "=", "SampleDistortionMetric", "(", "sd", ",", "sd_distorted", ")", "\n", "", "except", "ValueError", ":", "\n", "        ", "assert", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run": [[10, 36], ["os.path.split", "os.chdir", "tempfile.NamedTemporaryFile", "subprocess.check_call", "fout.seek", "nbformat.read"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split"], ["def", "notebook_run", "(", "path", ")", ":", "\n", "    ", "\"\"\"Execute a notebook via nbconvert and collect output.\n       :returns (parsed nb object, execution errors)\n    \"\"\"", "\n", "dirname", ",", "__", "=", "os", ".", "path", ".", "split", "(", "path", ")", "\n", "os", ".", "chdir", "(", "dirname", ")", "\n", "\n", "kername", "=", "\"python3\"", "\n", "\n", "with", "tempfile", ".", "NamedTemporaryFile", "(", "suffix", "=", "\".ipynb\"", ")", "as", "fout", ":", "\n", "        ", "args", "=", "[", "\"jupyter\"", ",", "\"nbconvert\"", ",", "\"--to\"", ",", "\"notebook\"", ",", "\"--execute\"", ",", "\n", "\"--ExecutePreprocessor.timeout=600\"", ",", "\n", "\"--ExecutePreprocessor.allow_errors=True\"", ",", "\n", "\"--ExecutePreprocessor.kernel_name={}\"", ".", "format", "(", "kername", ")", ",", "\n", "\"--output\"", ",", "fout", ".", "name", ",", "path", "]", "\n", "\n", "subprocess", ".", "check_call", "(", "args", ")", "\n", "\n", "fout", ".", "seek", "(", "0", ")", "\n", "nb", "=", "nbformat", ".", "read", "(", "fout", ",", "nbformat", ".", "current_nbformat", ")", "\n", "\n", "", "errors", "=", "[", "output", "for", "cell", "in", "nb", ".", "cells", "if", "\"outputs\"", "in", "cell", "\n", "for", "output", "in", "cell", "[", "\"outputs\"", "]", "\n", "if", "output", ".", "output_type", "==", "\"error\"", "]", "\n", "\n", "return", "nb", ",", "errors", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_demo_reweighing_preproc.test_reweighing_preproc": [[8, 18], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_reweighing_preproc", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'examples'", ",", "'demo_reweighing_preproc.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_demo_calibrated_eqodds_postprocessing.test_calibrated_eqodds_postprocessing": [[7, 17], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_calibrated_eqodds_postprocessing", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'examples'", ",", "'demo_calibrated_eqodds_postprocessing.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_structured_dataset.test_temporarily_ignore": [[16, 24], ["aif360.datasets.StructuredDataset", "aif360.datasets.StructuredDataset.copy", "aif360.datasets.StructuredDataset.temporarily_ignore"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.structured_dataset.StructuredDataset.temporarily_ignore"], ["def", "test_temporarily_ignore", "(", ")", ":", "\n", "    ", "sd", "=", "StructuredDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "protected_attribute_names", "=", "[", "'one'", ",", "'three'", "]", ")", "\n", "modified", "=", "sd", ".", "copy", "(", ")", "\n", "modified", ".", "labels", "=", "sd", ".", "labels", "+", "1", "\n", "assert", "sd", "!=", "modified", "\n", "with", "sd", ".", "temporarily_ignore", "(", "'labels'", ")", ":", "\n", "        ", "assert", "sd", "==", "modified", "\n", "", "assert", "'labels'", "not", "in", "sd", ".", "ignore_fields", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_structured_dataset.test_split": [[25, 33], ["aif360.datasets.StructuredDataset", "aif360.datasets.StructuredDataset.split", "aif360.datasets.StructuredDataset.split", "numpy.all", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split"], ["", "def", "test_split", "(", ")", ":", "\n", "    ", "sd", "=", "StructuredDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "protected_attribute_names", "=", "[", "'two'", "]", ")", "\n", "train", ",", "test", "=", "sd", ".", "split", "(", "[", "0.5", "]", ")", "\n", "train2", ",", "test2", "=", "sd", ".", "split", "(", "2", ")", "\n", "\n", "assert", "train", "==", "train2", "\n", "assert", "test", "==", "test2", "\n", "assert", "np", ".", "all", "(", "np", ".", "concatenate", "(", "(", "train", ".", "features", ",", "test", ".", "features", ")", ")", "==", "sd", ".", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_structured_dataset.test_k_folds": [[34, 45], ["aif360.datasets.StructuredDataset", "aif360.datasets.StructuredDataset.split", "all", "aif360.datasets.StructuredDataset.split", "len", "len"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split"], ["", "def", "test_k_folds", "(", ")", ":", "\n", "    ", "sd", "=", "StructuredDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "protected_attribute_names", "=", "[", "'two'", "]", ")", "\n", "folds", "=", "sd", ".", "split", "(", "4", ")", "\n", "\n", "assert", "len", "(", "folds", ")", "==", "4", "\n", "assert", "all", "(", "f", ".", "features", ".", "shape", "[", "0", "]", "==", "f", ".", "labels", ".", "shape", "[", "0", "]", "\n", "==", "f", ".", "protected_attributes", ".", "shape", "[", "0", "]", "==", "len", "(", "f", ".", "instance_names", ")", "\n", "==", "f", ".", "instance_weights", ".", "shape", "[", "0", "]", "==", "1", "for", "f", "in", "folds", ")", "\n", "\n", "folds", "=", "sd", ".", "split", "(", "3", ")", "\n", "assert", "folds", "[", "0", "]", ".", "features", ".", "shape", "[", "0", "]", "==", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_structured_dataset.test_copy": [[46, 54], ["aif360.datasets.StructuredDataset", "aif360.datasets.StructuredDataset.copy", "aif360.datasets.StructuredDataset.copy", "numpy.all", "numpy.any"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "test_copy", "(", ")", ":", "\n", "    ", "sd", "=", "StructuredDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "protected_attribute_names", "=", "[", "'two'", "]", ")", "\n", "sd2", "=", "sd", ".", "copy", "(", ")", "\n", "sd3", "=", "sd", ".", "copy", "(", "True", ")", "\n", "\n", "sd", ".", "features", "[", "0", "]", "=", "999", "\n", "assert", "np", ".", "all", "(", "sd2", ".", "features", "[", "0", "]", "==", "999", ")", "\n", "assert", "not", "np", ".", "any", "(", "sd3", ".", "features", "[", "0", "]", "==", "999", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_structured_dataset.test_eq": [[55, 65], ["aif360.datasets.StructuredDataset", "aif360.datasets.StructuredDataset.copy", "aif360.datasets.StructuredDataset.copy", "aif360.datasets.StructuredDataset"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy"], ["", "def", "test_eq", "(", ")", ":", "\n", "    ", "sd", "=", "StructuredDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "protected_attribute_names", "=", "[", "'two'", "]", ")", "\n", "sd2", "=", "sd", ".", "copy", "(", ")", "\n", "sd3", "=", "sd", ".", "copy", "(", "True", ")", "\n", "sd4", "=", "StructuredDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "protected_attribute_names", "=", "[", "'one'", ",", "'three'", "]", ")", "\n", "\n", "assert", "sd", "==", "sd2", "\n", "assert", "sd", "==", "sd3", "\n", "assert", "sd2", "==", "sd3", "\n", "assert", "sd", "!=", "sd4", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_demo_lfr.test_demo_lfr": [[8, 18], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_demo_lfr", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'examples'", ",", "'demo_lfr.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_disparate_impact_remover.test_repair0": [[12, 21], ["aif360.datasets.AdultDataset", "aif360.algorithms.preprocessing.DisparateImpactRemover", "aif360.algorithms.preprocessing.DisparateImpactRemover.fit_transform"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform"], ["def", "test_repair0", "(", ")", ":", "\n", "    ", "ad", "=", "AdultDataset", "(", "protected_attribute_names", "=", "[", "'sex'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'Male'", "]", "]", ",", "categorical_features", "=", "[", "]", ",", "\n", "features_to_keep", "=", "[", "'age'", ",", "'education-num'", "]", ")", "\n", "\n", "di", "=", "DisparateImpactRemover", "(", "repair_level", "=", "0.", ")", "\n", "ad_repd", "=", "di", ".", "fit_transform", "(", "ad", ")", "\n", "\n", "assert", "ad_repd", "==", "ad", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_disparate_impact_remover.test_adult": [[22, 81], ["aif360.datasets.AdultDataset", "sklearn.preprocessing.MinMaxScaler", "aif360.datasets.AdultDataset.split", "numpy.any", "sklearn.preprocessing.MinMaxScaler.fit_transform", "sklearn.preprocessing.MinMaxScaler.transform", "train.feature_names.index", "numpy.delete", "numpy.delete", "train.labels.ravel", "aif360.algorithms.preprocessing.DisparateImpactRemover", "aif360.algorithms.preprocessing.DisparateImpactRemover.fit_transform", "aif360.algorithms.preprocessing.DisparateImpactRemover.fit_transform", "numpy.all", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression.fit", "test.copy", "sklearn.linear_model.LogisticRegression.predict", "numpy.delete", "numpy.delete", "di.fit_transform.labels.ravel", "sklearn.linear_model.LogisticRegression.fit", "di.fit_transform.copy", "sklearn.linear_model.LogisticRegression.predict", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.disparate_impact", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.disparate_impact", "abs"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.learning_fair_representations.LearnedFairRepresentations.transform", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact"], ["", "def", "test_adult", "(", ")", ":", "\n", "    ", "protected", "=", "'sex'", "\n", "ad", "=", "AdultDataset", "(", "protected_attribute_names", "=", "[", "protected", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'Male'", "]", "]", ",", "categorical_features", "=", "[", "]", ",", "\n", "features_to_keep", "=", "[", "'age'", ",", "'education-num'", ",", "'capital-gain'", ",", "'capital-loss'", ",", "'hours-per-week'", "]", ")", "\n", "\n", "scaler", "=", "MinMaxScaler", "(", "copy", "=", "False", ")", "\n", "# ad.features = scaler.fit_transform(ad.features)", "\n", "\n", "test", ",", "train", "=", "ad", ".", "split", "(", "[", "16281", "]", ")", "\n", "assert", "np", ".", "any", "(", "test", ".", "labels", ")", "\n", "\n", "train", ".", "features", "=", "scaler", ".", "fit_transform", "(", "train", ".", "features", ")", "\n", "test", ".", "features", "=", "scaler", ".", "transform", "(", "test", ".", "features", ")", "\n", "\n", "index", "=", "train", ".", "feature_names", ".", "index", "(", "protected", ")", "\n", "X_tr", "=", "np", ".", "delete", "(", "train", ".", "features", ",", "index", ",", "axis", "=", "1", ")", "\n", "X_te", "=", "np", ".", "delete", "(", "test", ".", "features", ",", "index", ",", "axis", "=", "1", ")", "\n", "y_tr", "=", "train", ".", "labels", ".", "ravel", "(", ")", "\n", "\n", "di", "=", "DisparateImpactRemover", "(", "repair_level", "=", "1.0", ")", "\n", "train_repd", "=", "di", ".", "fit_transform", "(", "train", ")", "\n", "# train_repd2 = di.fit_transform(train)", "\n", "# assert train_repd == train_repd2", "\n", "test_repd", "=", "di", ".", "fit_transform", "(", "test", ")", "\n", "\n", "assert", "np", ".", "all", "(", "train_repd", ".", "protected_attributes", "==", "train", ".", "protected_attributes", ")", "\n", "\n", "lmod", "=", "LogisticRegression", "(", "class_weight", "=", "'balanced'", ")", "\n", "# lmod = SVM(class_weight='balanced')", "\n", "lmod", ".", "fit", "(", "X_tr", ",", "y_tr", ")", "\n", "\n", "test_pred", "=", "test", ".", "copy", "(", ")", "\n", "test_pred", ".", "labels", "=", "lmod", ".", "predict", "(", "X_te", ")", "\n", "\n", "X_tr_repd", "=", "np", ".", "delete", "(", "train_repd", ".", "features", ",", "index", ",", "axis", "=", "1", ")", "\n", "X_te_repd", "=", "np", ".", "delete", "(", "test_repd", ".", "features", ",", "index", ",", "axis", "=", "1", ")", "\n", "y_tr_repd", "=", "train_repd", ".", "labels", ".", "ravel", "(", ")", "\n", "assert", "(", "y_tr", "==", "y_tr_repd", ")", ".", "all", "(", ")", "\n", "\n", "lmod", ".", "fit", "(", "X_tr_repd", ",", "y_tr_repd", ")", "\n", "test_repd_pred", "=", "test_repd", ".", "copy", "(", ")", "\n", "test_repd_pred", ".", "labels", "=", "lmod", ".", "predict", "(", "X_te_repd", ")", "\n", "\n", "p", "=", "[", "{", "protected", ":", "1", "}", "]", "\n", "u", "=", "[", "{", "protected", ":", "0", "}", "]", "\n", "\n", "cm", "=", "ClassificationMetric", "(", "test", ",", "test_pred", ",", "privileged_groups", "=", "p", ",", "unprivileged_groups", "=", "u", ")", "\n", "before", "=", "cm", ".", "disparate_impact", "(", ")", "\n", "# print('Disparate impact: {:.4}'.format(before))", "\n", "# print('Acc overall: {:.4}'.format(cm.accuracy()))", "\n", "\n", "repaired_cm", "=", "ClassificationMetric", "(", "test_repd", ",", "test_repd_pred", ",", "privileged_groups", "=", "p", ",", "unprivileged_groups", "=", "u", ")", "\n", "after", "=", "repaired_cm", ".", "disparate_impact", "(", ")", "\n", "# print('Disparate impact: {:.4}'.format(after))", "\n", "# print('Acc overall: {:.4}'.format(repaired_cm.accuracy()))", "\n", "\n", "assert", "after", ">", "before", "\n", "assert", "abs", "(", "1", "-", "after", ")", "<=", "0.2", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_demo_exp_grad_red.test_demo_exp_grad_red": [[5, 16], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_demo_exp_grad_red", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'examples'", ",", "\n", "'demo_exponentiated_gradient_reduction.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_classification_metric.test_generalized_entropy_index": [[9, 41], ["numpy.array", "np.array.copy", "pandas.DataFrame", "pandas.DataFrame", "aif360.datasets.BinaryLabelDataset", "aif360.datasets.BinaryLabelDataset", "aif360.metrics.ClassificationMetric", "np.array.copy", "numpy.array", "pandas.DataFrame", "aif360.datasets.BinaryLabelDataset", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.generalized_entropy_index", "aif360.metrics.ClassificationMetric.generalized_entropy_index"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.generalized_entropy_index"], ["def", "test_generalized_entropy_index", "(", ")", ":", "\n", "    ", "data", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "2", ",", "1", "]", ",", "\n", "[", "2", ",", "0", "]", ",", "\n", "[", "2", ",", "1", "]", ",", "\n", "[", "2", ",", "1", "]", "]", ")", "\n", "pred", "=", "data", ".", "copy", "(", ")", "\n", "pred", "[", "[", "3", ",", "9", "]", ",", "-", "1", "]", "=", "0", "\n", "pred", "[", "[", "4", ",", "5", "]", ",", "-", "1", "]", "=", "1", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "df2", "=", "pd", ".", "DataFrame", "(", "pred", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "bld", "=", "BinaryLabelDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ")", "\n", "bld2", "=", "BinaryLabelDataset", "(", "df", "=", "df2", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ")", "\n", "cm", "=", "ClassificationMetric", "(", "bld", ",", "bld2", ")", "\n", "\n", "assert", "cm", ".", "generalized_entropy_index", "(", ")", "==", "0.2", "\n", "\n", "pred", "=", "data", ".", "copy", "(", ")", "\n", "pred", "[", ":", ",", "-", "1", "]", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "df2", "=", "pd", ".", "DataFrame", "(", "pred", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "bld2", "=", "BinaryLabelDataset", "(", "df", "=", "df2", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ")", "\n", "cm", "=", "ClassificationMetric", "(", "bld", ",", "bld2", ")", "\n", "\n", "assert", "cm", ".", "generalized_entropy_index", "(", ")", "==", "0.3", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_classification_metric.test_theil_index": [[42, 65], ["numpy.array", "np.array.copy", "pandas.DataFrame", "pandas.DataFrame", "aif360.datasets.BinaryLabelDataset", "aif360.datasets.BinaryLabelDataset", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.theil_index", "numpy.log"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.theil_index"], ["", "def", "test_theil_index", "(", ")", ":", "\n", "    ", "data", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "2", ",", "1", "]", ",", "\n", "[", "2", ",", "0", "]", ",", "\n", "[", "2", ",", "1", "]", ",", "\n", "[", "2", ",", "1", "]", "]", ")", "\n", "pred", "=", "data", ".", "copy", "(", ")", "\n", "pred", "[", "[", "3", ",", "9", "]", ",", "-", "1", "]", "=", "0", "\n", "pred", "[", "[", "4", ",", "5", "]", ",", "-", "1", "]", "=", "1", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "df2", "=", "pd", ".", "DataFrame", "(", "pred", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "bld", "=", "BinaryLabelDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ")", "\n", "bld2", "=", "BinaryLabelDataset", "(", "df", "=", "df2", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ")", "\n", "cm", "=", "ClassificationMetric", "(", "bld", ",", "bld2", ")", "\n", "\n", "assert", "cm", ".", "theil_index", "(", ")", "==", "4", "*", "np", ".", "log", "(", "2", ")", "/", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_classification_metric.test_between_all_groups": [[66, 90], ["numpy.array", "np.array.copy", "pandas.DataFrame", "pandas.DataFrame", "aif360.datasets.BinaryLabelDataset", "aif360.datasets.BinaryLabelDataset", "aif360.metrics.ClassificationMetric", "numpy.array", "aif360.metrics.ClassificationMetric.between_all_groups_generalized_entropy_index", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_all_groups_generalized_entropy_index"], ["", "def", "test_between_all_groups", "(", ")", ":", "\n", "    ", "data", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "2", ",", "1", "]", ",", "\n", "[", "2", ",", "0", "]", ",", "\n", "[", "2", ",", "1", "]", ",", "\n", "[", "2", ",", "1", "]", "]", ")", "\n", "pred", "=", "data", ".", "copy", "(", ")", "\n", "pred", "[", "[", "3", ",", "9", "]", ",", "-", "1", "]", "=", "0", "\n", "pred", "[", "[", "4", ",", "5", "]", ",", "-", "1", "]", "=", "1", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "df2", "=", "pd", ".", "DataFrame", "(", "pred", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "bld", "=", "BinaryLabelDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ")", "\n", "bld2", "=", "BinaryLabelDataset", "(", "df", "=", "df2", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ")", "\n", "cm", "=", "ClassificationMetric", "(", "bld", ",", "bld2", ")", "\n", "\n", "b", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1.25", ",", "1.25", ",", "1.25", ",", "1.25", ",", "0.75", ",", "0.75", ",", "0.75", ",", "0.75", "]", ")", "\n", "assert", "cm", ".", "between_all_groups_generalized_entropy_index", "(", ")", "==", "1", "/", "20", "*", "np", ".", "sum", "(", "b", "**", "2", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_classification_metric.test_between_group": [[91, 112], ["numpy.array", "np.array.copy", "pandas.DataFrame", "pandas.DataFrame", "aif360.datasets.BinaryLabelDataset", "aif360.datasets.BinaryLabelDataset", "aif360.metrics.ClassificationMetric", "numpy.array", "aif360.metrics.ClassificationMetric.between_group_generalized_entropy_index", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.between_group_generalized_entropy_index"], ["", "def", "test_between_group", "(", ")", ":", "\n", "    ", "data", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", "]", "]", ")", "\n", "pred", "=", "data", ".", "copy", "(", ")", "\n", "pred", "[", "[", "0", ",", "3", "]", ",", "-", "1", "]", "=", "0", "\n", "pred", "[", "[", "4", ",", "5", "]", ",", "-", "1", "]", "=", "1", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "[", "'feat'", ",", "'feat2'", ",", "'label'", "]", ")", "\n", "df2", "=", "pd", ".", "DataFrame", "(", "pred", ",", "columns", "=", "[", "'feat'", ",", "'feat2'", ",", "'label'", "]", ")", "\n", "bld", "=", "BinaryLabelDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", ",", "'feat2'", "]", ")", "\n", "bld2", "=", "BinaryLabelDataset", "(", "df", "=", "df2", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", ",", "'feat2'", "]", ")", "\n", "cm", "=", "ClassificationMetric", "(", "bld", ",", "bld2", ",", "unprivileged_groups", "=", "[", "{", "'feat'", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "'feat'", ":", "1", "}", "]", ")", "\n", "\n", "b", "=", "np", ".", "array", "(", "[", "0.5", ",", "0.5", ",", "1.25", ",", "1.25", ",", "1.25", ",", "1.25", "]", ")", "\n", "assert", "cm", ".", "between_group_generalized_entropy_index", "(", ")", "==", "1", "/", "12", "*", "np", ".", "sum", "(", "b", "**", "2", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_classification_metric.test_multiclass_confusion_matrix": [[113, 151], ["numpy.array", "np.array.copy", "pandas.DataFrame", "pandas.DataFrame", "aif360.datasets.multiclass_label_dataset.MulticlassLabelDataset", "aif360.datasets.multiclass_label_dataset.MulticlassLabelDataset", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.binary_confusion_matrix", "numpy.all", "numpy.all", "aif360.metrics.ClassificationMetric.false_negative_rate_difference"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.copy", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.binary_confusion_matrix", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_negative_rate_difference"], ["", "def", "test_multiclass_confusion_matrix", "(", ")", ":", "\n", "    ", "data", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "2", "]", ",", "\n", "[", "2", ",", "1", "]", ",", "\n", "[", "2", ",", "0", "]", ",", "\n", "[", "2", ",", "2", "]", ",", "\n", "[", "2", ",", "1", "]", "]", ")", "\n", "pred", "=", "data", ".", "copy", "(", ")", "\n", "pred", "[", "3", ",", "1", "]", "=", "0", "\n", "pred", "[", "4", ",", "1", "]", "=", "2", "\n", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "df2", "=", "pd", ".", "DataFrame", "(", "pred", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "\n", "favorable_values", "=", "[", "0", ",", "1", "]", "\n", "unfavorable_values", "=", "[", "2", "]", "\n", "mcld", "=", "MulticlassLabelDataset", "(", "favorable_label", "=", "favorable_values", ",", "unfavorable_label", "=", "unfavorable_values", ",", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ")", "\n", "mcld2", "=", "MulticlassLabelDataset", "(", "favorable_label", "=", "favorable_values", ",", "unfavorable_label", "=", "unfavorable_values", ",", "df", "=", "df2", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ")", "\n", "cm", "=", "ClassificationMetric", "(", "mcld", ",", "mcld2", ",", "unprivileged_groups", "=", "[", "{", "'feat'", ":", "2", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "'feat'", ":", "0", "}", ",", "{", "'feat'", ":", "1", "}", "]", ")", "\n", "confusion_matrix", "=", "cm", ".", "binary_confusion_matrix", "(", ")", "\n", "\n", "actual_labels_df", "=", "df", "[", "[", "'label'", "]", "]", ".", "values", "\n", "actual_labels_df2", "=", "df2", "[", "[", "'label'", "]", "]", ".", "values", "\n", "\n", "assert", "np", ".", "all", "(", "actual_labels_df", "==", "mcld", ".", "labels", ")", "\n", "assert", "np", ".", "all", "(", "actual_labels_df2", "==", "mcld2", ".", "labels", ")", "\n", "\n", "assert", "confusion_matrix", "==", "{", "'TP'", ":", "7.0", ",", "'FN'", ":", "1.0", ",", "'TN'", ":", "2.0", ",", "'FP'", ":", "0.0", "}", "\n", "\n", "fnr", "=", "cm", ".", "false_negative_rate_difference", "(", ")", "\n", "assert", "fnr", "==", "-", "0.2", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_classification_metric.test_generalized_binary_confusion_matrix": [[152, 196], ["numpy.array", "numpy.array", "pandas.DataFrame", "pandas.DataFrame", "aif360.datasets.multiclass_label_dataset.MulticlassLabelDataset", "aif360.datasets.multiclass_label_dataset.MulticlassLabelDataset", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.generalized_binary_confusion_matrix", "aif360.metrics.ClassificationMetric.num_generalized_true_positives", "aif360.metrics.ClassificationMetric.num_generalized_false_positives", "round"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.generalized_binary_confusion_matrix", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_true_positives", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.num_generalized_false_positives"], ["", "def", "test_generalized_binary_confusion_matrix", "(", ")", ":", "\n", "    ", "data", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "2", "]", ",", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "2", "]", "]", ")", "\n", "\n", "pred", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0.8", "]", ",", "\n", "[", "0", ",", "0", ",", "0.6", "]", ",", "\n", "[", "1", ",", "0", ",", "0.7", "]", ",", "\n", "[", "1", ",", "1", ",", "0.8", "]", ",", "\n", "[", "1", ",", "2", ",", "0.36", "]", ",", "\n", "[", "1", ",", "0", ",", "0.82", "]", ",", "\n", "[", "1", ",", "1", ",", "0.79", "]", ",", "\n", "[", "0", ",", "2", ",", "0.42", "]", ",", "\n", "[", "0", ",", "1", ",", "0.81", "]", ",", "\n", "[", "1", ",", "2", ",", "0.3", "]", "]", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "[", "'feat'", ",", "'label'", "]", ")", "\n", "df2", "=", "pd", ".", "DataFrame", "(", "pred", ",", "columns", "=", "[", "'feat'", ",", "'label'", ",", "'score'", "]", ")", "\n", "\n", "favorable_values", "=", "[", "0", ",", "1", "]", "\n", "unfavorable_values", "=", "[", "2", "]", "\n", "\n", "mcld", "=", "MulticlassLabelDataset", "(", "df", "=", "df", ",", "label_names", "=", "[", "'label'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ",", "favorable_label", "=", "favorable_values", ",", "unfavorable_label", "=", "unfavorable_values", ")", "\n", "\n", "mcld2", "=", "MulticlassLabelDataset", "(", "df", "=", "df2", ",", "label_names", "=", "[", "'label'", "]", ",", "scores_names", "=", "[", "'score'", "]", ",", "\n", "protected_attribute_names", "=", "[", "'feat'", "]", ",", "favorable_label", "=", "favorable_values", ",", "unfavorable_label", "=", "unfavorable_values", ")", "\n", "\n", "\n", "cm", "=", "ClassificationMetric", "(", "mcld", ",", "mcld2", ",", "unprivileged_groups", "=", "[", "{", "'feat'", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "'feat'", ":", "1", "}", "]", ")", "\n", "\n", "gen_confusion_matrix", "=", "cm", ".", "generalized_binary_confusion_matrix", "(", ")", "\n", "\n", "gtp", "=", "cm", ".", "num_generalized_true_positives", "(", ")", "\n", "assert", "round", "(", "gtp", ",", "2", ")", "==", "5.31", "\n", "gfp", "=", "cm", ".", "num_generalized_false_positives", "(", ")", "\n", "assert", "gfp", "==", "1.09", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_differential_fairness.test_epsilon_dataset_binary_groups": [[26, 29], ["dataset_metric.smoothed_empirical_differential_fairness"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.smoothed_empirical_differential_fairness"], ["def", "test_epsilon_dataset_binary_groups", "(", ")", ":", "\n", "    ", "eps_data", "=", "dataset_metric", ".", "smoothed_empirical_differential_fairness", "(", ")", "\n", "assert", "eps_data", "==", "1.53679014653623", "# verified with reference implementation", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_differential_fairness.test_epsilon_classifier_binary_groups": [[30, 33], ["classifier_metric.smoothed_empirical_differential_fairness"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.smoothed_empirical_differential_fairness"], ["", "def", "test_epsilon_classifier_binary_groups", "(", ")", ":", "\n", "    ", "eps_clf", "=", "classifier_metric", ".", "smoothed_empirical_differential_fairness", "(", ")", "\n", "assert", "eps_clf", "==", "1.6434003346776307", "# verified with reference implementation", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_differential_fairness.test_bias_amplification_binary_groups": [[34, 40], ["aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.differential_fairness_bias_amplification", "dataset_metric.smoothed_empirical_differential_fairness", "classifier_metric.smoothed_empirical_differential_fairness"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.metrics.classification_metric.ClassificationMetric.differential_fairness_bias_amplification", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.smoothed_empirical_differential_fairness", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.smoothed_empirical_differential_fairness"], ["", "def", "test_bias_amplification_binary_groups", "(", ")", ":", "\n", "    ", "metric", "=", "ClassificationMetric", "(", "adult_test", ",", "adult_pred", ")", "\n", "bias_amp", "=", "metric", ".", "differential_fairness_bias_amplification", "(", ")", "\n", "eps_data", "=", "dataset_metric", ".", "smoothed_empirical_differential_fairness", "(", ")", "\n", "eps_clf", "=", "classifier_metric", ".", "smoothed_empirical_differential_fairness", "(", ")", "\n", "assert", "bias_amp", "==", "(", "eps_clf", "-", "eps_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_differential_fairness.test_epsilon_all_groups": [[41, 65], ["aif360.datasets.AdultDataset", "aif360.datasets.AdultDataset.feature_names.index", "numpy.delete", "numpy.delete", "aif360.datasets.AdultDataset.split", "aif360.metrics.BinaryLabelDatasetMetric", "aif360.metrics.BinaryLabelDatasetMetric.smoothed_empirical_differential_fairness", "df.race.map", "df.fillna"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.binary_label_dataset_metric.BinaryLabelDatasetMetric.smoothed_empirical_differential_fairness"], ["", "def", "test_epsilon_all_groups", "(", ")", ":", "\n", "    ", "def", "custom_preprocessing", "(", "df", ")", ":", "\n", "# slight workaround for non-binary protected attribute", "\n", "# feature should be categorical but protected attribute should be numerical", "\n", "        ", "mapping", "=", "{", "'Black'", ":", "0", ",", "'White'", ":", "1", ",", "'Asian-Pac-Islander'", ":", "2", ",", "\n", "'Amer-Indian-Eskimo'", ":", "3", ",", "'Other'", ":", "4", "}", "\n", "df", "[", "'race-num'", "]", "=", "df", ".", "race", ".", "map", "(", "mapping", ")", "\n", "return", "df", ".", "fillna", "(", "'Unknown'", ")", "\n", "\n", "", "nonbinary_ad", "=", "AdultDataset", "(", "\n", "protected_attribute_names", "=", "[", "'sex'", ",", "'native-country'", ",", "'race-num'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'Male'", "]", ",", "[", "'United-States'", "]", ",", "[", "1", "]", "]", ",", "\n", "categorical_features", "=", "[", "'workclass'", ",", "'education'", ",", "'marital-status'", ",", "\n", "'occupation'", ",", "'relationship'", ",", "'race'", "]", ",", "\n", "custom_preprocessing", "=", "custom_preprocessing", ")", "\n", "# drop redundant race feature (not relevant to this test)", "\n", "index", "=", "nonbinary_ad", ".", "feature_names", ".", "index", "(", "'race-num'", ")", "\n", "nonbinary_ad", ".", "features", "=", "np", ".", "delete", "(", "nonbinary_ad", ".", "features", ",", "index", ",", "axis", "=", "1", ")", "\n", "nonbinary_ad", ".", "feature_names", "=", "np", ".", "delete", "(", "nonbinary_ad", ".", "feature_names", ",", "index", ")", "\n", "\n", "nonbinary_test", ",", "_", "=", "nonbinary_ad", ".", "split", "(", "[", "16281", "]", ",", "shuffle", "=", "False", ")", "\n", "dataset_metric", "=", "BinaryLabelDatasetMetric", "(", "nonbinary_test", ")", "\n", "eps_data", "=", "dataset_metric", ".", "smoothed_empirical_differential_fairness", "(", ")", "\n", "assert", "eps_data", "==", "2.063813731996515", "# verified with reference implementation", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_standard_datasets.test_compas": [[15, 18], ["aif360.datasets.CompasDataset"], "function", ["None"], ["def", "test_compas", "(", ")", ":", "\n", "# just test that there are no errors for default loading...", "\n", "    ", "cd", "=", "CompasDataset", "(", ")", "\n", "# print(cd)", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_standard_datasets.test_german": [[20, 24], ["aif360.datasets.GermanDataset", "aif360.metrics.BinaryLabelDatasetMetric", "aif360.metrics.BinaryLabelDatasetMetric.num_instances"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "test_german", "(", ")", ":", "\n", "    ", "gd", "=", "GermanDataset", "(", ")", "\n", "bldm", "=", "BinaryLabelDatasetMetric", "(", "gd", ")", "\n", "assert", "bldm", ".", "num_instances", "(", ")", "==", "1000", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_standard_datasets.test_adult_test_set": [[25, 30], ["aif360.datasets.AdultDataset", "aif360.datasets.AdultDataset.split", "numpy.any"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.datasets.dataset.Dataset.split"], ["", "def", "test_adult_test_set", "(", ")", ":", "\n", "    ", "ad", "=", "AdultDataset", "(", ")", "\n", "# test, train = ad.split([16281])", "\n", "test", ",", "train", "=", "ad", ".", "split", "(", "[", "15060", "]", ")", "\n", "assert", "np", ".", "any", "(", "test", ".", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_standard_datasets.test_adult": [[31, 38], ["aif360.datasets.AdultDataset", "numpy.isclose", "aif360.metrics.BinaryLabelDatasetMetric", "aif360.datasets.AdultDataset.labels.mean", "aif360.metrics.BinaryLabelDatasetMetric.num_instances"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "test_adult", "(", ")", ":", "\n", "    ", "ad", "=", "AdultDataset", "(", ")", "\n", "# print(ad.feature_names)", "\n", "assert", "np", ".", "isclose", "(", "ad", ".", "labels", ".", "mean", "(", ")", ",", "0.2478", ",", "atol", "=", "5e-5", ")", "\n", "\n", "bldm", "=", "BinaryLabelDatasetMetric", "(", "ad", ")", "\n", "assert", "bldm", ".", "num_instances", "(", ")", "==", "45222", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_standard_datasets.test_adult_no_drop": [[39, 45], ["aif360.datasets.AdultDataset", "aif360.metrics.BinaryLabelDatasetMetric", "aif360.metrics.BinaryLabelDatasetMetric.num_instances"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.num_instances"], ["", "def", "test_adult_no_drop", "(", ")", ":", "\n", "    ", "ad", "=", "AdultDataset", "(", "protected_attribute_names", "=", "[", "'sex'", "]", ",", "\n", "privileged_classes", "=", "[", "[", "'Male'", "]", "]", ",", "categorical_features", "=", "[", "]", ",", "\n", "features_to_keep", "=", "[", "'age'", ",", "'education-num'", "]", ")", "\n", "bldm", "=", "BinaryLabelDatasetMetric", "(", "ad", ")", "\n", "assert", "bldm", ".", "num_instances", "(", ")", "==", "48842", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_demo_optim_data_preproc.test_optim_preproc": [[8, 18], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_optim_preproc", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'examples'", ",", "'demo_optim_data_preproc.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_demo_mdss_classifier_metric.test_demo_mdss_classifier_metric": [[4, 15], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_demo_mdss_classifier_metric", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'examples'", ",", "\n", "'demo_mdss_classifier_metric.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_demo_reject_option_classification.test_reject_option_classification": [[8, 18], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_reject_option_classification", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'examples'", ",", "'demo_reject_option_classification.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_eq_odds_postprocessing.test_eqodds": [[22, 32], ["aif360.algorithms.postprocessing.EqOddsPostprocessing", "aif360.algorithms.postprocessing.EqOddsPostprocessing.fit().predict", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.average_abs_odds_difference", "aif360.algorithms.postprocessing.EqOddsPostprocessing.fit", "cm_lr.accuracy", "cm_lr.accuracy", "aif360.metrics.ClassificationMetric.accuracy"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.average_abs_odds_difference", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy"], ["def", "test_eqodds", "(", ")", ":", "\n", "    ", "eqo", "=", "EqOddsPostprocessing", "(", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ",", "seed", "=", "1234567", ")", "\n", "pred_eqo", "=", "eqo", ".", "fit", "(", "val", ",", "val_pred", ")", ".", "predict", "(", "pred", ")", "\n", "cm_eqo", "=", "ClassificationMetric", "(", "test", ",", "pred_eqo", ",", "\n", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ")", "\n", "# accuracy drop should be less than 10% (arbitrary)", "\n", "assert", "(", "cm_lr", ".", "accuracy", "(", ")", "-", "cm_eqo", ".", "accuracy", "(", ")", ")", "/", "cm_lr", ".", "accuracy", "(", ")", "<", "0.1", "\n", "# approximately equal odds", "\n", "assert", "cm_eqo", ".", "average_abs_odds_difference", "(", ")", "<", "0.1", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_eq_odds_postprocessing.test_caleq": [[33, 45], ["aif360.algorithms.postprocessing.CalibratedEqOddsPostprocessing", "aif360.algorithms.postprocessing.CalibratedEqOddsPostprocessing.fit().predict", "aif360.metrics.ClassificationMetric", "abs", "aif360.algorithms.postprocessing.CalibratedEqOddsPostprocessing.fit", "cm_lr.accuracy", "aif360.metrics.ClassificationMetric.difference", "cm_lr.accuracy", "aif360.metrics.ClassificationMetric.accuracy"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy", "home.repos.pwc.inspect_result.IBM_AIF360.metrics.dataset_metric.DatasetMetric.difference", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.accuracy"], ["", "def", "test_caleq", "(", ")", ":", "\n", "    ", "ceo", "=", "CalibratedEqOddsPostprocessing", "(", "cost_constraint", "=", "'fnr'", ",", "\n", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ",", "seed", "=", "1234567", ")", "\n", "pred_ceo", "=", "ceo", ".", "fit", "(", "val", ",", "val_pred", ")", ".", "predict", "(", "pred", ")", "\n", "\n", "cm_ceo", "=", "ClassificationMetric", "(", "test", ",", "pred_ceo", ",", "\n", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", ",", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", ")", "\n", "# accuracy drop should be less than 10% (arbitrary)", "\n", "assert", "(", "cm_lr", ".", "accuracy", "(", ")", "-", "cm_ceo", ".", "accuracy", "(", ")", ")", "/", "cm_lr", ".", "accuracy", "(", ")", "<", "0.1", "\n", "# approximate GFNR parity", "\n", "assert", "abs", "(", "cm_ceo", ".", "difference", "(", "cm_ceo", ".", "generalized_false_negative_rate", ")", ")", "<", "0.1", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_meta_classifier.test_adult_sr": [[15, 36], ["aif360.algorithms.inprocessing.MetaFairClassifier().fit", "MetaFairClassifier().fit.predict", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.disparate_impact", "min", "aif360.algorithms.inprocessing.MetaFairClassifier().fit", "MetaFairClassifier().fit.predict", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.disparate_impact", "min", "aif360.algorithms.inprocessing.MetaFairClassifier", "aif360.algorithms.inprocessing.MetaFairClassifier"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.disparate_impact"], ["def", "test_adult_sr", "(", ")", ":", "\n", "    ", "biased_model", "=", "MetaFairClassifier", "(", "tau", "=", "0", ",", "sensitive_attr", "=", "protected", ",", "\n", "type", "=", "'sr'", ",", "seed", "=", "123", ")", ".", "fit", "(", "train", ")", "\n", "dataset_bias_test", "=", "biased_model", ".", "predict", "(", "test", ")", "\n", "\n", "biased_cm", "=", "ClassificationMetric", "(", "test", ",", "dataset_bias_test", ",", "\n", "unprivileged_groups", "=", "[", "{", "protected", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "protected", ":", "1", "}", "]", ")", "\n", "spd1", "=", "biased_cm", ".", "disparate_impact", "(", ")", "\n", "spd1", "=", "min", "(", "spd1", ",", "1", "/", "spd1", ")", "\n", "\n", "debiased_model", "=", "MetaFairClassifier", "(", "tau", "=", "0.9", ",", "sensitive_attr", "=", "protected", ",", "\n", "type", "=", "'sr'", ",", "seed", "=", "123", ")", ".", "fit", "(", "train", ")", "\n", "dataset_debiasing_test", "=", "debiased_model", ".", "predict", "(", "test", ")", "\n", "\n", "debiased_cm", "=", "ClassificationMetric", "(", "test", ",", "dataset_debiasing_test", ",", "\n", "unprivileged_groups", "=", "[", "{", "protected", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "protected", ":", "1", "}", "]", ")", "\n", "spd2", "=", "debiased_cm", ".", "disparate_impact", "(", ")", "\n", "spd2", "=", "min", "(", "spd2", ",", "1", "/", "spd2", ")", "\n", "assert", "(", "spd2", ">=", "spd1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_meta_classifier.test_adult_fdr": [[37, 58], ["aif360.algorithms.inprocessing.MetaFairClassifier().fit", "MetaFairClassifier().fit.predict", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.false_discovery_rate_ratio", "min", "aif360.algorithms.inprocessing.MetaFairClassifier().fit", "MetaFairClassifier().fit.predict", "aif360.metrics.ClassificationMetric", "aif360.metrics.ClassificationMetric.false_discovery_rate_ratio", "min", "aif360.algorithms.inprocessing.MetaFairClassifier", "aif360.algorithms.inprocessing.MetaFairClassifier"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate_ratio", "home.repos.pwc.inspect_result.IBM_AIF360.lr.pr.LRwPRFittingType1Mixin.fit", "home.repos.pwc.inspect_result.IBM_AIF360.gerryfair.reg_oracle_class.LinearThresh.predict", "home.repos.pwc.inspect_result.IBM_AIF360.explainers.metric_text_explainer.MetricTextExplainer.false_discovery_rate_ratio"], ["", "def", "test_adult_fdr", "(", ")", ":", "\n", "    ", "biased_model", "=", "MetaFairClassifier", "(", "tau", "=", "0", ",", "sensitive_attr", "=", "protected", ",", "\n", "type", "=", "'fdr'", ",", "seed", "=", "123", ")", ".", "fit", "(", "train", ")", "\n", "dataset_bias_test", "=", "biased_model", ".", "predict", "(", "test", ")", "\n", "\n", "biased_cm", "=", "ClassificationMetric", "(", "test", ",", "dataset_bias_test", ",", "\n", "unprivileged_groups", "=", "[", "{", "protected", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "protected", ":", "1", "}", "]", ")", "\n", "fdr1", "=", "biased_cm", ".", "false_discovery_rate_ratio", "(", ")", "\n", "fdr1", "=", "min", "(", "fdr1", ",", "1", "/", "fdr1", ")", "\n", "\n", "debiased_model", "=", "MetaFairClassifier", "(", "tau", "=", "0.9", ",", "sensitive_attr", "=", "protected", ",", "\n", "type", "=", "'fdr'", ",", "seed", "=", "123", ")", ".", "fit", "(", "train", ")", "\n", "dataset_debiasing_test", "=", "debiased_model", ".", "predict", "(", "test", ")", "\n", "\n", "debiased_cm", "=", "ClassificationMetric", "(", "test", ",", "dataset_debiasing_test", ",", "\n", "unprivileged_groups", "=", "[", "{", "protected", ":", "0", "}", "]", ",", "\n", "privileged_groups", "=", "[", "{", "protected", ":", "1", "}", "]", ")", "\n", "fdr2", "=", "debiased_cm", ".", "false_discovery_rate_ratio", "(", ")", "\n", "fdr2", "=", "min", "(", "fdr2", ",", "1", "/", "fdr2", ")", "\n", "assert", "(", "fdr2", ">=", "fdr1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_gerryfair.test_gerryfair_classifier": [[5, 15], ["notebook_runner.notebook_run", "os.path.join", "len", "AssertionError", "os.path.dirname", "os.path.abspath", "print"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.tests.notebook_runner.notebook_run"], ["def", "test_gerryfair_classifier", "(", ")", ":", "\n", "    ", "nb", ",", "errors", "=", "notebook_run", "(", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "\n", "'..'", ",", "'examples'", ",", "'demo_short_gerryfair_test.ipynb'", ")", ")", "\n", "\n", "if", "len", "(", "errors", ")", ">", "0", ":", "\n", "        ", "for", "err", "in", "errors", ":", "\n", "            ", "for", "tbi", "in", "err", "[", "'traceback'", "]", ":", "\n", "                ", "print", "(", "tbi", ")", "\n", "", "", "raise", "AssertionError", "(", "\"errors in notebook testcases\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_AIF360.tests.test_reweighing.test_instance_weights": [[6, 15], ["aif360.datasets.AdultDataset", "aif360.algorithms.preprocessing.reweighing.Reweighing", "aif360.algorithms.preprocessing.reweighing.Reweighing.fit_transform", "print", "numpy.isclose", "rw.fit_transform.instance_weights.sum", "aif360.datasets.AdultDataset.instance_weights.sum", "rw.fit_transform.instance_weights.sum"], "function", ["home.repos.pwc.inspect_result.IBM_AIF360.preprocessing.fairadapt.FairAdapt.fit_transform"], ["def", "test_instance_weights", "(", ")", ":", "\n", "    ", "ad", "=", "AdultDataset", "(", "instance_weights_name", "=", "'fnlwgt'", ",", "features_to_drop", "=", "[", "]", ")", "\n", "privileged_groups", "=", "[", "{", "'sex'", ":", "1", "}", "]", "\n", "unprivileged_groups", "=", "[", "{", "'sex'", ":", "0", "}", "]", "\n", "rw", "=", "Reweighing", "(", "unprivileged_groups", "=", "unprivileged_groups", ",", "\n", "privileged_groups", "=", "privileged_groups", ")", "\n", "transf", "=", "rw", ".", "fit_transform", "(", "ad", ")", "\n", "print", "(", "transf", ".", "instance_weights", ".", "sum", "(", ")", ")", "\n", "assert", "np", ".", "isclose", "(", "ad", ".", "instance_weights", ".", "sum", "(", ")", ",", "transf", ".", "instance_weights", ".", "sum", "(", ")", ")", "\n", "", ""]]}