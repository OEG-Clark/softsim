{"home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_MDN.lstm_cell": [[15, 19], ["tensorflow.nn.rnn_cell.BasicLSTMCell", "tensorflow.nn.rnn_cell.DropoutWrapper"], "function", ["None"], ["def", "lstm_cell", "(", "lstm_size", ",", "keep_prob", ")", ":", "\n", "  ", "lstm", "=", "tf", ".", "nn", ".", "rnn_cell", ".", "BasicLSTMCell", "(", "lstm_size", ")", "\n", "drop", "=", "tf", ".", "nn", ".", "rnn_cell", ".", "DropoutWrapper", "(", "lstm", ",", "output_keep_prob", "=", "keep_prob", ")", "\n", "return", "drop", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_MDN.tf_2d_normal": [[21, 38], ["tensorflow.subtract", "tensorflow.subtract", "tensorflow.multiply", "tensorflow.exp", "tensorflow.div", "tensorflow.square", "tensorflow.div", "tensorflow.multiply", "tensorflow.square", "tensorflow.square", "tensorflow.div", "tensorflow.sqrt", "tensorflow.div", "tensorflow.div", "tensorflow.multiply", "tensorflow.multiply"], "function", ["None"], ["", "def", "tf_2d_normal", "(", "x1", ",", "x2", ",", "mu1", ",", "mu2", ",", "s1", ",", "s2", ",", "rho", ")", ":", "\n", "  ", "\"\"\" 2D normal distribution\n  input\n  - x,mu: input vectors\n  - s1,s2: standard deviances over x1 and x2\n  - rho: correlation coefficient in x1-x2 plane\n  \"\"\"", "\n", "# eq # 24 and 25 of http://arxiv.org/abs/1308.0850", "\n", "norm1", "=", "tf", ".", "subtract", "(", "x1", ",", "mu1", ")", "\n", "norm2", "=", "tf", ".", "subtract", "(", "x2", ",", "mu2", ")", "\n", "s1s2", "=", "tf", ".", "multiply", "(", "s1", ",", "s2", ")", "\n", "z", "=", "tf", ".", "square", "(", "tf", ".", "div", "(", "norm1", ",", "s1", ")", ")", "+", "tf", ".", "square", "(", "tf", ".", "div", "(", "norm2", ",", "s2", ")", ")", "-", "2.0", "*", "tf", ".", "div", "(", "tf", ".", "multiply", "(", "rho", ",", "tf", ".", "multiply", "(", "norm1", ",", "norm2", ")", ")", ",", "s1s2", ")", "\n", "negRho", "=", "1", "-", "tf", ".", "square", "(", "rho", ")", "\n", "result", "=", "tf", ".", "exp", "(", "tf", ".", "div", "(", "-", "1.0", "*", "z", ",", "2.0", "*", "negRho", ")", ")", "\n", "denom", "=", "2", "*", "np", ".", "pi", "*", "tf", ".", "multiply", "(", "s1s2", ",", "tf", ".", "sqrt", "(", "negRho", ")", ")", "\n", "px1x2", "=", "tf", ".", "div", "(", "result", ",", "denom", ")", "\n", "return", "px1x2", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_MDN.tf_1d_normal": [[39, 52], ["tensorflow.subtract", "tensorflow.square", "tensorflow.exp", "tensorflow.div", "tensorflow.div", "tensorflow.div"], "function", ["None"], ["", "def", "tf_1d_normal", "(", "x3", ",", "mu3", ",", "s3", ")", ":", "\n", "  ", "\"\"\" 3D normal distribution Under assumption that x3 is uncorrelated with x1 and x2\n  input\n  - x,mu: input vectors\n  - s1,s2,s3: standard deviances over x1 and x2 and x3\n  - rho: correlation coefficient in x1-x2 plane\n  \"\"\"", "\n", "norm3", "=", "tf", ".", "subtract", "(", "x3", ",", "mu3", ")", "\n", "z", "=", "tf", ".", "square", "(", "tf", ".", "div", "(", "norm3", ",", "s3", ")", ")", "\n", "result", "=", "tf", ".", "exp", "(", "tf", ".", "div", "(", "-", "z", ",", "2", ")", ")", "\n", "denom", "=", "2.0", "*", "np", ".", "pi", "*", "s3", "\n", "px3", "=", "tf", ".", "div", "(", "result", ",", "denom", ")", "#probability in x3 dimension", "\n", "return", "px3", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_MDN.plot_traj_MDN_mult": [[118, 213], ["sess.run", "matplotlib.figure", "plt.figure.add_subplot", "fig.add_subplot.plot", "fig.add_subplot.scatter", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.set_zlabel", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.meshgrid", "numpy.stack", "range", "numpy.stack", "numpy.dot", "print", "plt.figure.add_subplot", "numpy.meshgrid", "numpy.sum", "fig.add_subplot.contour", "matplotlib.clabel", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "plt.figure.add_subplot", "numpy.meshgrid", "numpy.sum", "fig.add_subplot.contour", "matplotlib.clabel", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "plt.figure.add_subplot", "numpy.meshgrid", "numpy.sum", "fig.add_subplot.contour", "matplotlib.clabel", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "numpy.random.randint", "numpy.zeros", "numpy.zeros", "numpy.square", "numpy.square", "numpy.square", "scipy.stats.multivariate_normal", "scipy.stats.multivariate_normal.pdf", "np.stack.append"], "function", ["None"], ["", "def", "plot_traj_MDN_mult", "(", "model", ",", "sess", ",", "val_dict", ",", "batch", ",", "sl_plot", "=", "5", ",", "ind", "=", "-", "1", ")", ":", "\n", "  ", "\"\"\"Plots the trajectory. At given time-stamp, it plots the probability distributions\n  of where the next point will be\n  THIS IS FOR MULTIPLE MIXTURES\n  input:\n  - sess: the TF session\n  - val_dict: a dictionary with which to evaluate the model\n  - batch: the batch X_val[some_indices] that you feed into val_dict.\n    we could also pick this from val-dict, but this workflow is cleaner\n  - sl_plot: the time-stamp where you'd like to visualize\n  - ind: some index into the batch. if -1, we'll pick a random one\"\"\"", "\n", "result", "=", "sess", ".", "run", "(", "[", "model", ".", "mu1", ",", "model", ".", "mu2", ",", "model", ".", "mu3", ",", "model", ".", "s1", ",", "model", ".", "s2", ",", "model", ".", "s3", ",", "model", ".", "rho", ",", "model", ".", "theta", "]", ",", "feed_dict", "=", "val_dict", ")", "\n", "batch_size", ",", "crd", ",", "seq_len", "=", "batch", ".", "shape", "\n", "assert", "ind", "<", "batch_size", ",", "'Your index is outside batch'", "\n", "assert", "sl_plot", "<", "seq_len", ",", "'Your sequence index is outside sequence'", "\n", "if", "ind", "==", "-", "1", ":", "ind", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "batch_size", ")", "\n", "delta", "=", "0.025", "#Grid size to evaluate the PDF", "\n", "width", "=", "1.0", "# how far to evaluate the pdf?", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "1", ",", "projection", "=", "'3d'", ")", "\n", "ax", ".", "plot", "(", "batch", "[", "ind", ",", "0", ",", ":", "]", ",", "batch", "[", "ind", ",", "1", ",", ":", "]", ",", "batch", "[", "ind", ",", "2", ",", ":", "]", ",", "'r'", ")", "\n", "ax", ".", "scatter", "(", "batch", "[", "ind", ",", "0", ",", "sl_plot", "]", ",", "batch", "[", "ind", ",", "1", ",", "sl_plot", "]", ",", "batch", "[", "ind", ",", "2", ",", "sl_plot", "]", ")", "\n", "ax", ".", "set_xlabel", "(", "'x coordinate'", ")", "\n", "ax", ".", "set_ylabel", "(", "'y coordinate'", ")", "\n", "ax", ".", "set_zlabel", "(", "'z coordinate'", ")", "\n", "\n", "\n", "# lower-case x1,x2,x3 are indezing the grid", "\n", "# upper-case X1,X2,X3 are coordinates in the mesh", "\n", "x1", "=", "np", ".", "arange", "(", "-", "width", ",", "width", "+", "0.1", ",", "delta", ")", "\n", "x2", "=", "np", ".", "arange", "(", "-", "width", ",", "width", "+", "0.2", ",", "delta", ")", "\n", "x3", "=", "np", ".", "arange", "(", "-", "width", ",", "width", "+", "0.3", ",", "delta", ")", "\n", "X1", ",", "X2", ",", "X3", "=", "np", ".", "meshgrid", "(", "x1", ",", "x2", ",", "x3", ",", "indexing", "=", "'ij'", ")", "\n", "XX", "=", "np", ".", "stack", "(", "(", "X1", ",", "X2", ",", "X3", ")", ",", "axis", "=", "3", ")", "\n", "\n", "PP", "=", "[", "]", "\n", "\n", "mixtures", "=", "result", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "for", "m", "in", "range", "(", "mixtures", ")", ":", "\n", "    ", "mean", "=", "np", ".", "zeros", "(", "(", "3", ")", ")", "\n", "mean", "[", "0", "]", "=", "result", "[", "0", "]", "[", "ind", ",", "m", ",", "sl_plot", "]", "\n", "mean", "[", "1", "]", "=", "result", "[", "1", "]", "[", "ind", ",", "m", ",", "sl_plot", "]", "\n", "mean", "[", "2", "]", "=", "result", "[", "2", "]", "[", "ind", ",", "m", ",", "sl_plot", "]", "\n", "cov", "=", "np", ".", "zeros", "(", "(", "3", ",", "3", ")", ")", "\n", "sigma1", "=", "result", "[", "3", "]", "[", "ind", ",", "m", ",", "sl_plot", "]", "\n", "sigma2", "=", "result", "[", "4", "]", "[", "ind", ",", "m", ",", "sl_plot", "]", "\n", "sigma3", "=", "result", "[", "5", "]", "[", "ind", ",", "m", ",", "sl_plot", "]", "\n", "sigma12", "=", "result", "[", "6", "]", "[", "ind", ",", "m", ",", "sl_plot", "]", "*", "sigma1", "*", "sigma2", "\n", "cov", "[", "0", ",", "0", "]", "=", "np", ".", "square", "(", "sigma1", ")", "\n", "cov", "[", "1", ",", "1", "]", "=", "np", ".", "square", "(", "sigma2", ")", "\n", "cov", "[", "2", ",", "2", "]", "=", "np", ".", "square", "(", "sigma3", ")", "\n", "cov", "[", "1", ",", "2", "]", "=", "sigma12", "\n", "cov", "[", "2", ",", "1", "]", "=", "sigma12", "\n", "rv", "=", "multivariate_normal", "(", "mean", ",", "cov", ")", "\n", "P", "=", "rv", ".", "pdf", "(", "XX", ")", "#P is now in [x1,x2,x3]", "\n", "PP", ".", "append", "(", "P", ")", "\n", "# PP is now a list", "\n", "", "PP", "=", "np", ".", "stack", "(", "PP", ",", "axis", "=", "3", ")", "\n", "# PP is now in [x1,x2,x3,mixtures]", "\n", "#Multiply with the mixture", "\n", "theta_local", "=", "result", "[", "7", "]", "[", "ind", ",", ":", ",", "sl_plot", "]", "\n", "ZZ", "=", "np", ".", "dot", "(", "PP", ",", "theta_local", ")", "\n", "#ZZ is now in [x1,x2,x3]", "\n", "\n", "print", "(", "'The theta variables %s'", "%", "theta_local", ")", "\n", "\n", "\n", "#Every Z is a marginalization of ZZ.", "\n", "# summing over axis 2, gives the pdf over x1,x2", "\n", "# summing over axis 1, gives the pdf over x1,x3", "\n", "# summing over axis 0, gives the pdf over x2,x3", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "2", ")", "\n", "X1", ",", "X2", "=", "np", ".", "meshgrid", "(", "x1", ",", "x2", ")", "\n", "Z", "=", "np", ".", "sum", "(", "ZZ", ",", "axis", "=", "2", ")", "\n", "CS", "=", "ax", ".", "contour", "(", "X1", ",", "X2", ",", "Z", ".", "T", ")", "\n", "plt", ".", "clabel", "(", "CS", ",", "inline", "=", "1", ",", "fontsize", "=", "10", ")", "\n", "ax", ".", "set_xlabel", "(", "'x coordinate'", ")", "\n", "ax", ".", "set_ylabel", "(", "'y coordinate'", ")", "\n", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "3", ")", "\n", "X1", ",", "X3", "=", "np", ".", "meshgrid", "(", "x1", ",", "x3", ")", "\n", "Z", "=", "np", ".", "sum", "(", "ZZ", ",", "axis", "=", "1", ")", "\n", "CS", "=", "ax", ".", "contour", "(", "X1", ",", "X3", ",", "Z", ".", "T", ")", "\n", "plt", ".", "clabel", "(", "CS", ",", "inline", "=", "1", ",", "fontsize", "=", "10", ")", "\n", "ax", ".", "set_xlabel", "(", "'x coordinate'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Z coordinate'", ")", "\n", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "4", ")", "\n", "X2", ",", "X3", "=", "np", ".", "meshgrid", "(", "x2", ",", "x3", ")", "\n", "Z", "=", "np", ".", "sum", "(", "ZZ", ",", "axis", "=", "0", ")", "\n", "CS", "=", "ax", ".", "contour", "(", "X2", ",", "X3", ",", "Z", ".", "T", ")", "\n", "plt", ".", "clabel", "(", "CS", ",", "inline", "=", "1", ",", "fontsize", "=", "10", ")", "\n", "ax", ".", "set_xlabel", "(", "'y coordinate'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Z coordinate'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_basket.plot_basket": [[14, 62], ["matplotlib.figure", "plt.figure.gca", "numpy.random.permutation", "fig.gca.get_legend_handles_labels", "zip", "fig.gca.legend", "matplotlib.title", "matplotlib.show", "numpy.transpose", "print", "fig.gca.plot", "newLabels.append", "newHandles.append", "fig.gca.plot", "fig.gca.plot", "fig.gca.plot"], "function", ["None"], ["def", "plot_basket", "(", "data", ",", "labels", ",", "extra_title", "=", "' '", ")", ":", "\n", "    ", "\"\"\"Utility function to plot XYZ trajectories of the basketbal data\n    Input:\n    - data: takes any 3D array, the first three indices of the second dimension must correspond to X, Y and Z\n    - labels: the correct (binary) labels for the sequences. Same size as first dimension of data\n    - extra_title: string to append to the title\n    Output\n    - Plots =)\n    #Credits for this code go to\n# http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html\n    mpl.rcParams['legend.fontsize'] = 10\n    \"\"\"", "\n", "\n", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "gca", "(", "projection", "=", "'3d'", ")", "\n", "\n", "N", ",", "crd", ",", "sl", "=", "data", ".", "shape", "\n", "if", "crd", ">", "sl", ":", "\n", "      ", "data", "=", "np", ".", "transpose", "(", "data", ",", "[", "0", ",", "2", ",", "1", "]", ")", "\n", "print", "(", "'We transpose dimension 1 and 2'", ")", "\n", "\n", "", "P", "=", "100", "#How many lines you want?", "\n", "ind", "=", "np", ".", "random", ".", "permutation", "(", "N", ")", "\n", "\n", "for", "p", "in", "ind", "[", ":", "P", "]", ":", "\n", "        ", "if", "labels", "[", "p", "]", "==", "1", ":", "\n", "            ", "ax", ".", "plot", "(", "data", "[", "p", ",", "0", ",", ":", "]", ",", "data", "[", "p", ",", "1", ",", ":", "]", ",", "data", "[", "p", ",", "2", ",", ":", "]", ",", "'r'", ",", "label", "=", "'miss'", ")", "\n", "", "elif", "labels", "[", "p", "]", "==", "0", ":", "\n", "            ", "ax", ".", "plot", "(", "data", "[", "p", ",", "0", ",", ":", "]", ",", "data", "[", "p", ",", "1", ",", ":", "]", ",", "data", "[", "p", ",", "2", ",", ":", "]", ",", "'b'", ",", "label", "=", "'hit'", ")", "\n", "\n", "", "elif", "labels", "[", "p", "]", "==", "2", ":", "\n", "            ", "ax", ".", "plot", "(", "data", "[", "p", ",", "0", ",", ":", "]", ",", "data", "[", "p", ",", "1", ",", ":", "]", ",", "data", "[", "p", ",", "2", ",", ":", "]", ",", "'c'", ",", "label", "=", "'lc hit'", ")", "\n", "\n", "", "elif", "labels", "[", "p", "]", "==", "3", ":", "\n", "            ", "ax", ".", "plot", "(", "data", "[", "p", ",", "0", ",", ":", "]", ",", "data", "[", "p", ",", "1", ",", ":", "]", ",", "data", "[", "p", ",", "2", ",", ":", "]", ",", "'m'", ",", "label", "=", "'lc miss'", ")", "\n", "\n", "#Next lines serve to only plot one legend per label", "\n", "", "", "handles", ",", "labels", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "newLabels", ",", "newHandles", "=", "[", "]", ",", "[", "]", "\n", "for", "handle", ",", "label", "in", "zip", "(", "handles", ",", "labels", ")", ":", "\n", "      ", "if", "label", "not", "in", "newLabels", ":", "\n", "        ", "newLabels", ".", "append", "(", "label", ")", "\n", "newHandles", ".", "append", "(", "handle", ")", "\n", "", "", "ax", ".", "legend", "(", "newHandles", ",", "newLabels", ")", "\n", "plt", ".", "title", "(", "'Blue=hit, red=miss '", "+", "extra_title", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_basket.shuffle_basket": [[63, 85], ["X.copy.copy", "X[].copy", "numpy.random.shuffle", "X[].copy", "numpy.random.shuffle"], "function", ["None"], ["", "def", "shuffle_basket", "(", "X", ",", "order", ",", "ind", ")", ":", "\n", "    ", "\"\"\"Function in order to calculate variable importance during session\n    The function takes in\n    - X, the data. Expected a 3D Tensor of N x crd x sl\n     - N = number of samples\n     - crd = how many coordinates we have\n     - sl = sequence length\n    - order, the kind of variable we check\n     - 'crd' we will random shuffle different coordinates\n     - 'sl' we will random shuffle different sequence indices\n    - ind specifies the exact index along order to shuffle\n    \"\"\"", "\n", "X", "=", "X", ".", "copy", "(", ")", "\n", "if", "order", "==", "'crd'", ":", "\n", "        ", "extract", "=", "X", "[", ":", ",", "ind", ",", ":", "]", ".", "copy", "(", ")", "#Extracted 2D tensor N x sl", "\n", "np", ".", "random", ".", "shuffle", "(", "extract", ")", "\n", "X", "[", ":", ",", "ind", ",", ":", "]", "=", "extract", "\n", "", "elif", "order", "==", "'sl'", ":", "\n", "        ", "extract", "=", "X", "[", ":", ",", ":", ",", "ind", "]", ".", "copy", "(", ")", "#Extracted 2D tensor N x sl", "\n", "np", ".", "random", ".", "shuffle", "(", "extract", ")", "\n", "X", "[", ":", ",", ":", ",", "ind", "]", "=", "extract", "\n", "", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_basket.plot_vi": [[86, 114], ["matplotlib.subplots", "axarr[].bar", "axarr[].set_title", "axarr[].axis", "axarr[].bar", "axarr[].set_title", "axarr[].axis", "xrange", "xrange", "axarr[].bar", "axarr[].set_title", "axarr[].axis", "axarr[].bar", "axarr[].set_title", "axarr[].axis", "xrange", "xrange"], "function", ["None"], ["", "def", "plot_vi", "(", "vi_crd", ",", "vi_sl", ")", ":", "\n", "# Four axes, returned as a 2-d array", "\n", "    ", "D", "=", "vi_crd", ".", "shape", "[", "1", "]", "\n", "#Make color array to color baseline different", "\n", "color", "=", "[", "'b'", "]", "*", "(", "D", ")", "\n", "color", "[", "D", "-", "1", "]", "=", "'r'", "\n", "\n", "## TODO For now, the axes are defined with numerics, in future we might add", "\n", "# a better heuristic here", "\n", "f", ",", "axarr", "=", "plt", ".", "subplots", "(", "2", ",", "2", ")", "\n", "axarr", "[", "0", ",", "0", "]", ".", "bar", "(", "xrange", "(", "D", ")", ",", "vi_crd", "[", "0", "]", ",", "color", "=", "color", ")", "\n", "axarr", "[", "0", ",", "0", "]", ".", "set_title", "(", "'Accuracy - crd'", ")", "\n", "axarr", "[", "0", ",", "0", "]", ".", "axis", "(", "[", "0", ",", "D", ",", "0.6", ",", "1.0", "]", ")", "\n", "axarr", "[", "0", ",", "1", "]", ".", "bar", "(", "xrange", "(", "D", ")", ",", "vi_crd", "[", "1", "]", ",", "color", "=", "color", ")", "\n", "axarr", "[", "0", ",", "1", "]", ".", "set_title", "(", "'Cost - crd'", ")", "\n", "axarr", "[", "0", ",", "1", "]", ".", "axis", "(", "[", "0", ",", "D", ",", "0.3", ",", "1.0", "]", ")", "\n", "if", "vi_sl", "is", "not", "None", ":", "\n", "# Four axes, returned as a 2-d array", "\n", "        ", "D", "=", "vi_sl", ".", "shape", "[", "1", "]", "\n", "#Make color array to color baseline different", "\n", "color", "=", "[", "'b'", "]", "*", "(", "D", ")", "\n", "color", "[", "D", "-", "1", "]", "=", "'r'", "\n", "axarr", "[", "1", ",", "0", "]", ".", "bar", "(", "xrange", "(", "D", ")", ",", "vi_sl", "[", "0", "]", ",", "color", "=", "color", ")", "\n", "axarr", "[", "1", ",", "0", "]", ".", "set_title", "(", "'Accuracy - sl'", ")", "\n", "axarr", "[", "1", ",", "0", "]", ".", "axis", "(", "[", "0", ",", "D", ",", "0.6", ",", "1.0", "]", ")", "\n", "axarr", "[", "1", ",", "1", "]", ".", "bar", "(", "xrange", "(", "D", ")", ",", "vi_sl", "[", "1", "]", ",", "color", "=", "color", ")", "\n", "axarr", "[", "1", ",", "1", "]", ".", "set_title", "(", "'Cost - sl'", ")", "\n", "axarr", "[", "1", ",", "1", "]", ".", "axis", "(", "[", "0", ",", "D", ",", "0.3", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_basket.conf_ind": [[119, 166], ["len", "y_val.astype", "numpy.zeros", "numpy.zeros", "np.zeros.astype", "np.zeros.astype", "numpy.argsort", "numpy.argsort"], "function", ["None"], ["", "", "def", "conf_ind", "(", "conf_correct", ",", "y_val", ",", "am", ",", "which_conf", ")", ":", "\n", "    ", "\"\"\"Computes indices per class for which we have highest confidence\n    Input arguments\n    - conf_correct: Confidence at the correct target. That is the probability that the Softmax classifiers outputs at thus sample\n    - y_val the true labels\n    - am: how many indices per class you want?\n    - which_conf: string label for which confidence you want?\n    -- hc for high confidence\n    -- lc for low confidence\n    returns\n    - conf_pos: indices at pos class for which we have high confidence\n    - hc_ned: indices at nex class for which we have high confidence\n    \n    Note that this function only works for binary classes\n    \"\"\"", "\n", "N", "=", "len", "(", "y_val", ")", "#How many samples we got?  ", "\n", "\n", "\n", "if", "which_conf", "==", "'hc'", ":", "\n", "      ", "conf_ind", "=", "np", ".", "argsort", "(", "conf_correct", ")", "[", ":", ":", "-", "1", "]", "#indices for which we have the highest confidence. ", "\n", "# descending order, becase we are interested in high confidence", "\n", "count", "=", "0", "\n", "", "elif", "which_conf", "==", "'lc'", ":", "\n", "      ", "conf_ind", "=", "np", ".", "argsort", "(", "conf_correct", ")", "\n", "count", "=", "0", "\n", "#We only want indices for which the confidence is at least 0.5", "\n", "while", "conf_correct", "[", "conf_ind", "[", "count", "]", "]", "<", "0.5", ":", "\n", "        ", "count", "+=", "1", "\n", "", "", "y_val", ".", "astype", "(", "int", ")", "#change so that we can use it for indexing", "\n", "\n", "#Set up some variables", "\n", "conf_pos", "=", "np", ".", "zeros", "(", "(", "am", ")", ")", "\n", "ipos", "=", "0", "\n", "conf_neg", "=", "np", ".", "zeros", "(", "(", "am", ")", ")", "\n", "ineg", "=", "0", "\n", "\n", "\n", "while", "count", "<", "N", ":", "#while we're still in the array", "\n", "        ", "if", "ipos", "<", "am", "and", "y_val", "[", "conf_ind", "[", "count", "]", "]", "==", "0", ":", "\n", "#positive sample", "\n", "            ", "conf_pos", "[", "ipos", "]", "=", "conf_ind", "[", "count", "]", "\n", "ipos", "+=", "1", "\n", "", "if", "ineg", "<", "am", "and", "y_val", "[", "conf_ind", "[", "count", "]", "]", "==", "1", ":", "\n", "            ", "conf_neg", "[", "ineg", "]", "=", "conf_ind", "[", "count", "]", "\n", "ineg", "+=", "1", "\n", "", "count", "+=", "1", "\n", "", "return", "conf_pos", ".", "astype", "(", "int", ")", ",", "conf_neg", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_basket.plot_grad": [[169, 203], ["matplotlib.figure", "plt.figure.gca", "numpy.min", "numpy.random.permutation", "matplotlib.title", "print", "matplotlib.show", "len", "numpy.squeeze", "fig.gca.plot", "numpy.linalg.norm", "fig.gca.quiver", "fig.gca.plot", "fig.gca.quiver"], "function", ["None"], ["", "def", "plot_grad", "(", "data", ",", "labels", ",", "grad", ")", ":", "\n", "    ", "\"\"\" Plots the gradient over the input trajectory wrt the cross-entropy cost\n    Input:\n    - data: the 3D Tensor containing the original trajectories. The first three indices\n    of the second dimension must correspond to X Y and Z\n    - labels: the corresponding target labels\n    - grad: The gradient over the trajectory. Due to Tensorflow's default for 4D Tensors,\n    also this input can be four dimensional\n    Output\n    - Plots =)\n    \"\"\"", "\n", "if", "len", "(", "grad", ".", "shape", ")", "==", "4", ":", "#remove the fourth dimension. SHould be empty", "\n", "      ", "grad", "=", "np", ".", "squeeze", "(", "grad", ",", "axis", "=", "3", ")", "\n", "\n", "", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "gca", "(", "projection", "=", "'3d'", ")", "\n", "\n", "N", "=", "data", ".", "shape", "[", "0", "]", "\n", "\n", "P", "=", "np", ".", "min", "(", "(", "100", ",", "N", ")", ")", "#How many lines you want?", "\n", "ind", "=", "np", ".", "random", ".", "permutation", "(", "N", ")", "\n", "\n", "for", "p", "in", "ind", "[", ":", "P", "]", ":", "\n", "        ", "if", "labels", "[", "p", "]", "==", "1", ":", "\n", "            ", "ax", ".", "plot", "(", "data", "[", "p", ",", "0", ",", ":", "]", ",", "data", "[", "p", ",", "1", ",", ":", "]", ",", "data", "[", "p", ",", "2", ",", ":", "]", ",", "'r'", ",", "label", "=", "'miss'", ")", "\n", "length_quiver", "=", "np", ".", "linalg", ".", "norm", "(", "grad", "[", "p", ",", ":", "3", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "ax", ".", "quiver", "(", "data", "[", "p", ",", "0", ",", ":", "]", ",", "data", "[", "p", ",", "1", ",", ":", "]", ",", "data", "[", "p", ",", "2", ",", ":", "]", ",", "grad", "[", "p", ",", "0", ",", ":", "]", ",", "grad", "[", "p", ",", "1", ",", ":", "]", ",", "grad", "[", "p", ",", "2", ",", ":", "]", ",", "length", "=", "1.0", ",", "pivot", "=", "'middle'", ")", "\n", "", "else", ":", "\n", "            ", "ax", ".", "plot", "(", "data", "[", "p", ",", "0", ",", ":", "]", ",", "data", "[", "p", ",", "1", ",", ":", "]", ",", "data", "[", "p", ",", "2", ",", ":", "]", ",", "'b'", ",", "label", "=", "'hit'", ")", "\n", "ax", ".", "quiver", "(", "data", "[", "p", ",", "0", ",", ":", "]", ",", "data", "[", "p", ",", "1", ",", ":", "]", ",", "data", "[", "p", ",", "2", ",", ":", "]", ",", "grad", "[", "p", ",", "0", ",", ":", "]", ",", "grad", "[", "p", ",", "1", ",", ":", "]", ",", "grad", "[", "p", ",", "2", ",", ":", "]", ",", "length", "=", "1.0", ",", "pivot", "=", "'middle'", ")", "\n", "\n", "", "", "plt", ".", "title", "(", "'Blue=hit, red=miss'", ")", "\n", "print", "(", "'Red lines are misses, blue lines are hits'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_basket.abs_to_off": [[204, 217], ["numpy.zeros_like", "len"], "function", ["None"], ["", "def", "abs_to_off", "(", "data", ")", ":", "\n", "  ", "\"\"\"Converts absolute data to offset data\n  Every first vector in the sequence is a zero vector\n  Input\n  - data in size [N by coordinates by sequence_length]\n  Output\n  - offset data in size [N by coordinates by sequence_length]\"\"\"", "\n", "assert", "len", "(", "data", ".", "shape", ")", "==", "3", ",", "'abs_to_off() expects three dimensional matrices'", "\n", "\n", "off", "=", "np", ".", "zeros_like", "(", "data", ")", "\n", "sl", "=", "data", ".", "shape", "[", "2", "]", "\n", "off", "[", ":", ",", ":", ",", "1", ":", "]", "=", "data", "[", ":", ",", ":", ",", "1", ":", "]", "-", "data", "[", ":", ",", ":", ",", ":", "sl", "-", "1", "]", "\n", "return", "off", "\n", "", ""]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.model.Model.__init__": [[25, 159], ["tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.summary.merge_all", "tensorflow.name_scope", "tensorflow.nn.rnn_cell.MultiRNNCell", "tensorflow.unstack", "tensorflow.contrib.rnn.static_rnn", "tensorflow.name_scope", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "tensorflow.reduce_mean", "tensorflow.summary.scalar", "tensorflow.name_scope", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.concat", "tensorflow.nn.xw_plus_b", "tensorflow.name_scope", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.subtract", "tensorflow.split", "tensorflow.split", "tensorflow.reduce_max", "tensorflow.subtract", "tensorflow.exp", "tensorflow.reciprocal", "tensorflow.multiply", "tensorflow.exp", "tensorflow.exp", "tensorflow.exp", "tensorflow.tanh", "util_MDN.tf_2d_normal", "util_MDN.tf_1d_normal", "tensorflow.multiply", "tensorflow.reduce_sum", "print", "tensorflow.reduce_mean", "tensorflow.name_scope", "tensorflow.trainable_variables", "tensorflow.gradients", "tensorflow.clip_by_global_norm", "tensorflow.Variable", "tensorflow.train.exponential_decay", "tensorflow.train.AdamOptimizer", "zip", "tensorflow.train.AdamOptimizer.apply_gradients", "tensorflow.constant", "tensorflow.name_scope", "tensorflow.equal", "tensorflow.reduce_mean", "tensorflow.summary.scalar", "tensorflow.random_normal", "tensorflow.constant", "tensorflow.matmul", "tensorflow.random_normal", "tensorflow.constant", "tensorflow.reduce_sum", "tensorflow.multiply", "tensorflow.log", "isinstance", "tensorflow.reduce_sum", "tensorflow.argmax", "tensorflow.cast", "util_MDN.lstm_cell", "tensorflow.maximum", "tensorflow.size", "range"], "methods", ["home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_MDN.tf_2d_normal", "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_MDN.tf_1d_normal", "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_MDN.lstm_cell"], ["  ", "def", "__init__", "(", "self", ",", "config", ")", ":", "\n", "    ", "\"\"\"Hyperparameters\"\"\"", "\n", "num_layers", "=", "config", "[", "'num_layers'", "]", "\n", "hidden_size", "=", "config", "[", "'hidden_size'", "]", "\n", "max_grad_norm", "=", "config", "[", "'max_grad_norm'", "]", "\n", "batch_size", "=", "config", "[", "'batch_size'", "]", "\n", "sl", "=", "config", "[", "'sl'", "]", "\n", "mixtures", "=", "config", "[", "'mixtures'", "]", "\n", "crd", "=", "config", "[", "'crd'", "]", "\n", "learning_rate", "=", "config", "[", "'learning_rate'", "]", "\n", "MDN", "=", "config", "[", "'MDN'", "]", "\n", "self", ".", "sl", "=", "sl", "\n", "self", ".", "crd", "=", "crd", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "# Nodes for the input variables", "\n", "self", ".", "x", "=", "tf", ".", "placeholder", "(", "dtype", "=", "tf", ".", "float32", ",", "shape", "=", "[", "batch_size", ",", "crd", ",", "sl", "]", ",", "name", "=", "'Input_data'", ")", "\n", "self", ".", "y_", "=", "tf", ".", "placeholder", "(", "tf", ".", "int64", ",", "shape", "=", "[", "batch_size", "]", ",", "name", "=", "'Ground_truth'", ")", "\n", "self", ".", "keep_prob", "=", "tf", ".", "placeholder", "(", "\"float\"", ")", "\n", "with", "tf", ".", "name_scope", "(", "\"LSTM\"", ")", "as", "scope", ":", "\n", "      ", "cell", "=", "tf", ".", "nn", ".", "rnn_cell", ".", "MultiRNNCell", "(", "[", "\n", "lstm_cell", "(", "hidden_size", ",", "self", ".", "keep_prob", ")", "for", "_", "in", "range", "(", "num_layers", ")", "\n", "]", ")", "\n", "\n", "inputs", "=", "tf", ".", "unstack", "(", "self", ".", "x", ",", "axis", "=", "2", ")", "\n", "# outputs, _ = tf.nn.rnn(cell, inputs, dtype=tf.float32)", "\n", "outputs", ",", "_", "=", "tf", ".", "contrib", ".", "rnn", ".", "static_rnn", "(", "cell", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "", "with", "tf", ".", "name_scope", "(", "\"SoftMax\"", ")", "as", "scope", ":", "\n", "      ", "final", "=", "outputs", "[", "-", "1", "]", "\n", "W_c", "=", "tf", ".", "Variable", "(", "tf", ".", "random_normal", "(", "[", "hidden_size", ",", "2", "]", ",", "stddev", "=", "0.01", ")", ")", "\n", "b_c", "=", "tf", ".", "Variable", "(", "tf", ".", "constant", "(", "0.1", ",", "shape", "=", "[", "2", "]", ")", ")", "\n", "self", ".", "h_c", "=", "tf", ".", "matmul", "(", "final", ",", "W_c", ")", "+", "b_c", "\n", "\n", "loss", "=", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "logits", "=", "self", ".", "h_c", ",", "labels", "=", "self", ".", "y_", ")", "\n", "self", ".", "cost", "=", "tf", ".", "reduce_mean", "(", "loss", ")", "\n", "loss_summ", "=", "tf", ".", "summary", ".", "scalar", "(", "\"cross entropy_loss\"", ",", "self", ".", "cost", ")", "\n", "\n", "", "with", "tf", ".", "name_scope", "(", "\"Output_MDN\"", ")", "as", "scope", ":", "\n", "      ", "params", "=", "8", "# 7+theta", "\n", "# Two for distribution over hit&miss, params for distribution parameters", "\n", "output_units", "=", "mixtures", "*", "params", "\n", "W_o", "=", "tf", ".", "Variable", "(", "tf", ".", "random_normal", "(", "\n", "[", "hidden_size", ",", "output_units", "]", ",", "stddev", "=", "0.01", ")", ")", "\n", "b_o", "=", "tf", ".", "Variable", "(", "tf", ".", "constant", "(", "0.5", ",", "shape", "=", "[", "output_units", "]", ")", ")", "\n", "# For comparison with XYZ, only up to last time_step", "\n", "# --> because for final time_step you cannot make a prediction", "\n", "output", "=", "outputs", "[", ":", "-", "1", "]", "\n", "outputs_tensor", "=", "tf", ".", "concat", "(", "output", ",", "axis", "=", "0", ")", "\n", "# is of size [batch_size*seq_len by output_units]", "\n", "h_out_tensor", "=", "tf", ".", "nn", ".", "xw_plus_b", "(", "outputs_tensor", ",", "W_o", ",", "b_o", ")", "\n", "\n", "", "with", "tf", ".", "name_scope", "(", "'MDN_over_next_vector'", ")", "as", "scope", ":", "\n", "# Next two lines are rather ugly, But its the most efficient way to", "\n", "# reshape the data", "\n", "      ", "h_xyz", "=", "tf", ".", "reshape", "(", "h_out_tensor", ",", "(", "sl", "-", "1", ",", "batch_size", ",", "output_units", ")", ")", "\n", "# transpose to [batch_size, output_units, sl-1]", "\n", "h_xyz", "=", "tf", ".", "transpose", "(", "h_xyz", ",", "[", "1", ",", "2", ",", "0", "]", ")", "\n", "# x_next = tf.slice(x,[0,0,1],[batch_size,3,sl-1])  #in size [batch_size,", "\n", "# output_units, sl-1]", "\n", "x_next", "=", "tf", ".", "subtract", "(", "self", ".", "x", "[", ":", ",", ":", "3", ",", "1", ":", "]", ",", "self", ".", "x", "[", ":", ",", ":", "3", ",", ":", "sl", "-", "1", "]", ")", "\n", "# From here any, many variables have size [batch_size, mixtures, sl-1]", "\n", "xn1", ",", "xn2", ",", "xn3", "=", "tf", ".", "split", "(", "value", "=", "x_next", ",", "num_or_size_splits", "=", "3", ",", "axis", "=", "1", ")", "\n", "self", ".", "mu1", ",", "self", ".", "mu2", ",", "self", ".", "mu3", ",", "self", ".", "s1", ",", "self", ".", "s2", ",", "self", ".", "s3", ",", "self", ".", "rho", ",", "self", ".", "theta", "=", "tf", ".", "split", "(", "value", "=", "h_xyz", ",", "num_or_size_splits", "=", "params", ",", "axis", "=", "1", ")", "\n", "\n", "# make the theta mixtures", "\n", "# softmax all the theta's:", "\n", "max_theta", "=", "tf", ".", "reduce_max", "(", "self", ".", "theta", ",", "1", ",", "keep_dims", "=", "True", ")", "\n", "self", ".", "theta", "=", "tf", ".", "subtract", "(", "self", ".", "theta", ",", "max_theta", ")", "\n", "self", ".", "theta", "=", "tf", ".", "exp", "(", "self", ".", "theta", ")", "\n", "normalize_theta", "=", "tf", ".", "reciprocal", "(", "tf", ".", "reduce_sum", "(", "self", ".", "theta", ",", "1", ",", "keep_dims", "=", "True", ")", ")", "\n", "self", ".", "theta", "=", "tf", ".", "multiply", "(", "normalize_theta", ",", "self", ".", "theta", ")", "\n", "\n", "# Deviances are non-negative and tho between -1 and 1", "\n", "self", ".", "s1", "=", "tf", ".", "exp", "(", "self", ".", "s1", ")", "\n", "self", ".", "s2", "=", "tf", ".", "exp", "(", "self", ".", "s2", ")", "\n", "self", ".", "s3", "=", "tf", ".", "exp", "(", "self", ".", "s3", ")", "\n", "self", ".", "rho", "=", "tf", ".", "tanh", "(", "self", ".", "rho", ")", "\n", "\n", "# probability in x1x2 plane", "\n", "px1x2", "=", "tf_2d_normal", "(", "xn1", ",", "xn2", ",", "self", ".", "mu1", ",", "self", ".", "mu2", ",", "\n", "self", ".", "s1", ",", "self", ".", "s2", ",", "self", ".", "rho", ")", "\n", "px3", "=", "tf_1d_normal", "(", "xn3", ",", "self", ".", "mu3", ",", "self", ".", "s3", ")", "\n", "px1x2x3", "=", "tf", ".", "multiply", "(", "px1x2", ",", "px3", ")", "\n", "\n", "# Sum along the mixtures in dimension 1", "\n", "px1x2x3_mixed", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "px1x2x3", ",", "self", ".", "theta", ")", ",", "1", ")", "\n", "print", "(", "'You are using %.0f mixtures'", "%", "mixtures", ")", "\n", "# at the beginning, some errors are exactly zero.", "\n", "loss_seq", "=", "-", "tf", ".", "log", "(", "tf", ".", "maximum", "(", "px1x2x3_mixed", ",", "1e-20", ")", ")", "\n", "self", ".", "cost_seq", "=", "tf", ".", "reduce_mean", "(", "loss_seq", ")", "\n", "self", ".", "cost_comb", "=", "self", ".", "cost", "\n", "if", "MDN", ":", "\n", "# The magic line where both heads come together.", "\n", "        ", "self", ".", "cost_comb", "+=", "self", ".", "cost_seq", "\n", "\n", "", "", "with", "tf", ".", "name_scope", "(", "\"train\"", ")", "as", "scope", ":", "\n", "      ", "tvars", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "# We clip the gradients to prevent explosion", "\n", "grads", "=", "tf", ".", "gradients", "(", "self", ".", "cost_comb", ",", "tvars", ")", "\n", "grads", ",", "_", "=", "tf", ".", "clip_by_global_norm", "(", "grads", ",", "0.5", ")", "\n", "\n", "# Some decay on the learning rate", "\n", "global_step", "=", "tf", ".", "Variable", "(", "0", ",", "trainable", "=", "False", ")", "\n", "lr", "=", "tf", ".", "train", ".", "exponential_decay", "(", "\n", "learning_rate", ",", "global_step", ",", "14000", ",", "0.95", ",", "staircase", "=", "True", ")", "\n", "optimizer", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "lr", ")", "\n", "gradients", "=", "zip", "(", "grads", ",", "tvars", ")", "\n", "self", ".", "train_step", "=", "optimizer", ".", "apply_gradients", "(", "\n", "gradients", ",", "global_step", "=", "global_step", ")", "\n", "# The following block plots for every trainable variable", "\n", "#  - Histogram of the entries of the Tensor", "\n", "#  - Histogram of the gradient over the Tensor", "\n", "#  - Histogram of the grradient-norm over the Tensor", "\n", "self", ".", "numel", "=", "tf", ".", "constant", "(", "[", "[", "0", "]", "]", ")", "\n", "for", "gradient", ",", "variable", "in", "gradients", ":", "\n", "        ", "if", "isinstance", "(", "gradient", ",", "ops", ".", "IndexedSlices", ")", ":", "\n", "          ", "grad_values", "=", "gradient", ".", "values", "\n", "", "else", ":", "\n", "          ", "grad_values", "=", "gradient", "\n", "\n", "", "self", ".", "numel", "+=", "tf", ".", "reduce_sum", "(", "tf", ".", "size", "(", "variable", ")", ")", "\n", "#", "\n", "#        h1 = tf.histogram_summary(variable.name, variable)", "\n", "#        h2 = tf.histogram_summary(variable.name + \"/gradients\", grad_values)", "\n", "#        h3 = tf.histogram_summary(variable.name + \"/gradient_norm\", clip_ops.global_norm([grad_values]))", "\n", "\n", "", "", "with", "tf", ".", "name_scope", "(", "\"Evaluating_accuracy\"", ")", "as", "scope", ":", "\n", "      ", "correct_prediction", "=", "tf", ".", "equal", "(", "tf", ".", "argmax", "(", "self", ".", "h_c", ",", "1", ")", ",", "self", ".", "y_", ")", "\n", "self", ".", "accuracy", "=", "tf", ".", "reduce_mean", "(", "tf", ".", "cast", "(", "correct_prediction", ",", "\"float\"", ")", ")", "\n", "accuracy_summary", "=", "tf", ".", "summary", ".", "scalar", "(", "\"accuracy\"", ",", "self", ".", "accuracy", ")", "\n", "\n", "# Define one op to call all summaries", "\n", "", "self", ".", "merged", "=", "tf", ".", "summary", ".", "merge_all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.model.Model.sample": [[160, 226], ["numpy.zeros", "numpy.zeros", "range", "matplotlib.figure", "matplotlib.figure", "matplotlib.figure.gca", "plt.figure.gca.plot", "plt.figure.gca.plot", "plt.figure.gca.set_xlabel", "plt.figure.gca.set_ylabel", "plt.figure.gca.set_zlabel", "numpy.random.rand", "len", "range", "print", "sess.run", "model.Model.sample.sample_theta"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "sess", ",", "seq", ",", "sl_pre", "=", "4", ",", "bias", "=", "0", ")", ":", "\n", "    ", "\"\"\"Continually samples from the MDN. The frist \"sl_pre\" samples\n    are taken from original data in seq\n    input\n    - sess: tf session\n    - seq: a sequence in [crd,sl]\n    - sl_pre: how many predefined sequence stamps to use?\"\"\"", "\n", "assert", "seq", ".", "shape", "[", "1", "]", "==", "self", ".", "sl", "and", "seq", ".", "shape", "[", "\n", "0", "]", "==", "self", ".", "crd", ",", "'Feed a sequence in [crd,sl]'", "\n", "assert", "sl_pre", ">", "1", ",", "'Please provide two predefined coordinates'", "\n", "\n", "def", "sample_theta", "(", "thetas", ")", ":", "\n", "      ", "stop", "=", "np", ".", "random", ".", "rand", "(", ")", "# random number to stop", "\n", "num_thetas", "=", "len", "(", "thetas", ")", "\n", "cum", "=", "0.0", "# cumulative probability", "\n", "for", "i", "in", "range", "(", "num_thetas", ")", ":", "\n", "        ", "cum", "+=", "thetas", "[", "i", "]", "\n", "if", "cum", ">", "stop", ":", "\n", "          ", "return", "i", "\n", "", "", "print", "(", "'No theta is drawn, ERROR'", ")", "\n", "return", "\n", "\n", "# Work around for tensor sizes, feed a tensor with zeros", "\n", "", "seq_feed", "=", "np", ".", "zeros", "(", "(", "self", ".", "batch_size", ",", "self", ".", "crd", ",", "self", ".", "sl", ")", ")", "\n", "seq_feed", "[", "0", ",", ":", ",", ":", "]", "=", "seq", "[", ":", ",", ":", "]", "\n", "offset_draw", "=", "np", ".", "zeros", "(", "(", "3", ")", ")", "# 3 coordinates", "\n", "# from the predefined sequences till end", "\n", "for", "sl_draw", "in", "range", "(", "sl_pre", ",", "self", ".", "sl", "-", "1", ")", ":", "\n", "      ", "feed_dict", "=", "{", "self", ".", "x", ":", "seq_feed", ",", "self", ".", "keep_prob", ":", "1.0", "}", "\n", "result", "=", "sess", ".", "run", "(", "[", "self", ".", "mu1", ",", "self", ".", "mu2", ",", "self", ".", "mu3", ",", "self", ".", "s1", ",", "\n", "self", ".", "s2", ",", "self", ".", "s3", ",", "self", ".", "rho", ",", "self", ".", "theta", "]", ",", "feed_dict", "=", "feed_dict", ")", "\n", "\n", "# Sample from theta", "\n", "idx_theta", "=", "sample_theta", "(", "result", "[", "7", "]", "[", "0", ",", ":", ",", "sl_pre", "]", ")", "\n", "\n", "# Collect two distributions to draw from", "\n", "#  One for XY plane", "\n", "#  One for Z plane", "\n", "mean", "=", "np", ".", "zeros", "(", "(", "3", ")", ")", "\n", "mean", "[", "0", "]", "=", "result", "[", "0", "]", "[", "0", ",", "idx_theta", ",", "sl_draw", "]", "\n", "mean", "[", "1", "]", "=", "result", "[", "1", "]", "[", "0", ",", "idx_theta", ",", "sl_draw", "]", "\n", "mean", "[", "2", "]", "=", "result", "[", "2", "]", "[", "0", ",", "idx_theta", ",", "sl_draw", "]", "\n", "cov", "=", "np", ".", "zeros", "(", "(", "3", ",", "3", ")", ")", "\n", "sigma1", "=", "np", ".", "exp", "(", "-", "1", "*", "bias", ")", "*", "result", "[", "3", "]", "[", "0", ",", "idx_theta", ",", "sl_draw", "]", "\n", "sigma2", "=", "np", ".", "exp", "(", "-", "1", "*", "bias", ")", "*", "result", "[", "4", "]", "[", "0", ",", "idx_theta", ",", "sl_draw", "]", "\n", "sigma3", "=", "np", ".", "exp", "(", "-", "1", "*", "bias", ")", "*", "result", "[", "5", "]", "[", "0", ",", "idx_theta", ",", "sl_draw", "]", "\n", "sigma12", "=", "result", "[", "6", "]", "[", "0", ",", "idx_theta", ",", "sl_draw", "]", "*", "sigma1", "*", "sigma2", "\n", "cov", "[", "0", ",", "0", "]", "=", "np", ".", "square", "(", "sigma1", ")", "\n", "cov", "[", "1", ",", "1", "]", "=", "np", ".", "square", "(", "sigma2", ")", "\n", "cov", "[", "2", ",", "2", "]", "=", "np", ".", "square", "(", "sigma3", ")", "\n", "cov", "[", "1", ",", "2", "]", "=", "sigma12", "\n", "cov", "[", "2", ",", "1", "]", "=", "sigma12", "\n", "rv", "=", "multivariate_normal", "(", "mean", ",", "cov", ")", "\n", "draw", "=", "rv", ".", "rvs", "(", ")", "\n", "offset_draw", "=", "draw", "\n", "seq_feed", "[", "0", ",", ":", "3", ",", "sl_draw", "+", "1", "]", "=", "seq_feed", "[", "0", ",", ":", "3", ",", "sl_draw", "]", "+", "offset_draw", "\n", "\n", "# Now draw some trajectories", "\n", "", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "gca", "(", "projection", "=", "'3d'", ")", "\n", "ax", ".", "plot", "(", "seq", "[", "0", ",", ":", "]", ",", "seq", "[", "1", ",", ":", "]", ",", "seq", "[", "2", ",", ":", "]", ",", "'r'", ")", "\n", "ax", ".", "plot", "(", "seq_feed", "[", "0", ",", "0", ",", ":", "]", ",", "seq_feed", "[", "0", ",", "1", ",", ":", "]", ",", "seq_feed", "[", "0", ",", "2", ",", ":", "]", ",", "'b'", ")", "\n", "ax", ".", "set_xlabel", "(", "'x coordinate'", ")", "\n", "ax", ".", "set_ylabel", "(", "'y coordinate'", ")", "\n", "ax", ".", "set_zlabel", "(", "'z coordinate'", ")", "\n", "return", "seq_feed", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.__init__": [[35, 54], ["numpy.array"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "direc", ",", "csv_file", ",", "center", "=", "np", ".", "array", "(", "[", "5.25", ",", "25.0", ",", "10.0", "]", ")", ")", ":", "\n", "    ", "\"\"\"Init the class\n    input:\n    - direc: the folder with the datafiles\n    - csv_file: the name of the csv file    \"\"\"", "\n", "assert", "direc", "[", "-", "1", "]", "==", "'/'", ",", "'Please provide a directory ending with a /'", "\n", "assert", "csv_file", "[", "-", "4", ":", "]", "==", "'.csv'", ",", "'Please provide a filename ending with .csv'", "\n", "self", ".", "center", "=", "center", "\n", "self", ".", "csv_loc", "=", "direc", "+", "csv_file", "#The location of the csv file", "\n", "self", ".", "data3", "=", "[", "]", "#the list where eventually will be all the data", "\n", "#After munging, the data3 will be in [n, seq_len, crd]", "\n", "self", ".", "labels", "=", "[", "]", "#the list where eventually will be all the data", "\n", "self", ".", "is_abs", "=", "True", "#Boolean to indicate if we have absolute data or offset data", "\n", "self", ".", "data", "=", "{", "}", "#Dictionary where the train and val date are located after split_train_test()", "\n", "#Count the epochs", "\n", "self", ".", "N", "=", "0", "\n", "self", ".", "iter_train", "=", "0", "\n", "self", ".", "epochs", "=", "0", "\n", "self", ".", "omit", "=", "0", "#A counter for how many sequences didn;t match criteria", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.munge_data": [[57, 116], ["float", "pandas.read_csv().sort_values", "pandas.read_csv().sort_values.as_matrix", "range", "print", "print", "print", "test.head", "print", "numpy.stack", "numpy.stack", "numpy.min", "len", "pandas.read_csv", "print", "int", "numpy.linalg.norm", "numpy.logical_and", "dataloader.return_large_true", "print", "numpy.sum", "dataloader.DataLoad.data3.append", "dataloader.DataLoad.labels.append", "numpy.min", "print", "float"], "methods", ["home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.return_large_true"], ["", "def", "munge_data", "(", "self", ",", "height", "=", "11.0", ",", "seq_len", "=", "10.0", ",", "dist", "=", "3.0", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "\"\"\"Function to munge the data\n    NOTE: this implementation assumes that the time is ticking down\n    input:\n    - height: the height to chop of data\n    - seq_len: how long sequences you want?\n    - verbose: boolean if you want to see some headers and other output\n    - dist: the minimum distance to the basket\"\"\"", "\n", "if", "self", ".", "data3", ":", "print", "(", "'You already have data in this instance. Are you calling function twice?'", ")", "\n", "\n", "if", "height", "<", "9.0", ":", "'Please note that height is measured from ground.'", "\n", "height", "=", "float", "(", "height", ")", "\n", "##Import data", "\n", "df", "=", "pd", ".", "read_csv", "(", "self", ".", "csv_loc", ")", ".", "sort_values", "(", "by", "=", "[", "'id'", ",", "'game_clock'", "]", ",", "ascending", "=", "[", "1", ",", "0", "]", ")", "\n", "if", "verbose", ":", "\n", "      ", "print", "(", "'The shape of the read data is '", ",", "df", ".", "shape", ")", "\n", "##To plot a single shot", "\n", "test", "=", "df", "[", "df", "[", "'id'", "]", "==", "\"0021500001_105\"", "]", "\n", "test", ".", "head", "(", "10", ")", "\n", "\n", "#Check is the datafram has the columns we want", "\n", "", "if", "not", "'x'", "and", "'y'", "and", "'z'", "and", "'game_clock'", "and", "'rankc'", "in", "df", ".", "columns", ":", "print", "(", "'We miss columns in the dataframe'", ")", "\n", "\n", "df_arr", "=", "df", ".", "as_matrix", "(", "[", "'x'", ",", "'y'", ",", "'z'", ",", "'game_clock'", ",", "'EVENTMSGTYPE'", ",", "'rankc'", "]", ")", "\n", "df", "=", "None", "\n", "#Note to Rajiv: from here I continue with NumPy.", "\n", "start_ind", "=", "0", "\n", "N", ",", "D", "=", "df_arr", ".", "shape", "\n", "for", "i", "in", "range", "(", "1", ",", "N", ",", "1", ")", ":", "\n", "      ", "if", "verbose", "and", "i", "%", "1000", "==", "0", ":", "print", "(", "'At line %5.0f of %5.0f'", "%", "(", "i", ",", "N", ")", ")", "\n", "if", "int", "(", "df_arr", "[", "i", ",", "5", "]", ")", "==", "1", ":", "\n", "        ", "end_ind", "=", "i", "#Note this represent the final index + 1", "\n", "\n", "#Now we have the start index and end index", "\n", "seq", "=", "df_arr", "[", "start_ind", ":", "end_ind", ",", ":", "4", "]", "\n", "dist_xyz", "=", "np", ".", "linalg", ".", "norm", "(", "seq", "[", ":", ",", ":", "3", "]", "-", "self", ".", "center", ",", "axis", "=", "1", ")", "\n", "ind_crit", "=", "np", ".", "logical_and", "(", "(", "seq", "[", ":", ",", "2", "]", ">", "height", ")", ",", "(", "dist_xyz", ">", "dist", ")", ")", "#Indices satisfying oru criteria", "\n", "if", "np", ".", "sum", "(", "ind_crit", ")", "==", "0", ":", "continue", "#No sequence satisfies the criteria for this i", "\n", "li", ",", "i", "=", "return_large_true", "(", "ind_crit", ")", "\n", "seq", "=", "seq", "[", "i", ":", "i", "+", "li", ",", ":", "]", "#Excludes rows where z coordinate is lower than \"height\"", "\n", "try", ":", "\n", "            ", "seq", "[", ":", ",", "3", "]", "=", "seq", "[", ":", ",", "3", "]", "-", "np", ".", "min", "(", "seq", "[", ":", ",", "3", "]", ")", "#    NOTE: this implementation assumes that the time is ticking down", "\n", "", "except", ":", "\n", "            ", "print", "(", "'A sequence didnt match criteria'", ")", "\n", "", "if", "seq", ".", "shape", "[", "0", "]", ">=", "seq_len", ":", "\n", "          ", "self", ".", "data3", ".", "append", "(", "seq", "[", "-", "seq_len", ":", "]", ")", "#Add the current sequence to the list", "\n", "self", ".", "labels", ".", "append", "(", "df_arr", "[", "start_ind", ",", "4", "]", ")", "\n", "", "else", ":", "\n", "          ", "self", ".", "omit", "+=", "1", "\n", "", "start_ind", "=", "end_ind", "\n", "", "", "try", ":", "\n", "      ", "self", ".", "data3", "=", "np", ".", "stack", "(", "self", ".", "data3", ",", "0", ")", "\n", "self", ".", "labels", "=", "np", ".", "stack", "(", "self", ".", "labels", ",", "0", ")", "\n", "if", "np", ".", "min", "(", "self", ".", "labels", ">", "0.9", ")", ":", "\n", "        ", "self", ".", "labels", "-=", "1", "\n", "", "self", ".", "N", "=", "len", "(", "self", ".", "labels", ")", "\n", "", "except", ":", "\n", "      ", "print", "(", "'Something went wrong when convert list to np array'", ")", "\n", "", "print", "(", "'In the munging, we lost %.0f sequences (%.2f) that didn;t match criteria'", "%", "(", "self", ".", "omit", ",", "float", "(", "self", ".", "omit", ")", "/", "self", ".", "N", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.entropy_offset": [[118, 127], ["numpy.reshape", "numpy.cov", "print", "print", "numpy.log", "numpy.power", "numpy.linalg.det"], "methods", ["None"], ["", "def", "entropy_offset", "(", "self", ")", ":", "\n", "    ", "\"\"\"Calculates the self entropy for all the offsets\"\"\"", "\n", "offset", "=", "self", ".", "data3", "[", ":", ",", "1", ":", ",", ":", "3", "]", "-", "self", ".", "data3", "[", ":", ",", ":", "-", "1", ",", ":", "3", "]", "\n", "offset", "=", "np", ".", "reshape", "(", "offset", ",", "(", "-", "1", ",", "3", ")", ")", "\n", "cov", "=", "np", ".", "cov", "(", "offset", ",", "rowvar", "=", "False", ")", "\n", "print", "(", "cov", ")", "\n", "ent", "=", "0.5", "*", "np", ".", "log", "(", "np", ".", "power", "(", "2", "*", "np", ".", "pi", "*", "np", ".", "e", ",", "3", ")", "*", "np", ".", "linalg", ".", "det", "(", "cov", ")", ")", "\n", "print", "(", "ent", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.center_data": [[129, 136], ["numpy.array", "isinstance", "print", "isinstance"], "methods", ["None"], ["", "def", "center_data", "(", "self", ",", "center_cent", "=", "np", ".", "array", "(", "[", "5.25", ",", "25.0", ",", "10.0", "]", ")", ")", ":", "\n", "    ", "assert", "not", "isinstance", "(", "self", ".", "data3", ",", "list", ")", ",", "'First munge the data before centering'", "\n", "assert", "isinstance", "(", "center_cent", ",", "np", ".", "ndarray", ")", ",", "'Please provide the center as a numpy array'", "\n", "self", ".", "data3", "[", ":", ",", ":", ",", ":", "3", "]", "=", "self", ".", "data3", "[", ":", ",", ":", ",", ":", "3", "]", "-", "center_cent", "\n", "self", ".", "center", "-=", "center_cent", "\n", "print", "(", "'New center'", ",", "self", ".", "center", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.abs_to_off": [[139, 148], ["numpy.expand_dims", "numpy.concatenate", "print", "isinstance"], "methods", ["None"], ["", "def", "abs_to_off", "(", "self", ")", ":", "\n", "    ", "assert", "self", ".", "is_abs", ",", "'Your data is already offset'", "\n", "assert", "not", "isinstance", "(", "self", ".", "data3", ",", "list", ")", ",", "'First munge the data before returning'", "\n", "off", "=", "self", ".", "data3", "[", ":", ",", "1", ":", ",", ":", "3", "]", "-", "self", ".", "data3", "[", ":", ",", ":", "-", "1", ",", ":", "3", "]", "\n", "time", "=", "np", ".", "expand_dims", "(", "self", ".", "data3", "[", ":", ",", "1", ":", ",", "3", "]", ",", "axis", "=", "2", ")", "\n", "self", ".", "data3", "=", "np", ".", "concatenate", "(", "(", "off", ",", "time", ")", ",", "axis", "=", "2", ")", "\n", "self", ".", "is_abs", "=", "False", "\n", "print", "(", "'Data is now offset data'", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.plot_basket_traj": [[149, 152], ["util_basket.plot_basket"], "methods", ["home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.util_basket.plot_basket"], ["", "def", "plot_basket_traj", "(", "self", ")", ":", "\n", "    ", "plot_basket", "(", "self", ".", "data3", ",", "self", ".", "labels", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.split_train_test": [[153, 170], ["int", "numpy.random.permutation", "print", "isinstance"], "methods", ["None"], ["", "def", "split_train_test", "(", "self", ",", "ratio", "=", "0.8", ")", ":", "\n", "    ", "assert", "not", "isinstance", "(", "self", ".", "data3", ",", "list", ")", ",", "'First munge the data before returning'", "\n", "N", ",", "seq_len", ",", "crd", "=", "self", ".", "data3", ".", "shape", "\n", "assert", "seq_len", ">", "1", ",", "'Seq_len appears to be singleton'", "\n", "assert", "ratio", "<", "1.0", ",", "'Provide ratio as a float between 0 and 1'", "\n", "#Split the data", "\n", "#Shuffle the data", "\n", "ind_cut", "=", "int", "(", "ratio", "*", "N", ")", "\n", "ind", "=", "np", ".", "random", ".", "permutation", "(", "N", ")", "\n", "\n", "self", ".", "data", "[", "'X_train'", "]", "=", "self", ".", "data3", "[", ":", "ind_cut", "]", "\n", "self", ".", "data", "[", "'y_train'", "]", "=", "self", ".", "labels", "[", ":", "ind_cut", "]", "\n", "self", ".", "data", "[", "'X_val'", "]", "=", "self", ".", "data3", "[", "ind_cut", ":", "]", "\n", "self", ".", "data", "[", "'y_val'", "]", "=", "self", ".", "labels", "[", "ind_cut", ":", "]", "\n", "print", "(", "'%.0f Train samples and %.0f val samples'", "%", "(", "ind_cut", ",", "N", "-", "ind_cut", ")", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.sample_batch": [[171, 195], ["numpy.random.choice", "range", "[].astype", "temp_dict.update", "temp_dict.update", "numpy.zeros", "range", "numpy.ones", "range"], "methods", ["None"], ["", "def", "sample_batch", "(", "self", ",", "inputs", ",", "result", ",", "mode", "=", "'train'", ",", "batch_size", "=", "64", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "\"\"\"Samples a batch from data. Mode indicates train or val \"\"\"", "\n", "assert", "mode", "in", "[", "'train'", ",", "'val'", "]", ",", "'Only val or train for sample_batch'", "\n", "N", ",", "sl", ",", "crd", "=", "self", ".", "data", "[", "'X_'", "+", "mode", "]", ".", "shape", "\n", "assert", "batch_size", "<", "N", ",", "'Batch size exceeds total size of X_'", "+", "mode", "\n", "ind", "=", "np", ".", "random", ".", "choice", "(", "N", ",", "batch_size", ",", "replace", "=", "False", ")", "\n", "feed_list", "=", "[", "]", "\n", "temp_dict", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "sl", ")", ":", "\n", "      ", "temp_dict", ".", "update", "(", "{", "inputs", "[", "i", "]", ":", "self", ".", "data", "[", "'X_'", "+", "mode", "]", "[", "ind", ",", "i", ",", ":", "4", "]", "}", ")", "\n", "", "labels_sub", "=", "self", ".", "data", "[", "'y_'", "+", "mode", "]", "[", "ind", "]", ".", "astype", "(", "int", ")", "\n", "\n", "reverse", "=", "False", "\n", "if", "not", "reverse", ":", "\n", "      ", "label_one_hot", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "2", ")", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "label_one_hot", "[", "i", ",", "labels_sub", "[", "i", "]", "]", "=", "1", "\n", "", "", "else", ":", "\n", "      ", "label_one_hot", "=", "np", ".", "ones", "(", "(", "batch_size", ",", "2", ")", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "label_one_hot", "[", "i", ",", "labels_sub", "[", "i", "]", "]", "=", "0", "\n", "\n", "", "", "temp_dict", ".", "update", "(", "{", "result", ":", "label_one_hot", "}", ")", "\n", "return", "temp_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.return_data_list": [[197, 224], ["int", "numpy.random.permutation", "print", "isinstance", "range", "listdata.append"], "methods", ["None"], ["", "def", "return_data_list", "(", "self", ",", "ratio", "=", "0.8", ",", "ret_list", "=", "True", ")", ":", "\n", "    ", "\"\"\"From data3 in [N,seq_len,crd] returns a list of [N,crd] with seq_len elements\n    \"\"\"", "\n", "assert", "not", "isinstance", "(", "self", ".", "data3", ",", "list", ")", ",", "'First munge the data before returning'", "\n", "N", ",", "seq_len", ",", "crd", "=", "self", ".", "data3", ".", "shape", "\n", "assert", "seq_len", ">", "1", ",", "'Seq_len appears to be singleton'", "\n", "assert", "ratio", "<", "1.0", ",", "'Provide ratio as a float between 0 and 1'", "\n", "\n", "data", "=", "{", "}", "#dictionary for the data", "\n", "\n", "#Split the data", "\n", "#Shuffle the data", "\n", "ind_cut", "=", "int", "(", "ratio", "*", "N", ")", "\n", "ind", "=", "np", ".", "random", ".", "permutation", "(", "N", ")", "\n", "data", "[", "'X_train'", "]", "=", "self", ".", "data3", "[", ":", "ind_cut", "]", "\n", "data", "[", "'X_val'", "]", "=", "self", ".", "data3", "[", "ind_cut", ":", "]", "\n", "data", "[", "'y_train'", "]", "=", "self", ".", "labels", "[", ":", "ind_cut", "]", "\n", "data", "[", "'y_val'", "]", "=", "self", ".", "labels", "[", "ind_cut", ":", "]", "\n", "if", "ret_list", ":", "#Do you want train data as list or 3D np array", "\n", "      ", "for", "key", "in", "[", "'X_train'", ",", "'X_val'", "]", ":", "\n", "        ", "listdata", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "seq_len", ")", ":", "\n", "          ", "listdata", ".", "append", "(", "data", "[", "key", "]", "[", ":", ",", "i", ",", ":", "]", ")", "\n", "", "data", "[", "key", "]", "=", "listdata", "\n", "", "", "print", "(", "'Returned data with center %s'", "%", "(", "self", ".", "center", ")", ")", "\n", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.plot_traj_2d": [[225, 250], ["matplotlib.figure", "numpy.linalg.norm", "numpy.dstack", "range", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.gca().get_legend_handles_labels", "zip", "matplotlib.legend", "matplotlib.show", "numpy.random.randint", "matplotlib.plot", "matplotlib.plot", "matplotlib.gca", "newLabels.append", "newHandles.append"], "methods", ["None"], ["", "def", "plot_traj_2d", "(", "self", ",", "Nplot", ",", "extra_title", "=", "' '", ")", ":", "\n", "    ", "\"\"\"Plots N trajectories in 2D plane. That is XY versus Z\n    N: the number of trajectories within the plot\"\"\"", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "\n", "data2", "=", "np", ".", "linalg", ".", "norm", "(", "self", ".", "data", "[", "'X_train'", "]", "[", ":", ",", ":", ",", ":", "2", "]", ",", "axis", "=", "2", ")", "\n", "data2", "=", "np", ".", "dstack", "(", "(", "data2", ",", "self", ".", "data", "[", "'X_train'", "]", "[", ":", ",", ":", ",", "2", "]", ")", ")", "\n", "N", "=", "data2", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "Nplot", ")", ":", "\n", "      ", "ind", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "N", ")", "\n", "if", "self", ".", "data", "[", "'y_train'", "]", "[", "ind", "]", "==", "1", ":", "\n", "        ", "plt", ".", "plot", "(", "data2", "[", "ind", ",", ":", ",", "0", "]", ",", "data2", "[", "ind", ",", ":", ",", "1", "]", ",", "'r'", ",", "label", "=", "'miss'", ")", "\n", "", "if", "self", ".", "data", "[", "'y_train'", "]", "[", "ind", "]", "==", "0", ":", "\n", "        ", "plt", ".", "plot", "(", "data2", "[", "ind", ",", ":", ",", "0", "]", ",", "data2", "[", "ind", ",", ":", ",", "1", "]", ",", "'b'", ",", "label", "=", "'hit'", ")", "\n", "", "", "plt", ".", "title", "(", "'Example trajectories '", "+", "extra_title", ")", "\n", "plt", ".", "xlabel", "(", "'Distance to basket (feet)'", ")", "\n", "plt", ".", "ylabel", "(", "'Height (feet)'", ")", "\n", "handles", ",", "labels", "=", "plt", ".", "gca", "(", ")", ".", "get_legend_handles_labels", "(", ")", "\n", "newLabels", ",", "newHandles", "=", "[", "]", ",", "[", "]", "\n", "for", "handle", ",", "label", "in", "zip", "(", "handles", ",", "labels", ")", ":", "\n", "      ", "if", "label", "not", "in", "newLabels", ":", "\n", "        ", "newLabels", ".", "append", "(", "label", ")", "\n", "newHandles", ".", "append", "(", "handle", ")", "\n", "", "", "plt", ".", "legend", "(", "newHandles", ",", "newLabels", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.DataLoad.export": [[252, 265], ["numpy.reshape", "numpy.savetxt", "print"], "methods", ["None"], ["", "def", "export", "(", "self", ",", "folder", ",", "filename", ")", ":", "\n", "    ", "\"\"\"Export the data3 for use in other classifiers or programs\n    input\n    - folder: folder name, ending with '/'\n    - filename: ending with .csv\n    output\n    - saves the data_windows to csv at specified context\"\"\"", "\n", "assert", "folder", "[", "-", "1", "]", "==", "'/'", ",", "'Please provide a folder ending with a /'", "\n", "assert", "filename", "[", "-", "4", ":", "]", "==", "'.csv'", ",", "'Please provide a filename ending with .csv'", "\n", "data", "=", "np", ".", "reshape", "(", "self", ".", "data3", ",", "(", "-", "1", ",", "4", ")", ")", "\n", "np", ".", "savetxt", "(", "folder", "+", "filename", ",", "data", ",", "delimiter", "=", "','", ")", "\n", "print", "(", "'Data is saved to %s, with %.0f rows and center at %s'", "%", "(", "filename", ",", "data", ".", "shape", "[", "0", "]", ",", "self", ".", "center", ")", ")", "\n", "return", "\n", "", "", ""]], "home.repos.pwc.inspect_result.RobRomijnders_RNN_basketball.None.dataloader.return_large_true": [[14, 33], ["itertools.groupby", "next", "len", "list"], "function", ["None"], ["def", "return_large_true", "(", "ind_crit", ")", ":", "\n", "  ", "\"\"\"Calculate the longest consequetive True's in ind_crit\n  For use in selecting indices from the sequence. ind_crit\n  is a boolean array where criteria are met. This function\n  return the index (best_i) and the length (best_elems) of\n  consequetive True's\"\"\"", "\n", "i", "=", "0", "\n", "best_elems", "=", "0", "\n", "best_i", "=", "0", "\n", "\n", "for", "key", ",", "group", "in", "groupby", "(", "ind_crit", ",", "lambda", "x", ":", "x", ")", ":", "\n", "    ", "number", "=", "next", "(", "group", ")", "\n", "elems", "=", "len", "(", "list", "(", "group", ")", ")", "+", "1", "\n", "if", "number", "==", "1", "and", "elems", ">", "1", ":", "\n", "      ", "if", "elems", ">", "best_elems", ":", "\n", "        ", "best_elems", "=", "elems", "\n", "best_i", "=", "i", "\n", "", "", "i", "+=", "elems", "\n", "", "return", "best_elems", ",", "best_i", "\n", "\n"]]}