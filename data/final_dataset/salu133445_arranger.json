{"home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize.parse_arguments": [[9, 30], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_filename\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input filename\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\n", "\"--output_filename\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"ourput filename\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize.main": [[32, 58], ["synthesize.parse_arguments", "muspy.load", "muspy.load.write_audio", "subprocess.run", "parse_arguments.output_filename.with_suffix", "parse_arguments.output_filename.with_suffix"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "\n", "# Load the music", "\n", "music", "=", "muspy", ".", "load", "(", "args", ".", "input_filename", ")", "\n", "\n", "# Synthesize the music", "\n", "music", ".", "write_audio", "(", "args", ".", "output_filename", ".", "with_suffix", "(", "\".wav\"", ")", ")", "\n", "\n", "subprocess", ".", "run", "(", "\n", "[", "\n", "\"ffmpeg\"", ",", "\n", "\"-i\"", ",", "\n", "args", ".", "output_filename", ".", "with_suffix", "(", "\".wav\"", ")", ",", "\n", "\"-vn\"", ",", "\n", "\"-ar\"", ",", "\n", "\"44100\"", ",", "\n", "\"-ab\"", ",", "\n", "\"192k\"", ",", "\n", "\"-f\"", ",", "\n", "\"mp3\"", ",", "\n", "args", ".", "output_filename", ",", "\n", "]", ",", "\n", "check", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.evaluate.parse_arguments": [[12, 26], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.evaluate.main": [[28, 86], ["evaluate.parse_arguments", "arranger.utils.setup_loggers", "list", "list", "numpy.concatenate", "numpy.concatenate", "sklearn.metrics.accuracy_score", "logging.info", "sklearn.metrics.balanced_accuracy_score", "logging.info", "sklearn.metrics.confusion_matrix", "numpy.save", "zip", "logging.info", "logging.info", "numpy.load().values", "numpy.load().values", "numpy.printoptions", "logging.info", "logging.info", "numpy.max", "range", "numpy.diff", "numpy.count_nonzero", "len", "numpy.diff", "numpy.count_nonzero", "len", "numpy.load", "numpy.load", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "input_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Load ground truth and predictions", "\n", "all_predictions", "=", "list", "(", "\n", "np", ".", "load", "(", "args", ".", "input_dir", "/", "\"predictions.npz\"", ")", ".", "values", "(", ")", "\n", ")", "\n", "all_labels", "=", "list", "(", "np", ".", "load", "(", "args", ".", "input_dir", "/", "\"labels.npz\"", ")", ".", "values", "(", ")", ")", "\n", "concat_predictions", "=", "np", ".", "concatenate", "(", "all_predictions", ")", "\n", "concat_labels", "=", "np", ".", "concatenate", "(", "all_labels", ")", "\n", "\n", "# Compute accuracy", "\n", "acc", "=", "sklearn", ".", "metrics", ".", "accuracy_score", "(", "concat_labels", ",", "concat_predictions", ")", "\n", "logging", ".", "info", "(", "f\"Accuracy : {100*acc:.2f}% ({acc})\"", ")", "\n", "\n", "# Compute balanced accuracy", "\n", "balanced_acc", "=", "sklearn", ".", "metrics", ".", "balanced_accuracy_score", "(", "\n", "concat_labels", ",", "concat_predictions", "\n", ")", "\n", "logging", ".", "info", "(", "\n", "f\"Balanced accuracy : {100*balanced_acc:.2f}% ({balanced_acc})\"", "\n", ")", "\n", "\n", "# Compute confusion matrix", "\n", "confusion_matrix", "=", "sklearn", ".", "metrics", ".", "confusion_matrix", "(", "\n", "concat_labels", ",", "concat_predictions", ",", "normalize", "=", "\"all\"", "\n", ")", "\n", "with", "np", ".", "printoptions", "(", "precision", "=", "4", ",", "suppress", "=", "True", ")", ":", "\n", "        ", "logging", ".", "info", "(", "\"Confusion matrix : \"", ")", "\n", "logging", ".", "info", "(", "confusion_matrix", ")", "\n", "", "np", ".", "save", "(", "args", ".", "input_dir", "/", "\"confusion_matrix.npy\"", ",", "confusion_matrix", ")", "\n", "\n", "# Compute soundness and completeness", "\n", "n_labels", "=", "np", ".", "max", "(", "concat_labels", ")", "+", "1", "\n", "n_sound", ",", "n_complete", "=", "0", ",", "0", "\n", "total_sound", ",", "total_complete", "=", "0", ",", "0", "\n", "for", "labels", ",", "predictions", "in", "zip", "(", "all_labels", ",", "all_predictions", ")", ":", "\n", "        ", "for", "label", "in", "range", "(", "n_labels", ")", ":", "\n", "# Soundness", "\n", "            ", "diff_sound", "=", "np", ".", "diff", "(", "labels", "[", "predictions", "==", "label", "]", ")", "\n", "n_sound", "+=", "np", ".", "count_nonzero", "(", "diff_sound", "==", "0", ")", "\n", "total_sound", "+=", "len", "(", "diff_sound", ")", "\n", "# Completeness", "\n", "diff_complete", "=", "np", ".", "diff", "(", "predictions", "[", "labels", "==", "label", "]", ")", "\n", "n_complete", "+=", "np", ".", "count_nonzero", "(", "diff_complete", "==", "0", ")", "\n", "total_complete", "+=", "len", "(", "diff_complete", ")", "\n", "", "", "soundness", "=", "n_sound", "/", "total_sound", "\n", "completeness", "=", "n_complete", "/", "total_complete", "\n", "logging", ".", "info", "(", "f\"Soundness : {100*soundness:.2f}% ({soundness})\"", ")", "\n", "logging", ".", "info", "(", "f\"Completeness : {100*completeness:.2f}% ({completeness})\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.collect_images.parse_arguments": [[8, 43], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\n", "\"--output_filename\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"output filename\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--datasets\"", ",", "\n", "nargs", "=", "\"*\"", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "default", "=", "[", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", "]", ",", "\n", "help", "=", "\"dataset(s)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-k\"", ",", "\n", "\"--keywords\"", ",", "\n", "nargs", "=", "\"*\"", ",", "\n", "help", "=", "\"keyword(s)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.collect_images.main": [[45, 102], ["collect_images.parse_arguments", "random.seed", "zipfile.ZipFile", "zip", "zip", "str", "print", "f.write", "print", "f.write", "any"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "with", "zipfile", ".", "ZipFile", "(", "args", ".", "output_filename", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "for", "dataset", "in", "args", ".", "datasets", ":", "\n", "# Collect filenames (without suffix and extension)", "\n", "            ", "names", "=", "[", "\n", "str", "(", "filename", ".", "name", ")", "[", ":", "-", "9", "]", "\n", "for", "filename", "in", "(", "\n", "args", ".", "input_dir", "/", "f\"{dataset}/common/default/samples/png\"", "\n", ")", ".", "glob", "(", "\"*_comp.png\"", ")", "\n", "]", "\n", "if", "args", ".", "keywords", ":", "\n", "                ", "names", "=", "[", "\n", "name", "\n", "for", "name", "in", "names", "\n", "if", "any", "(", "k", "in", "name", "for", "k", "in", "args", ".", "keywords", ")", "\n", "]", "\n", "\n", "# Baselines", "\n", "", "models", "=", "(", "\"common\"", ",", "\"zone\"", ",", "\"closest\"", ",", "\"closest\"", ")", "\n", "settings", "=", "(", "\"default\"", ",", "\"permutation\"", ",", "\"default\"", ",", "\"states\"", ")", "\n", "for", "model", ",", "setting", "in", "zip", "(", "models", ",", "settings", ")", ":", "\n", "                ", "sample_dir", "=", "(", "\n", "args", ".", "input_dir", "/", "f\"{dataset}/{model}/{setting}/samples\"", "\n", ")", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "                    ", "print", "(", "sample_dir", ")", "\n", "", "for", "name", "in", "names", ":", "\n", "                    ", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"png\"", "/", "f\"{name}_comp.png\"", ",", "\n", "f\"{dataset}/{name}_{model}_{setting}.png\"", ",", "\n", ")", "\n", "\n", "# Models", "\n", "", "", "models", "=", "(", "\"lstm\"", ",", "\"lstm\"", ",", "\"lstm\"", ",", "\"lstm\"", ")", "\n", "settings", "=", "(", "\n", "\"default_embedding\"", ",", "\n", "\"default_embedding_onsethint\"", ",", "\n", "\"bidirectional_embedding\"", ",", "\n", "\"bidirectional_embedding_onsethint_duration\"", ",", "\n", ")", "\n", "for", "model", ",", "setting", "in", "zip", "(", "models", ",", "settings", ")", ":", "\n", "                ", "sample_dir", "=", "(", "\n", "args", ".", "input_dir", "/", "f\"{dataset}/{model}/{setting}/samples\"", "\n", ")", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "                    ", "print", "(", "sample_dir", ")", "\n", "", "for", "name", "in", "names", ":", "\n", "                    ", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"png\"", "/", "f\"{name}_comp.png\"", ",", "\n", "f\"{dataset}/{name}_{model}_{setting}.png\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_config": [[12, 16], ["open", "yaml.safe_load", "pathlib.Path"], "function", ["None"], ["def", "load_config", "(", ")", ":", "\n", "    ", "\"\"\"Load configuration into a dictionary.\"\"\"", "\n", "with", "open", "(", "Path", "(", "__file__", ")", ".", "parent", "/", "\"config.yaml\"", ")", "as", "f", ":", "\n", "        ", "return", "yaml", ".", "safe_load", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers": [[18, 32], ["logging.basicConfig", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger().addHandler", "logging.Formatter", "logging.getLogger"], "function", ["None"], ["", "", "def", "setup_loggers", "(", "filename", ",", "quiet", ")", ":", "\n", "    ", "\"\"\"Set up the loggers.\"\"\"", "\n", "logging", ".", "basicConfig", "(", "\n", "level", "=", "logging", ".", "DEBUG", ",", "\n", "format", "=", "\"%(asctime)s %(levelname)-8s %(message)s\"", ",", "\n", "datefmt", "=", "\"%Y-%m-%d %H:%M:%S\"", ",", "\n", "filename", "=", "filename", ",", "\n", "filemode", "=", "\"w\"", ",", "\n", ")", "\n", "if", "not", "quiet", ":", "\n", "        ", "console", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "console", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "console", ".", "setFormatter", "(", "logging", ".", "Formatter", "(", "\"%(message)s\"", ")", ")", "\n", "logging", ".", "getLogger", "(", ")", ".", "addHandler", "(", "console", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks": [[34, 58], ["zip", "zip", "note_lists[].append", "programs.items", "tracks.append", "range", "muspy.Note", "muspy.Track", "len", "int", "int", "int", "int", "int"], "function", ["None"], ["", "", "def", "reconstruct_tracks", "(", "notes", ",", "labels", ",", "programs", ")", ":", "\n", "    ", "\"\"\"Reconstruct the tracks from data.\"\"\"", "\n", "# Reconstruct the notes", "\n", "note_lists", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "programs", ")", ")", "]", "\n", "for", "note", ",", "label", "in", "zip", "(", "notes", ",", "labels", ")", ":", "\n", "        ", "note_lists", "[", "int", "(", "label", ")", "]", ".", "append", "(", "\n", "muspy", ".", "Note", "(", "\n", "time", "=", "int", "(", "note", "[", "0", "]", ")", ",", "\n", "pitch", "=", "int", "(", "note", "[", "1", "]", ")", ",", "\n", "duration", "=", "int", "(", "note", "[", "2", "]", ")", ",", "\n", "velocity", "=", "int", "(", "note", "[", "3", "]", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "# Reconstruct the tracks", "\n", "", "tracks", "=", "[", "]", "\n", "for", "note_list", ",", "(", "name", ",", "program", ")", "in", "zip", "(", "note_lists", ",", "programs", ".", "items", "(", ")", ")", ":", "\n", "        ", "tracks", ".", "append", "(", "\n", "muspy", ".", "Track", "(", "\n", "program", "=", "program", ",", "is_drum", "=", "False", ",", "name", "=", "name", ",", "notes", "=", "note_list", "\n", ")", "\n", ")", "\n", "\n", "", "return", "tracks", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.to_pianoroll": [[60, 71], ["music.to_pypianoroll", "numpy.array", "stacked.reshape", "numpy.round().astype", "np.round().astype.reshape", "numpy.moveaxis", "numpy.flip().transpose", "music.to_pypianoroll.stack", "len", "numpy.matmul", "numpy.round", "numpy.flip", "len", "numpy.clip"], "function", ["None"], ["", "def", "to_pianoroll", "(", "music", ",", "colors", ")", ":", "\n", "    ", "\"\"\"Convert a music into a piano roll.\"\"\"", "\n", "multitrack", "=", "music", ".", "to_pypianoroll", "(", ")", "\n", "stacked", "=", "multitrack", ".", "stack", "(", ")", ">", "0", "\n", "colormatrix", "=", "np", ".", "array", "(", "colors", "[", ":", "len", "(", "music", ")", "]", ")", "\n", "reshaped", "=", "stacked", ".", "reshape", "(", "len", "(", "music", ")", ",", "-", "1", ")", "\n", "recolored", "=", "255", "-", "np", ".", "matmul", "(", "(", "255", "-", "colormatrix", ".", "T", ")", ",", "reshaped", ")", "\n", "clipped", "=", "np", ".", "round", "(", "np", ".", "clip", "(", "recolored", ",", "0", ",", "255", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "reshaped", "=", "clipped", ".", "reshape", "(", "(", "3", ",", "stacked", ".", "shape", "[", "1", "]", ",", "stacked", ".", "shape", "[", "2", "]", ")", ")", "\n", "transposed", "=", "np", ".", "moveaxis", "(", "reshaped", ",", "0", ",", "-", "1", ")", "\n", "return", "np", ".", "flip", "(", "transposed", ",", "axis", "=", "1", ")", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample": [[73, 85], ["music.save", "utils.to_pianoroll", "imageio.imwrite", "music.write", "music.write"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.to_pianoroll"], ["", "def", "save_sample", "(", "music", ",", "sample_dir", ",", "filename", ",", "colors", ")", ":", "\n", "    ", "\"\"\"Save a music sample into different formats.\"\"\"", "\n", "music", ".", "save", "(", "sample_dir", "/", "\"json\"", "/", "f\"{filename}.json\"", ")", "\n", "try", ":", "\n", "        ", "music", ".", "write", "(", "sample_dir", "/", "\"mid\"", "/", "f\"{filename}.mid\"", ")", "\n", "", "except", "ValueError", ":", "\n", "# NOTE: A workaround for a MIDI output bug in MusPy", "\n", "        ", "music", ".", "key_signatures", "=", "[", "]", "\n", "music", ".", "write", "(", "sample_dir", "/", "\"mid\"", "/", "f\"{filename}.mid\"", ")", "\n", "", "pianoroll", "=", "to_pianoroll", "(", "music", ",", "colors", ")", "\n", "imageio", ".", "imwrite", "(", "sample_dir", "/", "\"png\"", "/", "f\"{filename}.png\"", ",", "pianoroll", ")", "\n", "return", "pianoroll", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat": [[87, 99], ["music.save", "utils.to_pianoroll", "imageio.imwrite", "music.write", "music.write"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.to_pianoroll"], ["", "def", "save_sample_flat", "(", "music", ",", "sample_dir", ",", "filename", ",", "colors", ")", ":", "\n", "    ", "\"\"\"Save a music sample into different formats.\"\"\"", "\n", "music", ".", "save", "(", "sample_dir", "/", "f\"{filename}.json\"", ")", "\n", "try", ":", "\n", "        ", "music", ".", "write", "(", "sample_dir", "/", "f\"{filename}.mid\"", ")", "\n", "", "except", "ValueError", ":", "\n", "# NOTE: A workaround for a MIDI output bug in MusPy", "\n", "        ", "music", ".", "key_signatures", "=", "[", "]", "\n", "music", ".", "write", "(", "sample_dir", "/", "f\"{filename}.mid\"", ")", "\n", "", "pianoroll", "=", "to_pianoroll", "(", "music", ",", "colors", ")", "\n", "imageio", ".", "imwrite", "(", "sample_dir", "/", "f\"{filename}.png\"", ",", "pianoroll", ")", "\n", "return", "pianoroll", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison": [[101, 133], ["numpy.tile", "numpy.concatenate", "imageio.imwrite", "numpy.pad", "numpy.pad"], "function", ["None"], ["", "def", "save_comparison", "(", "pianoroll", ",", "pianoroll_pred", ",", "sample_dir", ",", "filename", ")", ":", "\n", "    ", "\"\"\"Save comparisons of piano rolls.\"\"\"", "\n", "if", "pianoroll", ".", "shape", "[", "1", "]", ">", "pianoroll_pred", ".", "shape", "[", "1", "]", ":", "\n", "        ", "pad_width", "=", "pianoroll", ".", "shape", "[", "1", "]", "-", "pianoroll_pred", ".", "shape", "[", "1", "]", "\n", "pianoroll_pred", "=", "np", ".", "pad", "(", "\n", "pianoroll_pred", ",", "\n", "(", "\n", "(", "0", ",", "0", ")", ",", "\n", "(", "0", ",", "pad_width", ")", ",", "\n", "(", "0", ",", "0", ")", ",", "\n", ")", ",", "\n", "constant_values", "=", "255", ",", "\n", ")", "\n", "", "elif", "pianoroll", ".", "shape", "[", "1", "]", "<", "pianoroll_pred", ".", "shape", "[", "1", "]", ":", "\n", "        ", "pad_width", "=", "pianoroll_pred", ".", "shape", "[", "1", "]", "-", "pianoroll", ".", "shape", "[", "1", "]", "\n", "pianoroll", "=", "np", ".", "pad", "(", "\n", "pianoroll", ",", "\n", "(", "\n", "(", "0", ",", "0", ")", ",", "\n", "(", "0", ",", "pad_width", ")", ",", "\n", "(", "0", ",", "0", ")", ",", "\n", ")", ",", "\n", "constant_values", "=", "255", ",", "\n", ")", "\n", "", "binarized", "=", "np", ".", "tile", "(", "(", "pianoroll", "<", "250", ")", ".", "any", "(", "-", "1", ",", "keepdims", "=", "True", ")", ",", "(", "1", ",", "1", ",", "3", ")", ")", "\n", "uncolored", "=", "(", "255", "*", "(", "1", "-", "binarized", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "pianoroll_comp", "=", "np", ".", "concatenate", "(", "(", "uncolored", ",", "pianoroll", ",", "pianoroll_pred", ")", ",", "0", ")", "\n", "imageio", ".", "imwrite", "(", "\n", "sample_dir", "/", "\"png\"", "/", "f\"{filename}.png\"", ",", "\n", "pianoroll_comp", ",", "\n", ")", "\n", "return", "pianoroll_comp", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npy": [[135, 138], ["numpy.load().astype", "numpy.load"], "function", ["None"], ["", "def", "load_npy", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Load a NPY file into an array.\"\"\"", "\n", "return", "np", ".", "load", "(", "filename", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz": [[140, 143], ["arr.astype", "numpy.load().values", "numpy.load"], "function", ["None"], ["", "def", "load_npz", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Load a NPZ file into a list of arrays.\"\"\"", "\n", "return", "[", "arr", ".", "astype", "(", "np", ".", "int32", ")", "for", "arr", "in", "np", ".", "load", "(", "filename", ")", ".", "values", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.compute_metrics": [[145, 204], ["numpy.savez", "numpy.savez", "numpy.concatenate", "numpy.concatenate", "sklearn.metrics.accuracy_score", "logging.info", "sklearn.metrics.balanced_accuracy_score", "logging.info", "sklearn.metrics.confusion_matrix", "numpy.save", "zip", "logging.info", "logging.info", "all_predictions.append", "all_labels.append", "numpy.printoptions", "logging.info", "logging.info", "numpy.max", "range", "numpy.diff", "numpy.count_nonzero", "len", "numpy.diff", "numpy.count_nonzero", "len"], "function", ["None"], ["", "def", "compute_metrics", "(", "results", ",", "output_dir", ")", ":", "\n", "    ", "\"\"\"Compute the metrics.\"\"\"", "\n", "# Compute accuracy", "\n", "all_predictions", "=", "[", "]", "\n", "all_labels", "=", "[", "]", "\n", "for", "result", "in", "results", ":", "\n", "        ", "if", "result", "is", "None", ":", "\n", "            ", "continue", "\n", "", "predictions", ",", "labels", "=", "result", "\n", "all_predictions", ".", "append", "(", "predictions", ")", "\n", "all_labels", ".", "append", "(", "labels", ")", "\n", "\n", "# Save predictions and labels", "\n", "", "np", ".", "savez", "(", "output_dir", "/", "\"predictions.npz\"", ",", "*", "all_predictions", ")", "\n", "np", ".", "savez", "(", "output_dir", "/", "\"labels.npz\"", ",", "*", "all_labels", ")", "\n", "\n", "# Load ground truth and predictions", "\n", "concat_predictions", "=", "np", ".", "concatenate", "(", "all_predictions", ")", "\n", "concat_labels", "=", "np", ".", "concatenate", "(", "all_labels", ")", "\n", "\n", "# Compute accuracy", "\n", "acc", "=", "sklearn", ".", "metrics", ".", "accuracy_score", "(", "concat_labels", ",", "concat_predictions", ")", "\n", "logging", ".", "info", "(", "f\"Accuracy : {100*acc:.2f}% ({acc})\"", ")", "\n", "\n", "# Compute balanced accuracy", "\n", "balanced_acc", "=", "sklearn", ".", "metrics", ".", "balanced_accuracy_score", "(", "\n", "concat_labels", ",", "concat_predictions", "\n", ")", "\n", "logging", ".", "info", "(", "\n", "f\"Balanced accuracy : {100*balanced_acc:.2f}% ({balanced_acc})\"", "\n", ")", "\n", "\n", "# Compute confusion matrix", "\n", "confusion_matrix", "=", "sklearn", ".", "metrics", ".", "confusion_matrix", "(", "\n", "concat_labels", ",", "concat_predictions", ",", "normalize", "=", "\"all\"", "\n", ")", "\n", "with", "np", ".", "printoptions", "(", "precision", "=", "4", ",", "suppress", "=", "True", ")", ":", "\n", "        ", "logging", ".", "info", "(", "\"Confusion matrix : \"", ")", "\n", "logging", ".", "info", "(", "confusion_matrix", ")", "\n", "", "np", ".", "save", "(", "output_dir", "/", "\"confusion_matrix.npy\"", ",", "confusion_matrix", ")", "\n", "\n", "# Compute soundness and completeness", "\n", "n_labels", "=", "np", ".", "max", "(", "concat_labels", ")", "+", "1", "\n", "n_sound", ",", "n_complete", "=", "0", ",", "0", "\n", "total_sound", ",", "total_complete", "=", "0", ",", "0", "\n", "for", "labels", ",", "predictions", "in", "zip", "(", "all_labels", ",", "all_predictions", ")", ":", "\n", "        ", "for", "label", "in", "range", "(", "n_labels", ")", ":", "\n", "# Soundness", "\n", "            ", "diff_sound", "=", "np", ".", "diff", "(", "labels", "[", "predictions", "==", "label", "]", ")", "\n", "n_sound", "+=", "np", ".", "count_nonzero", "(", "diff_sound", "==", "0", ")", "\n", "total_sound", "+=", "len", "(", "diff_sound", ")", "\n", "# Completeness", "\n", "diff_complete", "=", "np", ".", "diff", "(", "predictions", "[", "labels", "==", "label", "]", ")", "\n", "n_complete", "+=", "np", ".", "count_nonzero", "(", "diff_complete", "==", "0", ")", "\n", "total_complete", "+=", "len", "(", "diff_complete", ")", "\n", "", "", "soundness", "=", "n_sound", "/", "total_sound", "\n", "completeness", "=", "n_complete", "/", "total_complete", "\n", "logging", ".", "info", "(", "f\"Soundness : {100*soundness:.2f}% ({soundness})\"", ")", "\n", "logging", ".", "info", "(", "f\"Completeness : {100*completeness:.2f}% ({completeness})\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.collect_audio.parse_arguments": [[8, 43], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\n", "\"--output_filename\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"output filename\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--datasets\"", ",", "\n", "nargs", "=", "\"*\"", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "default", "=", "[", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", "]", ",", "\n", "help", "=", "\"dataset(s)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-k\"", ",", "\n", "\"--keywords\"", ",", "\n", "nargs", "=", "\"*\"", ",", "\n", "help", "=", "\"keyword(s)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.collect_audio.main": [[45, 159], ["collect_audio.parse_arguments", "random.seed", "zipfile.ZipFile", "zip", "zip", "f.write", "f.write", "str", "len", "random.sample", "f.write", "f.write", "print", "f.write", "f.write", "print", "f.write", "f.write", "any", "f.write", "f.write", "f.write", "f.write"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "# Create the zip archive", "\n", "with", "zipfile", ".", "ZipFile", "(", "args", ".", "output_filename", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "for", "dataset", "in", "args", ".", "datasets", ":", "\n", "# Collect filenames (without suffix and extension)", "\n", "            ", "names", "=", "[", "\n", "str", "(", "filename", ".", "name", ")", "[", ":", "-", "10", "]", "\n", "for", "filename", "in", "(", "\n", "args", ".", "input_dir", "/", "f\"{dataset}/common/default/samples/mid\"", "\n", ")", ".", "glob", "(", "\"*_truth.mid\"", ")", "\n", "]", "\n", "if", "args", ".", "keywords", ":", "\n", "                ", "names", "=", "[", "\n", "name", "\n", "for", "name", "in", "names", "\n", "if", "any", "(", "k", "in", "name", "for", "k", "in", "args", ".", "keywords", ")", "\n", "]", "\n", "", "elif", "len", "(", "names", ")", ">", "10", ":", "\n", "                ", "names", "=", "random", ".", "sample", "(", "names", ",", "5", ")", "\n", "\n", "# Ground truth", "\n", "", "for", "name", "in", "names", ":", "\n", "                ", "f", ".", "write", "(", "\n", "args", ".", "input_dir", "\n", "/", "f\"{dataset}/common/default/samples/mid/{name}_truth.mid\"", ",", "\n", "f\"{dataset}/{name}_truth.mid\"", ",", "\n", ")", "\n", "f", ".", "write", "(", "\n", "args", ".", "input_dir", "\n", "/", "f\"{dataset}/common/default/samples/mp3/{name}_truth.mp3\"", ",", "\n", "f\"{dataset}/{name}_truth.mp3\"", ",", "\n", ")", "\n", "if", "dataset", "==", "\"lmd\"", ":", "\n", "                    ", "f", ".", "write", "(", "\n", "args", ".", "input_dir", "\n", "/", "f\"{dataset}/common/default/samples/mid/{name}_truth_drums.mid\"", ",", "\n", "f\"{dataset}_drums/{name}_truth_drums.mid\"", ",", "\n", ")", "\n", "f", ".", "write", "(", "\n", "args", ".", "input_dir", "\n", "/", "f\"{dataset}/common/default/samples/mp3/{name}_truth_drums.mp3\"", ",", "\n", "f\"{dataset}_drums/{name}_truth_drums.mp3\"", ",", "\n", ")", "\n", "\n", "# Baselines", "\n", "", "", "models", "=", "(", "\"common\"", ",", "\"zone\"", ",", "\"closest\"", ",", "\"closest\"", ")", "\n", "settings", "=", "(", "\"default\"", ",", "\"permutation\"", ",", "\"default\"", ",", "\"states\"", ")", "\n", "for", "model", ",", "setting", "in", "zip", "(", "models", ",", "settings", ")", ":", "\n", "                ", "sample_dir", "=", "(", "\n", "args", ".", "input_dir", "/", "f\"{dataset}/{model}/{setting}/samples\"", "\n", ")", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "                    ", "print", "(", "sample_dir", ")", "\n", "\n", "# Save MIDI and MP3 files", "\n", "", "for", "name", "in", "names", ":", "\n", "                    ", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"mid\"", "/", "f\"{name}_pred.mid\"", ",", "\n", "f\"{dataset}/{name}_{model}_{setting}.mid\"", ",", "\n", ")", "\n", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"mp3\"", "/", "f\"{name}_pred.mp3\"", ",", "\n", "f\"{dataset}/{name}_{model}_{setting}.mp3\"", ",", "\n", ")", "\n", "if", "dataset", "==", "\"lmd\"", ":", "\n", "                        ", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"mid\"", "/", "f\"{name}_pred_drums.mid\"", ",", "\n", "f\"{dataset}_drums/{name}_{model}_{setting}.mid\"", ",", "\n", ")", "\n", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"mp3\"", "/", "f\"{name}_pred_drums.mp3\"", ",", "\n", "f\"{dataset}_drums/{name}_{model}_{setting}_drums.mp3\"", ",", "\n", ")", "\n", "\n", "# Models", "\n", "", "", "", "models", "=", "(", "\"lstm\"", ",", "\"lstm\"", ",", "\"lstm\"", ",", "\"lstm\"", ")", "\n", "settings", "=", "(", "\n", "\"default_embedding\"", ",", "\n", "\"default_embedding_onsethint\"", ",", "\n", "\"bidirectional_embedding\"", ",", "\n", "\"bidirectional_embedding_onsethint_duration\"", ",", "\n", ")", "\n", "for", "model", ",", "setting", "in", "zip", "(", "models", ",", "settings", ")", ":", "\n", "                ", "sample_dir", "=", "(", "\n", "args", ".", "input_dir", "/", "f\"{dataset}/{model}/{setting}/samples\"", "\n", ")", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "                    ", "print", "(", "sample_dir", ")", "\n", "\n", "# Save MIDI and MP3 files", "\n", "", "for", "name", "in", "names", ":", "\n", "                    ", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"mid\"", "/", "f\"{name}_pred.mid\"", ",", "\n", "f\"{dataset}/{name}_{model}_{setting}.mid\"", ",", "\n", ")", "\n", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"mp3\"", "/", "f\"{name}_pred.mp3\"", ",", "\n", "f\"{dataset}/{name}_{model}_{setting}.mp3\"", ",", "\n", ")", "\n", "if", "dataset", "==", "\"lmd\"", ":", "\n", "                        ", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"mid\"", "/", "f\"{name}_pred_drums.mid\"", ",", "\n", "f\"{dataset}_drums/{name}_{model}_{setting}_drums.mid\"", ",", "\n", ")", "\n", "f", ".", "write", "(", "\n", "sample_dir", "/", "\"mp3\"", "/", "f\"{name}_pred_drums.mp3\"", ",", "\n", "f\"{dataset}_drums/{name}_{model}_{setting}_drums.mp3\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.parse_arguments": [[15, 32], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio": [[34, 79], ["tempfile.mkdtemp", "muspy.load", "os.path.join", "os.path.join", "subprocess.run", "os.remove", "os.remove", "os.rmdir", "os.rmdir", "muspy.load.write_audio", "muspy.load.write_audio", "filename.with_suffix"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio"], ["", "def", "write_audio", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Write the audio.\"\"\"", "\n", "# Create a temporary directory", "\n", "tmpdir", "=", "tempfile", ".", "mkdtemp", "(", ")", "\n", "\n", "# Load the music", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Synthesize the music", "\n", "wav_path", "=", "os", ".", "path", ".", "join", "(", "tmpdir", ",", "\"temp.wav\"", ")", "\n", "try", ":", "\n", "        ", "music", ".", "write_audio", "(", "wav_path", ")", "\n", "", "except", "ValueError", ":", "\n", "# NOTE: A workaround for a MIDI output bug in MusPy", "\n", "        ", "music", ".", "key_signatures", "=", "[", "]", "\n", "music", ".", "write_audio", "(", "wav_path", ")", "\n", "\n", "# Convert it to mp3", "\n", "", "mp3_path", "=", "(", "\n", "filename", ".", "parent", ".", "parent", "/", "\"mp3\"", "/", "filename", ".", "with_suffix", "(", "\".mp3\"", ")", ".", "name", "\n", ")", "\n", "subprocess", ".", "run", "(", "\n", "[", "\n", "\"ffmpeg\"", ",", "\n", "\"-hide_banner\"", ",", "\n", "\"-loglevel\"", ",", "\n", "\"error\"", ",", "\n", "\"-y\"", ",", "\n", "\"-i\"", ",", "\n", "wav_path", ",", "\n", "\"-vn\"", ",", "\n", "\"-ar\"", ",", "\n", "\"44100\"", ",", "\n", "\"-ab\"", ",", "\n", "\"192k\"", ",", "\n", "\"-f\"", ",", "\n", "\"mp3\"", ",", "\n", "mp3_path", ",", "\n", "]", ",", "\n", "check", "=", "True", ",", "\n", ")", "\n", "\n", "# Remove the temporary directory", "\n", "os", ".", "remove", "(", "wav_path", ")", "\n", "os", ".", "rmdir", "(", "tmpdir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.main": [[81, 177], ["synthesize_all.parse_arguments", "random.seed", "list", "zip", "print", "list.extend", "tqdm.tqdm", "list", "synthesize_all.write_audio", "joblib.Parallel", "print", "list.extend", "tqdm.tqdm", "range", "synthesize_all.write_audio", "joblib.Parallel", "list", "joblib.delayed", "len", "print", "list.extend", "tqdm.tqdm", "joblib.delayed", "synthesize_all.write_audio", "joblib.Parallel", "joblib.delayed"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "for", "dataset", "in", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ":", "\n", "        ", "if", "dataset", "!=", "\"lmd\"", ":", "\n", "            ", "continue", "\n", "# Ground truth", "\n", "", "sample_dir", "=", "args", ".", "input_dir", "/", "f\"{dataset}/common/default/samples\"", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "            ", "print", "(", "sample_dir", ")", "\n", "", "(", "sample_dir", "/", "\"mp3\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Save audio files", "\n", "filenames", "=", "list", "(", "(", "sample_dir", "/", "\"json\"", ")", ".", "glob", "(", "\"*_truth.json\"", ")", ")", "\n", "if", "dataset", "==", "\"lmd\"", ":", "\n", "            ", "filenames", ".", "extend", "(", "(", "sample_dir", "/", "\"json\"", ")", ".", "glob", "(", "\"*_truth_drums.json\"", ")", ")", "\n", "\n", "", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "            ", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "ncols", "=", "80", ")", ":", "\n", "                ", "write_audio", "(", "filename", ")", "\n", "", "", "else", ":", "\n", "            ", "joblib", ".", "Parallel", "(", "\n", "args", ".", "n_jobs", ",", "\n", "prefer", "=", "\"threads\"", ",", "\n", "verbose", "=", "0", "if", "args", ".", "quiet", "else", "5", ",", "\n", ")", "(", "joblib", ".", "delayed", "(", "write_audio", ")", "(", "filename", ")", "for", "filename", "in", "filenames", ")", "\n", "\n", "# Baselines", "\n", "", "models", "=", "(", "\"common\"", ",", "\"zone\"", ",", "\"closest\"", ",", "\"closest\"", ")", "\n", "settings", "=", "(", "\"default\"", ",", "\"permutation\"", ",", "\"default\"", ",", "\"states\"", ")", "\n", "for", "model", ",", "setting", "in", "zip", "(", "models", ",", "settings", ")", ":", "\n", "            ", "sample_dir", "=", "(", "\n", "args", ".", "input_dir", "/", "f\"{dataset}/{model}/{setting}/samples\"", "\n", ")", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "                ", "print", "(", "sample_dir", ")", "\n", "", "(", "sample_dir", "/", "\"mp3\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Save audio files", "\n", "filenames", "=", "list", "(", "(", "sample_dir", "/", "\"json\"", ")", ".", "glob", "(", "\"*_pred.json\"", ")", ")", "\n", "if", "dataset", "==", "\"lmd\"", ":", "\n", "                ", "filenames", ".", "extend", "(", "\n", "(", "sample_dir", "/", "\"json\"", ")", ".", "glob", "(", "\"*_pred_drums.json\"", ")", "\n", ")", "\n", "", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "                ", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "ncols", "=", "80", ")", ":", "\n", "                    ", "write_audio", "(", "filename", ")", "\n", "", "", "else", ":", "\n", "                ", "joblib", ".", "Parallel", "(", "\n", "args", ".", "n_jobs", ",", "\n", "prefer", "=", "\"threads\"", ",", "\n", "verbose", "=", "0", "if", "args", ".", "quiet", "else", "5", ",", "\n", ")", "(", "\n", "joblib", ".", "delayed", "(", "write_audio", ")", "(", "filename", ")", "\n", "for", "filename", "in", "filenames", "\n", ")", "\n", "\n", "# Models", "\n", "", "", "for", "model", "in", "(", "\"lstm\"", ",", "\"transformer\"", ")", ":", "\n", "            ", "keys", "=", "[", "\"embedding\"", ",", "\"onsethint\"", ",", "\"duration\"", "]", "\n", "if", "model", "==", "\"lstm\"", ":", "\n", "                ", "keys1", "=", "(", "\"default\"", ",", "\"bidirectional\"", ")", "\n", "", "else", ":", "\n", "                ", "keys1", "=", "(", "\"default\"", ",", "\"lookahead\"", ")", "\n", "", "for", "key1", "in", "keys1", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "keys", ")", "+", "1", ")", ":", "\n", "                    ", "setting", "=", "\"_\"", ".", "join", "(", "[", "key1", "]", "+", "keys", "[", ":", "i", "]", ")", "\n", "sample_dir", "=", "(", "\n", "args", ".", "input_dir", "/", "f\"{dataset}/{model}/{setting}/samples\"", "\n", ")", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "                        ", "print", "(", "sample_dir", ")", "\n", "", "(", "sample_dir", "/", "\"mp3\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Save audio files", "\n", "filenames", "=", "list", "(", "(", "sample_dir", "/", "\"json\"", ")", ".", "glob", "(", "\"*_pred.json\"", ")", ")", "\n", "if", "dataset", "==", "\"lmd\"", ":", "\n", "                        ", "filenames", ".", "extend", "(", "\n", "(", "sample_dir", "/", "\"json\"", ")", ".", "glob", "(", "\"*_pred_drums.json\"", ")", "\n", ")", "\n", "", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "                        ", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "ncols", "=", "80", ")", ":", "\n", "                            ", "write_audio", "(", "filename", ")", "\n", "", "", "else", ":", "\n", "                        ", "joblib", ".", "Parallel", "(", "\n", "args", ".", "n_jobs", ",", "\n", "prefer", "=", "\"threads\"", ",", "\n", "verbose", "=", "0", "if", "args", ".", "quiet", "else", "5", ",", "\n", ")", "(", "\n", "joblib", ".", "delayed", "(", "write_audio", ")", "(", "filename", ")", "\n", "for", "filename", "in", "filenames", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.predict.parse_arguments": [[22, 65], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input filename or directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-of\"", ",", "\n", "\"--onsets_filename\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"onsets filename\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-a\"", ",", "\n", "\"--audio\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"whether to write audio\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--suffix\"", ",", "\n", "default", "=", "\"pred\"", ",", "\n", "help", "=", "\"suffix to the output filename(s)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.predict._predict_without_states": [[67, 86], ["predictions.append", "onsets.index", "enumerate", "numpy.argmax", "numpy.square"], "function", ["None"], ["", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.predict._predict_with_states": [[88, 119], ["numpy.zeros", "enumerate", "itertools.permutations", "range", "len", "numpy.sum", "len", "enumerate", "numpy.square", "onsets.index", "range", "len"], "function", ["None"], ["", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.predict._predict": [[121, 210], ["numpy.zeros", "numpy.zeros", "enumerate", "enumerate", "len", "numpy.zeros", "predict._predict_with_states", "zip", "predict._predict_without_states", "zip", "predict._predict_with_states", "zip", "collected.append", "predict._predict_without_states", "zip", "len", "len"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_with_states", "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_without_states", "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_with_states", "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_without_states"], ["", "def", "_predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "else", ":", "\n", "# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.predict.predict": [[212, 237], ["np.array.sort", "numpy.array", "len", "predict._predict", "numpy.asarray", "np.array.append"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.zone.predict._predict"], ["", "def", "predict", "(", "music", ",", "dataset", ",", "states", ",", "onsets", ")", ":", "\n", "    ", "\"\"\"Predict on a music.\"\"\"", "\n", "# Collect notes and labels", "\n", "notes", "=", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Collect notes and labels", "\n", "", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "\n", "# Sort the notes", "\n", "", "", "notes", ".", "sort", "(", ")", "\n", "\n", "# Convert lists to arrays for speed reason", "\n", "notes", "=", "np", ".", "array", "(", "notes", ",", "int", ")", "\n", "\n", "# Get number of tracks", "\n", "n_tracks", "=", "len", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ")", "\n", "\n", "# Predict the labels", "\n", "predictions", "=", "_predict", "(", "notes", ",", "np", ".", "asarray", "(", "onsets", ")", ",", "n_tracks", ",", "states", ")", "\n", "\n", "return", "notes", ",", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.predict.process": [[239, 281], ["muspy.load", "numpy.load", "predict.predict", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample_flat", "muspy.write_audio", "music.deepcopy.tracks.append", "arranger.utils.save_sample_flat", "muspy.write_audio"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio"], ["", "def", "process", "(", "filename", ",", "args", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Load onsets", "\n", "onsets", "=", "np", ".", "load", "(", "args", ".", "onsets_filename", ")", "\n", "\n", "# Get note and predicted labels", "\n", "notes", ",", "predictions", "=", "predict", "(", "music", ",", "args", ".", "dataset", ",", "args", ".", "states", ",", "onsets", ")", "\n", "\n", "# Shorthands", "\n", "programs", "=", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"programs\"", "]", "\n", "colors", "=", "CONFIG", "[", "\"colors\"", "]", "\n", "\n", "# Reconstruct and save the music using the predicted labels", "\n", "music_pred", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_pred", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "predictions", ",", "programs", ")", "\n", "save_sample_flat", "(", "\n", "music_pred", ",", "args", ".", "output_dir", ",", "f\"{filename.stem}_{args.suffix}\"", ",", "colors", "\n", ")", "\n", "if", "args", ".", "audio", ":", "\n", "        ", "muspy", ".", "write_audio", "(", "\n", "args", ".", "output_dir", "/", "f\"{filename.stem}_{args.suffix}.wav\"", ",", "music_pred", "\n", ")", "\n", "\n", "# Save the samples with drums", "\n", "", "if", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"has_drums\"", "]", ":", "\n", "        ", "music_pred", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "save_sample_flat", "(", "\n", "music_pred", ",", "\n", "args", ".", "output_dir", ",", "\n", "f\"{filename.stem}_{args.suffix}_drums\"", ",", "\n", "colors", ",", "\n", ")", "\n", "if", "args", ".", "audio", ":", "\n", "            ", "muspy", ".", "write_audio", "(", "\n", "args", ".", "output_dir", "/", "f\"{filename.stem}_{args.suffix}_drums.wav\"", ",", "\n", "music_pred", ",", "\n", ")", "\n", "\n", "", "", "return", "notes", ",", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.predict.main": [[283, 317], ["predict.parse_arguments", "arranger.utils.setup_loggers", "logging.debug", "vars().items", "parse_arguments.input.is_file", "logging.info", "list", "logging.info", "tqdm.tqdm", "NotADirectoryError", "logging.debug", "predict.process", "parse_arguments.input.glob", "predict.process", "parse_arguments.output_dir.is_dir", "vars", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "\n", "# Check output directory", "\n", "if", "args", ".", "output_dir", "is", "not", "None", "and", "not", "args", ".", "output_dir", ".", "is_dir", "(", ")", ":", "\n", "        ", "raise", "NotADirectoryError", "(", "\"`output_dir` must be an existing directory.\"", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "debug", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "debug", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# Process the file", "\n", "", "if", "args", ".", "input", ".", "is_file", "(", ")", ":", "\n", "        ", "process", "(", "args", ".", "input", ",", "args", ")", "\n", "return", "\n", "\n", "# Collect filenames", "\n", "", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "filenames", "=", "list", "(", "args", ".", "input", ".", "glob", "(", "\"*.json\"", ")", ")", "\n", "assert", "filenames", ",", "\"No input files found. Only JSON files are supported.\"", "\n", "\n", "# Start inference", "\n", "logging", ".", "info", "(", "\"Start testing...\"", ")", "\n", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ":", "\n", "        ", "process", "(", "filename", ",", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer.parse_arguments": [[26, 56], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\"--states\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"use state array\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_without_states": [[58, 77], ["predictions.append", "onsets.index", "enumerate", "numpy.argmax", "numpy.square"], "function", ["None"], ["", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_with_states": [[79, 110], ["numpy.zeros", "enumerate", "itertools.permutations", "range", "len", "numpy.sum", "len", "enumerate", "numpy.square", "onsets.index", "range", "len"], "function", ["None"], ["", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer.predict": [[112, 201], ["numpy.zeros", "numpy.zeros", "enumerate", "enumerate", "len", "numpy.zeros", "infer._predict_with_states", "zip", "infer._predict_without_states", "zip", "infer._predict_with_states", "zip", "collected.append", "infer._predict_without_states", "zip", "len", "len"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_with_states", "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_without_states", "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_with_states", "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer._predict_without_states"], ["", "def", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "else", ":", "\n", "# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer.process": [[203, 287], ["muspy.load", "list", "len", "zip", "numpy.array", "numpy.array", "range", "infer.predict", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "arranger.utils.save_comparison", "[].keys", "list.index", "onsets.append", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "arranger.utils.save_comparison", "np.array.append", "np.array.append", "sorted", "zip", "operator.itemgetter"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison"], ["", "def", "process", "(", "filename", ",", "states", ",", "dataset", ",", "output_dir", ",", "save", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Get track names and number of tracks", "\n", "names", "=", "list", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ".", "keys", "(", ")", ")", "\n", "n_tracks", "=", "len", "(", "names", ")", "\n", "\n", "# Collect notes and labels", "\n", "notes", ",", "labels", "=", "[", "]", ",", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Get label", "\n", "", "label", "=", "names", ".", "index", "(", "track", ".", "name", ")", "\n", "# Collect notes and labels", "\n", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "\n", "# Sort the notes and labels (using notes as keys)", "\n", "", "", "notes", ",", "labels", "=", "zip", "(", "*", "sorted", "(", "zip", "(", "notes", ",", "labels", ")", ",", "key", "=", "itemgetter", "(", "0", ")", ")", ")", "\n", "\n", "# Convert lists to arrays for speed reason", "\n", "notes", "=", "np", ".", "array", "(", "notes", ",", "int", ")", "\n", "labels", "=", "np", ".", "array", "(", "labels", ",", "int", ")", "\n", "\n", "# Find the onset time for each track", "\n", "onsets", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_tracks", ")", ":", "\n", "        ", "nonzero", "=", "(", "labels", "==", "i", ")", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "onsets", ".", "append", "(", "nonzero", "[", "0", "]", "if", "nonzero", ".", "size", "else", "None", ")", "\n", "\n", "# Predict the labels", "\n", "", "predictions", "=", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", "\n", "\n", "# Return early if no need to save the sample", "\n", "if", "not", "save", ":", "\n", "        ", "return", "predictions", ",", "labels", "\n", "\n", "# Shorthands", "\n", "", "sample_dir", "=", "output_dir", "/", "\"samples\"", "\n", "programs", "=", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", "\n", "colors", "=", "CONFIG", "[", "\"colors\"", "]", "\n", "\n", "# Reconstruct and save the music using the predicted labels", "\n", "music_pred", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_pred", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "predictions", ",", "programs", ")", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred\"", ",", "colors", "\n", ")", "\n", "\n", "# Reconstruct and save the music using the original labels", "\n", "music_truth", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_truth", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "labels", ",", "programs", ")", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n", "music_truth", ",", "sample_dir", ",", "f\"{filename.stem}_truth\"", ",", "colors", "\n", ")", "\n", "\n", "# Save comparison", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "pianoroll_pred", ",", "sample_dir", ",", "f\"{filename.stem}_comp\"", "\n", ")", "\n", "\n", "# Save the samples with drums", "\n", "if", "CONFIG", "[", "dataset", "]", "[", "\"has_drums\"", "]", ":", "\n", "        ", "music_pred", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred_drums\"", ",", "colors", "\n", ")", "\n", "music_truth", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n", "music_truth", ",", "sample_dir", ",", "f\"{filename.stem}_truth_drums\"", ",", "colors", "\n", ")", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "\n", "pianoroll_pred", ",", "\n", "sample_dir", ",", "\n", "f\"{filename.stem}_comp_drums\"", ",", "\n", ")", "\n", "\n", "", "return", "predictions", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.closest.infer.main": [[289, 352], ["infer.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "logging.info", "vars().items", "logging.info", "list", "logging.info", "arranger.utils.compute_metrics", "logging.info", "open", "parse_arguments.input_dir.glob", "vars", "line.rstrip", "infer.process", "joblib.Parallel", "zip", "pathlib.Path().with_suffix", "tqdm.tqdm", "joblib.delayed", "zip", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.compute_metrics", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Make sure sample directories exist", "\n", "(", "args", ".", "output_dir", "/", "\"samples\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"json\"", ",", "\"mid\"", ",", "\"png\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "\"samples\"", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# Load sample filenames", "\n", "", "with", "open", "(", "args", ".", "input_dir", "/", "\"samples.txt\"", ")", "as", "f", ":", "\n", "        ", "sample_filenames", "=", "[", "line", ".", "rstrip", "(", ")", "for", "line", "in", "f", "]", "\n", "\n", "# Collect filenames", "\n", "", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "extension", "=", "\"json\"", "if", "args", ".", "dataset", "!=", "\"lmd\"", "else", "\"json.gz\"", "\n", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "glob", "(", "f\"test/*.{extension}\"", ")", ")", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "is_samples", "=", "(", "filename", ".", "stem", "in", "sample_filenames", "for", "filename", "in", "filenames", ")", "\n", "\n", "# Iterate over the test data", "\n", "logging", ".", "info", "(", "\"Start testing...\"", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "results", "=", "[", "\n", "process", "(", "\n", "filename", ",", "\n", "args", ".", "states", ",", "\n", "args", ".", "dataset", ",", "\n", "args", ".", "output_dir", ",", "\n", "is_sample", ",", "\n", ")", "\n", "for", "filename", ",", "is_sample", "in", "zip", "(", "\n", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ",", "is_samples", "\n", ")", "\n", "]", "\n", "", "else", ":", "\n", "        ", "results", "=", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process", ")", "(", "\n", "filename", ",", "\n", "args", ".", "states", ",", "\n", "args", ".", "dataset", ",", "\n", "args", ".", "output_dir", ",", "\n", "is_sample", ",", "\n", ")", "\n", "for", "filename", ",", "is_sample", "in", "zip", "(", "filenames", ",", "is_samples", ")", "\n", ")", "\n", "\n", "# Compute metrics", "\n", "", "compute_metrics", "(", "results", ",", "args", ".", "output_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.train.parse_arguments": [[16, 203], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "# parser.add_argument(", "\n", "#     \"-na\",", "\n", "#     \"--no_augmentation\",", "\n", "#     dest=\"augmentation\",", "\n", "#     action=\"store_false\",", "\n", "#     help=\"whether to disable data augmentation\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-pr\",", "\n", "#     \"--augmentation_pitch_range\",", "\n", "#     nargs=2,", "\n", "#     type=int,", "\n", "#     default=[5, 6],", "\n", "#     help=\"pitch augmentation range\",", "\n", "# )", "\n", "# parser.set_defaults(augmentation=True)", "\n", "# parser.add_argument(", "\n", "#     \"-sl\",", "\n", "#     \"--seq_len\",", "\n", "#     type=int,", "\n", "#     default=500,", "\n", "#     help=\"sequence length\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-ml\",", "\n", "#     \"--max_len\",", "\n", "#     type=int,", "\n", "#     default=2000,", "\n", "#     help=\"maximum sequence length for validation\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-bp\",", "\n", "#     \"--use_beat_postion\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use beat and position rather than time\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-di\",", "\n", "#     \"--use_duration\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use duration as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-fi\",", "\n", "#     \"--use_frequency\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use frequency as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-oh\",", "\n", "#     \"--use_onset_hint\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use onset hint as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-ph\",", "\n", "#     \"--use_pitch_hint\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use pitch hint as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-pe\",", "\n", "#     \"--use_pitch_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use pitch embedding\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-te\",", "\n", "#     \"--use_time_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use time embedding\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-be\",", "\n", "#     \"--use_beat_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use beat embedding\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-de\",", "\n", "#     \"--use_duration_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use duration embedding\",", "\n", "# )", "\n", "parser", ".", "add_argument", "(", "\n", "\"-r\"", ",", "\n", "\"--resolution\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "24", ",", "\n", "help", "=", "\"resolution (time step per quarter note)\"", ",", "\n", ")", "\n", "# parser.add_argument(", "\n", "#     \"-mt\",", "\n", "#     \"--max_time\",", "\n", "#     type=int,", "\n", "#     default=4096,", "\n", "#     help=\"maximum time\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-mb\",", "\n", "#     \"--max_beat\",", "\n", "#     type=int,", "\n", "#     default=4096,", "\n", "#     help=\"maximum number of beats\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-md\",", "\n", "#     \"--max_duration\",", "\n", "#     type=int,", "\n", "#     default=192,", "\n", "#     help=\"maximum duration\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-ar\",", "\n", "#     \"--autoregressive\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use autoregressive LSTM\",", "\n", "# )", "\n", "parser", ".", "add_argument", "(", "\n", "\"-bi\"", ",", "\n", "\"--bidirectional\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"use bidirectional LSTM\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-nl\"", ",", "\n", "\"--n_layers\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "3", ",", "\n", "help", "=", "\"number of layers\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-nu\"", ",", "\n", "\"--n_units\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "128", ",", "\n", "help", "=", "\"number of hidden units per layer\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-bs\"", ",", "\n", "\"--batch_size\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "16", ",", "\n", "help", "=", "\"batch size for training\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-e\"", ",", "\"--epoch\"", ",", "type", "=", "int", ",", "default", "=", "100", ",", "help", "=", "\"maximum number of epochs\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--steps_per_epoch\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "500", ",", "\n", "help", "=", "\"number of steps per epochs\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-p\"", ",", "\n", "\"--patience\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "5", ",", "\n", "help", "=", "\"patience for early stopping\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"-g\"", ",", "\"--gpu\"", ",", "type", "=", "int", ",", "help", "=", "\"GPU device to use\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.train.main": [[216, 355], ["train.parse_arguments", "parse_arguments.output_dir.mkdir", "tensorflow.config.list_physical_devices", "tensorflow.config.set_visible_devices", "tensorflow.config.experimental.set_memory_growth", "arranger.utils.setup_loggers", "tensorflow.get_logger().setLevel", "random.seed", "tensorflow.random.set_seed", "logging.info", "vars().items", "len", "logging.info", "numpy.concatenate", "numpy.concatenate", "tensorflow.data.Dataset.from_tensor_slices", "train_dataset.shuffle().repeat().batch().prefetch.shuffle().repeat().batch().prefetch", "logging.info", "numpy.concatenate", "numpy.concatenate", "tensorflow.data.Dataset.from_tensor_slices", "val_dataset.batch().prefetch.batch().prefetch", "logging.info", "tensorflow.keras.Sequential", "tf.keras.Sequential.add", "range", "tf.keras.Sequential.add", "sum", "sum", "logging.info", "logging.info", "logging.info", "logging.info", "logging.info", "tf.keras.Sequential.compile", "logging.info", "tensorflow.keras.callbacks.ModelCheckpoint", "tensorflow.keras.callbacks.CSVLogger", "tensorflow.keras.callbacks.EarlyStopping", "tf.keras.Sequential.fit", "logging.info", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "tensorflow.keras.Input", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "tensorflow.keras.layers.Dense", "tf.keras.Sequential.summary", "str", "str", "tensorflow.get_logger", "vars", "train_dataset.shuffle().repeat().batch().prefetch.shuffle().repeat().batch", "val_dataset.batch().prefetch.batch", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dropout", "tensorflow.keras.backend.count_params", "tensorflow.keras.backend.count_params", "tensorflow.keras.losses.SparseCategoricalCrossentropy", "pathlib.Path().with_suffix", "train_dataset.shuffle().repeat().batch().prefetch.shuffle().repeat", "pathlib.Path", "train_dataset.shuffle().repeat().batch().prefetch.shuffle"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Configure TensorFlow", "\n", "gpus", "=", "tf", ".", "config", ".", "list_physical_devices", "(", "\"GPU\"", ")", "\n", "tf", ".", "config", ".", "set_visible_devices", "(", "gpus", "[", "args", ".", "gpu", "]", ",", "\"GPU\"", ")", "\n", "tf", ".", "config", ".", "experimental", ".", "set_memory_growth", "(", "gpus", "[", "args", ".", "gpu", "]", ",", "True", ")", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "tf", ".", "get_logger", "(", ")", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "\n", "# Set random seeds", "\n", "random", ".", "seed", "(", "0", ")", "\n", "tf", ".", "random", ".", "set_seed", "(", "0", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# === Data ===", "\n", "\n", "# Get output shapes nad types", "\n", "", "n_tracks", "=", "len", "(", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"programs\"", "]", ")", "\n", "n_features", "=", "9", "+", "4", "*", "n_tracks", "\n", "# output_shapes = ({\"feature\": (n_features,)}, (1,))", "\n", "# output_types = ({\"feature\": tf.float32}, tf.int32)", "\n", "\n", "# Load training data", "\n", "logging", ".", "info", "(", "\"Loading training data...\"", ")", "\n", "train_data", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"feature_train.npz\"", ")", ")", "\n", "train_labels", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"label_train.npz\"", ")", ")", "\n", "\n", "train_dataset", "=", "tf", ".", "data", ".", "Dataset", ".", "from_tensor_slices", "(", "\n", "(", "train_data", ",", "train_labels", ")", "\n", ")", "\n", "# train_dataset = tf.data.Dataset.from_generator(", "\n", "#     lambda: loader(", "\n", "#         train_data, train_labels, n_tracks, args, training=True", "\n", "#     ),", "\n", "#     output_shapes=output_shapes,", "\n", "#     output_types=output_types,", "\n", "# )", "\n", "train_dataset", "=", "(", "\n", "train_dataset", ".", "shuffle", "(", "100", ")", ".", "repeat", "(", ")", ".", "batch", "(", "args", ".", "batch_size", ")", ".", "prefetch", "(", "3", ")", "\n", ")", "\n", "\n", "# Load validation data", "\n", "logging", ".", "info", "(", "\"Loading validation data...\"", ")", "\n", "val_data", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"feature_valid.npz\"", ")", ")", "\n", "val_labels", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"label_valid.npz\"", ")", ")", "\n", "val_dataset", "=", "tf", ".", "data", ".", "Dataset", ".", "from_tensor_slices", "(", "(", "val_data", ",", "val_labels", ")", ")", "\n", "# val_dataset = tf.data.Dataset.from_generator(", "\n", "#     lambda: loader(val_data, val_labels, n_tracks, args, training=False),", "\n", "#     output_shapes=output_shapes,", "\n", "#     output_types=output_types,", "\n", "# )", "\n", "val_dataset", "=", "val_dataset", ".", "batch", "(", "1", ")", ".", "prefetch", "(", "3", ")", "\n", "\n", "# === Model ===", "\n", "\n", "# Build the model", "\n", "logging", ".", "info", "(", "\"Building model...\"", ")", "\n", "\n", "# Inputs", "\n", "# inputs = {", "\n", "#     \"feature\": tf.keras.layers.Input(", "\n", "#         (n_features,), dtype=tf.float32, name=\"feature\"", "\n", "#     )", "\n", "# }", "\n", "model", "=", "tf", ".", "keras", ".", "Sequential", "(", ")", "\n", "model", ".", "add", "(", "tf", ".", "keras", ".", "Input", "(", "shape", "=", "(", "n_features", ",", ")", ")", ")", "\n", "for", "_", "in", "range", "(", "args", ".", "n_layers", ")", ":", "\n", "        ", "model", ".", "add", "(", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "args", ".", "n_units", ")", ")", "\n", "model", ".", "add", "(", "tf", ".", "keras", ".", "layers", ".", "Dropout", "(", "0.2", ")", ")", "\n", "", "model", ".", "add", "(", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "n_tracks", "+", "1", ")", ")", "\n", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "        ", "model", ".", "summary", "(", ")", "\n", "\n", "# Count variables", "\n", "", "n_trainables", "=", "sum", "(", "\n", "tf", ".", "keras", ".", "backend", ".", "count_params", "(", "w", ")", "for", "w", "in", "model", ".", "trainable_weights", "\n", ")", "\n", "n_nontrainables", "=", "sum", "(", "\n", "tf", ".", "keras", ".", "backend", ".", "count_params", "(", "w", ")", "for", "w", "in", "model", ".", "non_trainable_weights", "\n", ")", "\n", "logging", ".", "info", "(", "\"Model statistics:\"", ")", "\n", "logging", ".", "info", "(", "f\"- Total parameters : {n_trainables + n_nontrainables}\"", ")", "\n", "logging", ".", "info", "(", "f\"- Trainable parameters : {n_trainables}\"", ")", "\n", "logging", ".", "info", "(", "f\"- Nontrainable parameters : {n_nontrainables}\"", ")", "\n", "\n", "# Compile the model", "\n", "logging", ".", "info", "(", "\"Compiling model...\"", ")", "\n", "\n", "# def masked_acc(y_true, y_pred):", "\n", "#     accuracies = tf.equal(", "\n", "#         y_true, 1 + tf.cast(tf.argmax(y_pred[..., 1:], axis=2), tf.float32)", "\n", "#     )", "\n", "#     mask = tf.math.logical_not(tf.math.equal(y_true, 0))", "\n", "#     accuracies = tf.cast(tf.math.logical_and(mask, accuracies), tf.float32)", "\n", "#     mask = tf.cast(mask, tf.float32)", "\n", "#     return tf.reduce_sum(accuracies) / tf.reduce_sum(mask)", "\n", "\n", "model", ".", "compile", "(", "\n", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "SparseCategoricalCrossentropy", "(", "from_logits", "=", "True", ")", ",", "\n", "optimizer", "=", "\"adam\"", ",", "\n", "metrics", "=", "[", "\"acc\"", "]", ",", "\n", ")", "\n", "\n", "# === Training ===", "\n", "\n", "# Train the model", "\n", "logging", ".", "info", "(", "\"Training model...\"", ")", "\n", "model_checkpoint", "=", "tf", ".", "keras", ".", "callbacks", ".", "ModelCheckpoint", "(", "\n", "str", "(", "args", ".", "output_dir", "/", "\"best_model.hdf5\"", ")", ",", "\n", "save_best_only", "=", "True", ",", "\n", "save_weights_only", "=", "True", ",", "\n", ")", "\n", "csv_logger", "=", "tf", ".", "keras", ".", "callbacks", ".", "CSVLogger", "(", "\n", "str", "(", "args", ".", "output_dir", "/", "\"training.log\"", ")", "\n", ")", "\n", "early_stopping", "=", "tf", ".", "keras", ".", "callbacks", ".", "EarlyStopping", "(", "patience", "=", "args", ".", "patience", ")", "\n", "model", ".", "fit", "(", "\n", "train_dataset", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "epochs", "=", "args", ".", "epoch", ",", "\n", "steps_per_epoch", "=", "args", ".", "steps_per_epoch", ",", "\n", "validation_data", "=", "val_dataset", ",", "\n", "validation_batch_size", "=", "1", ",", "\n", "callbacks", "=", "[", "model_checkpoint", ",", "csv_logger", ",", "early_stopping", "]", ",", "\n", "verbose", "=", "(", "1", "-", "args", ".", "quiet", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.data.parse_arguments": [[19, 46], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.data.get_arrays": [[48, 128], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "enumerate", "numpy.zeros", "numpy.zeros", "zip", "enumerate", "zip", "collected.append", "len", "len", "numpy.abs", "numpy.abs", "numpy.abs"], "function", ["None"], ["", "def", "get_arrays", "(", "notes", ",", "labels", ",", "n_tracks", ",", "seq_len", ")", ":", "\n", "    ", "\"\"\"Process data and return as a dictionary of arrays.\"\"\"", "\n", "# Create a dictionary of arrays initialized to zeros", "\n", "data", "=", "{", "\n", "\"feature\"", ":", "np", ".", "zeros", "(", "(", "seq_len", ",", "9", "+", "4", "*", "n_tracks", ")", ",", "float", ")", ",", "\n", "\"label\"", ":", "np", ".", "zeros", "(", "(", "seq_len", ",", ")", ",", "int", ")", ",", "\n", "}", "\n", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "last_onsets", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "last_offsets", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "voice_active", "=", "np", ".", "zeros", "(", "n_tracks", ",", "bool", ")", "\n", "\n", "# Fill in data", "\n", "for", "i", ",", "(", "note", ",", "label", ")", "in", "enumerate", "(", "zip", "(", "notes", ",", "labels", ")", ")", ":", "\n", "# 0 - pitch", "\n", "        ", "data", "[", "\"feature\"", "]", "[", "i", ",", "0", "]", "=", "note", "[", "1", "]", "\n", "# 1 - duration", "\n", "data", "[", "\"feature\"", "]", "[", "i", ",", "1", "]", "=", "note", "[", "2", "]", "\n", "# 2 - isOrnamentation", "\n", "data", "[", "\"feature\"", "]", "[", "i", ",", "2", "]", "=", "note", "[", "2", "]", "<=", "6", "\n", "# 7 - metric position", "\n", "data", "[", "\"feature\"", "]", "[", "i", ",", "7", "]", "=", "note", "[", "2", "]", "%", "24", "\n", "\n", "# pitchProx", "\n", "data", "[", "\"feature\"", "]", "[", "i", ",", "9", ":", "9", "+", "n_tracks", "]", "=", "(", "\n", "np", ".", "abs", "(", "last_pitches", "-", "note", "[", "1", "]", ")", "*", "voice_active", "\n", ")", "-", "1", "*", "(", "1", "-", "voice_active", ")", "\n", "# interOnsetProx", "\n", "data", "[", "\"feature\"", "]", "[", "i", ",", "9", "+", "n_tracks", ":", "9", "+", "2", "*", "n_tracks", "]", "=", "(", "\n", "np", ".", "abs", "(", "last_onsets", "-", "note", "[", "0", "]", ")", "*", "voice_active", "\n", ")", "-", "1", "*", "(", "1", "-", "voice_active", ")", "\n", "# offsetOnsetProx", "\n", "data", "[", "\"feature\"", "]", "[", "i", ",", "9", "+", "2", "*", "n_tracks", ":", "9", "+", "3", "*", "n_tracks", "]", "=", "(", "\n", "np", ".", "abs", "(", "last_offsets", "-", "note", "[", "0", "]", ")", "*", "voice_active", "\n", ")", "-", "1", "*", "(", "1", "-", "voice_active", ")", "\n", "# voicesOccupied", "\n", "data", "[", "\"feature\"", "]", "[", "i", ",", "9", "+", "3", "*", "n_tracks", ":", "9", "+", "4", "*", "n_tracks", "]", "=", "(", "\n", "note", "[", "0", "]", "<", "last_offsets", "\n", ")", "*", "voice_active", "-", "1", "*", "(", "1", "-", "voice_active", ")", "\n", "\n", "# label", "\n", "data", "[", "\"label\"", "]", "[", "i", "]", "=", "label", "+", "1", "\n", "\n", "# update", "\n", "last_pitches", "[", "label", "]", "=", "note", "[", "1", "]", "\n", "last_onsets", "[", "label", "]", "=", "note", "[", "0", "]", "\n", "last_offsets", "[", "label", "]", "=", "note", "[", "0", "]", "+", "note", "[", "2", "]", "\n", "voice_active", "[", "label", "]", "=", "1", "\n", "\n", "# Iterate over the notes to find chords", "\n", "", "collected", "=", "[", "]", "\n", "last_collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# 3 - indexInChord", "\n", "            ", "data", "[", "\"feature\"", "]", "[", "note_idx", ",", "3", "]", "=", "idx", "\n", "# 6 - chordSize", "\n", "data", "[", "\"feature\"", "]", "[", "note_idx", ",", "6", "]", "=", "len", "(", "collected", ")", "\n", "", "for", "note_idx", ",", "nextnote_idx", "in", "zip", "(", "collected", "[", ":", "-", "1", "]", ",", "collected", "[", "1", ":", "]", ")", ":", "\n", "# 4 - pitchDistBelow", "\n", "            ", "data", "[", "\"feature\"", "]", "[", "nextnote_idx", ",", "4", "]", "=", "(", "\n", "notes", "[", "nextnote_idx", ",", "1", "]", "-", "notes", "[", "note_idx", ",", "1", "]", "\n", ")", "\n", "# 5 - pitchDistAbove", "\n", "data", "[", "\"feature\"", "]", "[", "note_idx", ",", "5", "]", "=", "(", "\n", "notes", "[", "nextnote_idx", ",", "1", "]", "-", "notes", "[", "note_idx", ",", "1", "]", "\n", ")", "\n", "\n", "", "for", "note_idx", "in", "last_collected", ":", "\n", "# 8 - numNotesNext", "\n", "            ", "data", "[", "\"feature\"", "]", "[", "note_idx", ",", "8", "]", "=", "len", "(", "collected", ")", "\n", "\n", "", "last_collected", "=", "collected", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.data.process": [[130, 166], ["muspy.load", "list", "len", "zip", "numpy.array", "numpy.array", "data.get_arrays", "[].keys", "list.index", "len", "random.sample", "np.array.append", "np.array.append", "sorted", "len", "range", "zip", "len", "operator.itemgetter"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.infer.get_arrays"], ["", "def", "process", "(", "filename", ",", "dataset", ",", "subset", ")", ":", "\n", "    ", "\"\"\"Process the data and return as a list of dictionary of arrays.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Get track names and number of tracks", "\n", "names", "=", "list", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ".", "keys", "(", ")", ")", "\n", "n_tracks", "=", "len", "(", "names", ")", "\n", "\n", "# Collect notes and labels", "\n", "notes", ",", "labels", "=", "[", "]", ",", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Get label", "\n", "", "label", "=", "names", ".", "index", "(", "track", ".", "name", ")", "\n", "# Collect notes and labels", "\n", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "\n", "# Sort the notes and labels (using notes as keys)", "\n", "", "", "notes", ",", "labels", "=", "zip", "(", "*", "sorted", "(", "zip", "(", "notes", ",", "labels", ")", ",", "key", "=", "itemgetter", "(", "0", ")", ")", ")", "\n", "notes", "=", "np", ".", "array", "(", "notes", ")", "\n", "labels", "=", "np", ".", "array", "(", "labels", ")", "\n", "\n", "# Set sequence length to number of notes by default", "\n", "arrays", "=", "get_arrays", "(", "notes", ",", "labels", ",", "n_tracks", ",", "len", "(", "notes", ")", ")", "\n", "\n", "if", "subset", "==", "\"valid\"", "and", "dataset", "==", "\"lmd\"", "and", "len", "(", "arrays", "[", "\"feature\"", "]", ")", ">", "100", ":", "\n", "        ", "indices", "=", "random", ".", "sample", "(", "range", "(", "len", "(", "arrays", "[", "\"feature\"", "]", ")", ")", ",", "100", ")", "\n", "arrays", "[", "\"feature\"", "]", "=", "arrays", "[", "\"feature\"", "]", "[", "indices", "]", "\n", "arrays", "[", "\"label\"", "]", "=", "arrays", "[", "\"label\"", "]", "[", "indices", "]", "\n", "\n", "", "return", "arrays", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.data.main": [[168, 232], ["data.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "random.seed", "logging.info", "vars().items", "logging.info", "logging.info", "list", "logging.info", "vars", "parse_arguments.input_dir.glob", "tqdm.tqdm", "numpy.savez", "open", "data.process", "joblib.Parallel", "f.write", "pathlib.Path().with_suffix", "data.append", "zip", "len", "joblib.delayed", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "", "features", "=", "[", "\"feature\"", ",", "\"label\"", "]", "\n", "\n", "# === Training data ===", "\n", "logging", ".", "info", "(", "\"Processing training data...\"", ")", "\n", "ext", "=", "\"json\"", "if", "args", ".", "dataset", "!=", "\"lmd\"", "else", "\"json.gz\"", "\n", "for", "subset", "in", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ":", "\n", "        ", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "glob", "(", "f\"{subset}/*.{ext}\"", ")", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "            ", "data", "=", "[", "]", "\n", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ":", "\n", "                ", "processed", "=", "process", "(", "filename", ",", "args", ".", "dataset", ",", "subset", ")", "\n", "if", "processed", "is", "not", "None", ":", "\n", "                    ", "data", ".", "append", "(", "\n", "{", "\"filename\"", ":", "filename", ".", "stem", ",", "\"arrays\"", ":", "processed", "}", "\n", ")", "\n", "\n", "", "", "", "else", ":", "\n", "            ", "results", "=", "joblib", ".", "Parallel", "(", "\n", "args", ".", "n_jobs", ",", "verbose", "=", "0", "if", "args", ".", "quiet", "else", "5", "\n", ")", "(", "\n", "joblib", ".", "delayed", "(", "process", ")", "(", "filename", ",", "args", ".", "dataset", ",", "subset", ")", "\n", "for", "filename", "in", "filenames", "\n", ")", "\n", "data", "=", "[", "\n", "{", "\"filename\"", ":", "filename", ".", "stem", ",", "\"arrays\"", ":", "result", "}", "\n", "for", "filename", ",", "result", "in", "zip", "(", "filenames", ",", "results", ")", "\n", "if", "result", "is", "not", "None", "\n", "]", "\n", "\n", "# Save arrays", "\n", "", "for", "name", "in", "features", ":", "\n", "            ", "np", ".", "savez", "(", "\n", "args", ".", "output_dir", "/", "f\"{name}_{subset}.npz\"", ",", "\n", "*", "[", "sample", "[", "\"arrays\"", "]", "[", "name", "]", "for", "sample", "in", "data", "]", ",", "\n", ")", "\n", "", "logging", ".", "info", "(", "\n", "f\"Successfully saved {len(data)} samples for subset : {subset}.\"", "\n", ")", "\n", "\n", "# Save filenames", "\n", "with", "open", "(", "args", ".", "output_dir", "/", "f\"filenames_{subset}.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "for", "sample", "in", "data", ":", "\n", "                ", "f", ".", "write", "(", "f\"{sample['filename']}\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.infer.parse_arguments": [[26, 178], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\"--states\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"use state array\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n", "", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.infer.get_arrays": [[180, 260], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "enumerate", "numpy.zeros", "numpy.zeros", "zip", "enumerate", "zip", "collected.append", "len", "len", "numpy.abs", "numpy.abs", "numpy.abs"], "function", ["None"], [")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "else", ":", "\n", "# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "process", "(", "filename", ",", "states", ",", "dataset", ",", "output_dir", ",", "save", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Get track names and number of tracks", "\n", "names", "=", "list", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ".", "keys", "(", ")", ")", "\n", "n_tracks", "=", "len", "(", "names", ")", "\n", "\n", "# Collect notes and labels", "\n", "notes", ",", "labels", "=", "[", "]", ",", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Get label", "\n", "", "label", "=", "names", ".", "index", "(", "track", ".", "name", ")", "\n", "# Collect notes and labels", "\n", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "\n", "# Sort the notes and labels (using notes as keys)", "\n", "", "", "notes", ",", "labels", "=", "zip", "(", "*", "sorted", "(", "zip", "(", "notes", ",", "labels", ")", ",", "key", "=", "itemgetter", "(", "0", ")", ")", ")", "\n", "\n", "# Convert lists to arrays for speed reason", "\n", "notes", "=", "np", ".", "array", "(", "notes", ",", "int", ")", "\n", "labels", "=", "np", ".", "array", "(", "labels", ",", "int", ")", "\n", "\n", "# Find the onset time for each track", "\n", "onsets", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_tracks", ")", ":", "\n", "        ", "nonzero", "=", "(", "labels", "==", "i", ")", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "onsets", ".", "append", "(", "nonzero", "[", "0", "]", "if", "nonzero", ".", "size", "else", "None", ")", "\n", "\n", "# Predict the labels", "\n", "", "predictions", "=", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", "\n", "\n", "# Return early if no need to save the sample", "\n", "if", "not", "save", ":", "\n", "        ", "return", "predictions", ",", "labels", "\n", "\n", "# Shorthands", "\n", "", "sample_dir", "=", "output_dir", "/", "\"samples\"", "\n", "programs", "=", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", "\n", "colors", "=", "CONFIG", "[", "\"colors\"", "]", "\n", "\n", "# Reconstruct and save the music using the predicted labels", "\n", "music_pred", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_pred", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "predictions", ",", "programs", ")", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred\"", ",", "colors", "\n", ")", "\n", "\n", "# Reconstruct and save the music using the original labels", "\n", "music_truth", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_truth", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "labels", ",", "programs", ")", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.infer.process": [[262, 387], ["muspy.load", "list", "len", "zip", "min", "numpy.array", "numpy.array", "infer.get_arrays", "numpy.argmax().flatten", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "arranger.utils.save_comparison", "[].keys", "list.index", "len", "model.predict", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "numpy.concatenate", "len", "len", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "arranger.utils.save_comparison", "np.array.append", "np.array.append", "sorted", "model.predict", "np.concatenate.append", "int", "numpy.argmax", "zip", "numpy.expand_dims", "raw_prediction[].argmax", "operator.itemgetter", "numpy.abs", "numpy.abs", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.infer.get_arrays", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict"], [")", "\n", "\n", "# Save comparison", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "pianoroll_pred", ",", "sample_dir", ",", "f\"{filename.stem}_comp\"", "\n", ")", "\n", "\n", "# Save the samples with drums", "\n", "if", "CONFIG", "[", "dataset", "]", "[", "\"has_drums\"", "]", ":", "\n", "        ", "music_pred", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred_drums\"", ",", "colors", "\n", ")", "\n", "music_truth", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n", "music_truth", ",", "sample_dir", ",", "f\"{filename.stem}_truth_drums\"", ",", "colors", "\n", ")", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "\n", "pianoroll_pred", ",", "\n", "sample_dir", ",", "\n", "f\"{filename.stem}_comp_drums\"", ",", "\n", ")", "\n", "\n", "", "return", "predictions", ",", "labels", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Make sure sample directories exist", "\n", "(", "args", ".", "output_dir", "/", "\"samples\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"json\"", ",", "\"mid\"", ",", "\"png\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "\"samples\"", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# Load sample filenames", "\n", "", "with", "open", "(", "args", ".", "input_dir", "/", "\"samples.txt\"", ")", "as", "f", ":", "\n", "        ", "sample_filenames", "=", "[", "line", ".", "rstrip", "(", ")", "for", "line", "in", "f", "]", "\n", "\n", "# Collect filenames", "\n", "", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "extension", "=", "\"json\"", "if", "args", ".", "dataset", "!=", "\"lmd\"", "else", "\"json.gz\"", "\n", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "glob", "(", "f\"test/*.{extension}\"", ")", ")", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "is_samples", "=", "(", "filename", ".", "stem", "in", "sample_filenames", "for", "filename", "in", "filenames", ")", "\n", "\n", "# Iterate over the test data", "\n", "logging", ".", "info", "(", "\"Start testing...\"", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "results", "=", "[", "\n", "process", "(", "\n", "filename", ",", "\n", "args", ".", "states", ",", "\n", "args", ".", "dataset", ",", "\n", "args", ".", "output_dir", ",", "\n", "is_sample", ",", "\n", ")", "\n", "for", "filename", ",", "is_sample", "in", "zip", "(", "\n", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ",", "is_samples", "\n", ")", "\n", "]", "\n", "", "else", ":", "\n", "        ", "results", "=", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process", ")", "(", "\n", "filename", ",", "\n", "args", ".", "states", ",", "\n", "args", ".", "dataset", ",", "\n", "args", ".", "output_dir", ",", "\n", "is_sample", ",", "\n", ")", "\n", "for", "filename", ",", "is_sample", "in", "zip", "(", "filenames", ",", "is_samples", ")", "\n", ")", "\n", "\n", "# Compute metrics", "\n", "", "compute_metrics", "(", "results", ",", "args", ".", "output_dir", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.salu133445_arranger.mlp.infer.main": [[389, 484], ["infer.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "tensorflow.get_logger().setLevel", "random.seed", "logging.info", "vars().items", "logging.info", "len", "tensorflow.keras.Sequential", "tf.keras.Sequential.add", "range", "tf.keras.Sequential.add", "logging.info", "logging.info", "arranger.utils.compute_metrics", "parse_arguments.output_dir.mkdir", "tensorflow.config.list_physical_devices", "tensorflow.config.set_visible_devices", "tensorflow.config.experimental.set_memory_growth", "logging.info", "tensorflow.keras.Input", "tf.keras.Sequential.add", "tensorflow.keras.layers.Dense", "tf.keras.Sequential.summary", "tf.keras.Sequential.load_weights", "open", "list", "infer.process", "tensorflow.get_logger", "vars", "tensorflow.keras.layers.Dense", "tf.keras.Sequential.load_weights", "tf.keras.Sequential.load_weights", "str", "line.rstrip", "parse_arguments.input_dir.glob", "tqdm.tqdm", "parse_arguments.input_dir.glob", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.compute_metrics", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], []], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.predict.parse_arguments": [[23, 189], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input filename or directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-of\"", ",", "\n", "\"--onsets_filename\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"onsets filename\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-a\"", ",", "\n", "\"--audio\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"whether to write audio\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--suffix\"", ",", "\n", "default", "=", "\"pred\"", ",", "\n", "help", "=", "\"suffix to the output filename(s)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n", "", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.predict.get_model": [[191, 242], ["len", "arranger.transformer.model.TransformerArranger", "arranger.transformer.model.TransformerArranger.", "tensorflow.keras.Model", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input"], "function", ["None"], ["# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "else", ":", "\n", "# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "predict", "(", "music", ",", "dataset", ",", "states", ",", "onsets", ")", ":", "\n", "    ", "\"\"\"Predict on a music.\"\"\"", "\n", "# Collect notes and labels", "\n", "notes", "=", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Collect notes and labels", "\n", "", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "\n", "# Sort the notes", "\n", "", "", "notes", ".", "sort", "(", ")", "\n", "\n", "# Convert lists to arrays for speed reason", "\n", "notes", "=", "np", ".", "array", "(", "notes", ",", "int", ")", "\n", "\n", "# Get number of tracks", "\n", "n_tracks", "=", "len", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ")", "\n", "\n", "# Predict the labels", "\n", "predictions", "=", "_predict", "(", "notes", ",", "np", ".", "asarray", "(", "onsets", ")", ",", "n_tracks", ",", "states", ")", "\n", "\n", "return", "notes", ",", "predictions", "\n", "\n", "\n", "", "def", "process", "(", "filename", ",", "args", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.predict.get_inputs": [[244, 271], ["len", "enumerate", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.asarray", "numpy.asarray", "numpy.expand_dims"], "function", ["None"], ["# Load onsets", "\n", "onsets", "=", "np", ".", "load", "(", "args", ".", "onsets_filename", ")", "\n", "\n", "# Get note and predicted labels", "\n", "notes", ",", "predictions", "=", "predict", "(", "music", ",", "args", ".", "dataset", ",", "args", ".", "states", ",", "onsets", ")", "\n", "\n", "# Shorthands", "\n", "programs", "=", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"programs\"", "]", "\n", "colors", "=", "CONFIG", "[", "\"colors\"", "]", "\n", "\n", "# Reconstruct and save the music using the predicted labels", "\n", "music_pred", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_pred", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "predictions", ",", "programs", ")", "\n", "save_sample_flat", "(", "\n", "music_pred", ",", "args", ".", "output_dir", ",", "f\"{filename.stem}_{args.suffix}\"", ",", "colors", "\n", ")", "\n", "if", "args", ".", "audio", ":", "\n", "        ", "muspy", ".", "write_audio", "(", "\n", "args", ".", "output_dir", "/", "f\"{filename.stem}_{args.suffix}.wav\"", ",", "music_pred", "\n", ")", "\n", "\n", "# Save the samples with drums", "\n", "", "if", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"has_drums\"", "]", ":", "\n", "        ", "music_pred", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "save_sample_flat", "(", "\n", "music_pred", ",", "\n", "args", ".", "output_dir", ",", "\n", "f\"{filename.stem}_{args.suffix}_drums\"", ",", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.predict.predict": [[273, 341], ["list", "len", "np.array.sort", "min", "numpy.array", "predict.get_inputs", "numpy.argmax().flatten", "[].keys", "len", "numpy.load", "numpy.load", "model.predict", "numpy.zeros", "range", "numpy.concatenate", "np.array.append", "get_inputs.items", "model.predict", "np.concatenate.append", "np.zeros.fill", "numpy.argmax", "int", "raw_prediction[].argmax"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.get_inputs", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict"], [")", "\n", "if", "args", ".", "audio", ":", "\n", "            ", "muspy", ".", "write_audio", "(", "\n", "args", ".", "output_dir", "/", "f\"{filename.stem}_{args.suffix}_drums.wav\"", ",", "\n", "music_pred", ",", "\n", ")", "\n", "\n", "", "", "return", "notes", ",", "predictions", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "\n", "# Check output directory", "\n", "if", "args", ".", "output_dir", "is", "not", "None", "and", "not", "args", ".", "output_dir", ".", "is_dir", "(", ")", ":", "\n", "        ", "raise", "NotADirectoryError", "(", "\"`output_dir` must be an existing directory.\"", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "debug", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "debug", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# Process the file", "\n", "", "if", "args", ".", "input", ".", "is_file", "(", ")", ":", "\n", "        ", "process", "(", "args", ".", "input", ",", "args", ")", "\n", "return", "\n", "\n", "# Collect filenames", "\n", "", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "filenames", "=", "list", "(", "args", ".", "input", ".", "glob", "(", "\"*.json\"", ")", ")", "\n", "assert", "filenames", ",", "\"No input files found. Only JSON files are supported.\"", "\n", "\n", "# Start inference", "\n", "logging", ".", "info", "(", "\"Start testing...\"", ")", "\n", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ":", "\n", "        ", "process", "(", "filename", ",", "args", ")", "\n", "\n", "\n", "", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.predict.process": [[343, 393], ["muspy.load", "predict.predict", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample_flat", "muspy.write_audio", "music.deepcopy.tracks.append", "arranger.utils.save_sample_flat", "muspy.write_audio"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio"], []], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.predict.main": [[395, 444], ["predict.parse_arguments", "arranger.utils.setup_loggers", "tensorflow.get_logger().setLevel", "logging.debug", "vars().items", "logging.info", "predict.get_model", "logging.info", "get_model.load_weights", "parse_arguments.input.is_file", "logging.info", "list", "logging.info", "tqdm.tqdm", "NotADirectoryError", "tensorflow.config.list_physical_devices", "tensorflow.config.set_visible_devices", "tensorflow.config.experimental.set_memory_growth", "logging.debug", "predict.process", "parse_arguments.input.glob", "predict.process", "parse_arguments.output_dir.is_dir", "tensorflow.get_logger", "vars", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.get_model", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], []], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.train.parse_arguments": [[17, 184], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "# parser.add_argument(", "\n", "#     \"-na\",", "\n", "#     \"--no_augmentation\",", "\n", "#     dest=\"augmentation\",", "\n", "#     action=\"store_false\",", "\n", "#     help=\"whether to disable data augmentation\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-pr\",", "\n", "#     \"--augmentation_pitch_range\",", "\n", "#     nargs=2,", "\n", "#     type=int,", "\n", "#     default=[5, 6],", "\n", "#     help=\"pitch augmentation range\",", "\n", "# )", "\n", "# parser.set_defaults(augmentation=True)", "\n", "# parser.add_argument(", "\n", "#     \"-sl\",", "\n", "#     \"--seq_len\",", "\n", "#     type=int,", "\n", "#     default=500,", "\n", "#     help=\"sequence length\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-ml\",", "\n", "#     \"--max_len\",", "\n", "#     type=int,", "\n", "#     default=2000,", "\n", "#     help=\"maximum sequence length for validation\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-bp\",", "\n", "#     \"--use_beat_postion\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use beat and position rather than time\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-di\",", "\n", "#     \"--use_duration\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use duration as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-fi\",", "\n", "#     \"--use_frequency\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use frequency as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-oh\",", "\n", "#     \"--use_onset_hint\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use onset hint as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-ph\",", "\n", "#     \"--use_pitch_hint\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use pitch hint as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-pe\",", "\n", "#     \"--use_pitch_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use pitch embedding\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-te\",", "\n", "#     \"--use_time_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use time embedding\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-be\",", "\n", "#     \"--use_beat_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use beat embedding\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-de\",", "\n", "#     \"--use_duration_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use duration embedding\",", "\n", "# )", "\n", "parser", ".", "add_argument", "(", "\n", "\"-r\"", ",", "\n", "\"--resolution\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "24", ",", "\n", "help", "=", "\"resolution (time step per quarter note)\"", ",", "\n", ")", "\n", "# parser.add_argument(", "\n", "#     \"-mt\",", "\n", "#     \"--max_time\",", "\n", "#     type=int,", "\n", "#     default=4096,", "\n", "#     help=\"maximum time\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-mb\",", "\n", "#     \"--max_beat\",", "\n", "#     type=int,", "\n", "#     default=4096,", "\n", "#     help=\"maximum number of beats\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-md\",", "\n", "#     \"--max_duration\",", "\n", "#     type=int,", "\n", "#     default=192,", "\n", "#     help=\"maximum duration\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-ar\",", "\n", "#     \"--autoregressive\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use autoregressive LSTM\",", "\n", "# )", "\n", "parser", ".", "add_argument", "(", "\n", "\"-bi\"", ",", "\n", "\"--bidirectional\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"use bidirectional LSTM\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-nl\"", ",", "\n", "\"--n_layers\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "3", ",", "\n", "help", "=", "\"number of layers\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-nu\"", ",", "\n", "\"--n_units\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "128", ",", "\n", "help", "=", "\"number of hidden units per layer\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-bs\"", ",", "\n", "\"--batch_size\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "16", ",", "\n", "help", "=", "\"batch size for training\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-e\"", ",", "\"--epoch\"", ",", "type", "=", "int", ",", "default", "=", "100", ",", "help", "=", "\"maximum number of epochs\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.train.loader": [[186, 249], ["random.sample", "range", "len", "range", "len", "len", "min", "numpy.zeros", "enumerate", "numpy.zeros", "range", "numpy.pad", "len", "len", "random.randint", "len", "random.randint", "numpy.nonzero", "numpy.pad", "len", "numpy.pad", "numpy.full_like"], "function", ["None"], ["\"--steps_per_epoch\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "500", ",", "\n", "help", "=", "\"number of steps per epochs\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-p\"", ",", "\n", "\"--patience\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "5", ",", "\n", "help", "=", "\"patience for early stopping\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"-g\"", ",", "\"--gpu\"", ",", "type", "=", "int", ",", "help", "=", "\"GPU device to use\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n", "# def loader(data, labels, n_tracks, args, training):", "\n", "#     \"\"\"Data loader.\"\"\"", "\n", "#     if training:", "\n", "#         indices = random.sample(range(len(labels)), len(labels))", "\n", "#     else:", "\n", "#         indices = range(len(labels))", "\n", "#     for i in indices:", "\n", "\n", "#         yield inputs, label", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Configure TensorFlow", "\n", "gpus", "=", "tf", ".", "config", ".", "list_physical_devices", "(", "\"GPU\"", ")", "\n", "tf", ".", "config", ".", "set_visible_devices", "(", "gpus", "[", "args", ".", "gpu", "]", ",", "\"GPU\"", ")", "\n", "tf", ".", "config", ".", "experimental", ".", "set_memory_growth", "(", "gpus", "[", "args", ".", "gpu", "]", ",", "True", ")", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "tf", ".", "get_logger", "(", ")", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "\n", "# Set random seeds", "\n", "random", ".", "seed", "(", "0", ")", "\n", "tf", ".", "random", ".", "set_seed", "(", "0", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# === Data ===", "\n", "\n", "# Get output shapes nad types", "\n", "", "n_tracks", "=", "len", "(", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"programs\"", "]", ")", "\n", "n_features", "=", "9", "+", "4", "*", "n_tracks", "\n", "# output_shapes = ({\"feature\": (n_features,)}, (1,))", "\n", "# output_types = ({\"feature\": tf.float32}, tf.int32)", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.train.main": [[251, 453], ["train.parse_arguments", "parse_arguments.output_dir.mkdir", "tensorflow.config.list_physical_devices", "tensorflow.config.set_visible_devices", "tensorflow.config.experimental.set_memory_growth", "arranger.utils.setup_loggers", "tensorflow.get_logger().setLevel", "random.seed", "tensorflow.random.set_seed", "logging.info", "vars().items", "len", "logging.info", "arranger.utils.load_npz", "tensorflow.data.Dataset.from_generator", "train_dataset.shuffle().repeat().batch().prefetch.shuffle().repeat().batch().prefetch", "logging.info", "arranger.utils.load_npz", "tensorflow.data.Dataset.from_generator", "val_dataset.batch().prefetch.batch().prefetch", "logging.info", "arranger.transformer.model.TransformerArranger", "arranger.transformer.model.TransformerArranger.", "tensorflow.keras.Model", "sum", "sum", "logging.info", "logging.info", "logging.info", "logging.info", "logging.info", "tf.keras.Model.compile", "logging.info", "tensorflow.keras.callbacks.ModelCheckpoint", "tensorflow.keras.callbacks.CSVLogger", "tensorflow.keras.callbacks.EarlyStopping", "tf.keras.Model.fit", "logging.info", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.equal", "tensorflow.math.logical_not", "tensorflow.cast", "tensorflow.cast", "str", "str", "tensorflow.get_logger", "vars", "train.loader", "train_dataset.shuffle().repeat().batch().prefetch.shuffle().repeat().batch", "train.loader", "val_dataset.batch().prefetch.batch", "tensorflow.keras.backend.count_params", "tensorflow.keras.backend.count_params", "tensorflow.math.equal", "tensorflow.math.logical_and", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.keras.losses.SparseCategoricalCrossentropy", "tensorflow.cast", "pathlib.Path().with_suffix", "train_dataset.shuffle().repeat().batch().prefetch.shuffle().repeat", "tensorflow.argmax", "pathlib.Path", "train_dataset.shuffle().repeat().batch().prefetch.shuffle"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.train.loader", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.train.loader"], ["# Load training data", "\n", "logging", ".", "info", "(", "\"Loading training data...\"", ")", "\n", "train_data", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"feature_train.npz\"", ")", ")", "\n", "train_labels", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"label_train.npz\"", ")", ")", "\n", "\n", "train_dataset", "=", "tf", ".", "data", ".", "Dataset", ".", "from_tensor_slices", "(", "\n", "(", "train_data", ",", "train_labels", ")", "\n", ")", "\n", "# train_dataset = tf.data.Dataset.from_generator(", "\n", "#     lambda: loader(", "\n", "#         train_data, train_labels, n_tracks, args, training=True", "\n", "#     ),", "\n", "#     output_shapes=output_shapes,", "\n", "#     output_types=output_types,", "\n", "# )", "\n", "train_dataset", "=", "(", "\n", "train_dataset", ".", "shuffle", "(", "100", ")", ".", "repeat", "(", ")", ".", "batch", "(", "args", ".", "batch_size", ")", ".", "prefetch", "(", "3", ")", "\n", ")", "\n", "\n", "# Load validation data", "\n", "logging", ".", "info", "(", "\"Loading validation data...\"", ")", "\n", "val_data", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"feature_valid.npz\"", ")", ")", "\n", "val_labels", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"label_valid.npz\"", ")", ")", "\n", "val_dataset", "=", "tf", ".", "data", ".", "Dataset", ".", "from_tensor_slices", "(", "(", "val_data", ",", "val_labels", ")", ")", "\n", "# val_dataset = tf.data.Dataset.from_generator(", "\n", "#     lambda: loader(val_data, val_labels, n_tracks, args, training=False),", "\n", "#     output_shapes=output_shapes,", "\n", "#     output_types=output_types,", "\n", "# )", "\n", "val_dataset", "=", "val_dataset", ".", "batch", "(", "1", ")", ".", "prefetch", "(", "3", ")", "\n", "\n", "# === Model ===", "\n", "\n", "# Build the model", "\n", "logging", ".", "info", "(", "\"Building model...\"", ")", "\n", "\n", "# Inputs", "\n", "# inputs = {", "\n", "#     \"feature\": tf.keras.layers.Input(", "\n", "#         (n_features,), dtype=tf.float32, name=\"feature\"", "\n", "#     )", "\n", "# }", "\n", "model", "=", "tf", ".", "keras", ".", "Sequential", "(", ")", "\n", "model", ".", "add", "(", "tf", ".", "keras", ".", "Input", "(", "shape", "=", "(", "n_features", ",", ")", ")", ")", "\n", "for", "_", "in", "range", "(", "args", ".", "n_layers", ")", ":", "\n", "        ", "model", ".", "add", "(", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "args", ".", "n_units", ")", ")", "\n", "model", ".", "add", "(", "tf", ".", "keras", ".", "layers", ".", "Dropout", "(", "0.2", ")", ")", "\n", "", "model", ".", "add", "(", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "n_tracks", "+", "1", ")", ")", "\n", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "        ", "model", ".", "summary", "(", ")", "\n", "\n", "# Count variables", "\n", "", "n_trainables", "=", "sum", "(", "\n", "tf", ".", "keras", ".", "backend", ".", "count_params", "(", "w", ")", "for", "w", "in", "model", ".", "trainable_weights", "\n", ")", "\n", "n_nontrainables", "=", "sum", "(", "\n", "tf", ".", "keras", ".", "backend", ".", "count_params", "(", "w", ")", "for", "w", "in", "model", ".", "non_trainable_weights", "\n", ")", "\n", "logging", ".", "info", "(", "\"Model statistics:\"", ")", "\n", "logging", ".", "info", "(", "f\"- Total parameters : {n_trainables + n_nontrainables}\"", ")", "\n", "logging", ".", "info", "(", "f\"- Trainable parameters : {n_trainables}\"", ")", "\n", "logging", ".", "info", "(", "f\"- Nontrainable parameters : {n_nontrainables}\"", ")", "\n", "\n", "# Compile the model", "\n", "logging", ".", "info", "(", "\"Compiling model...\"", ")", "\n", "\n", "# def masked_acc(y_true, y_pred):", "\n", "#     accuracies = tf.equal(", "\n", "#         y_true, 1 + tf.cast(tf.argmax(y_pred[..., 1:], axis=2), tf.float32)", "\n", "#     )", "\n", "#     mask = tf.math.logical_not(tf.math.equal(y_true, 0))", "\n", "#     accuracies = tf.cast(tf.math.logical_and(mask, accuracies), tf.float32)", "\n", "#     mask = tf.cast(mask, tf.float32)", "\n", "#     return tf.reduce_sum(accuracies) / tf.reduce_sum(mask)", "\n", "\n", "model", ".", "compile", "(", "\n", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "SparseCategoricalCrossentropy", "(", "from_logits", "=", "True", ")", ",", "\n", "optimizer", "=", "\"adam\"", ",", "\n", "metrics", "=", "[", "\"acc\"", "]", ",", "\n", ")", "\n", "\n", "# === Training ===", "\n", "\n", "# Train the model", "\n", "logging", ".", "info", "(", "\"Training model...\"", ")", "\n", "model_checkpoint", "=", "tf", ".", "keras", ".", "callbacks", ".", "ModelCheckpoint", "(", "\n", "str", "(", "args", ".", "output_dir", "/", "\"best_model.hdf5\"", ")", ",", "\n", "save_best_only", "=", "True", ",", "\n", "save_weights_only", "=", "True", ",", "\n", ")", "\n", "csv_logger", "=", "tf", ".", "keras", ".", "callbacks", ".", "CSVLogger", "(", "\n", "str", "(", "args", ".", "output_dir", "/", "\"training.log\"", ")", "\n", ")", "\n", "early_stopping", "=", "tf", ".", "keras", ".", "callbacks", ".", "EarlyStopping", "(", "patience", "=", "args", ".", "patience", ")", "\n", "model", ".", "fit", "(", "\n", "train_dataset", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "epochs", "=", "args", ".", "epoch", ",", "\n", "steps_per_epoch", "=", "args", ".", "steps_per_epoch", ",", "\n", "validation_data", "=", "val_dataset", ",", "\n", "validation_batch_size", "=", "1", ",", "\n", "callbacks", "=", "[", "model_checkpoint", ",", "csv_logger", ",", "early_stopping", "]", ",", "\n", "verbose", "=", "(", "1", "-", "args", ".", "quiet", ")", ",", "\n", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.infer.parse_arguments": [[27, 174], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\"--states\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"use state array\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n", "", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.infer.get_arrays": [[176, 219], ["len", "enumerate", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "numpy.zeros", "range", "numpy.expand_dims", "numpy.nonzero", "numpy.nonzero", "round", "numpy.mean", "numpy.full_like"], "function", ["None"], ["", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "else", ":", "\n", "# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "process", "(", "filename", ",", "states", ",", "dataset", ",", "output_dir", ",", "save", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Get track names and number of tracks", "\n", "names", "=", "list", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ".", "keys", "(", ")", ")", "\n", "n_tracks", "=", "len", "(", "names", ")", "\n", "\n", "# Collect notes and labels", "\n", "notes", ",", "labels", "=", "[", "]", ",", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Get label", "\n", "", "label", "=", "names", ".", "index", "(", "track", ".", "name", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.infer.process": [[221, 322], ["muspy.load", "list", "len", "zip", "min", "numpy.array", "numpy.array", "infer.get_arrays", "numpy.argmax().flatten", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "arranger.utils.save_comparison", "[].keys", "list.index", "len", "model.predict", "numpy.zeros", "range", "numpy.concatenate", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "arranger.utils.save_comparison", "np.array.append", "np.array.append", "sorted", "len", "get_arrays.items", "model.predict", "np.concatenate.append", "np.zeros.fill", "numpy.argmax", "zip", "operator.itemgetter", "int", "raw_prediction[].argmax"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.infer.get_arrays", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict"], ["for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "\n", "# Sort the notes and labels (using notes as keys)", "\n", "", "", "notes", ",", "labels", "=", "zip", "(", "*", "sorted", "(", "zip", "(", "notes", ",", "labels", ")", ",", "key", "=", "itemgetter", "(", "0", ")", ")", ")", "\n", "\n", "# Convert lists to arrays for speed reason", "\n", "notes", "=", "np", ".", "array", "(", "notes", ",", "int", ")", "\n", "labels", "=", "np", ".", "array", "(", "labels", ",", "int", ")", "\n", "\n", "# Find the onset time for each track", "\n", "onsets", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_tracks", ")", ":", "\n", "        ", "nonzero", "=", "(", "labels", "==", "i", ")", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "onsets", ".", "append", "(", "nonzero", "[", "0", "]", "if", "nonzero", ".", "size", "else", "None", ")", "\n", "\n", "# Predict the labels", "\n", "", "predictions", "=", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", "\n", "\n", "# Return early if no need to save the sample", "\n", "if", "not", "save", ":", "\n", "        ", "return", "predictions", ",", "labels", "\n", "\n", "# Shorthands", "\n", "", "sample_dir", "=", "output_dir", "/", "\"samples\"", "\n", "programs", "=", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", "\n", "colors", "=", "CONFIG", "[", "\"colors\"", "]", "\n", "\n", "# Reconstruct and save the music using the predicted labels", "\n", "music_pred", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_pred", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "predictions", ",", "programs", ")", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred\"", ",", "colors", "\n", ")", "\n", "\n", "# Reconstruct and save the music using the original labels", "\n", "music_truth", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_truth", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "labels", ",", "programs", ")", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n", "music_truth", ",", "sample_dir", ",", "f\"{filename.stem}_truth\"", ",", "colors", "\n", ")", "\n", "\n", "# Save comparison", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "pianoroll_pred", ",", "sample_dir", ",", "f\"{filename.stem}_comp\"", "\n", ")", "\n", "\n", "# Save the samples with drums", "\n", "if", "CONFIG", "[", "dataset", "]", "[", "\"has_drums\"", "]", ":", "\n", "        ", "music_pred", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred_drums\"", ",", "colors", "\n", ")", "\n", "music_truth", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n", "music_truth", ",", "sample_dir", ",", "f\"{filename.stem}_truth_drums\"", ",", "colors", "\n", ")", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "\n", "pianoroll_pred", ",", "\n", "sample_dir", ",", "\n", "f\"{filename.stem}_comp_drums\"", ",", "\n", ")", "\n", "\n", "", "return", "predictions", ",", "labels", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Make sure sample directories exist", "\n", "(", "args", ".", "output_dir", "/", "\"samples\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"json\"", ",", "\"mid\"", ",", "\"png\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "\"samples\"", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# Load sample filenames", "\n", "", "with", "open", "(", "args", ".", "input_dir", "/", "\"samples.txt\"", ")", "as", "f", ":", "\n", "        ", "sample_filenames", "=", "[", "line", ".", "rstrip", "(", ")", "for", "line", "in", "f", "]", "\n", "\n", "# Collect filenames", "\n", "", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "extension", "=", "\"json\"", "if", "args", ".", "dataset", "!=", "\"lmd\"", "else", "\"json.gz\"", "\n", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "glob", "(", "f\"test/*.{extension}\"", ")", ")", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "is_samples", "=", "(", "filename", ".", "stem", "in", "sample_filenames", "for", "filename", "in", "filenames", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.infer.main": [[324, 455], ["infer.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "tensorflow.get_logger().setLevel", "random.seed", "logging.info", "vars().items", "logging.info", "len", "arranger.transformer.model.TransformerArranger", "arranger.transformer.model.TransformerArranger.", "tensorflow.keras.Model", "logging.info", "logging.info", "arranger.utils.compute_metrics", "parse_arguments.output_dir.mkdir", "tensorflow.config.list_physical_devices", "tensorflow.config.set_visible_devices", "tensorflow.config.experimental.set_memory_growth", "logging.info", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tf.keras.Model.load_weights", "open", "list", "infer.process", "tensorflow.get_logger", "vars", "tf.keras.Model.load_weights", "tf.keras.Model.load_weights", "str", "line.rstrip", "len", "parse_arguments.input_dir.glob", "zip", "parse_arguments.input_dir.glob", "tqdm.tqdm", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.compute_metrics", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["logging", ".", "info", "(", "\"Start testing...\"", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "results", "=", "[", "\n", "process", "(", "\n", "filename", ",", "\n", "args", ".", "states", ",", "\n", "args", ".", "dataset", ",", "\n", "args", ".", "output_dir", ",", "\n", "is_sample", ",", "\n", ")", "\n", "for", "filename", ",", "is_sample", "in", "zip", "(", "\n", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ",", "is_samples", "\n", ")", "\n", "]", "\n", "", "else", ":", "\n", "        ", "results", "=", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process", ")", "(", "\n", "filename", ",", "\n", "args", ".", "states", ",", "\n", "args", ".", "dataset", ",", "\n", "args", ".", "output_dir", ",", "\n", "is_sample", ",", "\n", ")", "\n", "for", "filename", ",", "is_sample", "in", "zip", "(", "filenames", ",", "is_samples", ")", "\n", ")", "\n", "\n", "# Compute metrics", "\n", "", "compute_metrics", "(", "results", ",", "args", ".", "output_dir", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.MultiHeadAttention.__init__": [[78, 92], ["super().__init__", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense"], "methods", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.__init__"], ["def", "__init__", "(", "self", ",", "d_model", ",", "num_heads", ")", ":", "\n", "        ", "super", "(", "MultiHeadAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "self", ".", "d_model", "=", "d_model", "\n", "\n", "assert", "d_model", "%", "self", ".", "num_heads", "==", "0", "\n", "\n", "self", ".", "depth", "=", "d_model", "//", "self", ".", "num_heads", "\n", "\n", "self", ".", "wq", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", "\n", "self", ".", "wk", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", "\n", "self", ".", "wv", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", "\n", "\n", "self", ".", "dense", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.MultiHeadAttention.split_heads": [[93, 99], ["tensorflow.reshape", "tensorflow.transpose"], "methods", ["None"], ["", "def", "split_heads", "(", "self", ",", "x", ",", "batch_size", ")", ":", "# noqa", "\n", "        ", "\"\"\"Split the last dimension into (num_heads, depth). Transpose the\n        result such that the shape is (batch_size, num_heads, seq_len, depth).\n        \"\"\"", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "(", "batch_size", ",", "-", "1", ",", "self", ".", "num_heads", ",", "self", ".", "depth", ")", ")", "\n", "return", "tf", ".", "transpose", "(", "x", ",", "perm", "=", "[", "0", ",", "2", ",", "1", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.MultiHeadAttention.call": [[100, 136], ["model.MultiHeadAttention.wq", "model.MultiHeadAttention.wk", "model.MultiHeadAttention.wv", "model.MultiHeadAttention.split_heads", "model.MultiHeadAttention.split_heads", "model.MultiHeadAttention.split_heads", "model.scaled_dot_product_attention", "tensorflow.transpose", "tensorflow.reshape", "model.MultiHeadAttention.dense", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.MultiHeadAttention.split_heads", "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.MultiHeadAttention.split_heads", "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.MultiHeadAttention.split_heads", "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.scaled_dot_product_attention"], ["", "def", "call", "(", "self", ",", "v", ",", "k", ",", "q", ",", "mask", ")", ":", "# noqa", "\n", "        ", "batch_size", "=", "tf", ".", "shape", "(", "q", ")", "[", "0", "]", "\n", "\n", "q", "=", "self", ".", "wq", "(", "q", ")", "# (batch_size, seq_len, d_model)", "\n", "k", "=", "self", ".", "wk", "(", "k", ")", "# (batch_size, seq_len, d_model)", "\n", "v", "=", "self", ".", "wv", "(", "v", ")", "# (batch_size, seq_len, d_model)", "\n", "\n", "q", "=", "self", ".", "split_heads", "(", "\n", "q", ",", "batch_size", "\n", ")", "# (batch_size, num_heads, seq_len_q, depth)", "\n", "k", "=", "self", ".", "split_heads", "(", "\n", "k", ",", "batch_size", "\n", ")", "# (batch_size, num_heads, seq_len_k, depth)", "\n", "v", "=", "self", ".", "split_heads", "(", "\n", "v", ",", "batch_size", "\n", ")", "# (batch_size, num_heads, seq_len_v, depth)", "\n", "\n", "# scaled_attention -> (batch_size, num_heads, seq_len_q, depth)", "\n", "# attention_weights -> (batch_size, num_heads, seq_len_q, seq_len_k)", "\n", "scaled_attention", ",", "attention_weights", "=", "scaled_dot_product_attention", "(", "\n", "q", ",", "k", ",", "v", ",", "mask", "\n", ")", "\n", "\n", "scaled_attention", "=", "tf", ".", "transpose", "(", "\n", "scaled_attention", ",", "perm", "=", "[", "0", ",", "2", ",", "1", ",", "3", "]", "\n", ")", "# (batch_size, seq_len_q, num_heads, depth)", "\n", "\n", "concat_attention", "=", "tf", ".", "reshape", "(", "\n", "scaled_attention", ",", "(", "batch_size", ",", "-", "1", ",", "self", ".", "d_model", ")", "\n", ")", "# (batch_size, seq_len_q, d_model)", "\n", "\n", "output", "=", "self", ".", "dense", "(", "\n", "concat_attention", "\n", ")", "# (batch_size, seq_len_q, d_model)", "\n", "\n", "return", "output", ",", "attention_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.TransformerLayer.__init__": [[153, 164], ["super().__init__", "model.MultiHeadAttention", "model.point_wise_feed_forward_network", "tensorflow.keras.layers.LayerNormalization", "tensorflow.keras.layers.LayerNormalization", "tensorflow.keras.layers.Dropout", "tensorflow.keras.layers.Dropout"], "methods", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.__init__", "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.point_wise_feed_forward_network"], ["def", "__init__", "(", "self", ",", "d_model", ",", "num_heads", ",", "dff", ",", "rate", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "mha", "=", "MultiHeadAttention", "(", "d_model", ",", "num_heads", ")", "\n", "self", ".", "ffn", "=", "point_wise_feed_forward_network", "(", "d_model", ",", "dff", ")", "\n", "\n", "self", ".", "layernorm1", "=", "tf", ".", "keras", ".", "layers", ".", "LayerNormalization", "(", "epsilon", "=", "1e-6", ")", "\n", "self", ".", "layernorm2", "=", "tf", ".", "keras", ".", "layers", ".", "LayerNormalization", "(", "epsilon", "=", "1e-6", ")", "\n", "\n", "self", ".", "dropout1", "=", "tf", ".", "keras", ".", "layers", ".", "Dropout", "(", "rate", ")", "\n", "self", ".", "dropout2", "=", "tf", ".", "keras", ".", "layers", ".", "Dropout", "(", "rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.TransformerLayer.call": [[165, 181], ["model.TransformerLayer.mha", "model.TransformerLayer.dropout1", "model.TransformerLayer.layernorm1", "model.TransformerLayer.ffn", "model.TransformerLayer.dropout2", "model.TransformerLayer.layernorm2"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ",", "training", ",", "mask", ")", ":", "# noqa", "\n", "        ", "attn_output", ",", "_", "=", "self", ".", "mha", "(", "\n", "x", ",", "x", ",", "x", ",", "mask", "\n", ")", "# (batch_size, input_seq_len, d_model)", "\n", "attn_output", "=", "self", ".", "dropout1", "(", "attn_output", ",", "training", "=", "training", ")", "\n", "out1", "=", "self", ".", "layernorm1", "(", "\n", "x", "+", "attn_output", "\n", ")", "# (batch_size, input_seq_len, d_model)", "\n", "\n", "ffn_output", "=", "self", ".", "ffn", "(", "out1", ")", "# (batch_size, input_seq_len, d_model)", "\n", "ffn_output", "=", "self", ".", "dropout2", "(", "ffn_output", ",", "training", "=", "training", ")", "\n", "out2", "=", "self", ".", "layernorm2", "(", "\n", "out1", "+", "ffn_output", "\n", ")", "# (batch_size, input_seq_len, d_model)", "\n", "\n", "return", "out2", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.InputLayer.__init__": [[186, 250], ["super().__init__", "tensorflow.keras.layers.Embedding", "tensorflow.keras.layers.Embedding", "tensorflow.keras.layers.Embedding", "tensorflow.keras.layers.Embedding", "numpy.pad", "numpy.pad.max", "tensorflow.keras.layers.Embedding", "model.positional_encoding", "numpy.expand_dims", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.__init__", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.positional_encoding"], ["def", "__init__", "(", "\n", "self", ",", "\n", "max_len", ":", "int", ",", "\n", "use_duration", ":", "bool", ",", "\n", "use_frequency", ":", "bool", ",", "\n", "use_onset_hint", ":", "bool", ",", "\n", "use_pitch_hint", ":", "bool", ",", "\n", "use_pitch_embedding", ":", "bool", ",", "\n", "use_time_embedding", ":", "bool", ",", "\n", "use_duration_embedding", ":", "bool", ",", "\n", "max_beat", ":", "int", ",", "\n", "max_duration", ":", "int", ",", "\n", "n_tracks", ":", "int", ",", "\n", "use_lookahead_mask", ":", "bool", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "max_len", "=", "max_len", "\n", "self", ".", "use_duration", "=", "use_duration", "\n", "self", ".", "use_frequency", "=", "use_frequency", "\n", "self", ".", "use_onset_hint", "=", "use_onset_hint", "\n", "self", ".", "use_pitch_hint", "=", "use_pitch_hint", "\n", "self", ".", "use_pitch_embedding", "=", "use_pitch_embedding", "\n", "self", ".", "use_time_embedding", "=", "use_time_embedding", "\n", "self", ".", "use_duration_embedding", "=", "use_duration_embedding", "\n", "self", ".", "max_beat", "=", "max_beat", "\n", "self", ".", "max_duration", "=", "max_duration", "\n", "self", ".", "n_tracks", "=", "n_tracks", "\n", "self", ".", "use_lookahead_mask", "=", "use_lookahead_mask", "\n", "\n", "# Embedding", "\n", "if", "use_pitch_embedding", ":", "\n", "            ", "self", ".", "pitch_embedding", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "129", ",", "16", ",", "name", "=", "\"pitch_embedding\"", "\n", ")", "\n", "", "if", "use_time_embedding", ":", "\n", "            ", "self", ".", "time_embedding_position", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "24", ",", "16", ",", "name", "=", "\"time_embedding_position\"", "\n", ")", "\n", "self", ".", "time_embedding_beat", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "max_beat", "+", "1", ",", "\n", "16", ",", "\n", "weights", "=", "[", "positional_encoding", "(", "max_beat", "+", "1", ",", "16", ")", "]", ",", "\n", "trainable", "=", "False", ",", "\n", "name", "=", "\"time_embedding_beat\"", ",", "\n", ")", "\n", "", "if", "use_duration", "and", "use_duration_embedding", ":", "\n", "            ", "self", ".", "duration_embedding", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "max_duration", "+", "1", ",", "16", ",", "name", "=", "\"duration_embedding\"", "\n", ")", "\n", "\n", "# Frequency matrix", "\n", "", "if", "use_frequency", ":", "\n", "            ", "frequency_matrix", "=", "440.0", "*", "2", "**", "(", "(", "np", ".", "arange", "(", "128", ")", "-", "69", ")", "/", "12", ")", "\n", "frequency_matrix", "=", "np", ".", "pad", "(", "frequency_matrix", ",", "(", "1", ",", "0", ")", ")", "\n", "frequency_matrix", "/=", "frequency_matrix", ".", "max", "(", ")", "\n", "self", ".", "frequency_mapping", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "129", ",", "\n", "1", ",", "\n", "weights", "=", "[", "np", ".", "expand_dims", "(", "frequency_matrix", ",", "-", "1", ")", "]", ",", "\n", "trainable", "=", "False", ",", "\n", "name", "=", "\"frequency_mapping\"", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "frequency_mapping", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.InputLayer.call": [[251, 333], ["tensorflow.concat", "tensorflow.cast", "tensorflow.shape", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "range", "tensorflow.equal", "tensorflow.tile", "tensorflow.maximum", "model.InputLayer.pitch_embedding", "tensorflow.expand_dims", "model.InputLayer.time_embedding_position", "model.InputLayer.time_embedding_beat", "tensorflow.expand_dims", "tensors.append", "tensors.append", "model.InputLayer.frequency_mapping", "tensorflow.cast", "tensors.append", "tensorflow.linalg.band_part", "tensorflow.cast", "tensorflow.clip_by_value", "tensorflow.cast", "model.InputLayer.duration_embedding", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.ones", "tensorflow.clip_by_value", "tensorflow.cast", "model.InputLayer.pitch_embedding", "tensorflow.shape", "tensorflow.expand_dims"], "methods", ["None"], ["", "", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Apply the layer to the input tensors.\n\n        Parameters\n        ----------\n        inputs : dict of Tensor\n            Input tensors.\n\n            - time : shape=(batch_size, seq_len)\n            - pitch : shape=(batch_size, seq_len)\n            - duration : shape=(batch_size, seq_len), optional\n            - onset_hint : shape=(batch_size, n_tracks), optional\n            - pitch_hint : shape=(batch_size, n_tracks), optional\n\n        \"\"\"", "\n", "# Collect input tensors", "\n", "seq_len", "=", "tf", ".", "shape", "(", "inputs", "[", "\"time\"", "]", ")", "[", "1", "]", "\n", "tensors", "=", "[", "]", "\n", "if", "self", ".", "use_pitch_embedding", ":", "\n", "            ", "tensors", ".", "append", "(", "self", ".", "pitch_embedding", "(", "inputs", "[", "\"pitch\"", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "tensors", ".", "append", "(", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "cast", "(", "inputs", "[", "\"pitch\"", "]", ",", "tf", ".", "float32", ")", ",", "-", "1", ")", "\n", ")", "\n", "\n", "", "if", "self", ".", "use_time_embedding", ":", "\n", "            ", "tensors", ".", "append", "(", "self", ".", "time_embedding_position", "(", "inputs", "[", "\"time\"", "]", "%", "24", ")", ")", "\n", "tensors", ".", "append", "(", "\n", "self", ".", "time_embedding_beat", "(", "\n", "tf", ".", "clip_by_value", "(", "inputs", "[", "\"time\"", "]", "//", "24", ",", "0", ",", "self", ".", "max_beat", ")", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "tensors", ".", "append", "(", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "cast", "(", "inputs", "[", "\"time\"", "]", ",", "tf", ".", "float32", ")", ",", "-", "1", ")", "\n", ")", "\n", "", "if", "self", ".", "use_duration", ":", "\n", "            ", "if", "self", ".", "use_duration_embedding", ":", "\n", "                ", "tensors", ".", "append", "(", "\n", "self", ".", "duration_embedding", "(", "\n", "tf", ".", "clip_by_value", "(", "\n", "inputs", "[", "\"duration\"", "]", ",", "0", ",", "self", ".", "max_duration", "\n", ")", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "tensors", ".", "append", "(", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "cast", "(", "inputs", "[", "\"duration\"", "]", ",", "tf", ".", "float32", ")", ",", "-", "1", ")", "\n", ")", "\n", "", "", "if", "self", ".", "use_frequency", ":", "\n", "            ", "tensors", ".", "append", "(", "self", ".", "frequency_mapping", "(", "inputs", "[", "\"pitch\"", "]", ")", ")", "\n", "", "if", "self", ".", "use_onset_hint", ":", "\n", "            ", "tensors", ".", "append", "(", "tf", ".", "cast", "(", "inputs", "[", "\"onset_hint\"", "]", ",", "tf", ".", "float32", ")", ")", "\n", "", "if", "self", ".", "use_pitch_hint", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "n_tracks", ")", ":", "\n", "                ", "tensors", ".", "append", "(", "\n", "tf", ".", "tile", "(", "\n", "self", ".", "pitch_embedding", "(", "\n", "tf", ".", "expand_dims", "(", "inputs", "[", "\"pitch_hint\"", "]", "[", "...", ",", "i", "]", ",", "1", ")", "\n", ")", ",", "\n", "(", "1", ",", "seq_len", ",", "1", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "# Concate features", "\n", "", "", "tensor_out", "=", "tf", ".", "concat", "(", "tensors", ",", "-", "1", ")", "\n", "\n", "# Create mask", "\n", "mask", "=", "tf", ".", "cast", "(", "tf", ".", "equal", "(", "inputs", "[", "\"pitch\"", "]", ",", "0", ")", ",", "tf", ".", "float32", ")", "\n", "mask", "=", "mask", "[", ":", ",", "tf", ".", "newaxis", ",", "tf", ".", "newaxis", ",", ":", "]", "\n", "\n", "if", "self", ".", "use_lookahead_mask", ":", "\n", "            ", "look_ahead_mask", "=", "1", "-", "tf", ".", "linalg", ".", "band_part", "(", "\n", "tf", ".", "ones", "(", "(", "seq_len", ",", "seq_len", ")", ")", ",", "-", "1", ",", "0", "\n", ")", "\n", "look_ahead_mask", "=", "tf", ".", "tile", "(", "\n", "look_ahead_mask", "[", "tf", ".", "newaxis", ",", "tf", ".", "newaxis", ",", ":", ",", ":", "]", ",", "\n", "[", "tf", ".", "shape", "(", "inputs", "[", "\"time\"", "]", ")", "[", "0", "]", ",", "1", ",", "1", ",", "1", "]", ",", "\n", ")", "\n", "mask", "=", "tf", ".", "maximum", "(", "mask", ",", "look_ahead_mask", ")", "\n", "\n", "", "return", "tensor_out", ",", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.Transformer.__init__": [[338, 365], ["super().__init__", "model.positional_encoding", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dropout", "model.TransformerLayer", "range"], "methods", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.__init__", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.positional_encoding"], ["def", "__init__", "(", "\n", "self", ",", "\n", "autoregressive", ":", "bool", ",", "\n", "max_len", ":", "int", ",", "\n", "n_layers", ":", "int", ",", "\n", "d_model", ":", "int", ",", "\n", "n_heads", ":", "int", ",", "\n", "d_feedforward", ":", "int", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "autoregressive", "=", "autoregressive", "\n", "self", ".", "max_len", "=", "max_len", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "n_heads", "=", "n_heads", "\n", "self", ".", "d_feedforward", "=", "d_feedforward", "\n", "\n", "# Positional embedding", "\n", "self", ".", "positional_encoding", "=", "positional_encoding", "(", "max_len", ",", "d_model", ")", "\n", "self", ".", "positional_encoding", "=", "self", ".", "positional_encoding", "[", "tf", ".", "newaxis", ",", ":", "]", "\n", "\n", "self", ".", "dense_in", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", "\n", "self", ".", "transformers", "=", "[", "\n", "TransformerLayer", "(", "d_model", ",", "n_heads", ",", "d_feedforward", ",", "rate", "=", "0.2", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", "\n", "]", "\n", "self", ".", "dropout", "=", "tf", ".", "keras", ".", "layers", ".", "Dropout", "(", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.Transformer.call": [[366, 373], ["model.Transformer.dense_in", "model.Transformer.dropout", "transformer", "tensorflow.shape"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ",", "training", "=", "False", ",", "mask", "=", "None", ")", ":", "# noqa", "\n", "        ", "x", "=", "self", ".", "dense_in", "(", "x", ")", "\n", "x", "+=", "self", ".", "positional_encoding", "[", ":", ",", ":", "tf", ".", "shape", "(", "x", ")", "[", "1", "]", ",", ":", "]", "\n", "x", "=", "self", ".", "dropout", "(", "x", ",", "training", "=", "training", ")", "\n", "for", "transformer", "in", "self", ".", "transformers", ":", "\n", "            ", "x", "=", "transformer", "(", "x", ",", "mask", "=", "mask", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.TransformerArranger.__init__": [[378, 440], ["super().__init__", "model.InputLayer", "model.Transformer", "tensorflow.keras.layers.Dense"], "methods", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "max_len", ":", "int", ",", "\n", "use_duration", ":", "bool", ",", "\n", "use_frequency", ":", "bool", ",", "\n", "use_onset_hint", ":", "bool", ",", "\n", "use_pitch_hint", ":", "bool", ",", "\n", "use_pitch_embedding", ":", "bool", ",", "\n", "use_time_embedding", ":", "bool", ",", "\n", "use_duration_embedding", ":", "bool", ",", "\n", "max_beat", ":", "int", ",", "\n", "max_duration", ":", "int", ",", "\n", "use_lookahead_mask", ":", "bool", ",", "\n", "autoregressive", ":", "bool", ",", "\n", "n_tracks", ":", "int", ",", "\n", "n_layers", ":", "int", ",", "\n", "d_model", ":", "int", ",", "\n", "n_heads", ":", "int", ",", "\n", "d_feedforward", ":", "int", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "max_len", "=", "max_len", "\n", "self", ".", "use_duration", "=", "use_duration", "\n", "self", ".", "use_frequency", "=", "use_frequency", "\n", "self", ".", "use_onset_hint", "=", "use_onset_hint", "\n", "self", ".", "use_pitch_hint", "=", "use_pitch_hint", "\n", "self", ".", "use_pitch_embedding", "=", "use_pitch_embedding", "\n", "self", ".", "use_time_embedding", "=", "use_time_embedding", "\n", "self", ".", "use_duration_embedding", "=", "use_duration_embedding", "\n", "self", ".", "max_beat", "=", "max_beat", "\n", "self", ".", "max_duration", "=", "max_duration", "\n", "self", ".", "use_lookahead_mask", "=", "use_lookahead_mask", "\n", "self", ".", "autoregressive", "=", "autoregressive", "\n", "self", ".", "n_tracks", "=", "n_tracks", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "n_heads", "=", "n_heads", "\n", "self", ".", "d_feedforward", "=", "d_feedforward", "\n", "\n", "self", ".", "input_layer", "=", "InputLayer", "(", "\n", "max_len", "=", "max_len", ",", "\n", "use_duration", "=", "use_duration", ",", "\n", "use_frequency", "=", "use_frequency", ",", "\n", "use_onset_hint", "=", "use_onset_hint", ",", "\n", "use_pitch_hint", "=", "use_pitch_hint", ",", "\n", "use_pitch_embedding", "=", "use_pitch_embedding", ",", "\n", "use_time_embedding", "=", "use_time_embedding", ",", "\n", "use_duration_embedding", "=", "use_duration_embedding", ",", "\n", "max_beat", "=", "max_beat", ",", "\n", "max_duration", "=", "max_duration", ",", "\n", "n_tracks", "=", "n_tracks", ",", "\n", "use_lookahead_mask", "=", "use_lookahead_mask", ",", "\n", ")", "\n", "self", ".", "transformer", "=", "Transformer", "(", "\n", "autoregressive", "=", "autoregressive", ",", "\n", "max_len", "=", "max_len", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "d_model", "=", "d_model", ",", "\n", "n_heads", "=", "n_heads", ",", "\n", "d_feedforward", "=", "d_feedforward", ",", "\n", ")", "\n", "self", ".", "dense", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "n_tracks", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.TransformerArranger.call": [[441, 449], ["model.TransformerArranger.input_layer", "model.TransformerArranger.transformer", "model.TransformerArranger.dense", "tensorflow.concat", "tensorflow.cast"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ",", "training", "=", "False", ",", "mask", "=", "None", ")", ":", "# noqa", "\n", "        ", "x", ",", "mask", "=", "self", ".", "input_layer", "(", "inputs", ")", "\n", "if", "self", ".", "autoregressive", ":", "\n", "            ", "x", "=", "tf", ".", "concat", "(", "\n", "(", "x", ",", "tf", ".", "cast", "(", "inputs", "[", "\"previous_label\"", "]", ",", "tf", ".", "float32", ")", ")", ",", "-", "1", "\n", ")", "\n", "", "x", "=", "self", ".", "transformer", "(", "x", ",", "training", "=", "training", ",", "mask", "=", "mask", ")", "\n", "return", "self", ".", "dense", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.get_angles": [[8, 12], ["numpy.power", "numpy.float32"], "function", ["None"], ["def", "get_angles", "(", "pos", ",", "i", ",", "d_model", ")", ":", "\n", "    ", "\"\"\"Copied from https://www.tensorflow.org/tutorials/text/transformer .\"\"\"", "\n", "angle_rates", "=", "1", "/", "np", ".", "power", "(", "10000", ",", "(", "2", "*", "(", "i", "//", "2", ")", ")", "/", "np", ".", "float32", "(", "d_model", ")", ")", "\n", "return", "pos", "*", "angle_rates", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.positional_encoding": [[14, 29], ["model.get_angles", "numpy.sin", "numpy.cos", "tensorflow.cast", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.get_angles"], ["", "def", "positional_encoding", "(", "position", ",", "d_model", ")", ":", "\n", "    ", "\"\"\"Copied from https://www.tensorflow.org/tutorials/text/transformer .\"\"\"", "\n", "pos_encoding", "=", "get_angles", "(", "\n", "np", ".", "arange", "(", "position", ")", "[", ":", ",", "np", ".", "newaxis", "]", ",", "\n", "np", ".", "arange", "(", "d_model", ")", "[", "np", ".", "newaxis", ",", ":", "]", ",", "\n", "d_model", ",", "\n", ")", "\n", "\n", "# apply sin to even indices in the array; 2i", "\n", "pos_encoding", "[", ":", ",", "0", ":", ":", "2", "]", "=", "np", ".", "sin", "(", "pos_encoding", "[", ":", ",", "0", ":", ":", "2", "]", ")", "\n", "\n", "# apply cos to odd indices in the array; 2i+1", "\n", "pos_encoding", "[", ":", ",", "1", ":", ":", "2", "]", "=", "np", ".", "cos", "(", "pos_encoding", "[", ":", ",", "1", ":", ":", "2", "]", ")", "\n", "\n", "return", "tf", ".", "cast", "(", "pos_encoding", ",", "dtype", "=", "tf", ".", "float32", ")", "# pylint: disable=all", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.scaled_dot_product_attention": [[31, 73], ["tensorflow.matmul", "tensorflow.cast", "tensorflow.nn.softmax", "tensorflow.matmul", "tensorflow.math.sqrt", "tensorflow.shape"], "function", ["None"], ["", "def", "scaled_dot_product_attention", "(", "q", ",", "k", ",", "v", ",", "mask", ")", ":", "# noqa", "\n", "    ", "\"\"\"Calculate the attention weights.\n\n    q, k, v must have matching leading dimensions.\n    k, v must have matching penultimate dimension, i.e.: seq_len_k = seq_len_v.\n    The mask has different shapes depending on its type(padding or look ahead)\n    but it must be broadcastable for addition.\n\n    Args:\n        q: query shape == (..., seq_len_q, depth)\n        k: key shape == (..., seq_len_k, depth)\n        v: value shape == (..., seq_len_v, depth_v)\n        mask: Float tensor with shape broadcastable\n            to (..., seq_len_q, seq_len_k). Defaults to None.\n\n    Returns:\n        output, attention_weights\n\n    Copied from https://www.tensorflow.org/tutorials/text/transformer .\n    \"\"\"", "\n", "\n", "matmul_qk", "=", "tf", ".", "matmul", "(", "\n", "q", ",", "k", ",", "transpose_b", "=", "True", "\n", ")", "# (..., seq_len_q, seq_len_k)", "\n", "\n", "# scale matmul_qk", "\n", "dk", "=", "tf", ".", "cast", "(", "tf", ".", "shape", "(", "k", ")", "[", "-", "1", "]", ",", "tf", ".", "float32", ")", "\n", "scaled_attention_logits", "=", "matmul_qk", "/", "tf", ".", "math", ".", "sqrt", "(", "dk", ")", "\n", "\n", "# add the mask to the scaled tensor.", "\n", "if", "mask", "is", "not", "None", ":", "\n", "        ", "scaled_attention_logits", "+=", "mask", "*", "-", "1e9", "\n", "\n", "# softmax is normalized on the last axis (seq_len_k) so that the scores", "\n", "# add up to 1.", "\n", "", "attention_weights", "=", "tf", ".", "nn", ".", "softmax", "(", "\n", "scaled_attention_logits", ",", "axis", "=", "-", "1", "\n", ")", "# (..., seq_len_q, seq_len_k)", "\n", "\n", "output", "=", "tf", ".", "matmul", "(", "attention_weights", ",", "v", ")", "# (..., seq_len_q, depth_v)", "\n", "\n", "return", "output", ",", "attention_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.transformer.model.point_wise_feed_forward_network": [[138, 146], ["tensorflow.keras.Sequential", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense"], "function", ["None"], ["", "", "def", "point_wise_feed_forward_network", "(", "d_model", ",", "dff", ")", ":", "\n", "    ", "\"\"\"Copied from https://www.tensorflow.org/tutorials/text/transformer .\"\"\"", "\n", "return", "tf", ".", "keras", ".", "Sequential", "(", "\n", "[", "\n", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "\n", "dff", ",", "activation", "=", "\"relu\"", "\n", ")", ",", "# (batch_size, seq_len, dff)", "\n", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", ",", "# (batch_size, seq_len, d_model)", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.learn.parse_arguments": [[18, 48], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-p\"", ",", "\"--permutation\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"consider permutation\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.learn._nonincreasing_sequences": [[50, 57], ["range", "range", "len", "learn._nonincreasing_sequences"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.learn._nonincreasing_sequences"], ["", "def", "_nonincreasing_sequences", "(", "seq_len", ",", "n", ",", "seq", ")", ":", "\n", "    ", "if", "seq_len", "-", "len", "(", "seq", ")", ">", "1", ":", "\n", "        ", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "yield", "from", "_nonincreasing_sequences", "(", "seq_len", ",", "i", "+", "1", ",", "seq", "+", "(", "i", ",", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "yield", "seq", "+", "(", "i", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.learn.nonincreasing_sequences": [[59, 66], ["range", "range", "learn._nonincreasing_sequences"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.learn._nonincreasing_sequences"], ["", "", "", "def", "nonincreasing_sequences", "(", "seq_len", ",", "n", ")", ":", "\n", "    ", "\"\"\"Yield nonincreasing sequences of a fixed length with values < n.\"\"\"", "\n", "if", "seq_len", ">", "1", ":", "\n", "        ", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "yield", "from", "_nonincreasing_sequences", "(", "seq_len", ",", "i", "+", "1", ",", "(", "i", ",", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "yield", "from", "range", "(", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.learn.compute_score": [[68, 76], ["zip", "numpy.sum"], "function", ["None"], ["", "", "def", "compute_score", "(", "counts", ",", "boundaries", ",", "permutation", ")", ":", "\n", "    ", "\"\"\"Compute the score for the given zone boundaries and permutation.\"\"\"", "\n", "score", "=", "0", "\n", "uppers", "=", "(", "128", ",", ")", "+", "boundaries", "\n", "lowers", "=", "boundaries", "+", "(", "0", ",", ")", "\n", "for", "upper", ",", "lower", ",", "label", "in", "zip", "(", "uppers", ",", "lowers", ",", "permutation", ")", ":", "\n", "        ", "score", "+=", "np", ".", "sum", "(", "counts", "[", "label", "]", "[", "lower", ":", "upper", "]", ")", "\n", "", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.learn.find_optimal_zone": [[78, 90], ["learn.nonincreasing_sequences", "len", "learn.compute_score"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.learn.nonincreasing_sequences", "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.compute_score"], ["", "def", "find_optimal_zone", "(", "counts", ",", "permutations", ")", ":", "\n", "    ", "\"\"\"Find the optimal zone boundaries and permutation.\"\"\"", "\n", "max_score", "=", "0", "\n", "optimal_boundaries", ",", "optimal_permutation", "=", "None", ",", "None", "\n", "for", "boundaries", "in", "nonincreasing_sequences", "(", "len", "(", "counts", ")", "-", "1", ",", "128", ")", ":", "\n", "        ", "for", "permutation", "in", "permutations", ":", "\n", "            ", "score", "=", "compute_score", "(", "counts", ",", "boundaries", ",", "permutation", ")", "\n", "if", "score", ">", "max_score", ":", "\n", "                ", "max_score", "=", "score", "\n", "optimal_boundaries", "=", "boundaries", "\n", "optimal_permutation", "=", "permutation", "\n", "", "", "", "return", "optimal_boundaries", ",", "optimal_permutation", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.learn.process": [[92, 116], ["muspy.load", "list", "len", "numpy.zeros", "[].keys", "list.index", "numpy.bincount"], "function", ["None"], ["", "def", "process", "(", "filename", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Get track names", "\n", "names", "=", "list", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ".", "keys", "(", ")", ")", "\n", "\n", "# Get number of tracks", "\n", "n_tracks", "=", "len", "(", "names", ")", "\n", "\n", "# Collect pitch counts", "\n", "counts", "=", "np", ".", "zeros", "(", "(", "n_tracks", ",", "128", ")", ",", "int", ")", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Get label", "\n", "", "label", "=", "names", ".", "index", "(", "track", ".", "name", ")", "\n", "# Collect pitch counts", "\n", "pitches", "=", "[", "note", ".", "pitch", "for", "note", "in", "track", "]", "\n", "counts", "[", "label", "]", "=", "np", ".", "bincount", "(", "pitches", ",", "minlength", "=", "128", ")", "\n", "\n", "", "return", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.learn.main": [[118, 172], ["learn.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "logging.info", "vars().items", "logging.info", "list", "len", "learn.find_optimal_zone", "numpy.savetxt", "logging.info", "numpy.savetxt", "logging.info", "logging.info", "parse_arguments.input_dir.glob", "sum", "sum", "tuple", "vars", "itertools.permutations", "tuple", "learn.process", "joblib.Parallel", "range", "range", "pathlib.Path().with_suffix", "tqdm.tqdm", "joblib.delayed", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.find_optimal_zone", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Make sure sample directories exist", "\n", "(", "args", ".", "output_dir", "/", "\"samples\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"json\"", ",", "\"mid\"", ",", "\"png\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "\"samples\"", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# Iterate over the training data", "\n", "", "logging", ".", "info", "(", "\"Start learning...\"", ")", "\n", "extension", "=", "\"json\"", "if", "args", ".", "dataset", "!=", "\"lmd\"", "else", "\"json.gz\"", "\n", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "glob", "(", "f\"train/*.{extension}\"", ")", ")", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "counts", "=", "sum", "(", "\n", "process", "(", "filename", ",", "args", ".", "dataset", ")", "\n", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", "\n", ")", "\n", "", "else", ":", "\n", "        ", "counts", "=", "sum", "(", "\n", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process", ")", "(", "filename", ",", "args", ".", "dataset", ")", "\n", "for", "filename", "in", "filenames", "\n", ")", "\n", ")", "\n", "\n", "# Get permutations", "\n", "", "n_tracks", "=", "len", "(", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"programs\"", "]", ")", "\n", "if", "args", ".", "permutation", ":", "\n", "        ", "permutations", "=", "tuple", "(", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "permutations", "=", "(", "tuple", "(", "range", "(", "n_tracks", ")", ")", ",", ")", "\n", "\n", "# Find the optimal zone boundaries and permutation", "\n", "", "boundaries", ",", "permutation", "=", "find_optimal_zone", "(", "counts", ",", "permutations", ")", "\n", "np", ".", "savetxt", "(", "args", ".", "output_dir", "/", "\"optimal_boundaries.txt\"", ",", "boundaries", ")", "\n", "logging", ".", "info", "(", "f\"Optimal boundaries are : {boundaries}\"", ")", "\n", "np", ".", "savetxt", "(", "args", ".", "output_dir", "/", "\"optimal_permutation.txt\"", ",", "permutation", ")", "\n", "logging", ".", "info", "(", "f\"Optimal permutation is : {permutation}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.predict.parse_arguments": [[21, 71], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["\n", "def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input filename or directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-of\"", ",", "\n", "\"--onsets_filename\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"onsets filename\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-a\"", ",", "\n", "\"--audio\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"whether to write audio\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--suffix\"", ",", "\n", "default", "=", "\"pred\"", ",", "\n", "help", "=", "\"suffix to the output filename(s)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n", "", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.predict._nonincreasing": [[73, 80], ["range", "range", "len", "predict._nonincreasing"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.zone.infer._nonincreasing"], ["", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.predict.nonincreasing": [[82, 89], ["range", "range", "predict._nonincreasing"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.zone.infer._nonincreasing"], ["", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.predict.compute_score": [[91, 99], ["zip", "numpy.sum"], "function", ["None"], ["# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.predict.find_optimal_zone": [[101, 113], ["predict.nonincreasing", "len", "predict.compute_score"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.zone.infer.nonincreasing", "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.compute_score"], ["# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.predict._predict": [[115, 124], ["numpy.zeros", "zip", "len", "list", "list", "numpy.logical_and"], "function", ["None"], ["            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.predict.predict": [[126, 148], ["np.array.sort", "numpy.array", "predict._predict", "np.array.append"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.zone.predict._predict"], ["# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.predict.process": [[150, 193], ["muspy.load", "numpy.loadtxt", "numpy.loadtxt", "predict.predict", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample_flat", "muspy.write_audio", "music.deepcopy.tracks.append", "arranger.utils.save_sample_flat", "muspy.write_audio"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio"], ["for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.predict.main": [[195, 229], ["predict.parse_arguments", "arranger.utils.setup_loggers", "logging.debug", "vars().items", "parse_arguments.input.is_file", "logging.info", "list", "logging.info", "tqdm.tqdm", "NotADirectoryError", "logging.debug", "predict.process", "parse_arguments.input.glob", "predict.process", "parse_arguments.output_dir.is_dir", "vars", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "", "else", ":", "\n", "# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "predict", "(", "music", ",", "dataset", ",", "states", ",", "onsets", ")", ":", "\n", "    ", "\"\"\"Predict on a music.\"\"\"", "\n", "# Collect notes and labels", "\n", "notes", "=", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Collect notes and labels", "\n", "", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "\n", "# Sort the notes", "\n", "", "", "notes", ".", "sort", "(", ")", "\n", "\n", "# Convert lists to arrays for speed reason", "\n", "notes", "=", "np", ".", "array", "(", "notes", ",", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.infer.parse_arguments": [[26, 59], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\"--states\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"use state array\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n", "", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.infer._nonincreasing": [[61, 68], ["range", "range", "len", "infer._nonincreasing"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.zone.infer._nonincreasing"], ["# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.infer.nonincreasing": [[70, 77], ["range", "range", "infer._nonincreasing"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.zone.infer._nonincreasing"], ["                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.infer.compute_score": [[79, 87], ["zip", "numpy.sum"], "function", ["None"], ["", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.infer.find_optimal_zone": [[89, 101], ["infer.nonincreasing", "len", "infer.compute_score"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.zone.infer.nonincreasing", "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.compute_score"], ["", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.infer.predict": [[103, 112], ["numpy.zeros", "zip", "len", "list", "list", "numpy.logical_and"], "function", ["None"], ["for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.infer.process": [[114, 216], ["muspy.load", "list", "len", "numpy.zeros", "zip", "numpy.array", "numpy.array", "infer.predict", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "arranger.utils.save_comparison", "[].keys", "list.index", "numpy.bincount", "min", "max", "tuple", "infer.find_optimal_zone", "numpy.loadtxt", "numpy.loadtxt", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "arranger.utils.save_comparison", "min", "max", "np.array.append", "np.array.append", "sorted", "itertools.permutations", "tuple", "zip", "range", "range", "operator.itemgetter"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison", "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.find_optimal_zone", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison"], ["# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "else", ":", "\n", "# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "process", "(", "filename", ",", "states", ",", "dataset", ",", "output_dir", ",", "save", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Get track names and number of tracks", "\n", "names", "=", "list", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ".", "keys", "(", ")", ")", "\n", "n_tracks", "=", "len", "(", "names", ")", "\n", "\n", "# Collect notes and labels", "\n", "notes", ",", "labels", "=", "[", "]", ",", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.zone.infer.main": [[218, 298], ["infer.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "logging.info", "vars().items", "logging.info", "logging.info", "arranger.utils.compute_metrics", "parse_arguments.output_dir.mkdir", "logging.info", "open", "list", "vars", "line.rstrip", "len", "parse_arguments.input_dir.glob", "infer.process", "joblib.Parallel", "parse_arguments.input_dir.glob", "zip", "pathlib.Path().with_suffix", "tqdm.tqdm", "joblib.delayed", "zip", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.compute_metrics", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["# Get label", "\n", "", "label", "=", "names", ".", "index", "(", "track", ".", "name", ")", "\n", "# Collect notes and labels", "\n", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "\n", "# Sort the notes and labels (using notes as keys)", "\n", "", "", "notes", ",", "labels", "=", "zip", "(", "*", "sorted", "(", "zip", "(", "notes", ",", "labels", ")", ",", "key", "=", "itemgetter", "(", "0", ")", ")", ")", "\n", "\n", "# Convert lists to arrays for speed reason", "\n", "notes", "=", "np", ".", "array", "(", "notes", ",", "int", ")", "\n", "labels", "=", "np", ".", "array", "(", "labels", ",", "int", ")", "\n", "\n", "# Find the onset time for each track", "\n", "onsets", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_tracks", ")", ":", "\n", "        ", "nonzero", "=", "(", "labels", "==", "i", ")", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "onsets", ".", "append", "(", "nonzero", "[", "0", "]", "if", "nonzero", ".", "size", "else", "None", ")", "\n", "\n", "# Predict the labels", "\n", "", "predictions", "=", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", "\n", "\n", "# Return early if no need to save the sample", "\n", "if", "not", "save", ":", "\n", "        ", "return", "predictions", ",", "labels", "\n", "\n", "# Shorthands", "\n", "", "sample_dir", "=", "output_dir", "/", "\"samples\"", "\n", "programs", "=", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", "\n", "colors", "=", "CONFIG", "[", "\"colors\"", "]", "\n", "\n", "# Reconstruct and save the music using the predicted labels", "\n", "music_pred", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_pred", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "predictions", ",", "programs", ")", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred\"", ",", "colors", "\n", ")", "\n", "\n", "# Reconstruct and save the music using the original labels", "\n", "music_truth", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_truth", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "labels", ",", "programs", ")", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n", "music_truth", ",", "sample_dir", ",", "f\"{filename.stem}_truth\"", ",", "colors", "\n", ")", "\n", "\n", "# Save comparison", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "pianoroll_pred", ",", "sample_dir", ",", "f\"{filename.stem}_comp\"", "\n", ")", "\n", "\n", "# Save the samples with drums", "\n", "if", "CONFIG", "[", "dataset", "]", "[", "\"has_drums\"", "]", ":", "\n", "        ", "music_pred", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred_drums\"", ",", "colors", "\n", ")", "\n", "music_truth", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n", "music_truth", ",", "sample_dir", ",", "f\"{filename.stem}_truth_drums\"", ",", "colors", "\n", ")", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "\n", "pianoroll_pred", ",", "\n", "sample_dir", ",", "\n", "f\"{filename.stem}_comp_drums\"", ",", "\n", ")", "\n", "\n", "", "return", "predictions", ",", "labels", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Make sure sample directories exist", "\n", "(", "args", ".", "output_dir", "/", "\"samples\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"json\"", ",", "\"mid\"", ",", "\"png\"", ")", ":", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_musicnet.parse_arguments": [[26, 53], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--samples\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "\"maximum number of samples\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_musicnet.get_instrument": [[55, 68], ["name.lower", "name.lower", "name.lower", "name.lower"], "function", ["None"], ["", "def", "get_instrument", "(", "name", ")", ":", "\n", "    ", "\"\"\"Return the instrument inferred from the track name.\"\"\"", "\n", "if", "\"viola\"", "in", "name", ".", "lower", "(", ")", ":", "\n", "        ", "return", "\"Viola\"", "\n", "", "if", "\"cello\"", "in", "name", ".", "lower", "(", ")", ":", "\n", "        ", "return", "\"Cello\"", "\n", "", "for", "key", "in", "(", "\"1st\"", ",", "\"violin 1\"", ",", "\"violin1\"", ",", "\"violino i\"", ")", ":", "\n", "        ", "if", "key", "in", "name", ".", "lower", "(", ")", ":", "\n", "            ", "return", "\"Violin 1\"", "\n", "", "", "for", "key", "in", "(", "\"2nd\"", ",", "\"violin 2\"", ",", "\"violin2\"", ",", "\"violino ii\"", ")", ":", "\n", "        ", "if", "key", "in", "name", ".", "lower", "(", ")", ":", "\n", "            ", "return", "\"Violin 2\"", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_musicnet.process": [[70, 123], ["muspy.read", "muspy.read.adjust_resolution", "enumerate", "list", "notes[].sort", "sum", "muspy.Track", "muspy.read.tracks.append", "collect_musicnet.get_instrument", "note_dict.values", "str", "operator.attrgetter", "notes[].append", "notes[].append", "len", "notes.values"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.data.collect_lmd.get_instrument"], ["", "def", "process", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Process a file and return the processed music.\"\"\"", "\n", "# Read the file", "\n", "music", "=", "muspy", ".", "read", "(", "filename", ")", "\n", "\n", "# Return None if no track is found", "\n", "if", "not", "music", ".", "tracks", ":", "\n", "        ", "return", "None", "\n", "\n", "# Adjust resolution to 24 time steps per quarter note", "\n", "", "music", ".", "adjust_resolution", "(", "24", ")", "\n", "\n", "# Collect notes", "\n", "notes", "=", "{", "\"Violin 1\"", ":", "[", "]", ",", "\"Violin 2\"", ":", "[", "]", ",", "\"Viola\"", ":", "[", "]", ",", "\"Cello\"", ":", "[", "]", "}", "\n", "if", "filename", ".", "stem", "in", "SPECIAL_FILES", ":", "\n", "        ", "instruments", "=", "SPECIAL_FILES", "[", "str", "(", "filename", ".", "stem", ")", "]", "\n", "for", "i", ",", "track", "in", "enumerate", "(", "music", ".", "tracks", ")", ":", "\n", "            ", "for", "note", "in", "track", ".", "notes", ":", "\n", "                ", "if", "note", ".", "duration", ">", "0", ":", "\n", "                    ", "notes", "[", "instruments", "[", "i", "]", "]", ".", "append", "(", "note", ")", "\n", "", "", "", "", "else", ":", "\n", "        ", "for", "track", "in", "music", ".", "tracks", ":", "\n", "            ", "instrument", "=", "get_instrument", "(", "track", ".", "name", ")", "\n", "if", "instrument", "is", "None", ":", "\n", "                ", "continue", "\n", "", "for", "note", "in", "track", ".", "notes", ":", "\n", "                ", "if", "note", ".", "duration", ">", "0", ":", "\n", "                    ", "notes", "[", "instrument", "]", ".", "append", "(", "note", ")", "\n", "\n", "# Remove duplicate notes", "\n", "", "", "", "", "for", "name", "in", "notes", ":", "\n", "        ", "note_dict", "=", "{", "}", "\n", "for", "note", "in", "notes", "[", "name", "]", ":", "\n", "            ", "note_dict", "[", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ")", "]", "=", "note", "\n", "", "notes", "[", "name", "]", "=", "list", "(", "note_dict", ".", "values", "(", ")", ")", "\n", "notes", "[", "name", "]", ".", "sort", "(", "key", "=", "operator", ".", "attrgetter", "(", "\"time\"", ",", "\"pitch\"", ",", "\"duration\"", ")", ")", "\n", "\n", "# Skip the file if there are less than two active tracks", "\n", "", "if", "sum", "(", "(", "len", "(", "v", ")", ">", "10", "for", "v", "in", "notes", ".", "values", "(", ")", ")", ")", "<", "2", ":", "\n", "        ", "return", "None", "\n", "\n", "# Update tracks", "\n", "", "music", ".", "tracks", "=", "[", "]", "\n", "for", "name", "in", "notes", ":", "\n", "        ", "track", "=", "muspy", ".", "Track", "(", "\n", "name", "=", "name", ",", "\n", "program", "=", "CONFIG", "[", "\"musicnet\"", "]", "[", "\"programs\"", "]", "[", "name", "]", ",", "\n", "is_drum", "=", "False", ",", "\n", "notes", "=", "notes", "[", "name", "]", ",", "\n", ")", "\n", "music", ".", "tracks", ".", "append", "(", "track", ")", "\n", "\n", "", "return", "music", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_musicnet.process_and_save": [[125, 137], ["collect_musicnet.process", "process.save", "filename.with_suffix"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "process_and_save", "(", "filename", ",", "output_dir", ",", "split", ")", ":", "\n", "    ", "\"\"\"Process a file and save the processed music.\"\"\"", "\n", "# Process file", "\n", "music", "=", "process", "(", "filename", ")", "\n", "\n", "if", "music", "is", "None", ":", "\n", "        ", "return", "\n", "\n", "# Save the processed music", "\n", "", "music", ".", "save", "(", "output_dir", "/", "split", "/", "filename", ".", "with_suffix", "(", "\".json\"", ")", ".", "name", ")", "\n", "\n", "return", "filename", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_musicnet.main": [[139, 190], ["collect_musicnet.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "random.seed", "logging.info", "list", "random.choices", "logging.info", "list", "logging.info", "parse_arguments.input_dir.rglob", "tqdm.tqdm", "zip", "logging.info", "sum", "logging.info", "parse_arguments.output_dir.glob", "len", "random.sample", "open", "len", "collect_musicnet.process_and_save", "joblib.Parallel", "f.write", "bool", "len", "pathlib.Path().with_suffix", "joblib.delayed", "zip", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.process_and_save"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line options", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "# Collect filenames", "\n", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "rglob", "(", "\"*.mid\"", ")", ")", "\n", "splits", "=", "random", ".", "choices", "(", "\n", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ",", "(", "8", ",", "1", ",", "1", ")", ",", "k", "=", "len", "(", "filenames", ")", "\n", ")", "# Select splits for files randomly using an 8:1:1 train-valid-test ratio", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "\n", "# Start collecting data", "\n", "logging", ".", "info", "(", "\"Start collecting data...\"", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "count", "=", "0", "\n", "filenames", "=", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", "\n", "for", "filename", ",", "split", "in", "zip", "(", "filenames", ",", "splits", ")", ":", "\n", "            ", "if", "process_and_save", "(", "filename", ",", "args", ".", "output_dir", ",", "split", ")", ":", "\n", "                ", "count", "+=", "1", "\n", "", "", "logging", ".", "info", "(", "f\"Successfully saved {count} files.\"", ")", "\n", "", "else", ":", "\n", "        ", "results", "=", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "0", "if", "args", ".", "quiet", "else", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process_and_save", ")", "(", "filename", ",", "args", ".", "output_dir", ",", "split", ")", "\n", "for", "filename", ",", "split", "in", "zip", "(", "filenames", ",", "splits", ")", "\n", ")", "\n", "count", "=", "sum", "(", "(", "bool", "(", "x", ")", "for", "x", "in", "results", ")", ")", "\n", "logging", ".", "info", "(", "f\"Successfully saved {count} files.\"", ")", "\n", "\n", "# Sample test files", "\n", "", "sample_filenames", "=", "list", "(", "args", ".", "output_dir", ".", "glob", "(", "\"test/*.json\"", ")", ")", "\n", "if", "len", "(", "sample_filenames", ")", ">", "args", ".", "samples", ":", "\n", "        ", "sample_filenames", "=", "random", ".", "sample", "(", "sample_filenames", ",", "args", ".", "samples", ")", "\n", "", "with", "open", "(", "args", ".", "output_dir", "/", "\"samples.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "for", "sample_filename", "in", "sample_filenames", ":", "\n", "            ", "f", ".", "write", "(", "f\"{sample_filename.stem}\\n\"", ")", "\n", "", "", "logging", ".", "info", "(", "f\"Successfully sampled {len(sample_filenames)} test files.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_nes.parse_arguments": [[24, 51], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--samples\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "\"maximum number of samples\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_nes.process": [[53, 101], ["muspy.read", "muspy.read.adjust_resolution", "list", "track.notes.sort", "sum", "note_dict.values", "operator.attrgetter", "len"], "function", ["None"], ["", "def", "process", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Process a file and return the processed music.\"\"\"", "\n", "# Read the file", "\n", "music", "=", "muspy", ".", "read", "(", "filename", ")", "\n", "\n", "# Return None if no track is found", "\n", "if", "not", "music", ".", "tracks", ":", "\n", "        ", "return", "None", "\n", "\n", "# Adjust resolution to 100", "\n", "# NOTE: MIDI files in NES Music Database do not use metric timing. The", "\n", "# temporal resolution is set to 44100Hz and the MIDI resolution is set to", "\n", "# 22050. Reducing the MIDI resolution to 100 here is equivalent to", "\n", "# downsampling to a temporal resolution of 50 Hz, which is equivalent to a", "\n", "# resolution of 30 timesteps per quarter note in a bpm of 100.", "\n", "", "music", ".", "adjust_resolution", "(", "50", ")", "\n", "\n", "# Remove noise track", "\n", "# NOTE: Noise tracks in NES Music Database are not standard MIDI tracks.", "\n", "# They have pitches from 0 to 15, which corresponds to the some internal", "\n", "# parameter that controls the sound.", "\n", "music", ".", "tracks", "=", "[", "track", "for", "track", "in", "music", ".", "tracks", "if", "track", ".", "name", "!=", "\"no\"", "]", "\n", "\n", "# Remove duplicate notes", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "        ", "note_dict", "=", "{", "}", "\n", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "note_dict", "[", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ")", "]", "=", "note", "\n", "", "track", ".", "notes", "=", "list", "(", "note_dict", ".", "values", "(", ")", ")", "\n", "track", ".", "notes", ".", "sort", "(", "key", "=", "operator", ".", "attrgetter", "(", "\"time\"", ",", "\"pitch\"", ",", "\"duration\"", ")", ")", "\n", "\n", "# Skip the file if there are less than two active tracks", "\n", "", "if", "sum", "(", "(", "len", "(", "track", ")", ">", "10", "for", "track", "in", "music", ".", "tracks", ")", ")", "<", "2", ":", "\n", "        ", "return", "None", "\n", "\n", "# Update tracks", "\n", "", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Rename tracks", "\n", "        ", "track", ".", "name", "=", "NAMES", "[", "track", ".", "name", "]", "\n", "# Set programs and drums", "\n", "track", ".", "program", "=", "CONFIG", "[", "\"nes\"", "]", "[", "\"programs\"", "]", "[", "track", ".", "name", "]", "\n", "# Apply a constant velocity to the notes", "\n", "# NOTE: Note velocities in NES Music Database are not standard note", "\n", "# velocities. For simplicity, we overwrite them with a constant.", "\n", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "note", ".", "velocity", "=", "64", "\n", "\n", "", "", "return", "music", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_nes.process_and_save": [[103, 115], ["collect_nes.process", "process.save", "filename.with_suffix"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "process_and_save", "(", "filename", ",", "output_dir", ",", "split", ")", ":", "\n", "    ", "\"\"\"Process a file and save the processed music.\"\"\"", "\n", "# Process file", "\n", "music", "=", "process", "(", "filename", ")", "\n", "\n", "if", "music", "is", "None", ":", "\n", "        ", "return", "\n", "\n", "# Save the processed music", "\n", "", "music", ".", "save", "(", "output_dir", "/", "split", "/", "filename", ".", "with_suffix", "(", "\".json\"", ")", ".", "name", ")", "\n", "\n", "return", "filename", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_nes.main": [[117, 166], ["collect_nes.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "random.seed", "logging.info", "list", "logging.info", "list", "logging.info", "parse_arguments.input_dir.rglob", "tqdm.tqdm", "zip", "logging.info", "sum", "logging.info", "parse_arguments.output_dir.glob", "len", "random.sample", "open", "collect_nes.process_and_save", "joblib.Parallel", "f.write", "bool", "len", "pathlib.Path().with_suffix", "joblib.delayed", "zip", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.process_and_save"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line options", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "# Collect filenames", "\n", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "rglob", "(", "\"*.mid\"", ")", ")", "\n", "splits", "=", "(", "filename", ".", "parent", ".", "name", "for", "filename", "in", "filenames", ")", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "\n", "# Start collecting data", "\n", "logging", ".", "info", "(", "\"Start collecting data...\"", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "count", "=", "0", "\n", "filenames", "=", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", "\n", "for", "filename", ",", "split", "in", "zip", "(", "filenames", ",", "splits", ")", ":", "\n", "            ", "if", "process_and_save", "(", "filename", ",", "args", ".", "output_dir", ",", "split", ")", ":", "\n", "                ", "count", "+=", "1", "\n", "", "", "logging", ".", "info", "(", "f\"Successfully saved {count} files.\"", ")", "\n", "", "else", ":", "\n", "        ", "results", "=", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "0", "if", "args", ".", "quiet", "else", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process_and_save", ")", "(", "filename", ",", "args", ".", "output_dir", ",", "split", ")", "\n", "for", "filename", ",", "split", "in", "zip", "(", "filenames", ",", "splits", ")", "\n", ")", "\n", "count", "=", "sum", "(", "(", "bool", "(", "x", ")", "for", "x", "in", "results", ")", ")", "\n", "logging", ".", "info", "(", "f\"Successfully saved {count} files.\"", ")", "\n", "\n", "# Sample test files", "\n", "", "sample_filenames", "=", "list", "(", "args", ".", "output_dir", ".", "glob", "(", "\"test/*.json\"", ")", ")", "\n", "if", "len", "(", "sample_filenames", ")", ">", "args", ".", "samples", ":", "\n", "        ", "sample_filenames", "=", "random", ".", "sample", "(", "sample_filenames", ",", "args", ".", "samples", ")", "\n", "", "with", "open", "(", "args", ".", "output_dir", "/", "\"samples.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "for", "sample_filename", "in", "sample_filenames", ":", "\n", "            ", "f", ".", "write", "(", "f\"{sample_filename.stem}\\n\"", ")", "\n", "", "", "logging", ".", "info", "(", "f\"Successfully sampled {len(sample_filenames)} test files.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_lmd.parse_arguments": [[18, 51], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-id\"", ",", "\n", "\"--id_list\"", ",", "\n", "type", "=", "Path", ",", "\n", "help", "=", "\"filename of the cleansed ID list\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--samples\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "\"maximum number of samples\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_lmd.get_instrument": [[53, 66], ["None"], "function", ["None"], ["", "def", "get_instrument", "(", "program", ")", ":", "\n", "    ", "\"\"\"Return the instrument inferred from the program number.\"\"\"", "\n", "if", "0", "<=", "program", "<", "8", ":", "\n", "        ", "return", "\"Piano\"", "\n", "", "if", "24", "<=", "program", "<", "32", ":", "\n", "        ", "return", "\"Guitar\"", "\n", "", "if", "32", "<=", "program", "<", "40", ":", "\n", "        ", "return", "\"Bass\"", "\n", "", "if", "40", "<=", "program", "<", "46", "or", "48", "<=", "program", "<", "52", ":", "\n", "        ", "return", "\"Strings\"", "\n", "", "if", "56", "<=", "program", "<", "64", ":", "\n", "        ", "return", "\"Brass\"", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_lmd.process": [[68, 131], ["muspy.read", "muspy.read.adjust_resolution", "muspy.read.get_real_end_time", "list", "notes[].sort", "sum", "muspy.Track", "muspy.Track.sort", "muspy.read.tracks.append", "collect_lmd.get_instrument", "note_dict.values", "operator.attrgetter", "notes[].append", "notes.items", "notes[].append", "len"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.data.collect_lmd.get_instrument"], ["", "def", "process", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Process a file and return the processed music.\"\"\"", "\n", "# Read the file", "\n", "music", "=", "muspy", ".", "read", "(", "filename", ")", "\n", "\n", "# Return None if no track is found", "\n", "if", "not", "music", ".", "tracks", ":", "\n", "        ", "return", "None", "\n", "\n", "# Adjust resolution to 24 time steps per quarter note", "\n", "", "music", ".", "adjust_resolution", "(", "24", ")", "\n", "\n", "# Skip the file if it is longer than 20 minutes", "\n", "# (They are probably live-performance MIDI or simply corrupted.)", "\n", "if", "music", ".", "get_real_end_time", "(", ")", ">", "1200", ":", "\n", "        ", "return", "None", "\n", "\n", "# Collect notes", "\n", "", "notes", "=", "{", "\n", "\"Piano\"", ":", "[", "]", ",", "\n", "\"Guitar\"", ":", "[", "]", ",", "\n", "\"Bass\"", ":", "[", "]", ",", "\n", "\"Strings\"", ":", "[", "]", ",", "\n", "\"Brass\"", ":", "[", "]", ",", "\n", "\"Drums\"", ":", "[", "]", ",", "\n", "}", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "        ", "if", "track", ".", "is_drum", ":", "\n", "            ", "for", "note", "in", "track", ".", "notes", ":", "\n", "                ", "if", "note", ".", "duration", ">", "0", ":", "\n", "                    ", "notes", "[", "\"Drums\"", "]", ".", "append", "(", "note", ")", "\n", "", "", "", "else", ":", "\n", "            ", "instrument", "=", "get_instrument", "(", "track", ".", "program", ")", "\n", "if", "instrument", "is", "not", "None", ":", "\n", "                ", "for", "note", "in", "track", ".", "notes", ":", "\n", "                    ", "if", "note", ".", "duration", ">", "0", ":", "\n", "                        ", "notes", "[", "instrument", "]", ".", "append", "(", "note", ")", "\n", "\n", "# Remove duplicate notes", "\n", "", "", "", "", "", "for", "name", "in", "notes", ":", "\n", "        ", "note_dict", "=", "{", "}", "\n", "for", "note", "in", "notes", "[", "name", "]", ":", "\n", "            ", "note_dict", "[", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ")", "]", "=", "note", "\n", "", "notes", "[", "name", "]", "=", "list", "(", "note_dict", ".", "values", "(", ")", ")", "\n", "notes", "[", "name", "]", ".", "sort", "(", "key", "=", "operator", ".", "attrgetter", "(", "\"time\"", ",", "\"pitch\"", ",", "\"duration\"", ")", ")", "\n", "\n", "# Skip the file if there are less than two active non-drum tracks", "\n", "", "if", "sum", "(", "(", "len", "(", "v", ")", ">", "10", "and", "k", "!=", "\"Drums\"", "for", "k", ",", "v", "in", "notes", ".", "items", "(", ")", ")", ")", "<", "2", ":", "\n", "        ", "return", "None", "\n", "\n", "# Update tracks", "\n", "", "music", ".", "tracks", "=", "[", "]", "\n", "for", "name", "in", "notes", ":", "\n", "        ", "track", "=", "muspy", ".", "Track", "(", "\n", "name", "=", "name", ",", "\n", "program", "=", "CONFIG", "[", "\"lmd\"", "]", "[", "\"programs\"", "]", "[", "name", "]", "if", "name", "!=", "\"Drums\"", "else", "0", ",", "\n", "is_drum", "=", "(", "name", "==", "\"Drums\"", ")", ",", "\n", "notes", "=", "notes", "[", "name", "]", ",", "\n", ")", "\n", "track", ".", "sort", "(", ")", "\n", "music", ".", "tracks", ".", "append", "(", "track", ")", "\n", "\n", "", "return", "music", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_lmd.process_and_save": [[133, 153], ["collect_lmd.process", "process.save", "filename.with_suffix"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "process_and_save", "(", "filename", ",", "output_dir", ",", "split", ")", ":", "\n", "    ", "\"\"\"Process a file and save the processed music.\"\"\"", "\n", "try", ":", "\n", "# Process file", "\n", "        ", "music", "=", "process", "(", "filename", ")", "\n", "\n", "# Save the processed music", "\n", "if", "music", "is", "None", ":", "\n", "            ", "return", "\n", "\n", "# Save the processed music", "\n", "", "music", ".", "save", "(", "\n", "output_dir", "/", "split", "/", "filename", ".", "with_suffix", "(", "\".json.gz\"", ")", ".", "name", ",", "\n", "compressed", "=", "True", ",", "\n", ")", "\n", "\n", "return", "filename", "\n", "\n", "", "except", ":", "# noqa # pylint: disable=bare-except", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_lmd.main": [[155, 214], ["collect_lmd.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "random.seed", "logging.info", "random.choices", "logging.info", "list", "logging.info", "open", "set", "tqdm.tqdm", "zip", "logging.info", "sum", "logging.info", "parse_arguments.output_dir.glob", "len", "random.sample", "open", "parse_arguments.input_dir.rglob", "len", "collect_lmd.process_and_save", "joblib.Parallel", "f.write", "bool", "len", "pathlib.Path().with_suffix", "line.split", "joblib.delayed", "zip", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.process_and_save"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line options", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "# Load cleansed IDs", "\n", "logging", ".", "info", "(", "\"Loading IDs...\"", ")", "\n", "with", "open", "(", "args", ".", "id_list", ")", "as", "f", ":", "\n", "        ", "file_ids", "=", "set", "(", "line", ".", "split", "(", ")", "[", "0", "]", "for", "line", "in", "f", ")", "\n", "\n", "# Get filenames", "\n", "", "filenames", "=", "[", "\n", "filename", "\n", "for", "filename", "in", "args", ".", "input_dir", ".", "rglob", "(", "\"*.mid\"", ")", "\n", "if", "filename", ".", "stem", "in", "file_ids", "\n", "]", "\n", "splits", "=", "random", ".", "choices", "(", "\n", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ",", "(", "8", ",", "1", ",", "1", ")", ",", "k", "=", "len", "(", "filenames", ")", "\n", ")", "# Select splits for files randomly using an 8:1:1 train-valid-test ratio", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "\n", "# Start collecting data", "\n", "logging", ".", "info", "(", "\"Start collecting data...\"", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "count", "=", "0", "\n", "filenames", "=", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", "\n", "for", "filename", ",", "split", "in", "zip", "(", "filenames", ",", "splits", ")", ":", "\n", "            ", "if", "process_and_save", "(", "filename", ",", "args", ".", "output_dir", ",", "split", ")", ":", "\n", "                ", "count", "+=", "1", "\n", "", "", "logging", ".", "info", "(", "f\"Successfully saved {count} files.\"", ")", "\n", "", "else", ":", "\n", "        ", "results", "=", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "0", "if", "args", ".", "quiet", "else", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process_and_save", ")", "(", "filename", ",", "args", ".", "output_dir", ",", "split", ")", "\n", "for", "filename", ",", "split", "in", "zip", "(", "filenames", ",", "splits", ")", "\n", ")", "\n", "count", "=", "sum", "(", "(", "bool", "(", "x", ")", "for", "x", "in", "results", ")", ")", "\n", "logging", ".", "info", "(", "f\"Successfully saved {count} files.\"", ")", "\n", "\n", "# Sample test files", "\n", "", "sample_filenames", "=", "list", "(", "args", ".", "output_dir", ".", "glob", "(", "\"test/*.json.gz\"", ")", ")", "\n", "if", "len", "(", "sample_filenames", ")", ">", "args", ".", "samples", ":", "\n", "        ", "sample_filenames", "=", "random", ".", "sample", "(", "sample_filenames", ",", "args", ".", "samples", ")", "\n", "", "with", "open", "(", "args", ".", "output_dir", "/", "\"samples.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "for", "sample_filename", "in", "sample_filenames", ":", "\n", "            ", "f", ".", "write", "(", "f\"{sample_filename.stem}\\n\"", ")", "\n", "", "", "logging", ".", "info", "(", "f\"Successfully sampled {len(sample_filenames)} test files.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.prepare.parse_arguments": [[17, 34], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input filename or directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.prepare.process_music": [[36, 82], ["music.adjust_resolution", "ValueError", "list", "notes[].sort", "muspy.Track", "muspy.Track", "note_dict.values", "operator.attrgetter", "notes[].append", "notes[].append"], "function", ["None"], ["", "def", "process_music", "(", "music", ")", ":", "\n", "    ", "\"\"\"Process a music and return the processed music.\"\"\"", "\n", "# Raise ValueError if no track is found", "\n", "if", "not", "music", ".", "tracks", ":", "\n", "        ", "raise", "ValueError", "(", "\"No track is found.\"", ")", "\n", "\n", "# Adjust resolution to 24 time steps per quarter note", "\n", "", "music", ".", "adjust_resolution", "(", "24", ")", "\n", "\n", "# Collect notes", "\n", "notes", "=", "{", "\n", "\"Mixture\"", ":", "[", "]", ",", "\n", "\"Drums\"", ":", "[", "]", ",", "\n", "}", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "        ", "if", "track", ".", "is_drum", ":", "\n", "            ", "for", "note", "in", "track", ".", "notes", ":", "\n", "                ", "if", "note", ".", "duration", ">", "0", ":", "\n", "                    ", "notes", "[", "\"Drums\"", "]", ".", "append", "(", "note", ")", "\n", "", "", "", "else", ":", "\n", "            ", "for", "note", "in", "track", ".", "notes", ":", "\n", "                ", "if", "note", ".", "duration", ">", "0", ":", "\n", "                    ", "notes", "[", "\"Mixture\"", "]", ".", "append", "(", "note", ")", "\n", "\n", "# Remove duplicate notes", "\n", "", "", "", "", "for", "name", "in", "notes", ":", "\n", "        ", "note_dict", "=", "{", "}", "\n", "for", "note", "in", "notes", "[", "name", "]", ":", "\n", "            ", "note_dict", "[", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ")", "]", "=", "note", "\n", "", "notes", "[", "name", "]", "=", "list", "(", "note_dict", ".", "values", "(", ")", ")", "\n", "notes", "[", "name", "]", ".", "sort", "(", "key", "=", "operator", ".", "attrgetter", "(", "\"time\"", ",", "\"pitch\"", ",", "\"duration\"", ")", ")", "\n", "\n", "# Update tracks", "\n", "", "music", ".", "tracks", "=", "[", "\n", "muspy", ".", "Track", "(", "\n", "program", "=", "CONFIG", "[", "\"mixture_program\"", "]", ",", "\n", "is_drum", "=", "False", ",", "\n", "name", "=", "\"Mixture\"", ",", "\n", "notes", "=", "notes", "[", "\"Mixture\"", "]", ",", "\n", ")", ",", "\n", "muspy", ".", "Track", "(", "\n", "program", "=", "0", ",", "is_drum", "=", "True", ",", "name", "=", "\"Drums\"", ",", "notes", "=", "notes", "[", "\"Drums\"", "]", "\n", ")", ",", "\n", "]", "\n", "\n", "return", "music", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.prepare.process": [[84, 94], ["prepare.process_music", "muspy.read", "music21.converter.parse", "muspy.from_music21_score"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.data.prepare.process_music"], ["", "def", "process", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Process a file and return the processed music.\"\"\"", "\n", "try", ":", "\n", "# Read the file with muspy", "\n", "        ", "music", "=", "muspy", ".", "read", "(", "filename", ")", "\n", "", "except", "Exception", ":", "\n", "# Try music21 if failed", "\n", "        ", "m21", "=", "music21", ".", "converter", ".", "parse", "(", "filename", ")", "\n", "music", "=", "muspy", ".", "from_music21_score", "(", "m21", ")", "\n", "", "return", "process_music", "(", "music", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.prepare.process_and_save": [[96, 105], ["prepare.process", "process.save", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "process_and_save", "(", "filename", ",", "output_dir", ")", ":", "\n", "    ", "\"\"\"Process a file and save the processed music.\"\"\"", "\n", "# Process file", "\n", "music", "=", "process", "(", "filename", ")", "\n", "\n", "# Save the processed music", "\n", "music", ".", "save", "(", "output_dir", "/", "Path", "(", "filename", ")", ".", "with_suffix", "(", "\".json\"", ")", ".", "name", ")", "\n", "\n", "return", "music", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.prepare.main": [[107, 141], ["prepare.parse_arguments", "arranger.utils.setup_loggers", "parse_arguments.input.is_file", "logging.info", "logging.info", "tqdm.tqdm", "NotADirectoryError", "prepare.process_and_save", "filenames.extend", "prepare.process_and_save", "parse_arguments.output_dir.is_dir", "parse_arguments.input.glob", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.process_and_save", "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.process_and_save"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line options", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "\n", "# Check output directory", "\n", "if", "args", ".", "output_dir", "is", "not", "None", "and", "not", "args", ".", "output_dir", ".", "is_dir", "(", ")", ":", "\n", "        ", "raise", "NotADirectoryError", "(", "\"`output_dir` must be an existing directory.\"", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Process the file", "\n", "if", "args", ".", "input", ".", "is_file", "(", ")", ":", "\n", "        ", "process_and_save", "(", "args", ".", "input", ",", "args", ".", "output_dir", ")", "\n", "return", "\n", "\n", "# Collect filenames", "\n", "", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "filenames", "=", "[", "]", "\n", "for", "extension", "in", "(", "\"mid\"", ",", "\"midi\"", ",", "\"mxl\"", ",", "\"xml\"", ",", "\"abc\"", ")", ":", "\n", "        ", "filenames", ".", "extend", "(", "args", ".", "input", ".", "glob", "(", "f\"*.{extension}\"", ")", ")", "\n", "", "assert", "filenames", ",", "(", "\n", "\"No supported input files found. Supported extensions are 'mid', \"", "\n", "\"'midi', 'mxl', 'xml' and 'abc'.\"", "\n", ")", "\n", "\n", "# Process the collected files", "\n", "logging", ".", "info", "(", "\"Start preparing data...\"", ")", "\n", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ":", "\n", "        ", "process_and_save", "(", "filename", ",", "args", ".", "output_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.preprocess.parse_arguments": [[19, 46], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.preprocess.get_arrays": [[48, 76], ["enumerate", "range", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "zip", "round", "numpy.mean"], "function", ["None"], ["", "def", "get_arrays", "(", "notes", ",", "labels", ",", "n_tracks", ",", "seq_len", ")", ":", "\n", "    ", "\"\"\"Process data and return as a dictionary of arrays.\"\"\"", "\n", "# Create a dictionary of arrays initialized to zeros", "\n", "data", "=", "{", "\n", "\"time\"", ":", "np", ".", "zeros", "(", "(", "seq_len", ",", ")", ",", "int", ")", ",", "\n", "\"pitch\"", ":", "np", ".", "zeros", "(", "(", "seq_len", ",", ")", ",", "int", ")", ",", "\n", "\"duration\"", ":", "np", ".", "zeros", "(", "(", "seq_len", ",", ")", ",", "int", ")", ",", "\n", "\"velocity\"", ":", "np", ".", "zeros", "(", "(", "seq_len", ",", ")", ",", "int", ")", ",", "\n", "\"label\"", ":", "np", ".", "zeros", "(", "(", "seq_len", ",", ")", ",", "int", ")", ",", "\n", "\"onset_hint\"", ":", "np", ".", "zeros", "(", "(", "n_tracks", ",", ")", ",", "int", ")", ",", "\n", "\"pitch_hint\"", ":", "np", ".", "zeros", "(", "(", "n_tracks", ",", ")", ",", "int", ")", ",", "\n", "}", "\n", "\n", "# Fill in data", "\n", "for", "i", ",", "(", "note", ",", "label", ")", "in", "enumerate", "(", "zip", "(", "notes", ",", "labels", ")", ")", ":", "\n", "        ", "data", "[", "\"time\"", "]", "[", "i", "]", "=", "note", "[", "0", "]", "\n", "data", "[", "\"pitch\"", "]", "[", "i", "]", "=", "note", "[", "1", "]", "+", "1", "# 0 is reserved for 'no pitch'", "\n", "data", "[", "\"duration\"", "]", "[", "i", "]", "=", "note", "[", "2", "]", "\n", "data", "[", "\"velocity\"", "]", "[", "i", "]", "=", "note", "[", "3", "]", "\n", "data", "[", "\"label\"", "]", "[", "i", "]", "=", "label", "+", "1", "# 0 is reserved for 'no label'", "\n", "\n", "", "for", "i", "in", "range", "(", "n_tracks", ")", ":", "\n", "        ", "nonzero", "=", "(", "data", "[", "\"label\"", "]", "==", "i", ")", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "if", "nonzero", ".", "size", ":", "\n", "            ", "data", "[", "\"onset_hint\"", "]", "[", "i", "]", "=", "nonzero", "[", "0", "]", "\n", "data", "[", "\"pitch_hint\"", "]", "[", "i", "]", "=", "round", "(", "np", ".", "mean", "(", "data", "[", "\"pitch\"", "]", "[", "nonzero", "]", ")", ")", "\n", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.preprocess.process": [[78, 109], ["muspy.load", "list", "len", "zip", "numpy.array", "numpy.array", "preprocess.get_arrays", "[].keys", "list.index", "len", "np.array.append", "np.array.append", "sorted", "zip", "operator.itemgetter"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.infer.get_arrays"], ["", "def", "process", "(", "filename", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"Process the data and return as a list of dictionary of arrays.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Get track names and number of tracks", "\n", "names", "=", "list", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ".", "keys", "(", ")", ")", "\n", "n_tracks", "=", "len", "(", "names", ")", "\n", "\n", "# Collect notes and labels", "\n", "notes", ",", "labels", "=", "[", "]", ",", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Get label", "\n", "", "label", "=", "names", ".", "index", "(", "track", ".", "name", ")", "\n", "# Collect notes and labels", "\n", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "\n", "# Sort the notes and labels (using notes as keys)", "\n", "", "", "notes", ",", "labels", "=", "zip", "(", "*", "sorted", "(", "zip", "(", "notes", ",", "labels", ")", ",", "key", "=", "itemgetter", "(", "0", ")", ")", ")", "\n", "notes", "=", "np", ".", "array", "(", "notes", ")", "\n", "labels", "=", "np", ".", "array", "(", "labels", ")", "\n", "\n", "# Set sequence length to number of notes by default", "\n", "arrays", "=", "get_arrays", "(", "notes", ",", "labels", ",", "n_tracks", ",", "len", "(", "notes", ")", ")", "\n", "\n", "return", "arrays", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.preprocess.main": [[111, 187], ["preprocess.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "random.seed", "logging.info", "vars().items", "logging.info", "logging.info", "list", "logging.info", "vars", "parse_arguments.input_dir.glob", "tqdm.tqdm", "data.sort", "numpy.savez", "open", "preprocess.process", "joblib.Parallel", "f.write", "pathlib.Path().with_suffix", "data.append", "zip", "len", "joblib.delayed", "len", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "", "features", "=", "[", "\n", "\"time\"", ",", "\n", "\"pitch\"", ",", "\n", "\"duration\"", ",", "\n", "\"velocity\"", ",", "\n", "\"label\"", ",", "\n", "\"onset_hint\"", ",", "\n", "\"pitch_hint\"", ",", "\n", "]", "\n", "\n", "# === Training data ===", "\n", "logging", ".", "info", "(", "\"Processing training data...\"", ")", "\n", "ext", "=", "\"json\"", "if", "args", ".", "dataset", "!=", "\"lmd\"", "else", "\"json.gz\"", "\n", "for", "subset", "in", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ":", "\n", "        ", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "glob", "(", "f\"{subset}/*.{ext}\"", ")", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "            ", "data", "=", "[", "]", "\n", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ":", "\n", "                ", "processed", "=", "process", "(", "filename", ",", "args", ".", "dataset", ")", "\n", "if", "processed", "is", "not", "None", ":", "\n", "                    ", "data", ".", "append", "(", "\n", "{", "\"filename\"", ":", "filename", ".", "stem", ",", "\"arrays\"", ":", "processed", "}", "\n", ")", "\n", "\n", "", "", "", "else", ":", "\n", "            ", "results", "=", "joblib", ".", "Parallel", "(", "\n", "args", ".", "n_jobs", ",", "verbose", "=", "0", "if", "args", ".", "quiet", "else", "5", "\n", ")", "(", "\n", "joblib", ".", "delayed", "(", "process", ")", "(", "filename", ",", "args", ".", "dataset", ")", "\n", "for", "filename", "in", "filenames", "\n", ")", "\n", "data", "=", "[", "\n", "{", "\"filename\"", ":", "filename", ".", "stem", ",", "\"arrays\"", ":", "result", "}", "\n", "for", "filename", ",", "result", "in", "zip", "(", "filenames", ",", "results", ")", "\n", "if", "result", "is", "not", "None", "\n", "]", "\n", "\n", "# Sort collected data by array length (to speed up batch inference)", "\n", "", "if", "subset", "in", "(", "\"valid\"", ",", "\"test\"", ")", ":", "\n", "            ", "data", ".", "sort", "(", "key", "=", "lambda", "x", ":", "len", "(", "x", "[", "\"arrays\"", "]", "[", "\"time\"", "]", ")", ")", "\n", "\n", "# Save arrays", "\n", "", "for", "name", "in", "features", ":", "\n", "            ", "np", ".", "savez", "(", "\n", "args", ".", "output_dir", "/", "f\"{name}_{subset}.npz\"", ",", "\n", "*", "[", "sample", "[", "\"arrays\"", "]", "[", "name", "]", "for", "sample", "in", "data", "]", ",", "\n", ")", "\n", "", "logging", ".", "info", "(", "\n", "f\"Successfully saved {len(data)} samples for subset : {subset}.\"", "\n", ")", "\n", "\n", "# Save filenames", "\n", "with", "open", "(", "args", ".", "output_dir", "/", "f\"filenames_{subset}.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "for", "sample", "in", "data", ":", "\n", "                ", "f", ".", "write", "(", "f\"{sample['filename']}\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.parse_arguments": [[40, 67], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--samples\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "\"maximum number of samples\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.process": [[69, 119], ["music21.converter.parse", "muspy.from_music21_score", "muspy.from_music21_score.adjust_resolution", "list", "notes[].sort", "sum", "muspy.Track", "muspy.from_music21_score.tracks.append", "SPECIAL_FILES[].get", "NAMES.get", "note_dict.values", "muspy.Track.name.lower", "notes[].append", "operator.attrgetter", "len", "notes.values", "str"], "function", ["None"], ["", "def", "process", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Process a file and return the processed music.\"\"\"", "\n", "# Read the file", "\n", "m21", "=", "music21", ".", "converter", ".", "parse", "(", "filename", ")", "\n", "music", "=", "muspy", ".", "from_music21_score", "(", "m21", ")", "\n", "\n", "# Return None if no track is found", "\n", "if", "not", "music", ".", "tracks", ":", "\n", "        ", "return", "None", "\n", "\n", "# Adjust resolution to 24 time steps per quarter note", "\n", "", "music", ".", "adjust_resolution", "(", "24", ")", "\n", "\n", "# Collect notes", "\n", "notes", "=", "{", "\"Soprano\"", ":", "[", "]", ",", "\"Alto\"", ":", "[", "]", ",", "\"Tenor\"", ":", "[", "]", ",", "\"Bass\"", ":", "[", "]", "}", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "        ", "if", "filename", ".", "stem", "in", "SPECIAL_FILES", ":", "\n", "            ", "instrument", "=", "SPECIAL_FILES", "[", "str", "(", "filename", ".", "stem", ")", "]", ".", "get", "(", "track", ".", "name", ")", "\n", "", "else", ":", "\n", "            ", "instrument", "=", "NAMES", ".", "get", "(", "track", ".", "name", ".", "lower", "(", ")", ")", "\n", "", "if", "instrument", "is", "None", ":", "\n", "            ", "continue", "\n", "", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "if", "note", ".", "duration", ">", "0", ":", "\n", "                ", "notes", "[", "instrument", "]", ".", "append", "(", "note", ")", "\n", "\n", "# Remove duplicate notes", "\n", "", "", "", "for", "name", "in", "notes", ":", "\n", "        ", "note_dict", "=", "{", "}", "\n", "for", "note", "in", "notes", "[", "name", "]", ":", "\n", "            ", "note_dict", "[", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ")", "]", "=", "note", "\n", "", "notes", "[", "name", "]", "=", "list", "(", "note_dict", ".", "values", "(", ")", ")", "\n", "notes", "[", "name", "]", ".", "sort", "(", "key", "=", "operator", ".", "attrgetter", "(", "\"time\"", ",", "\"pitch\"", ",", "\"duration\"", ")", ")", "\n", "\n", "# Skip the file if there are less than two active tracks", "\n", "", "if", "sum", "(", "(", "len", "(", "v", ")", ">", "10", "for", "v", "in", "notes", ".", "values", "(", ")", ")", ")", "<", "2", ":", "\n", "        ", "return", "None", "\n", "\n", "# Update tracks", "\n", "", "music", ".", "tracks", "=", "[", "]", "\n", "for", "name", "in", "notes", ":", "\n", "        ", "track", "=", "muspy", ".", "Track", "(", "\n", "name", "=", "name", ",", "\n", "program", "=", "CONFIG", "[", "\"bach\"", "]", "[", "\"programs\"", "]", "[", "name", "]", ",", "\n", "is_drum", "=", "False", ",", "\n", "notes", "=", "notes", "[", "name", "]", ",", "\n", ")", "\n", "music", ".", "tracks", ".", "append", "(", "track", ")", "\n", "\n", "", "return", "music", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.process_and_save": [[121, 133], ["collect_bach.process", "process.save", "filename.with_suffix"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["", "def", "process_and_save", "(", "filename", ",", "output_dir", ",", "split", ")", ":", "\n", "    ", "\"\"\"Process a file and save the processed music.\"\"\"", "\n", "# Process file", "\n", "music", "=", "process", "(", "filename", ")", "\n", "\n", "if", "music", "is", "None", ":", "\n", "        ", "return", "\n", "\n", "# Save the processed music", "\n", "", "music", ".", "save", "(", "output_dir", "/", "split", "/", "filename", ".", "with_suffix", "(", "\".json\"", ")", ".", "name", ")", "\n", "\n", "return", "filename", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.main": [[135, 194], ["collect_bach.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "random.seed", "logging.info", "list", "tqdm.tqdm.extend", "random.choices", "logging.info", "list", "logging.info", "parse_arguments.input_dir.rglob", "parse_arguments.input_dir.rglob", "tqdm.tqdm", "zip", "logging.info", "sum", "logging.info", "parse_arguments.output_dir.glob", "len", "random.sample", "open", "len", "collect_bach.process_and_save", "joblib.Parallel", "f.write", "open", "zip", "bool", "len", "pathlib.Path().with_suffix", "joblib.delayed", "zip", "f.write", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.data.collect_bach.process_and_save"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line options", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "# Collect filenames", "\n", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "rglob", "(", "\"*.mxl\"", ")", ")", "\n", "filenames", ".", "extend", "(", "args", ".", "input_dir", ".", "rglob", "(", "\"*.xml\"", ")", ")", "\n", "splits", "=", "random", ".", "choices", "(", "\n", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ",", "(", "8", ",", "1", ",", "1", ")", ",", "k", "=", "len", "(", "filenames", ")", "\n", ")", "# Select splits for files randomly using an 8:1:1 train-valid-test ratio", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "\n", "# Start collecting data", "\n", "logging", ".", "info", "(", "\"Start collecting data...\"", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "count", "=", "0", "\n", "filenames", "=", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", "\n", "for", "filename", ",", "split", "in", "zip", "(", "filenames", ",", "splits", ")", ":", "\n", "            ", "if", "process_and_save", "(", "filename", ",", "args", ".", "output_dir", ",", "split", ")", ":", "\n", "                ", "count", "+=", "1", "\n", "", "", "logging", ".", "info", "(", "f\"Successfully saved {count} files.\"", ")", "\n", "", "else", ":", "\n", "        ", "results", "=", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "0", "if", "args", ".", "quiet", "else", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process_and_save", ")", "(", "filename", ",", "args", ".", "output_dir", ",", "split", ")", "\n", "for", "filename", ",", "split", "in", "zip", "(", "filenames", ",", "splits", ")", "\n", ")", "\n", "count", "=", "sum", "(", "(", "bool", "(", "x", ")", "for", "x", "in", "results", ")", ")", "\n", "logging", ".", "info", "(", "f\"Successfully saved {count} files.\"", ")", "\n", "\n", "# Sample test files", "\n", "", "sample_filenames", "=", "list", "(", "args", ".", "output_dir", ".", "glob", "(", "\"test/*.json\"", ")", ")", "\n", "if", "len", "(", "sample_filenames", ")", ">", "args", ".", "samples", ":", "\n", "        ", "sample_filenames", "=", "random", ".", "sample", "(", "sample_filenames", ",", "args", ".", "samples", ")", "\n", "", "with", "open", "(", "args", ".", "output_dir", "/", "\"samples.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "for", "sample_filename", "in", "sample_filenames", ":", "\n", "            ", "f", ".", "write", "(", "f\"{sample_filename.stem}\\n\"", ")", "\n", "", "", "logging", ".", "info", "(", "f\"Successfully sampled {len(sample_filenames)} test files.\"", ")", "\n", "\n", "# Save split results", "\n", "for", "target", "in", "(", "\"train\"", ",", "\"valid\"", ",", "\"test\"", ")", ":", "\n", "        ", "with", "open", "(", "args", ".", "output_dir", "/", "target", "/", "\"filenames.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "for", "filename", ",", "split", "in", "zip", "(", "filenames", ",", "splits", ")", ":", "\n", "                ", "if", "split", "==", "target", ":", "\n", "                    ", "f", ".", "write", "(", "f\"{filename.stem}\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.parse_arguments": [[23, 194], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input filename or directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-of\"", ",", "\n", "\"--onsets_filename\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"onsets filename\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-a\"", ",", "\n", "\"--audio\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"whether to write audio\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--suffix\"", ",", "\n", "default", "=", "\"pred\"", ",", "\n", "help", "=", "\"suffix to the output filename(s)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n", "", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.get_model": [[196, 248], ["len", "arranger.lstm.model.LSTMArranger", "arranger.lstm.model.LSTMArranger.", "tensorflow.keras.Model", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input"], "function", ["None"], ["# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "predict", "(", "music", ",", "dataset", ",", "states", ",", "onsets", ")", ":", "\n", "    ", "\"\"\"Predict on a music.\"\"\"", "\n", "# Collect notes and labels", "\n", "notes", "=", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Collect notes and labels", "\n", "", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "\n", "# Sort the notes", "\n", "", "", "notes", ".", "sort", "(", ")", "\n", "\n", "# Convert lists to arrays for speed reason", "\n", "notes", "=", "np", ".", "array", "(", "notes", ",", "int", ")", "\n", "\n", "# Get number of tracks", "\n", "n_tracks", "=", "len", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ")", "\n", "\n", "# Predict the labels", "\n", "predictions", "=", "_predict", "(", "notes", ",", "np", ".", "asarray", "(", "onsets", ")", ",", "n_tracks", ",", "states", ")", "\n", "\n", "return", "notes", ",", "predictions", "\n", "\n", "\n", "", "def", "process", "(", "filename", ",", "args", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Load onsets", "\n", "onsets", "=", "np", ".", "load", "(", "args", ".", "onsets_filename", ")", "\n", "\n", "# Get note and predicted labels", "\n", "notes", ",", "predictions", "=", "predict", "(", "music", ",", "args", ".", "dataset", ",", "args", ".", "states", ",", "onsets", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.get_inputs": [[250, 277], ["len", "enumerate", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.asarray", "numpy.asarray", "numpy.expand_dims"], "function", ["None"], ["# Shorthands", "\n", "programs", "=", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"programs\"", "]", "\n", "colors", "=", "CONFIG", "[", "\"colors\"", "]", "\n", "\n", "# Reconstruct and save the music using the predicted labels", "\n", "music_pred", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_pred", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "predictions", ",", "programs", ")", "\n", "save_sample_flat", "(", "\n", "music_pred", ",", "args", ".", "output_dir", ",", "f\"{filename.stem}_{args.suffix}\"", ",", "colors", "\n", ")", "\n", "if", "args", ".", "audio", ":", "\n", "        ", "muspy", ".", "write_audio", "(", "\n", "args", ".", "output_dir", "/", "f\"{filename.stem}_{args.suffix}.wav\"", ",", "music_pred", "\n", ")", "\n", "\n", "# Save the samples with drums", "\n", "", "if", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"has_drums\"", "]", ":", "\n", "        ", "music_pred", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "save_sample_flat", "(", "\n", "music_pred", ",", "\n", "args", ".", "output_dir", ",", "\n", "f\"{filename.stem}_{args.suffix}_drums\"", ",", "\n", "colors", ",", "\n", ")", "\n", "if", "args", ".", "audio", ":", "\n", "            ", "muspy", ".", "write_audio", "(", "\n", "args", ".", "output_dir", "/", "f\"{filename.stem}_{args.suffix}_drums.wav\"", ",", "\n", "music_pred", ",", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.predict": [[279, 347], ["list", "len", "np.array.sort", "min", "numpy.array", "predict.get_inputs", "numpy.argmax().flatten", "[].keys", "len", "numpy.load", "numpy.load", "model.predict", "numpy.zeros", "range", "numpy.concatenate", "np.array.append", "get_inputs.items", "model.predict", "np.concatenate.append", "np.zeros.fill", "numpy.argmax", "int", "raw_prediction[].argmax"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.get_inputs", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict"], ["\n", "", "", "return", "notes", ",", "predictions", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "\n", "# Check output directory", "\n", "if", "args", ".", "output_dir", "is", "not", "None", "and", "not", "args", ".", "output_dir", ".", "is_dir", "(", ")", ":", "\n", "        ", "raise", "NotADirectoryError", "(", "\"`output_dir` must be an existing directory.\"", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "debug", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "debug", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# Process the file", "\n", "", "if", "args", ".", "input", ".", "is_file", "(", ")", ":", "\n", "        ", "process", "(", "args", ".", "input", ",", "args", ")", "\n", "return", "\n", "\n", "# Collect filenames", "\n", "", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "filenames", "=", "list", "(", "args", ".", "input", ".", "glob", "(", "\"*.json\"", ")", ")", "\n", "assert", "filenames", ",", "\"No input files found. Only JSON files are supported.\"", "\n", "\n", "# Start inference", "\n", "logging", ".", "info", "(", "\"Start testing...\"", ")", "\n", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ":", "\n", "        ", "process", "(", "filename", ",", "args", ")", "\n", "\n", "\n", "", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.process": [[349, 399], ["muspy.load", "predict.predict", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample_flat", "muspy.write_audio", "music.deepcopy.tracks.append", "arranger.utils.save_sample_flat", "muspy.write_audio"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio"], []], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.main": [[401, 450], ["predict.parse_arguments", "arranger.utils.setup_loggers", "tensorflow.get_logger().setLevel", "logging.debug", "vars().items", "logging.info", "predict.get_model", "logging.info", "get_model.load_weights", "parse_arguments.input.is_file", "logging.info", "list", "logging.info", "tqdm.tqdm", "NotADirectoryError", "logging.debug", "tensorflow.config.list_physical_devices", "tensorflow.config.set_visible_devices", "tensorflow.config.experimental.set_memory_growth", "predict.process", "parse_arguments.input.glob", "predict.process", "parse_arguments.output_dir.is_dir", "tensorflow.get_logger", "vars", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.predict.get_model", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], []], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.train.parse_arguments": [[17, 204], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "# parser.add_argument(", "\n", "#     \"-na\",", "\n", "#     \"--no_augmentation\",", "\n", "#     dest=\"augmentation\",", "\n", "#     action=\"store_false\",", "\n", "#     help=\"whether to disable data augmentation\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-pr\",", "\n", "#     \"--augmentation_pitch_range\",", "\n", "#     nargs=2,", "\n", "#     type=int,", "\n", "#     default=[5, 6],", "\n", "#     help=\"pitch augmentation range\",", "\n", "# )", "\n", "# parser.set_defaults(augmentation=True)", "\n", "# parser.add_argument(", "\n", "#     \"-sl\",", "\n", "#     \"--seq_len\",", "\n", "#     type=int,", "\n", "#     default=500,", "\n", "#     help=\"sequence length\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-ml\",", "\n", "#     \"--max_len\",", "\n", "#     type=int,", "\n", "#     default=2000,", "\n", "#     help=\"maximum sequence length for validation\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-bp\",", "\n", "#     \"--use_beat_postion\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use beat and position rather than time\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-di\",", "\n", "#     \"--use_duration\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use duration as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-fi\",", "\n", "#     \"--use_frequency\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use frequency as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-oh\",", "\n", "#     \"--use_onset_hint\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use onset hint as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-ph\",", "\n", "#     \"--use_pitch_hint\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use pitch hint as an input\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-pe\",", "\n", "#     \"--use_pitch_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use pitch embedding\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-te\",", "\n", "#     \"--use_time_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use time embedding\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-be\",", "\n", "#     \"--use_beat_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use beat embedding\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-de\",", "\n", "#     \"--use_duration_embedding\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use duration embedding\",", "\n", "# )", "\n", "parser", ".", "add_argument", "(", "\n", "\"-r\"", ",", "\n", "\"--resolution\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "24", ",", "\n", "help", "=", "\"resolution (time step per quarter note)\"", ",", "\n", ")", "\n", "# parser.add_argument(", "\n", "#     \"-mt\",", "\n", "#     \"--max_time\",", "\n", "#     type=int,", "\n", "#     default=4096,", "\n", "#     help=\"maximum time\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-mb\",", "\n", "#     \"--max_beat\",", "\n", "#     type=int,", "\n", "#     default=4096,", "\n", "#     help=\"maximum number of beats\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-md\",", "\n", "#     \"--max_duration\",", "\n", "#     type=int,", "\n", "#     default=192,", "\n", "#     help=\"maximum duration\",", "\n", "# )", "\n", "# parser.add_argument(", "\n", "#     \"-ar\",", "\n", "#     \"--autoregressive\",", "\n", "#     action=\"store_true\",", "\n", "#     help=\"use autoregressive LSTM\",", "\n", "# )", "\n", "parser", ".", "add_argument", "(", "\n", "\"-bi\"", ",", "\n", "\"--bidirectional\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"use bidirectional LSTM\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-nl\"", ",", "\n", "\"--n_layers\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "3", ",", "\n", "help", "=", "\"number of layers\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-nu\"", ",", "\n", "\"--n_units\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "128", ",", "\n", "help", "=", "\"number of hidden units per layer\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-bs\"", ",", "\n", "\"--batch_size\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "16", ",", "\n", "help", "=", "\"batch size for training\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-e\"", ",", "\"--epoch\"", ",", "type", "=", "int", ",", "default", "=", "100", ",", "help", "=", "\"maximum number of epochs\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--steps_per_epoch\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "500", ",", "\n", "help", "=", "\"number of steps per epochs\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-p\"", ",", "\n", "\"--patience\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "5", ",", "\n", "help", "=", "\"patience for early stopping\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"-g\"", ",", "\"--gpu\"", ",", "type", "=", "int", ",", "help", "=", "\"GPU device to use\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.train.loader": [[206, 276], ["random.sample", "range", "len", "range", "len", "len", "min", "numpy.zeros", "enumerate", "numpy.zeros", "range", "random.randint", "numpy.clip", "numpy.pad", "len", "len", "random.randint", "len", "range", "numpy.nonzero", "numpy.pad", "len", "numpy.clip", "numpy.pad", "numpy.full_like"], "function", ["None"], ["#     \"\"\"Data loader.\"\"\"", "\n", "#     if training:", "\n", "#         indices = random.sample(range(len(labels)), len(labels))", "\n", "#     else:", "\n", "#         indices = range(len(labels))", "\n", "#     for i in indices:", "\n", "\n", "#         yield inputs, label", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Configure TensorFlow", "\n", "gpus", "=", "tf", ".", "config", ".", "list_physical_devices", "(", "\"GPU\"", ")", "\n", "tf", ".", "config", ".", "set_visible_devices", "(", "gpus", "[", "args", ".", "gpu", "]", ",", "\"GPU\"", ")", "\n", "tf", ".", "config", ".", "experimental", ".", "set_memory_growth", "(", "gpus", "[", "args", ".", "gpu", "]", ",", "True", ")", "\n", "\n", "# Set up loggers", "\n", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "tf", ".", "get_logger", "(", ")", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "\n", "# Set random seeds", "\n", "random", ".", "seed", "(", "0", ")", "\n", "tf", ".", "random", ".", "set_seed", "(", "0", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# === Data ===", "\n", "\n", "# Get output shapes nad types", "\n", "", "n_tracks", "=", "len", "(", "CONFIG", "[", "args", ".", "dataset", "]", "[", "\"programs\"", "]", ")", "\n", "n_features", "=", "9", "+", "4", "*", "n_tracks", "\n", "# output_shapes = ({\"feature\": (n_features,)}, (1,))", "\n", "# output_types = ({\"feature\": tf.float32}, tf.int32)", "\n", "\n", "# Load training data", "\n", "logging", ".", "info", "(", "\"Loading training data...\"", ")", "\n", "train_data", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"feature_train.npz\"", ")", ")", "\n", "train_labels", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"label_train.npz\"", ")", ")", "\n", "\n", "train_dataset", "=", "tf", ".", "data", ".", "Dataset", ".", "from_tensor_slices", "(", "\n", "(", "train_data", ",", "train_labels", ")", "\n", ")", "\n", "# train_dataset = tf.data.Dataset.from_generator(", "\n", "#     lambda: loader(", "\n", "#         train_data, train_labels, n_tracks, args, training=True", "\n", "#     ),", "\n", "#     output_shapes=output_shapes,", "\n", "#     output_types=output_types,", "\n", "# )", "\n", "train_dataset", "=", "(", "\n", "train_dataset", ".", "shuffle", "(", "100", ")", ".", "repeat", "(", ")", ".", "batch", "(", "args", ".", "batch_size", ")", ".", "prefetch", "(", "3", ")", "\n", ")", "\n", "\n", "# Load validation data", "\n", "logging", ".", "info", "(", "\"Loading validation data...\"", ")", "\n", "val_data", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"feature_valid.npz\"", ")", ")", "\n", "val_labels", "=", "np", ".", "concatenate", "(", "load_npz", "(", "args", ".", "input_dir", "/", "\"label_valid.npz\"", ")", ")", "\n", "val_dataset", "=", "tf", ".", "data", ".", "Dataset", ".", "from_tensor_slices", "(", "(", "val_data", ",", "val_labels", ")", ")", "\n", "# val_dataset = tf.data.Dataset.from_generator(", "\n", "#     lambda: loader(val_data, val_labels, n_tracks, args, training=False),", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.train.main": [[278, 481], ["train.parse_arguments", "parse_arguments.output_dir.mkdir", "tensorflow.config.list_physical_devices", "tensorflow.config.set_visible_devices", "tensorflow.config.experimental.set_memory_growth", "arranger.utils.setup_loggers", "tensorflow.get_logger().setLevel", "random.seed", "tensorflow.random.set_seed", "logging.info", "vars().items", "len", "logging.info", "arranger.utils.load_npz", "tensorflow.data.Dataset.from_generator", "train_dataset.shuffle().repeat().batch().prefetch.shuffle().repeat().batch().prefetch", "logging.info", "arranger.utils.load_npz", "tensorflow.data.Dataset.from_generator", "val_dataset.batch().prefetch.batch().prefetch", "logging.info", "arranger.lstm.model.LSTMArranger", "arranger.lstm.model.LSTMArranger.", "tensorflow.keras.Model", "sum", "sum", "logging.info", "logging.info", "logging.info", "logging.info", "logging.info", "tf.keras.Model.compile", "logging.info", "tensorflow.keras.callbacks.ModelCheckpoint", "tensorflow.keras.callbacks.CSVLogger", "tensorflow.keras.callbacks.EarlyStopping", "tf.keras.Model.fit", "logging.info", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "arranger.utils.load_npz", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.equal", "tensorflow.math.logical_not", "tensorflow.cast", "tensorflow.cast", "str", "str", "tensorflow.get_logger", "vars", "train.loader", "train_dataset.shuffle().repeat().batch().prefetch.shuffle().repeat().batch", "train.loader", "val_dataset.batch().prefetch.batch", "tensorflow.keras.backend.count_params", "tensorflow.keras.backend.count_params", "tensorflow.math.equal", "tensorflow.math.logical_and", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.keras.losses.SparseCategoricalCrossentropy", "tensorflow.cast", "pathlib.Path().with_suffix", "train_dataset.shuffle().repeat().batch().prefetch.shuffle().repeat", "tensorflow.argmax", "pathlib.Path", "train_dataset.shuffle().repeat().batch().prefetch.shuffle"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.load_npz", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.train.loader", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.train.loader"], ["#     output_types=output_types,", "\n", "# )", "\n", "val_dataset", "=", "val_dataset", ".", "batch", "(", "1", ")", ".", "prefetch", "(", "3", ")", "\n", "\n", "# === Model ===", "\n", "\n", "# Build the model", "\n", "logging", ".", "info", "(", "\"Building model...\"", ")", "\n", "\n", "# Inputs", "\n", "# inputs = {", "\n", "#     \"feature\": tf.keras.layers.Input(", "\n", "#         (n_features,), dtype=tf.float32, name=\"feature\"", "\n", "#     )", "\n", "# }", "\n", "model", "=", "tf", ".", "keras", ".", "Sequential", "(", ")", "\n", "model", ".", "add", "(", "tf", ".", "keras", ".", "Input", "(", "shape", "=", "(", "n_features", ",", ")", ")", ")", "\n", "for", "_", "in", "range", "(", "args", ".", "n_layers", ")", ":", "\n", "        ", "model", ".", "add", "(", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "args", ".", "n_units", ")", ")", "\n", "model", ".", "add", "(", "tf", ".", "keras", ".", "layers", ".", "Dropout", "(", "0.2", ")", ")", "\n", "", "model", ".", "add", "(", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "n_tracks", "+", "1", ")", ")", "\n", "\n", "if", "not", "args", ".", "quiet", ":", "\n", "        ", "model", ".", "summary", "(", ")", "\n", "\n", "# Count variables", "\n", "", "n_trainables", "=", "sum", "(", "\n", "tf", ".", "keras", ".", "backend", ".", "count_params", "(", "w", ")", "for", "w", "in", "model", ".", "trainable_weights", "\n", ")", "\n", "n_nontrainables", "=", "sum", "(", "\n", "tf", ".", "keras", ".", "backend", ".", "count_params", "(", "w", ")", "for", "w", "in", "model", ".", "non_trainable_weights", "\n", ")", "\n", "logging", ".", "info", "(", "\"Model statistics:\"", ")", "\n", "logging", ".", "info", "(", "f\"- Total parameters : {n_trainables + n_nontrainables}\"", ")", "\n", "logging", ".", "info", "(", "f\"- Trainable parameters : {n_trainables}\"", ")", "\n", "logging", ".", "info", "(", "f\"- Nontrainable parameters : {n_nontrainables}\"", ")", "\n", "\n", "# Compile the model", "\n", "logging", ".", "info", "(", "\"Compiling model...\"", ")", "\n", "\n", "# def masked_acc(y_true, y_pred):", "\n", "#     accuracies = tf.equal(", "\n", "#         y_true, 1 + tf.cast(tf.argmax(y_pred[..., 1:], axis=2), tf.float32)", "\n", "#     )", "\n", "#     mask = tf.math.logical_not(tf.math.equal(y_true, 0))", "\n", "#     accuracies = tf.cast(tf.math.logical_and(mask, accuracies), tf.float32)", "\n", "#     mask = tf.cast(mask, tf.float32)", "\n", "#     return tf.reduce_sum(accuracies) / tf.reduce_sum(mask)", "\n", "\n", "model", ".", "compile", "(", "\n", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "SparseCategoricalCrossentropy", "(", "from_logits", "=", "True", ")", ",", "\n", "optimizer", "=", "\"adam\"", ",", "\n", "metrics", "=", "[", "\"acc\"", "]", ",", "\n", ")", "\n", "\n", "# === Training ===", "\n", "\n", "# Train the model", "\n", "logging", ".", "info", "(", "\"Training model...\"", ")", "\n", "model_checkpoint", "=", "tf", ".", "keras", ".", "callbacks", ".", "ModelCheckpoint", "(", "\n", "str", "(", "args", ".", "output_dir", "/", "\"best_model.hdf5\"", ")", ",", "\n", "save_best_only", "=", "True", ",", "\n", "save_weights_only", "=", "True", ",", "\n", ")", "\n", "csv_logger", "=", "tf", ".", "keras", ".", "callbacks", ".", "CSVLogger", "(", "\n", "str", "(", "args", ".", "output_dir", "/", "\"training.log\"", ")", "\n", ")", "\n", "early_stopping", "=", "tf", ".", "keras", ".", "callbacks", ".", "EarlyStopping", "(", "patience", "=", "args", ".", "patience", ")", "\n", "model", ".", "fit", "(", "\n", "train_dataset", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "epochs", "=", "args", ".", "epoch", ",", "\n", "steps_per_epoch", "=", "args", ".", "steps_per_epoch", ",", "\n", "validation_data", "=", "val_dataset", ",", "\n", "validation_batch_size", "=", "1", ",", "\n", "callbacks", "=", "[", "model_checkpoint", ",", "csv_logger", ",", "early_stopping", "]", ",", "\n", "verbose", "=", "(", "1", "-", "args", ".", "quiet", ")", ",", "\n", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.infer.parse_arguments": [[27, 179], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\"--states\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"use state array\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n", "", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.infer.get_arrays": [[181, 227], ["len", "enumerate", "len", "len", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "numpy.zeros", "range", "numpy.expand_dims", "numpy.nonzero", "numpy.nonzero", "round", "numpy.mean", "numpy.full_like"], "function", ["None"], ["\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "else", ":", "\n", "# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "process", "(", "filename", ",", "states", ",", "dataset", ",", "output_dir", ",", "save", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Get track names and number of tracks", "\n", "names", "=", "list", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ".", "keys", "(", ")", ")", "\n", "n_tracks", "=", "len", "(", "names", ")", "\n", "\n", "# Collect notes and labels", "\n", "notes", ",", "labels", "=", "[", "]", ",", "[", "]", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Get label", "\n", "", "label", "=", "names", ".", "index", "(", "track", ".", "name", ")", "\n", "# Collect notes and labels", "\n", "for", "note", "in", "track", ".", "notes", ":", "\n", "            ", "notes", ".", "append", "(", "(", "note", ".", "time", ",", "note", ".", "pitch", ",", "note", ".", "duration", ",", "note", ".", "velocity", ")", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "\n", "# Sort the notes and labels (using notes as keys)", "\n", "", "", "notes", ",", "labels", "=", "zip", "(", "*", "sorted", "(", "zip", "(", "notes", ",", "labels", ")", ",", "key", "=", "itemgetter", "(", "0", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.infer.process": [[229, 330], ["muspy.load", "list", "len", "zip", "min", "numpy.array", "numpy.array", "infer.get_arrays", "numpy.argmax().flatten", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "arranger.utils.save_comparison", "[].keys", "list.index", "len", "model.predict", "numpy.zeros", "range", "numpy.concatenate", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "arranger.utils.save_comparison", "np.array.append", "np.array.append", "sorted", "len", "get_arrays.items", "model.predict", "np.concatenate.append", "np.zeros.fill", "numpy.argmax", "zip", "operator.itemgetter", "int", "raw_prediction[].argmax"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.infer.get_arrays", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison", "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict"], ["notes", "=", "np", ".", "array", "(", "notes", ",", "int", ")", "\n", "labels", "=", "np", ".", "array", "(", "labels", ",", "int", ")", "\n", "\n", "# Find the onset time for each track", "\n", "onsets", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_tracks", ")", ":", "\n", "        ", "nonzero", "=", "(", "labels", "==", "i", ")", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "onsets", ".", "append", "(", "nonzero", "[", "0", "]", "if", "nonzero", ".", "size", "else", "None", ")", "\n", "\n", "# Predict the labels", "\n", "", "predictions", "=", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", "\n", "\n", "# Return early if no need to save the sample", "\n", "if", "not", "save", ":", "\n", "        ", "return", "predictions", ",", "labels", "\n", "\n", "# Shorthands", "\n", "", "sample_dir", "=", "output_dir", "/", "\"samples\"", "\n", "programs", "=", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", "\n", "colors", "=", "CONFIG", "[", "\"colors\"", "]", "\n", "\n", "# Reconstruct and save the music using the predicted labels", "\n", "music_pred", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_pred", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "predictions", ",", "programs", ")", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred\"", ",", "colors", "\n", ")", "\n", "\n", "# Reconstruct and save the music using the original labels", "\n", "music_truth", "=", "music", ".", "deepcopy", "(", ")", "\n", "music_truth", ".", "tracks", "=", "reconstruct_tracks", "(", "notes", ",", "labels", ",", "programs", ")", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n", "music_truth", ",", "sample_dir", ",", "f\"{filename.stem}_truth\"", ",", "colors", "\n", ")", "\n", "\n", "# Save comparison", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "pianoroll_pred", ",", "sample_dir", ",", "f\"{filename.stem}_comp\"", "\n", ")", "\n", "\n", "# Save the samples with drums", "\n", "if", "CONFIG", "[", "dataset", "]", "[", "\"has_drums\"", "]", ":", "\n", "        ", "music_pred", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_pred", "=", "save_sample", "(", "\n", "music_pred", ",", "sample_dir", ",", "f\"{filename.stem}_pred_drums\"", ",", "colors", "\n", ")", "\n", "music_truth", ".", "tracks", ".", "append", "(", "music", ".", "tracks", "[", "-", "1", "]", ")", "# append drum track", "\n", "pianoroll_truth", "=", "save_sample", "(", "\n", "music_truth", ",", "sample_dir", ",", "f\"{filename.stem}_truth_drums\"", ",", "colors", "\n", ")", "\n", "save_comparison", "(", "\n", "pianoroll_truth", ",", "\n", "pianoroll_pred", ",", "\n", "sample_dir", ",", "\n", "f\"{filename.stem}_comp_drums\"", ",", "\n", ")", "\n", "\n", "", "return", "predictions", ",", "labels", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Make sure sample directories exist", "\n", "(", "args", ".", "output_dir", "/", "\"samples\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"json\"", ",", "\"mid\"", ",", "\"png\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "\"samples\"", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# Load sample filenames", "\n", "", "with", "open", "(", "args", ".", "input_dir", "/", "\"samples.txt\"", ")", "as", "f", ":", "\n", "        ", "sample_filenames", "=", "[", "line", ".", "rstrip", "(", ")", "for", "line", "in", "f", "]", "\n", "\n", "# Collect filenames", "\n", "", "logging", ".", "info", "(", "\"Collecting filenames...\"", ")", "\n", "extension", "=", "\"json\"", "if", "args", ".", "dataset", "!=", "\"lmd\"", "else", "\"json.gz\"", "\n", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "glob", "(", "f\"test/*.{extension}\"", ")", ")", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "is_samples", "=", "(", "filename", ".", "stem", "in", "sample_filenames", "for", "filename", "in", "filenames", ")", "\n", "\n", "# Iterate over the test data", "\n", "logging", ".", "info", "(", "\"Start testing...\"", ")", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "results", "=", "[", "\n", "process", "(", "\n", "filename", ",", "\n", "args", ".", "states", ",", "\n", "args", ".", "dataset", ",", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.infer.main": [[332, 464], ["infer.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "tensorflow.get_logger().setLevel", "random.seed", "logging.info", "vars().items", "logging.info", "len", "arranger.lstm.model.LSTMArranger", "arranger.lstm.model.LSTMArranger.", "tensorflow.keras.Model", "logging.info", "logging.info", "arranger.utils.compute_metrics", "parse_arguments.output_dir.mkdir", "tensorflow.config.list_physical_devices", "tensorflow.config.set_visible_devices", "tensorflow.config.experimental.set_memory_growth", "logging.info", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tf.keras.Model.load_weights", "open", "list", "infer.process", "tensorflow.get_logger", "vars", "tf.keras.Model.load_weights", "tf.keras.Model.load_weights", "str", "line.rstrip", "len", "parse_arguments.input_dir.glob", "zip", "parse_arguments.input_dir.glob", "tqdm.tqdm", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.compute_metrics", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["is_sample", ",", "\n", ")", "\n", "for", "filename", ",", "is_sample", "in", "zip", "(", "\n", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", ",", "is_samples", "\n", ")", "\n", "]", "\n", "", "else", ":", "\n", "        ", "results", "=", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process", ")", "(", "\n", "filename", ",", "\n", "args", ".", "states", ",", "\n", "args", ".", "dataset", ",", "\n", "args", ".", "output_dir", ",", "\n", "is_sample", ",", "\n", ")", "\n", "for", "filename", ",", "is_sample", "in", "zip", "(", "filenames", ",", "is_samples", ")", "\n", ")", "\n", "\n", "# Compute metrics", "\n", "", "compute_metrics", "(", "results", ",", "args", ".", "output_dir", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.InputLayer.__init__": [[34, 119], ["super().__init__", "tensorflow.keras.layers.Embedding", "tensorflow.keras.layers.Embedding", "tensorflow.keras.layers.Embedding", "tensorflow.keras.layers.Embedding", "tensorflow.keras.layers.Embedding", "numpy.pad", "numpy.pad.max", "tensorflow.keras.layers.Embedding", "model.positional_encoding", "model.positional_encoding", "numpy.expand_dims", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.__init__", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.positional_encoding", "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.positional_encoding"], ["\n", "\n", "matmul_qk", "=", "tf", ".", "matmul", "(", "\n", "q", ",", "k", ",", "transpose_b", "=", "True", "\n", ")", "# (..., seq_len_q, seq_len_k)", "\n", "\n", "# scale matmul_qk", "\n", "dk", "=", "tf", ".", "cast", "(", "tf", ".", "shape", "(", "k", ")", "[", "-", "1", "]", ",", "tf", ".", "float32", ")", "\n", "scaled_attention_logits", "=", "matmul_qk", "/", "tf", ".", "math", ".", "sqrt", "(", "dk", ")", "\n", "\n", "# add the mask to the scaled tensor.", "\n", "if", "mask", "is", "not", "None", ":", "\n", "        ", "scaled_attention_logits", "+=", "mask", "*", "-", "1e9", "\n", "\n", "# softmax is normalized on the last axis (seq_len_k) so that the scores", "\n", "# add up to 1.", "\n", "", "attention_weights", "=", "tf", ".", "nn", ".", "softmax", "(", "\n", "scaled_attention_logits", ",", "axis", "=", "-", "1", "\n", ")", "# (..., seq_len_q, seq_len_k)", "\n", "\n", "output", "=", "tf", ".", "matmul", "(", "attention_weights", ",", "v", ")", "# (..., seq_len_q, depth_v)", "\n", "\n", "return", "output", ",", "attention_weights", "\n", "\n", "\n", "", "class", "MultiHeadAttention", "(", "tf", ".", "keras", ".", "layers", ".", "Layer", ")", ":", "# noqa", "\n", "    ", "\"\"\"Copied from https://www.tensorflow.org/tutorials/text/transformer .\"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "d_model", ",", "num_heads", ")", ":", "\n", "        ", "super", "(", "MultiHeadAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "self", ".", "d_model", "=", "d_model", "\n", "\n", "assert", "d_model", "%", "self", ".", "num_heads", "==", "0", "\n", "\n", "self", ".", "depth", "=", "d_model", "//", "self", ".", "num_heads", "\n", "\n", "self", ".", "wq", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", "\n", "self", ".", "wk", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", "\n", "self", ".", "wv", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", "\n", "\n", "self", ".", "dense", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", "\n", "\n", "", "def", "split_heads", "(", "self", ",", "x", ",", "batch_size", ")", ":", "# noqa", "\n", "        ", "\"\"\"Split the last dimension into (num_heads, depth). Transpose the\n        result such that the shape is (batch_size, num_heads, seq_len, depth).\n        \"\"\"", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "(", "batch_size", ",", "-", "1", ",", "self", ".", "num_heads", ",", "self", ".", "depth", ")", ")", "\n", "return", "tf", ".", "transpose", "(", "x", ",", "perm", "=", "[", "0", ",", "2", ",", "1", ",", "3", "]", ")", "\n", "\n", "", "def", "call", "(", "self", ",", "v", ",", "k", ",", "q", ",", "mask", ")", ":", "# noqa", "\n", "        ", "batch_size", "=", "tf", ".", "shape", "(", "q", ")", "[", "0", "]", "\n", "\n", "q", "=", "self", ".", "wq", "(", "q", ")", "# (batch_size, seq_len, d_model)", "\n", "k", "=", "self", ".", "wk", "(", "k", ")", "# (batch_size, seq_len, d_model)", "\n", "v", "=", "self", ".", "wv", "(", "v", ")", "# (batch_size, seq_len, d_model)", "\n", "\n", "q", "=", "self", ".", "split_heads", "(", "\n", "q", ",", "batch_size", "\n", ")", "# (batch_size, num_heads, seq_len_q, depth)", "\n", "k", "=", "self", ".", "split_heads", "(", "\n", "k", ",", "batch_size", "\n", ")", "# (batch_size, num_heads, seq_len_k, depth)", "\n", "v", "=", "self", ".", "split_heads", "(", "\n", "v", ",", "batch_size", "\n", ")", "# (batch_size, num_heads, seq_len_v, depth)", "\n", "\n", "# scaled_attention -> (batch_size, num_heads, seq_len_q, depth)", "\n", "# attention_weights -> (batch_size, num_heads, seq_len_q, seq_len_k)", "\n", "scaled_attention", ",", "attention_weights", "=", "scaled_dot_product_attention", "(", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.InputLayer.call": [[120, 212], ["tensorflow.concat", "tensorflow.not_equal", "tensorflow.shape", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "range", "model.InputLayer.pitch_embedding", "tensorflow.expand_dims", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "tensors.append", "model.InputLayer.frequency_mapping", "tensorflow.cast", "tensors.append", "tensorflow.cast", "model.InputLayer.time_embedding", "tensorflow.expand_dims", "model.InputLayer.time_embedding_position", "model.InputLayer.time_embedding_beat", "tensorflow.expand_dims", "tensorflow.expand_dims", "model.InputLayer.duration_embedding", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.clip_by_value", "tensorflow.cast", "tensorflow.clip_by_value", "tensorflow.cast", "tensorflow.cast", "tensorflow.clip_by_value", "tensorflow.cast", "model.InputLayer.pitch_embedding", "tensorflow.clip_by_value", "tensorflow.expand_dims"], "methods", ["None"], ["q", ",", "k", ",", "v", ",", "mask", "\n", ")", "\n", "\n", "scaled_attention", "=", "tf", ".", "transpose", "(", "\n", "scaled_attention", ",", "perm", "=", "[", "0", ",", "2", ",", "1", ",", "3", "]", "\n", ")", "# (batch_size, seq_len_q, num_heads, depth)", "\n", "\n", "concat_attention", "=", "tf", ".", "reshape", "(", "\n", "scaled_attention", ",", "(", "batch_size", ",", "-", "1", ",", "self", ".", "d_model", ")", "\n", ")", "# (batch_size, seq_len_q, d_model)", "\n", "\n", "output", "=", "self", ".", "dense", "(", "\n", "concat_attention", "\n", ")", "# (batch_size, seq_len_q, d_model)", "\n", "\n", "return", "output", ",", "attention_weights", "\n", "\n", "\n", "", "", "def", "point_wise_feed_forward_network", "(", "d_model", ",", "dff", ")", ":", "\n", "    ", "\"\"\"Copied from https://www.tensorflow.org/tutorials/text/transformer .\"\"\"", "\n", "return", "tf", ".", "keras", ".", "Sequential", "(", "\n", "[", "\n", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "\n", "dff", ",", "activation", "=", "\"relu\"", "\n", ")", ",", "# (batch_size, seq_len, dff)", "\n", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "d_model", ")", ",", "# (batch_size, seq_len, d_model)", "\n", "]", "\n", ")", "\n", "\n", "\n", "", "class", "TransformerLayer", "(", "tf", ".", "keras", ".", "layers", ".", "Layer", ")", ":", "\n", "    ", "\"\"\"Copied from https://www.tensorflow.org/tutorials/text/transformer .\"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "d_model", ",", "num_heads", ",", "dff", ",", "rate", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "mha", "=", "MultiHeadAttention", "(", "d_model", ",", "num_heads", ")", "\n", "self", ".", "ffn", "=", "point_wise_feed_forward_network", "(", "d_model", ",", "dff", ")", "\n", "\n", "self", ".", "layernorm1", "=", "tf", ".", "keras", ".", "layers", ".", "LayerNormalization", "(", "epsilon", "=", "1e-6", ")", "\n", "self", ".", "layernorm2", "=", "tf", ".", "keras", ".", "layers", ".", "LayerNormalization", "(", "epsilon", "=", "1e-6", ")", "\n", "\n", "self", ".", "dropout1", "=", "tf", ".", "keras", ".", "layers", ".", "Dropout", "(", "rate", ")", "\n", "self", ".", "dropout2", "=", "tf", ".", "keras", ".", "layers", ".", "Dropout", "(", "rate", ")", "\n", "\n", "", "def", "call", "(", "self", ",", "x", ",", "training", ",", "mask", ")", ":", "# noqa", "\n", "        ", "attn_output", ",", "_", "=", "self", ".", "mha", "(", "\n", "x", ",", "x", ",", "x", ",", "mask", "\n", ")", "# (batch_size, input_seq_len, d_model)", "\n", "attn_output", "=", "self", ".", "dropout1", "(", "attn_output", ",", "training", "=", "training", ")", "\n", "out1", "=", "self", ".", "layernorm1", "(", "\n", "x", "+", "attn_output", "\n", ")", "# (batch_size, input_seq_len, d_model)", "\n", "\n", "ffn_output", "=", "self", ".", "ffn", "(", "out1", ")", "# (batch_size, input_seq_len, d_model)", "\n", "ffn_output", "=", "self", ".", "dropout2", "(", "ffn_output", ",", "training", "=", "training", ")", "\n", "out2", "=", "self", ".", "layernorm2", "(", "\n", "out1", "+", "ffn_output", "\n", ")", "# (batch_size, input_seq_len, d_model)", "\n", "\n", "return", "out2", "\n", "\n", "\n", "", "", "class", "InputLayer", "(", "tf", ".", "keras", ".", "layers", ".", "Layer", ")", ":", "\n", "    ", "\"\"\"Input layer.\"\"\"", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "max_len", ":", "int", ",", "\n", "use_duration", ":", "bool", ",", "\n", "use_frequency", ":", "bool", ",", "\n", "use_onset_hint", ":", "bool", ",", "\n", "use_pitch_hint", ":", "bool", ",", "\n", "use_pitch_embedding", ":", "bool", ",", "\n", "use_time_embedding", ":", "bool", ",", "\n", "use_duration_embedding", ":", "bool", ",", "\n", "max_beat", ":", "int", ",", "\n", "max_duration", ":", "int", ",", "\n", "n_tracks", ":", "int", ",", "\n", "use_lookahead_mask", ":", "bool", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "max_len", "=", "max_len", "\n", "self", ".", "use_duration", "=", "use_duration", "\n", "self", ".", "use_frequency", "=", "use_frequency", "\n", "self", ".", "use_onset_hint", "=", "use_onset_hint", "\n", "self", ".", "use_pitch_hint", "=", "use_pitch_hint", "\n", "self", ".", "use_pitch_embedding", "=", "use_pitch_embedding", "\n", "self", ".", "use_time_embedding", "=", "use_time_embedding", "\n", "self", ".", "use_duration_embedding", "=", "use_duration_embedding", "\n", "self", ".", "max_beat", "=", "max_beat", "\n", "self", ".", "max_duration", "=", "max_duration", "\n", "self", ".", "n_tracks", "=", "n_tracks", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTM.__init__": [[217, 246], ["super().__init__", "tensorflow.keras.layers.LSTM", "tensorflow.keras.layers.LayerNormalization", "tensorflow.keras.layers.Dropout", "range", "tensorflow.keras.layers.Bidirectional", "tensorflow.keras.layers.LSTM", "range", "range", "tensorflow.keras.layers.LSTM", "range", "range"], "methods", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.__init__"], ["            ", "self", ".", "pitch_embedding", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "129", ",", "16", ",", "name", "=", "\"pitch_embedding\"", "\n", ")", "\n", "", "if", "use_time_embedding", ":", "\n", "            ", "self", ".", "time_embedding_position", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "24", ",", "16", ",", "name", "=", "\"time_embedding_position\"", "\n", ")", "\n", "self", ".", "time_embedding_beat", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "max_beat", "+", "1", ",", "\n", "16", ",", "\n", "weights", "=", "[", "positional_encoding", "(", "max_beat", "+", "1", ",", "16", ")", "]", ",", "\n", "trainable", "=", "False", ",", "\n", "name", "=", "\"time_embedding_beat\"", ",", "\n", ")", "\n", "", "if", "use_duration", "and", "use_duration_embedding", ":", "\n", "            ", "self", ".", "duration_embedding", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "max_duration", "+", "1", ",", "16", ",", "name", "=", "\"duration_embedding\"", "\n", ")", "\n", "\n", "# Frequency matrix", "\n", "", "if", "use_frequency", ":", "\n", "            ", "frequency_matrix", "=", "440.0", "*", "2", "**", "(", "(", "np", ".", "arange", "(", "128", ")", "-", "69", ")", "/", "12", ")", "\n", "frequency_matrix", "=", "np", ".", "pad", "(", "frequency_matrix", ",", "(", "1", ",", "0", ")", ")", "\n", "frequency_matrix", "/=", "frequency_matrix", ".", "max", "(", ")", "\n", "self", ".", "frequency_mapping", "=", "tf", ".", "keras", ".", "layers", ".", "Embedding", "(", "\n", "129", ",", "\n", "1", ",", "\n", "weights", "=", "[", "np", ".", "expand_dims", "(", "frequency_matrix", ",", "-", "1", ")", "]", ",", "\n", "trainable", "=", "False", ",", "\n", "name", "=", "\"frequency_mapping\"", ",", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTM.call": [[247, 255], ["zip", "lstm", "layernorm", "dropout"], "methods", ["None"], [")", "\n", "", "else", ":", "\n", "            ", "self", ".", "frequency_mapping", "=", "None", "\n", "\n", "", "", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.__init__": [[260, 324], ["super().__init__", "model.InputLayer", "model.LSTM", "tensorflow.keras.layers.Dense"], "methods", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.__init__"], ["\n", "# Collect input tensors", "\n", "seq_len", "=", "tf", ".", "shape", "(", "inputs", "[", "\"time\"", "]", ")", "[", "1", "]", "\n", "tensors", "=", "[", "]", "\n", "if", "self", ".", "use_pitch_embedding", ":", "\n", "            ", "tensors", ".", "append", "(", "self", ".", "pitch_embedding", "(", "inputs", "[", "\"pitch\"", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "tensors", ".", "append", "(", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "cast", "(", "inputs", "[", "\"pitch\"", "]", ",", "tf", ".", "float32", ")", ",", "-", "1", ")", "\n", ")", "\n", "\n", "", "if", "self", ".", "use_time_embedding", ":", "\n", "            ", "tensors", ".", "append", "(", "self", ".", "time_embedding_position", "(", "inputs", "[", "\"time\"", "]", "%", "24", ")", ")", "\n", "tensors", ".", "append", "(", "\n", "self", ".", "time_embedding_beat", "(", "\n", "tf", ".", "clip_by_value", "(", "inputs", "[", "\"time\"", "]", "//", "24", ",", "0", ",", "self", ".", "max_beat", ")", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "tensors", ".", "append", "(", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "cast", "(", "inputs", "[", "\"time\"", "]", ",", "tf", ".", "float32", ")", ",", "-", "1", ")", "\n", ")", "\n", "", "if", "self", ".", "use_duration", ":", "\n", "            ", "if", "self", ".", "use_duration_embedding", ":", "\n", "                ", "tensors", ".", "append", "(", "\n", "self", ".", "duration_embedding", "(", "\n", "tf", ".", "clip_by_value", "(", "\n", "inputs", "[", "\"duration\"", "]", ",", "0", ",", "self", ".", "max_duration", "\n", ")", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "tensors", ".", "append", "(", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "cast", "(", "inputs", "[", "\"duration\"", "]", ",", "tf", ".", "float32", ")", ",", "-", "1", ")", "\n", ")", "\n", "", "", "if", "self", ".", "use_frequency", ":", "\n", "            ", "tensors", ".", "append", "(", "self", ".", "frequency_mapping", "(", "inputs", "[", "\"pitch\"", "]", ")", ")", "\n", "", "if", "self", ".", "use_onset_hint", ":", "\n", "            ", "tensors", ".", "append", "(", "tf", ".", "cast", "(", "inputs", "[", "\"onset_hint\"", "]", ",", "tf", ".", "float32", ")", ")", "\n", "", "if", "self", ".", "use_pitch_hint", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "n_tracks", ")", ":", "\n", "                ", "tensors", ".", "append", "(", "\n", "tf", ".", "tile", "(", "\n", "self", ".", "pitch_embedding", "(", "\n", "tf", ".", "expand_dims", "(", "inputs", "[", "\"pitch_hint\"", "]", "[", "...", ",", "i", "]", ",", "1", ")", "\n", ")", ",", "\n", "(", "1", ",", "seq_len", ",", "1", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "# Concate features", "\n", "", "", "tensor_out", "=", "tf", ".", "concat", "(", "tensors", ",", "-", "1", ")", "\n", "\n", "# Create mask", "\n", "mask", "=", "tf", ".", "cast", "(", "tf", ".", "equal", "(", "inputs", "[", "\"pitch\"", "]", ",", "0", ")", ",", "tf", ".", "float32", ")", "\n", "mask", "=", "mask", "[", ":", ",", "tf", ".", "newaxis", ",", "tf", ".", "newaxis", ",", ":", "]", "\n", "\n", "if", "self", ".", "use_lookahead_mask", ":", "\n", "            ", "look_ahead_mask", "=", "1", "-", "tf", ".", "linalg", ".", "band_part", "(", "\n", "tf", ".", "ones", "(", "(", "seq_len", ",", "seq_len", ")", ")", ",", "-", "1", ",", "0", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.LSTMArranger.call": [[325, 333], ["model.LSTMArranger.input_layer", "model.LSTMArranger.lstm", "model.LSTMArranger.dense", "tensorflow.concat", "tensorflow.cast"], "methods", ["None"], [")", "\n", "look_ahead_mask", "=", "tf", ".", "tile", "(", "\n", "look_ahead_mask", "[", "tf", ".", "newaxis", ",", "tf", ".", "newaxis", ",", ":", ",", ":", "]", ",", "\n", "[", "tf", ".", "shape", "(", "inputs", "[", "\"time\"", "]", ")", "[", "0", "]", ",", "1", ",", "1", ",", "1", "]", ",", "\n", ")", "\n", "mask", "=", "tf", ".", "maximum", "(", "mask", ",", "look_ahead_mask", ")", "\n", "\n", "", "return", "tensor_out", ",", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.get_angles": [[8, 12], ["numpy.power", "numpy.float32"], "function", ["None"], ["def", "get_angles", "(", "pos", ",", "i", ",", "d_model", ")", ":", "\n", "    ", "\"\"\"Copied from https://www.tensorflow.org/tutorials/text/transformer .\"\"\"", "\n", "angle_rates", "=", "1", "/", "np", ".", "power", "(", "10000", ",", "(", "2", "*", "(", "i", "//", "2", ")", ")", "/", "np", ".", "float32", "(", "d_model", ")", ")", "\n", "return", "pos", "*", "angle_rates", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.positional_encoding": [[14, 29], ["model.get_angles", "numpy.sin", "numpy.cos", "tensorflow.cast", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.lstm.model.get_angles"], ["", "def", "positional_encoding", "(", "position", ",", "d_model", ")", ":", "\n", "    ", "\"\"\"Copied from https://www.tensorflow.org/tutorials/text/transformer .\"\"\"", "\n", "pos_encoding", "=", "get_angles", "(", "\n", "np", ".", "arange", "(", "position", ")", "[", ":", ",", "np", ".", "newaxis", "]", ",", "\n", "np", ".", "arange", "(", "d_model", ")", "[", "np", ".", "newaxis", ",", ":", "]", ",", "\n", "d_model", ",", "\n", ")", "\n", "\n", "# apply sin to even indices in the array; 2i", "\n", "pos_encoding", "[", ":", ",", "0", ":", ":", "2", "]", "=", "np", ".", "sin", "(", "pos_encoding", "[", ":", ",", "0", ":", ":", "2", "]", ")", "\n", "\n", "# apply cos to odd indices in the array; 2i+1", "\n", "pos_encoding", "[", ":", ",", "1", ":", ":", "2", "]", "=", "np", ".", "cos", "(", "pos_encoding", "[", ":", ",", "1", ":", ":", "2", "]", ")", "\n", "\n", "return", "tf", ".", "cast", "(", "pos_encoding", ",", "dtype", "=", "tf", ".", "float32", ")", "# pylint: disable=all", "\n", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.parse_arguments": [[17, 44], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["\n", "def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-p\"", ",", "\"--permutation\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"consider permutation\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.learn._nonincreasing_sequences": [[46, 53], ["range", "range", "len", "learn._nonincreasing_sequences"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.learn._nonincreasing_sequences"], [")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n", "\n", "", "def", "_nonincreasing_sequences", "(", "seq_len", ",", "n", ",", "seq", ")", ":", "\n", "    ", "if", "seq_len", "-", "len", "(", "seq", ")", ">", "1", ":", "\n", "        ", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "yield", "from", "_nonincreasing_sequences", "(", "seq_len", ",", "i", "+", "1", ",", "seq", "+", "(", "i", ",", ")", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.nonincreasing_sequences": [[55, 62], ["range", "range", "learn._nonincreasing_sequences"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.learn._nonincreasing_sequences"], ["        ", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "yield", "seq", "+", "(", "i", ",", ")", "\n", "\n", "\n", "", "", "", "def", "nonincreasing_sequences", "(", "seq_len", ",", "n", ")", ":", "\n", "    ", "\"\"\"Yield nonincreasing sequences of a fixed length with values < n.\"\"\"", "\n", "if", "seq_len", ">", "1", ":", "\n", "        ", "for", "i", "in", "range", "(", "n", ")", ":", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.compute_score": [[64, 72], ["zip", "numpy.sum"], "function", ["None"], ["", "", "else", ":", "\n", "        ", "yield", "from", "range", "(", "n", ")", "\n", "\n", "\n", "", "", "def", "compute_score", "(", "counts", ",", "boundaries", ",", "permutation", ")", ":", "\n", "    ", "\"\"\"Compute the score for the given zone boundaries and permutation.\"\"\"", "\n", "score", "=", "0", "\n", "uppers", "=", "(", "128", ",", ")", "+", "boundaries", "\n", "lowers", "=", "boundaries", "+", "(", "0", ",", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.find_optimal_zone": [[74, 86], ["learn.nonincreasing_sequences", "len", "learn.compute_score"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.learn.nonincreasing_sequences", "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.compute_score"], ["        ", "score", "+=", "np", ".", "sum", "(", "counts", "[", "label", "]", "[", "lower", ":", "upper", "]", ")", "\n", "", "return", "score", "\n", "\n", "\n", "", "def", "find_optimal_zone", "(", "counts", ",", "permutations", ")", ":", "\n", "    ", "\"\"\"Find the optimal zone boundaries and permutation.\"\"\"", "\n", "max_score", "=", "0", "\n", "optimal_boundaries", ",", "optimal_permutation", "=", "None", ",", "None", "\n", "for", "boundaries", "in", "nonincreasing_sequences", "(", "len", "(", "counts", ")", "-", "1", ",", "128", ")", ":", "\n", "        ", "for", "permutation", "in", "permutations", ":", "\n", "            ", "score", "=", "compute_score", "(", "counts", ",", "boundaries", ",", "permutation", ")", "\n", "if", "score", ">", "max_score", ":", "\n", "                ", "max_score", "=", "score", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.process": [[88, 111], ["muspy.load", "list", "len", "numpy.zeros", "[].keys", "list.index", "len"], "function", ["None"], ["optimal_permutation", "=", "permutation", "\n", "", "", "", "return", "optimal_boundaries", ",", "optimal_permutation", "\n", "\n", "\n", "", "def", "process", "(", "filename", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n", "music", "=", "muspy", ".", "load", "(", "filename", ")", "\n", "\n", "# Get track names", "\n", "names", "=", "list", "(", "CONFIG", "[", "dataset", "]", "[", "\"programs\"", "]", ".", "keys", "(", ")", ")", "\n", "\n", "# Get number of tracks", "\n", "n_tracks", "=", "len", "(", "names", ")", "\n", "\n", "# Collect pitch counts", "\n", "counts", "=", "np", ".", "zeros", "(", "(", "n_tracks", ",", "128", ")", ",", "int", ")", "\n", "for", "track", "in", "music", ".", "tracks", ":", "\n", "# Skip drum track or empty track", "\n", "        ", "if", "track", ".", "is_drum", "or", "not", "track", ".", "notes", ":", "\n", "            ", "continue", "\n", "# Get label", "\n", "", "label", "=", "names", ".", "index", "(", "track", ".", "name", ")", "\n", "# Collect pitch counts", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.learn.main": [[113, 159], ["learn.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "logging.info", "vars().items", "logging.info", "list", "numpy.argmax", "logging.info", "logging.info", "parse_arguments.input_dir.glob", "sum", "sum", "open", "out_file.write", "vars", "learn.process", "joblib.Parallel", "pathlib.Path().with_suffix", "tqdm.tqdm", "joblib.delayed", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["counts", "[", "label", "]", "=", "np", ".", "bincount", "(", "pitches", ",", "minlength", "=", "128", ")", "\n", "\n", "", "return", "counts", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function.\"\"\"", "\n", "# Parse command-line arguments", "\n", "args", "=", "parse_arguments", "(", ")", "\n", "assert", "args", ".", "n_jobs", ">=", "1", ",", "\"`n_jobs` must be a positive integer.\"", "\n", "args", ".", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Make sure sample directories exist", "\n", "(", "args", ".", "output_dir", "/", "\"samples\"", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "for", "subdir", "in", "(", "\"json\"", ",", "\"mid\"", ",", "\"png\"", ")", ":", "\n", "        ", "(", "args", ".", "output_dir", "/", "\"samples\"", "/", "subdir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "# Set up loggers", "\n", "", "setup_loggers", "(", "\n", "filename", "=", "args", ".", "output_dir", "/", "Path", "(", "__file__", ")", ".", "with_suffix", "(", "\".log\"", ")", ".", "name", ",", "\n", "quiet", "=", "args", ".", "quiet", ",", "\n", ")", "\n", "\n", "# Log command-line arguments", "\n", "logging", ".", "info", "(", "\"Running with command-line arguments :\"", ")", "\n", "for", "arg", ",", "value", "in", "vars", "(", "args", ")", ".", "items", "(", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f\"- {arg} : {value}\"", ")", "\n", "\n", "# Iterate over the training data", "\n", "", "logging", ".", "info", "(", "\"Start learning...\"", ")", "\n", "extension", "=", "\"json\"", "if", "args", ".", "dataset", "!=", "\"lmd\"", "else", "\"json.gz\"", "\n", "filenames", "=", "list", "(", "args", ".", "input_dir", ".", "glob", "(", "f\"train/*.{extension}\"", ")", ")", "\n", "assert", "filenames", ",", "\"No input files found.\"", "\n", "if", "args", ".", "n_jobs", "==", "1", ":", "\n", "        ", "counts", "=", "sum", "(", "\n", "process", "(", "filename", ",", "args", ".", "dataset", ")", "\n", "for", "filename", "in", "tqdm", ".", "tqdm", "(", "filenames", ",", "disable", "=", "args", ".", "quiet", ",", "ncols", "=", "80", ")", "\n", ")", "\n", "", "else", ":", "\n", "        ", "counts", "=", "sum", "(", "\n", "joblib", ".", "Parallel", "(", "args", ".", "n_jobs", ",", "verbose", "=", "5", ")", "(", "\n", "joblib", ".", "delayed", "(", "process", ")", "(", "filename", ",", "args", ".", "dataset", ")", "\n", "for", "filename", "in", "filenames", "\n", ")", "\n", ")", "\n", "\n", "# Get permutations", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.parse_arguments": [[21, 64], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["\n", "def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input filename or directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-of\"", ",", "\n", "\"--onsets_filename\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"onsets filename\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-a\"", ",", "\n", "\"--audio\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"whether to write audio\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\n", "\"--suffix\"", ",", "\n", "default", "=", "\"pred\"", ",", "\n", "help", "=", "\"suffix to the output filename(s)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict": [[66, 91], ["np.array.sort", "numpy.array", "numpy.loadtxt", "numpy.full", "len", "np.array.append"], "function", ["None"], ["\n", "", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.process": [[93, 132], ["muspy.load", "predict.predict", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample_flat", "muspy.write_audio", "music.deepcopy.tracks.append", "arranger.utils.save_sample_flat", "muspy.write_audio"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.predict.predict", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample_flat", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.synthesize_all.write_audio"], ["for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.predict.main": [[134, 168], ["predict.parse_arguments", "arranger.utils.setup_loggers", "logging.debug", "vars().items", "parse_arguments.input.is_file", "logging.info", "list", "logging.info", "tqdm.tqdm", "NotADirectoryError", "logging.debug", "predict.process", "parse_arguments.input.glob", "predict.process", "parse_arguments.output_dir.is_dir", "vars", "pathlib.Path().with_suffix", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments": [[25, 55], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["\n", "def", "parse_arguments", "(", ")", ":", "\n", "    ", "\"\"\"Parse command-line arguments.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-i\"", ",", "\n", "\"--input_dir\"", ",", "\n", "type", "=", "Path", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"input data directory\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-o\"", ",", "\"--output_dir\"", ",", "type", "=", "Path", ",", "required", "=", "True", ",", "help", "=", "\"output directory\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-d\"", ",", "\n", "\"--dataset\"", ",", "\n", "required", "=", "True", ",", "\n", "choices", "=", "(", "\"bach\"", ",", "\"musicnet\"", ",", "\"nes\"", ",", "\"lmd\"", ")", ",", "\n", "help", "=", "\"dataset key\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-s\"", ",", "\"--states\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"use state array\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-j\"", ",", "\"--n_jobs\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"number of workers\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"-q\"", ",", "\"--quiet\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"reduce output verbosity\"", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process": [[57, 145], ["muspy.load", "list", "len", "numpy.zeros", "zip", "numpy.array", "numpy.array", "numpy.full_like", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "muspy.load.deepcopy", "arranger.utils.reconstruct_tracks", "arranger.utils.save_sample", "arranger.utils.save_comparison", "[].keys", "list.index", "len", "numpy.argmax", "numpy.loadtxt", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "music.deepcopy.tracks.append", "arranger.utils.save_sample", "arranger.utils.save_comparison", "np.array.append", "np.array.append", "sorted", "zip", "operator.itemgetter"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.reconstruct_tracks", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_sample", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.save_comparison"], ["\n", "", "def", "_predict_without_states", "(", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ")", ":", "\n", "    ", "predictions", "=", "[", "]", "\n", "for", "note_idx", "in", "collected", ":", "\n", "# Find the labels", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "            ", "label", "=", "onsets", ".", "index", "(", "note_idx", ")", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "score", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "score", "[", "j", "]", "=", "-", "99999", "\n", "# Find the label with the highest score", "\n", "", "", "label", "=", "np", ".", "argmax", "(", "score", ")", "\n", "# Set prediction", "\n", "", "predictions", ".", "append", "(", "label", ")", "\n", "", "return", "predictions", "\n", "\n", "\n", "", "def", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", ":", "\n", "# Compute the scores", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "(", "len", "(", "collected", ")", ",", "n_tracks", ")", ",", "int", ")", "\n", "for", "idx", ",", "note_idx", "in", "enumerate", "(", "collected", ")", ":", "\n", "# Find the label", "\n", "        ", "if", "note_idx", "in", "onsets", ":", "\n", "# Set a large score for the correct label", "\n", "            ", "scores", "[", "idx", ",", "onsets", ".", "index", "(", "note_idx", ")", "]", "=", "99999", "\n", "", "else", ":", "\n", "# Set the score to negative absolute pitch difference", "\n", "            ", "scores", "[", "idx", "]", "=", "-", "np", ".", "square", "(", "last_pitches", "-", "notes", "[", "note_idx", ",", "1", "]", ")", "\n", "# Substract a large number if the track is active", "\n", "scores", "[", "idx", "]", "-=", "99999", "*", "(", "track_states", ">", "0", ")", "\n", "# Set a large negative score if the note appears before the", "\n", "# track onset", "\n", "for", "j", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "                ", "if", "onset", "is", "None", "or", "note_idx", "<", "onset", ":", "\n", "                    ", "scores", "[", "idx", ",", "j", "]", "=", "-", "9999999", "\n", "\n", "# Find the optimal labels", "\n", "", "", "", "", "max_score", "=", "-", "99999999", "\n", "predictions", "=", "None", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "range", "(", "n_tracks", ")", ",", "len", "(", "collected", ")", ")", ":", "\n", "        ", "score", "=", "np", ".", "sum", "(", "scores", "[", "range", "(", "len", "(", "collected", ")", ")", ",", "permutation", "]", ")", "\n", "if", "score", ">=", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "predictions", "=", "permutation", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "predict", "(", "notes", ",", "onsets", ",", "n_tracks", ",", "states", ")", ":", "\n", "    ", "\"\"\"Predict the labels.\"\"\"", "\n", "# Create the prediction array", "\n", "predictions", "=", "np", ".", "zeros", "(", "len", "(", "notes", ")", ",", "int", ")", "\n", "\n", "# Initialize states (recording the time until when each track is active)", "\n", "track_states", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "if", "states", "else", "None", "\n", "\n", "# Initialize last pitches (recording the last active pitch for each track)", "\n", "last_pitches", "=", "np", ".", "zeros", "(", "n_tracks", ",", "int", ")", "\n", "for", "i", ",", "onset", "in", "enumerate", "(", "onsets", ")", ":", "\n", "        ", "if", "onset", "is", "not", "None", ":", "\n", "            ", "last_pitches", "[", "i", "]", "=", "notes", "[", "onset", "]", "[", "1", "]", "\n", "\n", "# Iterate over the notes", "\n", "", "", "collected", "=", "[", "]", "\n", "time", "=", "notes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "note", "in", "enumerate", "(", "notes", ")", ":", "\n", "        ", "if", "note", "[", "0", "]", "<=", "time", ":", "\n", "            ", "collected", ".", "append", "(", "i", ")", "\n", "continue", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "            ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "                ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "\n", "# Reset the collected notes", "\n"]], "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.main": [[147, 205], ["infer.parse_arguments", "parse_arguments.output_dir.mkdir", "arranger.utils.setup_loggers", "logging.info", "vars().items", "logging.info", "list", "logging.info", "arranger.utils.compute_metrics", "parse_arguments.output_dir.mkdir", "logging.info", "open", "parse_arguments.input_dir.glob", "vars", "line.rstrip", "infer.process", "joblib.Parallel", "zip", "pathlib.Path().with_suffix", "tqdm.tqdm", "joblib.delayed", "zip", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.salu133445_arranger.common.infer.parse_arguments", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.setup_loggers", "home.repos.pwc.inspect_result.salu133445_arranger.arranger.utils.compute_metrics", "home.repos.pwc.inspect_result.salu133445_arranger.common.infer.process"], ["\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "continue", "\n", "\n", "# Update track states", "\n", "", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "# Update last pitches", "\n", "last_pitches", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "1", "]", "\n", "# Update track state to the end time of the note", "\n", "track_states", "[", "label", "]", "=", "notes", "[", "note_idx", ",", "0", "]", "+", "notes", "[", "note_idx", ",", "2", "]", "\n", "\n", "# Reset the collected notes", "\n", "", "collected", "=", "[", "i", "]", "\n", "\n", "# Set current time", "\n", "time", "=", "note", "[", "0", "]", "\n", "\n", "", "if", "not", "states", "or", "len", "(", "collected", ")", ">", "n_tracks", ":", "\n", "# Predict the labels", "\n", "        ", "labels", "=", "_predict_without_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", "\n", ")", "\n", "\n", "# Set prediction and update last pitches", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "else", ":", "\n", "# Update track states", "\n", "        ", "track_states", "[", "track_states", "<=", "time", "]", "=", "0", "\n", "\n", "# Predict the labels", "\n", "labels", "=", "_predict_with_states", "(", "\n", "notes", ",", "collected", ",", "onsets", ",", "last_pitches", ",", "track_states", ",", "n_tracks", "\n", ")", "\n", "\n", "# Set predictions and update track_states", "\n", "for", "note_idx", ",", "label", "in", "zip", "(", "collected", ",", "labels", ")", ":", "\n", "# Set prediction", "\n", "            ", "predictions", "[", "note_idx", "]", "=", "label", "\n", "\n", "", "", "return", "predictions", "\n", "\n", "\n", "", "def", "process", "(", "filename", ",", "states", ",", "dataset", ",", "output_dir", ",", "save", ")", ":", "\n", "    ", "\"\"\"Process a file.\"\"\"", "\n", "# Load the data", "\n"]]}