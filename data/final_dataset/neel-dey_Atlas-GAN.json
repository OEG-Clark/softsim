{"home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.get_inputs": [[306, 313], ["None"], "function", ["None"], ["@", "tf", ".", "function", "\n", "def", "get_inputs", "(", "unconditional_inputs", ",", "conditional_inputs", ")", ":", "\n", "    ", "\"\"\"If conditionally training, append condition tensor to network inputs.\"\"\"", "\n", "if", "conditional", ":", "\n", "        ", "return", "unconditional_inputs", "+", "conditional_inputs", "\n", "", "else", ":", "\n", "        ", "return", "unconditional_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.gen_train_step": [[315, 417], ["gen_tape.gradient", "generator_optimizer.apply_gradients", "list", "tensorflow.reduce_max", "tensorflow.reduce_max", "list", "tensorflow.GradientTape", "generator", "src.losses.generator_loss", "zip", "tb_scalar.keys", "tensorflow.image.convert_image_dtype", "tensorflow.image.convert_image_dtype", "tensorflow.image.convert_image_dtype", "tb_img.keys", "train_script.get_inputs", "tensorflow.zeros", "discriminator", "tensorflow.nn.relu", "tensorflow.nn.relu", "tensorflow.nn.relu", "tensorflow.nn.relu", "tensorflow.nn.relu", "tensorflow.nn.relu", "summary_writer.as_default", "range", "range", "train_script.get_inputs", "len", "tensorflow.summary.scalar", "len", "tensorflow.summary.image"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.losses.generator_loss", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.get_inputs", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.get_inputs"], ["", "", "@", "tf", ".", "function", "\n", "def", "gen_train_step", "(", "input_images", ",", "avg_input", ",", "input_condns", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"\n    Generator training step. Args:\n        input_images: tf tensor of training images.\n        avg_input: tf tensor of linear average repeated 'batch_size' times.\n        input_condns: tf tensor of input condns.\n        epoch: tf tensor of training step.\n    \"\"\"", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "gen_tape", ":", "\n", "# Generator forward pass, get moved atlases, moving average of", "\n", "# displacements, generated atlases (sharp_atlas), and displacement:", "\n", "        ", "moved_atlases", ",", "disp_fields_ms", ",", "sharp_atlases", ",", "disp_fields", "=", "generator", "(", "\n", "get_inputs", "(", "[", "input_images", ",", "avg_input", "]", ",", "[", "input_condns", "]", ")", ",", "\n", "training", "=", "True", ",", "\n", ")", "\n", "\n", "# Not used in paper. If pretraining model with registration-only:", "\n", "if", "epoch", "<", "start_step", ":", "\n", "            ", "d_logits_fake_local", "=", "tf", ".", "zeros", "(", "(", "batch_size", ",", "10", ",", "12", ",", "10", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "d_logits_fake_local", "=", "discriminator", "(", "\n", "get_inputs", "(", "[", "moved_atlases", "]", ",", "[", "input_condns", "]", ")", ",", "\n", "training", "=", "True", ",", "\n", ")", "\n", "\n", "# Get loss values. gen_tv_loss not used.", "\n", "", "(", "gen_total_loss", ",", "gen_gan_loss", ",", "gen_smoothness_loss", ",", "gen_mag_loss", ",", "\n", "gen_sim_loss", ",", "gen_moving_mag_loss", ",", "gen_tv_loss", ")", "=", "generator_loss", "(", "\n", "d_logits_fake_local", ",", "\n", "disp_fields_ms", ",", "\n", "disp_fields", ",", "\n", "moved_atlases", ",", "\n", "input_images", ",", "\n", "epoch", ",", "\n", "sharp_atlases", ",", "\n", "g_loss_wts", ",", "\n", "start_step", "=", "start_step", ",", "\n", "reg_loss_type", "=", "reg_loss", ",", "\n", ")", "\n", "\n", "# Get gradients:", "\n", "", "generator_gradients", "=", "gen_tape", ".", "gradient", "(", "\n", "gen_total_loss", ",", "\n", "generator", ".", "trainable_variables", ",", "\n", ")", "\n", "\n", "# Update model:", "\n", "generator_optimizer", ".", "apply_gradients", "(", "\n", "zip", "(", "generator_gradients", ",", "generator", ".", "trainable_variables", ")", ",", "\n", ")", "\n", "\n", "# Tensorboard logging:", "\n", "tb_scalar", "=", "{", "\n", "'total_losses/gen_total_loss'", ":", "gen_total_loss", ",", "\n", "'gan_losses/gen_gan_loss'", ":", "gen_gan_loss", ",", "\n", "'regularizers/gen_smooth_loss'", ":", "gen_smoothness_loss", ",", "\n", "'regularizers/gen_mag_loss'", ":", "gen_mag_loss", ",", "\n", "'regularizers/gen_movmag_loss'", ":", "gen_moving_mag_loss", ",", "\n", "'regularizers/gen_tv_loss'", ":", "gen_tv_loss", ",", "# Not used in paper", "\n", "'registration_losses/gen_sim_loss'", ":", "gen_sim_loss", ",", "\n", "}", "\n", "\n", "tbscalarnames", "=", "list", "(", "tb_scalar", ".", "keys", "(", ")", ")", "\n", "\n", "atlasmax", "=", "tf", ".", "reduce_max", "(", "sharp_atlases", ")", "\n", "movedmax", "=", "tf", ".", "reduce_max", "(", "moved_atlases", ")", "\n", "\n", "tb_img", "=", "{", "\n", "'atlas/1'", ":", "tf", ".", "nn", ".", "relu", "(", "sharp_atlases", "[", ":", ",", "80", ",", ":", ",", ":", ",", ":", "]", ")", "/", "atlasmax", ",", "\n", "'atlas/2'", ":", "tf", ".", "nn", ".", "relu", "(", "sharp_atlases", "[", ":", ",", ":", ",", "96", ",", ":", ",", ":", "]", ")", "/", "atlasmax", ",", "\n", "'atlas/3'", ":", "tf", ".", "nn", ".", "relu", "(", "sharp_atlases", "[", ":", ",", ":", ",", ":", ",", "70", ",", ":", "]", ")", "/", "atlasmax", ",", "\n", "'moved_atlases/1'", ":", "tf", ".", "nn", ".", "relu", "(", "moved_atlases", "[", ":", ",", "80", ",", ":", ",", ":", ",", ":", "]", ")", "/", "movedmax", ",", "\n", "'moved_atlases/2'", ":", "tf", ".", "nn", ".", "relu", "(", "moved_atlases", "[", ":", ",", ":", ",", "96", ",", ":", ",", ":", "]", ")", "/", "movedmax", ",", "\n", "'moved_atlases/3'", ":", "tf", ".", "nn", ".", "relu", "(", "moved_atlases", "[", ":", ",", ":", ",", ":", ",", "70", ",", ":", "]", ")", "/", "movedmax", ",", "\n", "'target_images/1'", ":", "\n", "tf", ".", "image", ".", "convert_image_dtype", "(", "\n", "input_images", "[", ":", ",", "80", ",", ":", ",", ":", ",", ":", "]", ",", "dtype", "=", "tf", ".", "uint8", ",", "\n", ")", ",", "\n", "'target_images/2'", ":", "\n", "tf", ".", "image", ".", "convert_image_dtype", "(", "\n", "input_images", "[", ":", ",", ":", ",", "96", ",", ":", ",", ":", "]", ",", "dtype", "=", "tf", ".", "uint8", ",", "\n", ")", ",", "\n", "'target_images/3'", ":", "\n", "tf", ".", "image", ".", "convert_image_dtype", "(", "\n", "input_images", "[", ":", ",", ":", ",", ":", ",", "70", ",", ":", "]", ",", "dtype", "=", "tf", ".", "uint8", ",", "\n", ")", ",", "\n", "}", "\n", "\n", "tbimg_names", "=", "list", "(", "tb_img", ".", "keys", "(", ")", ")", "\n", "\n", "# Update tensorboard every 10 steps:", "\n", "if", "(", "epoch", "%", "10", ")", "==", "0", ":", "\n", "        ", "with", "summary_writer", ".", "as_default", "(", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "tbscalarnames", ")", ")", ":", "\n", "                ", "tf", ".", "summary", ".", "scalar", "(", "\n", "tbscalarnames", "[", "i", "]", ",", "tb_scalar", "[", "tbscalarnames", "[", "i", "]", "]", ",", "step", "=", "epoch", ",", "\n", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "tbimg_names", ")", ")", ":", "\n", "                ", "tf", ".", "summary", ".", "image", "(", "\n", "tbimg_names", "[", "i", "]", ",", "tb_img", "[", "tbimg_names", "[", "i", "]", "]", ",", "step", "=", "epoch", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.disc_train_step": [[423, 524], ["tensorflow.random.uniform", "tensorflow.random.uniform", "disc_tape.gradient", "discriminator_optimizer.apply_gradients", "tensorflow.GradientTape", "generator", "src.discriminator_augmentations.disc_augment", "src.discriminator_augmentations.disc_augment", "discriminator", "discriminator", "src.losses.discriminator_loss", "zip", "train_script.get_inputs", "train_script.get_inputs", "train_script.get_inputs", "summary_writer.as_default", "tensorflow.summary.scalar", "tensorflow.summary.scalar", "tensorflow.summary.scalar", "gp_tape.gradient", "tensorflow.math.square", "tensorflow.reduce_sum", "tensorflow.GradientTape", "gp_tape.watch", "discriminator", "tensorflow.reduce_mean", "train_script.get_inputs", "numpy.arange", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.disc_augment", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.disc_augment", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.losses.discriminator_loss", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.get_inputs", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.get_inputs", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.get_inputs", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.get_inputs", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange"], ["", "", "", "", "@", "tf", ".", "function", "\n", "def", "disc_train_step", "(", "\n", "input_images", ",", "avg_input", ",", "real_images", ",", "input_condns", ",", "real_condns", ",", "epoch", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Discriminator training step. Args:\n        input_images: tf tensor of training images for template branch.\n        avg_input: tf tensor of linear average repeated 'batch_size' times.\n        input_images: tf tensor of training images for discriminator.\n        input_condns: tf tensor of input condns for template branch.\n        real_condns: tf tensor of input condns for discriminator.\n        epoch: tf tensor of training step.\n    \"\"\"", "\n", "# Reorient image for more augs. Pick a flip (subset of D_4h group):", "\n", "real_choice", "=", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", ")", ",", "0", ",", "4", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "fake_choice", "=", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", ")", ",", "0", ",", "4", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "disc_tape", ":", "\n", "# Generator forward pass:", "\n", "        ", "moved_atlases", ",", "_", ",", "_", ",", "_", "=", "generator", "(", "\n", "get_inputs", "(", "[", "input_images", ",", "avg_input", "]", ",", "[", "input_condns", "]", ")", ",", "\n", "training", "=", "True", ",", "\n", ")", "\n", "\n", "# Discriminator augmentation sequence on both fakes and reals:", "\n", "moved_atlases", "=", "disc_augment", "(", "\n", "moved_atlases", ",", "fake_choice", ",", "intensity_mods", "=", "False", ",", "\n", ")", "\n", "real_images", "=", "disc_augment", "(", "\n", "real_images", ",", "real_choice", ",", "intensity_mods", "=", "False", ",", "\n", ")", "\n", "\n", "# Discriminator forward passes:", "\n", "d_logits_real_local", "=", "discriminator", "(", "\n", "get_inputs", "(", "[", "real_images", "]", ",", "[", "real_condns", "]", ")", ",", "\n", "training", "=", "True", ",", "\n", ")", "\n", "d_logits_fake_local", "=", "discriminator", "(", "\n", "get_inputs", "(", "[", "moved_atlases", "]", ",", "[", "input_condns", "]", ")", ",", "\n", "training", "=", "True", ",", "\n", ")", "\n", "\n", "# Get loss:", "\n", "disc_loss", "=", "discriminator_loss", "(", "\n", "d_logits_real_local", ",", "\n", "d_logits_fake_local", ",", "\n", ")", "\n", "\n", "# Get R1 gradient penalty from Mescheder, et al 2017:", "\n", "# Gradient penalty inside gradient with tf.function leads to lots of", "\n", "# if/else blocks for the tf2 graph.", "\n", "if", "lambda_gp", ">", "0.0", ":", "\n", "# Every \"lazy_reg\" iterations compute the R1 gradient penalty:", "\n", "            ", "if", "(", "epoch", "%", "lazy_reg", ")", "==", "0", ":", "\n", "                ", "new_real_batch", "=", "1.0", "*", "real_images", "\n", "new_label", "=", "1.0", "*", "real_condns", "\n", "with", "tf", ".", "GradientTape", "(", "persistent", "=", "True", ")", "as", "gp_tape", ":", "\n", "                    ", "gp_tape", ".", "watch", "(", "new_real_batch", ")", "\n", "d_logits_real_local_new", "=", "discriminator", "(", "\n", "get_inputs", "(", "[", "new_real_batch", "]", ",", "[", "new_label", "]", ")", ",", "\n", "training", "=", "True", ",", "\n", ")", "\n", "\n", "", "grad", "=", "gp_tape", ".", "gradient", "(", "\n", "d_logits_real_local_new", ",", "new_real_batch", ",", "\n", ")", "\n", "grad_sqr", "=", "tf", ".", "math", ".", "square", "(", "grad", ")", "\n", "\n", "grad_sqr_sum", "=", "tf", ".", "reduce_sum", "(", "\n", "grad_sqr", ",", "\n", "axis", "=", "np", ".", "arange", "(", "1", ",", "len", "(", "grad_sqr", ".", "shape", ")", ")", ",", "\n", ")", "\n", "\n", "gp", "=", "(", "lambda_gp", "/", "2.0", ")", "*", "tf", ".", "reduce_mean", "(", "grad_sqr_sum", ")", "\n", "", "else", ":", "\n", "                ", "gp", "=", "0.0", "\n", "", "", "else", ":", "\n", "            ", "gp", "=", "0.0", "\n", "\n", "# Total loss:", "\n", "", "total_disc_loss", "=", "disc_loss", "+", "gp", "\n", "\n", "", "discriminator_gradients", "=", "disc_tape", ".", "gradient", "(", "\n", "total_disc_loss", ",", "\n", "discriminator", ".", "trainable_variables", ",", "\n", ")", "\n", "\n", "discriminator_optimizer", ".", "apply_gradients", "(", "\n", "zip", "(", "discriminator_gradients", ",", "discriminator", ".", "trainable_variables", ")", ",", "\n", ")", "\n", "\n", "if", "(", "epoch", "%", "10", ")", "==", "0", ":", "\n", "        ", "with", "summary_writer", ".", "as_default", "(", ")", ":", "\n", "            ", "tf", ".", "summary", ".", "scalar", "(", "\n", "'total_losses/total_disc_loss'", ",", "total_disc_loss", ",", "step", "=", "epoch", ",", "\n", ")", "\n", "tf", ".", "summary", ".", "scalar", "(", "\n", "'gan_losses/disc_loss'", ",", "disc_loss", ",", "step", "=", "epoch", ",", "\n", ")", "\n", "tf", ".", "summary", ".", "scalar", "(", "\n", "'regularizers/gp'", ",", "gp", ",", "step", "=", "epoch", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.fit": [[531, 585], ["range", "print", "checkpoint.save", "time.time", "print", "range", "print", "print", "next", "range", "checkpoint.save", "print", "range", "iter", "train_script.gen_train_step", "time.time", "next", "train_script.disc_train_step", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "iter", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.gen_train_step", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.None.train_script.disc_train_step"], ["", "", "", "def", "fit", "(", "epochs", ",", "disc_train_steps", "=", "1", ",", "gen_train_steps", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Fit framework. Args:\n        epochs: Number of epochs\n        disc_train_steps: Number of discriminator updates in each GAN cycle.\n        gen_train_steps: Number of discriminator updates in each GAN cycle.\n    \"\"\"", "\n", "for", "epoch", "in", "range", "(", "epochs", ")", ":", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Epoch: \"", ",", "epoch", ")", "\n", "\n", "# Train", "\n", "for", "n", "in", "range", "(", "steps", ")", ":", "\n", "            ", "print", "(", "'.'", ",", "end", "=", "''", ")", "\n", "if", "(", "n", "+", "1", ")", "%", "100", "==", "0", ":", "\n", "                ", "print", "(", ")", "\n", "\n", "", "if", "(", "n", "+", "epoch", "*", "steps", ")", ">=", "start_step", ":", "\n", "                ", "for", "_", "in", "range", "(", "disc_train_steps", ")", ":", "\n", "                    ", "(", "target_images", ",", "real_images", ",", "\n", "target_condns", ",", "real_condns", ")", "=", "next", "(", "\n", "iter", "(", "Dtrain_data_generator", ")", ",", "\n", ")", "\n", "\n", "disc_train_step", "(", "\n", "tf", ".", "convert_to_tensor", "(", "target_images", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "convert_to_tensor", "(", "avg_batch", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "convert_to_tensor", "(", "real_images", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "convert_to_tensor", "(", "target_condns", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "convert_to_tensor", "(", "real_condns", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "convert_to_tensor", "(", "(", "n", "+", "epoch", "*", "steps", ")", ",", "dtype", "=", "tf", ".", "int64", ")", ",", "\n", ")", "\n", "\n", "", "", "target_images", ",", "target_condns", "=", "next", "(", "iter", "(", "Gtrain_data_generator", ")", ")", "\n", "\n", "for", "_", "in", "range", "(", "gen_train_steps", ")", ":", "\n", "                ", "gen_train_step", "(", "\n", "tf", ".", "convert_to_tensor", "(", "target_images", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "convert_to_tensor", "(", "avg_batch", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "convert_to_tensor", "(", "target_condns", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "convert_to_tensor", "(", "(", "n", "+", "epoch", "*", "steps", ")", ",", "dtype", "=", "tf", ".", "int64", ")", ",", "\n", ")", "\n", "\n", "", "", "print", "(", ")", "\n", "\n", "# saving (checkpoint) the model every 20 epochs", "\n", "if", "(", "epoch", "+", "1", ")", "%", "1", "==", "0", ":", "\n", "            ", "checkpoint", ".", "save", "(", "file_prefix", "=", "checkpoint_prefix", ")", "\n", "\n", "", "", "print", "(", "'Time taken for epoch {} is {} sec\\n'", ".", "format", "(", "\n", "epoch", "+", "1", ",", "time", ".", "time", "(", ")", "-", "start", ",", "\n", ")", ",", "\n", ")", "\n", "checkpoint", ".", "save", "(", "file_prefix", "=", "checkpoint_prefix", ")", "# Save checkpoint", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block": [[27, 127], ["getattr", "getattr", "getattr", "tensorflow.pad", "len", "tf.pad.get_shape", "tensorflow_addons.layers.SpectralNormalization", "getattr.", "tensorflow_addons.layers.InstanceNormalization", "film.FiLM", "tensorflow.LeakyReLU", "getattr.", "getattr.", "getattr.", "ValueError"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad"], ["def", "conv_block", "(", "\n", "x_in", ",", "\n", "nf", ",", "\n", "condn_emb", "=", "None", ",", "\n", "mode", "=", "'const'", ",", "\n", "activation", "=", "True", ",", "\n", "sn", "=", "False", ",", "\n", "instancen", "=", "False", ",", "\n", "stride", "=", "1", ",", "\n", "kernel_size", "=", "3", ",", "\n", "init", "=", "'default'", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Convolution module including convolution followed by leakyrelu.\n    Args:\n        x_in: input feature map\n        nf: number of filters\n        condn_emb: if using FiLM, this is the condition embedding.\n        mode: either upsample, downsample or leave at constant resolution.\n        activation: bool indicating whether to use a leaky relu.\n        sn: bool indicating whether to use spectral norm.\n        instancen: bool for instance norm. Not used in paper.\n        stride: convolutional stride\n        kernel_size: kernel size\n        init: weight initialization. either 'default' or 'orthogonal'\n    \"\"\"", "\n", "\n", "ndims", "=", "len", "(", "x_in", ".", "get_shape", "(", ")", ")", "-", "2", "\n", "assert", "ndims", "in", "[", "1", ",", "2", ",", "3", "]", ",", "\"ndims supported to up to 3. found: %d\"", "%", "ndims", "\n", "\n", "maxpool", "=", "getattr", "(", "KL", ",", "'MaxPooling%dD'", "%", "ndims", ")", "\n", "upsample", "=", "getattr", "(", "KL", ",", "'UpSampling%dD'", "%", "ndims", ")", "\n", "conv", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "\n", "# If unconditional and not using FiLM, then train conv layers with bias:", "\n", "if", "condn_emb", "is", "None", ":", "\n", "        ", "bias", "=", "True", "\n", "", "else", ":", "\n", "        ", "bias", "=", "False", "\n", "\n", "# Reflection pad:", "\n", "", "x_in", "=", "tf", ".", "pad", "(", "\n", "x_in", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\n", "\"REFLECT\"", ",", "\n", ")", "\n", "\n", "# Specify initializations:", "\n", "if", "init", "==", "'default'", "or", "init", "is", "None", ":", "\n", "        ", "initialization", "=", "None", "\n", "", "elif", "init", "==", "'orthogonal'", ":", "\n", "        ", "initialization", "=", "'orthogonal'", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "\n", "# If using spectral normalization:", "\n", "", "if", "sn", ":", "\n", "        ", "x_out", "=", "SpectralNormalization", "(", "conv", "(", "\n", "nf", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "bias", ",", "\n", "strides", "=", "stride", ",", "\n", "kernel_initializer", "=", "initialization", ",", "\n", ")", ")", "(", "x_in", ")", "\n", "", "else", ":", "\n", "        ", "x_out", "=", "conv", "(", "\n", "nf", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "bias", ",", "\n", "strides", "=", "stride", ",", "\n", "kernel_initializer", "=", "initialization", ",", "\n", ")", "(", "x_in", ")", "\n", "\n", "# If using instance normalization. Not used in paper.", "\n", "", "if", "instancen", ":", "\n", "        ", "x_out", "=", "InstanceNormalization", "(", "\n", "center", "=", "True", ",", "\n", "scale", "=", "True", ",", "\n", ")", "(", "x_out", ")", "\n", "\n", "# If using FiLM:", "\n", "", "if", "condn_emb", "is", "not", "None", ":", "\n", "        ", "x_out", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "x_out", ",", "condn_emb", "]", ")", "\n", "\n", "# Nonlinearity:", "\n", "", "if", "activation", ":", "\n", "        ", "x_out", "=", "KL", ".", "LeakyReLU", "(", "0.2", ")", "(", "x_out", ")", "\n", "\n", "# Up/down sample:", "\n", "", "if", "mode", "==", "'up'", ":", "\n", "        ", "x_out", "=", "upsample", "(", ")", "(", "x_out", ")", "\n", "", "elif", "mode", "==", "'down'", ":", "\n", "        ", "x_out", "=", "maxpool", "(", ")", "(", "x_out", ")", "# not used in paper, we used strided convs", "\n", "", "elif", "mode", "==", "'const'", ":", "\n", "        ", "pass", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'mode has to be up/down/const w.r.t. spatial res'", ")", "\n", "\n", "", "return", "x_out", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.const_inp": [[129, 136], ["tensorflow.constant", "tensorflow.expand_dims", "tensorflow.broadcast_to", "tensorflow.shape"], "function", ["None"], ["", "@", "tf", ".", "function", "\n", "def", "const_inp", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"Used to give a layer a constant input of 1.\"\"\"", "\n", "batch_size", "=", "tf", ".", "shape", "(", "tensor", ")", "[", "0", "]", "\n", "constant", "=", "tf", ".", "constant", "(", "1.0", ")", "\n", "constant", "=", "tf", ".", "expand_dims", "(", "constant", ",", "axis", "=", "0", ")", "\n", "return", "tf", ".", "broadcast_to", "(", "constant", ",", "shape", "=", "(", "batch_size", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.Generator": [[142, 454], ["tensorflow.keras.layers.Input", "tensorflow.keras.layers.Input", "tensorflow.concatenate", "networks.conv_block", "networks.conv_block", "networks.conv_block", "networks.conv_block", "networks.conv_block", "networks.conv_block", "tensorflow.concatenate", "networks.conv_block", "tensorflow.concatenate", "networks.conv_block", "tensorflow.concatenate", "networks.conv_block", "networks.conv_block", "networks.conv_block", "tensorflow.pad", "tensorflow.keras.layers.Input", "neurite.tf.layers.LocalParamWithInput", "neurite.tf.layers.LocalParamWithInput.", "networks.conv_block", "tensorflow.concatenate", "tensorflow.Conv3D", "voxelmorph.tf.layers.VecInt", "neurite.tf.layers.MeanStream_old", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.initializers.RandomNormal", "networks.conv_dec", "range", "tensorflow.cast", "voxelmorph.tf.layers.RescaleTransform", "voxelmorph.tf.layers.SpatialTransformer", "voxelmorph.tf.layers.SpatialTransformer", "tensorflow.keras.initializers.RandomNormal", "tensorflow.Dense", "tensorflow.Reshape", "tensorflow.Conv3D", "range", "networks.conv_block", "range", "networks.conv_dec_film", "tensorflow.math.greater", "tensorflow.Conv3D", "tensorflow.Lambda", "tensorflow.Dense", "tensorflow.Reshape", "film.FiLM", "networks.conv_block", "networks.conv_block", "tensorflow.Conv3D", "tensorflow.Activation", "networks.conv_block", "range", "networks.conv_dec_film", "tensorflow.keras.initializers.RandomNormal", "tensorflow.keras.initializers.RandomNormal", "tensorflow.Dense", "tensorflow.LeakyReLU", "tensorflow.Lambda", "tensorflow.Dense", "tensorflow.Reshape", "networks.conv_block", "networks.conv_block", "tensorflow.Conv3D", "tensorflow.Activation", "tensorflow.keras.initializers.RandomNormal", "tensorflow.keras.initializers.RandomNormal", "tensorflow.keras.initializers.RandomNormal", "tensorflow.keras.initializers.RandomNormal"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.conv_dec", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_dec_film", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_dec_film", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block"], ["", "def", "Generator", "(", "\n", "ch", "=", "32", ",", "\n", "full_size", "=", "False", ",", "\n", "conditional", "=", "True", ",", "\n", "normreg", "=", "False", ",", "\n", "atlas_model", "=", "'ours'", ",", "\n", "input_resolution", "=", "[", "160", ",", "192", ",", "160", ",", "1", "]", ",", "\n", "clip_bckgnd", "=", "True", ",", "\n", "initialization", "=", "'default'", ",", "\n", "n_condns", "=", "1", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        ch : int\n            Channel multiplier.\n        full_size : bool\n            Flag indicating whether vel. fields estimated at half or full res.\n        atlas_model : str\n            One of {'ours', 'voxelmorph'}\n        conditional : bool\n            Flag indicating whether generator model is conditional.\n        normreg : bool\n            Flag indicating whether InstanceNorm is used. Not used in paper.\n        input_resolution: list\n            Input image dimensions.\n        clip_bckgnd: bool\n            Whether to use a foreground mask during training on templates.\n        initialization: str\n            Weight init. One of \"default\" or \"orthogonal\".\n        n_condns: int\n            Number of conditions if training conditionally.\n    \"\"\"", "\n", "image_inputs", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "input_resolution", ")", "\n", "atlas_inputs", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "input_resolution", ")", "\n", "\n", "if", "conditional", ":", "\n", "        ", "condn", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "n_condns", ",", ")", ")", "\n", "\n", "# These are used in the template generation branch only for Atlas-HQ", "\n", "# Also for the registration sub-network.", "\n", "", "if", "initialization", "==", "'orthogonal'", ":", "\n", "        ", "init", "=", "'orthogonal'", "\n", "vel_init", "=", "'orthogonal'", "\n", "", "elif", "initialization", "==", "'default'", ":", "\n", "        ", "init", "=", "None", "\n", "vel_init", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1e-5", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "\n", "# Atlas sharpening branch:", "\n", "# TODO: Long if/else sequence, abstract out and make cleaner.", "\n", "# VXM archs taken verbatim from their repos", "\n", "", "if", "atlas_model", "==", "'voxelmorph'", "and", "conditional", "is", "False", ":", "\n", "# vxm unconditional model:", "\n", "        ", "atlas_layer", "=", "LocalParamWithInput", "(", "\n", "name", "=", "'atlas'", ",", "\n", "shape", "=", "input_resolution", ",", "\n", "mult", "=", "1.0", ",", "\n", "initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1e-7", ",", "\n", ")", ",", "\n", ")", "\n", "\n", "new_atlas", "=", "atlas_layer", "(", "atlas_inputs", ")", "\n", "\n", "", "elif", "atlas_model", "==", "'voxelmorph'", "and", "conditional", "is", "True", ":", "\n", "# vxm conditional model:", "\n", "# TODO: fix hardcoding", "\n", "        ", "condn_emb_vxm", "=", "KL", ".", "Dense", "(", "(", "80", "*", "96", "*", "80", "*", "8", ")", ",", "activation", "=", "'elu'", ")", "(", "condn", ")", "\n", "condn_emb_vxm", "=", "KL", ".", "Reshape", "(", "(", "80", ",", "96", ",", "80", ",", "8", ")", ")", "(", "condn_emb_vxm", ")", "\n", "\n", "# Atlas sharpening branch:", "\n", "dec_out", "=", "conv_dec", "(", "\n", "condn_emb_vxm", ",", "# vxm optimized parameters", "\n", "8", ",", "\n", "(", "80", ",", "96", ",", "80", ",", "8", ")", ",", "\n", "2", ",", "\n", "[", "3", ",", "3", ",", "3", "]", ",", "\n", "8", ",", "\n", ")", "\n", "last_tensor", "=", "dec_out", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "last_tensor", "=", "KL", ".", "Conv3D", "(", "\n", "8", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlas_ec_%d'", "%", "i", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "", "pout", "=", "KL", ".", "Conv3D", "(", "\n", "1", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlasmodel_c'", ",", "\n", "kernel_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "stddev", "=", "1e-7", ",", "\n", ")", ",", "\n", "bias_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "stddev", "=", "1e-7", ",", "\n", ")", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "new_atlas", "=", "atlas_inputs", "+", "pout", "\n", "\n", "", "elif", "atlas_model", "==", "'ours'", "and", "conditional", "is", "True", ":", "\n", "        ", "\"\"\"Start from a learned vector which is then conditioned.\"\"\"", "\n", "\n", "# FiLM branch:", "\n", "# TODO: fix hardcoding", "\n", "condn_vec", "=", "1.0", "*", "condn", "\n", "for", "_", "in", "range", "(", "4", ")", ":", "\n", "            ", "condn_vec", "=", "KL", ".", "Dense", "(", "\n", "64", ",", "\n", "kernel_initializer", "=", "init", ",", "\n", ")", "(", "condn_vec", ")", "\n", "condn_vec", "=", "KL", ".", "LeakyReLU", "(", "0.2", ")", "(", "condn_vec", ")", "\n", "\n", "# Input layer of decoder: learned parameter vector", "\n", "", "const_vec", "=", "KL", ".", "Lambda", "(", "const_inp", ")", "(", "condn", ")", "# use condn to get batch info", "\n", "condn_emb_vxm", "=", "KL", ".", "Dense", "(", "\n", "(", "80", "*", "96", "*", "80", "*", "8", ")", ",", "\n", "kernel_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "0.02", ",", "\n", ")", ",", "\n", "bias_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "0.02", ",", "\n", ")", ",", "\n", ")", "(", "const_vec", ")", "\n", "\n", "# Reshape to feature map and FiLM for convolutional processing:", "\n", "condn_emb_vxm", "=", "KL", ".", "Reshape", "(", "(", "80", ",", "96", ",", "80", ",", "8", ")", ")", "(", "condn_emb_vxm", ")", "\n", "condn_emb_vxm", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "condn_emb_vxm", ",", "condn_vec", "]", ")", "\n", "\n", "# 5 ResBlocks at lower resolution:", "\n", "s1", "=", "conv_block", "(", "\n", "condn_emb_vxm", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "1.0", "*", "s1", "\n", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "            ", "sip", "=", "sres", "\n", "sres", "=", "conv_block", "(", "\n", "sres", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "conv_block", "(", "\n", "sres", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "sres", "+", "sip", "\n", "\n", "# Upsample --> More Conv+FiLM+LeakyReLU blocks:", "\n", "", "dec_out", "=", "conv_dec_film", "(", "\n", "sres", ",", "\n", "condn_vec", ",", "\n", "8", ",", "\n", "(", "80", ",", "96", ",", "80", ",", "8", ")", ",", "\n", "2", ",", "\n", "[", "3", ",", "3", ",", "3", "]", ",", "\n", "8", ",", "\n", "sn", "=", "True", ",", "\n", "init", "=", "init", ",", "\n", ")", "\n", "last_tensor", "=", "dec_out", "\n", "\n", "pout", "=", "KL", ".", "Conv3D", "(", "\n", "1", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlasmodel_c'", ",", "\n", "kernel_initializer", "=", "init", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "pout", "=", "KL", ".", "Activation", "(", "'tanh'", ")", "(", "pout", ")", "\n", "\n", "# Add to linear average:", "\n", "new_atlas", "=", "atlas_inputs", "+", "pout", "\n", "\n", "", "elif", "atlas_model", "==", "'ours'", "and", "conditional", "is", "False", ":", "\n", "        ", "\"\"\"Start from a learned vector.\"\"\"", "\n", "\n", "condn_vec", "=", "None", "\n", "\n", "# Input layer of decoder: learned parameter vector", "\n", "const_vec", "=", "KL", ".", "Lambda", "(", "const_inp", ")", "(", "image_inputs", ")", "# use ip for batch info", "\n", "condn_emb_vxm", "=", "KL", ".", "Dense", "(", "\n", "(", "80", "*", "96", "*", "80", "*", "8", ")", ",", "\n", "kernel_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "0.02", ",", "\n", ")", ",", "\n", "bias_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "0.02", ",", "\n", ")", ",", "\n", ")", "(", "const_vec", ")", "\n", "\n", "condn_emb_vxm", "=", "KL", ".", "Reshape", "(", "(", "80", ",", "96", ",", "80", ",", "8", ")", ")", "(", "condn_emb_vxm", ")", "\n", "\n", "# 5 ResBlocks at lower resolution:", "\n", "s1", "=", "conv_block", "(", "\n", "condn_emb_vxm", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "1.0", "*", "s1", "\n", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "            ", "sip", "=", "sres", "\n", "sres", "=", "conv_block", "(", "\n", "sres", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "conv_block", "(", "\n", "sres", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "sres", "+", "sip", "\n", "\n", "# Upsample --> More Conv+FiLM+LeakyReLU blocks:", "\n", "", "dec_out", "=", "conv_dec_film", "(", "\n", "sres", ",", "\n", "condn_vec", ",", "\n", "8", ",", "\n", "(", "80", ",", "96", ",", "80", ",", "8", ")", ",", "\n", "2", ",", "\n", "[", "3", ",", "3", ",", "3", "]", ",", "\n", "8", ",", "\n", "sn", "=", "True", ",", "\n", "conditional", "=", "False", ",", "\n", "init", "=", "init", ",", "\n", ")", "\n", "last_tensor", "=", "dec_out", "\n", "\n", "pout", "=", "KL", ".", "Conv3D", "(", "\n", "1", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlasmodel_c'", ",", "\n", "kernel_initializer", "=", "init", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "pout", "=", "KL", ".", "Activation", "(", "'tanh'", ")", "(", "pout", ")", "\n", "\n", "# Add to linear average:", "\n", "new_atlas", "=", "atlas_inputs", "+", "pout", "\n", "\n", "", "if", "clip_bckgnd", ":", "\n", "        ", "new_atlas", "=", "new_atlas", "*", "tf", ".", "cast", "(", "\n", "tf", ".", "math", ".", "greater", "(", "atlas_inputs", ",", "1e-2", ")", ",", "tf", ".", "float32", ",", "\n", ")", "\n", "\n", "# Registration network. Taken from vxm:", "\n", "# Encoder:", "\n", "", "inp", "=", "KL", ".", "concatenate", "(", "[", "image_inputs", ",", "new_atlas", "]", ")", "\n", "d1", "=", "conv_block", "(", "inp", ",", "ch", ",", "stride", "=", "2", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "d2", "=", "conv_block", "(", "d1", ",", "ch", ",", "stride", "=", "2", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "d3", "=", "conv_block", "(", "d2", ",", "ch", ",", "stride", "=", "2", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "d4", "=", "conv_block", "(", "d3", ",", "ch", ",", "stride", "=", "2", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "\n", "# Bottleneck:", "\n", "dres", "=", "conv_block", "(", "d4", ",", "ch", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "\n", "# Decoder:", "\n", "d5", "=", "conv_block", "(", "dres", ",", "ch", ",", "mode", "=", "'up'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "d5", "=", "KL", ".", "concatenate", "(", "[", "d5", ",", "d3", "]", ")", "\n", "\n", "d6", "=", "conv_block", "(", "d5", ",", "ch", ",", "mode", "=", "'up'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "d6", "=", "KL", ".", "concatenate", "(", "[", "d6", ",", "d2", "]", ")", "\n", "\n", "d7", "=", "conv_block", "(", "d6", ",", "ch", ",", "mode", "=", "'up'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "d7", "=", "KL", ".", "concatenate", "(", "[", "d7", ",", "d1", "]", ")", "\n", "\n", "if", "full_size", ":", "# if estimating displacements at half-resolution for speed", "\n", "        ", "d7", "=", "conv_block", "(", "\n", "d7", ",", "ch", ",", "mode", "=", "'up'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ",", "\n", ")", "\n", "d7", "=", "KL", ".", "concatenate", "(", "[", "d7", ",", "inp", "]", ")", "\n", "\n", "", "d7", "=", "conv_block", "(", "\n", "d7", ",", "ch", ",", "mode", "=", "'const'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ",", "\n", ")", "\n", "d7", "=", "conv_block", "(", "\n", "d7", ",", "ch", ",", "mode", "=", "'const'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ",", "\n", ")", "\n", "d7", "=", "conv_block", "(", "d7", ",", "ch", "//", "2", ",", "mode", "=", "'const'", ",", "activation", "=", "False", ",", "init", "=", "init", ")", "\n", "\n", "# Get velocity field:", "\n", "d7", "=", "tf", ".", "pad", "(", "d7", ",", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\"REFLECT\"", ")", "\n", "\n", "vel", "=", "KL", ".", "Conv3D", "(", "\n", "filters", "=", "3", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "vel_init", ",", "\n", "name", "=", "'vel_field'", ",", "\n", ")", "(", "d7", ")", "\n", "\n", "# Get diffeomorphic displacement field:", "\n", "diff_field", "=", "VecInt", "(", "method", "=", "'ss'", ",", "int_steps", "=", "5", ",", "name", "=", "'def_field'", ")", "(", "vel", ")", "\n", "\n", "# Get moving average of deformations:", "\n", "diff_field_ms", "=", "MeanStream", "(", "name", "=", "'mean_stream'", ",", "cap", "=", "100", ")", "(", "diff_field", ")", "\n", "\n", "if", "full_size", "is", "False", ":", "# i.e. rescale displacement field to full size", "\n", "# compute regularizers on diff_field_half for efficiency:", "\n", "        ", "diff_field_half", "=", "1.0", "*", "diff_field", "\n", "diff_field", "=", "RescaleTransform", "(", "2.0", ",", "name", "=", "'flowup'", ")", "(", "diff_field", ")", "\n", "moved_atlas", "=", "SpatialTransformer", "(", ")", "(", "[", "new_atlas", ",", "diff_field", "]", ")", "\n", "ops", "=", "[", "moved_atlas", ",", "diff_field_ms", ",", "new_atlas", ",", "diff_field_half", "]", "\n", "", "else", ":", "\n", "        ", "moved_atlas", "=", "SpatialTransformer", "(", ")", "(", "[", "new_atlas", ",", "diff_field", "]", ")", "\n", "ops", "=", "[", "moved_atlas", ",", "diff_field_ms", ",", "new_atlas", ",", "diff_field", "]", "\n", "\n", "", "if", "conditional", ":", "\n", "        ", "return", "tf", ".", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "image_inputs", ",", "atlas_inputs", ",", "condn", "]", ",", "\n", "outputs", "=", "ops", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "return", "tf", ".", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "image_inputs", ",", "atlas_inputs", "]", ",", "\n", "outputs", "=", "ops", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.Discriminator": [[461, 576], ["tensorflow.keras.layers.Input", "networks.conv_block", "networks.conv_block", "networks.conv_block", "networks.conv_block", "networks.conv_block", "tensorflow.keras.layers.Input", "tensorflow.Lambda", "tensorflow.tile", "tensorflow.keras.Model", "tensorflow.keras.Model", "KL.Lambda.", "tensorflow.reshape", "tensorflow.tile", "KL.Lambda.", "tensorflow.Dense", "tensorflow.split", "tensorflow.Conv3D", "tensorflow.reshape", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.Conv3D", "tensorflow.Dense", "tensorflow.Dense", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.reduce_sum", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_block"], ["", "", "def", "Discriminator", "(", "\n", "ch", "=", "32", ",", "\n", "conditional", "=", "True", ",", "\n", "input_resolution", "=", "[", "160", ",", "192", ",", "160", ",", "1", "]", ",", "\n", "sn_out", "=", "True", ",", "\n", "initialization", "=", "'orthogonal'", ",", "\n", "n_condns", "=", "1", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        ch : int\n            Channel multiplier.\n        conditional : bool\n            Flag indicating whether generator model is conditional.\n        input_resolution: list\n            Input image dimensions.\n        sn_out: bool\n            Whether to use SpectralNorm of last layer of discriminator.\n        initialization: str\n            Weight init. One of \"default\" or \"orthogonal\".\n        n_condns: int\n            Number of conditions if training conditionally.\n    \"\"\"", "\n", "inp", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "input_resolution", ",", "name", "=", "'input_image'", ")", "\n", "\n", "if", "initialization", "==", "'orthogonal'", ":", "\n", "        ", "init", "=", "'orthogonal'", "\n", "", "elif", "initialization", "==", "'default'", "or", "initialization", "is", "None", ":", "\n", "        ", "init", "=", "None", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "\n", "# If training conditionally:", "\n", "", "if", "conditional", ":", "\n", "        ", "condn", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "n_condns", ",", ")", ")", "\n", "# If n_condns > 1 with both continuous and categorical attributes,", "\n", "# then continuous attributes can be linearly projected, but categorical", "\n", "# attributes need an embedding matrix, equivalently implemented here", "\n", "# with a bias-free dense layer acting on a one-hot representation:", "\n", "if", "n_condns", "==", "1", ":", "\n", "            ", "condn_age_emb", "=", "KL", ".", "Dense", "(", "ch", ",", "kernel_initializer", "=", "init", ")", "(", "condn", ")", "\n", "", "elif", "n_condns", ">", "1", ":", "# Assumes that 1st idx of condn vector is cont. age", "\n", "            ", "condn_age", ",", "condn_cat", "=", "tf", ".", "split", "(", "condn", ",", "[", "1", ",", "-", "1", "]", ",", "axis", "=", "-", "1", ")", "\n", "condn_age_emb", "=", "KL", ".", "Dense", "(", "ch", ",", "kernel_initializer", "=", "init", ")", "(", "condn_age", ")", "\n", "condn_cat_emb", "=", "KL", ".", "Dense", "(", "\n", "ch", ",", "use_bias", "=", "False", ",", "kernel_initializer", "=", "init", ",", "\n", ")", "(", "condn_cat", ")", "\n", "\n", "# If using spectralnorm:", "\n", "", "", "if", "sn_out", ":", "\n", "        ", "dOP", "=", "SpectralNormalization", "\n", "", "else", ":", "\n", "        ", "dOP", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", ")", "# basically no-op", "\n", "\n", "# Convolutional sequence:", "\n", "", "down1", "=", "conv_block", "(", "inp", ",", "ch", ",", "sn", "=", "True", ",", "stride", "=", "2", ",", "init", "=", "init", ")", "\n", "down2", "=", "conv_block", "(", "down1", ",", "ch", "*", "2", ",", "sn", "=", "True", ",", "stride", "=", "2", ",", "init", "=", "init", ")", "\n", "down3", "=", "conv_block", "(", "down2", ",", "ch", "*", "4", ",", "sn", "=", "True", ",", "stride", "=", "2", ",", "init", "=", "init", ")", "\n", "fin1", "=", "conv_block", "(", "down3", ",", "ch", "*", "8", ",", "sn", "=", "True", ",", "stride", "=", "2", ",", "init", "=", "init", ")", "\n", "\n", "# If using SN on discriminator output:", "\n", "fin1", "=", "conv_block", "(", "fin1", ",", "ch", ",", "sn", "=", "sn_out", ",", "activation", "=", "False", ",", "init", "=", "init", ")", "\n", "\n", "if", "conditional", ":", "\n", "# Local projection discriminator feedback:", "\n", "        ", "op_age", "=", "dOP", "(", "KL", ".", "Conv3D", "(", "\n", "1", ",", "1", ",", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "True", ",", "kernel_initializer", "=", "init", ",", "\n", ")", ")", "(", "fin1", ")", "\n", "\n", "condn_emb_spatial_age", "=", "tf", ".", "tile", "(", "\n", "tf", ".", "reshape", "(", "\n", "condn_age_emb", ",", "\n", "(", "tf", ".", "shape", "(", "condn_age_emb", ")", "[", "0", "]", ",", "1", ",", "1", ",", "\n", "1", ",", "tf", ".", "shape", "(", "condn_age_emb", ")", "[", "-", "1", "]", ")", ",", "\n", ")", ",", "\n", "(", "1", ",", "tf", ".", "shape", "(", "op_age", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "op_age", ")", "[", "2", "]", ",", "\n", "tf", ".", "shape", "(", "op_age", ")", "[", "3", "]", ",", "1", ")", ",", "\n", ")", "\n", "\n", "if", "n_condns", ">", "1", ":", "\n", "            ", "condn_emb_spatial_cat", "=", "tf", ".", "tile", "(", "\n", "tf", ".", "reshape", "(", "\n", "condn_cat_emb", ",", "\n", "(", "tf", ".", "shape", "(", "condn_cat_emb", ")", "[", "0", "]", ",", "1", ",", "1", ",", "\n", "1", ",", "tf", ".", "shape", "(", "condn_cat_emb", ")", "[", "-", "1", "]", ")", ",", "\n", ")", ",", "\n", "(", "1", ",", "tf", ".", "shape", "(", "op_age", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "op_age", ")", "[", "2", "]", ",", "\n", "tf", ".", "shape", "(", "op_age", ")", "[", "3", "]", ",", "1", ")", ",", "\n", ")", "\n", "\n", "op", "=", "(", "\n", "op_age", "+", "\n", "tf", ".", "reduce_sum", "(", "\n", "condn_emb_spatial_cat", "*", "fin1", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ",", "\n", ")", "+", "\n", "tf", ".", "reduce_sum", "(", "\n", "condn_emb_spatial_age", "*", "fin1", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "op", "=", "op_age", "+", "tf", ".", "reduce_sum", "(", "\n", "condn_emb_spatial_age", "*", "fin1", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ",", "\n", ")", "\n", "\n", "", "return", "tf", ".", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "inp", ",", "condn", "]", ",", "outputs", "=", "[", "op", "]", ",", "\n", ")", "\n", "", "else", ":", "# Unconditional", "\n", "        ", "op", "=", "dOP", "(", "KL", ".", "Conv3D", "(", "\n", "1", ",", "1", ",", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "True", ",", "kernel_initializer", "=", "init", ",", "\n", ")", ")", "(", "fin1", ")", "\n", "return", "tf", ".", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "inp", "]", ",", "outputs", "=", "[", "op", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_dec": [[582, 660], ["tuple", "isinstance", "getattr", "range", "len", "isinstance", "getattr", "numpy.round().astype", "range", "getattr.", "getattr.", "numpy.round", "getattr.", "getattr."], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "", "def", "conv_dec", "(", "\n", "input_tensor", ",", "\n", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "name", "=", "None", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "padding", "=", "'same'", ",", "\n", "dilation_rate_mult", "=", "1", ",", "\n", "activation", "=", "'elu'", ",", "\n", "use_residuals", "=", "False", ",", "\n", "final_pred_activation", "=", "'linear'", ",", "\n", "nb_conv_per_level", "=", "2", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "batch_norm", "=", "None", ",", "\n", "convL", "=", "None", ",", "\n", "input_model", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Decoder for conditional vxm architecture.\n\n    Taken directly from vxm/neurite,\n    https://github.com/adalca/neurite/blob/master/neurite/tf/models.py#L725\n\n    \"\"\"", "\n", "\n", "# vol size info", "\n", "ndims", "=", "len", "(", "input_shape", ")", "-", "1", "\n", "input_shape", "=", "tuple", "(", "input_shape", ")", "\n", "if", "isinstance", "(", "pool_size", ",", "int", ")", ":", "\n", "        ", "if", "ndims", ">", "1", ":", "\n", "            ", "pool_size", "=", "(", "pool_size", ",", ")", "*", "ndims", "\n", "", "", "if", "ndims", "==", "1", "and", "isinstance", "(", "pool_size", ",", "tuple", ")", ":", "\n", "        ", "pool_size", "=", "pool_size", "[", "0", "]", "# 1D upsampling takes int not tuple", "\n", "\n", "# prepare layers", "\n", "", "if", "convL", "is", "None", ":", "\n", "        ", "convL", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "", "conv_kwargs", "=", "{", "'padding'", ":", "padding", ",", "'activation'", ":", "activation", "}", "\n", "upsample", "=", "getattr", "(", "KL", ",", "'UpSampling%dD'", "%", "ndims", ")", "\n", "\n", "# up arm:", "\n", "# nb_levels - 1 layers of Deconvolution3D", "\n", "#    (approx via up + conv + ReLu) + merge + conv + ReLu + conv + ReLu", "\n", "lfidx", "=", "0", "\n", "for", "level", "in", "range", "(", "nb_levels", "-", "1", ")", ":", "\n", "        ", "nb_lvl_feats", "=", "np", ".", "round", "(", "\n", "nb_features", "*", "feat_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", ",", "\n", ")", ".", "astype", "(", "int", ")", "\n", "conv_kwargs", "[", "'dilation_rate'", "]", "=", "dilation_rate_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", "\n", "\n", "# upsample matching the max pooling layers size", "\n", "name", "=", "'%s_up_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ")", "\n", "last_tensor", "=", "upsample", "(", "size", "=", "pool_size", ",", "name", "=", "name", ")", "(", "input_tensor", ")", "\n", "\n", "# convolution layers", "\n", "for", "conv", "in", "range", "(", "nb_conv_per_level", ")", ":", "\n", "            ", "if", "layer_nb_feats", "is", "not", "None", ":", "\n", "                ", "nb_lvl_feats", "=", "layer_nb_feats", "[", "lfidx", "]", "\n", "lfidx", "+=", "1", "\n", "\n", "", "name", "=", "'%s_conv_uparm_%d_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ",", "conv", ")", "\n", "if", "conv", "<", "(", "nb_conv_per_level", "-", "1", ")", "or", "(", "not", "use_residuals", ")", ":", "\n", "                ", "last_tensor", "=", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ",", "\n", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "                ", "last_tensor", "=", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "padding", "=", "padding", ",", "name", "=", "name", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "", "", "", "pred_tensor", "=", "convL", "(", "nb_labels", ",", "1", ",", "activation", "=", "None", ")", "(", "last_tensor", ")", "\n", "\n", "return", "pred_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.networks.conv_dec_film": [[665, 800], ["tuple", "isinstance", "tuple", "range", "len", "isinstance", "getattr", "numpy.round().astype", "tuple", "range", "numpy.array", "trilinear.TrilinearResizeLayer", "tensorflow_addons.layers.SpectralNormalization", "getattr.", "film.FiLM", "numpy.round", "numpy.array", "tensorflow.pad", "tensorflow.pad", "getattr.", "tensorflow.int_shape", "tensorflow.LeakyReLU", "tensorflow_addons.layers.SpectralNormalization", "getattr.", "film.FiLM", "tensorflow_addons.layers.SpectralNormalization", "getattr.", "film.FiLM", "getattr.", "getattr."], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad"], ["", "def", "conv_dec_film", "(", "\n", "condn_emb", ",", "\n", "condn_vec", ",", "\n", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "sn", "=", "False", ",", "\n", "conditional", "=", "True", ",", "\n", "name", "=", "None", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "padding", "=", "'valid'", ",", "\n", "dilation_rate_mult", "=", "1", ",", "\n", "use_residuals", "=", "False", ",", "\n", "final_pred_activation", "=", "'linear'", ",", "\n", "nb_conv_per_level", "=", "2", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "convL", "=", "None", ",", "\n", "init", "=", "'default'", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Modified from VXM/neurite to use FiLM layers instead of bias params,\n    https://github.com/adalca/neurite/blob/master/neurite/tf/models.py#L725\n\n    As this function was taken from VXM, it has a lot of inapplicable\n    functionality which will be fixed prior to public release.\n    \"\"\"", "\n", "\n", "# vol size info", "\n", "ndims", "=", "len", "(", "input_shape", ")", "-", "1", "\n", "input_shape", "=", "tuple", "(", "input_shape", ")", "\n", "if", "isinstance", "(", "pool_size", ",", "int", ")", ":", "\n", "        ", "if", "ndims", ">", "1", ":", "\n", "            ", "pool_size", "=", "(", "pool_size", ",", ")", "*", "ndims", "\n", "", "", "if", "ndims", "==", "1", "and", "isinstance", "(", "pool_size", ",", "tuple", ")", ":", "\n", "        ", "pool_size", "=", "pool_size", "[", "0", "]", "# 1D upsampling takes int not tuple", "\n", "\n", "# prepare layers", "\n", "", "if", "convL", "is", "None", ":", "\n", "        ", "convL", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "\n", "# If conditional:", "\n", "", "if", "conditional", "is", "True", ":", "\n", "        ", "conv_kwargs", "=", "{", "\n", "'use_bias'", ":", "False", ",", "\n", "'kernel_initializer'", ":", "init", ",", "\n", "}", "\n", "", "else", ":", "\n", "       ", "conv_kwargs", "=", "{", "\n", "'use_bias'", ":", "True", ",", "\n", "'kernel_initializer'", ":", "init", ",", "\n", "}", "\n", "\n", "", "up_shape", "=", "tuple", "(", "2", "*", "np", ".", "array", "(", "K", ".", "int_shape", "(", "condn_emb", ")", "[", "1", ":", "-", "1", "]", ")", ")", "# TODO: ugly", "\n", "\n", "# up arm:", "\n", "# nb_levels - 1 layers of Deconvolution3D", "\n", "#    (approx via up + conv + ReLu) + merge + conv + ReLu + conv + ReLu", "\n", "lfidx", "=", "0", "\n", "\n", "last_tensor", "=", "1.0", "*", "condn_emb", "\n", "\n", "for", "level", "in", "range", "(", "nb_levels", "-", "1", ")", ":", "\n", "        ", "nb_lvl_feats", "=", "np", ".", "round", "(", "\n", "nb_features", "*", "feat_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", ",", "\n", ")", ".", "astype", "(", "int", ")", "\n", "conv_kwargs", "[", "'dilation_rate'", "]", "=", "dilation_rate_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", "\n", "\n", "# upsample matching the max pooling layers size", "\n", "name", "=", "'%s_up_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ")", "\n", "last_tensor", "=", "TrilinearResizeLayer", "(", "\n", "up_shape", ",", "\n", "name", "=", "name", ",", "\n", ")", "(", "last_tensor", ")", "\n", "# last_tensor = upsample(size=pool_size, name=name)(condn_emb)", "\n", "\n", "up_shape", "=", "tuple", "(", "2", "*", "np", ".", "array", "(", "up_shape", ")", ")", "# for next level", "\n", "\n", "# convolution layers", "\n", "for", "conv", "in", "range", "(", "nb_conv_per_level", ")", ":", "\n", "            ", "if", "layer_nb_feats", "is", "not", "None", ":", "\n", "                ", "nb_lvl_feats", "=", "layer_nb_feats", "[", "lfidx", "]", "\n", "lfidx", "+=", "1", "\n", "\n", "", "name", "=", "'%s_conv_uparm_%d_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ",", "conv", ")", "\n", "if", "conv", "<", "(", "nb_conv_per_level", "-", "1", ")", "or", "(", "not", "use_residuals", ")", ":", "\n", "                ", "last_tensor", "=", "tf", ".", "pad", "(", "\n", "last_tensor", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\n", "\"REFLECT\"", ",", "\n", ")", "\n", "if", "sn", ":", "\n", "                    ", "last_tensor", "=", "SpectralNormalization", "(", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ",", "\n", ")", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "                    ", "last_tensor", "=", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "conditional", ":", "\n", "                    ", "last_tensor", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "last_tensor", ",", "condn_vec", "]", ")", "\n", "", "last_tensor", "=", "KL", ".", "LeakyReLU", "(", "0.2", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "                ", "last_tensor", "=", "tf", ".", "pad", "(", "\n", "last_tensor", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\n", "\"REFLECT\"", ",", "\n", ")", "\n", "if", "sn", ":", "\n", "                    ", "last_tensor", "=", "SpectralNormalization", "(", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "padding", "=", "padding", ",", "name", "=", "name", ",", "\n", ")", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "                    ", "last_tensor", "=", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "padding", "=", "padding", ",", "name", "=", "name", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "conditional", ":", "\n", "                    ", "last_tensor", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "last_tensor", ",", "condn_vec", "]", ")", "\n", "\n", "", "", "", "", "if", "sn", ":", "\n", "        ", "pred_tensor", "=", "SpectralNormalization", "(", "convL", "(", "\n", "nb_labels", ",", "1", ",", "activation", "=", "None", ",", "\n", ")", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "        ", "pred_tensor", "=", "convL", "(", "nb_labels", ",", "1", ",", "activation", "=", "None", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "conditional", ":", "\n", "        ", "pred_tensor", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "pred_tensor", ",", "condn_vec", "]", ")", "\n", "\n", "", "return", "pred_tensor", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.film.FiLM.__init__": [[31, 49], ["tensorflow.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "init", "=", "'default'", ",", "wt_decay", "=", "1e-5", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            init: str\n                How to initialize dense layers.\n            wt_decay: float\n                L2 penalty on FiLM projection.\n        \"\"\"", "\n", "if", "init", "==", "'orthogonal'", ":", "\n", "            ", "self", ".", "init", "=", "'orthogonal'", "\n", "", "elif", "init", "==", "'default'", "or", "init", "is", "None", ":", "\n", "            ", "self", ".", "init", "=", "None", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "\n", "\n", "", "self", ".", "wt_decay", "=", "wt_decay", "\n", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.film.FiLM.build": [[50, 61], ["tensorflow.Dense", "tensorflow.Dense", "int", "tensorflow.keras.regularizers.l2", "tensorflow.keras.regularizers.l2", "tensorflow.keras.regularizers.l2", "tensorflow.keras.regularizers.l2"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.l2", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.l2", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.l2", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.l2"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "self", ".", "channels", "=", "input_shape", "[", "0", "]", "[", "-", "1", "]", "# input_shape: [x, z].", "\n", "\n", "self", ".", "fc", "=", "KL", ".", "Dense", "(", "\n", "int", "(", "2", "*", "self", ".", "channels", ")", ",", "\n", "kernel_initializer", "=", "self", ".", "init", ",", "\n", "kernel_regularizer", "=", "tf", ".", "keras", ".", "regularizers", ".", "l2", "(", "\n", "l", "=", "self", ".", "wt_decay", ",", "\n", ")", ",", "\n", "bias_regularizer", "=", "tf", ".", "keras", ".", "regularizers", ".", "l2", "(", "\n", "l", "=", "self", ".", "wt_decay", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.film.FiLM.call": [[64, 70], ["film.FiLM.hypernetwork", "film._film_reshape"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.film.FiLM.hypernetwork", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.film._film_reshape"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "x", ",", "z", "=", "inputs", "\n", "gamma", ",", "beta", "=", "self", ".", "hypernetwork", "(", "z", ")", "\n", "gamma", ",", "beta", "=", "_film_reshape", "(", "gamma", ",", "beta", ",", "x", ")", "\n", "\n", "return", "(", "1.", "+", "gamma", ")", "*", "x", "+", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.film.FiLM.hypernetwork": [[71, 75], ["film.FiLM.fc"], "methods", ["None"], ["", "def", "hypernetwork", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "x", "=", "self", ".", "fc", "(", "inputs", ")", "\n", "\n", "return", "x", "[", "...", ",", ":", "self", ".", "channels", "]", ",", "x", "[", "...", ",", "self", ".", "channels", ":", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.film._film_reshape": [[16, 27], ["tensorflow.tile", "tensorflow.tile", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["def", "_film_reshape", "(", "gamma", ",", "beta", ",", "x", ")", ":", "\n", "    ", "\"\"\"Reshape gamma and beta for FiLM.\"\"\"", "\n", "\n", "gamma", "=", "tf", ".", "tile", "(", "\n", "tf", ".", "reshape", "(", "gamma", ",", "(", "tf", ".", "shape", "(", "gamma", ")", "[", "0", "]", ",", "1", ",", "1", ",", "1", ",", "tf", ".", "shape", "(", "gamma", ")", "[", "-", "1", "]", ")", ")", ",", "\n", "(", "1", ",", "tf", ".", "shape", "(", "x", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "x", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "x", ")", "[", "3", "]", ",", "1", ")", ")", "\n", "beta", "=", "tf", ".", "tile", "(", "\n", "tf", ".", "reshape", "(", "beta", ",", "(", "tf", ".", "shape", "(", "beta", ")", "[", "0", "]", ",", "1", ",", "1", ",", "1", ",", "tf", ".", "shape", "(", "beta", ")", "[", "-", "1", "]", ")", ")", ",", "\n", "(", "1", ",", "tf", ".", "shape", "(", "x", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "x", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "x", ")", "[", "3", "]", ",", "1", ")", ")", "\n", "\n", "return", "gamma", ",", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.data_generators.D_data_generator": [[8, 97], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "data_generators.oversample", "numpy.random.choice", "numpy.random.choice", "range", "len", "len", "numpy.load", "numpy.load", "numpy.hstack", "numpy.hstack", "tensorflow.keras.utils.to_categorical", "tensorflow.keras.utils.to_categorical"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.data_generators.oversample", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], ["def", "D_data_generator", "(", "\n", "vol_shape", ",", "\n", "img_list", ",", "\n", "oversample_age", "=", "True", ",", "\n", "batch_size", "=", "32", ",", "\n", "dataset", "=", "'dHCP'", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Data generator for discriminator in conditional setting.\n\n    Args:\n        vol_shape: tuple\n            Shape of images (without feature axis).\n        img_list: list of strings\n            List of image file paths (assumed as npz files).\n        oversample_age : bool\n            Oversample images based on rarity w.r.t. age.\n        batch_size: int\n            Batch size.\n        dataset: str\n            Dataset choice. One of {'dHCP', 'pHD'}.\n    \"\"\"", "\n", "\n", "# Pick attribute of interest for dataset:", "\n", "if", "dataset", "==", "'dHCP'", ":", "\n", "        ", "age_max", "=", "45.142857142857", "# used for scaling age values", "\n", "n_condns", "=", "1", "# number of conditions", "\n", "", "elif", "dataset", "==", "'pHD'", ":", "\n", "        ", "attribute", "=", "'disease'", "# name of attribute in npz archive", "\n", "age_max", "=", "87.72895277", "# used for scaling age values", "\n", "n_condns", "=", "3", "# number of conditions", "\n", "\n", "# Oversample age:", "\n", "", "if", "oversample_age", "is", "True", ":", "\n", "        ", "ifrequencies", "=", "oversample", "(", "img_list", ")", "\n", "", "else", ":", "\n", "        ", "ifrequencies", "=", "None", "\n", "\n", "# prepare a zero array the size of the deformation:", "\n", "", "registration_images", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "vol_shape", "+", "(", "1", ",", ")", ")", "\n", "adversarial_images", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "vol_shape", "+", "(", "1", ",", ")", ")", "\n", "\n", "registration_images_condns", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "(", "n_condns", ",", ")", ")", "\n", "adversarial_images_condns", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "(", "n_condns", ",", ")", ")", "\n", "\n", "while", "True", ":", "\n", "# Sample indices for training:", "\n", "        ", "registration_idx", "=", "np", ".", "random", ".", "choice", "(", "\n", "len", "(", "img_list", ")", ",", "batch_size", ",", "p", "=", "ifrequencies", ",", "\n", ")", "\n", "adversarial_idx", "=", "np", ".", "random", ".", "choice", "(", "\n", "len", "(", "img_list", ")", ",", "batch_size", ",", "p", "=", "ifrequencies", ",", "\n", ")", "\n", "\n", "# TODO: looping is quite slow. however, typically 3D batches are very", "\n", "# small and it doesn't add much overhead.", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "# Registration targets:", "\n", "            ", "reg_img_path", "=", "img_list", "[", "registration_idx", "[", "i", "]", "]", "\n", "reg_imgs_npz", "=", "np", ".", "load", "(", "reg_img_path", ")", "\n", "\n", "registration_images", "[", "i", "]", "=", "reg_imgs_npz", "[", "'vol'", "]", "[", "...", ",", "np", ".", "newaxis", "]", "\n", "registration_images_condns", "[", "i", "]", "=", "reg_imgs_npz", "[", "'age'", "]", "/", "age_max", "\n", "\n", "if", "n_condns", ">", "1", ":", "\n", "                ", "registration_images_condns", "[", "i", "]", "=", "np", ".", "hstack", "(", "(", "\n", "reg_imgs_npz", "[", "'age'", "]", "/", "age_max", ",", "# scale age [0, 1]", "\n", "to_categorical", "(", "\n", "reg_imgs_npz", "[", "attribute", "]", ",", "n_condns", "-", "1", ",", "\n", ")", ",", "\n", ")", ")", "\n", "\n", "# Adversarial targets for comparison:", "\n", "", "adv_img_path", "=", "img_list", "[", "adversarial_idx", "[", "i", "]", "]", "\n", "advers_imgs_npz", "=", "np", ".", "load", "(", "adv_img_path", ")", "\n", "\n", "adversarial_images", "[", "i", "]", "=", "advers_imgs_npz", "[", "'vol'", "]", "[", "...", ",", "np", ".", "newaxis", "]", "\n", "adversarial_images_condns", "[", "i", "]", "=", "advers_imgs_npz", "[", "'age'", "]", "/", "age_max", "\n", "\n", "if", "n_condns", ">", "1", ":", "\n", "                ", "adversarial_images_condns", "[", "i", "]", "=", "np", ".", "hstack", "(", "(", "\n", "advers_imgs_npz", "[", "'age'", "]", "/", "age_max", ",", "\n", "to_categorical", "(", "\n", "advers_imgs_npz", "[", "attribute", "]", ",", "n_condns", "-", "1", ",", "\n", ")", ",", "\n", ")", ")", "\n", "\n", "", "", "yield", "(", "\n", "registration_images", ",", "adversarial_images", ",", "\n", "registration_images_condns", ",", "adversarial_images_condns", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.data_generators.G_data_generator": [[100, 165], ["numpy.zeros", "numpy.zeros", "data_generators.oversample", "numpy.random.choice", "range", "len", "numpy.load", "numpy.hstack", "tensorflow.keras.utils.to_categorical"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.data_generators.oversample", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], ["", "", "def", "G_data_generator", "(", "\n", "vol_shape", ",", "\n", "img_list", ",", "\n", "oversample_age", "=", "True", ",", "\n", "batch_size", "=", "32", ",", "\n", "dataset", "=", "'dHCP'", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Data generator for discriminator in conditional setting.\n\n    Args:\n        vol_shape: tuple\n            Shape of images (without feature axis).\n        img_list: list of strings\n            List of image file paths (assumed as npz files).\n        oversample_age : bool\n            Oversample images based on rarity w.r.t. age.\n        batch_size: int\n            Batch size.\n        dataset: str\n            Dataset choice. One of {'dHCP', 'pHD'}.\n    \"\"\"", "\n", "\n", "# Pick attribute of interest for dataset:", "\n", "if", "dataset", "==", "'dHCP'", ":", "\n", "        ", "age_max", "=", "45.142857142857", "# used for scaling age values", "\n", "n_condns", "=", "1", "# number of conditions", "\n", "", "elif", "dataset", "==", "'pHD'", ":", "\n", "        ", "attribute", "=", "'disease'", "# name of attribute in npz archive", "\n", "age_max", "=", "87.72895277", "# used for scaling age values", "\n", "n_condns", "=", "3", "# number of conditions", "\n", "\n", "# Oversample age:", "\n", "", "if", "oversample_age", "is", "True", ":", "\n", "        ", "ifrequencies", "=", "oversample", "(", "img_list", ")", "\n", "", "else", ":", "\n", "        ", "ifrequencies", "=", "None", "\n", "\n", "# prepare a zero array the size of the deformation:", "\n", "", "registration_images", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "vol_shape", "+", "(", "1", ",", ")", ")", "\n", "registration_images_condns", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "(", "n_condns", ",", ")", ")", "\n", "\n", "while", "True", ":", "\n", "        ", "registration_idx", "=", "np", ".", "random", ".", "choice", "(", "\n", "len", "(", "img_list", ")", ",", "batch_size", ",", "p", "=", "ifrequencies", ",", "\n", ")", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "# Registration targets:", "\n", "            ", "reg_img_path", "=", "img_list", "[", "registration_idx", "[", "i", "]", "]", "\n", "reg_imgs_npz", "=", "np", ".", "load", "(", "\n", "reg_img_path", ",", "\n", ")", "\n", "\n", "registration_images", "[", "i", "]", "=", "reg_imgs_npz", "[", "'vol'", "]", "[", "...", ",", "np", ".", "newaxis", "]", "\n", "registration_images_condns", "[", "i", "]", "=", "reg_imgs_npz", "[", "'age'", "]", "/", "age_max", "\n", "\n", "if", "n_condns", ">", "1", ":", "\n", "                ", "registration_images_condns", "[", "i", "]", "=", "np", ".", "hstack", "(", "(", "\n", "reg_imgs_npz", "[", "'age'", "]", "/", "age_max", ",", "\n", "to_categorical", "(", "\n", "reg_imgs_npz", "[", "attribute", "]", ",", "n_condns", "-", "1", ",", "\n", ")", ",", "\n", ")", ")", "\n", "\n", "", "", "yield", "registration_images", ",", "registration_images_condns", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.data_generators.oversample": [[170, 201], ["range", "numpy.array().round", "numpy.unique", "np.array().round.copy", "range", "len", "np.array().round.append", "counts.sum", "iprob.sum", "len", "numpy.where", "frequencies.copy.sum", "numpy.array", "numpy.load"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], ["", "", "def", "oversample", "(", "img_paths", ")", ":", "\n", "    ", "\"\"\"\n    Takes list of file paths of npz files containing images with ages and\n    outputs (rough) sampling probabilities such that the network sees\n    timepoints equally frequently.\n\n    Args:\n        img_paths : str\n            list of npz files containing images and attributes of interest.\n    \"\"\"", "\n", "\n", "frequencies", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "img_paths", ")", ")", ":", "\n", "        ", "frequencies", ".", "append", "(", "np", ".", "load", "(", "img_paths", "[", "i", "]", ")", "[", "'age'", "]", ")", "\n", "\n", "", "frequencies", "=", "np", ".", "array", "(", "frequencies", ")", ".", "round", "(", ")", "# quantize (essentially bin)", "\n", "ages", ",", "counts", "=", "np", ".", "unique", "(", "frequencies", ",", "return_counts", "=", "True", ")", "# get age hist.", "\n", "prob", "=", "counts", "/", "counts", ".", "sum", "(", ")", "# get age probabilities", "\n", "\n", "# Get inverted probabilities:", "\n", "iprob", "=", "1", "-", "prob", "\n", "iprob", "=", "iprob", "/", "iprob", ".", "sum", "(", ")", "# renormalize", "\n", "\n", "ifrequencies", "=", "frequencies", ".", "copy", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "ages", ")", ")", ":", "\n", "        ", "idx", "=", "np", ".", "where", "(", "frequencies", "==", "ages", "[", "i", "]", ")", "\n", "ifrequencies", "[", "idx", "]", "=", "iprob", "[", "i", "]", "\n", "\n", "", "ifrequencies", "=", "ifrequencies", "/", "ifrequencies", ".", "sum", "(", ")", "\n", "\n", "return", "ifrequencies", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.trilinear.TrilinearResizeLayer.__init__": [[20, 28], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "size_3d", ",", "name", "=", "'trilinear_resize'", ")", ":", "\n", "        ", "\"\"\"\n\n        :param size_3d: 3-element integers set the output 3D spatial shape\n        :param name: layer name string\n        \"\"\"", "\n", "self", ".", "size_3d", "=", "size_3d", "\n", "super", "(", "TrilinearResizeLayer", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.trilinear.TrilinearResizeLayer.call": [[29, 62], ["input_tensor.get_shape().as_list", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.image.resize", "tensorflow.image.resize", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.image.resize", "tensorflow.image.resize", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.transpose", "input_tensor.get_shape"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.resize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.resize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.resize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.resize"], ["", "def", "call", "(", "self", ",", "input_tensor", ")", ":", "\n", "        ", "\"\"\"\n        Computes trilinear interpolation using TF ``resize_images`` function.\n\n        :param input_tensor: 3D volume, shape\n            ``batch, X, Y, Z, Channels``\n        :return: interpolated volume\n        \"\"\"", "\n", "\n", "b_size", ",", "x_size", ",", "y_size", ",", "z_size", ",", "c_size", "=", "input_tensor", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "x_size_new", ",", "y_size_new", ",", "z_size_new", "=", "self", ".", "size_3d", "\n", "\n", "# resize y-z", "\n", "squeeze_b_x", "=", "tf", ".", "reshape", "(", "\n", "input_tensor", ",", "[", "-", "1", ",", "y_size", ",", "z_size", ",", "c_size", "]", ")", "\n", "resize_b_x", "=", "tf", ".", "image", ".", "resize", "(", "\n", "squeeze_b_x", ",", "[", "y_size_new", ",", "z_size_new", "]", ")", "\n", "resume_b_x", "=", "tf", ".", "reshape", "(", "\n", "resize_b_x", ",", "[", "-", "1", ",", "x_size", ",", "y_size_new", ",", "z_size_new", ",", "c_size", "]", ")", "\n", "\n", "# resize x-y", "\n", "#   first reorient", "\n", "reoriented", "=", "tf", ".", "transpose", "(", "resume_b_x", ",", "[", "0", ",", "3", ",", "2", ",", "1", ",", "4", "]", ")", "\n", "#   squeeze and 2d resize", "\n", "squeeze_b_z", "=", "tf", ".", "reshape", "(", "\n", "reoriented", ",", "[", "-", "1", ",", "y_size_new", ",", "x_size", ",", "c_size", "]", ")", "\n", "resize_b_z", "=", "tf", ".", "image", ".", "resize", "(", "\n", "squeeze_b_z", ",", "[", "y_size_new", ",", "x_size_new", "]", ")", "\n", "resume_b_z", "=", "tf", ".", "reshape", "(", "\n", "resize_b_z", ",", "[", "-", "1", ",", "z_size_new", ",", "y_size_new", ",", "x_size_new", ",", "c_size", "]", ")", "\n", "\n", "return", "tf", ".", "transpose", "(", "resume_b_z", ",", "[", "0", ",", "3", ",", "2", ",", "1", ",", "4", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.disc_augment": [[12, 46], ["discriminator_augmentations.rand_translation", "tensorflow.random.uniform", "tensorflow.reverse", "discriminator_augmentations.rand_brightness", "discriminator_augmentations.rand_saturation", "discriminator_augmentations.rand_contrast", "tensorflow.reverse", "tensorflow.reverse", "tensorflow.reverse", "tensorflow.reverse"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.rand_translation", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.rand_brightness", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.rand_saturation", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.rand_contrast"], ["@", "tf", ".", "function", "\n", "def", "disc_augment", "(", "image_batch", ",", "flip_choice", ",", "intensity_mods", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Return augmented training arrays. Args:\n        image_batch: tf tensor of batch to augment\n        flip_choice: tf tensor containing (int) choice of flip augmentation.\n        intensity_mods: bool indicating whether to use intensity augmentation.\n    \"\"\"", "\n", "\n", "# 50% of the time do random left-right reflections:", "\n", "if", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", ")", ")", ">", "0.5", ":", "\n", "        ", "image_batch", "=", "tf", ".", "reverse", "(", "image_batch", ",", "axis", "=", "[", "3", "]", ")", "\n", "\n", "# Other flips", "\n", "# TODO: figure out a cleaner way of doing this", "\n", "", "if", "flip_choice", "==", "0", ":", "\n", "        ", "pass", "\n", "", "elif", "flip_choice", "==", "1", ":", "\n", "        ", "image_batch", "=", "tf", ".", "reverse", "(", "image_batch", ",", "axis", "=", "[", "1", "]", ")", "\n", "", "elif", "flip_choice", "==", "2", ":", "\n", "        ", "image_batch", "=", "tf", ".", "reverse", "(", "image_batch", ",", "axis", "=", "[", "2", "]", ")", "\n", "", "elif", "flip_choice", "==", "3", ":", "\n", "        ", "image_batch", "=", "tf", ".", "reverse", "(", "tf", ".", "reverse", "(", "image_batch", ",", "axis", "=", "[", "2", "]", ")", ",", "axis", "=", "[", "1", "]", ")", "\n", "\n", "# Random Intensity:", "\n", "", "if", "intensity_mods", ":", "\n", "        ", "image_batch", "=", "rand_brightness", "(", "image_batch", ")", "\n", "image_batch", "=", "rand_saturation", "(", "image_batch", ")", "\n", "image_batch", "=", "rand_contrast", "(", "image_batch", ")", "\n", "\n", "# Random Translation:", "\n", "", "image_batch", "=", "rand_translation", "(", "image_batch", ")", "\n", "\n", "return", "image_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.rand_brightness": [[48, 53], ["tensorflow.random.uniform", "tensorflow.shape"], "function", ["None"], ["", "@", "tf", ".", "function", "\n", "def", "rand_brightness", "(", "x", ")", ":", "\n", "    ", "magnitude", "=", "tf", ".", "random", ".", "uniform", "(", "[", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", "-", "0.5", "\n", "x", "=", "x", "+", "magnitude", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.rand_saturation": [[55, 61], ["tensorflow.reduce_mean", "tensorflow.random.uniform", "tensorflow.shape"], "function", ["None"], ["", "@", "tf", ".", "function", "\n", "def", "rand_saturation", "(", "x", ")", ":", "\n", "    ", "magnitude", "=", "tf", ".", "random", ".", "uniform", "(", "[", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", "*", "2", "\n", "x_mean", "=", "tf", ".", "reduce_mean", "(", "x", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "\n", "x", "=", "(", "x", "-", "x_mean", ")", "*", "magnitude", "+", "x_mean", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.rand_contrast": [[63, 69], ["tensorflow.reduce_mean", "tensorflow.random.uniform", "tensorflow.shape"], "function", ["None"], ["", "@", "tf", ".", "function", "\n", "def", "rand_contrast", "(", "x", ")", ":", "\n", "    ", "magnitude", "=", "tf", ".", "random", ".", "uniform", "(", "[", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", "+", "0.5", "\n", "x_mean", "=", "tf", ".", "reduce_mean", "(", "x", ",", "axis", "=", "[", "1", ",", "2", ",", "3", ",", "4", "]", ",", "keepdims", "=", "True", ")", "\n", "x", "=", "(", "x", "-", "x_mean", ")", "*", "magnitude", "+", "x_mean", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.discriminator_augmentations.rand_translation": [[71, 135], ["tensorflow.cast", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.clip_by_value", "tensorflow.clip_by_value", "tensorflow.clip_by_value", "tensorflow.gather_nd", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.shape", "tensorflow.shape", "tensorflow.pad", "tensorflow.expand_dims", "tensorflow.gather_nd", "tensorflow.gather_nd", "tensorflow.pad", "tensorflow.expand_dims", "tensorflow.pad", "tensorflow.expand_dims", "tensorflow.cast", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.range", "tensorflow.range", "tensorflow.range"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "@", "tf", ".", "function", "\n", "def", "rand_translation", "(", "x", ",", "ratio", "=", "0.05", ")", ":", "\n", "    ", "batch_size", "=", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", "\n", "image_size", "=", "tf", ".", "shape", "(", "x", ")", "[", "1", ":", "4", "]", "\n", "shift", "=", "tf", ".", "cast", "(", "tf", ".", "cast", "(", "image_size", ",", "tf", ".", "float32", ")", "*", "ratio", "+", "0.5", ",", "tf", ".", "int32", ")", "\n", "\n", "translation_x", "=", "tf", ".", "random", ".", "uniform", "(", "\n", "[", "batch_size", ",", "1", "]", ",", "-", "shift", "[", "0", "]", ",", "shift", "[", "0", "]", "+", "1", ",", "dtype", "=", "tf", ".", "int32", ",", "\n", ")", "\n", "translation_y", "=", "tf", ".", "random", ".", "uniform", "(", "\n", "[", "batch_size", ",", "1", "]", ",", "-", "shift", "[", "1", "]", ",", "shift", "[", "1", "]", "+", "1", ",", "dtype", "=", "tf", ".", "int32", ",", "\n", ")", "\n", "translation_z", "=", "tf", ".", "random", ".", "uniform", "(", "\n", "[", "batch_size", ",", "1", "]", ",", "-", "shift", "[", "2", "]", ",", "shift", "[", "2", "]", "+", "1", ",", "dtype", "=", "tf", ".", "int32", ",", "\n", ")", "\n", "\n", "grid_x", "=", "tf", ".", "clip_by_value", "(", "\n", "(", "tf", ".", "expand_dims", "(", "tf", ".", "range", "(", "image_size", "[", "0", "]", ",", "dtype", "=", "tf", ".", "int32", ")", ",", "0", ")", "+", "\n", "translation_x", "+", "1", ")", ",", "\n", "0", ",", "\n", "image_size", "[", "0", "]", "+", "1", ",", "\n", ")", "\n", "grid_y", "=", "tf", ".", "clip_by_value", "(", "\n", "(", "tf", ".", "expand_dims", "(", "tf", ".", "range", "(", "image_size", "[", "1", "]", ",", "dtype", "=", "tf", ".", "int32", ")", ",", "0", ")", "+", "\n", "translation_y", "+", "1", ")", ",", "\n", "0", ",", "\n", "image_size", "[", "1", "]", "+", "1", ",", "\n", ")", "\n", "grid_z", "=", "tf", ".", "clip_by_value", "(", "\n", "(", "tf", ".", "expand_dims", "(", "tf", ".", "range", "(", "image_size", "[", "2", "]", ",", "dtype", "=", "tf", ".", "int32", ")", ",", "0", ")", "+", "\n", "translation_z", "+", "1", ")", ",", "\n", "0", ",", "\n", "image_size", "[", "2", "]", "+", "1", ",", "\n", ")", "\n", "\n", "x", "=", "tf", ".", "gather_nd", "(", "\n", "tf", ".", "pad", "(", "x", ",", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", ",", "\n", "tf", ".", "expand_dims", "(", "grid_x", ",", "-", "1", ")", ",", "\n", "batch_dims", "=", "1", ",", "\n", ")", "\n", "x", "=", "tf", ".", "transpose", "(", "\n", "tf", ".", "gather_nd", "(", "\n", "tf", ".", "pad", "(", "\n", "tf", ".", "transpose", "(", "x", ",", "[", "0", ",", "2", ",", "1", ",", "3", ",", "4", "]", ")", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\n", ")", ",", "\n", "tf", ".", "expand_dims", "(", "grid_y", ",", "-", "1", ")", ",", "\n", "batch_dims", "=", "1", ",", "\n", ")", ",", "\n", "[", "0", ",", "2", ",", "1", ",", "3", ",", "4", "]", ",", "\n", ")", "\n", "x", "=", "tf", ".", "transpose", "(", "\n", "tf", ".", "gather_nd", "(", "\n", "tf", ".", "pad", "(", "\n", "tf", ".", "transpose", "(", "x", ",", "[", "0", ",", "3", ",", "2", ",", "1", ",", "4", "]", ")", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\n", ")", ",", "\n", "tf", ".", "expand_dims", "(", "grid_z", ",", "-", "1", ")", ",", "\n", "batch_dims", "=", "1", ",", "\n", ")", ",", "\n", "[", "0", ",", "3", ",", "2", ",", "1", ",", "4", "]", ",", "\n", ")", "\n", "\n", "return", "x", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.losses.total_variation3D": [[19, 36], ["tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.math.abs", "tensorflow.math.abs", "tensorflow.math.abs"], "function", ["None"], ["@", "tf", ".", "function", "\n", "def", "total_variation3D", "(", "ypred", ")", ":", "\n", "    ", "\"\"\"\n    Not used in paper.\n    Calculates anisotropic total variation for a 3D image ypred.\n    \"\"\"", "\n", "\n", "pixel_dif1", "=", "ypred", "[", ":", ",", "1", ":", ",", ":", ",", ":", ",", ":", "]", "-", "ypred", "[", ":", ",", ":", "-", "1", ",", ":", ",", ":", ",", ":", "]", "\n", "pixel_dif2", "=", "ypred", "[", ":", ",", ":", ",", "1", ":", ",", ":", ",", ":", "]", "-", "ypred", "[", ":", ",", ":", ",", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "pixel_dif3", "=", "ypred", "[", ":", ",", ":", ",", ":", ",", "1", ":", ",", ":", "]", "-", "ypred", "[", ":", ",", ":", ",", ":", ",", ":", "-", "1", ",", ":", "]", "\n", "\n", "tot_var", "=", "(", "\n", "tf", ".", "reduce_mean", "(", "tf", ".", "math", ".", "abs", "(", "pixel_dif1", ")", ")", "+", "\n", "tf", ".", "reduce_mean", "(", "tf", ".", "math", ".", "abs", "(", "pixel_dif2", ")", ")", "+", "\n", "tf", ".", "reduce_mean", "(", "tf", ".", "math", ".", "abs", "(", "pixel_dif3", ")", ")", "\n", ")", "\n", "return", "tf", ".", "reduce_mean", "(", "tot_var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.losses.generator_loss": [[38, 129], ["tensorflow.reduce_mean", "loss_object", "loss_object", "loss_object", "tensorflow.reduce_mean", "voxelmorph.tf.losses.Grad().loss", "tensorflow.zeros_like", "tensorflow.zeros_like", "tensorflow.ones_like", "losses.total_variation3D", "loss_object_NCC.loss", "tensorflow.reduce_mean", "tensorflow.zeros_like", "loss_object_NonSquareNCC.loss", "voxelmorph.tf.losses.Grad"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.loss", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.losses.total_variation3D", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.loss", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.loss"], ["", "@", "tf", ".", "function", "\n", "def", "generator_loss", "(", "\n", "disc_opinion_fake_local", ",", "\n", "disp_ms", ",", "\n", "disp", ",", "\n", "moved_atlases", ",", "\n", "fixed_images", ",", "\n", "epoch", ",", "\n", "sharp_atlases", ",", "\n", "loss_wts", ",", "\n", "start_step", "=", "0", ",", "\n", "reg_loss_type", "=", "'NCC'", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Loss function for Generator:\n    Args:\n        disc_opinion_fake_local: tf float\n            Local feedback from discriminator.\n        disp_ms: tf float\n            Moving average of displacement fields.\n        disp: tf float\n            Displacement fields.\n        moved_atlases: tf float\n            Moved template images.\n        fixed_images: tf float\n            Target images.\n        epoch: int\n            Training step.\n        sharp_atlases: tf float\n            Generated Template image.\n        loss_wts: list\n            List of regularization weights for gan loss, deformation, and TV.\n        start_step: int\n            Training step to start training adversarial component.\n    \"\"\"", "\n", "\n", "lambda_gan", ",", "lambda_reg", ",", "lambda_tv", "=", "loss_wts", "\n", "\n", "# If training registration only, without GAN loss.", "\n", "# Need to do this, otherwise graph detaches:", "\n", "if", "epoch", ">=", "start_step", ":", "\n", "        ", "gan_loss", "=", "loss_object", "(", "\n", "tf", ".", "ones_like", "(", "disc_opinion_fake_local", ")", ",", "disc_opinion_fake_local", ",", "\n", ")", "\n", "if", "lambda_tv", ">", "0.0", ":", "# never happens as TV loss not used in paper", "\n", "            ", "tv_loss", "=", "total_variation3D", "(", "sharp_atlases", ")", "\n", "", "else", ":", "\n", "            ", "tv_loss", "=", "0.0", "\n", "", "", "else", ":", "\n", "        ", "gan_loss", "=", "0.0", "\n", "tv_loss", "=", "0.0", "\n", "\n", "# Similarity terms:", "\n", "", "if", "reg_loss_type", "==", "'NCC'", ":", "\n", "        ", "similarity_loss", "=", "tf", ".", "reduce_mean", "(", "\n", "loss_object_NCC", ".", "loss", "(", "moved_atlases", ",", "fixed_images", ")", ",", "\n", ")", "\n", "", "elif", "reg_loss_type", "==", "'NonSquareNCC'", ":", "# Not used in paper.", "\n", "        ", "similarity_loss", "=", "tf", ".", "reduce_mean", "(", "\n", "loss_object_NonSquareNCC", ".", "loss", "(", "moved_atlases", ",", "fixed_images", ")", ",", "\n", ")", "\n", "\n", "# smoothness terms:", "\n", "", "smoothness_loss", "=", "tf", ".", "reduce_mean", "(", "\n", "Grad", "(", "'l2'", ")", ".", "loss", "(", "tf", ".", "zeros_like", "(", "disp", ")", ",", "disp", ")", ",", "\n", ")", "\n", "\n", "# magnitude terms:", "\n", "magnitude_loss", "=", "loss_object", "(", "tf", ".", "zeros_like", "(", "disp", ")", ",", "disp", ")", "\n", "moving_magnitude_loss", "=", "loss_object", "(", "tf", ".", "zeros_like", "(", "disp_ms", ")", ",", "disp_ms", ")", "\n", "\n", "# Choose between registration only or reg+gan training:", "\n", "if", "epoch", "<", "start_step", ":", "\n", "        ", "total_gen_loss", "=", "(", "\n", "(", "lambda_reg", "*", "smoothness_loss", ")", "+", "\n", "(", "0.01", "*", "lambda_reg", "*", "magnitude_loss", ")", "+", "\n", "(", "lambda_reg", "*", "moving_magnitude_loss", ")", "+", "\n", "1", "*", "similarity_loss", "\n", ")", "\n", "", "else", ":", "\n", "        ", "total_gen_loss", "=", "(", "\n", "lambda_gan", "*", "gan_loss", "+", "\n", "(", "lambda_reg", "*", "smoothness_loss", ")", "+", "\n", "(", "0.01", "*", "lambda_reg", "*", "magnitude_loss", ")", "+", "\n", "(", "lambda_reg", "*", "moving_magnitude_loss", ")", "+", "\n", "1", "*", "similarity_loss", "+", "\n", "lambda_tv", "*", "tv_loss", "\n", ")", "\n", "\n", "", "return", "(", "\n", "total_gen_loss", ",", "gan_loss", ",", "smoothness_loss", ",", "magnitude_loss", ",", "\n", "similarity_loss", ",", "moving_magnitude_loss", ",", "tv_loss", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.losses.discriminator_loss": [[135, 161], ["loss_object", "loss_object", "tensorflow.zeros_like", "tensorflow.ones_like"], "function", ["None"], ["", "@", "tf", ".", "function", "\n", "def", "discriminator_loss", "(", "\n", "disc_opinion_real_local", ",", "\n", "disc_opinion_fake_local", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Loss function for Generator:\n    Args:\n        disc_opinion_fake_local: tf float\n            Local feedback from discriminator on moved templates.\n        disc_opinion_real_local: tf float\n            Local feedback from discriminator on real fixed images.\n    \"\"\"", "\n", "\n", "gan_fake_loss", "=", "loss_object", "(", "\n", "tf", ".", "zeros_like", "(", "disc_opinion_fake_local", ")", ",", "\n", "disc_opinion_fake_local", ",", "\n", ")", "\n", "\n", "gan_real_loss", "=", "loss_object", "(", "\n", "tf", ".", "ones_like", "(", "disc_opinion_real_local", ")", ",", "\n", "disc_opinion_real_local", ",", "\n", ")", "\n", "\n", "total_loss", "=", "0.5", "*", "(", "gan_fake_loss", "+", "gan_real_loss", ")", "\n", "\n", "return", "total_loss", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.src.optimizers.get_optimizers": [[8, 44], ["tensorflow.keras.optimizers.Adam", "tensorflow.Variable", "tensorflow.keras.optimizers.Adam", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable"], "function", ["None"], ["def", "get_optimizers", "(", "\n", "lr_g", ",", "beta1_g", ",", "beta2_g", ",", "lr_d", ",", "beta1_d", ",", "beta2_d", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Return optimizer objects for generator and discriminator.\n    Note the tf.Variable usage, this is to make Adam restore correctly when\n    using tf checkpoints.\n\n    Args:\n        lr_g: Adam step size (generator)\n        beta1_g: Adam beta1 (generator)\n        beta2_g: Adam beta2 (generator)\n        lr_d: Adam step size (discriminator)\n        beta1_d: Adam beta1 (discriminator)\n        beta2_d: Adam beta2 (discriminator)\n    \"\"\"", "\n", "\n", "generator_optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "Adam", "(", "\n", "learning_rate", "=", "tf", ".", "Variable", "(", "lr_g", ")", ",", "\n", "beta_1", "=", "tf", ".", "Variable", "(", "beta1_g", ")", ",", "\n", "beta_2", "=", "tf", ".", "Variable", "(", "beta2_g", ")", ",", "\n", "epsilon", "=", "tf", ".", "Variable", "(", "1e-7", ")", ",", "\n", ")", "\n", "generator_optimizer", ".", "iterations", "\n", "generator_optimizer", ".", "decay", "=", "tf", ".", "Variable", "(", "0.0", ")", "\n", "\n", "discriminator_optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "Adam", "(", "\n", "learning_rate", "=", "tf", ".", "Variable", "(", "lr_d", ")", ",", "\n", "beta_1", "=", "tf", ".", "Variable", "(", "beta1_d", ")", ",", "\n", "beta_2", "=", "tf", ".", "Variable", "(", "beta2_d", ")", ",", "\n", "epsilon", "=", "tf", ".", "Variable", "(", "1e-7", ")", ",", "\n", ")", "\n", "discriminator_optimizer", ".", "iterations", "\n", "discriminator_optimizer", ".", "decay", "=", "tf", ".", "Variable", "(", "0.0", ")", "\n", "\n", "return", "generator_optimizer", ",", "discriminator_optimizer", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.plotting.jitter": [[11, 64], ["range", "numpy.maximum().astype", "numpy.pad", "numpy.array", "isinstance", "matplotlib.colors.ListedColormap", "matplotlib.colors.ListedColormap", "numpy.ceil", "numpy.reshape().transpose().flatten", "len", "matplotlib.get_cmap", "plt.get_cmap.", "numpy.maximum", "numpy.where", "numpy.round", "numpy.reshape().transpose", "numpy.reshape"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten"], ["def", "jitter", "(", "n", "=", "256", ",", "colmap", "=", "\"hsv\"", ",", "nargout", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    jitter colormap of size [n x 3]. The jitter colormap will (likely) have distinct colors, with\n    neighburing colors being quite different\n\n    Parameters:\n        n (optional): the size of the colormap. default:256\n        colmap: the colormap to scramble. Either a string passable to plt.get_cmap,\n            or a n-by-3 or n-by-4 array\n\n    Algorithm: given a (preferably smooth) colormap as a starting point (default \"hsv\"), jitter\n    reorders the colors by skipping roughly a quarter of the colors. So given jitter(9, \"hsv\"),\n    jitter would take color numbers, in order, 1, 3, 5, 7, 9, 2, 4, 6, 8.\n\n    Contact: adalca@csail.mit.edu\n    \"\"\"", "\n", "\n", "# get a 1:n vector", "\n", "idx", "=", "range", "(", "n", ")", "\n", "\n", "# roughly compute the quarter mark. in hsv, a quarter is enough to see a significant col change", "\n", "m", "=", "np", ".", "maximum", "(", "np", ".", "round", "(", "0.25", "*", "n", ")", ",", "1", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# compute a new order, by reshaping this index array as a [m x ?] matrix, then vectorizing in", "\n", "# the opposite direction", "\n", "\n", "# pad with -1 to make it transformable to a square", "\n", "nb_elems", "=", "np", ".", "ceil", "(", "n", "/", "m", ")", "*", "m", "\n", "idx", "=", "np", ".", "pad", "(", "idx", ",", "[", "0", ",", "(", "nb_elems", "-", "n", ")", ".", "astype", "(", "int", ")", "]", ",", "'constant'", ",", "constant_values", "=", "-", "1", ")", "\n", "\n", "# permute elements by resizing to a matrix, transposing, and re-flatteneing", "\n", "idxnew", "=", "np", ".", "array", "(", "np", ".", "reshape", "(", "idx", ",", "[", "m", ",", "(", "nb_elems", "//", "m", ")", ".", "astype", "(", "int", ")", "]", ")", ".", "transpose", "(", ")", ".", "flatten", "(", ")", ")", "\n", "\n", "# throw away the extra elements", "\n", "idxnew", "=", "idxnew", "[", "np", ".", "where", "(", "idxnew", ">=", "0", ")", "]", "\n", "assert", "len", "(", "idxnew", ")", "==", "n", ",", "\"jitter: something went wrong with some inner logic :(\"", "\n", "\n", "# get colormap and scramble it", "\n", "if", "isinstance", "(", "colmap", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "cmap", "=", "plt", ".", "get_cmap", "(", "colmap", ",", "nb_elems", ")", "\n", "scrambled_cmap", "=", "cmap", "(", "idxnew", ")", "\n", "", "else", ":", "\n", "# assumes colmap is a nx3 or nx4", "\n", "        ", "assert", "colmap", ".", "shape", "[", "0", "]", "==", "n", "\n", "assert", "colmap", ".", "shape", "[", "1", "]", "==", "3", "or", "colmap", ".", "shape", "[", "1", "]", "==", "4", "\n", "scrambled_cmap", "=", "colmap", "[", "idxnew", ",", ":", "]", "\n", "\n", "", "new_cmap", "=", "matplotlib", ".", "colors", ".", "ListedColormap", "(", "scrambled_cmap", ")", "\n", "if", "nargout", "==", "1", ":", "\n", "        ", "return", "new_cmap", "\n", "", "else", ":", "\n", "        ", "assert", "nargout", "==", "2", "\n", "return", "(", "new_cmap", ",", "scrambled_cmap", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.timer.Timer.__init__": [[20, 23], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.timer.Timer.__enter__": [[24, 26], ["time.time"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "tstart", "=", "time", ".", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.timer.Timer.__exit__": [[27, 32], ["print", "print", "time.time"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "type", ",", "value", ",", "traceback", ")", ":", "\n", "        ", "if", "self", ".", "verbose", ":", "\n", "            ", "if", "self", ".", "name", ":", "\n", "                ", "print", "(", "'[%s]'", "%", "self", ".", "name", ",", "end", "=", "\"\"", ")", "\n", "", "print", "(", "'Elapsed: %6.4s'", "%", "(", "time", ".", "time", "(", ")", "-", "self", ".", "tstart", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.Struct.__str__": [[92, 94], ["iniparse.Struct.__dict__.__str__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.Struct.__str__"], ["def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__dict__", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.ini_to_struct": [[17, 83], ["configparser.ConfigParser", "configparser.ConfigParser.read", "iniparse.Struct", "configparser.ConfigParser.sections", "len", "iniparse.Struct", "setattr", "iniparse.str_convert_single", "setattr", "iniparse.str_to_list", "len", "all", "iniparse.str_convert_single", "iniparse.str_convert_single"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_convert_single", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_to_list", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_convert_single", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_convert_single"], ["def", "ini_to_struct", "(", "file", ")", ":", "\n", "    ", "\"\"\"\n    very simple ini parser that expands on configparser\n    tries to cast values from string whereever possible\n    parsed data ini can be accessed with\n\n    data = ini_to_struct(file)\n    value = data.section.key\n\n    does not support hierarchical sections\n\n    Parameters:\n        file: string full filename of the ini file.\n\n    Returns:\n        stuct: a Struct that allows ini data to be access in the manner of data.section.key\n    \"\"\"", "\n", "\n", "# read the file via config.", "\n", "conf", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "confout", "=", "conf", ".", "read", "(", "file", ")", "\n", "assert", "len", "(", "confout", ")", ">", "0", ",", "'Cannot read file %s '", "%", "file", "\n", "\n", "# prepare the Struct", "\n", "strct", "=", "Struct", "(", ")", "\n", "\n", "# go through the sections in the ini file", "\n", "for", "sec", "in", "conf", ".", "sections", "(", ")", ":", "\n", "\n", "# each section is its own struct", "\n", "        ", "secstrct", "=", "Struct", "(", ")", "\n", "\n", "# go through the keys", "\n", "for", "key", "in", "conf", "[", "sec", "]", ":", "\n", "            ", "val", "=", "conf", "[", "sec", "]", "[", "key", "]", "\n", "\n", "# try to cast the data", "\n", "ret", ",", "done", "=", "str_convert_single", "(", "val", ")", "\n", "\n", "# if couldn't cast, try a comma/whitespace separated list", "\n", "if", "not", "done", ":", "\n", "                ", "lst", "=", "str_to_list", "(", "val", ")", "\n", "\n", "# if the size of the list is 1, we didn't achieve anything", "\n", "if", "len", "(", "lst", ")", "==", "1", ":", "\n", "                    ", "ret", "=", "lst", "[", "0", "]", "# still not done", "\n", "\n", "# if we actually get a list, only keep it if we can cast its elements to something", "\n", "# otherwise keep the entry as an entire string", "\n", "", "else", ":", "\n", "# make sure all elements in the list convert to something", "\n", "                    ", "done", "=", "all", "(", "[", "str_convert_single", "(", "v", ")", "[", "1", "]", "for", "v", "in", "lst", "]", ")", "\n", "if", "done", ":", "\n", "                        ", "ret", "=", "[", "str_convert_single", "(", "v", ")", "[", "0", "]", "for", "v", "in", "lst", "]", "\n", "\n", "# defeated, accept the entry as just a simple string...", "\n", "", "", "", "if", "not", "done", ":", "\n", "                ", "ret", "=", "val", "# accept string", "\n", "\n", "# assign secstrct.key = ret", "\n", "", "setattr", "(", "secstrct", ",", "key", ",", "ret", ")", "\n", "\n", "# assign strct.sec = secstrct", "\n", "", "setattr", "(", "strct", ",", "sec", ",", "secstrct", ")", "\n", "\n", "", "return", "strct", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_to_none": [[96, 112], ["None"], "function", ["None"], ["", "", "def", "str_to_none", "(", "val", ")", ":", "\n", "    ", "\"\"\"\n    cast a string to a None\n\n    Parameters:\n        val: the string to cast\n\n    Returns:\n        (casted_val, success)\n        casted val: the casted value if successful, or None\n        success: None if casting was successful\n    \"\"\"", "\n", "if", "val", "==", "'None'", ":", "\n", "        ", "return", "(", "None", ",", "True", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "None", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_to_type": [[114, 136], ["ctype"], "function", ["None"], ["", "", "def", "str_to_type", "(", "val", ",", "ctype", ")", ":", "\n", "    ", "\"\"\"\n    cast a string to a type (e.g. int('8')), with try/except\n    do *not* use for bool casting, instead see str_to_bull\n\n    Parameters:\n        val: the string to cast\n\n    Returns:\n        (casted_val, success)\n        casted val: the casted value if successful, or None\n        success: bool if casting was successful\n    \"\"\"", "\n", "assert", "ctype", "is", "not", "bool", ",", "'use str_to_bull() for casting to bool'", "\n", "\n", "ret", "=", "None", "\n", "success", "=", "True", "\n", "try", ":", "\n", "        ", "ret", "=", "ctype", "(", "val", ")", "\n", "", "except", "ValueError", ":", "\n", "        ", "success", "=", "False", "\n", "", "return", "(", "ret", ",", "success", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_to_bool": [[138, 156], ["None"], "function", ["None"], ["", "def", "str_to_bool", "(", "val", ")", ":", "\n", "    ", "\"\"\"\n    cast a string to a bool\n\n    Parameters:\n        val: the string to cast\n\n    Returns:\n        (casted_val, success)\n        casted val: the casted value if successful, or None\n        success: bool if casting was successful\n    \"\"\"", "\n", "if", "val", "==", "'True'", ":", "\n", "        ", "return", "(", "True", ",", "True", ")", "\n", "", "elif", "val", "==", "'False'", ":", "\n", "        ", "return", "(", "False", ",", "True", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "None", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_to_list": [[158, 180], ["val.replace.replace", "val.replace.replace", "val.replace.replace", "val.replace.replace", "val.replace.split", "val.replace.split"], "function", ["None"], ["", "", "def", "str_to_list", "(", "val", ")", ":", "\n", "    ", "\"\"\"\n    Split a string to a list of elements, where elements are separated by whitespace or commas\n    Leading/ending parantheses are stripped.\n\n    Returns:\n        val: the string to split\n\n    Returns:\n        casted_dst: the casted list\n    \"\"\"", "\n", "val", "=", "val", ".", "replace", "(", "'['", ",", "''", ")", "\n", "val", "=", "val", ".", "replace", "(", "'('", ",", "''", ")", "\n", "val", "=", "val", ".", "replace", "(", "']'", ",", "''", ")", "\n", "val", "=", "val", ".", "replace", "(", "')'", ",", "''", ")", "\n", "\n", "if", "','", "in", "val", ":", "\n", "        ", "lst", "=", "val", ".", "split", "(", "','", ")", "\n", "", "else", ":", "\n", "        ", "lst", "=", "val", ".", "split", "(", ")", "\n", "\n", "", "return", "lst", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_convert_single": [[182, 211], ["val.strip.strip", "iniparse.str_to_type", "iniparse.str_to_type", "iniparse.str_to_bool", "iniparse.str_to_none"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_to_type", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_to_type", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_to_bool", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.iniparse.str_to_none"], ["", "def", "str_convert_single", "(", "val", ")", ":", "\n", "    ", "\"\"\"\n    try to cast a string to an int, float or bool (in that order)\n\n    Parameters:\n        val: the string to cast\n\n    Returns:\n        (casted_val, success)\n        casted val: the casted value if successful, or None\n        success: bool if casting was successful\n    \"\"\"", "\n", "val", "=", "val", ".", "strip", "(", ")", "\n", "# try int", "\n", "ret", ",", "done", "=", "str_to_type", "(", "val", ",", "int", ")", "\n", "\n", "# try float", "\n", "if", "not", "done", ":", "\n", "        ", "ret", ",", "done", "=", "str_to_type", "(", "val", ",", "float", ")", "\n", "\n", "# try bool", "\n", "", "if", "not", "done", ":", "\n", "        ", "ret", ",", "done", "=", "str_to_bool", "(", "val", ")", "\n", "\n", "# try None", "\n", "", "if", "not", "done", ":", "\n", "        ", "ret", ",", "done", "=", "str_to_none", "(", "val", ")", "\n", "\n", "", "return", "(", "ret", ",", "done", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.quilt": [[26, 69], ["len", "patchlib.stack", "nan_func_layers", "nan_func_K", "numpy.prod", "len", "numpy.prod"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack"], ["def", "quilt", "(", "patches", ",", "\n", "patch_size", ",", "\n", "grid_size", ",", "\n", "patch_stride", "=", "1", ",", "\n", "nan_func_layers", "=", "np", ".", "nanmean", ",", "\n", "nan_func_K", "=", "np", ".", "nanmean", ")", ":", "\n", "    ", "\"\"\"\n    quilt (merge) or reconstruct volume from patch indexes in library\n\n    TODO: allow patches to be generator\n\n    Parameters:\n        patches: matrix [N x V x K], with patches(i, :, 1:K)\n            indicates K patch candidates at location i (e.g. the result of a 3-nearest\n            neightbours search). V = prod(patch_size); N = prod(grid_size)\n        patch_size: vector indicating the patch size\n        grid_size or target_size: vector indicating the grid size in each dimension\n            OR\n            specification of the target image size instead of the grid_size\n        patch_stride (optional, default:1): patch stride (spacing), default is 1 (sliding window)\n        nan_func_layers (optional): function to compute accross stack layers. default: np.nanmean\n        nan_func_K (optional): function to compute accross K (nd+1th dim). default: np.nanmean\n\n    Returns:\n        quilt_img: the quilted nd volume\n    \"\"\"", "\n", "\n", "# input checks", "\n", "assert", "patches", ".", "ndim", "==", "2", "or", "patches", ".", "ndim", "==", "3", ",", "'patches should be [NxV] or [NxVxK]'", "\n", "assert", "patches", ".", "shape", "[", "1", "]", "==", "np", ".", "prod", "(", "patch_size", ")", ",", "\"patches V (%d) does not match patch size V (%d)\"", "%", "(", "patches", ".", "shape", "[", "1", "]", ",", "np", ".", "prod", "(", "patch_size", ")", ")", "\n", "nb_dims", "=", "len", "(", "patch_size", ")", "\n", "\n", "# stack patches", "\n", "patch_stack", "=", "stack", "(", "patches", ",", "patch_size", ",", "grid_size", ",", "patch_stride", ")", "\n", "\n", "# quilt via nan_funs", "\n", "quilted_vol_k", "=", "nan_func_layers", "(", "patch_stack", ",", "0", ")", "\n", "quilted_vol", "=", "nan_func_K", "(", "quilted_vol_k", ",", "nb_dims", ")", "\n", "assert", "quilted_vol", ".", "ndim", "==", "len", "(", "patch_size", ")", ",", "\"patchlib: problem with dimensions after quilt\"", "\n", "\n", "# done, yey! time to celebrate - maybe visualize the quilted volume?", "\n", "return", "quilted_vol", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack": [[71, 200], ["patchlib.grid", "numpy.all", "pynd.ind2sub_entries", "list", "numpy.array().transpose", "pynd.sub2ind", "numpy.unique", "len", "numpy.empty", "range", "numpy.prod", "patchlib.grid2volsize", "range", "numpy.empty", "numpy.where", "numpy.empty", "numpy.reshape", "len", "numpy.array", "numpy.nan", "numpy.squeeze", "numpy.reshape", "pynd.slice", "np.empty.flatten", "print", "numpy.array", "numpy.array", "numpy.matlib.repmat", "print", "numpy.zeros", "list", "patchlib._mod_base", "numpy.ones", "list", "numpy.max", "range", "range", "nd.sub2ind.flatten", "len", "numpy.prod"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.grid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ind2sub_entries", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.sub2ind", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.grid2volsize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib._mod_base", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten"], ["", "def", "stack", "(", "patches", ",", "patch_size", ",", "grid_size", ",", "patch_stride", "=", "1", ",", "nargout", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Stack (gridded) patches in layer structure.\n\n    Together, patch_size, grid_size and the patch overlap (see below), indicate\n    how the patches will be layed out and what the target layer size will be. For more\n    information about the interplay between patch_size, grid_size and patchOverlap, see\n    patchlib.grid.\n\n    TODO: allow patches to be generator\n\n    Parameters:\n        patches: matrix [N x V x K], with patches(i, :, 1:K)\n            indicates K patch candidates at location i (e.g. the result of a 3-nearest\n            neightbours search). V = prod(patch_size); N = prod(grid_size)\n        patch_size: vector indicating the patch size\n        grid_size or target_size: vector indicating the grid size in each dimension\n            OR\n            specification of the target image size instead of the grid_size\n        patch_stride (optional, default:1): patch stride (spacing), default is 1 (sliding window)\n        nargout (optional, default:1): the number of arguments to output\n\n    Returns:\n        layers: a [nb_layers x target_size x K] array, with nb_layers that are the size of\n            the desired target (i.e. once the patches are positioned to fit the grid). The\n            first layer, essentially stacks the first patch, then the next non-overlapping patch,\n            and so on. The second layer takes the first non-stacked patch, and then the next\n            non-overlapping patch, and so on until we run out of patches.\n        idxmat (if nargout >= 2): also returns a matrix the same size as\n            'layers' containing linear indexes into the inputted patches matrix. This is useful,\n            for example, to create a layer structure of patch weights to match the patches\n            layer structure. idxmat is [2 x N x targetSize x K], with idxmat[1, :] giving patch\n            ids, and idxmat[2, :] giving voxel ids\n        p_layer_idx (if nargout == 3): a [V x 1] vector indicating the layer index of each input\n            patch\n\n    See Also:\n        grid(), quilt()\n\n    See example in patchlib.quilt code.\n\n    Contact: {adalca,klbouman}@csail.mit.edu\n    \"\"\"", "\n", "\n", "#    assert np.all(np.mod(patch_size, 2) == 1), \"patch size is not odd\"", "\n", "K", "=", "patches", ".", "shape", "[", "2", "]", "if", "len", "(", "patches", ".", "shape", ")", ">", "2", "else", "1", "\n", "\n", "# compute the input target_size and target", "\n", "if", "np", ".", "prod", "(", "grid_size", ")", "==", "patches", ".", "shape", "[", "0", "]", ":", "# given the number of patches in the grid", "\n", "        ", "target_size", "=", "grid2volsize", "(", "grid_size", ",", "patch_size", ",", "patch_stride", "=", "patch_stride", ")", "\n", "", "else", ":", "\n", "        ", "target_size", "=", "grid_size", "\n", "\n", "# compute the grid indexes (and check that the target size matches)", "\n", "", "[", "grid_idx", ",", "target_size_chk", "]", "=", "grid", "(", "target_size", ",", "patch_size", ",", "patch_stride", ",", "nargout", "=", "2", ")", "\n", "assert", "np", ".", "all", "(", "target_size", "==", "target_size_chk", ")", ",", "'Target does not match the provided target size'", "\n", "\n", "# prepare subscript and index vectors", "\n", "grid_sub", "=", "nd", ".", "ind2sub_entries", "(", "grid_idx", ",", "target_size", ")", "\n", "all_idx", "=", "list", "(", "range", "(", "grid_idx", ".", "size", ")", ")", "\n", "\n", "# get index of layer location so that patches don't overlap", "\n", "# we do this by computing the modulo of the patch start location", "\n", "# with respect to the patch size. This won't be optimal yet, but we'll", "\n", "# eliminate any layers with no patches after", "\n", "mod_sub", "=", "np", ".", "array", "(", "[", "_mod_base", "(", "g", ",", "patch_size", ")", "for", "g", "in", "grid_sub", "]", ")", ".", "transpose", "(", ")", "\n", "patch_payer_idx", "=", "nd", ".", "sub2ind", "(", "mod_sub", ",", "patch_size", ")", "\n", "\n", "# initiate the votes layer structure", "\n", "layer_ids", "=", "np", ".", "unique", "(", "patch_payer_idx", ")", "\n", "nb_layers", "=", "len", "(", "layer_ids", ")", "\n", "layers", "=", "np", ".", "empty", "(", "[", "nb_layers", ",", "*", "target_size", ",", "K", "]", ")", "\n", "layers", "[", ":", "]", "=", "np", ".", "NAN", "\n", "\n", "# prepare input matching matrix", "\n", "if", "nargout", ">=", "2", ":", "\n", "        ", "idxmat", "=", "np", ".", "empty", "(", "[", "2", ",", "nb_layers", ",", "*", "target_size", ",", "K", "]", ")", "\n", "idxmat", "[", ":", "]", "=", "np", ".", "NAN", "\n", "\n", "#  go over each layer index", "\n", "", "for", "layer_idx", "in", "range", "(", "nb_layers", ")", ":", "\n", "# get patches attributed to this layer", "\n", "        ", "patch_id_in_layer", "=", "np", ".", "where", "(", "patch_payer_idx", "==", "layer_ids", "[", "layer_idx", "]", ")", "\n", "\n", "# prepare the layers", "\n", "layer_stack", "=", "np", ".", "empty", "(", "[", "*", "target_size", ",", "K", "]", ")", "\n", "layer_stack", "[", ":", "]", "=", "np", ".", "NAN", "\n", "if", "nargout", ">=", "2", ":", "\n", "            ", "layer_idxmat", "=", "np", ".", "nan", "(", "[", "2", ",", "*", "target_size", ",", "K", "]", ")", "\n", "\n", "# go thorugh each patch location for patches in this layer", "\n", "", "for", "pidx", "in", "patch_id_in_layer", "[", "0", "]", ":", "\n", "\n", "# extract the patches", "\n", "            ", "localpatches", "=", "np", ".", "squeeze", "(", "patches", "[", "pidx", ",", ":", "]", ")", "\n", "patch", "=", "np", ".", "reshape", "(", "localpatches", ",", "[", "*", "patch_size", ",", "K", "]", ")", "\n", "\n", "# put the patches in the layers", "\n", "sub", "=", "[", "*", "grid_sub", "[", "pidx", ",", ":", "]", ",", "0", "]", "\n", "endsub", "=", "np", ".", "array", "(", "sub", ")", "+", "np", ".", "array", "(", "[", "*", "patch_size", ",", "K", "]", ")", "\n", "rge", "=", "nd", ".", "slice", "(", "sub", ",", "endsub", ")", "\n", "layer_stack", "[", "rge", "]", "=", "patch", "\n", "\n", "# update input matching matrix", "\n", "if", "nargout", ">=", "2", ":", "\n", "# the linear index of the patch in the grid", "\n", "                ", "locidx", "=", "np", ".", "ones", "(", "[", "2", ",", "*", "patch_size", ",", "K", "]", ")", "*", "all_idx", "[", "pidx", "]", "\n", "locidx", "[", "1", ",", ":", "]", "=", "np", ".", "matlib", ".", "repmat", "(", "list", "(", "range", "(", "np", ".", "prod", "(", "patch_size", ")", ")", ")", ",", "1", ",", "K", ")", "\n", "layer_idxmat", "[", "rge", "]", "=", "locidx", "\n", "\n", "# update layer", "\n", "", "", "layers", "[", "layer_idx", ",", ":", "]", "=", "np", ".", "reshape", "(", "layer_stack", ".", "flatten", "(", ")", ",", "[", "*", "target_size", ",", "K", "]", ")", "\n", "\n", "# update the complete idxmat", "\n", "if", "nargout", ">=", "2", ":", "\n", "            ", "idxmat", "[", "0", ",", "layer_idx", ",", ":", "]", "=", "layer_idxmat", "[", "0", ",", ":", "]", "\n", "idxmat", "[", "1", ",", "layer_idx", ",", ":", "]", "=", "layer_idxmat", "[", "1", ",", ":", "]", "\n", "\n", "# setup outputs", "\n", "", "", "if", "nargout", "==", "1", ":", "\n", "        ", "return", "layers", "\n", "", "elif", "nargout", "==", "2", ":", "\n", "        ", "print", "(", "\"idxmat UNTESTED\"", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "return", "(", "layers", ",", "idxmat", ")", "\n", "", "elif", "nargout", "==", "3", ":", "\n", "        ", "print", "(", "\"p_layer_idx UNTESTED\"", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "p", "=", "np", ".", "zeros", "(", "1", ",", "np", ".", "max", "(", "patch_payer_idx", ".", "flatten", "(", ")", ")", ")", "\n", "p", "[", "layer_ids", "]", "=", "list", "(", "range", "(", "len", "(", "layer_ids", ")", ")", ")", "\n", "return", "(", "layers", ",", "idxmat", ",", "p", "[", "patch_payer_idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.grid2volsize": [[202, 233], ["len", "isinstance", "isinstance", "numpy.array", "isinstance", "numpy.array", "numpy.repeat().astype", "numpy.repeat"], "function", ["None"], ["", "", "def", "grid2volsize", "(", "grid_size", ",", "patch_size", ",", "patch_stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Compute the volume size from the grid size and patch information\n\n    Parameters:\n        grid_size (vector): the size of the grid in each dimension\n        patch_size (vector): the size of the patch_gen\n        patch_stride (vector/scalar, optional): the size of the stride\n\n    Returns:\n        Volume size filled up by the patches\n\n    See Also:\n        gridsize(), grid()\n\n    Contact:\n        {adalca,klbouman}@csail.mit.edu\n    \"\"\"", "\n", "\n", "# parameter checking", "\n", "if", "not", "isinstance", "(", "grid_size", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "grid_size", "=", "np", ".", "array", "(", "grid_size", ",", "'int'", ")", "\n", "", "if", "not", "isinstance", "(", "patch_size", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "patch_size", "=", "np", ".", "array", "(", "patch_size", ",", "'int'", ")", "\n", "", "nb_dims", "=", "len", "(", "patch_size", ")", "# number of dimensions", "\n", "if", "isinstance", "(", "patch_stride", ",", "int", ")", ":", "\n", "        ", "patch_stride", "=", "np", ".", "repeat", "(", "patch_stride", ",", "nb_dims", ")", ".", "astype", "(", "'int'", ")", "\n", "\n", "", "patch_overlap", "=", "patch_size", "-", "patch_stride", "\n", "vol_size", "=", "grid_size", "*", "patch_stride", "+", "patch_overlap", "\n", "return", "vol_size", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.gridsize": [[235, 296], ["len", "isinstance", "isinstance", "numpy.all", "numpy.floor().astype", "numpy.all", "isinstance", "numpy.array", "isinstance", "numpy.array", "numpy.repeat().astype", "numpy.repeat().astype", "patchlib.grid2volsize", "numpy.array", "numpy.floor", "numpy.array", "numpy.repeat", "numpy.repeat"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.grid2volsize"], ["", "def", "gridsize", "(", "vol_size", ",", "patch_size", ",", "patch_stride", "=", "1", ",", "start_sub", "=", "0", ",", "nargout", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Number of patches that fit into volSize given a particular patch_size. patch_strideb\n    cropped to the maximum size that fits the patch grid. For example, a [6x6] volume with\n    patch_size opatch_stridee\n\n    Parameters:\n        vol_size (numpy vector): the size of the input volume\n        patch_size (numpy vector): the size of the patches\n        patch_stride (int or numpy vector, optional): stride (separation) in each dimension.\n            default: 1\n        start_sub (int or numpy vector, optional): the volume location where patches start\n            This essentially means that the volume will be cropped starting at that location.\n            e.g. if startSub is [2, 2], then only vol(2:end, 2:end) will be included.\n            default: 0\n        nargout (int, 1 or 2): optionally output new (cropped) volume size.\n            return the grid_size only if nargout is 1, or (grid_size, new_vol_size)\n            if narout is 2.\n    Returns:\n        grid_size only, if nargout is 1, or\n        (grid_size, new_vol_size) if narout is 2\n\n    See Also:\n        grid()\n\n    Contact:\n        {adalca,klbouman}@csail.mit.edu\n    \"\"\"", "\n", "\n", "# parameter checking", "\n", "if", "not", "isinstance", "(", "vol_size", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "vol_size", "=", "np", ".", "array", "(", "vol_size", ",", "'int'", ")", "\n", "", "if", "not", "isinstance", "(", "patch_size", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "patch_size", "=", "np", ".", "array", "(", "patch_size", ",", "'int'", ")", "\n", "", "nb_dims", "=", "len", "(", "patch_size", ")", "# number of dimensions", "\n", "if", "isinstance", "(", "patch_stride", ",", "int", ")", ":", "\n", "        ", "patch_stride", "=", "np", ".", "repeat", "(", "patch_stride", ",", "nb_dims", ")", ".", "astype", "(", "'int'", ")", "\n", "", "if", "isinstance", "(", "start_sub", ",", "int", ")", ":", "\n", "        ", "start_sub", "=", "np", ".", "repeat", "(", "start_sub", ",", "nb_dims", ")", ".", "astype", "(", "'int'", ")", "\n", "\n", "# adjacent patch overlap", "\n", "", "patch_overlap", "=", "patch_size", "-", "patch_stride", "\n", "\n", "# modified volume size if starting late", "\n", "mod_vol_size", "=", "vol_size", "-", "start_sub", "\n", "assert", "np", ".", "all", "(", "np", ".", "array", "(", "mod_vol_size", ")", ">", "0", ")", ",", "\"New volume size is non-positive\"", "\n", "\n", "# compute the number of patches", "\n", "# the final volume size will be", "\n", "# >> grid_size * patch_stride + patch_overlap", "\n", "# thus the part that is a multiplier of patch_stride is vol_size - patch_overlap", "\n", "patch_stride_multiples", "=", "mod_vol_size", "-", "patch_overlap", "# not sure?", "\n", "grid_size", "=", "np", ".", "floor", "(", "patch_stride_multiples", "/", "patch_stride", ")", ".", "astype", "(", "'int'", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "array", "(", "grid_size", ")", ">", "0", ")", ",", "\"Grid size is non-positive\"", "\n", "\n", "if", "nargout", "==", "1", ":", "\n", "        ", "return", "grid_size", "\n", "", "else", ":", "\n", "# new volume size based on how far the patches can reach", "\n", "        ", "new_vol_size", "=", "grid2volsize", "(", "grid_size", ",", "patch_size", ",", "patch_stride", "=", "patch_stride", ")", "\n", "return", "(", "grid_size", ",", "new_vol_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.grid": [[298, 378], ["len", "isinstance", "isinstance", "patchlib.gridsize", "range", "pynd.ndgrid", "isinstance", "numpy.array", "isinstance", "numpy.array", "numpy.repeat().astype", "numpy.repeat().astype", "list", "any", "numpy.array", "numpy.reshape", "range", "list", "numpy.repeat", "numpy.repeat", "range", "numpy.prod"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.gridsize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ndgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "", "def", "grid", "(", "vol_size", ",", "patch_size", ",", "patch_stride", "=", "1", ",", "start_sub", "=", "0", ",", "nargout", "=", "1", ",", "grid_type", "=", "'idx'", ")", ":", "\n", "    ", "\"\"\"\n    grid of patch starting points for nd volume that fit into given volume size\n\n    The index is in the given volume. If the volume gets cropped as part of the function and you\n    want a linear indexing into the new volume size, use\n    >> newidx = ind2ind(new_vol_size, vol_size, idx)\n    new_vol_size can be passed by the current function, see below.\n\n    Parameters:\n        vol_size (numpy vector): the size of the input volume\n        patch_size (numpy vector): the size of the patches\n        patch_stride (int or numpy vector, optional): stride (separation) in each dimension.\n            default: 1\n        start_sub (int or numpy vector, optional): the volume location where patches start\n            This essentially means that the volume will be cropped starting at that location.\n            e.g. if startSub is [2, 2], then only vol(2:end, 2:end) will be included.\n            default: 0\n        nargout (int, 1,2 or 3): optionally output new (cropped) volume size and the grid size\n            return the idx array only if nargout is 1, or (idx, new_vol_size) if nargout is 2,\n            or (idx, new_vol_size, grid_size) if nargout is 3\n        grid_type ('idx' or 'sub', optional): how to describe the grid, in linear index (idx)\n            or nd subscripts ('sub'). sub will be a nb_patches x nb_dims ndarray. This is\n            equivalent to sub = ind2sub(vol_size, idx), but is done faster inside this function.\n            [TODO: or it was faster in MATLAB, this might not be true in python anymore]\n\n    Returns:\n        idx nd array only if nargout is 1, or (idx, new_vol_size) if nargout is 2,\n            or (idx, new_vol_size, grid_size) if nargout is 3\n\n    See also:\n        gridsize()\n\n    Contact:\n        {adalca,klbouman}@csail.mit.edu\n    \"\"\"", "\n", "\n", "# parameter checking", "\n", "assert", "grid_type", "in", "(", "'idx'", ",", "'sub'", ")", "\n", "if", "not", "isinstance", "(", "vol_size", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "vol_size", "=", "np", ".", "array", "(", "vol_size", ",", "'int'", ")", "\n", "", "if", "not", "isinstance", "(", "patch_size", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "patch_size", "=", "np", ".", "array", "(", "patch_size", ",", "'int'", ")", "\n", "", "nb_dims", "=", "len", "(", "patch_size", ")", "# number of dimensions", "\n", "if", "isinstance", "(", "patch_stride", ",", "int", ")", ":", "\n", "        ", "patch_stride", "=", "np", ".", "repeat", "(", "patch_stride", ",", "nb_dims", ")", ".", "astype", "(", "'int'", ")", "\n", "", "if", "isinstance", "(", "start_sub", ",", "int", ")", ":", "\n", "        ", "start_sub", "=", "np", ".", "repeat", "(", "start_sub", ",", "nb_dims", ")", ".", "astype", "(", "'int'", ")", "\n", "\n", "# get the grid data", "\n", "", "[", "grid_size", ",", "new_vol_size", "]", "=", "gridsize", "(", "vol_size", ",", "patch_size", ",", "\n", "patch_stride", "=", "patch_stride", ",", "\n", "start_sub", "=", "start_sub", ",", "\n", "nargout", "=", "2", ")", "\n", "\n", "# compute grid linear index", "\n", "# prepare the sample grid in each dimension", "\n", "xvec", "=", "(", ")", "\n", "for", "idx", "in", "range", "(", "nb_dims", ")", ":", "\n", "        ", "volend", "=", "new_vol_size", "[", "idx", "]", "+", "start_sub", "[", "idx", "]", "-", "patch_size", "[", "idx", "]", "+", "1", "\n", "locs", "=", "list", "(", "range", "(", "start_sub", "[", "idx", "]", ",", "volend", ",", "patch_stride", "[", "idx", "]", ")", ")", "\n", "xvec", "+=", "(", "locs", ",", ")", "\n", "assert", "any", "(", "(", "locs", "[", "-", "1", "]", "+", "patch_size", "-", "1", ")", "==", "(", "new_vol_size", "+", "start_sub", "-", "1", ")", ")", "\n", "\n", "# get the nd grid", "\n", "# if want subs, this is the faster way to compute in MATLAB (rather than ind -> ind2sub)", "\n", "# TODO: need to investigate for python, maybe use np.ix_ ?", "\n", "", "idx", "=", "nd", ".", "ndgrid", "(", "*", "xvec", ")", "\n", "if", "grid_type", "==", "'idx'", ":", "\n", "# if want index, this is the faster way to compute (rather than sub -> sub2ind", "\n", "        ", "all_idx", "=", "np", ".", "array", "(", "list", "(", "range", "(", "0", ",", "np", ".", "prod", "(", "vol_size", ")", ")", ")", ")", "\n", "all_idx", "=", "np", ".", "reshape", "(", "all_idx", ",", "vol_size", ")", "\n", "idx", "=", "all_idx", "[", "idx", "]", "\n", "\n", "", "if", "nargout", "==", "1", ":", "\n", "        ", "return", "idx", "\n", "", "elif", "nargout", "==", "2", ":", "\n", "        ", "return", "(", "idx", ",", "new_vol_size", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "idx", ",", "new_vol_size", ",", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.patch_gen": [[380, 432], ["isinstance", "numpy.all", "enumerate", "patchlib.gridsize", "pynd.ndgrid", "list", "len", "len", "len", "len", "list", "range", "random.shuffle", "pprint.pformat", "pprint.pformat", "pprint.pformat", "pprint.pformat", "numpy.array", "numpy.array", "list", "len", "len", "random.seed", "slice", "slicer", "range", "zip"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.gridsize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ndgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "", "def", "patch_gen", "(", "vol", ",", "patch_size", ",", "stride", "=", "1", ",", "nargout", "=", "1", ",", "rand", "=", "False", ",", "rand_seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    NOT VERY WELL TESTED\n    generator of patches from volume\n\n    TODO: use .grid() to get sub\n\n    \"\"\"", "\n", "\n", "# some parameter checking", "\n", "if", "isinstance", "(", "stride", ",", "int", ")", ":", "\n", "        ", "stride", "=", "[", "stride", "for", "f", "in", "patch_size", "]", "\n", "", "assert", "len", "(", "vol", ".", "shape", ")", "==", "len", "(", "patch_size", ")", ",", "\"vol shape %s and patch size %s do not match dimensions\"", "%", "(", "pformat", "(", "vol", ".", "shape", ")", ",", "pformat", "(", "patch_size", ")", ")", "\n", "assert", "len", "(", "vol", ".", "shape", ")", "==", "len", "(", "stride", ")", ",", "\"vol shape %s and patch stride %s do not match dimensions\"", "%", "(", "pformat", "(", "vol", ".", "shape", ")", ",", "pformat", "(", "stride", ")", ")", "\n", "\n", "cropped_vol_size", "=", "np", ".", "array", "(", "vol", ".", "shape", ")", "-", "np", ".", "array", "(", "patch_size", ")", "+", "1", "\n", "assert", "np", ".", "all", "(", "cropped_vol_size", ">=", "0", ")", ",", "\"patch size needs to be smaller than volume size\"", "\n", "\n", "# get range subs", "\n", "sub", "=", "(", ")", "\n", "for", "idx", ",", "cvs", "in", "enumerate", "(", "cropped_vol_size", ")", ":", "\n", "        ", "sub", "+=", "(", "list", "(", "range", "(", "0", ",", "cvs", ",", "stride", "[", "idx", "]", ")", ")", ",", ")", "\n", "\n", "# check the size", "\n", "", "gs", "=", "gridsize", "(", "vol", ".", "shape", ",", "patch_size", ",", "patch_stride", "=", "stride", ")", "\n", "assert", "[", "len", "(", "f", ")", "for", "f", "in", "sub", "]", "==", "list", "(", "gs", ")", ",", "'Patch gen side failure'", "\n", "\n", "# get ndgrid of subs", "\n", "ndg", "=", "nd", ".", "ndgrid", "(", "*", "sub", ")", "\n", "ndg", "=", "[", "f", ".", "flat", "for", "f", "in", "ndg", "]", "\n", "\n", "# generator", "\n", "rng", "=", "list", "(", "range", "(", "len", "(", "ndg", "[", "0", "]", ")", ")", ")", "\n", "if", "rand", ":", "\n", "        ", "if", "rand_seed", "is", "not", "None", ":", "\n", "            ", "random", ".", "seed", "(", "rand_seed", ")", "\n", "", "shuffle", "(", "rng", ")", "\n", "\n", "\n", "", "for", "idx", "in", "rng", ":", "\n", "        ", "slicer", "=", "lambda", "f", ",", "g", ":", "slice", "(", "f", "[", "idx", "]", ",", "f", "[", "idx", "]", "+", "g", ")", "\n", "patch_sub", "=", "[", "slicer", "(", "f", ",", "g", ")", "for", "f", ",", "g", "in", "zip", "(", "ndg", ",", "patch_size", ")", "]", "\n", "# print(patch_sub)", "\n", "if", "nargout", "==", "1", ":", "\n", "            ", "yield", "vol", "[", "patch_sub", "]", "\n", "", "else", ":", "\n", "            ", "yield", "(", "vol", "[", "patch_sub", "]", ",", "patch_sub", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib._mod_base": [[436, 452], ["numpy.mod"], "function", ["None"], ["", "", "", "def", "_mod_base", "(", "num", ",", "div", ",", "base", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    modulo with respect to a specific base numbering system\n    i.e. returns base + ((num - base) % div)\n    modBase(num, div) behaves like num % div\n\n    Parameters:\n        num (array_like): divident\n        div (array_like): divisor\n        base (optional, default 0): the base\n\n    Returns:\n        the modulo\n    \"\"\"", "\n", "\n", "return", "base", "+", "np", ".", "mod", "(", "num", "-", "base", ",", "div", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.dataproc.proc_mgh_vols": [[40, 88], ["tqdm.tqdm_notebook", "range", "nibabel.load", "nib.load.get_data().astype", "numpy.savez_compressed", "print", "os.listdir", "f.endswith", "len", "os.path.join", "dataproc.vol_proc", "nib.load.get_data", "print", "os.path.splitext", "os.path.join", "str"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.dataproc.vol_proc"], ["def", "proc_mgh_vols", "(", "inpath", ",", "\n", "outpath", ",", "\n", "ext", "=", "'.mgz'", ",", "\n", "label_idx", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "''' process mgh data from mgz format and save to numpy format\n\n    1. load file\n    2. normalize intensity\n    3. resize\n    4. save as python block\n\n    TODO: check header info and such.?\n    '''", "\n", "\n", "# get files in input directory", "\n", "files", "=", "[", "f", "for", "f", "in", "os", ".", "listdir", "(", "inpath", ")", "if", "f", ".", "endswith", "(", "ext", ")", "]", "\n", "\n", "# go through each file", "\n", "list_skipped_files", "=", "(", ")", "\n", "for", "fileidx", "in", "tqdm", "(", "range", "(", "len", "(", "files", ")", ")", ",", "ncols", "=", "80", ")", ":", "\n", "\n", "# load nifti volume", "\n", "        ", "volnii", "=", "nib", ".", "load", "(", "os", ".", "path", ".", "join", "(", "inpath", ",", "files", "[", "fileidx", "]", ")", ")", "\n", "\n", "# get the data out", "\n", "vol_data", "=", "volnii", ".", "get_data", "(", ")", ".", "astype", "(", "float", ")", "\n", "\n", "if", "(", "'dim'", "in", "volnii", ".", "header", ")", "and", "volnii", ".", "header", "[", "'dim'", "]", "[", "4", "]", ">", "1", ":", "\n", "            ", "vol_data", "=", "vol_data", "[", ":", ",", ":", ",", ":", ",", "-", "1", "]", "\n", "\n", "# process volume", "\n", "", "try", ":", "\n", "            ", "vol_data", "=", "vol_proc", "(", "vol_data", ",", "**", "kwargs", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "list_skipped_files", "+=", "(", "files", "[", "fileidx", "]", ",", ")", "\n", "print", "(", "\"Skipping %s\\nError: %s\"", "%", "(", "files", "[", "fileidx", "]", ",", "str", "(", "e", ")", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "continue", "\n", "\n", "", "if", "label_idx", "is", "not", "None", ":", "\n", "            ", "vol_data", "=", "(", "vol_data", "==", "label_idx", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# save numpy file", "\n", "", "outname", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "join", "(", "outpath", ",", "files", "[", "fileidx", "]", ")", ")", "[", "0", "]", "+", "'.npz'", "\n", "np", ".", "savez_compressed", "(", "outname", ",", "vol_data", "=", "vol_data", ")", "\n", "\n", "", "for", "file", "in", "list_skipped_files", ":", "\n", "        ", "print", "(", "\"Skipped: %s\"", "%", "file", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.dataproc.scans_to_slices": [[90, 160], ["tqdm.tqdm_notebook", "range", "nibabel.load", "nib.load.get_data().astype", "os.listdir", "f.endswith", "len", "os.path.join", "dataproc.vol_proc", "range", "range", "nib.load.get_data", "print", "numpy.squeeze", "PIL.Image.fromarray().convert().save", "nibabel.Nifti1Image", "nibabel.save", "numpy.squeeze", "numpy.squeeze", "numpy.expand_dims", "numpy.diag", "os.path.splitext", "PIL.Image.fromarray().convert", "os.path.splitext", "str", "os.path.join", "os.path.join", "PIL.Image.fromarray"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.dataproc.vol_proc", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save"], ["", "", "def", "scans_to_slices", "(", "inpath", ",", "outpath", ",", "slice_nrs", ",", "\n", "ext", "=", "'.mgz'", ",", "\n", "label_idx", "=", "None", ",", "\n", "dim_idx", "=", "2", ",", "\n", "out_ext", "=", "'.png'", ",", "\n", "slice_pad", "=", "0", ",", "\n", "vol_inner_pad_for_slice_nrs", "=", "0", ",", "\n", "**", "kwargs", ")", ":", "# vol_proc args", "\n", "\n", "# get files in input directory", "\n", "    ", "files", "=", "[", "f", "for", "f", "in", "os", ".", "listdir", "(", "inpath", ")", "if", "f", ".", "endswith", "(", "ext", ")", "]", "\n", "\n", "# go through each file", "\n", "list_skipped_files", "=", "(", ")", "\n", "for", "fileidx", "in", "tqdm", "(", "range", "(", "len", "(", "files", ")", ")", ",", "ncols", "=", "80", ")", ":", "\n", "\n", "# load nifti volume", "\n", "        ", "volnii", "=", "nib", ".", "load", "(", "os", ".", "path", ".", "join", "(", "inpath", ",", "files", "[", "fileidx", "]", ")", ")", "\n", "\n", "# get the data out", "\n", "vol_data", "=", "volnii", ".", "get_data", "(", ")", ".", "astype", "(", "float", ")", "\n", "\n", "if", "(", "'dim'", "in", "volnii", ".", "header", ")", "and", "volnii", ".", "header", "[", "'dim'", "]", "[", "4", "]", ">", "1", ":", "\n", "            ", "vol_data", "=", "vol_data", "[", ":", ",", ":", ",", ":", ",", "-", "1", "]", "\n", "\n", "", "if", "slice_pad", ">", "0", ":", "\n", "            ", "assert", "(", "out_ext", "!=", "'.png'", ")", ",", "\"slice pad can only be used with volumes\"", "\n", "\n", "# process volume", "\n", "", "try", ":", "\n", "            ", "vol_data", "=", "vol_proc", "(", "vol_data", ",", "**", "kwargs", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "list_skipped_files", "+=", "(", "files", "[", "fileidx", "]", ",", ")", "\n", "print", "(", "\"Skipping %s\\nError: %s\"", "%", "(", "files", "[", "fileidx", "]", ",", "str", "(", "e", ")", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "continue", "\n", "\n", "", "mult_fact", "=", "255", "\n", "if", "label_idx", "is", "not", "None", ":", "\n", "            ", "vol_data", "=", "(", "vol_data", "==", "label_idx", ")", ".", "astype", "(", "int", ")", "\n", "mult_fact", "=", "1", "\n", "\n", "# extract slice", "\n", "", "if", "slice_nrs", "is", "None", ":", "\n", "            ", "slice_nrs_sel", "=", "range", "(", "vol_inner_pad_for_slice_nrs", "+", "slice_pad", ",", "vol_data", ".", "shape", "[", "dim_idx", "]", "-", "slice_pad", "-", "vol_inner_pad_for_slice_nrs", ")", "\n", "", "else", ":", "\n", "            ", "slice_nrs_sel", "=", "slice_nrs", "\n", "\n", "", "for", "slice_nr", "in", "slice_nrs_sel", ":", "\n", "            ", "slice_nr_out", "=", "range", "(", "slice_nr", "-", "slice_pad", ",", "slice_nr", "+", "slice_pad", "+", "1", ")", "\n", "if", "dim_idx", "==", "2", ":", "# TODO: fix in one line", "\n", "                ", "vol_img", "=", "np", ".", "squeeze", "(", "vol_data", "[", ":", ",", ":", ",", "slice_nr_out", "]", ")", "\n", "", "elif", "dim_idx", "==", "1", ":", "\n", "                ", "vol_img", "=", "np", ".", "squeeze", "(", "vol_data", "[", ":", ",", "slice_nr_out", ",", ":", "]", ")", "\n", "", "else", ":", "\n", "                ", "vol_img", "=", "np", ".", "squeeze", "(", "vol_data", "[", "slice_nr_out", ",", ":", ",", ":", "]", ")", "\n", "\n", "# save file", "\n", "", "if", "out_ext", "==", "'.png'", ":", "\n", "# save png file", "\n", "                ", "img", "=", "(", "vol_img", "*", "mult_fact", ")", ".", "astype", "(", "'uint8'", ")", "\n", "outname", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "join", "(", "outpath", ",", "files", "[", "fileidx", "]", ")", ")", "[", "0", "]", "+", "'_slice%d.png'", "%", "slice_nr", "\n", "Image", ".", "fromarray", "(", "img", ")", ".", "convert", "(", "'RGB'", ")", ".", "save", "(", "outname", ")", "\n", "", "else", ":", "\n", "                ", "if", "slice_pad", "==", "0", ":", "# dimenion has collapsed", "\n", "                    ", "assert", "vol_img", ".", "ndim", "==", "2", "\n", "vol_img", "=", "np", ".", "expand_dims", "(", "vol_img", ",", "dim_idx", ")", "\n", "# assuming nibabel saving image", "\n", "", "nii", "=", "nib", ".", "Nifti1Image", "(", "vol_img", ",", "np", ".", "diag", "(", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", ")", "\n", "outname", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "join", "(", "outpath", ",", "files", "[", "fileidx", "]", ")", ")", "[", "0", "]", "+", "'_slice%d.nii.gz'", "%", "slice_nr", "\n", "nib", ".", "save", "(", "nii", ",", "outname", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.dataproc.vol_proc": [[162, 231], ["numpy.multiply", "numpy.percentile", "numpy.multiply", "numpy.divide", "scipy.ndimage.interpolation.zoom", "pynd.volcrop", "numpy.clip", "np.clip.astype", "numpy.divide", "numpy.round().astype", "numpy.max", "numpy.min", "numpy.where", "len", "numpy.ix_", "numpy.round"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.volcrop"], ["", "", "", "", "def", "vol_proc", "(", "vol_data", ",", "\n", "crop", "=", "None", ",", "\n", "resize_shape", "=", "None", ",", "# None (to not resize), or vector. If vector, third entry can be None", "\n", "interp_order", "=", "None", ",", "\n", "rescale", "=", "None", ",", "\n", "rescale_prctle", "=", "None", ",", "\n", "resize_slices", "=", "None", ",", "\n", "resize_slices_dim", "=", "None", ",", "\n", "offset", "=", "None", ",", "\n", "clip", "=", "None", ",", "\n", "extract_nd", "=", "None", ",", "# extracts a particular section", "\n", "force_binary", "=", "None", ",", "# forces anything > 0 to be 1", "\n", "permute", "=", "None", ")", ":", "\n", "    ", "''' process a volume with a series of intensity rescale, resize and crop rescale'''", "\n", "\n", "if", "offset", "is", "not", "None", ":", "\n", "        ", "vol_data", "=", "vol_data", "+", "offset", "\n", "\n", "# intensity normalize data .* rescale", "\n", "", "if", "rescale", "is", "not", "None", ":", "\n", "        ", "vol_data", "=", "np", ".", "multiply", "(", "vol_data", ",", "rescale", ")", "\n", "\n", "", "if", "rescale_prctle", "is", "not", "None", ":", "\n", "# print(\"max:\", np.max(vol_data.flat))", "\n", "# print(\"test\")", "\n", "        ", "rescale", "=", "np", ".", "percentile", "(", "vol_data", ".", "flat", ",", "rescale_prctle", ")", "\n", "# print(\"rescaling by 1/%f\" % (rescale))", "\n", "vol_data", "=", "np", ".", "multiply", "(", "vol_data", ".", "astype", "(", "float", ")", ",", "1", "/", "rescale", ")", "\n", "\n", "", "if", "resize_slices", "is", "not", "None", ":", "\n", "        ", "resize_slices", "=", "[", "*", "resize_slices", "]", "\n", "assert", "resize_shape", "is", "None", ",", "\"if resize_slices is given, resize_shape has to be None\"", "\n", "resize_shape", "=", "resize_slices", "\n", "if", "resize_slices_dim", "is", "None", ":", "\n", "            ", "resize_slices_dim", "=", "np", ".", "where", "(", "[", "f", "is", "None", "for", "f", "in", "resize_slices", "]", ")", "[", "0", "]", "\n", "assert", "len", "(", "resize_slices_dim", ")", "==", "1", ",", "\"Could not find dimension or slice resize\"", "\n", "resize_slices_dim", "=", "resize_slices_dim", "[", "0", "]", "\n", "", "resize_shape", "[", "resize_slices_dim", "]", "=", "vol_data", ".", "shape", "[", "resize_slices_dim", "]", "\n", "\n", "# resize (downsample) matrices", "\n", "", "if", "resize_shape", "is", "not", "None", "and", "resize_shape", "!=", "vol_data", ".", "shape", ":", "\n", "        ", "resize_shape", "=", "[", "*", "resize_shape", "]", "\n", "# allow for the last entry to be None", "\n", "if", "resize_shape", "[", "-", "1", "]", "is", "None", ":", "\n", "            ", "resize_ratio", "=", "np", ".", "divide", "(", "resize_shape", "[", "0", "]", ",", "vol_data", ".", "shape", "[", "0", "]", ")", "\n", "resize_shape", "[", "-", "1", "]", "=", "np", ".", "round", "(", "resize_ratio", "*", "vol_data", ".", "shape", "[", "-", "1", "]", ")", ".", "astype", "(", "'int'", ")", "\n", "", "resize_ratio", "=", "np", ".", "divide", "(", "resize_shape", ",", "vol_data", ".", "shape", ")", "\n", "vol_data", "=", "scipy", ".", "ndimage", ".", "interpolation", ".", "zoom", "(", "vol_data", ",", "resize_ratio", ",", "order", "=", "interp_order", ")", "\n", "\n", "# crop data if necessary", "\n", "", "if", "crop", "is", "not", "None", ":", "\n", "        ", "vol_data", "=", "nd", ".", "volcrop", "(", "vol_data", ",", "crop", "=", "crop", ")", "\n", "\n", "# needs to be last to guarantee clip limits.", "\n", "# For e.g., resize might screw this up due to bicubic interpolation if it was done after.", "\n", "", "if", "clip", "is", "not", "None", ":", "\n", "        ", "vol_data", "=", "np", ".", "clip", "(", "vol_data", ",", "clip", "[", "0", "]", ",", "clip", "[", "1", "]", ")", "\n", "\n", "", "if", "extract_nd", "is", "not", "None", ":", "\n", "        ", "vol_data", "=", "vol_data", "[", "np", ".", "ix_", "(", "*", "extract_nd", ")", "]", "\n", "\n", "", "if", "force_binary", ":", "\n", "        ", "vol_data", "=", "(", "vol_data", ">", "0", ")", ".", "astype", "(", "float", ")", "\n", "\n", "# return with checks. this check should be right at the end before rturn", "\n", "", "if", "clip", "is", "not", "None", ":", "\n", "        ", "assert", "np", ".", "max", "(", "vol_data", ")", "<=", "clip", "[", "1", "]", ",", "\"clip failed\"", "\n", "assert", "np", ".", "min", "(", "vol_data", ")", ">=", "clip", "[", "0", "]", ",", "\"clip failed\"", "\n", "", "return", "vol_data", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.dataproc.prior_to_weights": [[233, 287], ["isinstance", "numpy.reshape", "numpy.sum", "numpy.any", "numpy.sum", "numpy.delete", "numpy.sum", "numpy.sum", "print", "numpy.sum", "matplotlib.subplots", "ax1.bar", "ax1.set_title", "ax2.bar", "ax2.set_title", "ax3.bar", "ax3.set_title", "f.set_size_inches", "matplotlib.show", "numpy.set_printoptions", "numpy.load", "numpy.ndim", "numpy.ndim", "numpy.prod", "range", "range", "numpy.log", "range", "range", "numpy.log", "numpy.min", "numpy.log", "numpy.ndim"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "prior_to_weights", "(", "prior_filename", ",", "nargout", "=", "1", ",", "min_freq", "=", "0", ",", "force_binary", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "\n", "    ", "''' transform a 4D prior (3D + nb_labels) into a class weight vector '''", "\n", "\n", "# load prior", "\n", "if", "isinstance", "(", "prior_filename", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "prior", "=", "np", ".", "load", "(", "prior_filename", ")", "[", "'prior'", "]", "\n", "", "else", ":", "\n", "        ", "prior", "=", "prior_filename", "\n", "\n", "# assumes prior is 4D.", "\n", "", "assert", "np", ".", "ndim", "(", "prior", ")", "==", "4", "or", "np", ".", "ndim", "(", "prior", ")", "==", "3", ",", "\"prior is the wrong number of dimensions\"", "\n", "prior_flat", "=", "np", ".", "reshape", "(", "prior", ",", "(", "np", ".", "prod", "(", "prior", ".", "shape", "[", "0", ":", "(", "np", ".", "ndim", "(", "prior", ")", "-", "1", ")", "]", ")", ",", "prior", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "\n", "if", "force_binary", ":", "\n", "        ", "nb_labels", "=", "prior_flat", ".", "shape", "[", "-", "1", "]", "\n", "prior_flat", "[", ":", ",", "1", "]", "=", "np", ".", "sum", "(", "prior_flat", "[", ":", ",", "1", ":", "nb_labels", "]", ",", "1", ")", "\n", "prior_flat", "=", "np", ".", "delete", "(", "prior_flat", ",", "range", "(", "2", ",", "nb_labels", ")", ",", "1", ")", "\n", "\n", "# sum total class votes", "\n", "", "class_count", "=", "np", ".", "sum", "(", "prior_flat", ",", "0", ")", "\n", "class_prior", "=", "class_count", "/", "np", ".", "sum", "(", "class_count", ")", "\n", "\n", "# adding minimum frequency", "\n", "class_prior", "[", "class_prior", "<", "min_freq", "]", "=", "min_freq", "\n", "class_prior", "=", "class_prior", "/", "np", ".", "sum", "(", "class_prior", ")", "\n", "\n", "if", "np", ".", "any", "(", "class_prior", "==", "0", ")", ":", "\n", "        ", "print", "(", "\"Warning, found a label with 0 support. Setting its weight to 0!\"", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "class_prior", "[", "class_prior", "==", "0", "]", "=", "np", ".", "inf", "\n", "\n", "# compute weights from class frequencies", "\n", "", "weights", "=", "1", "/", "class_prior", "\n", "weights", "=", "weights", "/", "np", ".", "sum", "(", "weights", ")", "\n", "# weights[0] = 0 # explicitly don't care about bg", "\n", "\n", "# a bit of verbosity", "\n", "if", "verbose", ":", "\n", "        ", "f", ",", "(", "ax1", ",", "ax2", ",", "ax3", ")", "=", "plt", ".", "subplots", "(", "1", ",", "3", ")", "\n", "ax1", ".", "bar", "(", "range", "(", "prior", ".", "size", ")", ",", "np", ".", "log", "(", "prior", ")", ")", "\n", "ax1", ".", "set_title", "(", "'log class freq'", ")", "\n", "ax2", ".", "bar", "(", "range", "(", "weights", ".", "size", ")", ",", "weights", ")", "\n", "ax2", ".", "set_title", "(", "'weights'", ")", "\n", "ax3", ".", "bar", "(", "range", "(", "weights", ".", "size", ")", ",", "np", ".", "log", "(", "(", "weights", ")", ")", "-", "np", ".", "min", "(", "np", ".", "log", "(", "(", "weights", ")", ")", ")", ")", "\n", "ax3", ".", "set_title", "(", "'log(weights)-minlog'", ")", "\n", "f", ".", "set_size_inches", "(", "12", ",", "3", ")", "\n", "plt", ".", "show", "(", ")", "\n", "np", ".", "set_printoptions", "(", "precision", "=", "3", ")", "\n", "\n", "# return", "\n", "", "if", "nargout", "==", "1", ":", "\n", "        ", "return", "weights", "\n", "", "else", ":", "\n", "        ", "return", "(", "weights", ",", "prior", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.dataproc.filestruct_change": [[291, 359], ["tqdm.tqdm_notebook", "os.path.isdir", "os.mkdir", "os.listdir", "os.listdir", "os.path.join", "sum", "os.path.splitext", "isinstance", "os.path.join", "os.path.join", "os.path.join", "re.match", "os.path.isdir", "os.mkdir", "os.symlink", "shutil.copyfile", "re_map.keys", "enumerate", "list", "re_map.keys"], "function", ["None"], ["", "", "def", "filestruct_change", "(", "in_path", ",", "out_path", ",", "re_map", ",", "\n", "mode", "=", "'subj_to_type'", ",", "\n", "use_symlinks", "=", "False", ",", "name", "=", "\"\"", ")", ":", "\n", "    ", "\"\"\"\n    change from independent subjects in a folder to breakdown structure \n\n    example: filestruct_change('/../in_path', '/../out_path', {'asegs.nii.gz':'asegs', 'norm.nii.gz':'vols'})\n\n\n    input structure: \n        /.../in_path/subj_1 --> with files that match regular repressions defined in re_map.keys()\n        /.../in_path/subj_2 --> with files that match regular repressions defined in re_map.keys()\n        ...\n    output structure:\n        /.../out_path/asegs/subj_1.nii.gz, subj_2.nii.gz\n        /.../out_path/vols/subj_1.nii.gz, subj_2.nii.gz\n\n    Parameters:\n        in_path (string): input path\n        out_path (string): output path\n        re_map (dictionary): keys are reg-exs that match files in the input folders. \n            values are the folders to put those files in the new structure. \n            values can also be tuples, in which case values[0] is the dst folder, \n            and values[1] is the extension of the output file\n        mode (optional)\n        use_symlinks (bool): whether to just use symlinks rather than copy files\n            default:True\n    \"\"\"", "\n", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "out_path", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "out_path", ")", "\n", "\n", "# go through folders", "\n", "", "for", "subj", "in", "tqdm", "(", "os", ".", "listdir", "(", "in_path", ")", ",", "desc", "=", "name", ")", ":", "\n", "\n", "# go through files in a folder", "\n", "        ", "files", "=", "os", ".", "listdir", "(", "os", ".", "path", ".", "join", "(", "in_path", ",", "subj", ")", ")", "\n", "for", "file", "in", "files", ":", "\n", "\n", "# see which key matches. Make sure only one does.", "\n", "            ", "matches", "=", "[", "re", ".", "match", "(", "k", ",", "file", ")", "for", "k", "in", "re_map", ".", "keys", "(", ")", "]", "\n", "nb_matches", "=", "sum", "(", "[", "f", "is", "not", "None", "for", "f", "in", "matches", "]", ")", "\n", "assert", "nb_matches", "==", "1", ",", "\"Found %d matches for file %s/%s\"", "%", "(", "nb_matches", ",", "file", ",", "subj", ")", "\n", "\n", "# get the matches key", "\n", "match_idx", "=", "[", "i", "for", "i", ",", "f", "in", "enumerate", "(", "matches", ")", "if", "f", "is", "not", "None", "]", "[", "0", "]", "\n", "matched_dst", "=", "re_map", "[", "list", "(", "re_map", ".", "keys", "(", ")", ")", "[", "match_idx", "]", "]", "\n", "_", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "file", ")", "\n", "if", "isinstance", "(", "matched_dst", ",", "tuple", ")", ":", "\n", "                ", "ext", "=", "matched_dst", "[", "1", "]", "\n", "matched_dst", "=", "matched_dst", "[", "0", "]", "\n", "\n", "# prepare source and destination file", "\n", "", "src_file", "=", "os", ".", "path", ".", "join", "(", "in_path", ",", "subj", ",", "file", ")", "\n", "dst_path", "=", "os", ".", "path", ".", "join", "(", "out_path", ",", "matched_dst", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "dst_path", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "dst_path", ")", "\n", "", "dst_file", "=", "os", ".", "path", ".", "join", "(", "dst_path", ",", "subj", "+", "ext", ")", "\n", "\n", "if", "use_symlinks", ":", "\n", "# on windows there are permission problems. ", "\n", "# Can try : call(['mklink', 'LINK', 'TARGET'], shell=True)", "\n", "# or note https://stackoverflow.com/questions/6260149/os-symlink-support-in-windows", "\n", "                ", "os", ".", "symlink", "(", "src_file", ",", "dst_file", ")", "\n", "\n", "", "else", ":", "\n", "                ", "shutil", ".", "copyfile", "(", "src_file", ",", "dst_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.dataproc.ml_split": [[361, 411], ["sorted", "len", "numpy.random.permutation", "numpy.cumsum", "numpy.round().astype", "enumerate", "numpy.random.seed", "os.path.isdir", "os.makedirs", "os.listdir", "print", "tqdm.tqdm_notebook", "numpy.array", "numpy.round", "os.path.isdir", "os.mkdir", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.symlink", "os.path.isdir", "shutil.copytree", "shutil.copyfile"], "function", ["None"], ["", "", "", "", "def", "ml_split", "(", "in_path", ",", "out_path", ",", "\n", "cat_titles", "=", "[", "'train'", ",", "'validate'", ",", "'test'", "]", ",", "\n", "cat_prop", "=", "[", "0.5", ",", "0.3", ",", "0.2", "]", ",", "\n", "use_symlinks", "=", "False", ",", "\n", "seed", "=", "None", ",", "\n", "tqdm", "=", "tqdm", ")", ":", "\n", "    ", "\"\"\"\n    split dataset \n    \"\"\"", "\n", "\n", "if", "seed", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "out_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_path", ")", "\n", "\n", "# get subjects and randomize their order", "\n", "", "subjs", "=", "sorted", "(", "os", ".", "listdir", "(", "in_path", ")", ")", "\n", "nb_subj", "=", "len", "(", "subjs", ")", "\n", "subj_order", "=", "np", ".", "random", ".", "permutation", "(", "nb_subj", ")", "\n", "\n", "# prepare split", "\n", "cat_tot", "=", "np", ".", "cumsum", "(", "cat_prop", ")", "\n", "if", "not", "cat_tot", "[", "-", "1", "]", "==", "1", ":", "\n", "        ", "print", "(", "\"split_prop sums to %f, re-normalizing\"", "%", "cat_tot", ")", "\n", "cat_tot", "=", "np", ".", "array", "(", "cat_tot", ")", "/", "cat_tot", "[", "-", "1", "]", "\n", "", "nb_cat_subj", "=", "np", ".", "round", "(", "cat_tot", "*", "nb_subj", ")", ".", "astype", "(", "int", ")", "\n", "cat_subj_start", "=", "[", "0", ",", "*", "nb_cat_subj", "[", ":", "-", "1", "]", "]", "\n", "\n", "# go through each category", "\n", "for", "cat_idx", ",", "cat", "in", "enumerate", "(", "cat_titles", ")", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "out_path", ",", "cat", ")", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "os", ".", "path", ".", "join", "(", "out_path", ",", "cat", ")", ")", "\n", "\n", "", "cat_subj_idx", "=", "subj_order", "[", "cat_subj_start", "[", "cat_idx", "]", ":", "nb_cat_subj", "[", "cat_idx", "]", "]", "\n", "for", "subj_idx", "in", "tqdm", "(", "cat_subj_idx", ",", "desc", "=", "cat", ")", ":", "\n", "            ", "src_folder", "=", "os", ".", "path", ".", "join", "(", "in_path", ",", "subjs", "[", "subj_idx", "]", ")", "\n", "dst_folder", "=", "os", ".", "path", ".", "join", "(", "out_path", ",", "cat", ",", "subjs", "[", "subj_idx", "]", ")", "\n", "\n", "if", "use_symlinks", ":", "\n", "# on windows there are permission problems. ", "\n", "# Can try : call(['mklink', 'LINK', 'TARGET'], shell=True)", "\n", "# or note https://stackoverflow.com/questions/6260149/os-symlink-support-in-windows", "\n", "                ", "os", ".", "symlink", "(", "src_folder", ",", "dst_folder", ")", "\n", "\n", "", "else", ":", "\n", "                ", "if", "os", ".", "path", ".", "isdir", "(", "src_folder", ")", ":", "\n", "                    ", "shutil", ".", "copytree", "(", "src_folder", ",", "dst_folder", ")", "\n", "", "else", ":", "\n", "                    ", "shutil", ".", "copyfile", "(", "src_folder", ",", "dst_folder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.plot.slices": [[20, 125], ["len", "enumerate", "plot.slices.input_check"], "function", ["None"], ["def", "slices", "(", "slices_in", ",", "# the 2D slices", "\n", "titles", "=", "None", ",", "# list of titles", "\n", "cmaps", "=", "None", ",", "# list of colormaps", "\n", "norms", "=", "None", ",", "# list of normalizations", "\n", "do_colorbars", "=", "False", ",", "# option to show colorbars on each slice", "\n", "grid", "=", "False", ",", "# option to plot the images in a grid or a single row", "\n", "width", "=", "15", ",", "# width in in", "\n", "show", "=", "True", ",", "# option to actually show the plot (plt.show())", "\n", "axes_off", "=", "True", ",", "\n", "imshow_args", "=", "None", ")", ":", "\n", "    ", "'''\n    plot a grid of slices (2d images)\n    '''", "\n", "\n", "# input processing", "\n", "if", "type", "(", "slices_in", ")", "==", "np", ".", "ndarray", ":", "\n", "        ", "slices_in", "=", "[", "slices_in", "]", "\n", "", "nb_plots", "=", "len", "(", "slices_in", ")", "\n", "for", "si", ",", "slice_in", "in", "enumerate", "(", "slices_in", ")", ":", "\n", "        ", "if", "len", "(", "slice_in", ".", "shape", ")", "!=", "2", ":", "\n", "            ", "assert", "len", "(", "slice_in", ".", "shape", ")", "==", "3", "and", "slice_in", ".", "shape", "[", "-", "1", "]", "==", "3", ",", "'each slice has to be 2d or RGB (3 channels)'", "\n", "", "slices_in", "[", "si", "]", "=", "slice_in", ".", "astype", "(", "'float'", ")", "\n", "\n", "\n", "", "def", "input_check", "(", "inputs", ",", "nb_plots", ",", "name", ")", ":", "\n", "        ", "''' change input from None/single-link '''", "\n", "assert", "(", "inputs", "is", "None", ")", "or", "(", "len", "(", "inputs", ")", "==", "nb_plots", ")", "or", "(", "len", "(", "inputs", ")", "==", "1", ")", ",", "'number of %s is incorrect'", "%", "name", "\n", "if", "inputs", "is", "None", ":", "\n", "            ", "inputs", "=", "[", "None", "]", "\n", "", "if", "len", "(", "inputs", ")", "==", "1", ":", "\n", "            ", "inputs", "=", "[", "inputs", "[", "0", "]", "for", "i", "in", "range", "(", "nb_plots", ")", "]", "\n", "", "return", "inputs", "\n", "\n", "", "titles", "=", "input_check", "(", "titles", ",", "nb_plots", ",", "'titles'", ")", "\n", "cmaps", "=", "input_check", "(", "cmaps", ",", "nb_plots", ",", "'cmaps'", ")", "\n", "norms", "=", "input_check", "(", "norms", ",", "nb_plots", ",", "'norms'", ")", "\n", "imshow_args", "=", "input_check", "(", "imshow_args", ",", "nb_plots", ",", "'imshow_args'", ")", "\n", "for", "idx", ",", "ia", "in", "enumerate", "(", "imshow_args", ")", ":", "\n", "        ", "imshow_args", "[", "idx", "]", "=", "{", "}", "if", "ia", "is", "None", "else", "ia", "\n", "\n", "# figure out the number of rows and columns", "\n", "", "if", "grid", ":", "\n", "        ", "if", "isinstance", "(", "grid", ",", "bool", ")", ":", "\n", "            ", "rows", "=", "np", ".", "floor", "(", "np", ".", "sqrt", "(", "nb_plots", ")", ")", ".", "astype", "(", "int", ")", "\n", "cols", "=", "np", ".", "ceil", "(", "nb_plots", "/", "rows", ")", ".", "astype", "(", "int", ")", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "grid", ",", "(", "list", ",", "tuple", ")", ")", ",", "\"grid should either be bool or [rows,cols]\"", "\n", "rows", ",", "cols", "=", "grid", "\n", "", "", "else", ":", "\n", "        ", "rows", "=", "1", "\n", "cols", "=", "nb_plots", "\n", "\n", "# prepare the subplot", "\n", "", "fig", ",", "axs", "=", "plt", ".", "subplots", "(", "rows", ",", "cols", ")", "\n", "if", "rows", "==", "1", "and", "cols", "==", "1", ":", "\n", "        ", "axs", "=", "[", "axs", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "nb_plots", ")", ":", "\n", "        ", "col", "=", "np", ".", "remainder", "(", "i", ",", "cols", ")", "\n", "row", "=", "np", ".", "floor", "(", "i", "/", "cols", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# get row and column axes", "\n", "row_axs", "=", "axs", "if", "rows", "==", "1", "else", "axs", "[", "row", "]", "\n", "ax", "=", "row_axs", "[", "col", "]", "\n", "\n", "# turn off axis", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "\n", "# add titles", "\n", "if", "titles", "is", "not", "None", "and", "titles", "[", "i", "]", "is", "not", "None", ":", "\n", "            ", "ax", ".", "title", ".", "set_text", "(", "titles", "[", "i", "]", ")", "\n", "\n", "# show figure", "\n", "", "im_ax", "=", "ax", ".", "imshow", "(", "slices_in", "[", "i", "]", ",", "cmap", "=", "cmaps", "[", "i", "]", ",", "interpolation", "=", "\"nearest\"", ",", "norm", "=", "norms", "[", "i", "]", ",", "**", "imshow_args", "[", "i", "]", ")", "\n", "\n", "# colorbars", "\n", "# http://stackoverflow.com/questions/18195758/set-matplotlib-colorbar-size-to-match-graph", "\n", "if", "do_colorbars", "and", "cmaps", "[", "i", "]", "is", "not", "None", ":", "\n", "            ", "divider", "=", "make_axes_locatable", "(", "ax", ")", "\n", "cax", "=", "divider", ".", "append_axes", "(", "\"right\"", ",", "size", "=", "\"5%\"", ",", "pad", "=", "0.05", ")", "\n", "fig", ".", "colorbar", "(", "im_ax", ",", "cax", "=", "cax", ")", "\n", "\n", "# clear axes that are unnecessary", "\n", "", "", "for", "i", "in", "range", "(", "nb_plots", ",", "col", "*", "row", ")", ":", "\n", "        ", "col", "=", "np", ".", "remainder", "(", "i", ",", "cols", ")", "\n", "row", "=", "np", ".", "floor", "(", "i", "/", "cols", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# get row and column axes", "\n", "row_axs", "=", "axs", "if", "rows", "==", "1", "else", "axs", "[", "row", "]", "\n", "ax", "=", "row_axs", "[", "col", "]", "\n", "\n", "if", "axes_off", ":", "\n", "            ", "ax", ".", "axis", "(", "'off'", ")", "\n", "\n", "# show the plots", "\n", "", "", "fig", ".", "set_size_inches", "(", "width", ",", "rows", "/", "cols", "*", "width", ")", "\n", "\n", "\n", "if", "show", ":", "\n", "        ", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "return", "(", "fig", ",", "axs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.plot.volume3D": [[127, 162], ["len", "all", "enumerate", "plot.slices", "isinstance", "kwargs.keys", "kwargs.keys", "isinstance", "len", "numpy.take", "range", "range"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.plot.slices", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "volume3D", "(", "vols", ",", "slice_nos", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    plot slices of a 3D volume by taking a middle slice of each axis\n    \n    Parameters:\n        vols: a 3d volume or list of 3d volumes\n        slice_nos (optional): a list of 3 elements of the slice numbers for each axis, \n            or list of lists of 3 elements. if None, the middle slices will be used.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "vols", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "        ", "vols", "=", "[", "vols", "]", "\n", "", "nb_vols", "=", "len", "(", "vols", ")", "\n", "\n", "assert", "all", "(", "[", "len", "(", "vol", ".", "shape", ")", "==", "3", "for", "vol", "in", "vols", "]", ")", ",", "'only 3d volumes allowed in volume3D'", "\n", "\n", "slics", "=", "[", "]", "\n", "for", "vi", ",", "vol", "in", "enumerate", "(", "vols", ")", ":", "\n", "\n", "        ", "these_slice_nos", "=", "slice_nos", "\n", "if", "slice_nos", "is", "None", ":", "\n", "            ", "these_slice_nos", "=", "[", "f", "//", "2", "for", "f", "in", "vol", ".", "shape", "]", "\n", "", "elif", "isinstance", "(", "slice_nos", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "these_slice_nos", "=", "slice_nos", "[", "vi", "]", "\n", "", "else", ":", "\n", "            ", "these_slice_nos", "=", "slice_nos", "\n", "\n", "", "slics", "=", "slics", "+", "[", "np", ".", "take", "(", "vol", ",", "these_slice_nos", "[", "d", "]", ",", "d", ")", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n", "", "if", "'titles'", "not", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "        ", "kwargs", "[", "'titles'", "]", "=", "[", "'axis %d'", "%", "d", "for", "d", "in", "range", "(", "3", ")", "]", "*", "nb_vols", "\n", "\n", "", "if", "'grid'", "not", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "        ", "kwargs", "[", "'grid'", "]", "=", "[", "nb_vols", ",", "3", "]", "\n", "\n", "", "slices", "(", "slics", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.plot.flow_legend": [[164, 188], ["numpy.linspace", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin", "numpy.arctan2", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize.autoscale", "matplotlib.figure", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.quiver", "matplotlib.show", "colormap", "matplotlib.colors.Normalize."], "function", ["None"], ["", "def", "flow_legend", "(", ")", ":", "\n", "    ", "\"\"\"\n    show quiver plot to indicate how arrows are colored in the flow() method.\n    https://stackoverflow.com/questions/40026718/different-colours-for-arrows-in-quiver-plot\n    \"\"\"", "\n", "ph", "=", "np", ".", "linspace", "(", "0", ",", "2", "*", "np", ".", "pi", ",", "13", ")", "\n", "x", "=", "np", ".", "cos", "(", "ph", ")", "\n", "y", "=", "np", ".", "sin", "(", "ph", ")", "\n", "u", "=", "np", ".", "cos", "(", "ph", ")", "\n", "v", "=", "np", ".", "sin", "(", "ph", ")", "\n", "colors", "=", "np", ".", "arctan2", "(", "u", ",", "v", ")", "\n", "\n", "norm", "=", "Normalize", "(", ")", "\n", "norm", ".", "autoscale", "(", "colors", ")", "\n", "# we need to normalize our colors array to match it colormap domain", "\n", "# which is [0, 1]", "\n", "\n", "colormap", "=", "cm", ".", "winter", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "6", ",", "6", ")", ")", "\n", "plt", ".", "xlim", "(", "-", "2", ",", "2", ")", "\n", "plt", ".", "ylim", "(", "-", "2", ",", "2", ")", "\n", "plt", ".", "quiver", "(", "x", ",", "y", ",", "u", ",", "v", ",", "color", "=", "colormap", "(", "norm", "(", "colors", ")", ")", ",", "angles", "=", "'xy'", ",", "scale_units", "=", "'xy'", ",", "scale", "=", "1", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.plot.flow": [[190, 300], ["len", "plot.slices.input_check"], "function", ["None"], ["", "def", "flow", "(", "slices_in", ",", "# the 2D slices", "\n", "titles", "=", "None", ",", "# list of titles", "\n", "cmaps", "=", "None", ",", "# list of colormaps", "\n", "width", "=", "15", ",", "# width in in", "\n", "img_indexing", "=", "True", ",", "# whether to match the image view, i.e. flip y axis", "\n", "grid", "=", "False", ",", "# option to plot the images in a grid or a single row", "\n", "show", "=", "True", ",", "# option to actually show the plot (plt.show())", "\n", "quiver_width", "=", "None", ",", "\n", "scale", "=", "1", ")", ":", "# note quiver essentially draws quiver length = 1/scale", "\n", "    ", "'''\n    plot a grid of flows (2d+2 images)\n    '''", "\n", "\n", "# input processing", "\n", "nb_plots", "=", "len", "(", "slices_in", ")", "\n", "for", "slice_in", "in", "slices_in", ":", "\n", "        ", "assert", "len", "(", "slice_in", ".", "shape", ")", "==", "3", ",", "'each slice has to be 3d: 2d+2 channels'", "\n", "assert", "slice_in", ".", "shape", "[", "-", "1", "]", "==", "2", ",", "'each slice has to be 3d: 2d+2 channels'", "\n", "\n", "", "def", "input_check", "(", "inputs", ",", "nb_plots", ",", "name", ")", ":", "\n", "        ", "''' change input from None/single-link '''", "\n", "if", "not", "isinstance", "(", "inputs", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "inputs", "=", "[", "inputs", "]", "\n", "", "assert", "(", "inputs", "is", "None", ")", "or", "(", "len", "(", "inputs", ")", "==", "nb_plots", ")", "or", "(", "len", "(", "inputs", ")", "==", "1", ")", ",", "'number of %s is incorrect'", "%", "name", "\n", "if", "inputs", "is", "None", ":", "\n", "            ", "inputs", "=", "[", "None", "]", "\n", "", "if", "len", "(", "inputs", ")", "==", "1", ":", "\n", "            ", "inputs", "=", "[", "inputs", "[", "0", "]", "for", "i", "in", "range", "(", "nb_plots", ")", "]", "\n", "", "return", "inputs", "\n", "\n", "", "if", "img_indexing", ":", "\n", "        ", "for", "si", ",", "slc", "in", "enumerate", "(", "slices_in", ")", ":", "\n", "            ", "slices_in", "[", "si", "]", "=", "np", ".", "flipud", "(", "slc", ")", "\n", "\n", "", "", "titles", "=", "input_check", "(", "titles", ",", "nb_plots", ",", "'titles'", ")", "\n", "cmaps", "=", "input_check", "(", "cmaps", ",", "nb_plots", ",", "'cmaps'", ")", "\n", "scale", "=", "input_check", "(", "scale", ",", "nb_plots", ",", "'scale'", ")", "\n", "\n", "# figure out the number of rows and columns", "\n", "if", "grid", ":", "\n", "        ", "if", "isinstance", "(", "grid", ",", "bool", ")", ":", "\n", "            ", "rows", "=", "np", ".", "floor", "(", "np", ".", "sqrt", "(", "nb_plots", ")", ")", ".", "astype", "(", "int", ")", "\n", "cols", "=", "np", ".", "ceil", "(", "nb_plots", "/", "rows", ")", ".", "astype", "(", "int", ")", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "grid", ",", "(", "list", ",", "tuple", ")", ")", ",", "\"grid should either be bool or [rows,cols]\"", "\n", "rows", ",", "cols", "=", "grid", "\n", "", "", "else", ":", "\n", "        ", "rows", "=", "1", "\n", "cols", "=", "nb_plots", "\n", "\n", "# prepare the subplot", "\n", "", "fig", ",", "axs", "=", "plt", ".", "subplots", "(", "rows", ",", "cols", ")", "\n", "if", "rows", "==", "1", "and", "cols", "==", "1", ":", "\n", "        ", "axs", "=", "[", "axs", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "nb_plots", ")", ":", "\n", "        ", "col", "=", "np", ".", "remainder", "(", "i", ",", "cols", ")", "\n", "row", "=", "np", ".", "floor", "(", "i", "/", "cols", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# get row and column axes", "\n", "row_axs", "=", "axs", "if", "rows", "==", "1", "else", "axs", "[", "row", "]", "\n", "ax", "=", "row_axs", "[", "col", "]", "\n", "\n", "# turn off axis", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "\n", "# add titles", "\n", "if", "titles", "is", "not", "None", "and", "titles", "[", "i", "]", "is", "not", "None", ":", "\n", "            ", "ax", ".", "title", ".", "set_text", "(", "titles", "[", "i", "]", ")", "\n", "\n", "", "u", ",", "v", "=", "slices_in", "[", "i", "]", "[", "...", ",", "0", "]", ",", "slices_in", "[", "i", "]", "[", "...", ",", "1", "]", "\n", "colors", "=", "np", ".", "arctan2", "(", "u", ",", "v", ")", "\n", "colors", "[", "np", ".", "isnan", "(", "colors", ")", "]", "=", "0", "\n", "norm", "=", "Normalize", "(", ")", "\n", "norm", ".", "autoscale", "(", "colors", ")", "\n", "if", "cmaps", "[", "i", "]", "is", "None", ":", "\n", "            ", "colormap", "=", "cm", ".", "winter", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"custom cmaps not currently implemented for plt.flow()\"", ")", "\n", "\n", "# show figure", "\n", "", "ax", ".", "quiver", "(", "u", ",", "v", ",", "\n", "color", "=", "colormap", "(", "norm", "(", "colors", ")", ".", "flatten", "(", ")", ")", ",", "\n", "angles", "=", "'xy'", ",", "\n", "units", "=", "'xy'", ",", "\n", "width", "=", "quiver_width", ",", "\n", "scale", "=", "scale", "[", "i", "]", ")", "\n", "ax", ".", "axis", "(", "'equal'", ")", "\n", "\n", "# clear axes that are unnecessary", "\n", "", "for", "i", "in", "range", "(", "nb_plots", ",", "col", "*", "row", ")", ":", "\n", "        ", "col", "=", "np", ".", "remainder", "(", "i", ",", "cols", ")", "\n", "row", "=", "np", ".", "floor", "(", "i", "/", "cols", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# get row and column axes", "\n", "row_axs", "=", "axs", "if", "rows", "==", "1", "else", "axs", "[", "row", "]", "\n", "ax", "=", "row_axs", "[", "col", "]", "\n", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "\n", "# show the plots", "\n", "", "fig", ".", "set_size_inches", "(", "width", ",", "rows", "/", "cols", "*", "width", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "if", "show", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n", "", "return", "(", "fig", ",", "axs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.plot.pca": [[302, 341], ["numpy.mean", "numpy.std", "matplotlib.figure", "matplotlib.subplot", "matplotlib.plot", "matplotlib.title", "matplotlib.subplot", "matplotlib.plot", "matplotlib.ylim", "matplotlib.grid", "matplotlib.title", "matplotlib.subplot", "matplotlib.plot", "matplotlib.ylim", "matplotlib.grid", "matplotlib.title", "matplotlib.subplot", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.title", "matplotlib.subplot", "matplotlib.hist", "matplotlib.title", "matplotlib.subplot", "matplotlib.imshow", "matplotlib.colorbar", "matplotlib.title", "matplotlib.show", "numpy.maximum", "numpy.cumsum", "numpy.cumsum", "numpy.transpose", "matplotlib.get_cmap", "numpy.finfo", "numpy.abs", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.grid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.grid"], ["", "def", "pca", "(", "pca", ",", "x", ",", "y", ")", ":", "\n", "    ", "x_mean", "=", "np", ".", "mean", "(", "x", ",", "0", ")", "\n", "x_std", "=", "np", ".", "std", "(", "x", ",", "0", ")", "\n", "\n", "W", "=", "pca", ".", "components_", "\n", "x_mu", "=", "W", "@", "pca", ".", "mean_", "# pca.mean_ is y_mean", "\n", "y_hat", "=", "x", "@", "W", "+", "pca", ".", "mean_", "\n", "\n", "y_err", "=", "y_hat", "-", "y", "\n", "y_rel_err", "=", "y_err", "/", "np", ".", "maximum", "(", "0.5", "*", "(", "np", ".", "abs", "(", "y", ")", "+", "np", ".", "abs", "(", "y_hat", ")", ")", ",", "np", ".", "finfo", "(", "'float'", ")", ".", "eps", ")", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "7", ")", ")", "\n", "plt", ".", "subplot", "(", "2", ",", "3", ",", "1", ")", "\n", "plt", ".", "plot", "(", "pca", ".", "explained_variance_ratio_", ")", "\n", "plt", ".", "title", "(", "'var %% explained'", ")", "\n", "plt", ".", "subplot", "(", "2", ",", "3", ",", "2", ")", "\n", "plt", ".", "plot", "(", "np", ".", "cumsum", "(", "pca", ".", "explained_variance_ratio_", ")", ")", "\n", "plt", ".", "ylim", "(", "[", "0", ",", "1.01", "]", ")", "\n", "plt", ".", "grid", "(", ")", "\n", "plt", ".", "title", "(", "'cumvar explained'", ")", "\n", "plt", ".", "subplot", "(", "2", ",", "3", ",", "3", ")", "\n", "plt", ".", "plot", "(", "np", ".", "cumsum", "(", "pca", ".", "explained_variance_ratio_", ")", ")", "\n", "plt", ".", "ylim", "(", "[", "0.8", ",", "1.01", "]", ")", "\n", "plt", ".", "grid", "(", ")", "\n", "plt", ".", "title", "(", "'cumvar explained'", ")", "\n", "\n", "plt", ".", "subplot", "(", "2", ",", "3", ",", "4", ")", "\n", "plt", ".", "plot", "(", "x_mean", ")", "\n", "plt", ".", "plot", "(", "x_mean", "+", "x_std", ",", "'k'", ")", "\n", "plt", ".", "plot", "(", "x_mean", "-", "x_std", ",", "'k'", ")", "\n", "plt", ".", "title", "(", "'x mean across dims (sorted)'", ")", "\n", "plt", ".", "subplot", "(", "2", ",", "3", ",", "5", ")", "\n", "plt", ".", "hist", "(", "y_rel_err", ".", "flat", ",", "100", ")", "\n", "plt", ".", "title", "(", "'y rel err histogram'", ")", "\n", "plt", ".", "subplot", "(", "2", ",", "3", ",", "6", ")", "\n", "plt", ".", "imshow", "(", "W", "@", "np", ".", "transpose", "(", "W", ")", ",", "cmap", "=", "plt", ".", "get_cmap", "(", "'gray'", ")", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "plt", ".", "title", "(", "'W * W\\''", ")", "\n", "plt", ".", "show", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.get_backend": [[18, 24], ["os.environ.get"], "function", ["None"], ["\n", "return", "'pytorch'", "if", "os", ".", "environ", ".", "get", "(", "'NEURITE_BACKEND'", ")", "==", "'pytorch'", "else", "'tensorflow'", "\n", "\n", "\n", "", "def", "softmax", "(", "x", ",", "axis", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.softmax": [[22, 28], ["numpy.exp", "numpy.sum", "numpy.exp"], "function", ["None"], ["", "def", "softmax", "(", "x", ",", "axis", ")", ":", "\n", "    ", "\"\"\"\n    softmax of a numpy array along a given dimension\n    \"\"\"", "\n", "\n", "return", "np", ".", "exp", "(", "x", ")", "/", "np", ".", "sum", "(", "np", ".", "exp", "(", "x", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.default_unet_features": [[10, 16], ["None"], "function", ["None"], ["\n", "# local (our) imports", "\n", "\n", "\n", "def", "get_backend", "(", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.load_volfile": [[26, 76], ["filename.endswith", "nib.load", "nib.load.get_data().squeeze", "filename.endswith", "utils.pad", "utils.resize", "numpy.load", "filename.endswith", "nib.load.get_data", "numpy.load", "ValueError", "next", "len", "iter", "np.load.keys", "np.load.values"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.resize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], ["\n", "return", "np", ".", "exp", "(", "x", ")", "/", "np", ".", "sum", "(", "np", ".", "exp", "(", "x", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.save_volfile": [[78, 102], ["filename.endswith", "nib.save", "filename.endswith", "numpy.array", "numpy.append", "nib.Nifti1Image", "numpy.savez_compressed", "ValueError", "numpy.array", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.load_pheno_csv": [[104, 135], ["open", "csv.reader", "next", "list", "numpy.array", "list.keys", "float", "os.path.basename", "pheno.keys", "os.path.basename"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad": [[137, 150], ["numpy.zeros", "tuple", "tuple", "int", "zip", "slice", "zip"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.resize": [[152, 161], ["scipy.ndimage.interpolation.zoom"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.dice": [[163, 174], ["numpy.zeros", "enumerate", "len", "numpy.maximum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.logical_and", "numpy.finfo"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.affine_shift_to_matrix": [[176, 184], ["numpy.concatenate", "numpy.eye", "trf.reshape", "numpy.zeros"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.extract_largest_vol": [[186, 197], ["skimage.measure.label", "skimage.measure.regionprops", "bw.astype", "numpy.argsort"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.clean_seg": [[199, 216], ["utils.extract_largest_vol", "scipy.ndimage.gaussian_filter", "numpy.isclose", "clean_bw.astype", "utils.extract_largest_vol", "extract_largest_vol.astype", "numpy.sort", "extract_largest_vol.sum", "clean_bw.sum", "scipy.ndimage.gaussian_filter.flatten", "numpy.ceil().astype", "numpy.ceil", "extract_largest_vol.sum"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.extract_largest_vol", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.extract_largest_vol", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.clean_seg_batch": [[218, 230], ["numpy.zeros", "enumerate", "X_label.astype.astype", "utils.clean_seg"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.clean_seg"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.filter_labels": [[232, 240], ["numpy.zeros", "numpy.logical_or"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.dist_trf": [[242, 248], ["numpy.logical_not", "scipy.ndimage.morphology.distance_transform_edt"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.signed_dist_trf": [[250, 269], ["utils.dist_trf", "numpy.logical_not", "utils.dist_trf"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.dist_trf", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.dist_trf"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.vol_to_sdt": [[271, 288], ["utils.signed_dist_trf", "any", "numpy.abs", "isinstance", "scipy.ndimage.interpolation.zoom"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.signed_dist_trf"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.vol_to_sdt_batch": [[290, 301], ["utils.vol_to_sdt", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.vol_to_sdt", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.get_surface_pts_per_label": [[303, 310], ["numpy.round().astype", "int", "numpy.round", "numpy.sum", "numpy.array"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.edge_to_surface_pts": [[312, 326], ["numpy.stack().transpose", "numpy.random.choice", "numpy.stack", "range", "numpy.where"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.sdt_to_surface_pts": [[328, 346], ["utils.edge_to_surface_pts", "numpy.stack", "scipy.ndimage.interpolation.zoom", "resize_fn", "numpy.array_equal", "numpy.abs", "numpy.array", "range"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.edge_to_surface_pts", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.dilation_net": [[31, 72], ["models.unet"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.unet"], ["def", "dilation_net", "(", "nb_features", ",", "\n", "input_shape", ",", "# input layer shape, vector of size ndims + 1(nb_channels)", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "name", "=", "'dilation_net'", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "use_logp", "=", "True", ",", "\n", "padding", "=", "'same'", ",", "\n", "dilation_rate_mult", "=", "1", ",", "\n", "activation", "=", "'elu'", ",", "\n", "use_residuals", "=", "False", ",", "\n", "final_pred_activation", "=", "'softmax'", ",", "\n", "nb_conv_per_level", "=", "1", ",", "\n", "add_prior_layer", "=", "False", ",", "\n", "add_prior_layer_reg", "=", "0", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "batch_norm", "=", "None", ")", ":", "\n", "\n", "    ", "return", "unet", "(", "nb_features", ",", "\n", "input_shape", ",", "# input layer shape, vector of size ndims + 1(nb_channels)", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "name", "=", "'unet'", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "use_logp", "=", "True", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation", "=", "'elu'", ",", "\n", "use_residuals", "=", "False", ",", "\n", "dilation_rate_mult", "=", "dilation_rate_mult", ",", "\n", "final_pred_activation", "=", "'softmax'", ",", "\n", "nb_conv_per_level", "=", "1", ",", "\n", "add_prior_layer", "=", "False", ",", "\n", "add_prior_layer_reg", "=", "0", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "batch_norm", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.unet": [[74, 195], ["isinstance", "models.conv_enc", "models.conv_dec", "len", "models.add_prior"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.conv_enc", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.conv_dec", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.add_prior"], ["", "def", "unet", "(", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "name", "=", "'unet'", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "use_logp", "=", "True", ",", "\n", "padding", "=", "'same'", ",", "\n", "dilation_rate_mult", "=", "1", ",", "\n", "activation", "=", "'elu'", ",", "\n", "use_residuals", "=", "False", ",", "\n", "final_pred_activation", "=", "'softmax'", ",", "\n", "nb_conv_per_level", "=", "1", ",", "\n", "add_prior_layer", "=", "False", ",", "\n", "add_prior_layer_reg", "=", "0", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "conv_dropout", "=", "0", ",", "\n", "batch_norm", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    unet-style keras model with an overdose of parametrization.\n\n    downsampling: \n\n    for U-net like architecture, we need to use Deconvolution3D.\n    However, this is not yet available (maybe soon, it's on a dev branch in github I believe)\n    Until then, we'll upsample and convolve.\n    TODO: Need to check that UpSampling3D actually does NN-upsampling!\n\n    Parameters:\n        nb_features: the number of features at each convolutional level\n            see below for `feat_mult` and `layer_nb_feats` for modifiers to this number\n        input_shape: input layer shape, vector of size ndims + 1 (nb_channels)\n        conv_size: the convolution kernel size\n        nb_levels: the number of Unet levels (number of downsamples) in the \"encoder\" \n            (e.g. 4 would give you 4 levels in encoder, 4 in decoder)\n        nb_labels: number of output channels\n        name (default: 'unet'): the name of the network\n        prefix (default: `name` value): prefix to be added to layer names\n        feat_mult (default: 1) multiple for `nb_features` as we go down the encoder levels.\n            e.g. feat_mult of 2 and nb_features of 16 would yield 32 features in the \n            second layer, 64 features in the third layer, etc\n        pool_size (default: 2): max pooling size (integer or list if specifying per dimension)\n        use_logp:\n        padding:\n        dilation_rate_mult:\n        activation:\n        use_residuals:\n        final_pred_activation:\n        nb_conv_per_level:\n        add_prior_layer:\n        add_prior_layer_reg:\n        layer_nb_feats:\n        conv_dropout:\n        batch_norm:\n    \"\"\"", "\n", "\n", "# naming", "\n", "model_name", "=", "name", "\n", "if", "prefix", "is", "None", ":", "\n", "        ", "prefix", "=", "model_name", "\n", "\n", "# volume size data", "\n", "", "ndims", "=", "len", "(", "input_shape", ")", "-", "1", "\n", "if", "isinstance", "(", "pool_size", ",", "int", ")", ":", "\n", "        ", "pool_size", "=", "(", "pool_size", ",", ")", "*", "ndims", "\n", "\n", "# get encoding model", "\n", "", "enc_model", "=", "conv_enc", "(", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "name", "=", "model_name", ",", "\n", "prefix", "=", "prefix", ",", "\n", "feat_mult", "=", "feat_mult", ",", "\n", "pool_size", "=", "pool_size", ",", "\n", "padding", "=", "padding", ",", "\n", "dilation_rate_mult", "=", "dilation_rate_mult", ",", "\n", "activation", "=", "activation", ",", "\n", "use_residuals", "=", "use_residuals", ",", "\n", "nb_conv_per_level", "=", "nb_conv_per_level", ",", "\n", "layer_nb_feats", "=", "layer_nb_feats", ",", "\n", "conv_dropout", "=", "conv_dropout", ",", "\n", "batch_norm", "=", "batch_norm", ")", "\n", "\n", "# get decoder", "\n", "# use_skip_connections=1 makes it a u-net", "\n", "lnf", "=", "layer_nb_feats", "[", "(", "nb_levels", "*", "nb_conv_per_level", ")", ":", "]", "if", "layer_nb_feats", "is", "not", "None", "else", "None", "\n", "dec_model", "=", "conv_dec", "(", "nb_features", ",", "\n", "None", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "name", "=", "model_name", ",", "\n", "prefix", "=", "prefix", ",", "\n", "feat_mult", "=", "feat_mult", ",", "\n", "pool_size", "=", "pool_size", ",", "\n", "use_skip_connections", "=", "1", ",", "\n", "padding", "=", "padding", ",", "\n", "dilation_rate_mult", "=", "dilation_rate_mult", ",", "\n", "activation", "=", "activation", ",", "\n", "use_residuals", "=", "use_residuals", ",", "\n", "final_pred_activation", "=", "'linear'", "if", "add_prior_layer", "else", "final_pred_activation", ",", "\n", "nb_conv_per_level", "=", "nb_conv_per_level", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "layer_nb_feats", "=", "lnf", ",", "\n", "conv_dropout", "=", "conv_dropout", ",", "\n", "input_model", "=", "enc_model", ")", "\n", "\n", "final_model", "=", "dec_model", "\n", "if", "add_prior_layer", ":", "\n", "        ", "final_model", "=", "add_prior", "(", "dec_model", ",", "\n", "[", "*", "input_shape", "[", ":", "-", "1", "]", ",", "nb_labels", "]", ",", "\n", "name", "=", "model_name", "+", "'_prior'", ",", "\n", "use_logp", "=", "use_logp", ",", "\n", "final_pred_activation", "=", "final_pred_activation", ",", "\n", "add_prior_layer_reg", "=", "add_prior_layer_reg", ")", "\n", "\n", "", "return", "final_model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.ae": [[197, 323], ["isinstance", "models.conv_enc", "models.single_ae", "models.conv_dec", "len", "models.add_prior", "conv_enc.output.shape.as_list", "single_ae.output.shape.as_list"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.conv_enc", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.single_ae", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.conv_dec", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.add_prior"], ["", "def", "ae", "(", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "enc_size", ",", "\n", "name", "=", "'ae'", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation", "=", "'elu'", ",", "\n", "use_residuals", "=", "False", ",", "\n", "nb_conv_per_level", "=", "1", ",", "\n", "batch_norm", "=", "None", ",", "\n", "enc_batch_norm", "=", "None", ",", "\n", "ae_type", "=", "'conv'", ",", "# 'dense', or 'conv'", "\n", "enc_lambda_layers", "=", "None", ",", "\n", "add_prior_layer", "=", "False", ",", "\n", "add_prior_layer_reg", "=", "0", ",", "\n", "use_logp", "=", "True", ",", "\n", "conv_dropout", "=", "0", ",", "\n", "include_mu_shift_layer", "=", "False", ",", "\n", "single_model", "=", "False", ",", "# whether to return a single model, or a tuple of models that can be stacked.", "\n", "final_pred_activation", "=", "'softmax'", ",", "\n", "src", "=", "None", ",", "\n", "src_input", "=", "None", ",", "\n", "do_vae", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Convolutional Auto-Encoder.\n    Optionally Variational.\n    Optionally Dense middle layer\n\n    \"Mostly\" in that the inner encoding can be (optionally) constructed via dense features.\n\n    Parameters:\n        do_vae (bool): whether to do a variational auto-encoder or not.\n\n    enc_lambda_layers functions to try:\n        K.softsign\n\n        a = 1\n        longtanh = lambda x: K.tanh(x) *  K.log(2 + a * abs(x))\n    \"\"\"", "\n", "\n", "# naming", "\n", "model_name", "=", "name", "\n", "\n", "# volume size data", "\n", "ndims", "=", "len", "(", "input_shape", ")", "-", "1", "\n", "if", "isinstance", "(", "pool_size", ",", "int", ")", ":", "\n", "        ", "pool_size", "=", "(", "pool_size", ",", ")", "*", "ndims", "\n", "\n", "# get encoding model", "\n", "", "enc_model", "=", "conv_enc", "(", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "name", "=", "model_name", ",", "\n", "feat_mult", "=", "feat_mult", ",", "\n", "pool_size", "=", "pool_size", ",", "\n", "padding", "=", "padding", ",", "\n", "activation", "=", "activation", ",", "\n", "use_residuals", "=", "use_residuals", ",", "\n", "nb_conv_per_level", "=", "nb_conv_per_level", ",", "\n", "conv_dropout", "=", "conv_dropout", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "src", "=", "src", ",", "\n", "src_input", "=", "src_input", ")", "\n", "\n", "# middle AE structure", "\n", "if", "single_model", ":", "\n", "        ", "in_input_shape", "=", "None", "\n", "in_model", "=", "enc_model", "\n", "", "else", ":", "\n", "        ", "in_input_shape", "=", "enc_model", ".", "output", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "]", "\n", "in_model", "=", "None", "\n", "", "mid_ae_model", "=", "single_ae", "(", "enc_size", ",", "\n", "in_input_shape", ",", "\n", "conv_size", "=", "conv_size", ",", "\n", "name", "=", "model_name", ",", "\n", "ae_type", "=", "ae_type", ",", "\n", "input_model", "=", "in_model", ",", "\n", "batch_norm", "=", "enc_batch_norm", ",", "\n", "enc_lambda_layers", "=", "enc_lambda_layers", ",", "\n", "include_mu_shift_layer", "=", "include_mu_shift_layer", ",", "\n", "do_vae", "=", "do_vae", ")", "\n", "\n", "# decoder", "\n", "if", "single_model", ":", "\n", "        ", "in_input_shape", "=", "None", "\n", "in_model", "=", "mid_ae_model", "\n", "", "else", ":", "\n", "        ", "in_input_shape", "=", "mid_ae_model", ".", "output", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "]", "\n", "in_model", "=", "None", "\n", "", "dec_model", "=", "conv_dec", "(", "nb_features", ",", "\n", "in_input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "name", "=", "model_name", ",", "\n", "feat_mult", "=", "feat_mult", ",", "\n", "pool_size", "=", "pool_size", ",", "\n", "use_skip_connections", "=", "False", ",", "\n", "padding", "=", "padding", ",", "\n", "activation", "=", "activation", ",", "\n", "use_residuals", "=", "use_residuals", ",", "\n", "final_pred_activation", "=", "final_pred_activation", ",", "\n", "nb_conv_per_level", "=", "nb_conv_per_level", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "conv_dropout", "=", "conv_dropout", ",", "\n", "input_model", "=", "in_model", ")", "\n", "\n", "if", "add_prior_layer", ":", "\n", "        ", "dec_model", "=", "add_prior", "(", "dec_model", ",", "\n", "[", "*", "input_shape", "[", ":", "-", "1", "]", ",", "nb_labels", "]", ",", "\n", "name", "=", "model_name", ",", "\n", "prefix", "=", "model_name", "+", "'_prior'", ",", "\n", "use_logp", "=", "use_logp", ",", "\n", "final_pred_activation", "=", "final_pred_activation", ",", "\n", "add_prior_layer_reg", "=", "add_prior_layer_reg", ")", "\n", "\n", "", "if", "single_model", ":", "\n", "        ", "return", "dec_model", "\n", "", "else", ":", "\n", "        ", "return", "(", "dec_model", ",", "mid_ae_model", ",", "enc_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.add_prior": [[325, 383], ["tensorflow.Input", "merge_op", "tensorflow.keras.models.Model", "print", "print", "tensorflow.Activation", "tensorflow.keras.activations.softmax", "tensorflow.Lambda", "tensorflow.Activation"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.softmax"], ["", "", "def", "add_prior", "(", "input_model", ",", "\n", "prior_shape", ",", "\n", "name", "=", "'prior_model'", ",", "\n", "prefix", "=", "None", ",", "\n", "use_logp", "=", "True", ",", "\n", "final_pred_activation", "=", "'softmax'", ",", "\n", "add_prior_layer_reg", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Append post-prior layer to a given model\n    \"\"\"", "\n", "\n", "# naming", "\n", "model_name", "=", "name", "\n", "if", "prefix", "is", "None", ":", "\n", "        ", "prefix", "=", "model_name", "\n", "\n", "# prior input layer", "\n", "", "prior_input_name", "=", "'%s-input'", "%", "prefix", "\n", "prior_tensor", "=", "KL", ".", "Input", "(", "shape", "=", "prior_shape", ",", "name", "=", "prior_input_name", ")", "\n", "prior_tensor_input", "=", "prior_tensor", "\n", "like_tensor", "=", "input_model", ".", "output", "\n", "\n", "# operation varies depending on whether we log() prior or not.", "\n", "if", "use_logp", ":", "\n", "# name = '%s-log' % prefix", "\n", "# prior_tensor = KL.Lambda(_log_layer_wrap(add_prior_layer_reg), name=name)(prior_tensor)", "\n", "        ", "print", "(", "\"Breaking change: use_logp option now requires log input!\"", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "merge_op", "=", "KL", ".", "add", "\n", "\n", "", "else", ":", "\n", "# using sigmoid to get the likelihood values between 0 and 1", "\n", "# note: they won't add up to 1.", "\n", "        ", "name", "=", "'%s_likelihood_sigmoid'", "%", "prefix", "\n", "like_tensor", "=", "KL", ".", "Activation", "(", "'sigmoid'", ",", "name", "=", "name", ")", "(", "like_tensor", ")", "\n", "merge_op", "=", "KL", ".", "multiply", "\n", "\n", "# merge the likelihood and prior layers into posterior layer", "\n", "", "name", "=", "'%s_posterior'", "%", "prefix", "\n", "post_tensor", "=", "merge_op", "(", "[", "prior_tensor", ",", "like_tensor", "]", ",", "name", "=", "name", ")", "\n", "\n", "# output prediction layer", "\n", "# we use a softmax to compute P(L_x|I) where x is each location", "\n", "pred_name", "=", "'%s_prediction'", "%", "prefix", "\n", "if", "final_pred_activation", "==", "'softmax'", ":", "\n", "        ", "assert", "use_logp", ",", "'cannot do softmax when adding prior via P()'", "\n", "print", "(", "\"using final_pred_activation %s for %s\"", "%", "(", "final_pred_activation", ",", "model_name", ")", ")", "\n", "softmax_lambda_fcn", "=", "lambda", "x", ":", "tf", ".", "keras", ".", "activations", ".", "softmax", "(", "x", ",", "axis", "=", "-", "1", ")", "\n", "pred_tensor", "=", "KL", ".", "Lambda", "(", "softmax_lambda_fcn", ",", "name", "=", "pred_name", ")", "(", "post_tensor", ")", "\n", "\n", "", "else", ":", "\n", "        ", "pred_tensor", "=", "KL", ".", "Activation", "(", "'linear'", ",", "name", "=", "pred_name", ")", "(", "post_tensor", ")", "\n", "\n", "# create the model", "\n", "", "model_inputs", "=", "[", "*", "input_model", ".", "inputs", ",", "prior_tensor_input", "]", "\n", "model", "=", "Model", "(", "inputs", "=", "model_inputs", ",", "outputs", "=", "[", "pred_tensor", "]", ",", "name", "=", "model_name", ")", "\n", "\n", "# compile", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.single_ae": [[385, 592], ["tensorflow.keras.models.Model", "tensorflow.Input", "last_tensor.shape.as_list", "getattr", "tensorflow.Lambda", "last_tensor.shape.as_list", "len", "len", "tensorflow.Flatten", "len", "tensorflow.Dense", "len", "len", "all", "all", "layers.LocalBias", "tensorflow.Lambda", "tensorflow.BatchNormalization", "tensorflow.Lambda", "layers.SampleNormalLogVar", "layers.LocalBias", "tensorflow.Dense", "len", "all", "all", "getattr.", "tensorflow.BatchNormalization", "len", "len", "getattr.", "layers.Resize", "tensorflow.Dense", "all", "all", "tensorflow.Lambda", "tensorflow.BatchNormalization", "numpy.prod", "tensorflow.Reshape", "layers.Resize", "list", "list", "range", "tensorflow.Lambda", "getattr.", "getattr.", "layers.Resize", "list", "list", "range", "list", "list", "range", "getattr.", "getattr.", "last_tensor.shape.as_list", "len", "len", "last_tensor.shape.as_list", "len", "pre_enc_layer.shape.as_list"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "single_ae", "(", "enc_size", ",", "\n", "input_shape", ",", "\n", "name", "=", "'single_ae'", ",", "\n", "prefix", "=", "None", ",", "\n", "ae_type", "=", "'dense'", ",", "# 'dense', or 'conv'", "\n", "conv_size", "=", "None", ",", "\n", "input_model", "=", "None", ",", "\n", "enc_lambda_layers", "=", "None", ",", "\n", "batch_norm", "=", "True", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation", "=", "None", ",", "\n", "include_mu_shift_layer", "=", "False", ",", "\n", "do_vae", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    single-layer Autoencoder (i.e. input - encoding - output)\n    \"\"\"", "\n", "\n", "# naming", "\n", "model_name", "=", "name", "\n", "if", "prefix", "is", "None", ":", "\n", "        ", "prefix", "=", "model_name", "\n", "\n", "", "if", "enc_lambda_layers", "is", "None", ":", "\n", "        ", "enc_lambda_layers", "=", "[", "]", "\n", "\n", "# prepare input", "\n", "", "input_name", "=", "'%s_input'", "%", "prefix", "\n", "if", "input_model", "is", "None", ":", "\n", "        ", "assert", "input_shape", "is", "not", "None", ",", "'input_shape of input_model is necessary'", "\n", "input_tensor", "=", "KL", ".", "Input", "(", "shape", "=", "input_shape", ",", "name", "=", "input_name", ")", "\n", "last_tensor", "=", "input_tensor", "\n", "", "else", ":", "\n", "        ", "input_tensor", "=", "input_model", ".", "input", "\n", "last_tensor", "=", "input_model", ".", "output", "\n", "input_shape", "=", "last_tensor", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "]", "\n", "", "input_nb_feats", "=", "last_tensor", ".", "shape", ".", "as_list", "(", ")", "[", "-", "1", "]", "\n", "\n", "# prepare conv type based on input", "\n", "if", "ae_type", "==", "'conv'", ":", "\n", "        ", "ndims", "=", "len", "(", "input_shape", ")", "-", "1", "\n", "convL", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "assert", "conv_size", "is", "not", "None", ",", "'with conv ae, need conv_size'", "\n", "", "conv_kwargs", "=", "{", "'padding'", ":", "padding", ",", "'activation'", ":", "activation", "}", "\n", "\n", "\n", "\n", "# if want to go through a dense layer in the middle of the U, need to:", "\n", "# - flatten last layer if not flat", "\n", "# - do dense encoding and decoding", "\n", "# - unflatten (rehsape spatially) at end", "\n", "if", "ae_type", "==", "'dense'", "and", "len", "(", "input_shape", ")", ">", "1", ":", "\n", "        ", "name", "=", "'%s_ae_%s_down_flat'", "%", "(", "prefix", ",", "ae_type", ")", "\n", "last_tensor", "=", "KL", ".", "Flatten", "(", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# recall this layer", "\n", "", "pre_enc_layer", "=", "last_tensor", "\n", "\n", "# encoding layer", "\n", "if", "ae_type", "==", "'dense'", ":", "\n", "        ", "assert", "len", "(", "enc_size", ")", "==", "1", ",", "\"enc_size should be of length 1 for dense layer\"", "\n", "\n", "enc_size_str", "=", "''", ".", "join", "(", "[", "'%d_'", "%", "d", "for", "d", "in", "enc_size", "]", ")", "[", ":", "-", "1", "]", "\n", "name", "=", "'%s_ae_mu_enc_dense_%s'", "%", "(", "prefix", ",", "enc_size_str", ")", "\n", "last_tensor", "=", "KL", ".", "Dense", "(", "enc_size", "[", "0", "]", ",", "name", "=", "name", ")", "(", "pre_enc_layer", ")", "\n", "\n", "", "else", ":", "# convolution", "\n", "# convolve then resize. enc_size should be [nb_dim1, nb_dim2, ..., nb_feats]", "\n", "        ", "assert", "len", "(", "enc_size", ")", "==", "len", "(", "input_shape", ")", ",", "\"encoding size does not match input shape %d %d\"", "%", "(", "len", "(", "enc_size", ")", ",", "len", "(", "input_shape", ")", ")", "\n", "\n", "if", "list", "(", "enc_size", ")", "[", ":", "-", "1", "]", "!=", "list", "(", "input_shape", ")", "[", ":", "-", "1", "]", "and", "all", "(", "[", "f", "is", "not", "None", "for", "f", "in", "input_shape", "[", ":", "-", "1", "]", "]", ")", "and", "all", "(", "[", "f", "is", "not", "None", "for", "f", "in", "enc_size", "[", ":", "-", "1", "]", "]", ")", ":", "\n", "\n", "# assert len(enc_size) - 1 == 2, \"Sorry, I have not yet implemented non-2D resizing -- need to check out interpn!\"", "\n", "            ", "name", "=", "'%s_ae_mu_enc_conv'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "convL", "(", "enc_size", "[", "-", "1", "]", ",", "conv_size", ",", "name", "=", "name", ",", "**", "conv_kwargs", ")", "(", "pre_enc_layer", ")", "\n", "\n", "name", "=", "'%s_ae_mu_enc'", "%", "(", "prefix", ")", "\n", "zf", "=", "[", "enc_size", "[", ":", "-", "1", "]", "[", "f", "]", "/", "last_tensor", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "-", "1", "]", "[", "f", "]", "for", "f", "in", "range", "(", "len", "(", "enc_size", ")", "-", "1", ")", "]", "\n", "last_tensor", "=", "layers", ".", "Resize", "(", "zoom_factor", "=", "zf", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "# resize_fn = lambda x: tf.image.resize_bilinear(x, enc_size[:-1])", "\n", "# last_tensor = KL.Lambda(resize_fn, name=name)(last_tensor)", "\n", "\n", "", "elif", "enc_size", "[", "-", "1", "]", "is", "None", ":", "# convolutional, but won't tell us bottleneck", "\n", "            ", "name", "=", "'%s_ae_mu_enc'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", ",", "name", "=", "name", ")", "(", "pre_enc_layer", ")", "\n", "\n", "", "else", ":", "\n", "            ", "name", "=", "'%s_ae_mu_enc'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "convL", "(", "enc_size", "[", "-", "1", "]", ",", "conv_size", ",", "name", "=", "name", ",", "**", "conv_kwargs", ")", "(", "pre_enc_layer", ")", "\n", "\n", "", "", "if", "include_mu_shift_layer", ":", "\n", "# shift", "\n", "        ", "name", "=", "'%s_ae_mu_shift'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "layers", ".", "LocalBias", "(", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# encoding clean-up layers", "\n", "", "for", "layer_fcn", "in", "enc_lambda_layers", ":", "\n", "        ", "lambda_name", "=", "layer_fcn", ".", "__name__", "\n", "name", "=", "'%s_ae_mu_%s'", "%", "(", "prefix", ",", "lambda_name", ")", "\n", "last_tensor", "=", "KL", ".", "Lambda", "(", "layer_fcn", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "batch_norm", "is", "not", "None", ":", "\n", "        ", "name", "=", "'%s_ae_mu_bn'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "KL", ".", "BatchNormalization", "(", "axis", "=", "batch_norm", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# have a simple layer that does nothing to have a clear name before sampling", "\n", "", "name", "=", "'%s_ae_mu'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "\n", "# if doing variational AE, will need the sigma layer as well.", "\n", "if", "do_vae", ":", "\n", "        ", "mu_tensor", "=", "last_tensor", "\n", "\n", "# encoding layer", "\n", "if", "ae_type", "==", "'dense'", ":", "\n", "            ", "name", "=", "'%s_ae_sigma_enc_dense_%s'", "%", "(", "prefix", ",", "enc_size_str", ")", "\n", "last_tensor", "=", "KL", ".", "Dense", "(", "enc_size", "[", "0", "]", ",", "name", "=", "name", ",", "\n", "#    kernel_initializer=tf.keras.initializers.RandomNormal(mean=0.0, stddev=1e-5),", "\n", "#    bias_initializer=tf.keras.initializers.RandomNormal(mean=-5.0, stddev=1e-5)", "\n", ")", "(", "pre_enc_layer", ")", "\n", "\n", "", "else", ":", "\n", "            ", "if", "list", "(", "enc_size", ")", "[", ":", "-", "1", "]", "!=", "list", "(", "input_shape", ")", "[", ":", "-", "1", "]", "and", "all", "(", "[", "f", "is", "not", "None", "for", "f", "in", "input_shape", "[", ":", "-", "1", "]", "]", ")", "and", "all", "(", "[", "f", "is", "not", "None", "for", "f", "in", "enc_size", "[", ":", "-", "1", "]", "]", ")", ":", "\n", "\n", "# assert len(enc_size) - 1 == 2, \"Sorry, I have not yet implemented non-2D resizing...\"", "\n", "                ", "name", "=", "'%s_ae_sigma_enc_conv'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "convL", "(", "enc_size", "[", "-", "1", "]", ",", "conv_size", ",", "name", "=", "name", ",", "**", "conv_kwargs", ")", "(", "pre_enc_layer", ")", "\n", "\n", "name", "=", "'%s_ae_sigma_enc'", "%", "(", "prefix", ")", "\n", "zf", "=", "[", "enc_size", "[", ":", "-", "1", "]", "[", "f", "]", "/", "last_tensor", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "-", "1", "]", "[", "f", "]", "for", "f", "in", "range", "(", "len", "(", "enc_size", ")", "-", "1", ")", "]", "\n", "last_tensor", "=", "layers", ".", "Resize", "(", "zoom_factor", "=", "zf", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "# resize_fn = lambda x: tf.image.resize_bilinear(x, enc_size[:-1])", "\n", "# last_tensor = KL.Lambda(resize_fn, name=name)(last_tensor)", "\n", "\n", "", "elif", "enc_size", "[", "-", "1", "]", "is", "None", ":", "# convolutional, but won't tell us bottleneck", "\n", "                ", "name", "=", "'%s_ae_sigma_enc'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "convL", "(", "pre_enc_layer", ".", "shape", ".", "as_list", "(", ")", "[", "-", "1", "]", ",", "conv_size", ",", "name", "=", "name", ",", "**", "conv_kwargs", ")", "(", "pre_enc_layer", ")", "\n", "# cannot use lambda, then mu and sigma will be same layer.", "\n", "# last_tensor = KL.Lambda(lambda x: x, name=name)(pre_enc_layer)", "\n", "\n", "", "else", ":", "\n", "                ", "name", "=", "'%s_ae_sigma_enc'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "convL", "(", "enc_size", "[", "-", "1", "]", ",", "conv_size", ",", "name", "=", "name", ",", "**", "conv_kwargs", ")", "(", "pre_enc_layer", ")", "\n", "\n", "# encoding clean-up layers", "\n", "", "", "for", "layer_fcn", "in", "enc_lambda_layers", ":", "\n", "            ", "lambda_name", "=", "layer_fcn", ".", "__name__", "\n", "name", "=", "'%s_ae_sigma_%s'", "%", "(", "prefix", ",", "lambda_name", ")", "\n", "last_tensor", "=", "KL", ".", "Lambda", "(", "layer_fcn", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "batch_norm", "is", "not", "None", ":", "\n", "            ", "name", "=", "'%s_ae_sigma_bn'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "KL", ".", "BatchNormalization", "(", "axis", "=", "batch_norm", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# have a simple layer that does nothing to have a clear name before sampling", "\n", "", "name", "=", "'%s_ae_sigma'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "logvar_tensor", "=", "last_tensor", "\n", "\n", "# VAE sampling ", "\n", "name", "=", "'%s_ae_sample'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "layers", ".", "SampleNormalLogVar", "(", "name", "=", "name", ")", "(", "[", "mu_tensor", ",", "logvar_tensor", "]", ")", "\n", "\n", "", "if", "include_mu_shift_layer", ":", "\n", "# shift", "\n", "        ", "name", "=", "'%s_ae_sample_shift'", "%", "(", "prefix", ")", "\n", "last_tensor", "=", "layers", ".", "LocalBias", "(", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# decoding layer", "\n", "", "if", "ae_type", "==", "'dense'", ":", "\n", "        ", "name", "=", "'%s_ae_%s_dec_flat_%s'", "%", "(", "prefix", ",", "ae_type", ",", "enc_size_str", ")", "\n", "last_tensor", "=", "KL", ".", "Dense", "(", "np", ".", "prod", "(", "input_shape", ")", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# unflatten if dense method", "\n", "if", "len", "(", "input_shape", ")", ">", "1", ":", "\n", "            ", "name", "=", "'%s_ae_%s_dec'", "%", "(", "prefix", ",", "ae_type", ")", "\n", "last_tensor", "=", "KL", ".", "Reshape", "(", "input_shape", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "", "", "else", ":", "\n", "\n", "        ", "if", "list", "(", "enc_size", ")", "[", ":", "-", "1", "]", "!=", "list", "(", "input_shape", ")", "[", ":", "-", "1", "]", "and", "all", "(", "[", "f", "is", "not", "None", "for", "f", "in", "input_shape", "[", ":", "-", "1", "]", "]", ")", "and", "all", "(", "[", "f", "is", "not", "None", "for", "f", "in", "enc_size", "[", ":", "-", "1", "]", "]", ")", ":", "\n", "\n", "            ", "name", "=", "'%s_ae_mu_dec'", "%", "(", "prefix", ")", "\n", "zf", "=", "[", "input_shape", "[", ":", "-", "1", "]", "[", "f", "]", "/", "enc_size", "[", ":", "-", "1", "]", "[", "f", "]", "for", "f", "in", "range", "(", "len", "(", "enc_size", ")", "-", "1", ")", "]", "\n", "last_tensor", "=", "layers", ".", "Resize", "(", "zoom_factor", "=", "zf", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "# resize_fn = lambda x: tf.image.resize_bilinear(x, input_shape[:-1])", "\n", "# last_tensor = KL.Lambda(resize_fn, name=name)(last_tensor)", "\n", "\n", "", "name", "=", "'%s_ae_%s_dec'", "%", "(", "prefix", ",", "ae_type", ")", "\n", "last_tensor", "=", "convL", "(", "input_nb_feats", ",", "conv_size", ",", "name", "=", "name", ",", "**", "conv_kwargs", ")", "(", "last_tensor", ")", "\n", "\n", "\n", "", "if", "batch_norm", "is", "not", "None", ":", "\n", "        ", "name", "=", "'%s_bn_ae_%s_dec'", "%", "(", "prefix", ",", "ae_type", ")", "\n", "last_tensor", "=", "KL", ".", "BatchNormalization", "(", "axis", "=", "batch_norm", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# create the model and retun", "\n", "", "model", "=", "Model", "(", "inputs", "=", "input_tensor", ",", "outputs", "=", "[", "last_tensor", "]", ",", "name", "=", "model_name", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.conv_enc": [[601, 723], ["tuple", "isinstance", "getattr", "range", "tensorflow.keras.models.Model", "len", "getattr", "tensorflow.Input", "numpy.round().astype", "range", "tensorflow.add", "numpy.round", "tensorflow.__version__.split", "int", "int", "lvl_first_tensor.get_shape", "convarm_layer.get_shape", "tensorflow.Activation", "tensorflow.BatchNormalization", "getattr.", "getattr.", "getattr.", "tensorflow.Dropout", "getattr.", "tensorflow.__version__.split", "int", "int", "tensorflow.Dropout"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "conv_enc", "(", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "name", "=", "None", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "dilation_rate_mult", "=", "1", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation", "=", "'elu'", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "use_residuals", "=", "False", ",", "\n", "nb_conv_per_level", "=", "2", ",", "\n", "conv_dropout", "=", "0", ",", "\n", "batch_norm", "=", "None", ",", "\n", "convL", "=", "None", ",", "# conv layer function", "\n", "src", "=", "None", ",", "\n", "src_input", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Fully Convolutional Encoder\n    \"\"\"", "\n", "\n", "# naming", "\n", "model_name", "=", "name", "\n", "if", "prefix", "is", "None", ":", "\n", "        ", "prefix", "=", "model_name", "\n", "\n", "# volume size data", "\n", "", "ndims", "=", "len", "(", "input_shape", ")", "-", "1", "\n", "input_shape", "=", "tuple", "(", "input_shape", ")", "\n", "if", "isinstance", "(", "pool_size", ",", "int", ")", ":", "\n", "        ", "pool_size", "=", "(", "pool_size", ",", ")", "*", "ndims", "\n", "\n", "# prepare layers", "\n", "", "if", "convL", "is", "None", ":", "\n", "        ", "convL", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "", "conv_kwargs", "=", "{", "'padding'", ":", "padding", ",", "'activation'", ":", "activation", "}", "\n", "maxpool", "=", "getattr", "(", "KL", ",", "'MaxPooling%dD'", "%", "ndims", ")", "\n", "\n", "# first layer: input", "\n", "if", "src", "is", "None", ":", "\n", "        ", "name", "=", "'%s_input'", "%", "prefix", "\n", "last_tensor", "=", "KL", ".", "Input", "(", "shape", "=", "input_shape", ",", "name", "=", "name", ")", "\n", "input_tensor", "=", "last_tensor", "\n", "", "else", ":", "\n", "        ", "assert", "src_input", "is", "not", "None", ",", "'need to provide src_input if given src'", "\n", "input_tensor", "=", "src_input", "\n", "last_tensor", "=", "src", "\n", "\n", "\n", "# down arm:", "\n", "# add nb_levels of conv + ReLu + conv + ReLu. Pool after each of first nb_levels - 1 layers", "\n", "", "lfidx", "=", "0", "\n", "for", "level", "in", "range", "(", "nb_levels", ")", ":", "\n", "        ", "lvl_first_tensor", "=", "last_tensor", "\n", "nb_lvl_feats", "=", "np", ".", "round", "(", "nb_features", "*", "feat_mult", "**", "level", ")", ".", "astype", "(", "int", ")", "\n", "conv_kwargs", "[", "'dilation_rate'", "]", "=", "dilation_rate_mult", "**", "level", "\n", "\n", "for", "conv", "in", "range", "(", "nb_conv_per_level", ")", ":", "\n", "            ", "if", "layer_nb_feats", "is", "not", "None", ":", "\n", "                ", "nb_lvl_feats", "=", "layer_nb_feats", "[", "lfidx", "]", "\n", "lfidx", "+=", "1", "\n", "\n", "", "name", "=", "'%s_conv_downarm_%d_%d'", "%", "(", "prefix", ",", "level", ",", "conv", ")", "\n", "if", "conv", "<", "(", "nb_conv_per_level", "-", "1", ")", "or", "(", "not", "use_residuals", ")", ":", "\n", "                ", "last_tensor", "=", "convL", "(", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "# no activation", "\n", "                ", "last_tensor", "=", "convL", "(", "nb_lvl_feats", ",", "conv_size", ",", "padding", "=", "padding", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "conv_dropout", ">", "0", ":", "\n", "# conv dropout along feature space only", "\n", "                ", "name", "=", "'%s_dropout_downarm_%d_%d'", "%", "(", "prefix", ",", "level", ",", "conv", ")", "\n", "noise_shape", "=", "[", "None", ",", "*", "[", "1", "]", "*", "ndims", ",", "nb_lvl_feats", "]", "\n", "versions", "=", "tf", ".", "__version__", ".", "split", "(", "'.'", ")", "\n", "ver", "=", "int", "(", "versions", "[", "0", "]", ")", "\n", "rev", "=", "int", "(", "versions", "[", "1", "]", ")", "\n", "if", "ver", "<", "2", "or", "(", "ver", "==", "2", "and", "rev", "<", "2", ")", ":", "# < 2.2", "\n", "                    ", "noise_shape", "=", "None", "\n", "", "last_tensor", "=", "KL", ".", "Dropout", "(", "conv_dropout", ",", "noise_shape", "=", "noise_shape", ")", "(", "last_tensor", ")", "\n", "\n", "", "", "if", "use_residuals", ":", "\n", "            ", "convarm_layer", "=", "last_tensor", "\n", "\n", "# the \"add\" layer is the original input", "\n", "# However, it may not have the right number of features to be added", "\n", "nb_feats_in", "=", "lvl_first_tensor", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "nb_feats_out", "=", "convarm_layer", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "add_layer", "=", "lvl_first_tensor", "\n", "if", "nb_feats_in", ">", "1", "and", "nb_feats_out", ">", "1", "and", "(", "nb_feats_in", "!=", "nb_feats_out", ")", ":", "\n", "                ", "name", "=", "'%s_expand_down_merge_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "last_tensor", "=", "convL", "(", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ")", "(", "lvl_first_tensor", ")", "\n", "add_layer", "=", "last_tensor", "\n", "\n", "if", "conv_dropout", ">", "0", ":", "\n", "                    ", "name", "=", "'%s_dropout_down_merge_%d_%d'", "%", "(", "prefix", ",", "level", ",", "conv", ")", "\n", "noise_shape", "=", "[", "None", ",", "*", "[", "1", "]", "*", "ndims", ",", "nb_lvl_feats", "]", "\n", "versions", "=", "tf", ".", "__version__", ".", "split", "(", "'.'", ")", "\n", "ver", "=", "int", "(", "versions", "[", "0", "]", ")", "\n", "rev", "=", "int", "(", "versions", "[", "1", "]", ")", "\n", "if", "ver", "<", "2", "or", "(", "ver", "==", "2", "and", "rev", "<", "2", ")", ":", "# < 2.2", "\n", "                        ", "noise_shape", "=", "None", "\n", "", "last_tensor", "=", "KL", ".", "Dropout", "(", "conv_dropout", ",", "noise_shape", "=", "noise_shape", ")", "(", "last_tensor", ")", "\n", "\n", "", "", "name", "=", "'%s_res_down_merge_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "last_tensor", "=", "KL", ".", "add", "(", "[", "add_layer", ",", "convarm_layer", "]", ",", "name", "=", "name", ")", "\n", "\n", "name", "=", "'%s_res_down_merge_act_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "last_tensor", "=", "KL", ".", "Activation", "(", "activation", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "batch_norm", "is", "not", "None", ":", "\n", "            ", "name", "=", "'%s_bn_down_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "last_tensor", "=", "KL", ".", "BatchNormalization", "(", "axis", "=", "batch_norm", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# max pool if we're not at the last level", "\n", "", "if", "level", "<", "(", "nb_levels", "-", "1", ")", ":", "\n", "            ", "name", "=", "'%s_maxpool_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "last_tensor", "=", "maxpool", "(", "pool_size", "=", "pool_size", ",", "name", "=", "name", ",", "padding", "=", "padding", ")", "(", "last_tensor", ")", "\n", "\n", "# create the model and return", "\n", "", "", "model", "=", "Model", "(", "inputs", "=", "input_tensor", ",", "outputs", "=", "[", "last_tensor", "]", ",", "name", "=", "model_name", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.conv_dec": [[725, 884], ["tuple", "isinstance", "getattr", "range", "tensorflow.keras.models.Model", "tensorflow.Input", "len", "isinstance", "getattr", "numpy.round().astype", "range", "getattr.", "print", "KL.add.shape.as_list", "getattr.", "tensorflow.concatenate", "tensorflow.add", "tensorflow.keras.activations.softmax", "tensorflow.Lambda", "numpy.round", "input_model.get_layer", "tensorflow.__version__.split", "int", "int", "add_layer.get_shape", "KL.add.get_shape", "tensorflow.Activation", "tensorflow.BatchNormalization", "tensorflow.Activation", "tensorflow.Activation", "getattr.", "getattr.", "tensorflow.Dropout", "getattr.", "tensorflow.Dropout"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.softmax"], ["", "def", "conv_dec", "(", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "name", "=", "None", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "use_skip_connections", "=", "False", ",", "\n", "padding", "=", "'same'", ",", "\n", "dilation_rate_mult", "=", "1", ",", "\n", "activation", "=", "'elu'", ",", "\n", "use_residuals", "=", "False", ",", "\n", "final_pred_activation", "=", "'softmax'", ",", "\n", "nb_conv_per_level", "=", "2", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "batch_norm", "=", "None", ",", "\n", "conv_dropout", "=", "0", ",", "\n", "convL", "=", "None", ",", "\n", "input_model", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Fully Convolutional Decoder\n\n    Parameters:\n        ...\n        use_skip_connections (bool): if true, turns an Enc-Dec to a U-Net.\n            If true, input_tensor and tensors are required.\n            It assumes a particular naming of layers. conv_enc...\n    \"\"\"", "\n", "\n", "# naming", "\n", "model_name", "=", "name", "\n", "if", "prefix", "is", "None", ":", "\n", "        ", "prefix", "=", "model_name", "\n", "\n", "# if using skip connections, make sure need to use them.", "\n", "", "if", "use_skip_connections", ":", "\n", "        ", "assert", "input_model", "is", "not", "None", ",", "\"is using skip connections, tensors dictionary is required\"", "\n", "\n", "# first layer: input", "\n", "", "input_name", "=", "'%s_input'", "%", "prefix", "\n", "if", "input_model", "is", "None", ":", "\n", "        ", "input_tensor", "=", "KL", ".", "Input", "(", "shape", "=", "input_shape", ",", "name", "=", "input_name", ")", "\n", "last_tensor", "=", "input_tensor", "\n", "", "else", ":", "\n", "        ", "input_tensor", "=", "input_model", ".", "input", "\n", "last_tensor", "=", "input_model", ".", "output", "\n", "input_shape", "=", "last_tensor", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "]", "\n", "\n", "# vol size info", "\n", "", "ndims", "=", "len", "(", "input_shape", ")", "-", "1", "\n", "input_shape", "=", "tuple", "(", "input_shape", ")", "\n", "if", "isinstance", "(", "pool_size", ",", "int", ")", ":", "\n", "        ", "if", "ndims", ">", "1", ":", "\n", "            ", "pool_size", "=", "(", "pool_size", ",", ")", "*", "ndims", "\n", "", "", "if", "ndims", "==", "1", "and", "isinstance", "(", "pool_size", ",", "tuple", ")", ":", "\n", "        ", "pool_size", "=", "pool_size", "[", "0", "]", "# 1D upsampling takes int not tuple", "\n", "\n", "# prepare layers", "\n", "", "if", "convL", "is", "None", ":", "\n", "        ", "convL", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "", "conv_kwargs", "=", "{", "'padding'", ":", "padding", ",", "'activation'", ":", "activation", "}", "\n", "upsample", "=", "getattr", "(", "KL", ",", "'UpSampling%dD'", "%", "ndims", ")", "\n", "\n", "# up arm:", "\n", "# nb_levels - 1 layers of Deconvolution3D", "\n", "#    (approx via up + conv + ReLu) + merge + conv + ReLu + conv + ReLu", "\n", "lfidx", "=", "0", "\n", "for", "level", "in", "range", "(", "nb_levels", "-", "1", ")", ":", "\n", "        ", "nb_lvl_feats", "=", "np", ".", "round", "(", "nb_features", "*", "feat_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", ")", ".", "astype", "(", "int", ")", "\n", "conv_kwargs", "[", "'dilation_rate'", "]", "=", "dilation_rate_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", "\n", "\n", "# upsample matching the max pooling layers size", "\n", "name", "=", "'%s_up_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ")", "\n", "last_tensor", "=", "upsample", "(", "size", "=", "pool_size", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "up_tensor", "=", "last_tensor", "\n", "\n", "# merge layers combining previous layer", "\n", "# TODO: add Cropping3D or Cropping2D if 'valid' padding", "\n", "if", "use_skip_connections", ":", "\n", "            ", "conv_name", "=", "'%s_conv_downarm_%d_%d'", "%", "(", "prefix", ",", "nb_levels", "-", "2", "-", "level", ",", "nb_conv_per_level", "-", "1", ")", "\n", "cat_tensor", "=", "input_model", ".", "get_layer", "(", "conv_name", ")", ".", "output", "\n", "name", "=", "'%s_merge_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ")", "\n", "last_tensor", "=", "KL", ".", "concatenate", "(", "[", "cat_tensor", ",", "last_tensor", "]", ",", "axis", "=", "ndims", "+", "1", ",", "name", "=", "name", ")", "\n", "\n", "# convolution layers", "\n", "", "for", "conv", "in", "range", "(", "nb_conv_per_level", ")", ":", "\n", "            ", "if", "layer_nb_feats", "is", "not", "None", ":", "\n", "                ", "nb_lvl_feats", "=", "layer_nb_feats", "[", "lfidx", "]", "\n", "lfidx", "+=", "1", "\n", "\n", "", "name", "=", "'%s_conv_uparm_%d_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ",", "conv", ")", "\n", "if", "conv", "<", "(", "nb_conv_per_level", "-", "1", ")", "or", "(", "not", "use_residuals", ")", ":", "\n", "                ", "last_tensor", "=", "convL", "(", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "                ", "last_tensor", "=", "convL", "(", "nb_lvl_feats", ",", "conv_size", ",", "padding", "=", "padding", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "conv_dropout", ">", "0", ":", "\n", "                ", "name", "=", "'%s_dropout_uparm_%d_%d'", "%", "(", "prefix", ",", "level", ",", "conv", ")", "\n", "noise_shape", "=", "[", "None", ",", "*", "[", "1", "]", "*", "ndims", ",", "nb_lvl_feats", "]", "\n", "versions", "=", "tf", ".", "__version__", ".", "split", "(", "'.'", ")", "\n", "ver", "=", "int", "(", "versions", "[", "0", "]", ")", "\n", "rev", "=", "int", "(", "versions", "[", "1", "]", ")", "\n", "if", "ver", "<", "2", "or", "(", "ver", "==", "2", "and", "rev", "<", "2", ")", ":", "# < 2.2", "\n", "                    ", "noise_shape", "=", "None", "\n", "", "last_tensor", "=", "KL", ".", "Dropout", "(", "conv_dropout", ",", "noise_shape", "=", "noise_shape", ")", "(", "last_tensor", ")", "\n", "\n", "# residual block", "\n", "", "", "if", "use_residuals", ":", "\n", "\n", "# the \"add\" layer is the original input", "\n", "# However, it may not have the right number of features to be added", "\n", "            ", "add_layer", "=", "up_tensor", "\n", "nb_feats_in", "=", "add_layer", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "nb_feats_out", "=", "last_tensor", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "if", "nb_feats_in", ">", "1", "and", "nb_feats_out", ">", "1", "and", "(", "nb_feats_in", "!=", "nb_feats_out", ")", ":", "\n", "                ", "name", "=", "'%s_expand_up_merge_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "add_layer", "=", "convL", "(", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ")", "(", "add_layer", ")", "\n", "\n", "if", "conv_dropout", ">", "0", ":", "\n", "                    ", "name", "=", "'%s_dropout_up_merge_%d_%d'", "%", "(", "prefix", ",", "level", ",", "conv", ")", "\n", "noise_shape", "=", "[", "None", ",", "*", "[", "1", "]", "*", "ndims", ",", "nb_lvl_feats", "]", "\n", "last_tensor", "=", "KL", ".", "Dropout", "(", "conv_dropout", ",", "noise_shape", "=", "noise_shape", ")", "(", "last_tensor", ")", "\n", "\n", "", "", "name", "=", "'%s_res_up_merge_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "last_tensor", "=", "KL", ".", "add", "(", "[", "last_tensor", ",", "add_layer", "]", ",", "name", "=", "name", ")", "\n", "\n", "name", "=", "'%s_res_up_merge_act_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "last_tensor", "=", "KL", ".", "Activation", "(", "activation", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "batch_norm", "is", "not", "None", ":", "\n", "            ", "name", "=", "'%s_bn_up_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "last_tensor", "=", "KL", ".", "BatchNormalization", "(", "axis", "=", "batch_norm", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# Compute likelyhood prediction (no activation yet)", "\n", "", "", "name", "=", "'%s_likelihood'", "%", "prefix", "\n", "last_tensor", "=", "convL", "(", "nb_labels", ",", "1", ",", "activation", "=", "None", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "like_tensor", "=", "last_tensor", "\n", "\n", "# output prediction layer", "\n", "# we use a softmax to compute P(L_x|I) where x is each location", "\n", "if", "final_pred_activation", "==", "'softmax'", ":", "\n", "        ", "print", "(", "\"using final_pred_activation %s for %s\"", "%", "(", "final_pred_activation", ",", "model_name", ")", ")", "\n", "name", "=", "'%s_prediction'", "%", "prefix", "\n", "softmax_lambda_fcn", "=", "lambda", "x", ":", "tf", ".", "keras", ".", "activations", ".", "softmax", "(", "x", ",", "axis", "=", "ndims", "+", "1", ")", "\n", "pred_tensor", "=", "KL", ".", "Lambda", "(", "softmax_lambda_fcn", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "# otherwise create a layer that does nothing.", "\n", "", "else", ":", "\n", "        ", "name", "=", "'%s_prediction'", "%", "prefix", "\n", "if", "final_pred_activation", "is", "None", ":", "\n", "            ", "pred_tensor", "=", "KL", ".", "Activation", "(", "'linear'", ",", "name", "=", "name", ")", "(", "like_tensor", ")", "\n", "", "else", ":", "\n", "            ", "pred_tensor", "=", "KL", ".", "Activation", "(", "final_pred_activation", ",", "name", "=", "name", ")", "(", "like_tensor", ")", "\n", "\n", "# create the model and retun", "\n", "", "", "model", "=", "Model", "(", "inputs", "=", "input_tensor", ",", "outputs", "=", "pred_tensor", ",", "name", "=", "model_name", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.design_dnn": [[886, 1040], ["len", "tuple", "getattr", "isinstance", "tensorflow.Input", "range", "tensorflow.keras.models.Model", "tensorflow.batch_flatten", "tensorflow.max", "tensorflow.python.keras.constraints.maxnorm", "range", "len", "numpy.round().astype", "tensorflow.Flatten", "tensorflow.Dense", "getattr.", "getattr.", "maxpool", "tensorflow.Flatten", "tensorflow.Dense", "tensorflow.Activation", "tensorflow.Dropout", "numpy.round", "tensorflow.Flatten", "tensorflow.Dense", "tensorflow.BatchNormalization", "tensorflow.Lambda", "tensorflow.Reshape", "tensorflow.Conv1D", "tensorflow.Conv3D", "tensorflow.GlobalMaxPooling3D", "tensorflow.Activation"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "design_dnn", "(", "nb_features", ",", "input_shape", ",", "nb_levels", ",", "conv_size", ",", "nb_labels", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation", "=", "'elu'", ",", "\n", "final_layer", "=", "'dense-sigmoid'", ",", "\n", "conv_dropout", "=", "0", ",", "\n", "conv_maxnorm", "=", "0", ",", "\n", "nb_input_features", "=", "1", ",", "\n", "batch_norm", "=", "False", ",", "\n", "name", "=", "None", ",", "\n", "prefix", "=", "None", ",", "\n", "use_strided_convolution_maxpool", "=", "True", ",", "\n", "nb_conv_per_level", "=", "2", ")", ":", "\n", "    ", "\"\"\"\n    \"deep\" cnn with dense or global max pooling layer @ end...\n\n    Could use sequential...\n    \"\"\"", "\n", "\n", "\n", "def", "_global_max_nd", "(", "xtens", ")", ":", "\n", "        ", "ytens", "=", "K", ".", "batch_flatten", "(", "xtens", ")", "\n", "return", "K", ".", "max", "(", "ytens", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "\n", "\n", "", "model_name", "=", "name", "\n", "if", "model_name", "is", "None", ":", "\n", "        ", "model_name", "=", "'model_1'", "\n", "", "if", "prefix", "is", "None", ":", "\n", "        ", "prefix", "=", "model_name", "\n", "\n", "", "ndims", "=", "len", "(", "input_shape", ")", "\n", "input_shape", "=", "tuple", "(", "input_shape", ")", "\n", "\n", "convL", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "maxpool", "=", "KL", ".", "MaxPooling3D", "if", "len", "(", "input_shape", ")", "==", "3", "else", "KL", ".", "MaxPooling2D", "\n", "if", "isinstance", "(", "pool_size", ",", "int", ")", ":", "\n", "        ", "pool_size", "=", "(", "pool_size", ",", ")", "*", "ndims", "\n", "\n", "# kwargs for the convolution layer", "\n", "", "conv_kwargs", "=", "{", "'padding'", ":", "padding", ",", "'activation'", ":", "activation", "}", "\n", "if", "conv_maxnorm", ">", "0", ":", "\n", "        ", "conv_kwargs", "[", "'kernel_constraint'", "]", "=", "maxnorm", "(", "conv_maxnorm", ")", "\n", "\n", "# initialize a dictionary", "\n", "", "enc_tensors", "=", "{", "}", "\n", "\n", "# first layer: input", "\n", "name", "=", "'%s_input'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Input", "(", "shape", "=", "input_shape", "+", "(", "nb_input_features", ",", ")", ",", "name", "=", "name", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "# down arm:", "\n", "# add nb_levels of conv + ReLu + conv + ReLu. Pool after each of first nb_levels - 1 layers", "\n", "for", "level", "in", "range", "(", "nb_levels", ")", ":", "\n", "        ", "for", "conv", "in", "range", "(", "nb_conv_per_level", ")", ":", "\n", "            ", "if", "conv_dropout", ">", "0", ":", "\n", "                ", "name", "=", "'%s_dropout_%d_%d'", "%", "(", "prefix", ",", "level", ",", "conv", ")", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Dropout", "(", "conv_dropout", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "", "name", "=", "'%s_conv_%d_%d'", "%", "(", "prefix", ",", "level", ",", "conv", ")", "\n", "nb_lvl_feats", "=", "np", ".", "round", "(", "nb_features", "*", "feat_mult", "**", "level", ")", ".", "astype", "(", "int", ")", "\n", "enc_tensors", "[", "name", "]", "=", "convL", "(", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "# max pool", "\n", "", "if", "use_strided_convolution_maxpool", ":", "\n", "            ", "name", "=", "'%s_strided_conv_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "enc_tensors", "[", "name", "]", "=", "convL", "(", "nb_lvl_feats", ",", "pool_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "", "else", ":", "\n", "            ", "name", "=", "'%s_maxpool_%d'", "%", "(", "prefix", ",", "level", ")", "\n", "enc_tensors", "[", "name", "]", "=", "maxpool", "(", "pool_size", "=", "pool_size", ",", "name", "=", "name", ",", "padding", "=", "padding", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "# dense layer", "\n", "", "", "if", "final_layer", "==", "'dense-sigmoid'", ":", "\n", "\n", "        ", "name", "=", "\"%s_flatten\"", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Flatten", "(", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "name", "=", "'%s_dense'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Dense", "(", "1", ",", "name", "=", "name", ",", "activation", "=", "\"sigmoid\"", ")", "(", "last_tensor", ")", "\n", "\n", "", "elif", "final_layer", "==", "'dense-tanh'", ":", "\n", "\n", "        ", "name", "=", "\"%s_flatten\"", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Flatten", "(", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "name", "=", "'%s_dense'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Dense", "(", "1", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "# Omittting BatchNorm for now, it seems to have a cpu vs gpu problem", "\n", "# https://github.com/tensorflow/tensorflow/pull/8906", "\n", "# https://github.com/fchollet/keras/issues/5802", "\n", "# name = '%s_%s_bn' % prefix", "\n", "# enc_tensors[name] = KL.BatchNormalization(axis=batch_norm, name=name)(last_tensor)", "\n", "# last_tensor = enc_tensors[name]", "\n", "\n", "name", "=", "'%s_%s_tanh'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Activation", "(", "activation", "=", "\"tanh\"", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "", "elif", "final_layer", "==", "'dense-softmax'", ":", "\n", "\n", "        ", "name", "=", "\"%s_flatten\"", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Flatten", "(", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "name", "=", "'%s_dense'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Dense", "(", "nb_labels", ",", "name", "=", "name", ",", "activation", "=", "\"softmax\"", ")", "(", "last_tensor", ")", "\n", "\n", "# global max pooling layer", "\n", "", "elif", "final_layer", "==", "'myglobalmaxpooling'", ":", "\n", "\n", "        ", "name", "=", "'%s_batch_norm'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "BatchNormalization", "(", "axis", "=", "batch_norm", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "name", "=", "'%s_global_max_pool'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Lambda", "(", "_global_max_nd", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "name", "=", "'%s_global_max_pool_reshape'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Reshape", "(", "(", "1", ",", "1", ")", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "# cannot do activation in lambda layer. Could code inside, but will do extra lyaer", "\n", "name", "=", "'%s_global_max_pool_sigmoid'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Conv1D", "(", "1", ",", "1", ",", "name", "=", "name", ",", "activation", "=", "\"sigmoid\"", ",", "use_bias", "=", "True", ")", "(", "last_tensor", ")", "\n", "\n", "", "elif", "final_layer", "==", "'globalmaxpooling'", ":", "\n", "\n", "        ", "name", "=", "'%s_conv_to_featmaps'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Conv3D", "(", "2", ",", "1", ",", "name", "=", "name", ",", "activation", "=", "\"relu\"", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "name", "=", "'%s_global_max_pool'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "GlobalMaxPooling3D", "(", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "# cannot do activation in lambda layer. Could code inside, but will do extra lyaer", "\n", "name", "=", "'%s_global_max_pool_softmax'", "%", "prefix", "\n", "enc_tensors", "[", "name", "]", "=", "KL", ".", "Activation", "(", "'softmax'", ",", "name", "=", "name", ")", "(", "last_tensor", ")", "\n", "\n", "", "last_tensor", "=", "enc_tensors", "[", "name", "]", "\n", "\n", "# create the model", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "enc_tensors", "[", "'%s_input'", "%", "prefix", "]", "]", ",", "outputs", "=", "[", "last_tensor", "]", ",", "name", "=", "model_name", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.EncoderNet": [[1043, 1110], ["models.conv_enc", "tensorflow.keras.models.Model", "tensorflow.Flatten", "tensorflow.Dense", "tensorflow.Dense", "tensorflow.Dropout", "tensorflow.Dropout", "layers.RescaleValues"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.conv_enc"], ["", "def", "EncoderNet", "(", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "name", "=", "None", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "dilation_rate_mult", "=", "1", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation", "=", "'elu'", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "use_residuals", "=", "False", ",", "\n", "nb_conv_per_level", "=", "2", ",", "\n", "conv_dropout", "=", "0", ",", "\n", "dense_size", "=", "256", ",", "\n", "nb_labels", "=", "2", ",", "\n", "final_activation", "=", "None", ",", "\n", "rescale", "=", "None", ",", "\n", "dropout", "=", "None", ",", "\n", "batch_norm", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Fully Convolutional Encoder-based classifer\n    if nb_labels is 0 assume it is a regression net and use linear activation\n    (if None specified)\n    The end of the encoders/downsampling is flattened and attached to a dense\n    layer with dense_size units, then to the nb_labels output nodes. For other\n    parameters see conv_env documentation\n    \"\"\"", "\n", "\n", "# allocate the encoder arm", "\n", "enc_model", "=", "conv_enc", "(", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "name", "=", "name", ",", "\n", "feat_mult", "=", "feat_mult", ",", "\n", "pool_size", "=", "pool_size", ",", "\n", "padding", "=", "padding", ",", "\n", "activation", "=", "activation", ",", "\n", "use_residuals", "=", "use_residuals", ",", "\n", "nb_conv_per_level", "=", "nb_conv_per_level", ",", "\n", "conv_dropout", "=", "conv_dropout", ",", "\n", "batch_norm", "=", "batch_norm", ")", "\n", "\n", "# run the encoder outputs through a dense layer", "\n", "flat", "=", "KL", ".", "Flatten", "(", ")", "(", "enc_model", ".", "outputs", "[", "0", "]", ")", "\n", "if", "dropout", "is", "not", "None", "and", "dropout", ">", "0", ":", "\n", "        ", "flat", "=", "KL", ".", "Dropout", "(", "dropout", ",", "name", "=", "'dropout_flat'", ")", "(", "flat", ")", "\n", "", "dense", "=", "KL", ".", "Dense", "(", "dense_size", ",", "name", "=", "'dense'", ")", "(", "flat", ")", "\n", "if", "dropout", "is", "not", "None", "and", "dropout", ">", "0", ":", "\n", "        ", "dense", "=", "KL", ".", "Dropout", "(", "dropout", ",", "name", "=", "'dropout_dense'", ")", "(", "dense", ")", "\n", "\n", "", "if", "nb_labels", "<=", "0", ":", "# if labels <=0 assume a regression net", "\n", "        ", "nb_labels", "=", "1", "\n", "if", "(", "final_activation", "is", "None", ")", ":", "\n", "            ", "final_activation", "=", "'linear'", "\n", "", "", "else", ":", "# if labels>=1 assume a classification net", "\n", "        ", "if", "(", "final_activation", "is", "None", ")", ":", "\n", "            ", "final_activation", "=", "'softmax'", "\n", "\n", "", "", "if", "(", "rescale", "is", "not", "None", ")", ":", "\n", "        ", "dense", "=", "layers", ".", "RescaleValues", "(", "rescale", ")", "(", "dense", ")", "\n", "", "out", "=", "KL", ".", "Dense", "(", "nb_labels", ",", "name", "=", "'output_dense'", ",", "activation", "=", "final_activation", ")", "(", "dense", ")", "\n", "model", "=", "keras", ".", "models", ".", "Model", "(", "inputs", "=", "enc_model", ".", "inputs", ",", "outputs", "=", "out", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.DenseLayerNet": [[1112, 1138], ["tensorflow.Input", "tensorflow.keras.regularizers.l1_l2", "tensorflow.keras.regularizers.l2", "enumerate", "tensorflow.keras.models.Model", "tensorflow.Flatten", "tensorflow.Dense", "tensorflow.Dense", "tensorflow.Dropout", "tensorflow.BatchNormalization"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.l2"], ["", "def", "DenseLayerNet", "(", "inshape", ",", "layer_sizes", ",", "nb_labels", "=", "2", ",", "activation", "=", "'relu'", ",", "final_activation", "=", "'softmax'", ",", "dropout", "=", "None", ",", "batch_norm", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    A densenet that connects a set of dense layers to  a classification\n    output. \n    if nb_labels is 0 assume it is a regression net and use linear activation\n    (if None specified)\n    \"\"\"", "\n", "inputs", "=", "KL", ".", "Input", "(", "shape", "=", "inshape", ",", "name", "=", "'input'", ")", "\n", "prev_layer", "=", "KL", ".", "Flatten", "(", "name", "=", "'flat_inputs'", ")", "(", "inputs", ")", "\n", "# to prevent overfitting include some kernel and bias regularization", "\n", "kreg", "=", "keras", ".", "regularizers", ".", "l1_l2", "(", "l1", "=", "1e-5", ",", "l2", "=", "1e-4", ")", "\n", "breg", "=", "keras", ".", "regularizers", ".", "l2", "(", "1e-4", ")", "\n", "\n", "# connect the list of dense layers to each other", "\n", "for", "lno", ",", "layer_size", "in", "enumerate", "(", "layer_sizes", ")", ":", "\n", "        ", "prev_layer", "=", "KL", ".", "Dense", "(", "layer_size", ",", "name", "=", "'dense%d'", "%", "lno", ",", "activation", "=", "activation", ",", "kernel_regularizer", "=", "kreg", ",", "bias_regularizer", "=", "breg", ")", "(", "prev_layer", ")", "\n", "if", "dropout", "is", "not", "None", ":", "\n", "            ", "prev_layer", "=", "KL", ".", "Dropout", "(", "dropout", ",", "name", "=", "'dropout%d'", "%", "lno", ")", "(", "prev_layer", ")", "\n", "", "if", "batch_norm", "is", "not", "None", ":", "\n", "            ", "prev_layer", "=", "KL", ".", "BatchNormalization", "(", "name", "=", "'BatchNorm%d'", "%", "lno", ")", "(", "prev_layer", ")", "\n", "\n", "# tie the previous dense layer to a onehot encoded output layer", "\n", "", "", "last_layer", "=", "KL", ".", "Dense", "(", "nb_labels", ",", "name", "=", "'last_dense'", ",", "activation", "=", "final_activation", ")", "(", "prev_layer", ")", "\n", "\n", "model", "=", "keras", ".", "models", ".", "Model", "(", "inputs", "=", "inputs", ",", "outputs", "=", "last_layer", ")", "\n", "return", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.CategoricalCrossentropy.__init__": [[41, 61], ["utils.batch_gather"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather"], ["def", "__init__", "(", "self", ",", "weights", "=", "None", ",", "use_float16", "=", "False", ",", "vox_weights", "=", "None", ",", "crop_indices", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters:\n            vox_weights is either a numpy array the same size as y_true,\n                or a string: 'y_true' or 'expy_true'\n            crop_indices: indices to crop each element of the batch\n                if each element is N-D (so y_true is N+1 dimensional)\n                then crop_indices is a Tensor of crop ranges (indices)\n                of size <= N-D. If it's < N-D, then it acts as a slice\n                for the last few dimensions.\n                See Also: tf.gather_nd\n        \"\"\"", "\n", "\n", "self", ".", "weights", "=", "weights", "if", "(", "weights", "is", "not", "None", ")", "else", "None", "\n", "self", ".", "use_float16", "=", "use_float16", "\n", "self", ".", "vox_weights", "=", "vox_weights", "\n", "self", ".", "crop_indices", "=", "crop_indices", "\n", "\n", "if", "self", ".", "crop_indices", "is", "not", "None", "and", "vox_weights", "is", "not", "None", ":", "\n", "            ", "self", ".", "vox_weights", "=", "utils", ".", "batch_gather", "(", "self", ".", "vox_weights", ",", "self", ".", "crop_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.CategoricalCrossentropy.loss": [[62, 96], ["tensorflow.sum", "tensorflow.sum", "tensorflow.clip", "tensorflow.clip", "tensorflow.log", "tensorflow.log", "tensorflow.mean", "tensorflow.mean", "tensorflow.verify_tensor_all_finite", "tensorflow.verify_tensor_all_finite", "utils.batch_gather", "utils.batch_gather", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.sum", "tensorflow.sum", "tensorflow.cast", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather"], ["", "", "def", "loss", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "        ", "\"\"\" categorical crossentropy loss \"\"\"", "\n", "\n", "if", "self", ".", "crop_indices", "is", "not", "None", ":", "\n", "            ", "y_true", "=", "utils", ".", "batch_gather", "(", "y_true", ",", "self", ".", "crop_indices", ")", "\n", "y_pred", "=", "utils", ".", "batch_gather", "(", "y_pred", ",", "self", ".", "crop_indices", ")", "\n", "\n", "", "if", "self", ".", "use_float16", ":", "\n", "            ", "y_true", "=", "K", ".", "cast", "(", "y_true", ",", "'float16'", ")", "\n", "y_pred", "=", "K", ".", "cast", "(", "y_pred", ",", "'float16'", ")", "\n", "\n", "# scale and clip probabilities", "\n", "# this should not be necessary for softmax output.", "\n", "", "y_pred", "/=", "K", ".", "sum", "(", "y_pred", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "\n", "y_pred", "=", "K", ".", "clip", "(", "y_pred", ",", "K", ".", "epsilon", "(", ")", ",", "1", ")", "\n", "\n", "# compute log probability", "\n", "log_post", "=", "K", ".", "log", "(", "y_pred", ")", "# likelihood", "\n", "\n", "# loss", "\n", "loss", "=", "-", "y_true", "*", "log_post", "\n", "\n", "# weighted loss", "\n", "if", "self", ".", "weights", "is", "not", "None", ":", "\n", "            ", "loss", "*=", "self", ".", "weights", "\n", "\n", "", "if", "self", ".", "vox_weights", "is", "not", "None", ":", "\n", "            ", "loss", "*=", "self", ".", "vox_weights", "\n", "\n", "# take the total loss", "\n", "# loss = K.batch_flatten(loss)", "\n", "", "mloss", "=", "K", ".", "mean", "(", "K", ".", "sum", "(", "K", ".", "cast", "(", "loss", ",", "'float32'", ")", ",", "-", "1", ")", ")", "\n", "tf", ".", "verify_tensor_all_finite", "(", "mloss", ",", "'Loss not finite'", ")", "\n", "return", "mloss", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Dice.__init__": [[158, 191], ["tensorflow.variable", "tensorflow.variable", "tensorflow.variable", "tensorflow.variable", "utils.batch_gather"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather"], ["def", "__init__", "(", "self", ",", "nb_labels", ",", "\n", "weights", "=", "None", ",", "\n", "input_type", "=", "'prob'", ",", "\n", "dice_type", "=", "'soft'", ",", "\n", "approx_hard_max", "=", "True", ",", "\n", "vox_weights", "=", "None", ",", "\n", "crop_indices", "=", "None", ",", "\n", "re_norm", "=", "False", ",", "\n", "area_reg", "=", "0.1", ")", ":", "# regularization for bottom of Dice coeff", "\n", "        ", "\"\"\"\n        input_type is 'prob', or 'max_label'\n        dice_type is hard or soft\n        approx_hard_max - see note below\n\n        Note: for hard dice, we grab the most likely label and then compute a\n        one-hot encoding for each voxel with respect to possible labels. To grab the most\n        likely labels, argmax() can be used, but only when Dice is used as a metric\n        For a Dice *loss*, argmax is not differentiable, and so we can't use it\n        Instead, we approximate the prob->one_hot translation when approx_hard_max is True.\n        \"\"\"", "\n", "\n", "self", ".", "nb_labels", "=", "nb_labels", "\n", "self", ".", "weights", "=", "None", "if", "weights", "is", "None", "else", "K", ".", "variable", "(", "weights", ")", "\n", "self", ".", "vox_weights", "=", "None", "if", "vox_weights", "is", "None", "else", "K", ".", "variable", "(", "vox_weights", ")", "\n", "self", ".", "input_type", "=", "input_type", "\n", "self", ".", "dice_type", "=", "dice_type", "\n", "self", ".", "approx_hard_max", "=", "approx_hard_max", "\n", "self", ".", "area_reg", "=", "area_reg", "\n", "self", ".", "crop_indices", "=", "crop_indices", "\n", "self", ".", "re_norm", "=", "re_norm", "\n", "\n", "if", "self", ".", "crop_indices", "is", "not", "None", "and", "vox_weights", "is", "not", "None", ":", "\n", "            ", "self", ".", "vox_weights", "=", "utils", ".", "batch_gather", "(", "self", ".", "vox_weights", ",", "self", ".", "crop_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Dice.dice": [[192, 252], ["tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.maximum", "tensorflow.maximum", "utils.batch_gather", "utils.batch_gather", "tensorflow.clip", "tensorflow.clip", "tensorflow.clip", "tensorflow.clip", "tensorflow.shape", "tensorflow.shape", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.div_no_nan", "tensorflow.div_no_nan", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.div_no_nan", "tensorflow.div_no_nan", "tensorflow.epsilon", "tensorflow.epsilon", "metrics._label_to_one_hot", "metrics._label_to_one_hot", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "metrics._hard_max", "metrics._hard_max", "metrics._label_to_one_hot", "metrics._label_to_one_hot", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.argmax", "tensorflow.argmax", "tensorflow.argmax", "tensorflow.argmax"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics._label_to_one_hot", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics._label_to_one_hot", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics._hard_max", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics._hard_max", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics._label_to_one_hot", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics._label_to_one_hot"], ["", "", "def", "dice", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "        ", "\"\"\"\n        compute dice for given Tensors\n\n        \"\"\"", "\n", "if", "self", ".", "crop_indices", "is", "not", "None", ":", "\n", "            ", "y_true", "=", "utils", ".", "batch_gather", "(", "y_true", ",", "self", ".", "crop_indices", ")", "\n", "y_pred", "=", "utils", ".", "batch_gather", "(", "y_pred", ",", "self", ".", "crop_indices", ")", "\n", "\n", "", "if", "self", ".", "input_type", "==", "'prob'", ":", "\n", "# We assume that y_true is probabilistic, but just in case:", "\n", "            ", "if", "self", ".", "re_norm", ":", "\n", "                ", "y_true", "=", "tf", ".", "div_no_nan", "(", "y_true", ",", "K", ".", "sum", "(", "y_true", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", ")", "\n", "", "y_true", "=", "K", ".", "clip", "(", "y_true", ",", "K", ".", "epsilon", "(", ")", ",", "1", ")", "\n", "\n", "# make sure pred is a probability", "\n", "if", "self", ".", "re_norm", ":", "\n", "                ", "y_pred", "=", "tf", ".", "div_no_nan", "(", "y_pred", ",", "K", ".", "sum", "(", "y_pred", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", ")", "\n", "", "y_pred", "=", "K", ".", "clip", "(", "y_pred", ",", "K", ".", "epsilon", "(", ")", ",", "1", ")", "\n", "\n", "# Prepare the volumes to operate on", "\n", "# If we're doing 'hard' Dice, then we will prepare one-hot-based matrices of size", "\n", "# [batch_size, nb_voxels, nb_labels], where for each voxel in each batch entry,", "\n", "# the entries are either 0 or 1", "\n", "", "if", "self", ".", "dice_type", "==", "'hard'", ":", "\n", "\n", "# if given predicted probability, transform to \"hard max\"\"", "\n", "            ", "if", "self", ".", "input_type", "==", "'prob'", ":", "\n", "                ", "if", "self", ".", "approx_hard_max", ":", "\n", "                    ", "y_pred_op", "=", "_hard_max", "(", "y_pred", ",", "axis", "=", "-", "1", ")", "\n", "y_true_op", "=", "_hard_max", "(", "y_true", ",", "axis", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "                    ", "y_pred_op", "=", "_label_to_one_hot", "(", "K", ".", "argmax", "(", "y_pred", ",", "axis", "=", "-", "1", ")", ",", "self", ".", "nb_labels", ")", "\n", "y_true_op", "=", "_label_to_one_hot", "(", "K", ".", "argmax", "(", "y_true", ",", "axis", "=", "-", "1", ")", ",", "self", ".", "nb_labels", ")", "\n", "\n", "# if given predicted label, transform to one hot notation", "\n", "", "", "else", ":", "\n", "                ", "assert", "self", ".", "input_type", "==", "'max_label'", "\n", "y_pred_op", "=", "_label_to_one_hot", "(", "y_pred", ",", "self", ".", "nb_labels", ")", "\n", "y_true_op", "=", "_label_to_one_hot", "(", "y_true", ",", "self", ".", "nb_labels", ")", "\n", "\n", "# If we're doing soft Dice, require prob output, and the data already is as we need it", "\n", "# [batch_size, nb_voxels, nb_labels]", "\n", "", "", "else", ":", "\n", "            ", "assert", "self", ".", "input_type", "==", "'prob'", ",", "\"cannot do soft dice with max_label input\"", "\n", "y_pred_op", "=", "y_pred", "\n", "y_true_op", "=", "y_true", "\n", "\n", "# reshape to [batch_size, nb_voxels, nb_labels]", "\n", "", "batch_size", "=", "K", ".", "shape", "(", "y_true", ")", "[", "0", "]", "\n", "y_pred_op", "=", "K", ".", "reshape", "(", "y_pred_op", ",", "[", "batch_size", ",", "-", "1", ",", "K", ".", "shape", "(", "y_true", ")", "[", "-", "1", "]", "]", ")", "\n", "y_true_op", "=", "K", ".", "reshape", "(", "y_true_op", ",", "[", "batch_size", ",", "-", "1", ",", "K", ".", "shape", "(", "y_true", ")", "[", "-", "1", "]", "]", ")", "\n", "\n", "# compute dice for each entry in batch.", "\n", "# dice will now be [batch_size, nb_labels]", "\n", "top", "=", "2", "*", "K", ".", "sum", "(", "y_true_op", "*", "y_pred_op", ",", "1", ")", "\n", "bottom", "=", "K", ".", "sum", "(", "K", ".", "square", "(", "y_true_op", ")", ",", "1", ")", "+", "K", ".", "sum", "(", "K", ".", "square", "(", "y_pred_op", ")", ",", "1", ")", "\n", "# make sure we have no 0s on the bottom. K.epsilon()", "\n", "bottom", "=", "K", ".", "maximum", "(", "bottom", ",", "self", ".", "area_reg", ")", "\n", "return", "top", "/", "bottom", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Dice.mean_dice": [[253, 269], ["metrics.Dice.dice", "tensorflow.mean", "tensorflow.mean", "tensorflow.verify_tensor_all_finite", "tensorflow.verify_tensor_all_finite"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Dice.dice"], ["", "def", "mean_dice", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "        ", "\"\"\" weighted mean dice across all patches and labels \"\"\"", "\n", "\n", "# compute dice, which will now be [batch_size, nb_labels]", "\n", "dice_metric", "=", "self", ".", "dice", "(", "y_true", ",", "y_pred", ")", "\n", "\n", "# weigh the entries in the dice matrix:", "\n", "if", "self", ".", "weights", "is", "not", "None", ":", "\n", "            ", "dice_metric", "*=", "self", ".", "weights", "\n", "", "if", "self", ".", "vox_weights", "is", "not", "None", ":", "\n", "            ", "dice_metric", "*=", "self", ".", "vox_weights", "\n", "\n", "# return one minus mean dice as loss", "\n", "", "mean_dice_metric", "=", "K", ".", "mean", "(", "dice_metric", ")", "\n", "tf", ".", "verify_tensor_all_finite", "(", "mean_dice_metric", ",", "'metric not finite'", ")", "\n", "return", "mean_dice_metric", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Dice.loss": [[271, 288], ["metrics.Dice.dice", "tensorflow.mean", "tensorflow.mean", "tensorflow.verify_tensor_all_finite", "tensorflow.verify_tensor_all_finite"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Dice.dice"], ["", "def", "loss", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "        ", "\"\"\" the loss. Assumes y_pred is prob (in [0,1] and sum_row = 1) \"\"\"", "\n", "\n", "# compute dice, which will now be [batch_size, nb_labels]", "\n", "dice_metric", "=", "self", ".", "dice", "(", "y_true", ",", "y_pred", ")", "\n", "\n", "# loss", "\n", "dice_loss", "=", "1", "-", "dice_metric", "\n", "\n", "# weigh the entries in the dice matrix:", "\n", "if", "self", ".", "weights", "is", "not", "None", ":", "\n", "            ", "dice_loss", "*=", "self", ".", "weights", "\n", "\n", "# return one minus mean dice as loss", "\n", "", "mean_dice_loss", "=", "K", ".", "mean", "(", "dice_loss", ")", "\n", "tf", ".", "verify_tensor_all_finite", "(", "mean_dice_loss", ",", "'Loss not finite'", ")", "\n", "return", "mean_dice_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.MeanSquaredError.__init__": [[296, 314], ["utils.batch_gather"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather"], ["def", "__init__", "(", "self", ",", "weights", "=", "None", ",", "vox_weights", "=", "None", ",", "crop_indices", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters:\n            vox_weights is either a numpy array the same size as y_true,\n                or a string: 'y_true' or 'expy_true'\n            crop_indices: indices to crop each element of the batch\n                if each element is N-D (so y_true is N+1 dimensional)\n                then crop_indices is a Tensor of crop ranges (indices)\n                of size <= N-D. If it's < N-D, then it acts as a slice\n                for the last few dimensions.\n                See Also: tf.gather_nd\n        \"\"\"", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "vox_weights", "=", "vox_weights", "\n", "self", ".", "crop_indices", "=", "crop_indices", "\n", "\n", "if", "self", ".", "crop_indices", "is", "not", "None", "and", "vox_weights", "is", "not", "None", ":", "\n", "            ", "self", ".", "vox_weights", "=", "utils", ".", "batch_gather", "(", "self", ".", "vox_weights", ",", "self", ".", "crop_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.MeanSquaredError.loss": [[315, 335], ["tensorflow.square", "tensorflow.square", "tensorflow.mean", "tensorflow.mean", "utils.batch_gather", "utils.batch_gather", "tensorflow.exp", "tensorflow.exp"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather"], ["", "", "def", "loss", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "\n", "        ", "if", "self", ".", "crop_indices", "is", "not", "None", ":", "\n", "            ", "y_true", "=", "utils", ".", "batch_gather", "(", "y_true", ",", "self", ".", "crop_indices", ")", "\n", "y_pred", "=", "utils", ".", "batch_gather", "(", "y_pred", ",", "self", ".", "crop_indices", ")", "\n", "\n", "", "ksq", "=", "K", ".", "square", "(", "y_pred", "-", "y_true", ")", "\n", "\n", "if", "self", ".", "vox_weights", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "vox_weights", "==", "'y_true'", ":", "\n", "                ", "ksq", "*=", "y_true", "\n", "", "elif", "self", ".", "vox_weights", "==", "'expy_true'", ":", "\n", "                ", "ksq", "*=", "tf", ".", "exp", "(", "y_true", ")", "\n", "", "else", ":", "\n", "                ", "ksq", "*=", "self", ".", "vox_weights", "\n", "\n", "", "", "if", "self", ".", "weights", "is", "not", "None", ":", "\n", "            ", "ksq", "*=", "self", ".", "weights", "\n", "\n", "", "return", "K", ".", "mean", "(", "ksq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Mix.__init__": [[340, 345], ["numpy.ones", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "losses", ",", "loss_weights", "=", "None", ")", ":", "\n", "        ", "self", ".", "losses", "=", "losses", "\n", "self", ".", "loss_wts", "=", "loss_wts", "\n", "if", "loss_wts", "is", "None", ":", "\n", "            ", "self", ".", "loss_wts", "=", "np", ".", "ones", "(", "len", "(", "loss_wts", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Mix.loss": [[346, 351], ["tensorflow.variable", "tensorflow.variable", "enumerate", "metrics.Mix.loss"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.loss"], ["", "", "def", "loss", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "        ", "total_loss", "=", "K", ".", "variable", "(", "0", ")", "\n", "for", "idx", ",", "loss", "in", "enumerate", "(", "self", ".", "losses", ")", ":", "\n", "            ", "total_loss", "+=", "self", ".", "loss_weights", "[", "idx", "]", "*", "loss", "(", "y_true", ",", "y_pred", ")", "\n", "", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.WGAN_GP.__init__": [[358, 362], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "disc", ",", "batch_size", "=", "1", ",", "lambda_gp", "=", "10", ")", ":", "\n", "        ", "self", ".", "disc", "=", "disc", "\n", "self", ".", "lambda_gp", "=", "lambda_gp", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.WGAN_GP.loss": [[363, 384], ["metrics.WGAN_GP.disc", "metrics.WGAN_GP.disc", "tensorflow.random_uniform", "tensorflow.random_uniform", "tensorflow.mean", "tensorflow.mean", "tensorflow.gradients", "tensorflow.gradients", "tensorflow.square", "tensorflow.square", "metrics.WGAN_GP.disc", "tensorflow.mean", "tensorflow.mean", "tensorflow.mean", "tensorflow.mean", "tensorflow.sqrt", "tensorflow.sqrt", "tensorflow.shape", "tensorflow.shape", "tensorflow.sum", "tensorflow.sum", "tensorflow.square", "tensorflow.square"], "methods", ["None"], ["", "def", "loss", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "\n", "# get the value for the true and fake images", "\n", "        ", "disc_true", "=", "self", ".", "disc", "(", "y_true", ")", "\n", "disc_pred", "=", "self", ".", "disc", "(", "y_pred", ")", "\n", "\n", "# sample a x_hat by sampling along the line between true and pred", "\n", "# z = tf.placeholder(tf.float32, shape=[None, 1])", "\n", "# shp = y_true.get_shape()[0]", "\n", "# WARNING: SHOULD REALLY BE shape=[batch_size, 1] !!!", "\n", "# self.batch_size does not work, since it's not None!!!", "\n", "alpha", "=", "K", ".", "random_uniform", "(", "shape", "=", "[", "K", ".", "shape", "(", "y_pred", ")", "[", "0", "]", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "diff", "=", "y_pred", "-", "y_true", "\n", "interp", "=", "y_true", "+", "alpha", "*", "diff", "\n", "\n", "# take gradient of D(x_hat)", "\n", "gradients", "=", "K", ".", "gradients", "(", "self", ".", "disc", "(", "interp", ")", ",", "[", "interp", "]", ")", "[", "0", "]", "\n", "grad_pen", "=", "K", ".", "mean", "(", "K", ".", "square", "(", "K", ".", "sqrt", "(", "K", ".", "sum", "(", "K", ".", "square", "(", "gradients", ")", ",", "axis", "=", "1", ")", ")", "-", "1", ")", ")", "\n", "\n", "# compute loss", "\n", "return", "(", "K", ".", "mean", "(", "disc_pred", ")", "-", "K", ".", "mean", "(", "disc_true", ")", ")", "+", "self", ".", "lambda_gp", "*", "grad_pen", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Nonbg.__init__": [[398, 400], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "metric", ")", ":", "\n", "        ", "self", ".", "metric", "=", "metric", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.Nonbg.loss": [[401, 408], ["numpy.where", "tensorflow.variable", "tensorflow.variable", "tensorflow.variable", "tensorflow.variable", "metrics.Nonbg.metric", "yt.flat", "y_pred.flat"], "methods", ["None"], ["", "def", "loss", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "        ", "\"\"\" prepare a loss of the given metric/loss operating on non-bg data \"\"\"", "\n", "yt", "=", "y_true", "#.eval()", "\n", "ytbg", "=", "np", ".", "where", "(", "yt", "==", "0", ")", "\n", "y_true_fix", "=", "K", ".", "variable", "(", "yt", ".", "flat", "(", "ytbg", ")", ")", "\n", "y_pred_fix", "=", "K", ".", "variable", "(", "y_pred", ".", "flat", "(", "ytbg", ")", ")", "\n", "return", "self", ".", "metric", "(", "y_true_fix", ",", "y_pred_fix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.l1": [[414, 417], ["tensorflow.keras.losses.mean_absolute_error"], "function", ["None"], ["", "", "def", "l1", "(", "y_true", ",", "y_pred", ")", ":", "\n", "    ", "\"\"\" L1 metric (MAE) \"\"\"", "\n", "return", "losses", ".", "mean_absolute_error", "(", "y_true", ",", "y_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics.l2": [[419, 422], ["tensorflow.keras.losses.mean_squared_error"], "function", ["None"], ["", "def", "l2", "(", "y_true", ",", "y_pred", ")", ":", "\n", "    ", "\"\"\" L2 metric (MSE) \"\"\"", "\n", "return", "losses", ".", "mean_squared_error", "(", "y_true", ",", "y_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics._label_to_one_hot": [[428, 435], ["tensorflow.batch_flatten", "tensorflow.one_hot"], "function", ["None"], ["", "def", "_label_to_one_hot", "(", "tens", ",", "nb_labels", ")", ":", "\n", "    ", "\"\"\"\n    Transform a label nD Tensor to a one-hot 3D Tensor. The input tensor is first\n    batch-flattened, and then each batch and each voxel gets a one-hot representation\n    \"\"\"", "\n", "y", "=", "K", ".", "batch_flatten", "(", "tens", ")", "\n", "return", "K", ".", "one_hot", "(", "y", ",", "nb_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.metrics._hard_max": [[437, 448], ["tensorflow.max", "tensorflow.maximum", "tensorflow.epsilon", "tensorflow.epsilon"], "function", ["None"], ["", "def", "_hard_max", "(", "tens", ",", "axis", ")", ":", "\n", "    ", "\"\"\"\n    we can't use the argmax function in a loss, as it's not differentiable\n    We can use it in a metric, but not in a loss function\n    therefore, we replace the 'hard max' operation (i.e. argmax + onehot)\n    with this approximation\n    \"\"\"", "\n", "tensmax", "=", "K", ".", "max", "(", "tens", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "eps_hot", "=", "K", ".", "maximum", "(", "tens", "-", "tensmax", "+", "K", ".", "epsilon", "(", ")", ",", "0", ")", "\n", "one_hot", "=", "eps_hot", "/", "K", ".", "epsilon", "(", ")", "\n", "return", "one_hot", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.Vol.__init__": [[27, 59], ["generators._get_file_list", "len", "generators._load_medical_volume", "os.path.join", "data_proc_fn", "all", "numpy.prod", "pytools.gridsize", "pytools.gridsize", "generators._npz_headers"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._get_file_list", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._load_medical_volume", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.gridsize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.gridsize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._npz_headers"], ["    ", "def", "__init__", "(", "self", ",", "\n", "volpath", ",", "\n", "ext", "=", "'.npz'", ",", "\n", "nb_restart_cycle", "=", "None", ",", "# number of files to restart after", "\n", "name", "=", "'single_vol'", ",", "# name", "\n", "fixed_vol_size", "=", "True", ",", "# assumes each volume is fixed size", "\n", ")", ":", "\n", "\n", "# get filenames at given paths", "\n", "        ", "volfiles", "=", "_get_file_list", "(", "volpath", ",", "ext", ",", "vol_rand_seed", ")", "\n", "nb_files", "=", "len", "(", "volfiles", ")", "\n", "assert", "nb_files", ">", "0", ",", "\"Could not find any files at %s with extension %s\"", "%", "(", "volpath", ",", "ext", ")", "\n", "\n", "# set up restart cycle for volume files --", "\n", "# i.e. after how many volumes do we restart", "\n", "if", "nb_restart_cycle", "is", "None", ":", "\n", "            ", "nb_restart_cycle", "=", "nb_files", "\n", "\n", "# compute subvolume split", "\n", "", "vol_data", "=", "_load_medical_volume", "(", "os", ".", "path", ".", "join", "(", "volpath", ",", "volfiles", "[", "0", "]", ")", ",", "ext", ")", "\n", "# process volume", "\n", "if", "data_proc_fn", "is", "not", "None", ":", "\n", "            ", "vol_data", "=", "data_proc_fn", "(", "vol_data", ")", "\n", "[", "f", "for", "f", "in", "_npz_headers", "(", "npz", ",", "namelist", "=", "[", "'vol_data.npy'", "]", ")", "]", "[", "0", "]", "[", "1", "]", "\n", "\n", "", "nb_patches_per_vol", "=", "1", "\n", "if", "fixed_vol_size", "and", "(", "patch_size", "is", "not", "None", ")", "and", "all", "(", "f", "is", "not", "None", "for", "f", "in", "patch_size", ")", ":", "\n", "            ", "nb_patches_per_vol", "=", "np", ".", "prod", "(", "pl", ".", "gridsize", "(", "vol_data", ".", "shape", ",", "patch_size", ",", "patch_stride", ")", ")", "\n", "\n", "", "assert", "nb_restart_cycle", "<=", "(", "nb_files", "*", "nb_patches_per_vol", ")", ",", "'%s restart cycle (%s) too big (%s) in %s'", "%", "(", "name", ",", "nb_restart_cycle", ",", "nb_files", "*", "nb_patches_per_vol", ",", "volpath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol": [[61, 240], ["generators._get_file_list", "len", "generators._load_medical_volume", "os.path.join", "data_proc_fn", "all", "numpy.prod", "print", "print", "numpy.mod", "numpy.all", "generators.patch", "len", "len", "pytools.gridsize", "print", "print", "print", "os.path.join", "generators._load_medical_volume", "data_proc_fn", "generators._relabel", "enumerate", "numpy.any", "numpy.isfinite", "ValueError", "len", "len", "len", "len", "len", "print", "print", "numpy.isnan", "numpy.mod", "numpy.concatenate", "vol_data_feats.astype.astype", "numpy.mod", "len", "print", "numpy.mod", "print", "numpy.vstack", "os.path.join", "numpy.ndim", "numpy.vstack", "len", "sys.exc_info", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._get_file_list", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._load_medical_volume", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.patch", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.gridsize", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._load_medical_volume", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._relabel"], ["", "", "def", "vol", "(", "volpath", ",", "\n", "ext", "=", "'.npz'", ",", "\n", "batch_size", "=", "1", ",", "\n", "expected_nb_files", "=", "-", "1", ",", "\n", "expected_files", "=", "None", ",", "\n", "data_proc_fn", "=", "None", ",", "# processing function that takes in one arg (the volume)", "\n", "relabel", "=", "None", ",", "# relabeling array", "\n", "nb_labels_reshape", "=", "0", ",", "# reshape to categorial format for keras, need # labels", "\n", "keep_vol_size", "=", "False", ",", "# whether to keep the volume size on categorical resizing", "\n", "name", "=", "'single_vol'", ",", "# name, optional", "\n", "nb_restart_cycle", "=", "None", ",", "# number of files to restart after", "\n", "patch_size", "=", "None", ",", "# split the volume in patches? if so, get patch_size", "\n", "patch_stride", "=", "1", ",", "# split the volume in patches? if so, get patch_stride", "\n", "collapse_2d", "=", "None", ",", "\n", "extract_slice", "=", "None", ",", "\n", "force_binary", "=", "False", ",", "\n", "nb_feats", "=", "1", ",", "\n", "patch_rand", "=", "False", ",", "\n", "patch_rand_seed", "=", "None", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "binary", "=", "False", ",", "\n", "yield_incomplete_final_batch", "=", "True", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    generator for single volume (or volume patches) from a list of files\n\n    simple volume generator that loads a volume (via npy/mgz/nii/niigz), processes it,\n    and prepares it for keras model formats\n\n    if a patch size is passed, breaks the volume into patches and generates those\n    \"\"\"", "\n", "\n", "# get filenames at given paths", "\n", "volfiles", "=", "_get_file_list", "(", "volpath", ",", "ext", ",", "vol_rand_seed", ")", "\n", "nb_files", "=", "len", "(", "volfiles", ")", "\n", "assert", "nb_files", ">", "0", ",", "\"Could not find any files at %s with extension %s\"", "%", "(", "volpath", ",", "ext", ")", "\n", "\n", "# compute subvolume split", "\n", "vol_data", "=", "_load_medical_volume", "(", "os", ".", "path", ".", "join", "(", "volpath", ",", "volfiles", "[", "0", "]", ")", ",", "ext", ")", "\n", "\n", "# process volume", "\n", "if", "data_proc_fn", "is", "not", "None", ":", "\n", "        ", "vol_data", "=", "data_proc_fn", "(", "vol_data", ")", "\n", "\n", "", "nb_patches_per_vol", "=", "1", "\n", "if", "patch_size", "is", "not", "None", "and", "all", "(", "f", "is", "not", "None", "for", "f", "in", "patch_size", ")", ":", "\n", "        ", "if", "relabel", "is", "None", "and", "len", "(", "patch_size", ")", "==", "(", "len", "(", "vol_data", ".", "shape", ")", "-", "1", ")", ":", "\n", "            ", "tmp_patch_size", "=", "[", "f", "for", "f", "in", "patch_size", "]", "\n", "patch_size", "=", "[", "*", "patch_size", ",", "vol_data", ".", "shape", "[", "-", "1", "]", "]", "\n", "patch_stride", "=", "[", "f", "for", "f", "in", "patch_stride", "]", "\n", "patch_stride", "=", "[", "*", "patch_stride", ",", "vol_data", ".", "shape", "[", "-", "1", "]", "]", "\n", "", "assert", "len", "(", "vol_data", ".", "shape", ")", "==", "len", "(", "patch_size", ")", ",", "\"Vol dims %d are  not equal to patch dims %d\"", "%", "(", "len", "(", "vol_data", ".", "shape", ")", ",", "len", "(", "patch_size", ")", ")", "\n", "nb_patches_per_vol", "=", "np", ".", "prod", "(", "pl", ".", "gridsize", "(", "vol_data", ".", "shape", ",", "patch_size", ",", "patch_stride", ")", ")", "\n", "", "if", "nb_restart_cycle", "is", "None", ":", "\n", "        ", "print", "(", "\"setting restart cycle to\"", ",", "nb_files", ")", "\n", "nb_restart_cycle", "=", "nb_files", "\n", "\n", "", "assert", "nb_restart_cycle", "<=", "(", "nb_files", "*", "nb_patches_per_vol", ")", ",", "'%s restart cycle (%s) too big (%s) in %s'", "%", "(", "name", ",", "nb_restart_cycle", ",", "nb_files", "*", "nb_patches_per_vol", ",", "volpath", ")", "\n", "\n", "# check the number of files matches expected (if passed)", "\n", "if", "expected_nb_files", ">=", "0", ":", "\n", "        ", "assert", "nb_files", "==", "expected_nb_files", ",", "\"number of files do not match: %d, %d\"", "%", "(", "nb_files", ",", "expected_nb_files", ")", "\n", "", "if", "expected_files", "is", "not", "None", ":", "\n", "        ", "if", "not", "(", "volfiles", "==", "expected_files", ")", ":", "\n", "            ", "print", "(", "'file lists did not match. You should probably stop execution.'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "len", "(", "volfiles", ")", ",", "len", "(", "expected_files", ")", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'nb_restart_cycle:'", ",", "nb_restart_cycle", ")", "\n", "\n", "# iterate through files", "\n", "", "fileidx", "=", "-", "1", "\n", "batch_idx", "=", "-", "1", "\n", "feat_idx", "=", "0", "\n", "batch_shape", "=", "None", "\n", "while", "1", ":", "\n", "        ", "fileidx", "=", "np", ".", "mod", "(", "fileidx", "+", "1", ",", "nb_restart_cycle", ")", "\n", "if", "verbose", "and", "fileidx", "==", "0", ":", "\n", "            ", "print", "(", "'starting %s cycle'", "%", "name", ")", "\n", "\n", "# read next file (circular)", "\n", "\n", "", "try", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "'opening %s'", "%", "os", ".", "path", ".", "join", "(", "volpath", ",", "volfiles", "[", "fileidx", "]", ")", ")", "\n", "", "file_name", "=", "os", ".", "path", ".", "join", "(", "volpath", ",", "volfiles", "[", "fileidx", "]", ")", "\n", "vol_data", "=", "_load_medical_volume", "(", "file_name", ",", "ext", ",", "verbose", ")", "\n", "# print(file_name, \" was loaded\", vol_data.shape)", "\n", "", "except", ":", "\n", "            ", "debug_error_msg", "=", "\"#files: %d, fileidx: %d, nb_restart_cycle: %d. error: %s\"", "\n", "print", "(", "debug_error_msg", "%", "(", "len", "(", "volfiles", ")", ",", "fileidx", ",", "nb_restart_cycle", ",", "sys", ".", "exc_info", "(", ")", "[", "0", "]", ")", ")", "\n", "raise", "\n", "\n", "# process volume", "\n", "", "if", "data_proc_fn", "is", "not", "None", ":", "\n", "            ", "vol_data", "=", "data_proc_fn", "(", "vol_data", ")", "\n", "\n", "# the original segmentation files have non-sequential relabel (i.e. some relabel are", "\n", "# missing to avoid exploding our model, we only care about the relabel that exist.", "\n", "", "if", "relabel", "is", "not", "None", ":", "\n", "            ", "vol_data", "=", "_relabel", "(", "vol_data", ",", "relabel", ")", "\n", "\n", "# split volume into patches if necessary and yield", "\n", "", "if", "patch_size", "is", "None", ":", "\n", "            ", "this_patch_size", "=", "vol_data", ".", "shape", "\n", "patch_stride", "=", "[", "1", "for", "f", "in", "this_patch_size", "]", "\n", "\n", "", "else", ":", "\n", "            ", "this_patch_size", "=", "[", "f", "for", "f", "in", "patch_size", "]", "\n", "for", "pi", ",", "p", "in", "enumerate", "(", "this_patch_size", ")", ":", "\n", "                ", "if", "p", "is", "None", ":", "\n", "                    ", "this_patch_size", "[", "pi", "]", "=", "vol_data", ".", "shape", "[", "pi", "]", "\n", "patch_stride", "[", "pi", "]", "=", "1", "\n", "\n", "", "", "", "assert", "~", "np", ".", "any", "(", "np", ".", "isnan", "(", "vol_data", ")", ")", ",", "\"Found a nan for %s\"", "%", "volfiles", "[", "fileidx", "]", "\n", "assert", "np", ".", "all", "(", "np", ".", "isfinite", "(", "vol_data", ")", ")", ",", "\"Found a inf for %s\"", "%", "volfiles", "[", "fileidx", "]", "\n", "\n", "patch_gen", "=", "patch", "(", "vol_data", ",", "this_patch_size", ",", "\n", "patch_stride", "=", "patch_stride", ",", "\n", "nb_labels_reshape", "=", "nb_labels_reshape", ",", "\n", "batch_size", "=", "1", ",", "\n", "infinite", "=", "False", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "patch_rand", "=", "patch_rand", ",", "\n", "patch_rand_seed", "=", "patch_rand_seed", ",", "\n", "keep_vol_size", "=", "keep_vol_size", ")", "\n", "\n", "empty_gen", "=", "True", "\n", "patch_idx", "=", "-", "1", "\n", "for", "lpatch", "in", "patch_gen", ":", "\n", "            ", "empty_gen", "=", "False", "\n", "patch_idx", "+=", "1", "\n", "\n", "# add to feature", "\n", "if", "np", ".", "mod", "(", "feat_idx", ",", "nb_feats", ")", "==", "0", ":", "\n", "                ", "vol_data_feats", "=", "lpatch", "\n", "\n", "", "else", ":", "\n", "                ", "vol_data_feats", "=", "np", ".", "concatenate", "(", "[", "vol_data_feats", ",", "lpatch", "]", ",", "np", ".", "ndim", "(", "lpatch", ")", "-", "1", ")", "\n", "", "feat_idx", "+=", "1", "\n", "\n", "if", "binary", ":", "\n", "                ", "vol_data_feats", "=", "vol_data_feats", ".", "astype", "(", "bool", ")", "\n", "\n", "", "if", "np", ".", "mod", "(", "feat_idx", ",", "nb_feats", ")", "==", "0", ":", "\n", "                ", "feats_shape", "=", "vol_data_feats", "[", "1", ":", "]", "\n", "\n", "# yield previous batch if the new volume has different patch sizes", "\n", "if", "batch_shape", "is", "not", "None", "and", "(", "feats_shape", "!=", "batch_shape", ")", ":", "\n", "                    ", "batch_idx", "=", "-", "1", "\n", "batch_shape", "=", "None", "\n", "print", "(", "'switching patch sizes'", ")", "\n", "yield", "np", ".", "vstack", "(", "vol_data_batch", ")", "\n", "\n", "# add to batch of volume data, unless the batch is currently empty", "\n", "", "if", "batch_idx", "==", "-", "1", ":", "\n", "                    ", "vol_data_batch", "=", "[", "vol_data_feats", "]", "\n", "batch_shape", "=", "vol_data_feats", "[", "1", ":", "]", "\n", "", "else", ":", "\n", "                    ", "vol_data_batch", "=", "[", "*", "vol_data_batch", ",", "vol_data_feats", "]", "\n", "\n", "# yield patch", "\n", "", "batch_idx", "+=", "1", "\n", "batch_done", "=", "batch_idx", "==", "batch_size", "-", "1", "\n", "files_done", "=", "np", ".", "mod", "(", "fileidx", "+", "1", ",", "nb_restart_cycle", ")", "==", "0", "\n", "final_batch", "=", "yield_incomplete_final_batch", "and", "files_done", "and", "patch_idx", "==", "(", "nb_patches_per_vol", "-", "1", ")", "\n", "if", "final_batch", ":", "# verbose and ", "\n", "                    ", "print", "(", "'last batch in %s cycle %d. nb_batch:%d'", "%", "(", "name", ",", "fileidx", ",", "len", "(", "vol_data_batch", ")", ")", ")", "\n", "\n", "", "if", "batch_done", "or", "final_batch", ":", "\n", "                    ", "batch_idx", "=", "-", "1", "\n", "q", "=", "np", ".", "vstack", "(", "vol_data_batch", ")", "\n", "yield", "q", "\n", "\n", "", "", "", "if", "empty_gen", ":", "\n", "            ", "raise", "ValueError", "(", "'Patch generator was empty for file %s'", ",", "volfiles", "[", "fileidx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.patch": [[242, 319], ["enumerate", "pytools.patch_gen", "generators._categorical_prep", "numpy.squeeze", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.patch_gen", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._categorical_prep"], ["", "", "", "def", "patch", "(", "vol_data", ",", "# the volume", "\n", "patch_size", ",", "# patch size", "\n", "patch_stride", "=", "1", ",", "# patch stride (spacing)", "\n", "nb_labels_reshape", "=", "1", ",", "# number of labels for categorical resizing. 0 if no resizing", "\n", "keep_vol_size", "=", "False", ",", "# whether to keep the volume size on categorical resizing", "\n", "batch_size", "=", "1", ",", "# batch size", "\n", "collapse_2d", "=", "None", ",", "\n", "patch_rand", "=", "False", ",", "\n", "patch_rand_seed", "=", "None", ",", "\n", "variable_batch_size", "=", "False", ",", "\n", "infinite", "=", "False", ")", ":", "# whether the generator should continue (re)-generating patches", "\n", "    ", "\"\"\"\n    generate patches from volume for keras package\n\n    Yields:\n        patch: nd array of shape [batch_size, *patch_size], unless resized via nb_labels_reshape\n    \"\"\"", "\n", "\n", "# some parameter setup", "\n", "assert", "batch_size", ">=", "1", ",", "\"batch_size should be at least 1\"", "\n", "if", "patch_size", "is", "None", ":", "\n", "        ", "patch_size", "=", "vol_data", ".", "shape", "\n", "", "for", "pi", ",", "p", "in", "enumerate", "(", "patch_size", ")", ":", "\n", "        ", "if", "p", "is", "None", ":", "\n", "            ", "patch_size", "[", "pi", "]", "=", "vol_data", ".", "shape", "[", "pi", "]", "\n", "", "", "batch_idx", "=", "-", "1", "\n", "if", "variable_batch_size", ":", "\n", "        ", "batch_size", "=", "yield", "\n", "\n", "\n", "# do while. if not infinite, will break at the end", "\n", "", "while", "True", ":", "\n", "# create patch generator", "\n", "        ", "gen", "=", "pl", ".", "patch_gen", "(", "vol_data", ",", "patch_size", ",", "\n", "stride", "=", "patch_stride", ",", "\n", "rand", "=", "patch_rand", ",", "\n", "rand_seed", "=", "patch_rand_seed", ")", "\n", "\n", "# go through the patch generator", "\n", "empty_gen", "=", "True", "\n", "for", "lpatch", "in", "gen", ":", "\n", "\n", "            ", "empty_gen", "=", "False", "\n", "# reshape output layer as categorical and prep proper size", "\n", "# print(lpatch.shape, nb_labels_reshape, keep_vol_size, patch_size)", "\n", "lpatch", "=", "_categorical_prep", "(", "lpatch", ",", "nb_labels_reshape", ",", "keep_vol_size", ",", "patch_size", ")", "\n", "\n", "if", "collapse_2d", "is", "not", "None", ":", "\n", "                ", "lpatch", "=", "np", ".", "squeeze", "(", "lpatch", ",", "collapse_2d", "+", "1", ")", "# +1 due to batch in first dim", "\n", "\n", "# add this patch to the stack", "\n", "", "if", "batch_idx", "==", "-", "1", ":", "\n", "                ", "if", "batch_size", "==", "1", ":", "\n", "                    ", "patch_data_batch", "=", "lpatch", "\n", "", "else", ":", "\n", "                    ", "patch_data_batch", "=", "np", ".", "zeros", "(", "[", "batch_size", ",", "*", "lpatch", ".", "shape", "[", "1", ":", "]", "]", ")", "\n", "patch_data_batch", "[", "0", ",", ":", "]", "=", "lpatch", "\n", "\n", "", "", "else", ":", "\n", "                ", "patch_data_batch", "[", "batch_idx", "+", "1", ",", ":", "]", "=", "lpatch", "\n", "\n", "# yield patch", "\n", "", "batch_idx", "+=", "1", "\n", "if", "batch_idx", "==", "batch_size", "-", "1", ":", "\n", "                ", "batch_idx", "=", "-", "1", "\n", "batch_size_y", "=", "yield", "patch_data_batch", "\n", "if", "variable_batch_size", ":", "\n", "                    ", "batch_size", "=", "batch_size_y", "\n", "\n", "", "", "", "assert", "not", "empty_gen", ",", "'generator was empty. vol size was %s'", "%", "''", ".", "join", "(", "[", "'%d '", "%", "d", "for", "d", "in", "vol_data", ".", "shape", "]", ")", "\n", "\n", "# if not infinite generation, yield the last batch and break the while", "\n", "if", "not", "infinite", ":", "\n", "            ", "if", "batch_idx", ">=", "0", ":", "\n", "                ", "patch_data_batch", "=", "patch_data_batch", "[", ":", "(", "batch_idx", "+", "1", ")", ",", ":", "]", "\n", "yield", "patch_data_batch", "\n", "", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol_seg": [[321, 372], ["generators.vol", "generators.vol", "f.replace", "next().astype", "next().astype", "generators._get_file_list", "next", "next"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._get_file_list"], ["", "", "", "def", "vol_seg", "(", "volpath", ",", "\n", "segpath", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", "name", "=", "'vol_seg'", ",", "# name, optional", "\n", "ext", "=", "'.npz'", ",", "\n", "nb_restart_cycle", "=", "None", ",", "# number of files to restart after", "\n", "nb_labels_reshape", "=", "-", "1", ",", "\n", "collapse_2d", "=", "None", ",", "\n", "force_binary", "=", "False", ",", "\n", "nb_input_feats", "=", "1", ",", "\n", "relabel", "=", "None", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "seg_binary", "=", "False", ",", "\n", "vol_subname", "=", "'norm'", ",", "# subname of volume", "\n", "seg_subname", "=", "'aseg'", ",", "# subname of segmentation", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    generator with (volume, segmentation)\n\n    verbose is passed down to the base generators.py primitive generator (e.g. vol, here)\n\n    ** kwargs are any named arguments for vol(...),\n        except verbose, data_proc_fn, ext, nb_labels_reshape and name\n            (which this function will control when calling vol())\n    \"\"\"", "\n", "\n", "# get vol generator", "\n", "vol_gen", "=", "vol", "(", "volpath", ",", "**", "kwargs", ",", "ext", "=", "ext", ",", "\n", "nb_restart_cycle", "=", "nb_restart_cycle", ",", "collapse_2d", "=", "collapse_2d", ",", "force_binary", "=", "False", ",", "\n", "relabel", "=", "None", ",", "data_proc_fn", "=", "proc_vol_fn", ",", "nb_labels_reshape", "=", "1", ",", "name", "=", "name", "+", "' vol'", ",", "\n", "verbose", "=", "verbose", ",", "nb_feats", "=", "nb_input_feats", ",", "vol_rand_seed", "=", "vol_rand_seed", ")", "\n", "\n", "# get seg generator, matching nb_files", "\n", "# vol_files = [f.replace('norm', 'aseg') for f in _get_file_list(volpath, ext)]", "\n", "# vol_files = [f.replace('orig', 'aseg') for f in vol_files]", "\n", "vol_files", "=", "[", "f", ".", "replace", "(", "vol_subname", ",", "seg_subname", ")", "for", "f", "in", "_get_file_list", "(", "volpath", ",", "ext", ",", "vol_rand_seed", ")", "]", "\n", "seg_gen", "=", "vol", "(", "segpath", ",", "**", "kwargs", ",", "ext", "=", "ext", ",", "nb_restart_cycle", "=", "nb_restart_cycle", ",", "collapse_2d", "=", "collapse_2d", ",", "\n", "force_binary", "=", "force_binary", ",", "relabel", "=", "relabel", ",", "vol_rand_seed", "=", "vol_rand_seed", ",", "\n", "data_proc_fn", "=", "proc_seg_fn", ",", "nb_labels_reshape", "=", "nb_labels_reshape", ",", "keep_vol_size", "=", "True", ",", "\n", "expected_files", "=", "vol_files", ",", "name", "=", "name", "+", "' seg'", ",", "binary", "=", "seg_binary", ",", "verbose", "=", "False", ")", "\n", "\n", "# on next (while):", "\n", "while", "1", ":", "\n", "# get input and output (seg) vols", "\n", "        ", "input_vol", "=", "next", "(", "vol_gen", ")", ".", "astype", "(", "'float16'", ")", "\n", "output_vol", "=", "next", "(", "seg_gen", ")", ".", "astype", "(", "'float16'", ")", "# was int8. Why? need float possibility...", "\n", "\n", "# output input and output", "\n", "yield", "(", "input_vol", ",", "output_vol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol_cat": [[374, 427], ["neurite.dataproc.vol_proc", "generators.vol", "print", "numpy.hstack().astype", "numpy.random.shuffle", "sorted", "os.path.join", "len", "numpy.zeros", "next().astype", "os.listdir", "generators._get_file_list", "numpy.hstack", "os.path.join", "next", "numpy.zeros", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.dataproc.vol_proc", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._get_file_list"], ["", "", "def", "vol_cat", "(", "volpaths", ",", "# expect two folders in here", "\n", "crop", "=", "None", ",", "resize_shape", "=", "None", ",", "rescale", "=", "None", ",", "# processing parameters", "\n", "verbose", "=", "False", ",", "\n", "name", "=", "'vol_cat'", ",", "# name, optional", "\n", "ext", "=", "'.npz'", ",", "\n", "nb_labels_reshape", "=", "-", "1", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "# named arguments for vol(...), except verbose, data_proc_fn, ext, nb_labels_reshape and name (which this function will control when calling vol()) ", "\n", "    ", "\"\"\"\n    generator with (volume, binary_bit) (random order)\n    ONLY works with abtch size of 1 for now\n\n    verbose is passed down to the base generators.py primitive generator (e.g. vol, here)\n    \"\"\"", "\n", "\n", "folders", "=", "[", "f", "for", "f", "in", "sorted", "(", "os", ".", "listdir", "(", "volpaths", ")", ")", "]", "\n", "\n", "# compute processing function", "\n", "proc_vol_fn", "=", "lambda", "x", ":", "nrn_proc", ".", "vol_proc", "(", "x", ",", "crop", "=", "crop", ",", "resize_shape", "=", "resize_shape", ",", "\n", "interp_order", "=", "2", ",", "rescale", "=", "rescale", ")", "\n", "\n", "# get vol generators", "\n", "generators", "=", "(", ")", "\n", "generators_len", "=", "(", ")", "\n", "for", "folder", "in", "folders", ":", "\n", "        ", "vol_gen", "=", "vol", "(", "os", ".", "path", ".", "join", "(", "volpaths", ",", "folder", ")", ",", "**", "kwargs", ",", "ext", "=", "ext", ",", "vol_rand_seed", "=", "vol_rand_seed", ",", "\n", "data_proc_fn", "=", "proc_vol_fn", ",", "nb_labels_reshape", "=", "1", ",", "name", "=", "folder", ",", "verbose", "=", "False", ")", "\n", "generators_len", "+=", "(", "len", "(", "_get_file_list", "(", "os", ".", "path", ".", "join", "(", "volpaths", ",", "folder", ")", ",", "'.npz'", ")", ")", ",", ")", "\n", "generators", "+=", "(", "vol_gen", ",", ")", "\n", "\n", "", "bake_data_test", "=", "False", "\n", "if", "bake_data_test", ":", "\n", "        ", "print", "(", "'fake_data_test'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# on next (while):", "\n", "", "while", "1", ":", "\n", "# build the random order stack", "\n", "        ", "order", "=", "np", ".", "hstack", "(", "(", "np", ".", "zeros", "(", "generators_len", "[", "0", "]", ")", ",", "np", ".", "ones", "(", "generators_len", "[", "1", "]", ")", ")", ")", ".", "astype", "(", "'int'", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "order", ")", "# shuffle", "\n", "for", "idx", "in", "order", ":", "\n", "            ", "gen", "=", "generators", "[", "idx", "]", "\n", "\n", "# for idx, gen in enumerate(generators):", "\n", "z", "=", "np", ".", "zeros", "(", "[", "1", ",", "2", "]", ")", "#1,1,2 for categorical binary style", "\n", "z", "[", "0", ",", "idx", "]", "=", "1", "#", "\n", "# z[0,0,0] = idx", "\n", "\n", "data", "=", "next", "(", "gen", ")", ".", "astype", "(", "'float32'", ")", "\n", "if", "bake_data_test", "and", "idx", "==", "0", ":", "\n", "# data = data*idx", "\n", "                ", "data", "=", "-", "data", "\n", "\n", "", "yield", "(", "data", ",", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.add_prior": [[429, 508], ["generators.patch", "pynd.volsize2ndgrid", "numpy.transpose", "numpy.expand_dims", "numpy.sum", "numpy.delete", "isinstance", "len", "len", "next", "next", "generators._get_shape", "patch.send", "range", "numpy.ndim", "numpy.ndim", "pytools.Timer", "numpy.load", "data[].astype", "pytools.Timer", "prior_file.astype"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.patch", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.volsize2ndgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._get_shape", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], ["", "", "", "def", "add_prior", "(", "gen", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "prior_type", "=", "'location'", ",", "# file-static, file-gen, location", "\n", "prior_file", "=", "None", ",", "# prior filename", "\n", "prior_feed", "=", "'input'", ",", "# input or output", "\n", "patch_stride", "=", "1", ",", "\n", "patch_size", "=", "None", ",", "\n", "batch_size", "=", "1", ",", "\n", "collapse_2d", "=", "None", ",", "\n", "extract_slice", "=", "None", ",", "\n", "force_binary", "=", "False", ",", "\n", "verbose", "=", "False", ",", "\n", "patch_rand", "=", "False", ",", "\n", "patch_rand_seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    #\n    # add a prior generator to a given generator\n    # with the number of patches in batch matching output of gen\n    \"\"\"", "\n", "\n", "# get prior", "\n", "if", "prior_type", "==", "'location'", ":", "\n", "        ", "prior_vol", "=", "nd", ".", "volsize2ndgrid", "(", "vol_size", ")", "\n", "prior_vol", "=", "np", ".", "transpose", "(", "prior_vol", ",", "[", "1", ",", "2", ",", "3", ",", "0", "]", ")", "\n", "prior_vol", "=", "np", ".", "expand_dims", "(", "prior_vol", ",", "axis", "=", "0", ")", "# reshape for model", "\n", "\n", "", "elif", "prior_type", "==", "'file'", ":", "# assumes a npz filename passed in prior_file", "\n", "        ", "with", "timer", ".", "Timer", "(", "'loading prior'", ",", "True", ")", ":", "\n", "            ", "data", "=", "np", ".", "load", "(", "prior_file", ")", "\n", "prior_vol", "=", "data", "[", "'prior'", "]", ".", "astype", "(", "'float16'", ")", "\n", "\n", "", "", "else", ":", "# assumes a volume", "\n", "        ", "with", "timer", ".", "Timer", "(", "'loading prior'", ",", "True", ")", ":", "\n", "            ", "prior_vol", "=", "prior_file", ".", "astype", "(", "'float16'", ")", "\n", "\n", "", "", "if", "force_binary", ":", "\n", "        ", "nb_labels", "=", "prior_vol", ".", "shape", "[", "-", "1", "]", "\n", "prior_vol", "[", ":", ",", ":", ",", ":", ",", "1", "]", "=", "np", ".", "sum", "(", "prior_vol", "[", ":", ",", ":", ",", ":", ",", "1", ":", "nb_labels", "]", ",", "3", ")", "\n", "prior_vol", "=", "np", ".", "delete", "(", "prior_vol", ",", "range", "(", "2", ",", "nb_labels", ")", ",", "3", ")", "\n", "\n", "", "nb_channels", "=", "prior_vol", ".", "shape", "[", "-", "1", "]", "\n", "\n", "if", "extract_slice", "is", "not", "None", ":", "\n", "        ", "if", "isinstance", "(", "extract_slice", ",", "int", ")", ":", "\n", "            ", "prior_vol", "=", "prior_vol", "[", ":", ",", ":", ",", "extract_slice", ",", "np", ".", "newaxis", ",", ":", "]", "\n", "", "else", ":", "# assume slices", "\n", "            ", "prior_vol", "=", "prior_vol", "[", ":", ",", ":", ",", "extract_slice", ",", ":", "]", "\n", "\n", "# get the prior to have the right volume [x, y, z, nb_channels]", "\n", "", "", "assert", "np", ".", "ndim", "(", "prior_vol", ")", "==", "4", "or", "np", ".", "ndim", "(", "prior_vol", ")", "==", "3", ",", "\"prior is the wrong size\"", "\n", "\n", "# prior generator", "\n", "if", "patch_size", "is", "None", ":", "\n", "        ", "patch_size", "=", "prior_vol", ".", "shape", "[", "0", ":", "3", "]", "\n", "", "assert", "len", "(", "patch_size", ")", "==", "len", "(", "patch_stride", ")", "\n", "prior_gen", "=", "patch", "(", "prior_vol", ",", "[", "*", "patch_size", ",", "nb_channels", "]", ",", "\n", "patch_stride", "=", "[", "*", "patch_stride", ",", "nb_channels", "]", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "keep_vol_size", "=", "True", ",", "\n", "infinite", "=", "True", ",", "\n", "patch_rand", "=", "patch_rand", ",", "\n", "patch_rand_seed", "=", "patch_rand_seed", ",", "\n", "variable_batch_size", "=", "True", ",", "\n", "nb_labels_reshape", "=", "0", ")", "\n", "assert", "next", "(", "prior_gen", ")", "is", "None", ",", "\"bad prior gen setup\"", "\n", "\n", "# generator loop", "\n", "while", "1", ":", "\n", "\n", "# generate input and output volumes", "\n", "        ", "gen_sample", "=", "next", "(", "gen", ")", "\n", "\n", "# generate prior batch", "\n", "gs_sample", "=", "_get_shape", "(", "gen_sample", ")", "\n", "prior_batch", "=", "prior_gen", ".", "send", "(", "gs_sample", ")", "\n", "\n", "yield", "(", "gen_sample", ",", "prior_batch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol_prior": [[510, 588], ["generators.vol", "generators.vol", "generators.add_prior", "numpy.random.random", "next"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.add_prior"], ["", "", "def", "vol_prior", "(", "*", "args", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "prior_type", "=", "'location'", ",", "# file-static, file-gen, location", "\n", "prior_file", "=", "None", ",", "# prior filename", "\n", "prior_feed", "=", "'input'", ",", "# input or output", "\n", "patch_stride", "=", "1", ",", "\n", "patch_size", "=", "None", ",", "\n", "batch_size", "=", "1", ",", "\n", "collapse_2d", "=", "None", ",", "\n", "extract_slice", "=", "None", ",", "\n", "force_binary", "=", "False", ",", "\n", "nb_input_feats", "=", "1", ",", "\n", "verbose", "=", "False", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "patch_rand", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "# anything else you'd like to pass to vol()", "\n", "    ", "\"\"\"\n    generator that appends prior to (volume, segmentation) depending on input\n    e.g. could be ((volume, prior), segmentation)\n    \"\"\"", "\n", "\n", "patch_rand_seed", "=", "None", "\n", "if", "patch_rand", ":", "\n", "        ", "patch_rand_seed", "=", "np", ".", "random", ".", "random", "(", ")", "\n", "\n", "\n", "# prepare the vol_seg", "\n", "", "vol_gen", "=", "vol", "(", "*", "args", ",", "\n", "**", "kwargs", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "force_binary", "=", "False", ",", "\n", "verbose", "=", "verbose", ",", "\n", "vol_rand_seed", "=", "vol_rand_seed", ")", "\n", "gen", "=", "vol", "(", "*", "args", ",", "**", "kwargs", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "extract_slice", "=", "extract_slice", ",", "\n", "force_binary", "=", "force_binary", ",", "\n", "verbose", "=", "verbose", ",", "\n", "patch_size", "=", "patch_size", ",", "\n", "patch_stride", "=", "patch_stride", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "vol_rand_seed", "=", "vol_rand_seed", ",", "\n", "patch_rand", "=", "patch_rand", ",", "\n", "patch_rand_seed", "=", "patch_rand_seed", ",", "\n", "nb_input_feats", "=", "nb_input_feats", ")", "\n", "\n", "# add prior to output", "\n", "pgen", "=", "add_prior", "(", "gen", ",", "\n", "proc_vol_fn", "=", "proc_vol_fn", ",", "\n", "proc_seg_fn", "=", "proc_seg_fn", ",", "\n", "prior_type", "=", "prior_type", ",", "\n", "prior_file", "=", "prior_file", ",", "\n", "prior_feed", "=", "prior_feed", ",", "\n", "patch_stride", "=", "patch_stride", ",", "\n", "patch_size", "=", "patch_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "extract_slice", "=", "extract_slice", ",", "\n", "force_binary", "=", "force_binary", ",", "\n", "verbose", "=", "verbose", ",", "\n", "patch_rand", "=", "patch_rand", ",", "\n", "patch_rand_seed", "=", "patch_rand_seed", ",", "\n", "vol_rand_seed", "=", "vol_rand_seed", ")", "\n", "\n", "# generator loop", "\n", "while", "1", ":", "\n", "\n", "        ", "gen_sample", ",", "prior_batch", "=", "next", "(", "pgen", ")", "\n", "input_vol", ",", "output_vol", "=", "gen_sample", "\n", "\n", "if", "prior_feed", "==", "'input'", ":", "\n", "            ", "yield", "(", "[", "input_vol", ",", "prior_batch", "]", ",", "output_vol", ")", "\n", "", "else", ":", "\n", "            ", "assert", "prior_feed", "==", "'output'", "\n", "yield", "(", "input_vol", ",", "[", "output_vol", ",", "prior_batch", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol_seg_prior": [[590, 661], ["generators.vol_seg", "generators.add_prior", "numpy.random.random", "next"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol_seg", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.add_prior"], ["", "", "", "def", "vol_seg_prior", "(", "*", "args", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "prior_type", "=", "'location'", ",", "# file-static, file-gen, location", "\n", "prior_file", "=", "None", ",", "# prior filename", "\n", "prior_feed", "=", "'input'", ",", "# input or output", "\n", "patch_stride", "=", "1", ",", "\n", "patch_size", "=", "None", ",", "\n", "batch_size", "=", "1", ",", "\n", "collapse_2d", "=", "None", ",", "\n", "extract_slice", "=", "None", ",", "\n", "force_binary", "=", "False", ",", "\n", "nb_input_feats", "=", "1", ",", "\n", "verbose", "=", "False", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "patch_rand", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    generator that appends prior to (volume, segmentation) depending on input\n    e.g. could be ((volume, prior), segmentation)\n    \"\"\"", "\n", "\n", "\n", "patch_rand_seed", "=", "None", "\n", "if", "patch_rand", ":", "\n", "        ", "patch_rand_seed", "=", "np", ".", "random", ".", "random", "(", ")", "\n", "\n", "# prepare the vol_seg", "\n", "", "gen", "=", "vol_seg", "(", "*", "args", ",", "**", "kwargs", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "extract_slice", "=", "extract_slice", ",", "\n", "force_binary", "=", "force_binary", ",", "\n", "verbose", "=", "verbose", ",", "\n", "patch_size", "=", "patch_size", ",", "\n", "patch_stride", "=", "patch_stride", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "vol_rand_seed", "=", "vol_rand_seed", ",", "\n", "patch_rand", "=", "patch_rand", ",", "\n", "patch_rand_seed", "=", "patch_rand_seed", ",", "\n", "nb_input_feats", "=", "nb_input_feats", ")", "\n", "\n", "# add prior to output", "\n", "pgen", "=", "add_prior", "(", "gen", ",", "\n", "proc_vol_fn", "=", "proc_vol_fn", ",", "\n", "proc_seg_fn", "=", "proc_seg_fn", ",", "\n", "prior_type", "=", "prior_type", ",", "\n", "prior_file", "=", "prior_file", ",", "\n", "prior_feed", "=", "prior_feed", ",", "\n", "patch_stride", "=", "patch_stride", ",", "\n", "patch_size", "=", "patch_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "extract_slice", "=", "extract_slice", ",", "\n", "force_binary", "=", "force_binary", ",", "\n", "verbose", "=", "verbose", ",", "\n", "patch_rand", "=", "patch_rand", ",", "\n", "patch_rand_seed", "=", "patch_rand_seed", ")", "\n", "\n", "# generator loop", "\n", "while", "1", ":", "\n", "\n", "        ", "gen_sample", ",", "prior_batch", "=", "next", "(", "pgen", ")", "\n", "input_vol", ",", "output_vol", "=", "gen_sample", "\n", "\n", "if", "prior_feed", "==", "'input'", ":", "\n", "            ", "yield", "(", "[", "input_vol", ",", "prior_batch", "]", ",", "output_vol", ")", "\n", "", "else", ":", "\n", "            ", "assert", "prior_feed", "==", "'output'", "\n", "yield", "(", "input_vol", ",", "[", "output_vol", ",", "prior_batch", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol_prior_hack": [[663, 761], ["generators.vol_seg_hack", "generators.patch", "pynd.volsize2ndgrid", "numpy.transpose", "numpy.expand_dims", "numpy.sum", "numpy.delete", "isinstance", "len", "len", "next", "next", "range", "numpy.ndim", "numpy.ndim", "numpy.all", "print", "pytools.Timer", "numpy.load", "data[].astype", "pytools.Timer", "prior_vol.astype.astype"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol_seg_hack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.patch", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.volsize2ndgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], ["", "", "", "def", "vol_prior_hack", "(", "*", "args", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "prior_type", "=", "'location'", ",", "# file-static, file-gen, location", "\n", "prior_file", "=", "None", ",", "# prior filename", "\n", "prior_feed", "=", "'input'", ",", "# input or output", "\n", "patch_stride", "=", "1", ",", "\n", "patch_size", "=", "None", ",", "\n", "batch_size", "=", "1", ",", "\n", "collapse_2d", "=", "None", ",", "\n", "extract_slice", "=", "None", ",", "\n", "force_binary", "=", "False", ",", "\n", "nb_input_feats", "=", "1", ",", "\n", "verbose", "=", "False", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    \n    \"\"\"", "\n", "# prepare the vol_seg", "\n", "gen", "=", "vol_seg_hack", "(", "*", "args", ",", "**", "kwargs", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "extract_slice", "=", "extract_slice", ",", "\n", "force_binary", "=", "force_binary", ",", "\n", "verbose", "=", "verbose", ",", "\n", "patch_size", "=", "patch_size", ",", "\n", "patch_stride", "=", "patch_stride", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "vol_rand_seed", "=", "vol_rand_seed", ",", "\n", "nb_input_feats", "=", "nb_input_feats", ")", "\n", "\n", "# get prior", "\n", "if", "prior_type", "==", "'location'", ":", "\n", "        ", "prior_vol", "=", "nd", ".", "volsize2ndgrid", "(", "vol_size", ")", "\n", "prior_vol", "=", "np", ".", "transpose", "(", "prior_vol", ",", "[", "1", ",", "2", ",", "3", ",", "0", "]", ")", "\n", "prior_vol", "=", "np", ".", "expand_dims", "(", "prior_vol", ",", "axis", "=", "0", ")", "# reshape for model", "\n", "\n", "", "elif", "prior_type", "==", "'file'", ":", "# assumes a npz filename passed in prior_file", "\n", "        ", "with", "timer", ".", "Timer", "(", "'loading prior'", ",", "True", ")", ":", "\n", "            ", "data", "=", "np", ".", "load", "(", "prior_file", ")", "\n", "prior_vol", "=", "data", "[", "'prior'", "]", ".", "astype", "(", "'float16'", ")", "\n", "", "", "else", ":", "# assumes a volume", "\n", "        ", "with", "timer", ".", "Timer", "(", "'astyping prior'", ",", "verbose", ")", ":", "\n", "            ", "prior_vol", "=", "prior_file", "\n", "if", "not", "(", "prior_vol", ".", "dtype", "==", "'float16'", ")", ":", "\n", "                ", "prior_vol", "=", "prior_vol", ".", "astype", "(", "'float16'", ")", "\n", "\n", "", "", "", "if", "force_binary", ":", "\n", "        ", "nb_labels", "=", "prior_vol", ".", "shape", "[", "-", "1", "]", "\n", "prior_vol", "[", ":", ",", ":", ",", ":", ",", "1", "]", "=", "np", ".", "sum", "(", "prior_vol", "[", ":", ",", ":", ",", ":", ",", "1", ":", "nb_labels", "]", ",", "3", ")", "\n", "prior_vol", "=", "np", ".", "delete", "(", "prior_vol", ",", "range", "(", "2", ",", "nb_labels", ")", ",", "3", ")", "\n", "\n", "", "nb_channels", "=", "prior_vol", ".", "shape", "[", "-", "1", "]", "\n", "\n", "if", "extract_slice", "is", "not", "None", ":", "\n", "        ", "if", "isinstance", "(", "extract_slice", ",", "int", ")", ":", "\n", "            ", "prior_vol", "=", "prior_vol", "[", ":", ",", ":", ",", "extract_slice", ",", "np", ".", "newaxis", ",", ":", "]", "\n", "", "else", ":", "# assume slices", "\n", "            ", "prior_vol", "=", "prior_vol", "[", ":", ",", ":", ",", "extract_slice", ",", ":", "]", "\n", "\n", "# get the prior to have the right volume [x, y, z, nb_channels]", "\n", "", "", "assert", "np", ".", "ndim", "(", "prior_vol", ")", "==", "4", "or", "np", ".", "ndim", "(", "prior_vol", ")", "==", "3", ",", "\"prior is the wrong size\"", "\n", "\n", "# prior generator", "\n", "if", "patch_size", "is", "None", ":", "\n", "        ", "patch_size", "=", "prior_vol", ".", "shape", "[", "0", ":", "3", "]", "\n", "", "assert", "len", "(", "patch_size", ")", "==", "len", "(", "patch_stride", ")", "\n", "prior_gen", "=", "patch", "(", "prior_vol", ",", "[", "*", "patch_size", ",", "nb_channels", "]", ",", "\n", "patch_stride", "=", "[", "*", "patch_stride", ",", "nb_channels", "]", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "keep_vol_size", "=", "True", ",", "\n", "infinite", "=", "True", ",", "\n", "#variable_batch_size=True,  # this", "\n", "nb_labels_reshape", "=", "0", ")", "\n", "# assert next(prior_gen) is None, \"bad prior gen setup\"", "\n", "\n", "# generator loop", "\n", "while", "1", ":", "\n", "\n", "# generate input and output volumes", "\n", "        ", "input_vol", "=", "next", "(", "gen", ")", "\n", "\n", "if", "verbose", "and", "np", ".", "all", "(", "input_vol", ".", "flat", "==", "0", ")", ":", "\n", "            ", "print", "(", "\"all entries are 0\"", ")", "\n", "\n", "# generate prior batch", "\n", "# with timer.Timer(\"with send?\"):", "\n", "# prior_batch = prior_gen.send(input_vol.shape[0])", "\n", "", "prior_batch", "=", "next", "(", "prior_gen", ")", "\n", "\n", "if", "prior_feed", "==", "'input'", ":", "\n", "            ", "yield", "(", "[", "input_vol", ",", "prior_batch", "]", ",", "input_vol", ")", "\n", "", "else", ":", "\n", "            ", "assert", "prior_feed", "==", "'output'", "\n", "yield", "(", "input_vol", ",", "[", "input_vol", ",", "prior_batch", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol_seg_hack": [[763, 805], ["generators.vol", "next().astype", "next"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol"], ["", "", "", "def", "vol_seg_hack", "(", "volpath", ",", "\n", "segpath", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", "name", "=", "'vol_seg'", ",", "# name, optional", "\n", "ext", "=", "'.npz'", ",", "\n", "nb_restart_cycle", "=", "None", ",", "# number of files to restart after", "\n", "nb_labels_reshape", "=", "-", "1", ",", "\n", "collapse_2d", "=", "None", ",", "\n", "force_binary", "=", "False", ",", "\n", "nb_input_feats", "=", "1", ",", "\n", "relabel", "=", "None", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "seg_binary", "=", "False", ",", "\n", "vol_subname", "=", "'norm'", ",", "# subname of volume", "\n", "seg_subname", "=", "'aseg'", ",", "# subname of segmentation", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    generator with (volume, segmentation)\n\n    verbose is passed down to the base generators.py primitive generator (e.g. vol, here)\n\n    ** kwargs are any named arguments for vol(...),\n        except verbose, data_proc_fn, ext, nb_labels_reshape and name\n            (which this function will control when calling vol())\n    \"\"\"", "\n", "\n", "# get vol generator", "\n", "vol_gen", "=", "vol", "(", "volpath", ",", "**", "kwargs", ",", "ext", "=", "ext", ",", "\n", "nb_restart_cycle", "=", "nb_restart_cycle", ",", "collapse_2d", "=", "collapse_2d", ",", "force_binary", "=", "False", ",", "\n", "relabel", "=", "None", ",", "data_proc_fn", "=", "proc_vol_fn", ",", "nb_labels_reshape", "=", "1", ",", "name", "=", "name", "+", "' vol'", ",", "\n", "verbose", "=", "verbose", ",", "nb_feats", "=", "nb_input_feats", ",", "vol_rand_seed", "=", "vol_rand_seed", ")", "\n", "\n", "\n", "# on next (while):", "\n", "while", "1", ":", "\n", "# get input and output (seg) vols", "\n", "        ", "input_vol", "=", "next", "(", "vol_gen", ")", ".", "astype", "(", "'float16'", ")", "\n", "\n", "# output input and output", "\n", "yield", "input_vol", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.vol_sr_slices": [[807, 893], ["print", "generators._get_file_list", "len", "numpy.expand_dims", "numpy.expand_dims", "numpy.reshape", "numpy.mod", "numpy.expand_dims", "numpy.vstack", "numpy.vstack", "print", "generators._load_medical_volume", "list", "range", "os.path.join", "print", "numpy.random.randint", "range", "len", "generators.vol_sr_slices.indices_to_batch"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._get_file_list", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._load_medical_volume", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "", "def", "vol_sr_slices", "(", "volpath", ",", "\n", "nb_input_slices", ",", "\n", "nb_slice_spacing", ",", "\n", "batch_size", "=", "1", ",", "\n", "ext", "=", "'.npz'", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "nb_restart_cycle", "=", "None", ",", "\n", "name", "=", "'vol_sr_slices'", ",", "\n", "rand_slices", "=", "True", ",", "# randomize init slice order (i.e. across entries per batch) given a volume", "\n", "simulate_whole_sparse_vol", "=", "False", ",", "\n", "verbose", "=", "False", "\n", ")", ":", "\n", "    ", "\"\"\"\n    default generator for slice-wise super resolution\n    \"\"\"", "\n", "\n", "def", "indices_to_batch", "(", "vol_data", ",", "start_indices", ",", "nb_slices_in_subvol", ",", "nb_slice_spacing", ")", ":", "\n", "        ", "idx", "=", "start_indices", "[", "0", "]", "\n", "output_batch", "=", "np", ".", "expand_dims", "(", "vol_data", "[", ":", ",", ":", ",", "idx", ":", "idx", "+", "nb_slices_in_subvol", "]", ",", "0", ")", "\n", "input_batch", "=", "np", ".", "expand_dims", "(", "vol_data", "[", ":", ",", ":", ",", "idx", ":", "(", "idx", "+", "nb_slices_in_subvol", ")", ":", "(", "nb_slice_spacing", "+", "1", ")", "]", ",", "0", ")", "\n", "\n", "for", "idx", "in", "start_indices", "[", "1", ":", "]", ":", "\n", "            ", "out_sel", "=", "np", ".", "expand_dims", "(", "vol_data", "[", ":", ",", ":", ",", "idx", ":", "idx", "+", "nb_slices_in_subvol", "]", ",", "0", ")", "\n", "output_batch", "=", "np", ".", "vstack", "(", "[", "output_batch", ",", "out_sel", "]", ")", "\n", "input_batch", "=", "np", ".", "vstack", "(", "[", "input_batch", ",", "np", ".", "expand_dims", "(", "vol_data", "[", ":", ",", ":", ",", "idx", ":", "(", "idx", "+", "nb_slices_in_subvol", ")", ":", "(", "nb_slice_spacing", "+", "1", ")", "]", ",", "0", ")", "]", ")", "\n", "", "output_batch", "=", "np", ".", "reshape", "(", "output_batch", ",", "[", "batch_size", ",", "-", "1", ",", "output_batch", ".", "shape", "[", "-", "1", "]", "]", ")", "\n", "\n", "return", "(", "input_batch", ",", "output_batch", ")", "\n", "\n", "\n", "", "print", "(", "'vol_sr_slices: SHOULD PROPERLY RANDOMIZE accross different subjects'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "volfiles", "=", "_get_file_list", "(", "volpath", ",", "ext", ",", "vol_rand_seed", ")", "\n", "nb_files", "=", "len", "(", "volfiles", ")", "\n", "\n", "if", "nb_restart_cycle", "is", "None", ":", "\n", "        ", "nb_restart_cycle", "=", "nb_files", "\n", "\n", "# compute the number of slices we'll need in a subvolume", "\n", "", "nb_slices_in_subvol", "=", "(", "nb_input_slices", "-", "1", ")", "*", "(", "nb_slice_spacing", "+", "1", ")", "+", "1", "\n", "\n", "# iterate through files", "\n", "fileidx", "=", "-", "1", "\n", "while", "1", ":", "\n", "        ", "fileidx", "=", "np", ".", "mod", "(", "fileidx", "+", "1", ",", "nb_restart_cycle", ")", "\n", "if", "verbose", "and", "fileidx", "==", "0", ":", "\n", "            ", "print", "(", "'starting %s cycle'", "%", "name", ")", "\n", "\n", "\n", "", "try", ":", "\n", "            ", "vol_data", "=", "_load_medical_volume", "(", "os", ".", "path", ".", "join", "(", "volpath", ",", "volfiles", "[", "fileidx", "]", ")", ",", "ext", ",", "verbose", ")", "\n", "", "except", ":", "\n", "            ", "debug_error_msg", "=", "\"#files: %d, fileidx: %d, nb_restart_cycle: %d. error: %s\"", "\n", "print", "(", "debug_error_msg", "%", "(", "len", "(", "volfiles", ")", ",", "fileidx", ",", "nb_restart_cycle", ",", "sys", ".", "exc_info", "(", ")", "[", "0", "]", ")", ")", "\n", "raise", "\n", "\n", "# compute some random slice", "\n", "", "nb_slices", "=", "vol_data", ".", "shape", "[", "2", "]", "\n", "nb_start_slices", "=", "nb_slices", "-", "nb_slices_in_subvol", "+", "1", "\n", "\n", "# prepare batches", "\n", "if", "simulate_whole_sparse_vol", ":", "# if essentially simulate a whole sparse volume for consistent inputs, and yield slices like that:", "\n", "            ", "init_slice", "=", "0", "\n", "if", "rand_slices", ":", "\n", "                ", "init_slice", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "high", "=", "nb_start_slices", "-", "1", ")", "\n", "\n", "", "all_start_indices", "=", "list", "(", "range", "(", "init_slice", ",", "nb_start_slices", ",", "nb_slice_spacing", "+", "1", ")", ")", "\n", "\n", "for", "batch_start", "in", "range", "(", "0", ",", "len", "(", "all_start_indices", ")", ",", "batch_size", "*", "(", "nb_input_slices", "-", "1", ")", ")", ":", "\n", "                ", "start_indices", "=", "[", "all_start_indices", "[", "s", "]", "for", "s", "in", "range", "(", "batch_start", ",", "batch_start", "+", "batch_size", ")", "]", "\n", "input_batch", ",", "output_batch", "=", "indices_to_batch", "(", "vol_data", ",", "start_indices", ",", "nb_slices_in_subvol", ",", "nb_slice_spacing", ")", "\n", "yield", "(", "input_batch", ",", "output_batch", ")", "\n", "\n", "# if just random slices, get a batch of random starts from this volume and that's it.", "\n", "", "", "elif", "rand_slices", ":", "\n", "            ", "assert", "not", "simulate_whole_sparse_vol", "\n", "start_indices", "=", "np", ".", "random", ".", "choice", "(", "range", "(", "nb_start_slices", ")", ",", "size", "=", "batch_size", ",", "replace", "=", "False", ")", "\n", "input_batch", ",", "output_batch", "=", "indices_to_batch", "(", "vol_data", ",", "start_indices", ",", "nb_slices_in_subvol", ",", "nb_slice_spacing", ")", "\n", "yield", "(", "input_batch", ",", "output_batch", ")", "\n", "\n", "# go slice by slice (overlapping regions)", "\n", "", "else", ":", "\n", "            ", "for", "batch_start", "in", "range", "(", "0", ",", "nb_start_slices", ",", "batch_size", ")", ":", "\n", "                ", "start_indices", "=", "list", "(", "range", "(", "batch_start", ",", "batch_start", "+", "batch_size", ")", ")", "\n", "input_batch", ",", "output_batch", "=", "indices_to_batch", "(", "vol_data", ",", "start_indices", ",", "nb_slices_in_subvol", ",", "nb_slice_spacing", ")", "\n", "yield", "(", "input_batch", ",", "output_batch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators.img_seg": [[895, 935], ["generators.img_seg.imggen"], "function", ["None"], ["", "", "", "", "def", "img_seg", "(", "volpath", ",", "\n", "segpath", ",", "\n", "batch_size", "=", "1", ",", "\n", "verbose", "=", "False", ",", "\n", "nb_restart_cycle", "=", "None", ",", "\n", "name", "=", "'img_seg'", ",", "# name, optional", "\n", "ext", "=", "'.png'", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    generator for (image, segmentation)\n    \"\"\"", "\n", "\n", "def", "imggen", "(", "path", ",", "ext", ",", "nb_restart_cycle", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        TODO: should really use the volume generators for this\n        \"\"\"", "\n", "files", "=", "_get_file_list", "(", "path", ",", "ext", ",", "vol_rand_seed", ")", "\n", "if", "nb_restart_cycle", "is", "None", ":", "\n", "            ", "nb_restart_cycle", "=", "len", "(", "files", ")", "\n", "\n", "", "idx", "=", "-", "1", "\n", "while", "1", ":", "\n", "            ", "idx", "=", "np", ".", "mod", "(", "idx", "+", "1", ",", "nb_restart_cycle", ")", "\n", "im", "=", "scipy", ".", "misc", ".", "imread", "(", "os", ".", "path", ".", "join", "(", "path", ",", "files", "[", "idx", "]", ")", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "yield", "im", ".", "reshape", "(", "(", "1", ",", ")", "+", "im", ".", "shape", ")", "\n", "\n", "", "", "img_gen", "=", "imggen", "(", "volpath", ",", "ext", ",", "nb_restart_cycle", ")", "\n", "seg_gen", "=", "imggen", "(", "segpath", ",", "ext", ")", "\n", "\n", "# on next (while):", "\n", "while", "1", ":", "\n", "        ", "input_vol", "=", "np", ".", "vstack", "(", "[", "next", "(", "img_gen", ")", ".", "astype", "(", "'float16'", ")", "/", "255", "for", "i", "in", "range", "(", "batch_size", ")", "]", ")", "\n", "input_vol", "=", "np", ".", "expand_dims", "(", "input_vol", ",", "axis", "=", "-", "1", ")", "\n", "\n", "output_vols", "=", "[", "np_utils", ".", "to_categorical", "(", "next", "(", "seg_gen", ")", ".", "astype", "(", "'int8'", ")", ",", "num_classes", "=", "2", ")", "for", "i", "in", "range", "(", "batch_size", ")", "]", "\n", "output_vol", "=", "np", ".", "vstack", "(", "[", "np", ".", "expand_dims", "(", "f", ",", "axis", "=", "0", ")", "for", "f", "in", "output_vols", "]", ")", "\n", "\n", "# output input and output", "\n", "yield", "(", "input_vol", ",", "output_vol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._get_file_list": [[939, 948], ["numpy.random.seed", "numpy.random.permutation().tolist", "sorted", "os.listdir", "f.endswith", "numpy.random.permutation"], "function", ["None"], ["", "", "def", "_get_file_list", "(", "volpath", ",", "ext", "=", "None", ",", "vol_rand_seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    get a list of files at the given path with the given extension\n    \"\"\"", "\n", "files", "=", "[", "f", "for", "f", "in", "sorted", "(", "os", ".", "listdir", "(", "volpath", ")", ")", "if", "ext", "is", "None", "or", "f", ".", "endswith", "(", "ext", ")", "]", "\n", "if", "vol_rand_seed", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "vol_rand_seed", ")", "\n", "files", "=", "np", ".", "random", ".", "permutation", "(", "files", ")", ".", "tolist", "(", ")", "\n", "", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._load_medical_volume": [[950, 967], ["pytools.Timer", "numpy.load", "numpy.load", "nibabel.load", "nib.load.get_data", "ValueError"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], ["", "def", "_load_medical_volume", "(", "filename", ",", "ext", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    load a medical volume from one of a number of file types\n    \"\"\"", "\n", "with", "timer", ".", "Timer", "(", "'load_vol'", ",", "verbose", ">=", "2", ")", ":", "\n", "        ", "if", "ext", "==", "'.npz'", ":", "\n", "            ", "vol_file", "=", "np", ".", "load", "(", "filename", ")", "\n", "vol_data", "=", "vol_file", "[", "'vol_data'", "]", "\n", "", "elif", "ext", "==", "'npy'", ":", "\n", "            ", "vol_data", "=", "np", ".", "load", "(", "filename", ")", "\n", "", "elif", "ext", "==", "'.mgz'", "or", "ext", "==", "'.nii'", "or", "ext", "==", "'.nii.gz'", ":", "\n", "            ", "vol_med", "=", "nib", ".", "load", "(", "filename", ")", "\n", "vol_data", "=", "vol_med", ".", "get_data", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unexpected extension %s\"", "%", "ext", ")", "\n", "\n", "", "", "return", "vol_data", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._categorical_prep": [[969, 984], ["numpy.expand_dims", "generators._to_categorical", "numpy.expand_dims"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._to_categorical"], ["", "def", "_categorical_prep", "(", "vol_data", ",", "nb_labels_reshape", ",", "keep_vol_size", ",", "patch_size", ")", ":", "\n", "\n", "    ", "if", "nb_labels_reshape", ">", "1", ":", "\n", "\n", "        ", "lpatch", "=", "_to_categorical", "(", "vol_data", ",", "nb_labels_reshape", ",", "keep_vol_size", ")", "\n", "# if keep_vol_size:", "\n", "# lpatch = np.reshape(lpatch, [*patch_size, nb_labels_reshape])", "\n", "", "elif", "nb_labels_reshape", "==", "1", ":", "\n", "        ", "lpatch", "=", "np", ".", "expand_dims", "(", "vol_data", ",", "axis", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "assert", "nb_labels_reshape", "==", "0", "\n", "lpatch", "=", "vol_data", "\n", "", "lpatch", "=", "np", ".", "expand_dims", "(", "lpatch", ",", "axis", "=", "0", ")", "\n", "\n", "return", "lpatch", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._to_categorical": [[987, 1015], ["numpy.array().ravel", "numpy.zeros", "numpy.reshape", "numpy.array", "numpy.max", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange"], ["", "def", "_to_categorical", "(", "y", ",", "num_classes", "=", "None", ",", "reshape", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    # copy of keras.utils.np_utils.to_categorical, but with a boolean matrix instead of float\n\n    Converts a class vector (integers) to binary class matrix.\n\n    E.g. for use with categorical_crossentropy.\n\n    # Arguments\n        y: class vector to be converted into a matrix\n            (integers from 0 to num_classes).\n        num_classes: total number of classes.\n\n    # Returns\n        A binary matrix representation of the input.\n    \"\"\"", "\n", "oshape", "=", "y", ".", "shape", "\n", "y", "=", "np", ".", "array", "(", "y", ",", "dtype", "=", "'int'", ")", ".", "ravel", "(", ")", "\n", "if", "not", "num_classes", ":", "\n", "        ", "num_classes", "=", "np", ".", "max", "(", "y", ")", "+", "1", "\n", "", "n", "=", "y", ".", "shape", "[", "0", "]", "\n", "categorical", "=", "np", ".", "zeros", "(", "(", "n", ",", "num_classes", ")", ",", "bool", ")", "\n", "categorical", "[", "np", ".", "arange", "(", "n", ")", ",", "y", "]", "=", "1", "\n", "\n", "if", "reshape", ":", "\n", "        ", "categorical", "=", "np", ".", "reshape", "(", "categorical", ",", "[", "*", "oshape", ",", "num_classes", "]", ")", "\n", "\n", "", "return", "categorical", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._relabel": [[1016, 1028], ["numpy.zeros", "numpy.ndenumerate", "numpy.unique", "len", "len"], "function", ["None"], ["", "def", "_relabel", "(", "vol_data", ",", "labels", ",", "forcecheck", "=", "False", ")", ":", "\n", "\n", "    ", "if", "forcecheck", ":", "\n", "        ", "vd", "=", "np", ".", "unique", "(", "vol_data", ".", "flat", ")", "\n", "assert", "len", "(", "vd", ")", "==", "len", "(", "labels", ")", ",", "\"number of given labels does not match number of actual labels\"", "\n", "\n", "# by doing zeros, any label not in labels gets left to 0", "\n", "", "new_vol_data", "=", "np", ".", "zeros", "(", "vol_data", ".", "shape", ",", "vol_data", ".", "dtype", ")", "\n", "for", "idx", ",", "val", "in", "np", ".", "ndenumerate", "(", "labels", ")", ":", "\n", "        ", "new_vol_data", "[", "vol_data", "==", "val", "]", "=", "idx", "\n", "\n", "", "return", "new_vol_data", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._npz_headers": [[1030, 1052], ["zipfile.ZipFile", "archive.namelist", "archive.open", "numpy.lib.format.read_magic", "numpy.lib.format._read_array_header", "name.endswith"], "function", ["None"], ["", "def", "_npz_headers", "(", "npz", ",", "namelist", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    taken from https://stackoverflow.com/a/43223420\n\n    Takes a path to an .npz file, which is a Zip archive of .npy files.\n    Generates a sequence of (name, shape, np.dtype).\n\n    namelist is a list with variable names, ending in '.npy'. \n    e.g. if variable 'var' is in the file, namelist could be ['var.npy']\n    \"\"\"", "\n", "with", "zipfile", ".", "ZipFile", "(", "npz", ")", "as", "archive", ":", "\n", "        ", "if", "namelist", "is", "None", ":", "\n", "            ", "namelist", "=", "archive", ".", "namelist", "(", ")", "\n", "\n", "", "for", "name", "in", "namelist", ":", "\n", "            ", "if", "not", "name", ".", "endswith", "(", "'.npy'", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "npy", "=", "archive", ".", "open", "(", "name", ")", "\n", "version", "=", "np", ".", "lib", ".", "format", ".", "read_magic", "(", "npy", ")", "\n", "shape", ",", "fortran", ",", "dtype", "=", "np", ".", "lib", ".", "format", ".", "_read_array_header", "(", "npy", ",", "version", ")", "\n", "yield", "name", "[", ":", "-", "4", "]", ",", "shape", ",", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._get_shape": [[1053, 1058], ["isinstance", "generators._get_shape"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.generators._get_shape"], ["", "", "", "def", "_get_shape", "(", "x", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "return", "_get_shape", "(", "x", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "x", ".", "shape", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Negate.__init__": [[45, 47], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Negate", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Negate.build": [[48, 50], ["super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "Negate", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Negate.call": [[51, 53], ["None"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "-", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Negate.compute_output_shape": [[54, 56], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleValues.__init__": [[63, 66], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "resize", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "resize", "=", "resize", "\n", "super", "(", "RescaleValues", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleValues.get_config": [[67, 71], ["super().get_config().copy", "super().get_config().copy.update", "super().get_config"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.LoadableModel.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", ".", "copy", "(", ")", "\n", "config", ".", "update", "(", "{", "'resize'", ":", "self", ".", "resize", "}", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleValues.build": [[72, 74], ["super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "RescaleValues", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleValues.call": [[75, 77], ["None"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "resize", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleValues.compute_output_shape": [[78, 80], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Resize.__init__": [[95, 110], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "\n", "zoom_factor", ",", "\n", "interp_method", "=", "'linear'", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Parameters: \n            interp_method: 'linear' or 'nearest'\n                'xy' indexing will have the first two entries of the flow \n                (along last axis) flipped compared to 'ij' indexing\n        \"\"\"", "\n", "self", ".", "zoom_factor", "=", "zoom_factor", "\n", "self", ".", "interp_method", "=", "interp_method", "\n", "self", ".", "ndims", "=", "None", "\n", "self", ".", "inshape", "=", "None", "\n", "super", "(", "Resize", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Resize.get_config": [[111, 118], ["super().get_config().copy", "super().get_config().copy.update", "super().get_config"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.LoadableModel.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", ".", "copy", "(", ")", "\n", "config", ".", "update", "(", "{", "\n", "'zoom_factor'", ":", "self", ".", "zoom_factor", ",", "\n", "'interp_method'", ":", "self", ".", "interp_method", ",", "\n", "}", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Resize.build": [[119, 146], ["isinstance", "super().build", "isinstance", "Exception", "len", "isinstance", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "\"\"\"\n        input_shape should be an element of list of one inputs:\n        input1: volume\n                should be a *vol_shape x N\n        \"\"\"", "\n", "\n", "if", "isinstance", "(", "input_shape", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", "and", "len", "(", "input_shape", ")", ">", "1", ":", "\n", "            ", "raise", "Exception", "(", "'Resize must be called on a list of length 1.'", ")", "\n", "\n", "", "if", "isinstance", "(", "input_shape", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "input_shape", "=", "input_shape", "[", "0", "]", "\n", "\n", "# set up number of dimensions", "\n", "", "self", ".", "ndims", "=", "len", "(", "input_shape", ")", "-", "2", "\n", "self", ".", "inshape", "=", "input_shape", "\n", "if", "not", "isinstance", "(", "self", ".", "zoom_factor", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "self", ".", "zoom_factor", "=", "[", "self", ".", "zoom_factor", "]", "*", "self", ".", "ndims", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "self", ".", "zoom_factor", ")", "==", "self", ".", "ndims", ",", "'zoom factor length {} does not match number of dimensions {}'", ".", "format", "(", "len", "(", "self", ".", "zoom_factor", ")", ",", "self", ".", "ndims", ")", "\n", "\n", "# confirm built", "\n", "", "self", ".", "built", "=", "True", "\n", "\n", "super", "(", "Resize", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Resize.call": [[148, 166], ["isinstance", "tensorflow.keras.backend.reshape", "tensorflow.map_fn", "len", "len"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n            inputs: volume of list with one volume\n        \"\"\"", "\n", "\n", "# check shapes", "\n", "if", "isinstance", "(", "inputs", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "assert", "len", "(", "inputs", ")", "==", "1", ",", "\"inputs has to be len 1. found: %d\"", "%", "len", "(", "inputs", ")", "\n", "vol", "=", "inputs", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "vol", "=", "inputs", "\n", "\n", "# necessary for multi_gpu models...", "\n", "", "vol", "=", "K", ".", "reshape", "(", "vol", ",", "[", "-", "1", ",", "*", "self", ".", "inshape", "[", "1", ":", "]", "]", ")", "\n", "\n", "# map transform across batch", "\n", "return", "tf", ".", "map_fn", "(", "self", ".", "_single_resize", ",", "vol", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Resize.compute_output_shape": [[167, 173], ["tuple", "int", "range"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "\n", "        ", "output_shape", "=", "[", "input_shape", "[", "0", "]", "]", "\n", "output_shape", "+=", "[", "int", "(", "input_shape", "[", "1", ":", "-", "1", "]", "[", "f", "]", "*", "self", ".", "zoom_factor", "[", "f", "]", ")", "for", "f", "in", "range", "(", "self", ".", "ndims", ")", "]", "\n", "output_shape", "+=", "[", "input_shape", "[", "-", "1", "]", "]", "\n", "return", "tuple", "(", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.Resize._single_resize": [[174, 176], ["utils.resize"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.resize"], ["", "def", "_single_resize", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "return", "utils", ".", "resize", "(", "inputs", ",", "self", ".", "zoom_factor", ",", "interp_method", "=", "self", ".", "interp_method", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MSE.__init__": [[186, 188], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "MSE", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MSE.build": [[189, 191], ["super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "MSE", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MSE.call": [[192, 194], ["tensorflow.keras.backend.mean", "tensorflow.keras.backend.batch_flatten", "tensorflow.keras.backend.square"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "K", ".", "mean", "(", "K", ".", "batch_flatten", "(", "K", ".", "square", "(", "x", "[", "0", "]", "-", "x", "[", "1", "]", ")", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MSE.compute_output_shape": [[195, 197], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "(", "input_shape", "[", "0", "]", "[", "0", "]", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.GaussianBlur.__init__": [[205, 222], ["tensorflow.keras.layers.Layer.__init__", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "level", "=", "None", ",", "sigma", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "sigma", "is", "not", "None", "or", "level", "is", "not", "None", ",", "'sigma or level must be provided'", "\n", "assert", "not", "(", "sigma", "is", "not", "None", "and", "level", "is", "not", "None", ")", ",", "'only sigma or level must be provided'", "\n", "\n", "if", "level", "is", "not", "None", ":", "\n", "            ", "if", "level", "<", "1", ":", "\n", "                ", "raise", "ValueError", "(", "'Gaussian blur level must not be less than 1'", ")", "\n", "\n", "", "self", ".", "sigma", "=", "(", "level", "-", "1", ")", "**", "2", "\n", "\n", "", "else", ":", "\n", "            ", "if", "sigma", "<", "0", ":", "\n", "                ", "raise", "ValueError", "(", "'Gaussian blur sigma must not be less than 0'", ")", "\n", "\n", "", "self", ".", "sigma", "=", "sigma", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.GaussianBlur.build": [[223, 234], ["utils.gaussian_kernel", "tensorflow.reshape", "getattr", "len", "getattr.", "tensorflow.reshape.shape.as_list", "tensorflow.expand_dims"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.gaussian_kernel"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "ndims", "=", "len", "(", "input_shape", ")", "-", "2", "\n", "\n", "# prepare kernel", "\n", "kernel", "=", "utils", ".", "gaussian_kernel", "(", "[", "self", ".", "sigma", "]", "*", "ndims", ")", "\n", "kernel", "=", "tf", ".", "reshape", "(", "kernel", ",", "kernel", ".", "shape", ".", "as_list", "(", ")", "+", "[", "1", ",", "1", "]", ")", "\n", "\n", "# prepare convoperation", "\n", "convnd", "=", "getattr", "(", "tf", ".", "nn", ",", "'conv%dd'", "%", "ndims", ")", "\n", "self", ".", "conv", "=", "lambda", "x", ":", "convnd", "(", "tf", ".", "expand_dims", "(", "x", ",", "-", "1", ")", ",", "kernel", ",", "[", "1", "]", "*", "(", "ndims", "+", "2", ")", ",", "padding", "=", "'SAME'", ")", "\n", "self", ".", "nfeat", "=", "input_shape", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.GaussianBlur.call": [[235, 238], ["tensorflow.concat", "layers.GaussianBlur.conv", "range"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "# TODO: switch to mutli-line if statement", "\n", "        ", "return", "x", "if", "self", ".", "sigma", "==", "0", "else", "tf", ".", "concat", "(", "[", "self", ".", "conv", "(", "x", "[", "...", ",", "n", "]", ")", "for", "n", "in", "range", "(", "self", ".", "nfeat", ")", "]", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.GaussianBlur.compute_output_shape": [[239, 241], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatiallySparse_Dense.__init__": [[262, 272], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "output_len", ",", "use_bias", "=", "False", ",", "\n", "kernel_initializer", "=", "'RandomNormal'", ",", "\n", "bias_initializer", "=", "'RandomNormal'", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "kernel_initializer", "=", "kernel_initializer", "\n", "self", ".", "bias_initializer", "=", "bias_initializer", "\n", "self", ".", "output_len", "=", "output_len", "\n", "self", ".", "cargs", "=", "0", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "self", ".", "orig_input_shape", "=", "input_shape", "# just the image size", "\n", "super", "(", "SpatiallySparse_Dense", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatiallySparse_Dense.build": [[273, 301], ["layers.SpatiallySparse_Dense.add_weight", "tensorflow.keras.backend.reshape", "tensorflow.keras.backend.transpose", "tensorflow.matrix_inverse", "tensorflow.keras.backend.dot", "super().build", "tensorflow.keras.backend.dot", "layers.SpatiallySparse_Dense.add_weight", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "\n", "\n", "\n", "# Create a trainable weight variable for this layer.", "\n", "        ", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "name", "=", "'mult-kernel'", ",", "\n", "shape", "=", "(", "np", ".", "prod", "(", "self", ".", "orig_input_shape", ")", ",", "\n", "self", ".", "output_len", ")", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "\n", "M", "=", "K", ".", "reshape", "(", "self", ".", "kernel", ",", "[", "-", "1", ",", "self", ".", "output_len", "]", ")", "# D x d", "\n", "mt", "=", "K", ".", "transpose", "(", "M", ")", "# d x D", "\n", "mtm_inv", "=", "tf", ".", "matrix_inverse", "(", "K", ".", "dot", "(", "mt", ",", "M", ")", ")", "# d x d", "\n", "self", ".", "W", "=", "K", ".", "dot", "(", "mtm_inv", ",", "mt", ")", "# d x D", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "            ", "self", ".", "bias", "=", "self", ".", "add_weight", "(", "name", "=", "'bias-kernel'", ",", "\n", "shape", "=", "(", "self", ".", "output_len", ",", ")", ",", "\n", "initializer", "=", "self", ".", "bias_initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "\n", "# self.sigma_sq = self.add_weight(name='bias-kernel',", "\n", "#                                 shape=(1, ),", "\n", "#                                 initializer=self.initializer,", "\n", "#                                 trainable=True)", "\n", "\n", "", "super", "(", "SpatiallySparse_Dense", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatiallySparse_Dense.call": [[302, 347], ["len", "isinstance", "len", "int", "tensorflow.keras.backend.repeat_elements", "tensorflow.keras.backend.batch_flatten", "tensorflow.keras.backend.batch_flatten", "tensorflow.keras.backend.expand_dims", "tensorflow.keras.backend.permute_dimensions", "tensorflow.matrix_inverse", "tensorflow.keras.backend.batch_dot", "tensorflow.keras.backend.batch_dot", "tensorflow.keras.backend.shape", "tensorflow.keras.backend.batch_flatten", "tensorflow.keras.backend.dot", "tensorflow.stack", "tensorflow.keras.backend.reshape", "tensorflow.keras.backend.permute_dimensions", "tensorflow.keras.backend.expand_dims", "tensorflow.keras.backend.batch_dot", "tensorflow.keras.backend.expand_dims", "y.get_shape().as_list", "tensorflow.keras.backend.repeat_elements.get_shape().as_list", "y.get_shape", "tensorflow.keras.backend.repeat_elements.get_shape"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack"], ["", "def", "call", "(", "self", ",", "args", ")", ":", "\n", "\n", "        ", "if", "not", "isinstance", "(", "args", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "args", "=", "[", "args", "]", "\n", "", "self", ".", "cargs", "=", "len", "(", "args", ")", "\n", "\n", "# flatten", "\n", "if", "len", "(", "args", ")", "==", "2", ":", "# input y, m", "\n", "# get inputs", "\n", "            ", "y", ",", "y_mask", "=", "args", "\n", "a_fact", "=", "int", "(", "y", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", "/", "y_mask", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", ")", "\n", "y_mask", "=", "K", ".", "repeat_elements", "(", "y_mask", ",", "a_fact", ",", "-", "1", ")", "\n", "y_flat", "=", "K", ".", "batch_flatten", "(", "y", ")", "# N x D", "\n", "y_mask_flat", "=", "K", ".", "batch_flatten", "(", "y_mask", ")", "# N x D", "\n", "\n", "# prepare switching matrix", "\n", "W", "=", "self", ".", "W", "# d x D", "\n", "\n", "w_tmp", "=", "K", ".", "expand_dims", "(", "W", ",", "0", ")", "# 1 x d x D", "\n", "Wo", "=", "K", ".", "permute_dimensions", "(", "w_tmp", ",", "[", "0", ",", "2", ",", "1", "]", ")", "*", "K", ".", "expand_dims", "(", "y_mask_flat", ",", "-", "1", ")", "# N x D x d", "\n", "WoT", "=", "K", ".", "permute_dimensions", "(", "Wo", ",", "[", "0", ",", "2", ",", "1", "]", ")", "# N x d x D", "\n", "WotWo_inv", "=", "tf", ".", "matrix_inverse", "(", "K", ".", "batch_dot", "(", "WoT", ",", "Wo", ")", ")", "# N x d x d", "\n", "pre", "=", "K", ".", "batch_dot", "(", "WotWo_inv", ",", "WoT", ")", "# N x d x D", "\n", "res", "=", "K", ".", "batch_dot", "(", "pre", ",", "y_flat", ")", "# N x d", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "                ", "res", "+=", "K", ".", "expand_dims", "(", "self", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "x_data", "=", "args", "[", "0", "]", "\n", "shape", "=", "K", ".", "shape", "(", "x_data", ")", "\n", "\n", "x_data", "=", "K", ".", "batch_flatten", "(", "x_data", ")", "# N x d", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "                ", "x_data", "-=", "self", ".", "bias", "\n", "\n", "", "res", "=", "K", ".", "dot", "(", "x_data", ",", "self", ".", "W", ")", "\n", "\n", "# reshape", "\n", "# Here you can mix integers and symbolic elements of `shape`", "\n", "pool_shape", "=", "tf", ".", "stack", "(", "[", "shape", "[", "0", "]", ",", "*", "self", ".", "orig_input_shape", "]", ")", "\n", "res", "=", "K", ".", "reshape", "(", "res", ",", "pool_shape", ")", "\n", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatiallySparse_Dense.compute_output_shape": [[348, 354], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "# print(self.cargs, input_shape, self.output_len, self.orig_input_shape)", "\n", "        ", "if", "self", ".", "cargs", "==", "2", ":", "\n", "            ", "return", "(", "input_shape", "[", "0", "]", "[", "0", "]", ",", "self", ".", "output_len", ")", "\n", "", "else", ":", "\n", "            ", "return", "(", "input_shape", "[", "0", "]", ",", "*", "self", ".", "orig_input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalBias.__init__": [[366, 370], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "my_initializer", "=", "'RandomNormal'", ",", "biasmult", "=", "1.0", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "initializer", "=", "my_initializer", "\n", "self", ".", "biasmult", "=", "biasmult", "\n", "super", "(", "LocalBias", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalBias.build": [[371, 378], ["layers.LocalBias.add_weight", "super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# Create a trainable weight variable for this layer.", "\n", "        ", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "name", "=", "'kernel'", ",", "\n", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "\n", "initializer", "=", "self", ".", "initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "super", "(", "LocalBias", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalBias.call": [[379, 381], ["None"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "+", "self", ".", "kernel", "*", "self", ".", "biasmult", "# weights are difference from input", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalBias.compute_output_shape": [[382, 384], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalLinear.__init__": [[392, 395], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "initializer", "=", "'RandomNormal'", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "initializer", "=", "initializer", "\n", "super", "(", "LocalLinear", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalLinear.build": [[396, 407], ["layers.LocalLinear.add_weight", "layers.LocalLinear.add_weight", "super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# Create a trainable weight variable for this layer.", "\n", "        ", "self", ".", "mult", "=", "self", ".", "add_weight", "(", "name", "=", "'mult-kernel'", ",", "\n", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "\n", "initializer", "=", "self", ".", "initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "self", ".", "bias", "=", "self", ".", "add_weight", "(", "name", "=", "'bias-kernel'", ",", "\n", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "\n", "initializer", "=", "self", ".", "initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "super", "(", "LocalLinear", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalLinear.call": [[408, 410], ["None"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "mult", "+", "self", ".", "bias", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalLinear.compute_output_shape": [[411, 413], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.__init__": [[516, 554], ["tensorflow.keras.layers.Layer.__init__", "tensorflow.python.keras.utils.conv_utils.normalize_tuple", "tensorflow.python.keras.utils.conv_utils.normalize_tuple", "tensorflow.python.keras.utils.conv_utils.normalize_padding", "tensorflow.python.keras.utils.conv_utils.normalize_data_format", "tensorflow.keras.activations.get", "tensorflow.keras.initializers.get", "tensorflow.keras.initializers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "tensorflow.python.keras.engine.input_spec.InputSpec", "ValueError"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "\n", "filters", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "padding", "=", "'valid'", ",", "\n", "data_format", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "implementation", "=", "1", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "LocallyConnected3D", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "filters", "=", "filters", "\n", "self", ".", "kernel_size", "=", "conv_utils", ".", "normalize_tuple", "(", "kernel_size", ",", "3", ",", "'kernel_size'", ")", "\n", "self", ".", "strides", "=", "conv_utils", ".", "normalize_tuple", "(", "strides", ",", "3", ",", "'strides'", ")", "\n", "self", ".", "padding", "=", "conv_utils", ".", "normalize_padding", "(", "padding", ")", "\n", "if", "self", ".", "padding", "!=", "'valid'", "and", "implementation", "==", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Invalid border mode for LocallyConnected3D '", "\n", "'(only \"valid\" is supported if implementation is 1): '", "\n", "+", "padding", ")", "\n", "", "self", ".", "data_format", "=", "conv_utils", ".", "normalize_data_format", "(", "data_format", ")", "\n", "self", ".", "activation", "=", "tf", ".", "keras", ".", "activations", ".", "get", "(", "activation", ")", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "self", ".", "kernel_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "get", "(", "kernel_initializer", ")", "\n", "self", ".", "bias_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "get", "(", "bias_initializer", ")", "\n", "self", ".", "kernel_regularizer", "=", "tf", ".", "keras", ".", "regularizers", ".", "get", "(", "kernel_regularizer", ")", "\n", "self", ".", "bias_regularizer", "=", "tf", ".", "keras", ".", "regularizers", ".", "get", "(", "bias_regularizer", ")", "\n", "self", ".", "activity_regularizer", "=", "tf", ".", "keras", ".", "regularizers", ".", "get", "(", "activity_regularizer", ")", "\n", "self", ".", "kernel_constraint", "=", "tf", ".", "keras", ".", "constraints", ".", "get", "(", "kernel_constraint", ")", "\n", "self", ".", "bias_constraint", "=", "tf", ".", "keras", ".", "constraints", ".", "get", "(", "bias_constraint", ")", "\n", "self", ".", "implementation", "=", "implementation", "\n", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.build": [[555, 653], ["tensorflow.python.keras.utils.conv_utils.conv_output_length", "tensorflow.python.keras.utils.conv_utils.conv_output_length", "tensorflow.python.keras.utils.conv_utils.conv_output_length", "ValueError", "layers.LocallyConnected3D.add_weight", "layers.LocallyConnected3D.add_weight", "tensorflow.python.keras.engine.input_spec.InputSpec", "tensorflow.python.keras.engine.input_spec.InputSpec", "layers.LocallyConnected3D.add_weight", "layers.LocallyConnected3D.get_locallyconnected_mask", "str", "sorted", "layers.LocallyConnected3D.add_weight", "ValueError", "layers.LocallyConnected3D.conv_kernel_idxs", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.get_locallyconnected_mask", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.conv_kernel_idxs"], ["", "@", "tf_utils", ".", "shape_type_conversion", "\n", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "if", "self", ".", "data_format", "==", "'channels_last'", ":", "\n", "            ", "input_row", ",", "input_col", ",", "input_z", "=", "input_shape", "[", "1", ":", "-", "1", "]", "\n", "input_filter", "=", "input_shape", "[", "4", "]", "\n", "", "else", ":", "\n", "            ", "input_row", ",", "input_col", ",", "input_z", "=", "input_shape", "[", "2", ":", "]", "\n", "input_filter", "=", "input_shape", "[", "1", "]", "\n", "", "if", "input_row", "is", "None", "or", "input_col", "is", "None", "or", "input_z", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'The spatial dimensions of the inputs to '", "\n", "' a LocallyConnected3D layer '", "\n", "'should be fully-defined, but layer received '", "\n", "'the inputs shape '", "+", "str", "(", "input_shape", ")", ")", "\n", "", "output_row", "=", "conv_utils", ".", "conv_output_length", "(", "\n", "input_row", ",", "self", ".", "kernel_size", "[", "0", "]", ",", "self", ".", "padding", ",", "self", ".", "strides", "[", "0", "]", ")", "\n", "output_col", "=", "conv_utils", ".", "conv_output_length", "(", "\n", "input_col", ",", "self", ".", "kernel_size", "[", "1", "]", ",", "self", ".", "padding", ",", "self", ".", "strides", "[", "1", "]", ")", "\n", "output_z", "=", "conv_utils", ".", "conv_output_length", "(", "\n", "input_z", ",", "self", ".", "kernel_size", "[", "2", "]", ",", "self", ".", "padding", ",", "self", ".", "strides", "[", "2", "]", ")", "\n", "self", ".", "output_row", "=", "output_row", "\n", "self", ".", "output_col", "=", "output_col", "\n", "self", ".", "output_z", "=", "output_z", "\n", "\n", "if", "self", ".", "implementation", "==", "1", ":", "\n", "            ", "self", ".", "kernel_shape", "=", "(", "\n", "output_row", "*", "output_col", "*", "output_z", ",", "\n", "self", ".", "kernel_size", "[", "0", "]", "*", "self", ".", "kernel_size", "[", "1", "]", "*", "self", ".", "kernel_size", "[", "2", "]", "*", "input_filter", ",", "\n", "self", ".", "filters", ")", "\n", "\n", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "\n", "shape", "=", "self", ".", "kernel_shape", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "name", "=", "'kernel'", ",", "\n", "regularizer", "=", "self", ".", "kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "kernel_constraint", ")", "\n", "\n", "", "elif", "self", ".", "implementation", "==", "2", ":", "\n", "            ", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "              ", "self", ".", "kernel_shape", "=", "(", "input_filter", ",", "input_row", ",", "input_col", ",", "input_z", ",", "\n", "self", ".", "filters", ",", "self", ".", "output_row", ",", "self", ".", "output_col", ",", "self", ".", "output_z", ")", "\n", "", "else", ":", "\n", "              ", "self", ".", "kernel_shape", "=", "(", "input_row", ",", "input_col", ",", "input_z", ",", "input_filter", ",", "\n", "self", ".", "output_row", ",", "self", ".", "output_col", ",", "self", ".", "output_z", ",", "self", ".", "filters", ")", "\n", "\n", "", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "self", ".", "kernel_shape", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "name", "=", "'kernel'", ",", "\n", "regularizer", "=", "self", ".", "kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "kernel_constraint", ")", "\n", "\n", "self", ".", "kernel_mask", "=", "LocallyConnected3D", ".", "get_locallyconnected_mask", "(", "\n", "input_shape", "=", "(", "input_row", ",", "input_col", ",", "input_z", ")", ",", "\n", "kernel_shape", "=", "self", ".", "kernel_size", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "data_format", "=", "self", ".", "data_format", "\n", ")", "\n", "\n", "", "elif", "self", ".", "implementation", "==", "3", ":", "\n", "            ", "self", ".", "kernel_shape", "=", "(", "self", ".", "output_row", "*", "self", ".", "output_col", "*", "self", ".", "output_z", "*", "self", ".", "filters", ",", "\n", "input_row", "*", "input_col", "*", "input_z", "*", "input_filter", ")", "\n", "\n", "self", ".", "kernel_idxs", "=", "sorted", "(", "\n", "LocallyConnected3D", ".", "conv_kernel_idxs", "(", "\n", "input_shape", "=", "(", "input_row", ",", "input_col", ",", "input_z", ")", ",", "\n", "kernel_shape", "=", "self", ".", "kernel_size", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "filters_in", "=", "input_filter", ",", "\n", "filters_out", "=", "self", ".", "filters", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", ")", "\n", "\n", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "\n", "shape", "=", "(", "len", "(", "self", ".", "kernel_idxs", ")", ",", ")", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "name", "=", "'kernel'", ",", "\n", "regularizer", "=", "self", ".", "kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "kernel_constraint", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unrecognized implementation mode: %d.'", "\n", "%", "self", ".", "implementation", ")", "\n", "\n", "", "if", "self", ".", "use_bias", ":", "\n", "            ", "self", ".", "bias", "=", "self", ".", "add_weight", "(", "\n", "shape", "=", "(", "output_row", ",", "output_col", ",", "output_z", ",", "self", ".", "filters", ")", ",", "\n", "initializer", "=", "self", ".", "bias_initializer", ",", "\n", "name", "=", "'bias'", ",", "\n", "regularizer", "=", "self", ".", "bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "bias_constraint", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bias", "=", "None", "\n", "", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "            ", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "5", ",", "axes", "=", "{", "1", ":", "input_filter", "}", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "5", ",", "axes", "=", "{", "-", "1", ":", "input_filter", "}", ")", "\n", "", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.compute_output_shape": [[654, 676], ["tensorflow.python.keras.utils.conv_utils.conv_output_length", "tensorflow.python.keras.utils.conv_utils.conv_output_length", "tensorflow.python.keras.utils.conv_utils.conv_output_length"], "methods", ["None"], ["", "@", "tf_utils", ".", "shape_type_conversion", "\n", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "            ", "rows", "=", "input_shape", "[", "2", "]", "\n", "cols", "=", "input_shape", "[", "3", "]", "\n", "z", "=", "input_shape", "[", "4", "]", "\n", "", "elif", "self", ".", "data_format", "==", "'channels_last'", ":", "\n", "            ", "rows", "=", "input_shape", "[", "1", "]", "\n", "cols", "=", "input_shape", "[", "2", "]", "\n", "z", "=", "input_shape", "[", "3", "]", "\n", "\n", "", "rows", "=", "conv_utils", ".", "conv_output_length", "(", "\n", "rows", ",", "self", ".", "kernel_size", "[", "0", "]", ",", "self", ".", "padding", ",", "self", ".", "strides", "[", "0", "]", ")", "\n", "cols", "=", "conv_utils", ".", "conv_output_length", "(", "\n", "cols", ",", "self", ".", "kernel_size", "[", "1", "]", ",", "self", ".", "padding", ",", "self", ".", "strides", "[", "1", "]", ")", "\n", "z", "=", "conv_utils", ".", "conv_output_length", "(", "\n", "z", ",", "self", ".", "kernel_size", "[", "2", "]", ",", "self", ".", "padding", ",", "self", ".", "strides", "[", "2", "]", ")", "\n", "\n", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "            ", "return", "(", "input_shape", "[", "0", "]", ",", "self", ".", "filters", ",", "rows", ",", "cols", ",", "z", ")", "\n", "", "elif", "self", ".", "data_format", "==", "'channels_last'", ":", "\n", "            ", "return", "(", "input_shape", "[", "0", "]", ",", "rows", ",", "cols", ",", "z", ",", "self", ".", "filters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.call": [[677, 701], ["layers.LocallyConnected3D.activation", "layers.LocallyConnected3D.local_conv", "tensorflow.keras.backend.bias_add", "layers.LocallyConnected3D.local_conv_matmul", "layers.LocallyConnected3D.compute_output_shape", "layers.LocallyConnected3D.local_conv_sparse_matmul", "ValueError", "layers.LocallyConnected3D.compute_output_shape"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.local_conv", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.local_conv_matmul", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineTransformationsToMatrix.compute_output_shape", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.local_conv_sparse_matmul", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineTransformationsToMatrix.compute_output_shape"], ["", "", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "self", ".", "implementation", "==", "1", ":", "\n", "            ", "output", "=", "LocallyConnected3D", ".", "local_conv", "(", "inputs", ",", "self", ".", "kernel", ",", "\n", "self", ".", "kernel_size", ",", "self", ".", "strides", ",", "\n", "(", "self", ".", "output_row", ",", "self", ".", "output_col", ",", "self", ".", "output_z", ")", ",", "self", ".", "data_format", ")", "\n", "\n", "", "elif", "self", ".", "implementation", "==", "2", ":", "\n", "            ", "output", "=", "LocallyConnected3D", ".", "local_conv_matmul", "(", "inputs", ",", "self", ".", "kernel", ",", "\n", "self", ".", "kernel_mask", ",", "self", ".", "compute_output_shape", "(", "inputs", ".", "shape", ")", ")", "\n", "\n", "", "elif", "self", ".", "implementation", "==", "3", ":", "\n", "            ", "output", "=", "LocallyConnected3D", ".", "local_conv_sparse_matmul", "(", "inputs", ",", "\n", "self", ".", "kernel", ",", "self", ".", "kernel_idxs", ",", "self", ".", "kernel_shape", ",", "\n", "self", ".", "compute_output_shape", "(", "inputs", ".", "shape", ")", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unrecognized implementation mode: %d.'", "\n", "%", "self", ".", "implementation", ")", "\n", "\n", "", "if", "self", ".", "use_bias", ":", "\n", "            ", "output", "=", "K", ".", "bias_add", "(", "output", ",", "self", ".", "bias", ",", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "", "output", "=", "self", ".", "activation", "(", "output", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.get_config": [[702, 722], ["super().get_config", "dict", "tensorflow.keras.activations.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.LoadableModel.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "{", "\n", "'filters'", ":", "self", ".", "filters", ",", "\n", "'kernel_size'", ":", "self", ".", "kernel_size", ",", "\n", "'strides'", ":", "self", ".", "strides", ",", "\n", "'padding'", ":", "self", ".", "padding", ",", "\n", "'data_format'", ":", "self", ".", "data_format", ",", "\n", "'activation'", ":", "tf", ".", "keras", ".", "activations", ".", "serialize", "(", "self", ".", "activation", ")", ",", "\n", "'use_bias'", ":", "self", ".", "use_bias", ",", "\n", "'kernel_initializer'", ":", "tf", ".", "keras", ".", "initializers", ".", "serialize", "(", "self", ".", "kernel_initializer", ")", ",", "\n", "'bias_initializer'", ":", "tf", ".", "keras", ".", "initializers", ".", "serialize", "(", "self", ".", "bias_initializer", ")", ",", "\n", "'kernel_regularizer'", ":", "tf", ".", "keras", ".", "regularizers", ".", "serialize", "(", "self", ".", "kernel_regularizer", ")", ",", "\n", "'bias_regularizer'", ":", "tf", ".", "keras", ".", "regularizers", ".", "serialize", "(", "self", ".", "bias_regularizer", ")", ",", "\n", "'activity_regularizer'", ":", "tf", ".", "keras", ".", "regularizers", ".", "serialize", "(", "self", ".", "activity_regularizer", ")", ",", "\n", "'kernel_constraint'", ":", "tf", ".", "keras", ".", "constraints", ".", "serialize", "(", "self", ".", "kernel_constraint", ")", ",", "\n", "'bias_constraint'", ":", "tf", ".", "keras", ".", "constraints", ".", "serialize", "(", "self", ".", "bias_constraint", ")", ",", "\n", "'implementation'", ":", "self", ".", "implementation", "\n", "}", "\n", "base_config", "=", "super", "(", "LocallyConnected3D", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.local_conv": [[724, 797], ["tensorflow.keras.backend.int_shape", "len", "list", "itertools.product", "tensorflow.keras.backend.concatenate", "tensorflow.keras.backend.batch_dot", "tensorflow.keras.backend.reshape", "tensorflow.keras.backend.permute_dimensions", "image_data_format", "ValueError", "range", "range", "slices.extend", "xs.append", "slice", "slices.append", "slices.append", "tensorflow.keras.backend.reshape", "str", "slice", "slice", "slice"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice"], ["", "@", "staticmethod", "\n", "def", "local_conv", "(", "inputs", ",", "\n", "kernel", ",", "\n", "kernel_size", ",", "\n", "strides", ",", "\n", "output_shape", ",", "\n", "data_format", "=", "None", ")", ":", "\n", "        ", "\"\"\"Apply N-D convolution with un-shared weights.\n        Arguments:\n            inputs: (N+2)-D tensor with shape\n                (batch_size, channels_in, d_in1, ..., d_inN)\n                if data_format='channels_first', or\n                (batch_size, d_in1, ..., d_inN, channels_in)\n                if data_format='channels_last'.\n            kernel: the unshared weight for N-D convolution,\n                with shape (output_items, feature_dim, channels_out), where\n                feature_dim = np.prod(kernel_size) * channels_in,\n                output_items = np.prod(output_shape).\n            kernel_size: a tuple of N integers, specifying the\n                spatial dimensions of the N-D convolution window.\n            strides: a tuple of N integers, specifying the strides\n                of the convolution along the spatial dimensions.\n            output_shape: a tuple of (d_out1, ..., d_outN) specifying the spatial\n                dimensionality of the output.\n            data_format: string, \"channels_first\" or \"channels_last\".\n        Returns:\n            An (N+2)-D tensor with shape:\n            (batch_size, channels_out) + output_shape\n            if data_format='channels_first', or:\n            (batch_size,) + output_shape + (channels_out,)\n            if data_format='channels_last'.\n        Raises:\n            ValueError: if `data_format` is neither\n            `channels_last` nor `channels_first`.\n        \"\"\"", "\n", "if", "data_format", "is", "None", ":", "\n", "            ", "data_format", "=", "image_data_format", "(", ")", "\n", "", "if", "data_format", "not", "in", "{", "'channels_first'", ",", "'channels_last'", "}", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown data_format: '", "+", "str", "(", "data_format", ")", ")", "\n", "\n", "", "kernel_shape", "=", "K", ".", "int_shape", "(", "kernel", ")", "\n", "feature_dim", "=", "kernel_shape", "[", "1", "]", "\n", "channels_out", "=", "kernel_shape", "[", "-", "1", "]", "\n", "ndims", "=", "len", "(", "output_shape", ")", "\n", "spatial_dimensions", "=", "list", "(", "range", "(", "ndims", ")", ")", "\n", "\n", "xs", "=", "[", "]", "\n", "output_axes_ticks", "=", "[", "range", "(", "axis_max", ")", "for", "axis_max", "in", "output_shape", "]", "\n", "for", "position", "in", "itertools", ".", "product", "(", "*", "output_axes_ticks", ")", ":", "\n", "            ", "slices", "=", "[", "slice", "(", "None", ")", "]", "\n", "\n", "if", "data_format", "==", "'channels_first'", ":", "\n", "                ", "slices", ".", "append", "(", "slice", "(", "None", ")", ")", "\n", "\n", "", "slices", ".", "extend", "(", "[", "slice", "(", "position", "[", "d", "]", "*", "strides", "[", "d", "]", ",", "\n", "position", "[", "d", "]", "*", "strides", "[", "d", "]", "+", "kernel_size", "[", "d", "]", ")", "\n", "for", "d", "in", "spatial_dimensions", "]", ")", "\n", "\n", "if", "data_format", "==", "'channels_last'", ":", "\n", "                ", "slices", ".", "append", "(", "slice", "(", "None", ")", ")", "\n", "\n", "", "xs", ".", "append", "(", "K", ".", "reshape", "(", "inputs", "[", "slices", "]", ",", "(", "1", ",", "-", "1", ",", "feature_dim", ")", ")", ")", "\n", "\n", "", "x_aggregate", "=", "K", ".", "concatenate", "(", "xs", ",", "axis", "=", "0", ")", "\n", "output", "=", "K", ".", "batch_dot", "(", "x_aggregate", ",", "kernel", ")", "\n", "output", "=", "K", ".", "reshape", "(", "output", ",", "output_shape", "+", "(", "-", "1", ",", "channels_out", ")", ")", "\n", "\n", "if", "data_format", "==", "'channels_first'", ":", "\n", "            ", "permutation", "=", "[", "ndims", ",", "ndims", "+", "1", "]", "+", "spatial_dimensions", "\n", "", "else", ":", "\n", "            ", "permutation", "=", "[", "ndims", "]", "+", "spatial_dimensions", "+", "[", "ndims", "+", "1", "]", "\n", "\n", "", "return", "K", ".", "permute_dimensions", "(", "output", ",", "permutation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.get_locallyconnected_mask": [[799, 858], ["tensorflow.python.keras.utils.conv_utils.conv_kernel_mask", "int", "numpy.expand_dims", "numpy.expand_dims", "numpy.expand_dims", "numpy.expand_dims", "ValueError", "str"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_locallyconnected_mask", "(", "input_shape", ",", "\n", "kernel_shape", ",", "\n", "strides", ",", "\n", "padding", ",", "\n", "data_format", ")", ":", "\n", "        ", "\"\"\"Return a mask representing connectivity of a locally-connected operation.\n        This method returns a masking numpy array of 0s and 1s (of type `np.float32`)\n        that, when element-wise multiplied with a fully-connected weight tensor, masks\n        out the weights between disconnected input-output pairs and thus implements\n        local connectivity through a sparse fully-connected weight tensor.\n        Assume an unshared convolution with given parameters is applied to an input\n        having N spatial dimensions with `input_shape = (d_in1, ..., d_inN)`\n        to produce an output with spatial shape `(d_out1, ..., d_outN)` (determined\n        by layer parameters such as `strides`).\n        This method returns a mask which can be broadcast-multiplied (element-wise)\n        with a 2*(N+1)-D weight matrix (equivalent to a fully-connected layer between\n        (N+1)-D activations (N spatial + 1 channel dimensions for input and output)\n        to make it perform an unshared convolution with given `kernel_shape`,\n        `strides`, `padding` and `data_format`.\n        Arguments:\n          input_shape: tuple of size N: `(d_in1, ..., d_inN)`\n                       spatial shape of the input.\n          kernel_shape: tuple of size N, spatial shape of the convolutional kernel\n                        / receptive field.\n          strides: tuple of size N, strides along each spatial dimension.\n          padding: type of padding, string `\"same\"` or `\"valid\"`.\n          data_format: a string, `\"channels_first\"` or `\"channels_last\"`.\n        Returns:\n          a `np.float32`-type `np.ndarray` of shape\n          `(1, d_in1, ..., d_inN, 1, d_out1, ..., d_outN)`\n          if `data_format == `\"channels_first\"`, or\n          `(d_in1, ..., d_inN, 1, d_out1, ..., d_outN, 1)`\n          if `data_format == \"channels_last\"`.\n        Raises:\n          ValueError: if `data_format` is neither `\"channels_first\"` nor\n                      `\"channels_last\"`.\n        \"\"\"", "\n", "mask", "=", "conv_utils", ".", "conv_kernel_mask", "(", "\n", "input_shape", "=", "input_shape", ",", "\n", "kernel_shape", "=", "kernel_shape", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", "\n", ")", "\n", "\n", "ndims", "=", "int", "(", "mask", ".", "ndim", "/", "2", ")", "\n", "\n", "if", "data_format", "==", "'channels_first'", ":", "\n", "            ", "mask", "=", "np", ".", "expand_dims", "(", "mask", ",", "0", ")", "\n", "mask", "=", "np", ".", "expand_dims", "(", "mask", ",", "-", "ndims", "-", "1", ")", "\n", "\n", "", "elif", "data_format", "==", "'channels_last'", ":", "\n", "            ", "mask", "=", "np", ".", "expand_dims", "(", "mask", ",", "ndims", ")", "\n", "mask", "=", "np", ".", "expand_dims", "(", "mask", ",", "-", "1", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unrecognized data_format: '", "+", "str", "(", "data_format", ")", ")", "\n", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.local_conv_matmul": [[860, 910], ["tensorflow.keras.backend.reshape", "layers.LocallyConnected3D.make_2d", "tensorflow.linalg.matmul", "tensorflow.keras.backend.reshape", "tensorflow.keras.backend.shape", "tensorflow.keras.backend.ndim", "output_shape.as_list", "tensorflow.keras.backend.shape"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.make_2d"], ["", "@", "staticmethod", "\n", "def", "local_conv_matmul", "(", "inputs", ",", "kernel", ",", "kernel_mask", ",", "output_shape", ")", ":", "\n", "        ", "\"\"\"Apply N-D convolution with un-shared weights using a single matmul call.\n        This method outputs `inputs . (kernel * kernel_mask)`\n        (with `.` standing for matrix-multiply and `*` for element-wise multiply)\n        and requires a precomputed `kernel_mask` to zero-out weights in `kernel` and\n        hence perform the same operation as a convolution with un-shared\n        (the remaining entries in `kernel`) weights. It also does the necessary\n        reshapes to make `inputs` and `kernel` 2-D and `output` (N+2)-D.\n        Arguments:\n            inputs: (N+2)-D tensor with shape\n                `(batch_size, channels_in, d_in1, ..., d_inN)`\n                or\n                `(batch_size, d_in1, ..., d_inN, channels_in)`.\n            kernel: the unshared weights for N-D convolution,\n                an (N+2)-D tensor of shape:\n                `(d_in1, ..., d_inN, channels_in, d_out2, ..., d_outN, channels_out)`\n                or\n                `(channels_in, d_in1, ..., d_inN, channels_out, d_out2, ..., d_outN)`,\n                with the ordering of channels and spatial dimensions matching\n                that of the input.\n                Each entry is the weight between a particular input and\n                output location, similarly to a fully-connected weight matrix.\n            kernel_mask: a float 0/1 mask tensor of shape:\n                 `(d_in1, ..., d_inN, 1, d_out2, ..., d_outN, 1)`\n                 or\n                 `(1, d_in1, ..., d_inN, 1, d_out2, ..., d_outN)`,\n                 with the ordering of singleton and spatial dimensions\n                 matching that of the input.\n                 Mask represents the connectivity pattern of the layer and is\n                 precomputed elsewhere based on layer parameters: stride,\n                 padding, and the receptive field shape.\n            output_shape: a tuple of (N+2) elements representing the output shape:\n                `(batch_size, channels_out, d_out1, ..., d_outN)`\n                or\n                `(batch_size, d_out1, ..., d_outN, channels_out)`,\n                with the ordering of channels and spatial dimensions matching that of\n                the input.\n        Returns:\n            Output (N+2)-D tensor with shape `output_shape`.\n        \"\"\"", "\n", "inputs_flat", "=", "K", ".", "reshape", "(", "inputs", ",", "(", "K", ".", "shape", "(", "inputs", ")", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "\n", "kernel", "=", "kernel_mask", "*", "kernel", "\n", "kernel", "=", "LocallyConnected3D", ".", "make_2d", "(", "kernel", ",", "split_dim", "=", "K", ".", "ndim", "(", "kernel", ")", "//", "2", ")", "\n", "\n", "output_flat", "=", "tf", ".", "linalg", ".", "matmul", "(", "inputs_flat", ",", "kernel", ",", "b_is_sparse", "=", "True", ")", "\n", "output", "=", "K", ".", "reshape", "(", "output_flat", ",", "\n", "[", "K", ".", "shape", "(", "output_flat", ")", "[", "0", "]", ",", "]", "+", "output_shape", ".", "as_list", "(", ")", "[", "1", ":", "]", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.local_conv_sparse_matmul": [[912, 946], ["tensorflow.keras.backend.reshape", "tensorflow.keras.backend.sparse_ops.sparse_tensor_dense_mat_mul", "tensorflow.keras.backend.transpose", "tensorflow.keras.backend.reshape", "tensorflow.keras.backend.shape", "output_shape.as_list", "tensorflow.keras.backend.shape"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "local_conv_sparse_matmul", "(", "inputs", ",", "kernel", ",", "kernel_idxs", ",", "kernel_shape", ",", "\n", "output_shape", ")", ":", "\n", "        ", "\"\"\"Apply N-D convolution with un-shared weights using a single sparse matmul.\n        This method outputs `inputs . tf.sparse.SparseTensor(indices=kernel_idxs,\n        values=kernel, dense_shape=kernel_shape)`, with `.` standing for\n        matrix-multiply. It also reshapes `inputs` to 2-D and `output` to (N+2)-D.\n        Arguments:\n            inputs: (N+2)-D tensor with shape `(batch_size, channels_in, d_in1, ...,\n              d_inN)` or `(batch_size, d_in1, ..., d_inN, channels_in)`.\n            kernel: a 1-D tensor with shape `(len(kernel_idxs),)` containing all the\n              weights of the layer.\n            kernel_idxs:  a list of integer tuples representing indices in a sparse\n              matrix performing the un-shared convolution as a matrix-multiply.\n            kernel_shape: a tuple `(input_size, output_size)`, where `input_size =\n              channels_in * d_in1 * ... * d_inN` and `output_size = channels_out *\n              d_out1 * ... * d_outN`.\n            output_shape: a tuple of (N+2) elements representing the output shape:\n              `(batch_size, channels_out, d_out1, ..., d_outN)` or `(batch_size,\n              d_out1, ..., d_outN, channels_out)`, with the ordering of channels and\n              spatial dimensions matching that of the input.\n        Returns:\n            Output (N+2)-D dense tensor with shape `output_shape`.\n        \"\"\"", "\n", "inputs_flat", "=", "K", ".", "reshape", "(", "inputs", ",", "(", "K", ".", "shape", "(", "inputs", ")", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "output_flat", "=", "backend", ".", "sparse_ops", ".", "sparse_tensor_dense_mat_mul", "(", "\n", "kernel_idxs", ",", "kernel", ",", "kernel_shape", ",", "inputs_flat", ",", "adjoint_b", "=", "True", ")", "\n", "output_flat_transpose", "=", "K", ".", "transpose", "(", "output_flat", ")", "\n", "\n", "output_reshaped", "=", "K", ".", "reshape", "(", "\n", "output_flat_transpose", ",", "\n", "[", "K", ".", "shape", "(", "output_flat_transpose", ")", "[", "0", "]", ",", "]", "+", "output_shape", ".", "as_list", "(", ")", "[", "1", ":", "]", "\n", ")", "\n", "return", "output_reshaped", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.conv_kernel_idxs": [[948, 1035], ["len", "isinstance", "isinstance", "len", "len", "layers.LocallyConnected3D.conv_output_shape", "itertools.product", "NotImplementedError", "ValueError", "range", "layers.LocallyConnected3D.conv_connected_inputs", "itertools.product", "ValueError", "range", "range", "numpy.ravel_multi_index", "numpy.ravel_multi_index", "concat_idxs", "concat_idxs", "concat_idxs", "concat_idxs"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.conv_output_shape", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.conv_connected_inputs", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "@", "staticmethod", "\n", "def", "conv_kernel_idxs", "(", "input_shape", ",", "kernel_shape", ",", "strides", ",", "padding", ",", "filters_in", ",", "\n", "filters_out", ",", "data_format", ")", ":", "\n", "        ", "\"\"\"Yields output-input tuples of indices in a CNN layer.\n        The generator iterates over all `(output_idx, input_idx)` tuples, where\n          `output_idx` is an integer index in a flattened tensor representing a single\n          output image of a convolutional layer that is connected (via the layer\n          weights) to the respective single input image at `input_idx`\n        Example:\n          >>> input_shape = (2, 2)\n          >>> kernel_shape = (2, 1)\n          >>> strides = (1, 1)\n          >>> padding = \"valid\"\n          >>> filters_in = 1\n          >>> filters_out = 1\n          >>> data_format = \"channels_last\"\n          >>> list(conv_kernel_idxs(input_shape, kernel_shape, strides, padding,\n          ...                       filters_in, filters_out, data_format))\n          [(0, 0), (0, 2), (1, 1), (1, 3)]\n        Args:\n          input_shape: tuple of size N: `(d_in1, ..., d_inN)`, spatial shape of the\n            input.\n          kernel_shape: tuple of size N, spatial shape of the convolutional kernel /\n            receptive field.\n          strides: tuple of size N, strides along each spatial dimension.\n          padding: type of padding, string `\"same\"` or `\"valid\"`.\n            `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n            the left/right or up/down of the input such that output has the same\n            height/width dimension as the input.\n          filters_in: `int`, number if filters in the input to the layer.\n          filters_out: `int', number if filters in the output of the layer.\n          data_format: string, \"channels_first\" or \"channels_last\".\n        Yields:\n          The next tuple `(output_idx, input_idx)`, where\n          `output_idx` is an integer index in a flattened tensor representing a single\n          output image of a convolutional layer that is connected (via the layer\n          weights) to the respective single input image at `input_idx`.\n        Raises:\n            ValueError: if `data_format` is neither\n            `\"channels_last\"` nor `\"channels_first\"`, or if number of strides, input,\n            and kernel number of dimensions do not match.\n            NotImplementedError: if `padding` is neither `\"same\"` nor `\"valid\"`.\n        \"\"\"", "\n", "if", "padding", "not", "in", "(", "'same'", ",", "'valid'", ")", ":", "\n", "             ", "raise", "NotImplementedError", "(", "'Padding type %s not supported. '", "\n", "'Only \"valid\" and \"same\" '", "\n", "'are implemented.'", "%", "padding", ")", "\n", "\n", "", "in_dims", "=", "len", "(", "input_shape", ")", "\n", "if", "isinstance", "(", "kernel_shape", ",", "int", ")", ":", "\n", "            ", "kernel_shape", "=", "(", "kernel_shape", ",", ")", "*", "in_dims", "\n", "", "if", "isinstance", "(", "strides", ",", "int", ")", ":", "\n", "            ", "strides", "=", "(", "strides", ",", ")", "*", "in_dims", "\n", "\n", "", "kernel_dims", "=", "len", "(", "kernel_shape", ")", "\n", "stride_dims", "=", "len", "(", "strides", ")", "\n", "if", "kernel_dims", "!=", "in_dims", "or", "stride_dims", "!=", "in_dims", ":", "\n", "            ", "raise", "ValueError", "(", "'Number of strides, input and kernel dimensions must all '", "\n", "'match. Received: %d, %d, %d.'", "%", "\n", "(", "stride_dims", ",", "in_dims", ",", "kernel_dims", ")", ")", "\n", "\n", "", "output_shape", "=", "LocallyConnected3D", ".", "conv_output_shape", "(", "input_shape", ",", "\n", "kernel_shape", ",", "strides", ",", "padding", ")", "\n", "output_axes_ticks", "=", "[", "range", "(", "dim", ")", "for", "dim", "in", "output_shape", "]", "\n", "\n", "if", "data_format", "==", "'channels_first'", ":", "\n", "            ", "concat_idxs", "=", "lambda", "spatial_idx", ",", "filter_idx", ":", "(", "filter_idx", ",", ")", "+", "spatial_idx", "\n", "", "elif", "data_format", "==", "'channels_last'", ":", "\n", "            ", "concat_idxs", "=", "lambda", "spatial_idx", ",", "filter_idx", ":", "spatial_idx", "+", "(", "filter_idx", ",", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Data format %s not recognized.'", "\n", "'`data_format` must be \"channels_first\" or '", "\n", "'\"channels_last\".'", "%", "data_format", ")", "\n", "\n", "", "for", "output_position", "in", "itertools", ".", "product", "(", "*", "output_axes_ticks", ")", ":", "\n", "            ", "input_axes_ticks", "=", "LocallyConnected3D", ".", "conv_connected_inputs", "(", "input_shape", ",", "\n", "kernel_shape", ",", "output_position", ",", "strides", ",", "padding", ")", "\n", "for", "input_position", "in", "itertools", ".", "product", "(", "*", "input_axes_ticks", ")", ":", "\n", "                ", "for", "f_in", "in", "range", "(", "filters_in", ")", ":", "\n", "                    ", "for", "f_out", "in", "range", "(", "filters_out", ")", ":", "\n", "                        ", "out_idx", "=", "np", ".", "ravel_multi_index", "(", "\n", "multi_index", "=", "concat_idxs", "(", "output_position", ",", "f_out", ")", ",", "\n", "dims", "=", "concat_idxs", "(", "output_shape", ",", "filters_out", ")", ")", "\n", "in_idx", "=", "np", ".", "ravel_multi_index", "(", "\n", "multi_index", "=", "concat_idxs", "(", "input_position", ",", "f_in", ")", ",", "\n", "dims", "=", "concat_idxs", "(", "input_shape", ",", "filters_in", ")", ")", "\n", "yield", "(", "out_idx", ",", "in_idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.conv_connected_inputs": [[1037, 1086], ["len", "range", "int", "max", "min", "ranges.append", "range"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "", "", "", "", "@", "staticmethod", "\n", "def", "conv_connected_inputs", "(", "input_shape", ",", "kernel_shape", ",", "output_position", ",", "strides", ",", "\n", "padding", ")", ":", "\n", "        ", "\"\"\"Return locations of the input connected to an output position.\n        Assume a convolution with given parameters is applied to an input having N\n        spatial dimensions with `input_shape = (d_in1, ..., d_inN)`. This method\n        returns N ranges specifying the input region that was convolved with the\n        kernel to produce the output at position\n        `output_position = (p_out1, ..., p_outN)`.\n        Example:\n          >>> input_shape = (4, 4)\n          >>> kernel_shape = (2, 1)\n          >>> output_position = (1, 1)\n          >>> strides = (1, 1)\n          >>> padding = \"valid\"\n          >>> conv_connected_inputs(input_shape, kernel_shape, output_position,\n          ...                       strides, padding)\n          [range(1, 3), range(1, 2)]\n        Args:\n          input_shape: tuple of size N: `(d_in1, ..., d_inN)`, spatial shape of the\n            input.\n          kernel_shape: tuple of size N, spatial shape of the convolutional kernel /\n            receptive field.\n          output_position: tuple of size N: `(p_out1, ..., p_outN)`, a single position\n            in the output of the convolution.\n          strides: tuple of size N, strides along each spatial dimension.\n          padding: type of padding, string `\"same\"` or `\"valid\"`.\n            `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n            the left/right or up/down of the input such that output has the same\n            height/width dimension as the input.\n        Returns:\n          N ranges `[[p_in_left1, ..., p_in_right1], ...,\n                    [p_in_leftN, ..., p_in_rightN]]` specifying the region in the\n          input connected to output_position.\n        \"\"\"", "\n", "ranges", "=", "[", "]", "\n", "\n", "ndims", "=", "len", "(", "input_shape", ")", "\n", "for", "d", "in", "range", "(", "ndims", ")", ":", "\n", "            ", "left_shift", "=", "int", "(", "kernel_shape", "[", "d", "]", "/", "2", ")", "\n", "right_shift", "=", "kernel_shape", "[", "d", "]", "-", "left_shift", "\n", "center", "=", "output_position", "[", "d", "]", "*", "strides", "[", "d", "]", "\n", "if", "padding", "==", "'valid'", ":", "\n", "                ", "center", "+=", "left_shift", "\n", "", "start", "=", "max", "(", "0", ",", "center", "-", "left_shift", ")", "\n", "end", "=", "min", "(", "input_shape", "[", "d", "]", ",", "center", "+", "right_shift", ")", "\n", "ranges", ".", "append", "(", "range", "(", "start", ",", "end", ")", ")", "\n", "\n", "", "return", "ranges", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.conv_output_shape": [[1088, 1113], ["range", "tuple", "len", "tensorflow.python.keras.utils.conv_utils.conv_output_length"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "@", "staticmethod", "\n", "def", "conv_output_shape", "(", "input_shape", ",", "kernel_shape", ",", "strides", ",", "padding", ")", ":", "\n", "        ", "\"\"\"Return the output shape of an N-D convolution.\n        Forces dimensions where input is empty (size 0) to remain empty.\n        Args:\n          input_shape: tuple of size N: `(d_in1, ..., d_inN)`, spatial shape of the\n            input.\n          kernel_shape: tuple of size N, spatial shape of the convolutional kernel /\n            receptive field.\n          strides: tuple of size N, strides along each spatial dimension.\n          padding: type of padding, string `\"same\"` or `\"valid\"`.\n            `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n            the left/right or up/down of the input such that output has the same\n            height/width dimension as the input.\n        Returns:\n          tuple of size N: `(d_out1, ..., d_outN)`, spatial shape of the output.\n        \"\"\"", "\n", "dims", "=", "range", "(", "len", "(", "kernel_shape", ")", ")", "\n", "output_shape", "=", "[", "\n", "conv_utils", ".", "conv_output_length", "(", "input_shape", "[", "d", "]", ",", "kernel_shape", "[", "d", "]", ",", "padding", ",", "strides", "[", "d", "]", ")", "\n", "for", "d", "in", "dims", "\n", "]", "\n", "output_shape", "=", "tuple", "(", "\n", "[", "0", "if", "input_shape", "[", "d", "]", "==", "0", "else", "output_shape", "[", "d", "]", "for", "d", "in", "dims", "]", ")", "\n", "return", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocallyConnected3D.make_2d": [[1115, 1136], ["tensorflow.keras.backend.shape", "tensorflow.math.reduce_prod", "tensorflow.math.reduce_prod", "tensorflow.keras.backend.reshape"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_2d", "(", "tensor", ",", "split_dim", ")", ":", "\n", "        ", "\"\"\"Reshapes an N-dimensional tensor into a 2D tensor.\n        Dimensions before (excluding) and after (including) `split_dim` are grouped\n        together.\n        Arguments:\n        tensor: a tensor of shape `(d0, ..., d(N-1))`.\n        split_dim: an integer from 1 to N-1, index of the dimension to group\n            dimensions before (excluding) and after (including).\n        Returns:\n        Tensor of shape\n        `(d0 * ... * d(split_dim-1), d(split_dim) * ... * d(N-1))`.\n        \"\"\"", "\n", "shape", "=", "K", ".", "shape", "(", "tensor", ")", "\n", "in_dims", "=", "shape", "[", ":", "split_dim", "]", "\n", "out_dims", "=", "shape", "[", "split_dim", ":", "]", "\n", "\n", "in_size", "=", "tf", ".", "math", ".", "reduce_prod", "(", "in_dims", ")", "\n", "out_size", "=", "tf", ".", "math", ".", "reduce_prod", "(", "out_dims", ")", "\n", "\n", "return", "K", ".", "reshape", "(", "tensor", ",", "(", "in_size", ",", "out_size", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinear.__init__": [[1148, 1164], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "output_features", ",", "\n", "mult_initializer", "=", "None", ",", "\n", "bias_initializer", "=", "None", ",", "\n", "mult_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "        ", "self", ".", "output_features", "=", "output_features", "\n", "self", ".", "mult_initializer", "=", "mult_initializer", "\n", "self", ".", "bias_initializer", "=", "bias_initializer", "\n", "self", ".", "mult_regularizer", "=", "mult_regularizer", "\n", "self", ".", "bias_regularizer", "=", "bias_regularizer", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "\n", "super", "(", "LocalCrossLinear", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinear.build": [[1165, 1195], ["layers.LocalCrossLinear.add_weight", "super().build", "tensorflow.keras.initializers.RandomNormal", "layers.LocalCrossLinear.add_weight", "tensorflow.keras.initializers.RandomNormal", "list", "list"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# Create a trainable weight variable for this layer.", "\n", "        ", "mult_shape", "=", "[", "1", "]", "+", "list", "(", "input_shape", ")", "[", "1", ":", "]", "+", "[", "self", ".", "output_features", "]", "\n", "\n", "\n", "# verify initializer", "\n", "if", "self", ".", "mult_initializer", "is", "None", ":", "\n", "            ", "mean", "=", "1", "/", "input_shape", "[", "-", "1", "]", "\n", "stddev", "=", "0.01", "\n", "self", ".", "mult_initializer", "=", "keras", ".", "initializers", ".", "RandomNormal", "(", "mean", "=", "mean", ",", "stddev", "=", "stddev", ")", "\n", "\n", "", "self", ".", "mult", "=", "self", ".", "add_weight", "(", "name", "=", "'mult-kernel'", ",", "\n", "shape", "=", "mult_shape", ",", "\n", "initializer", "=", "self", ".", "mult_initializer", ",", "\n", "regularizer", "=", "self", ".", "mult_regularizer", ",", "\n", "trainable", "=", "True", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "            ", "if", "self", ".", "bias_initializer", "is", "None", ":", "\n", "                ", "mean", "=", "1", "/", "input_shape", "[", "-", "1", "]", "\n", "stddev", "=", "0.01", "\n", "self", ".", "bias_initializer", "=", "keras", ".", "initializers", ".", "RandomNormal", "(", "mean", "=", "mean", ",", "stddev", "=", "stddev", ")", "\n", "\n", "", "bias_shape", "=", "[", "1", "]", "+", "list", "(", "input_shape", ")", "[", "1", ":", "-", "1", "]", "+", "[", "self", ".", "output_features", "]", "\n", "self", ".", "bias", "=", "self", ".", "add_weight", "(", "name", "=", "'bias-kernel'", ",", "\n", "shape", "=", "bias_shape", ",", "\n", "initializer", "=", "self", ".", "bias_initializer", ",", "\n", "regularizer", "=", "self", ".", "bias_regularizer", ",", "\n", "trainable", "=", "True", ")", "\n", "", "super", "(", "LocalCrossLinear", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinear.call": [[1196, 1204], ["tensorflow.stack", "layers.LocalCrossLinear._single_matmul", "tensorflow.map_fn"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinear._single_matmul"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "map_fn", "=", "lambda", "z", ":", "self", ".", "_single_matmul", "(", "z", ",", "self", ".", "mult", "[", "0", ",", "...", "]", ")", "\n", "y", "=", "tf", ".", "stack", "(", "tf", ".", "map_fn", "(", "map_fn", ",", "x", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "0", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "            ", "y", "=", "y", "+", "self", ".", "bias", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinear._single_matmul": [[1205, 1209], ["tensorflow.keras.backend.expand_dims", "tensorflow.matmul"], "methods", ["None"], ["", "def", "_single_matmul", "(", "self", ",", "x", ",", "mult", ")", ":", "\n", "        ", "x", "=", "K", ".", "expand_dims", "(", "x", ",", "-", "2", ")", "\n", "y", "=", "tf", ".", "matmul", "(", "x", ",", "mult", ")", "[", "...", ",", "0", ",", ":", "]", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinear.compute_output_shape": [[1210, 1212], ["tuple", "list"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "tuple", "(", "list", "(", "input_shape", ")", "[", ":", "-", "1", "]", "+", "[", "self", ".", "output_features", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinearTrf.__init__": [[1224, 1243], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "output_features", ",", "\n", "mult_initializer", "=", "None", ",", "\n", "bias_initializer", "=", "None", ",", "\n", "mult_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "trf_mult", "=", "1", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "        ", "self", ".", "output_features", "=", "output_features", "\n", "self", ".", "mult_initializer", "=", "mult_initializer", "\n", "self", ".", "bias_initializer", "=", "bias_initializer", "\n", "self", ".", "mult_regularizer", "=", "mult_regularizer", "\n", "self", ".", "bias_regularizer", "=", "bias_regularizer", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "self", ".", "trf_mult", "=", "trf_mult", "\n", "self", ".", "interp_method", "=", "'linear'", "\n", "\n", "super", "(", "LocalCrossLinearTrf", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinearTrf.build": [[1244, 1281], ["len", "layers.LocalCrossLinearTrf.add_weight", "layers.LocalCrossLinearTrf.add_weight", "super().build", "tensorflow.keras.initializers.RandomNormal", "layers.LocalCrossLinearTrf.add_weight", "list", "list", "tensorflow.keras.initializers.RandomNormal", "tensorflow.keras.initializers.RandomNormal", "list"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# Create a trainable weight variable for this layer.", "\n", "        ", "mult_shape", "=", "list", "(", "input_shape", ")", "[", "1", ":", "]", "+", "[", "self", ".", "output_features", "]", "\n", "ndims", "=", "len", "(", "list", "(", "input_shape", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n", "\n", "# verify initializer", "\n", "if", "self", ".", "mult_initializer", "is", "None", ":", "\n", "            ", "mean", "=", "1", "/", "input_shape", "[", "-", "1", "]", "\n", "stddev", "=", "0.01", "\n", "self", ".", "mult_initializer", "=", "keras", ".", "initializers", ".", "RandomNormal", "(", "mean", "=", "mean", ",", "stddev", "=", "stddev", ")", "\n", "\n", "", "self", ".", "mult", "=", "self", ".", "add_weight", "(", "name", "=", "'mult-kernel'", ",", "\n", "shape", "=", "mult_shape", ",", "\n", "initializer", "=", "self", ".", "mult_initializer", ",", "\n", "regularizer", "=", "self", ".", "mult_regularizer", ",", "\n", "trainable", "=", "True", ")", "\n", "\n", "self", ".", "trf", "=", "self", ".", "add_weight", "(", "name", "=", "'def-kernel'", ",", "\n", "shape", "=", "mult_shape", "+", "[", "ndims", "]", ",", "\n", "initializer", "=", "keras", ".", "initializers", ".", "RandomNormal", "(", "mean", "=", "0", ",", "stddev", "=", "0.001", ")", ",", "\n", "trainable", "=", "True", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "            ", "if", "self", ".", "bias_initializer", "is", "None", ":", "\n", "                ", "mean", "=", "1", "/", "input_shape", "[", "-", "1", "]", "\n", "stddev", "=", "0.01", "\n", "self", ".", "bias_initializer", "=", "keras", ".", "initializers", ".", "RandomNormal", "(", "mean", "=", "mean", ",", "stddev", "=", "stddev", ")", "\n", "\n", "", "bias_shape", "=", "list", "(", "input_shape", ")", "[", "1", ":", "-", "1", "]", "+", "[", "self", ".", "output_features", "]", "\n", "self", ".", "bias", "=", "self", ".", "add_weight", "(", "name", "=", "'bias-kernel'", ",", "\n", "shape", "=", "bias_shape", ",", "\n", "initializer", "=", "self", ".", "bias_initializer", ",", "\n", "regularizer", "=", "self", ".", "bias_regularizer", ",", "\n", "trainable", "=", "True", ")", "\n", "\n", "", "super", "(", "LocalCrossLinearTrf", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinearTrf.call": [[1282, 1289], ["tensorflow.map_fn"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "\n", "\n", "# for each element in the batch", "\n", "        ", "y", "=", "tf", ".", "map_fn", "(", "self", ".", "_single_batch_trf", ",", "x", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinearTrf._single_batch_trf": [[1290, 1310], ["vol.shape.as_list", "range", "tensorflow.stack", "tensorflow.zeros", "range", "transform", "tensorflow.reshape"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.transform"], ["", "def", "_single_batch_trf", "(", "self", ",", "vol", ")", ":", "\n", "# vol should be vol_shape + [nb_features]", "\n", "# self.trf should be vol_shape + [nb_features] + [ndims]", "\n", "\n", "        ", "vol_shape", "=", "vol", ".", "shape", ".", "as_list", "(", ")", "\n", "nb_input_dims", "=", "vol_shape", "[", "-", "1", "]", "\n", "\n", "# this is inefficient...", "\n", "new_vols", "=", "[", "None", "]", "*", "self", ".", "output_features", "\n", "for", "j", "in", "range", "(", "self", ".", "output_features", ")", ":", "\n", "            ", "new_vols", "[", "j", "]", "=", "tf", ".", "zeros", "(", "vol_shape", "[", ":", "-", "1", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "nb_input_dims", ")", ":", "\n", "                ", "trf_vol", "=", "transform", "(", "vol", "[", "...", ",", "i", "]", ",", "self", ".", "trf", "[", "...", ",", "i", ",", "j", ",", ":", "]", "*", "self", ".", "trf_mult", ",", "interp_method", "=", "self", ".", "interp_method", ")", "\n", "trf_vol", "=", "tf", ".", "reshape", "(", "trf_vol", ",", "vol_shape", "[", ":", "-", "1", "]", ")", "\n", "new_vols", "[", "j", "]", "+=", "trf_vol", "*", "self", ".", "mult", "[", "...", ",", "i", ",", "j", "]", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "                    ", "new_vols", "[", "j", "]", "+=", "self", ".", "bias", "[", "...", ",", "j", "]", "\n", "\n", "", "", "", "return", "tf", ".", "stack", "(", "new_vols", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalCrossLinearTrf.compute_output_shape": [[1312, 1314], ["tuple", "list"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "tuple", "(", "list", "(", "input_shape", ")", "[", ":", "-", "1", "]", "+", "[", "self", ".", "output_features", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalParamLayer.__init__": [[1327, 1383], ["tensorflow.keras.layers.Layer.__init__", "tensorflow.python.keras.engine.base_layer.KerasHistory", "tensorflow.python.keras.engine.base_layer.node_module.Node", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.name_scope", "layers.LocalParamLayer.add_weight", "tensorflow.keras.backend.expand_dims", "str", "tensorflow.keras.backend.get_uid", "tensorflow.keras.backend.get_uid"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "\n", "shape", ",", "\n", "my_initializer", "=", "'RandomNormal'", ",", "\n", "dtype", "=", "None", ",", "\n", "name", "=", "None", ",", "\n", "mult", "=", "1.0", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "\n", "# some input checking", "\n", "        ", "if", "not", "name", ":", "\n", "            ", "prefix", "=", "'local_param'", "\n", "name", "=", "prefix", "+", "'_'", "+", "str", "(", "backend", ".", "get_uid", "(", "prefix", ")", ")", "\n", "\n", "", "if", "not", "dtype", ":", "\n", "            ", "dtype", "=", "backend", ".", "floatx", "(", ")", "\n", "\n", "", "self", ".", "shape", "=", "[", "1", ",", "*", "shape", "]", "\n", "self", ".", "my_initializer", "=", "my_initializer", "\n", "self", ".", "mult", "=", "mult", "\n", "\n", "if", "not", "name", ":", "\n", "            ", "prefix", "=", "'param'", "\n", "name", "=", "'%s_%d'", "%", "(", "prefix", ",", "K", ".", "get_uid", "(", "prefix", ")", ")", "\n", "", "Layer", ".", "__init__", "(", "self", ",", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "\n", "# Create a trainable weight variable for this layer.", "\n", "with", "K", ".", "name_scope", "(", "self", ".", "name", ")", ":", "\n", "            ", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "name", "=", "'kernel'", ",", "\n", "shape", "=", "shape", ",", "\n", "initializer", "=", "self", ".", "my_initializer", ",", "\n", "dtype", "=", "dtype", ",", "\n", "trainable", "=", "True", ")", "\n", "\n", "# prepare output tensor, which is essentially the kernel.", "\n", "", "output_tensor", "=", "K", ".", "expand_dims", "(", "self", ".", "kernel", ",", "0", ")", "*", "self", ".", "mult", "\n", "output_tensor", ".", "_keras_shape", "=", "self", ".", "shape", "\n", "output_tensor", ".", "_uses_learning_phase", "=", "False", "\n", "output_tensor", ".", "_keras_history", "=", "base_layer", ".", "KerasHistory", "(", "self", ",", "0", ",", "0", ")", "\n", "output_tensor", ".", "_batch_input_shape", "=", "self", ".", "shape", "\n", "\n", "self", ".", "trainable", "=", "True", "\n", "self", ".", "built", "=", "True", "\n", "self", ".", "is_placeholder", "=", "False", "\n", "\n", "# create new node", "\n", "tensorflow", ".", "python", ".", "keras", ".", "engine", ".", "base_layer", ".", "node_module", ".", "Node", "(", "self", ",", "\n", "inbound_layers", "=", "[", "]", ",", "\n", "node_indices", "=", "[", "]", ",", "\n", "tensor_indices", "=", "[", "]", ",", "\n", "input_tensors", "=", "[", "]", ",", "\n", "output_tensors", "=", "[", "output_tensor", "]", ",", "\n", "input_masks", "=", "[", "]", ",", "\n", "output_masks", "=", "[", "None", "]", ",", "\n", "input_shapes", "=", "[", "]", ",", "\n", "output_shapes", "=", "self", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalParamLayer.get_config": [[1384, 1391], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "{", "\n", "'dtype'", ":", "self", ".", "dtype", ",", "\n", "'sparse'", ":", "self", ".", "sparse", ",", "\n", "'name'", ":", "self", ".", "name", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalParamWithInput.__init__": [[1408, 1414], ["print", "tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "shape", ",", "initializer", "=", "'RandomNormal'", ",", "mult", "=", "1.0", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "shape", "=", "shape", "\n", "self", ".", "initializer", "=", "initializer", "\n", "self", ".", "biasmult", "=", "mult", "\n", "print", "(", "'LocalParamWithInput: Consider using neuron.layers.LocalParam()'", ")", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalParamWithInput.build": [[1415, 1421], ["layers.LocalParamWithInput.add_weight", "super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "name", "=", "'kernel'", ",", "\n", "shape", "=", "self", ".", "shape", ",", "# input_shape[1:]", "\n", "initializer", "=", "self", ".", "initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "super", "(", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalParamWithInput.call": [[1422, 1429], ["tensorflow.keras.backend.reshape", "tensorflow.keras.backend.batch_flatten", "tensorflow.ones", "tensorflow.keras.backend.flatten", "tensorflow.keras.backend.dot", "tensorflow.zeros"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "# want the x variable for it's keras properties and the batch.", "\n", "        ", "xslice", "=", "K", ".", "batch_flatten", "(", "x", ")", "[", ":", ",", "0", ":", "1", "]", "\n", "b", "=", "xslice", "*", "tf", ".", "zeros", "(", "(", "1", ",", ")", ")", "+", "tf", ".", "ones", "(", "(", "1", ",", ")", ")", "\n", "# b = K.batch_flatten(0 * x)[:, 0:1] + 1", "\n", "params", "=", "K", ".", "flatten", "(", "self", ".", "kernel", "*", "self", ".", "biasmult", ")", "[", "tf", ".", "newaxis", ",", "...", "]", "\n", "return", "K", ".", "reshape", "(", "K", ".", "dot", "(", "b", ",", "params", ")", ",", "[", "-", "1", ",", "*", "self", ".", "shape", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalParamWithInput.compute_output_shape": [[1430, 1432], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "(", "input_shape", "[", "0", "]", ",", "*", "self", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MeanStream.__init__": [[1510, 1513], ["tensorflow.keras.backend.variable", "tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "cap", "=", "100", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "cap", "=", "K", ".", "variable", "(", "cap", ",", "dtype", "=", "'float32'", ")", "\n", "super", "(", "MeanStream", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MeanStream.build": [[1514, 1531], ["layers.MeanStream.add_weight", "layers.MeanStream.add_weight", "super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# Create mean and count", "\n", "# These are weights because just maintaining variables don't get saved with the model, and we'd like", "\n", "# to have these numbers saved when we save the model.", "\n", "# But we need to make sure that the weights are untrainable.", "\n", "        ", "self", ".", "mean", "=", "self", ".", "add_weight", "(", "name", "=", "'mean'", ",", "\n", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "\n", "initializer", "=", "'zeros'", ",", "\n", "trainable", "=", "False", ")", "\n", "self", ".", "count", "=", "self", ".", "add_weight", "(", "name", "=", "'count'", ",", "\n", "shape", "=", "[", "1", "]", ",", "\n", "initializer", "=", "'zeros'", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "# self.mean = K.zeros(input_shape[1:], name='mean')", "\n", "# self.count = K.variable(0.0, name='count')", "\n", "super", "(", "MeanStream", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MeanStream.call": [[1532, 1547], ["layers._mean_update", "layers.MeanStream.add_update", "tensorflow.concat", "tensorflow.ones", "tensorflow.keras.backend.shape", "tensorflow.keras.backend.minimum", "tensorflow.keras.backend.reshape", "tensorflow.keras.backend.shape", "tensorflow.keras.backend.expand_dims"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers._mean_update"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "# get new mean and count", "\n", "        ", "this_bs_int", "=", "K", ".", "shape", "(", "x", ")", "[", "0", "]", "\n", "new_mean", ",", "new_count", "=", "_mean_update", "(", "self", ".", "mean", ",", "self", ".", "count", ",", "x", ",", "self", ".", "cap", ")", "\n", "\n", "# update op", "\n", "updates", "=", "[", "(", "self", ".", "count", ",", "new_count", ")", ",", "(", "self", ".", "mean", ",", "new_mean", ")", "]", "\n", "self", ".", "add_update", "(", "updates", ",", "x", ")", "\n", "\n", "# prep for broadcasting :(", "\n", "p", "=", "tf", ".", "concat", "(", "(", "K", ".", "reshape", "(", "this_bs_int", ",", "(", "1", ",", ")", ")", ",", "K", ".", "shape", "(", "self", ".", "mean", ")", ")", ",", "0", ")", "\n", "z", "=", "tf", ".", "ones", "(", "p", ")", "\n", "\n", "# the first few 1000 should not matter that much towards this cost", "\n", "return", "K", ".", "minimum", "(", "1.", ",", "new_count", "/", "self", ".", "cap", ")", "*", "(", "z", "*", "K", ".", "expand_dims", "(", "new_mean", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MeanStream.compute_output_shape": [[1548, 1550], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MeanStream_old.__init__": [[1559, 1563], ["tensorflow.Variable", "tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "cap", "=", "100", ",", "**", "kwargs", ")", ":", "\n", "#self.cap = K.variable(cap, dtype='float32')", "\n", "        ", "self", ".", "cap", "=", "tf", ".", "Variable", "(", "cap", ",", "dtype", "=", "'float32'", ",", "trainable", "=", "False", ")", "\n", "super", "(", "MeanStream_old", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MeanStream_old.build": [[1564, 1581], ["layers.MeanStream_old.add_weight", "layers.MeanStream_old.add_weight", "super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# Create mean and count", "\n", "# These are weights because just maintaining variables don't get saved with the model, and we'd like", "\n", "# to have these numbers saved when we save the model.", "\n", "# But we need to make sure that the weights are untrainable.", "\n", "        ", "self", ".", "mean", "=", "self", ".", "add_weight", "(", "name", "=", "'mean'", ",", "\n", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "\n", "initializer", "=", "'zeros'", ",", "\n", "trainable", "=", "False", ")", "# was false", "\n", "self", ".", "count", "=", "self", ".", "add_weight", "(", "name", "=", "'count'", ",", "\n", "shape", "=", "[", "1", "]", ",", "\n", "initializer", "=", "'zeros'", ",", "\n", "trainable", "=", "False", ")", "# was false", "\n", "\n", "# self.mean = K.zeros(input_shape[1:], name='mean')", "\n", "# self.count = K.variable(0.0, name='count')", "\n", "super", "(", "MeanStream_old", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MeanStream_old.call": [[1582, 1608], ["tensorflow.reduce_sum", "tensorflow.cast", "layers.MeanStream_old.count.assign", "layers.MeanStream_old.mean.assign", "tensorflow.keras.backend.minimum", "tensorflow.keras.backend.minimum", "tensorflow.keras.backend.expand_dims", "tensorflow.keras.backend.minimum", "tensorflow.keras.backend.expand_dims", "tensorflow.keras.backend.shape"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "trainable", ":", "\n", "# previous mean", "\n", "            ", "pre_mean", "=", "self", ".", "mean", "\n", "\n", "# compute this batch stats", "\n", "this_sum", "=", "tf", ".", "reduce_sum", "(", "x", ",", "0", ")", "\n", "this_bs", "=", "tf", ".", "cast", "(", "K", ".", "shape", "(", "x", ")", "[", "0", "]", ",", "'float32'", ")", "# this batch size", "\n", "\n", "# increase count and compute weights", "\n", "new_count", "=", "self", ".", "count", "+", "this_bs", "\n", "alpha", "=", "this_bs", "/", "K", ".", "minimum", "(", "new_count", ",", "self", ".", "cap", ")", "\n", "\n", "# compute new mean. Note that once we reach self.cap (e.g. 1000), the 'previous mean' matters less", "\n", "new_mean", "=", "pre_mean", "*", "(", "1", "-", "alpha", ")", "+", "(", "this_sum", "/", "this_bs", ")", "*", "alpha", "\n", "\n", "#updates = [(self.count, new_count), (self.mean, new_mean)]", "\n", "#self.add_update(updates, x)", "\n", "\n", "self", ".", "count", ".", "assign", "(", "new_count", ")", "\n", "self", ".", "mean", ".", "assign", "(", "new_mean", ")", "\n", "\n", "# the first few 1000 should not matter that much towards this cost", "\n", "return", "K", ".", "minimum", "(", "1.", ",", "new_count", "/", "self", ".", "cap", ")", "*", "K", ".", "expand_dims", "(", "new_mean", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "return", "K", ".", "minimum", "(", "1.", ",", "self", ".", "count", "/", "self", ".", "cap", ")", "*", "K", ".", "expand_dims", "(", "self", ".", "mean", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.MeanStream_old.compute_output_shape": [[1609, 1611], ["None"], "methods", ["None"], ["", "", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.CovStream.__init__": [[1621, 1624], ["tensorflow.keras.backend.variable", "tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "cap", "=", "100", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "cap", "=", "K", ".", "variable", "(", "cap", ",", "dtype", "=", "'float32'", ")", "\n", "super", "(", "CovStream", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.CovStream.build": [[1625, 1643], ["layers.CovStream.add_weight", "numpy.prod", "layers.CovStream.add_weight", "layers.CovStream.add_weight", "super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# Create mean, cov and and count", "\n", "# See note in MeanStream.build()", "\n", "        ", "self", ".", "mean", "=", "self", ".", "add_weight", "(", "name", "=", "'mean'", ",", "\n", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "\n", "initializer", "=", "'zeros'", ",", "\n", "trainable", "=", "False", ")", "\n", "v", "=", "np", ".", "prod", "(", "input_shape", "[", "1", ":", "]", ")", "\n", "self", ".", "cov", "=", "self", ".", "add_weight", "(", "name", "=", "'cov'", ",", "\n", "shape", "=", "[", "v", ",", "v", "]", ",", "\n", "initializer", "=", "'zeros'", ",", "\n", "trainable", "=", "False", ")", "\n", "self", ".", "count", "=", "self", ".", "add_weight", "(", "name", "=", "'count'", ",", "\n", "shape", "=", "[", "1", "]", ",", "\n", "initializer", "=", "'zeros'", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "super", "(", "CovStream", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.CovStream.call": [[1644, 1674], ["tensorflow.cast", "tensorflow.keras.backend.batch_flatten", "layers._mean_update", "tensorflow.keras.backend.expand_dims", "tensorflow.keras.backend.batch_dot", "tensorflow.keras.backend.minimum", "layers.CovStream.add_update", "tensorflow.concat", "tensorflow.ones", "tensorflow.keras.backend.shape", "tensorflow.keras.backend.permute_dimensions", "tensorflow.keras.backend.sum", "tensorflow.keras.backend.minimum", "tensorflow.keras.backend.reshape", "tensorflow.keras.backend.shape", "tensorflow.keras.backend.expand_dims"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers._mean_update"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "x_orig", "=", "x", "\n", "\n", "# x reshape", "\n", "this_bs_int", "=", "K", ".", "shape", "(", "x", ")", "[", "0", "]", "\n", "this_bs", "=", "tf", ".", "cast", "(", "this_bs_int", ",", "'float32'", ")", "# this batch size", "\n", "prev_count", "=", "self", ".", "count", "\n", "x", "=", "K", ".", "batch_flatten", "(", "x", ")", "# B x N", "\n", "\n", "# update mean", "\n", "new_mean", ",", "new_count", "=", "_mean_update", "(", "self", ".", "mean", ",", "self", ".", "count", ",", "x", ",", "self", ".", "cap", ")", "\n", "\n", "# new C update. Should be B x N x N", "\n", "x", "=", "K", ".", "expand_dims", "(", "x", ",", "-", "1", ")", "\n", "C_delta", "=", "K", ".", "batch_dot", "(", "x", ",", "K", ".", "permute_dimensions", "(", "x", ",", "[", "0", ",", "2", ",", "1", "]", ")", ")", "\n", "\n", "# update cov", "\n", "prev_cap", "=", "K", ".", "minimum", "(", "prev_count", ",", "self", ".", "cap", ")", "\n", "C", "=", "self", ".", "cov", "*", "(", "prev_cap", "-", "1", ")", "+", "K", ".", "sum", "(", "C_delta", ",", "0", ")", "\n", "new_cov", "=", "C", "/", "(", "prev_cap", "+", "this_bs", "-", "1", ")", "\n", "\n", "# updates", "\n", "updates", "=", "[", "(", "self", ".", "count", ",", "new_count", ")", ",", "(", "self", ".", "mean", ",", "new_mean", ")", ",", "(", "self", ".", "cov", ",", "new_cov", ")", "]", "\n", "self", ".", "add_update", "(", "updates", ",", "x_orig", ")", "\n", "\n", "# prep for broadcasting :(", "\n", "p", "=", "tf", ".", "concat", "(", "(", "K", ".", "reshape", "(", "this_bs_int", ",", "(", "1", ",", ")", ")", ",", "K", ".", "shape", "(", "self", ".", "cov", ")", ")", ",", "0", ")", "\n", "z", "=", "tf", ".", "ones", "(", "p", ")", "\n", "\n", "return", "K", ".", "minimum", "(", "1.", ",", "new_count", "/", "self", ".", "cap", ")", "*", "(", "z", "*", "K", ".", "expand_dims", "(", "new_cov", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.CovStream.compute_output_shape": [[1675, 1678], ["numpy.prod"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "v", "=", "np", ".", "prod", "(", "input_shape", "[", "1", ":", "]", ")", "\n", "return", "(", "input_shape", "[", "0", "]", ",", "v", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.FFT.__init__": [[1706, 1708], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "FFT", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.FFT.build": [[1709, 1716], ["super().build", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# some input checking", "\n", "        ", "self", ".", "ndims", "=", "len", "(", "input_shape", ")", "-", "2", "\n", "assert", "self", ".", "ndims", "in", "[", "1", ",", "2", ",", "3", "]", ",", "'only 1D, 2D or 3D supported'", "\n", "\n", "# super", "\n", "super", "(", "FFT", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.FFT.call": [[1717, 1739], ["tensorflow.keras.backend.permute_dimensions", "fft", "tensorflow.keras.backend.permute_dimensions", "print", "tensorflow.cast", "list", "range", "list", "range"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "call", "(", "self", ",", "inputx", ")", ":", "\n", "\n", "        ", "if", "not", "inputx", ".", "dtype", "in", "[", "tf", ".", "complex64", ",", "tf", ".", "complex128", "]", ":", "\n", "            ", "print", "(", "'Warning: inputx is not complex. Converting.'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# if inputx is float, this will assume 0 imag channel", "\n", "inputx", "=", "tf", ".", "cast", "(", "inputx", ",", "tf", ".", "complex64", ")", "\n", "\n", "# get the right fft", "\n", "", "if", "self", ".", "ndims", "==", "1", ":", "\n", "            ", "fft", "=", "tf", ".", "fft", "\n", "", "elif", "self", ".", "ndims", "==", "2", ":", "\n", "            ", "fft", "=", "tf", ".", "fft2d", "\n", "", "else", ":", "\n", "            ", "fft", "=", "tf", ".", "fft3d", "\n", "\n", "", "perm_dims", "=", "[", "0", ",", "self", ".", "ndims", "+", "1", "]", "+", "list", "(", "range", "(", "1", ",", "self", ".", "ndims", "+", "1", ")", ")", "\n", "invert_perm_ndims", "=", "[", "0", "]", "+", "list", "(", "range", "(", "2", ",", "self", ".", "ndims", "+", "2", ")", ")", "+", "[", "1", "]", "\n", "\n", "perm_inputx", "=", "K", ".", "permute_dimensions", "(", "inputx", ",", "perm_dims", ")", "# [batch_size, nb_features, *vol_size]", "\n", "fft_inputx", "=", "fft", "(", "perm_inputx", ")", "\n", "return", "K", ".", "permute_dimensions", "(", "fft_inputx", ",", "invert_perm_ndims", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.FFT.compute_output_shape": [[1740, 1742], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.IFFT.__init__": [[1751, 1753], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "IFFT", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.IFFT.build": [[1754, 1761], ["super().build", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# some input checking", "\n", "        ", "self", ".", "ndims", "=", "len", "(", "input_shape", ")", "-", "2", "\n", "assert", "self", ".", "ndims", "in", "[", "1", ",", "2", ",", "3", "]", ",", "'only 1D, 2D or 3D supported'", "\n", "\n", "# super", "\n", "super", "(", "IFFT", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.IFFT.call": [[1762, 1784], ["tensorflow.keras.backend.permute_dimensions", "ifft", "tensorflow.keras.backend.permute_dimensions", "print", "tensorflow.cast", "list", "range", "list", "range"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "call", "(", "self", ",", "inputx", ")", ":", "\n", "\n", "        ", "if", "not", "inputx", ".", "dtype", "in", "[", "tf", ".", "complex64", ",", "tf", ".", "complex128", "]", ":", "\n", "            ", "print", "(", "'Warning: inputx is not complex. Converting.'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# if inputx is float, this will assume 0 imag channel", "\n", "inputx", "=", "tf", ".", "cast", "(", "inputx", ",", "tf", ".", "complex64", ")", "\n", "\n", "# get the right fft", "\n", "", "if", "self", ".", "ndims", "==", "1", ":", "\n", "            ", "ifft", "=", "tf", ".", "ifft", "\n", "", "elif", "self", ".", "ndims", "==", "2", ":", "\n", "            ", "ifft", "=", "tf", ".", "ifft2d", "\n", "", "else", ":", "\n", "            ", "ifft", "=", "tf", ".", "ifft3d", "\n", "\n", "", "perm_dims", "=", "[", "0", ",", "self", ".", "ndims", "+", "1", "]", "+", "list", "(", "range", "(", "1", ",", "self", ".", "ndims", "+", "1", ")", ")", "\n", "invert_perm_ndims", "=", "[", "0", "]", "+", "list", "(", "range", "(", "2", ",", "self", ".", "ndims", "+", "2", ")", ")", "+", "[", "1", "]", "\n", "\n", "perm_inputx", "=", "K", ".", "permute_dimensions", "(", "inputx", ",", "perm_dims", ")", "# [batch_size, nb_features, *vol_size]", "\n", "ifft_inputx", "=", "ifft", "(", "perm_inputx", ")", "\n", "return", "K", ".", "permute_dimensions", "(", "ifft_inputx", ",", "invert_perm_ndims", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.IFFT.compute_output_shape": [[1785, 1787], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ComplexToChannels.__init__": [[1791, 1793], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ComplexToChannels", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ComplexToChannels.build": [[1794, 1797], ["super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# super", "\n", "        ", "super", "(", "ComplexToChannels", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ComplexToChannels.call": [[1798, 1803], ["tensorflow.concat", "tensorflow.real", "tensorflow.imag"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputx", ")", ":", "\n", "\n", "        ", "assert", "inputx", ".", "dtype", "in", "[", "tf", ".", "complex64", ",", "tf", ".", "complex128", "]", ",", "'inputx is not complex.'", "\n", "\n", "return", "tf", ".", "concat", "(", "[", "tf", ".", "real", "(", "inputx", ")", ",", "tf", ".", "imag", "(", "inputx", ")", "]", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ComplexToChannels.compute_output_shape": [[1804, 1808], ["list", "tuple"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "i_s", "=", "list", "(", "input_shape", ")", "\n", "i_s", "[", "-", "1", "]", "*=", "2", "\n", "return", "tuple", "(", "i_s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ChannelsToComplex.__init__": [[1812, 1814], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ChannelsToComplex", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ChannelsToComplex.build": [[1815, 1818], ["super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# super", "\n", "        ", "super", "(", "ChannelsToComplex", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ChannelsToComplex.call": [[1819, 1822], ["tensorflow.complex"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputx", ")", ":", "\n", "        ", "nb_channels", "=", "inputx", ".", "shape", "[", "-", "1", "]", "//", "2", "\n", "return", "tf", ".", "complex", "(", "inputx", "[", "...", ",", ":", "nb_channels", "]", ",", "inputx", "[", "...", ",", "nb_channels", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ChannelsToComplex.compute_output_shape": [[1823, 1827], ["list", "tuple"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "i_s", "=", "list", "(", "input_shape", ")", "\n", "i_s", "[", "-", "1", "]", "=", "i_s", "[", "-", "1", "]", "//", "2", "\n", "return", "tuple", "(", "i_s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.FFTShift.__init__": [[1850, 1853], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "axes", "=", "axes", "\n", "super", "(", "FFTShift", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.FFTShift.build": [[1854, 1861], ["super().build", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# some input checking", "\n", "        ", "self", ".", "ndims", "=", "len", "(", "input_shape", ")", "-", "2", "\n", "assert", "self", ".", "ndims", "in", "[", "1", ",", "2", ",", "3", "]", ",", "'only 1D, 2D or 3D supported'", "\n", "\n", "# super", "\n", "super", "(", "FFTShift", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.FFTShift.call": [[1862, 1873], ["tensorflow.python.roll", "tuple", "isinstance", "range", "tensorflow.keras.backend.ndim"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "axes", "=", "self", ".", "axes", "\n", "if", "axes", "is", "None", ":", "\n", "            ", "axes", "=", "tuple", "(", "range", "(", "K", ".", "ndim", "(", "x", ")", ")", ")", "\n", "shift", "=", "[", "0", "]", "+", "[", "dim", "//", "2", "for", "dim", "in", "x", ".", "shape", "]", "+", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "axes", ",", "int", ")", ":", "\n", "            ", "shift", "=", "x", ".", "shape", "[", "axes", "]", "//", "2", "\n", "", "else", ":", "\n", "            ", "shift", "=", "[", "x", ".", "shape", "[", "ax", "]", "//", "2", "for", "ax", "in", "axes", "]", "\n", "\n", "", "return", "_roll", "(", "x", ",", "shift", ",", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.FFTShift.compute_output_shape": [[1874, 1876], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.IFFTShift.__init__": [[1897, 1900], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "axes", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "axes", "=", "axes", "\n", "super", "(", "IFFTShift", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.IFFTShift.build": [[1901, 1908], ["super().build", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# some input checking", "\n", "        ", "self", ".", "ndims", "=", "len", "(", "input_shape", ")", "-", "2", "\n", "assert", "self", ".", "ndims", "in", "[", "1", ",", "2", ",", "3", "]", ",", "'only 1D, 2D or 3D supported'", "\n", "\n", "# super", "\n", "super", "(", "IFFTShift", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.IFFTShift.call": [[1909, 1920], ["tensorflow.python.roll", "tuple", "isinstance", "range", "tensorflow.keras.backend.ndim", "x.shape.as_list"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "axes", "=", "self", ".", "axes", "\n", "if", "axes", "is", "None", ":", "\n", "            ", "axes", "=", "tuple", "(", "range", "(", "K", ".", "ndim", "(", "x", ")", ")", ")", "\n", "shift", "=", "[", "0", "]", "+", "[", "-", "(", "dim", "//", "2", ")", "for", "dim", "in", "x", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "-", "1", "]", "]", "+", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "axes", ",", "int", ")", ":", "\n", "            ", "shift", "=", "-", "(", "x", ".", "shape", "[", "axes", "]", "//", "2", ")", "\n", "", "else", ":", "\n", "            ", "shift", "=", "[", "-", "(", "x", ".", "shape", "[", "ax", "]", "//", "2", ")", "for", "ax", "in", "axes", "]", "\n", "\n", "", "return", "_roll", "(", "x", ",", "shift", ",", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.IFFTShift.compute_output_shape": [[1921, 1923], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SampleNormalLogVar.__init__": [[1937, 1939], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "SampleNormalLogVar", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SampleNormalLogVar.build": [[1940, 1942], ["super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "SampleNormalLogVar", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SampleNormalLogVar.call": [[1943, 1945], ["layers.SampleNormalLogVar._sample"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SampleNormalLogVar._sample"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "_sample", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SampleNormalLogVar.compute_output_shape": [[1946, 1948], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SampleNormalLogVar._sample": [[1949, 1966], ["tensorflow.random_normal", "tensorflow.shape", "tensorflow.exp"], "methods", ["None"], ["", "def", "_sample", "(", "self", ",", "args", ")", ":", "\n", "        ", "\"\"\"\n        sample from a normal distribution\n\n        args should be [mu, log_var], where log_var is the log of the squared sigma\n\n        This is probably equivalent to \n            K.random_normal(shape, args[0], exp(args[1]/2.0))\n        \"\"\"", "\n", "mu", ",", "log_var", "=", "args", "\n", "\n", "# sample from N(0, 1)", "\n", "noise", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "mu", ")", ",", "0", ",", "1", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "# make it a sample from N(mu, sigma^2)", "\n", "z", "=", "mu", "+", "tf", ".", "exp", "(", "log_var", "/", "2.0", ")", "*", "noise", "\n", "return", "z", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.LocalParam": [[1434, 1495], ["layers.LocalParamLayer", "len"], "function", ["None"], ["", "", "def", "LocalParam", "(", "# pylint: disable=invalid-name", "\n", "shape", ",", "\n", "batch_size", "=", "None", ",", "\n", "name", "=", "None", ",", "\n", "dtype", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    `LocalParam()` is used to instantiate a Keras tensor.\n    A Keras tensor is a tensor object from the underlying backend\n    (Theano or TensorFlow), which we augment with certain\n    attributes that allow us to build a Keras model\n    just by knowing the inputs and outputs of the model.\n    For instance, if a, b and c are Keras tensors,\n    it becomes possible to do:\n    `model = Model(input=[a, b], output=c)`\n    The added Keras attribute is:\n            `_keras_history`: Last layer applied to the tensor.\n                    the entire layer graph is retrievable from that layer,\n                    recursively.\n    Arguments:\n            shape: A shape tuple (integers), not including the batch size.\n                    For instance, `shape=(32,)` indicates that the expected input\n                    will be batches of 32-dimensional vectors. Elements of this tuple\n                    can be None; 'None' elements represent dimensions where the shape is\n                    not known.\n            batch_size: optional static batch size (integer).\n            name: An optional name string for the layer.\n                    Should be unique in a model (do not reuse the same name twice).\n                    It will be autogenerated if it isn't provided.\n            dtype: The data type expected by the input, as a string\n                    (`float32`, `float64`, `int32`...)\n            **kwargs: deprecated arguments support.\n    Returns:\n        A `tensor`.\n    Example:\n    ```python\n    # this is a logistic regression in Keras\n    x = Input(shape=(32,))\n    y = Dense(16, activation='softmax')(x)\n    model = Model(x, y)\n    ```\n    Note that even if eager execution is enabled,\n    `Input` produces a symbolic tensor (i.e. a placeholder).\n    This symbolic tensor can be used with other\n    TensorFlow ops, as such:\n    ```python\n    x = Input(shape=(32,))\n    y = tf.square(x)\n    ```\n    Raises:\n        ValueError: in case of invalid arguments.\n    \"\"\"", "\n", "input_layer", "=", "LocalParamLayer", "(", "shape", ",", "name", "=", "name", ",", "dtype", "=", "dtype", ")", "\n", "\n", "# Return tensor including `_keras_history`.", "\n", "# Note that in this case train_output and test_output are the same pointer.", "\n", "outputs", "=", "input_layer", ".", "_inbound_nodes", "[", "0", "]", ".", "output_tensors", "\n", "if", "len", "(", "outputs", ")", "==", "1", ":", "\n", "        ", "return", "outputs", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers._mean_update": [[1680, 1694], ["tensorflow.reduce_sum", "tensorflow.cast", "tensorflow.keras.backend.minimum", "tensorflow.keras.backend.shape"], "function", ["None"], ["", "", "def", "_mean_update", "(", "pre_mean", ",", "pre_count", ",", "x", ",", "pre_cap", "=", "None", ")", ":", "\n", "\n", "# compute this batch stats", "\n", "    ", "this_sum", "=", "tf", ".", "reduce_sum", "(", "x", ",", "0", ")", "\n", "this_bs", "=", "tf", ".", "cast", "(", "K", ".", "shape", "(", "x", ")", "[", "0", "]", ",", "'float32'", ")", "# this batch size", "\n", "\n", "# increase count and compute weights", "\n", "new_count", "=", "pre_count", "+", "this_bs", "\n", "alpha", "=", "this_bs", "/", "K", ".", "minimum", "(", "new_count", ",", "pre_cap", ")", "\n", "\n", "# compute new mean. Note that once we reach self.cap (e.g. 1000), the 'previous mean' matters less", "\n", "new_mean", "=", "pre_mean", "*", "(", "1", "-", "alpha", ")", "+", "(", "this_sum", "/", "this_bs", ")", "*", "alpha", "\n", "\n", "return", "(", "new_mean", ",", "new_count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.regularizers.soft_l0_wrap": [[26, 37], ["tensorflow.cast", "tensorflow.reduce_sum", "tensorflow.size", "utils.soft_delta", "tensorflow.flatten"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.soft_delta", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten"], ["def", "soft_l0_wrap", "(", "wt", "=", "1.", ")", ":", "\n", "\n", "    ", "def", "soft_l0", "(", "x", ")", ":", "\n", "        ", "\"\"\"\n        maximize the number of 0 weights\n        \"\"\"", "\n", "nb_weights", "=", "tf", ".", "cast", "(", "tf", ".", "size", "(", "x", ")", ",", "tf", ".", "float32", ")", "\n", "nb_zero_wts", "=", "tf", ".", "reduce_sum", "(", "soft_delta", "(", "K", ".", "flatten", "(", "x", ")", ")", ")", "\n", "return", "wt", "*", "(", "nb_weights", "-", "nb_zero_wts", ")", "/", "nb_weights", "\n", "\n", "", "return", "soft_l0", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelWeightCheck.__init__": [[34, 50], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "\n", "weight_diff", "=", "False", ",", "\n", "at_batch_end", "=", "False", ",", "\n", "at_epoch_end", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Params:\n            at_batch_end: None or number indicate when to execute\n                (i.e. at_batch_end = 10 means execute every 10 batches)\n            at_epoch_end: logical, whether to execute at epoch end\n        \"\"\"", "\n", "super", "(", "ModelWeightCheck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "at_batch_end", "=", "at_batch_end", "\n", "self", ".", "at_epoch_end", "=", "at_epoch_end", "\n", "self", ".", "current_epoch", "=", "0", "\n", "self", ".", "weight_diff", "=", "weight_diff", "\n", "self", ".", "wts", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelWeightCheck.on_batch_end": [[51, 54], ["callbacks.ModelWeightCheck.on_model_check", "numpy.mod"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.CheckLossTrend.on_model_check"], ["", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "at_batch_end", "is", "not", "None", "and", "np", ".", "mod", "(", "batch", "+", "1", ",", "self", ".", "at_batch_end", ")", "==", "0", ":", "\n", "            ", "self", ".", "on_model_check", "(", "self", ".", "current_epoch", ",", "batch", "+", "1", ",", "logs", "=", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelWeightCheck.on_epoch_end": [[55, 59], ["callbacks.ModelWeightCheck.on_model_check"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.CheckLossTrend.on_model_check"], ["", "", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "at_epoch_end", ":", "\n", "            ", "self", ".", "on_model_check", "(", "epoch", ",", "0", ",", "logs", "=", "logs", ")", "\n", "", "self", ".", "current_epoch", "=", "epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelWeightCheck.on_model_check": [[60, 79], ["layer.get_weights", "callbacks.ModelWeightCheck.model.get_weights", "numpy.all", "enumerate", "numpy.any", "numpy.isfinite", "numpy.isnan", "len", "enumerate", "numpy.maximum", "numpy.max", "numpy.abs"], "methods", ["None"], ["", "def", "on_model_check", "(", "self", ",", "epoch", ",", "iter", ",", "logs", "=", "None", ")", ":", "\n", "        ", "for", "layer", "in", "self", ".", "model", ".", "layers", ":", "\n", "            ", "for", "wt", "in", "layer", ".", "get_weights", "(", ")", ":", "\n", "                ", "assert", "~", "np", ".", "any", "(", "np", ".", "isnan", "(", "wt", ")", ")", ",", "'Found nan weights in model layer %s'", "%", "layer", ".", "name", "\n", "assert", "np", ".", "all", "(", "np", ".", "isfinite", "(", "wt", ")", ")", ",", "'Found infinite weights in model layer %s'", "%", "layer", ".", "name", "\n", "\n", "# compute max change", "\n", "", "", "if", "self", ".", "weight_diff", ":", "\n", "            ", "wts", "=", "self", ".", "model", ".", "get_weights", "(", ")", "\n", "diff", "=", "-", "np", ".", "inf", "\n", "\n", "if", "self", ".", "wts", "is", "not", "None", ":", "\n", "                ", "for", "wi", ",", "w", "in", "enumerate", "(", "wts", ")", ":", "\n", "                    ", "if", "len", "(", "w", ")", ">", "0", ":", "\n", "                        ", "for", "si", ",", "sw", "in", "enumerate", "(", "w", ")", ":", "\n", "                            ", "diff", "=", "np", ".", "maximum", "(", "diff", ",", "np", ".", "max", "(", "np", ".", "abs", "(", "sw", "-", "self", ".", "wts", "[", "wi", "]", "[", "si", "]", ")", ")", ")", "\n", "\n", "", "", "", "", "self", ".", "wts", "=", "wts", "\n", "logs", "[", "'max_diff'", "]", "=", "diff", "\n", "# print(\"max diff\", diff)", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.CheckLossTrend.__init__": [[87, 105], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "\n", "at_batch_end", "=", "True", ",", "\n", "at_epoch_end", "=", "False", ",", "\n", "nb_std_err", "=", "2", ",", "\n", "loss_window", "=", "10", ")", ":", "\n", "        ", "\"\"\"\n        Params:\n            at_batch_end: None or number indicate when to execute\n                (i.e. at_batch_end = 10 means execute every 10 batches)\n            at_epoch_end: logical, whether to execute at epoch end\n        \"\"\"", "\n", "super", "(", "CheckLossTrend", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "at_batch_end", "=", "at_batch_end", "\n", "self", ".", "at_epoch_end", "=", "at_epoch_end", "\n", "self", ".", "current_epoch", "=", "0", "\n", "self", ".", "loss_window", "=", "loss_window", "\n", "self", ".", "nb_std_err", "=", "nb_std_err", "\n", "self", ".", "losses", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.CheckLossTrend.on_batch_end": [[106, 109], ["callbacks.CheckLossTrend.on_model_check", "numpy.mod"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.CheckLossTrend.on_model_check"], ["", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "at_batch_end", "is", "not", "None", "and", "np", ".", "mod", "(", "batch", "+", "1", ",", "self", ".", "at_batch_end", ")", "==", "0", ":", "\n", "            ", "self", ".", "on_model_check", "(", "self", ".", "current_epoch", ",", "batch", "+", "1", ",", "logs", "=", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.CheckLossTrend.on_epoch_end": [[110, 114], ["callbacks.CheckLossTrend.on_model_check"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.CheckLossTrend.on_model_check"], ["", "", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "at_epoch_end", ":", "\n", "            ", "self", ".", "on_model_check", "(", "epoch", ",", "0", ",", "logs", "=", "logs", ")", "\n", "", "self", ".", "current_epoch", "=", "epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.CheckLossTrend.on_model_check": [[115, 135], ["len", "numpy.mean", "numpy.std", "print", "print", "ValueError"], "methods", ["None"], ["", "def", "on_model_check", "(", "self", ",", "epoch", ",", "iter", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "losses", ")", "<", "self", ".", "loss_window", ":", "\n", "            ", "self", ".", "losses", "=", "[", "*", "self", ".", "losses", ",", "logs", "[", "'loss'", "]", "]", "\n", "", "else", ":", "\n", "            ", "losses_mean", "=", "np", ".", "mean", "(", "self", ".", "losses", ")", "\n", "losses_std", "=", "np", ".", "std", "(", "self", ".", "losses", ")", "\n", "this_loss", "=", "logs", "[", "'loss'", "]", "\n", "\n", "if", "(", "this_loss", ")", ">", "(", "losses_mean", "+", "self", ".", "nb_std_err", "*", "losses_std", ")", ":", "\n", "                ", "print", "(", "logs", ")", "\n", "err", "=", "\"Found loss %f, which is much higher than %f + %f \"", "%", "(", "this_loss", ",", "losses_mean", ",", "losses_std", ")", "\n", "# raise ValueError(err)", "\n", "print", "(", "err", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "if", "(", "this_loss", "-", "losses_mean", ")", ">", "(", "losses_mean", "*", "100", ")", ":", "\n", "                ", "err", "=", "\"Found loss %f, which is much higher than %f * 100 \"", "%", "(", "this_loss", ",", "losses_mean", ")", "\n", "raise", "ValueError", "(", "err", ")", "\n", "\n", "# cut the first loss and stack athe latest loss.", "\n", "", "self", ".", "losses", "=", "[", "*", "self", ".", "losses", "[", "1", ":", "]", ",", "logs", "[", "'loss'", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PlotTestSlices.__init__": [[142, 190], ["super().__init__", "numpy.load", "numpy.expand_dims"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], ["def", "__init__", "(", "self", ",", "\n", "savefilepath", ",", "\n", "generator", ",", "\n", "vol_size", ",", "\n", "run", ",", "# object with fields: patch_size, patch_stride, grid_size", "\n", "data", ",", "# object with fields:", "\n", "at_batch_end", "=", "None", ",", "# None or number indicate when to execute (i.e. at_batch_end = 10 means execute every 10 batches)", "\n", "at_epoch_end", "=", "True", ",", "# logical, whether to execute at epoch end", "\n", "verbose", "=", "False", ",", "\n", "period", "=", "1", ",", "\n", "prior", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameteres:\n            savefilepath,\n            generator,\n            vol_size,\n            run: object with fields: patch_size, patch_stride, grid_size\n            data: object with fields:\n            at_batch_end=None: None or number indicate when to execute (i.e. at_batch_end = 10 means execute every 10 batches)\n            at_epoch_end=True: logical, whether to execute at epoch end\n            verbose=False:\n            period=1\n            prior=None\n        \"\"\"", "\n", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# save some parameters", "\n", "self", ".", "savefilepath", "=", "savefilepath", "\n", "self", ".", "generator", "=", "generator", "\n", "self", ".", "vol_size", "=", "vol_size", "\n", "\n", "self", ".", "run", "=", "run", "\n", "self", ".", "data", "=", "data", "\n", "\n", "self", ".", "at_batch_end", "=", "at_batch_end", "\n", "self", ".", "at_epoch_end", "=", "at_epoch_end", "\n", "self", ".", "current_epoch", "=", "0", "\n", "self", ".", "period", "=", "period", "\n", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "# prepare prior", "\n", "self", ".", "prior", "=", "None", "\n", "if", "prior", "is", "not", "None", ":", "\n", "            ", "data", "=", "np", ".", "load", "(", "prior", ")", "\n", "loc_vol", "=", "data", "[", "'prior'", "]", "\n", "self", ".", "prior", "=", "np", ".", "expand_dims", "(", "loc_vol", ",", "axis", "=", "0", ")", "# reshape for model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PlotTestSlices.on_batch_end": [[191, 194], ["callbacks.PlotTestSlices.on_plot_save", "numpy.mod"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PlotTestSlices.on_plot_save"], ["", "", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "{", "}", ")", ":", "\n", "        ", "if", "self", ".", "at_batch_end", "is", "not", "None", "and", "np", ".", "mod", "(", "batch", "+", "1", ",", "self", ".", "at_batch_end", ")", "==", "0", ":", "\n", "            ", "self", ".", "on_plot_save", "(", "self", ".", "current_epoch", ",", "batch", "+", "1", ",", "logs", "=", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PlotTestSlices.on_epoch_end": [[195, 199], ["callbacks.PlotTestSlices.on_plot_save", "numpy.mod"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PlotTestSlices.on_plot_save"], ["", "", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "{", "}", ")", ":", "\n", "        ", "if", "self", ".", "at_epoch_end", "and", "np", ".", "mod", "(", "epoch", "+", "1", ",", "self", ".", "period", ")", "==", "0", ":", "\n", "            ", "self", ".", "on_plot_save", "(", "epoch", ",", "0", ",", "logs", "=", "logs", ")", "\n", "", "self", ".", "current_epoch", "=", "epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PlotTestSlices.on_plot_save": [[200, 233], ["pytools.Timer", "show_example_prediction_result", "enumerate", "matplotlib.close", "len", "callbacks.PlotTestSlices.savefilepath.format", "fig.savefig"], "methods", ["None"], ["", "def", "on_plot_save", "(", "self", ",", "epoch", ",", "iter", ",", "logs", "=", "{", "}", ")", ":", "\n", "# import neuron sandbox", "\n", "# has to be here, can't be at the top, due to cyclical imports (??)", "\n", "# TODO: should just pass the function to compute the figures given the model and generator", "\n", "\n", "        ", "with", "timer", ".", "Timer", "(", "'plot callback'", ",", "self", ".", "verbose", ")", ":", "\n", "            ", "if", "len", "(", "self", ".", "run", ".", "grid_size", ")", "==", "3", ":", "\n", "                ", "collapse_2d", "=", "[", "0", ",", "1", ",", "2", "]", "\n", "", "else", ":", "\n", "                ", "collapse_2d", "=", "[", "2", "]", "\n", "\n", "# TODO: show_example_prediction_result is actually in neuron_sandbox for now", "\n", "", "exampl", "=", "show_example_prediction_result", "(", "self", ".", "model", ",", "\n", "self", ".", "generator", ",", "\n", "self", ".", "run", ",", "\n", "self", ".", "data", ",", "\n", "test_batch_size", "=", "1", ",", "\n", "test_model_names", "=", "None", ",", "\n", "test_grid_size", "=", "self", ".", "run", ".", "grid_size", ",", "\n", "ccmap", "=", "None", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "slice_nr", "=", "None", ",", "\n", "plt_width", "=", "17", ",", "\n", "verbose", "=", "self", ".", "verbose", ")", "\n", "\n", "# save, then close", "\n", "figs", "=", "exampl", "[", "1", ":", "]", "\n", "for", "idx", ",", "fig", "in", "enumerate", "(", "figs", ")", ":", "\n", "                ", "dirn", "=", "\"dirn_%d\"", "%", "idx", "\n", "slice_nr", "=", "0", "\n", "filename", "=", "self", ".", "savefilepath", ".", "format", "(", "epoch", "=", "epoch", ",", "iter", "=", "iter", ",", "axis", "=", "dirn", ",", "slice_nr", "=", "slice_nr", ")", "\n", "fig", ".", "savefig", "(", "filename", ")", "\n", "", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PredictMetrics.__init__": [[241, 290], ["list", "range"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["def", "__init__", "(", "self", ",", "\n", "filepath", ",", "\n", "metrics", ",", "\n", "data_generator", ",", "\n", "nb_samples", ",", "\n", "nb_labels", ",", "\n", "batch_size", ",", "\n", "label_ids", "=", "None", ",", "\n", "vol_params", "=", "None", ",", "\n", "at_batch_end", "=", "None", ",", "\n", "at_epoch_end", "=", "True", ",", "\n", "period", "=", "1", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Parameters:\n            filepath: filepath with epoch and metric\n            metrics: list of metrics (functions)\n            data_generator: validation generator\n            nb_samples: number of validation samples - volumes or batches\n                depending on whether vol_params is passed or not\n            nb_labels: number of labels\n            batch_size:\n            label_ids=None:\n            vol_params=None:\n            at_batch_end=None: None or number indicate when to execute\n                (i.e. at_batch_end = 10 means execute every 10 batches)\n            at_epoch_end=True: logical, whether to execute at epoch end\n            verbose=False\n        \"\"\"", "\n", "\n", "# pass in the parameters to object variables", "\n", "self", ".", "metrics", "=", "metrics", "\n", "self", ".", "data_generator", "=", "data_generator", "\n", "self", ".", "nb_samples", "=", "nb_samples", "\n", "self", ".", "filepath", "=", "filepath", "\n", "self", ".", "nb_labels", "=", "nb_labels", "\n", "if", "label_ids", "is", "None", ":", "\n", "            ", "self", ".", "label_ids", "=", "list", "(", "range", "(", "nb_labels", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "label_ids", "=", "label_ids", "\n", "", "self", ".", "vol_params", "=", "vol_params", "\n", "\n", "self", ".", "current_epoch", "=", "1", "\n", "self", ".", "at_batch_end", "=", "at_batch_end", "\n", "self", ".", "at_epoch_end", "=", "at_epoch_end", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "period", "=", "period", "\n", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PredictMetrics.on_batch_end": [[291, 294], ["callbacks.PredictMetrics.on_metric_call", "numpy.mod"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PredictMetrics.on_metric_call"], ["", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "{", "}", ")", ":", "\n", "        ", "if", "self", ".", "at_batch_end", "is", "not", "None", "and", "np", ".", "mod", "(", "batch", "+", "1", ",", "self", ".", "at_batch_end", ")", "==", "0", ":", "\n", "            ", "self", ".", "on_metric_call", "(", "self", ".", "current_epoch", ",", "batch", "+", "1", ",", "logs", "=", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PredictMetrics.on_epoch_end": [[295, 299], ["callbacks.PredictMetrics.on_metric_call", "numpy.mod"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PredictMetrics.on_metric_call"], ["", "", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "{", "}", ")", ":", "\n", "        ", "if", "self", ".", "at_epoch_end", "and", "np", ".", "mod", "(", "epoch", "+", "1", ",", "self", ".", "period", ")", "==", "0", ":", "\n", "            ", "self", ".", "on_metric_call", "(", "epoch", ",", "0", ",", "logs", "=", "logs", ")", "\n", "", "self", ".", "current_epoch", "=", "epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.PredictMetrics.on_metric_call": [[300, 332], ["pytools.Timer", "numpy.zeros", "callbacks._generate_predictions", "enumerate", "enumerate", "numpy.nanmean", "enumerate", "len", "metric", "callbacks.PredictMetrics.filepath.format", "numpy.savetxt", "range"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks._generate_predictions", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "on_metric_call", "(", "self", ",", "epoch", ",", "iter", ",", "logs", "=", "{", "}", ")", ":", "\n", "        ", "\"\"\" compute metrics on several predictions \"\"\"", "\n", "with", "timer", ".", "Timer", "(", "'predict metrics callback'", ",", "self", ".", "verbose", ")", ":", "\n", "\n", "# prepare metric", "\n", "            ", "met", "=", "np", ".", "zeros", "(", "(", "self", ".", "nb_samples", ",", "self", ".", "nb_labels", ",", "len", "(", "self", ".", "metrics", ")", ")", ")", "\n", "\n", "# generate predictions", "\n", "# the idea is to predict either a full volume or just a slice,", "\n", "# depending on what we need", "\n", "gen", "=", "_generate_predictions", "(", "self", ".", "model", ",", "\n", "self", ".", "data_generator", ",", "\n", "self", ".", "batch_size", ",", "\n", "self", ".", "nb_samples", ",", "\n", "self", ".", "vol_params", ")", "\n", "batch_idx", "=", "0", "\n", "for", "(", "vol_true", ",", "vol_pred", ")", "in", "gen", ":", "\n", "                ", "for", "idx", ",", "metric", "in", "enumerate", "(", "self", ".", "metrics", ")", ":", "\n", "                    ", "met", "[", "batch_idx", ",", ":", ",", "idx", "]", "=", "metric", "(", "vol_true", ",", "vol_pred", ")", "\n", "", "batch_idx", "+=", "1", "\n", "\n", "# write metric to csv file", "\n", "", "if", "self", ".", "filepath", "is", "not", "None", ":", "\n", "                ", "for", "idx", ",", "metric", "in", "enumerate", "(", "self", ".", "metrics", ")", ":", "\n", "                    ", "filen", "=", "self", ".", "filepath", ".", "format", "(", "epoch", "=", "epoch", ",", "iter", "=", "iter", ",", "metric", "=", "metric", ".", "__name__", ")", "\n", "np", ".", "savetxt", "(", "filen", ",", "met", "[", ":", ",", ":", ",", "idx", "]", ",", "fmt", "=", "'%f'", ",", "delimiter", "=", "','", ")", "\n", "", "", "else", ":", "\n", "                ", "meanmet", "=", "np", ".", "nanmean", "(", "met", ",", "axis", "=", "0", ")", "\n", "for", "midx", ",", "metric", "in", "enumerate", "(", "self", ".", "metrics", ")", ":", "\n", "                    ", "for", "idx", "in", "range", "(", "self", ".", "nb_labels", ")", ":", "\n", "                        ", "varname", "=", "'%s_label_%d'", "%", "(", "metric", ".", "__name__", ",", "self", ".", "label_ids", "[", "idx", "]", ")", "\n", "logs", "[", "varname", "]", "=", "meanmet", "[", "idx", ",", "midx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpoint.__init__": [[369, 416], ["super().__init__", "warnings.warn", "callbacks.ModelCheckpoint.monitor.startswith"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "filepath", ",", "\n", "monitor", "=", "'val_loss'", ",", "\n", "save_best_only", "=", "False", ",", "\n", "save_weights_only", "=", "False", ",", "\n", "at_batch_end", "=", "None", ",", "\n", "at_epoch_end", "=", "True", ",", "\n", "mode", "=", "'auto'", ",", "period", "=", "1", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Parameters:\n            ...\n            at_batch_end=None: None or number indicate when to execute\n                (i.e. at_batch_end = 10 means execute every 10 batches)\n            at_epoch_end=True: logical, whether to execute at epoch end\n        \"\"\"", "\n", "super", "(", "ModelCheckpoint", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "monitor", "=", "monitor", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "filepath", "=", "filepath", "\n", "self", ".", "save_best_only", "=", "save_best_only", "\n", "self", ".", "save_weights_only", "=", "save_weights_only", "\n", "self", ".", "period", "=", "period", "\n", "self", ".", "steps_since_last_save", "=", "0", "\n", "\n", "if", "mode", "not", "in", "[", "'auto'", ",", "'min'", ",", "'max'", "]", ":", "\n", "            ", "warnings", ".", "warn", "(", "'ModelCheckpoint mode %s is unknown, '", "\n", "'fallback to auto mode.'", "%", "(", "mode", ")", ",", "\n", "RuntimeWarning", ")", "\n", "mode", "=", "'auto'", "\n", "\n", "", "if", "mode", "==", "'min'", ":", "\n", "            ", "self", ".", "monitor_op", "=", "np", ".", "less", "\n", "self", ".", "best", "=", "np", ".", "Inf", "\n", "", "elif", "mode", "==", "'max'", ":", "\n", "            ", "self", ".", "monitor_op", "=", "np", ".", "greater", "\n", "self", ".", "best", "=", "-", "np", ".", "Inf", "\n", "", "else", ":", "\n", "            ", "if", "'acc'", "in", "self", ".", "monitor", "or", "self", ".", "monitor", ".", "startswith", "(", "'fmeasure'", ")", ":", "\n", "                ", "self", ".", "monitor_op", "=", "np", ".", "greater", "\n", "self", ".", "best", "=", "-", "np", ".", "Inf", "\n", "", "else", ":", "\n", "                ", "self", ".", "monitor_op", "=", "np", ".", "less", "\n", "self", ".", "best", "=", "np", ".", "Inf", "\n", "\n", "", "", "self", ".", "at_batch_end", "=", "at_batch_end", "\n", "self", ".", "at_epoch_end", "=", "at_epoch_end", "\n", "self", ".", "current_epoch", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpoint.on_epoch_begin": [[417, 419], ["None"], "methods", ["None"], ["", "def", "on_epoch_begin", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "self", ".", "current_epoch", "=", "epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpoint.on_batch_end": [[420, 424], ["print", "callbacks.ModelCheckpoint.on_model_save", "numpy.mod"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpointParallel.on_model_save"], ["", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "at_batch_end", "is", "not", "None", "and", "np", ".", "mod", "(", "batch", "+", "1", ",", "self", ".", "at_batch_end", ")", "==", "0", ":", "\n", "            ", "print", "(", "\"Saving model at batch end!\"", ")", "\n", "self", ".", "on_model_save", "(", "self", ".", "current_epoch", ",", "batch", "+", "1", ",", "logs", "=", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpoint.on_epoch_end": [[425, 429], ["callbacks.ModelCheckpoint.on_model_save"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpointParallel.on_model_save"], ["", "", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "at_epoch_end", ":", "\n", "            ", "self", ".", "on_model_save", "(", "epoch", ",", "0", ",", "logs", "=", "logs", ")", "\n", "", "self", ".", "current_epoch", "=", "epoch", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpoint.on_model_save": [[430, 467], ["pytools.Timer", "callbacks.ModelCheckpoint.filepath.format", "logs.get", "warnings.warn", "callbacks.ModelCheckpoint.monitor_op", "print", "callbacks.ModelCheckpoint.model.save_weights", "callbacks.ModelCheckpoint.model.save", "print", "callbacks.ModelCheckpoint.model.save_weights", "callbacks.ModelCheckpoint.model.save", "print"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save"], ["", "def", "on_model_save", "(", "self", ",", "epoch", ",", "iter", ",", "logs", "=", "None", ")", ":", "\n", "        ", "\"\"\" save the model to hdf5. Code mostly from keras core \"\"\"", "\n", "\n", "with", "timer", ".", "Timer", "(", "'model save callback'", ",", "self", ".", "verbose", ")", ":", "\n", "            ", "logs", "=", "logs", "or", "{", "}", "\n", "self", ".", "steps_since_last_save", "+=", "1", "\n", "if", "self", ".", "steps_since_last_save", ">=", "self", ".", "period", ":", "\n", "                ", "self", ".", "steps_since_last_save", "=", "0", "\n", "filepath", "=", "self", ".", "filepath", ".", "format", "(", "epoch", "=", "epoch", ",", "iter", "=", "iter", ",", "**", "logs", ")", "\n", "if", "self", ".", "save_best_only", ":", "\n", "                    ", "current", "=", "logs", ".", "get", "(", "self", ".", "monitor", ")", "\n", "if", "current", "is", "None", ":", "\n", "                        ", "warnings", ".", "warn", "(", "'Can save best model only with %s available, '", "\n", "'skipping.'", "%", "(", "self", ".", "monitor", ")", ",", "RuntimeWarning", ")", "\n", "", "else", ":", "\n", "                        ", "if", "self", ".", "monitor_op", "(", "current", ",", "self", ".", "best", ")", ":", "\n", "                            ", "if", "self", ".", "verbose", ">", "0", ":", "\n", "                                ", "print", "(", "'Epoch %05d Iter%05d: %s improved from %0.5f to %0.5f,'", "\n", "' saving model to %s'", "\n", "%", "(", "epoch", ",", "iter", ",", "self", ".", "monitor", ",", "self", ".", "best", ",", "\n", "current", ",", "filepath", ")", ")", "\n", "", "self", ".", "best", "=", "current", "\n", "if", "self", ".", "save_weights_only", ":", "\n", "                                ", "self", ".", "model", ".", "save_weights", "(", "filepath", ",", "overwrite", "=", "True", ")", "\n", "", "else", ":", "\n", "                                ", "self", ".", "model", ".", "save", "(", "filepath", ",", "overwrite", "=", "True", ")", "\n", "", "", "else", ":", "\n", "                            ", "if", "self", ".", "verbose", ">", "0", ":", "\n", "                                ", "print", "(", "'Epoch %05d Iter%05d: %s did not improve'", "%", "\n", "(", "epoch", ",", "iter", ",", "self", ".", "monitor", ")", ")", "\n", "", "", "", "", "else", ":", "\n", "                    ", "if", "self", ".", "verbose", ">", "0", ":", "\n", "                        ", "print", "(", "'Epoch %05d: saving model to %s'", "%", "(", "epoch", ",", "filepath", ")", ")", "\n", "", "if", "self", ".", "save_weights_only", ":", "\n", "                        ", "self", ".", "model", ".", "save_weights", "(", "filepath", ",", "overwrite", "=", "True", ")", "\n", "", "else", ":", "\n", "                        ", "self", ".", "model", ".", "save", "(", "filepath", ",", "overwrite", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpointParallel.__init__": [[502, 539], ["super().__init__", "warnings.warn", "callbacks.ModelCheckpointParallel.monitor.startswith"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "filepath", ",", "monitor", "=", "'val_loss'", ",", "verbose", "=", "0", ",", "\n", "save_best_only", "=", "False", ",", "save_weights_only", "=", "False", ",", "\n", "at_batch_end", "=", "None", ",", "\n", "at_epoch_end", "=", "True", ",", "\n", "mode", "=", "'auto'", ",", "period", "=", "1", ")", ":", "\n", "        ", "super", "(", "ModelCheckpointParallel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "monitor", "=", "monitor", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "filepath", "=", "filepath", "\n", "self", ".", "save_best_only", "=", "save_best_only", "\n", "self", ".", "save_weights_only", "=", "save_weights_only", "\n", "self", ".", "period", "=", "period", "\n", "self", ".", "epochs_since_last_save", "=", "0", "\n", "\n", "if", "mode", "not", "in", "[", "'auto'", ",", "'min'", ",", "'max'", "]", ":", "\n", "            ", "warnings", ".", "warn", "(", "'ModelCheckpointParallel mode %s is unknown, '", "\n", "'fallback to auto mode.'", "%", "(", "mode", ")", ",", "\n", "RuntimeWarning", ")", "\n", "mode", "=", "'auto'", "\n", "\n", "", "if", "mode", "==", "'min'", ":", "\n", "            ", "self", ".", "monitor_op", "=", "np", ".", "less", "\n", "self", ".", "best", "=", "np", ".", "Inf", "\n", "", "elif", "mode", "==", "'max'", ":", "\n", "            ", "self", ".", "monitor_op", "=", "np", ".", "greater", "\n", "self", ".", "best", "=", "-", "np", ".", "Inf", "\n", "", "else", ":", "\n", "            ", "if", "'acc'", "in", "self", ".", "monitor", "or", "self", ".", "monitor", ".", "startswith", "(", "'fmeasure'", ")", ":", "\n", "                ", "self", ".", "monitor_op", "=", "np", ".", "greater", "\n", "self", ".", "best", "=", "-", "np", ".", "Inf", "\n", "", "else", ":", "\n", "                ", "self", ".", "monitor_op", "=", "np", ".", "less", "\n", "self", ".", "best", "=", "np", ".", "Inf", "\n", "\n", "", "", "self", ".", "at_batch_end", "=", "at_batch_end", "\n", "self", ".", "at_epoch_end", "=", "at_epoch_end", "\n", "self", ".", "current_epoch", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpointParallel.on_epoch_begin": [[540, 542], ["None"], "methods", ["None"], ["", "def", "on_epoch_begin", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "self", ".", "current_epoch", "=", "epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpointParallel.on_batch_end": [[543, 547], ["print", "callbacks.ModelCheckpointParallel.on_model_save", "numpy.mod"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpointParallel.on_model_save"], ["", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "at_batch_end", "is", "not", "None", "and", "np", ".", "mod", "(", "batch", "+", "1", ",", "self", ".", "at_batch_end", ")", "==", "0", ":", "\n", "            ", "print", "(", "\"Saving model at batch end!\"", ")", "\n", "self", ".", "on_model_save", "(", "self", ".", "current_epoch", ",", "batch", "+", "1", ",", "logs", "=", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpointParallel.on_epoch_end": [[548, 552], ["callbacks.ModelCheckpointParallel.on_model_save"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpointParallel.on_model_save"], ["", "", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "at_epoch_end", ":", "\n", "            ", "self", ".", "on_model_save", "(", "epoch", ",", "0", ",", "logs", "=", "logs", ")", "\n", "", "self", ".", "current_epoch", "=", "epoch", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.ModelCheckpointParallel.on_model_save": [[553, 591], ["pytools.Timer", "len", "callbacks.ModelCheckpointParallel.filepath.format", "logs.get", "warnings.warn", "callbacks.ModelCheckpointParallel.monitor_op", "print", "callbacks.ModelCheckpointParallel.model.layers[].save_weights", "callbacks.ModelCheckpointParallel.model.layers[].save", "print", "callbacks.ModelCheckpointParallel.model.layers[].save_weights", "callbacks.ModelCheckpointParallel.model.layers[].save", "print"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save"], ["", "def", "on_model_save", "(", "self", ",", "epoch", ",", "iter", ",", "logs", "=", "None", ")", ":", "\n", "        ", "\"\"\" save the model to hdf5. Code mostly from keras core \"\"\"", "\n", "\n", "with", "timer", ".", "Timer", "(", "'model save callback'", ",", "self", ".", "verbose", ")", ":", "\n", "            ", "logs", "=", "logs", "or", "{", "}", "\n", "num_outputs", "=", "len", "(", "self", ".", "model", ".", "outputs", ")", "\n", "self", ".", "epochs_since_last_save", "+=", "1", "\n", "if", "self", ".", "epochs_since_last_save", ">=", "self", ".", "period", ":", "\n", "                ", "self", ".", "epochs_since_last_save", "=", "0", "\n", "filepath", "=", "self", ".", "filepath", ".", "format", "(", "epoch", "=", "epoch", ",", "iter", "=", "iter", ",", "**", "logs", ")", "\n", "if", "self", ".", "save_best_only", ":", "\n", "                    ", "current", "=", "logs", ".", "get", "(", "self", ".", "monitor", ")", "\n", "if", "current", "is", "None", ":", "\n", "                        ", "warnings", ".", "warn", "(", "'Can save best model only with %s available, '", "\n", "'skipping.'", "%", "(", "self", ".", "monitor", ")", ",", "RuntimeWarning", ")", "\n", "", "else", ":", "\n", "                        ", "if", "self", ".", "monitor_op", "(", "current", ",", "self", ".", "best", ")", ":", "\n", "                            ", "if", "self", ".", "verbose", ">", "0", ":", "\n", "                                ", "print", "(", "'Epoch %05d: Iter%05d: %s improved from %0.5f to %0.5f,'", "\n", "' saving model to %s'", "\n", "%", "(", "epoch", ",", "iter", ",", "self", ".", "monitor", ",", "self", ".", "best", ",", "\n", "current", ",", "filepath", ")", ")", "\n", "", "self", ".", "best", "=", "current", "\n", "if", "self", ".", "save_weights_only", ":", "\n", "                                ", "self", ".", "model", ".", "layers", "[", "-", "(", "num_outputs", "+", "1", ")", "]", ".", "save_weights", "(", "filepath", ",", "overwrite", "=", "True", ")", "\n", "", "else", ":", "\n", "                                ", "self", ".", "model", ".", "layers", "[", "-", "(", "num_outputs", "+", "1", ")", "]", ".", "save", "(", "filepath", ",", "overwrite", "=", "True", ")", "\n", "", "", "else", ":", "\n", "                            ", "if", "self", ".", "verbose", ">", "0", ":", "\n", "                                ", "print", "(", "'Epoch %05d Iter%05d: %s did not improve'", "%", "\n", "(", "epoch", ",", "iter", ",", "self", ".", "monitor", ")", ")", "\n", "", "", "", "", "else", ":", "\n", "                    ", "if", "self", ".", "verbose", ">", "0", ":", "\n", "                        ", "print", "(", "'Epoch %05d: saving model to %s'", "%", "(", "epoch", ",", "filepath", ")", ")", "\n", "", "if", "self", ".", "save_weights_only", ":", "\n", "                        ", "self", ".", "model", ".", "layers", "[", "-", "(", "num_outputs", "+", "1", ")", "]", ".", "save_weights", "(", "filepath", ",", "overwrite", "=", "True", ")", "\n", "", "else", ":", "\n", "                        ", "self", ".", "model", ".", "layers", "[", "-", "(", "num_outputs", "+", "1", ")", "]", ".", "save", "(", "filepath", ",", "overwrite", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.TimeHistory.on_train_begin": [[602, 604], ["None"], "methods", ["None"], ["def", "on_train_begin", "(", "self", ",", "logs", "=", "{", "}", ")", ":", "\n", "        ", "self", ".", "times", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.TimeHistory.on_epoch_begin": [[605, 607], ["time.time"], "methods", ["None"], ["", "def", "on_epoch_begin", "(", "self", ",", "batch", ",", "logs", "=", "{", "}", ")", ":", "\n", "        ", "self", ".", "epoch_time_start", "=", "time", ".", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks.TimeHistory.on_epoch_end": [[608, 610], ["callbacks.TimeHistory.times.append", "time.time"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ",", "batch", ",", "logs", "=", "{", "}", ")", ":", "\n", "        ", "self", ".", "times", ".", "append", "(", "time", ".", "time", "(", ")", "-", "self", ".", "epoch_time_start", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.callbacks._generate_predictions": [[616, 634], ["range", "range", "neurite.utils.seg.predict_volumes", "neurite.utils.seg.next_label"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.predict_volumes", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.next_label"], ["", "", "def", "_generate_predictions", "(", "model", ",", "data_generator", ",", "batch_size", ",", "nb_samples", ",", "vol_params", ")", ":", "\n", "# whole volumes", "\n", "    ", "if", "vol_params", "is", "not", "None", ":", "\n", "        ", "for", "_", "in", "range", "(", "nb_samples", ")", ":", "# assumes nr volume", "\n", "            ", "vols", "=", "ne", ".", "utils", ".", "seg", ".", "predict_volumes", "(", "model", ",", "\n", "data_generator", ",", "\n", "batch_size", ",", "\n", "vol_params", "[", "\"patch_size\"", "]", ",", "\n", "vol_params", "[", "\"patch_stride\"", "]", ",", "\n", "vol_params", "[", "\"grid_size\"", "]", ")", "\n", "vol_true", ",", "vol_pred", "=", "vols", "[", "0", "]", ",", "vols", "[", "1", "]", "\n", "yield", "(", "vol_true", ",", "vol_pred", ")", "\n", "\n", "# just one batch", "\n", "", "", "else", ":", "\n", "        ", "for", "_", "in", "range", "(", "nb_samples", ")", ":", "# assumes nr batches", "\n", "            ", "vol_pred", ",", "vol_true", "=", "ne", ".", "utils", ".", "seg", ".", "next_label", "(", "model", ",", "data_generator", ")", "\n", "yield", "(", "vol_true", ",", "vol_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.train_synth_reg.synth_generator": [[94, 116], ["voxelmorph.tf.synthseg.build_model_input_generator", "map", "split", "range", "numpy.zeros", "next"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.build_model_input_generator", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "synth_generator", "(", "files", ",", "all_labels", ",", "warp_shape", ",", "bias_shape", ",", "batch_size", "=", "1", ",", "same_subj", "=", "False", ",", "vel_std", "=", "6", ")", ":", "\n", "    ", "\"\"\"\n    Generator for sythesizing images and label maps from segmentations.\n    Parameters:\n        files: List of segmentations or paths.\n        all_labels: List of unique labels included.\n        warp_shape: Shape of warps to sample internally.\n        bias_shape: Shape of bias field to sample internally.\n        batch_size: Batch size. Default is 1.\n        same_subj: Whether to generate source and target from the same segmentation. Default is False.\n        vel_std: Maximum sampling SD for velocity fields. Default is 6.\n    \"\"\"", "\n", "gen", "=", "vxm", ".", "tf", ".", "synthseg", ".", "build_model_input_generator", "(", "files", ",", "all_labels", ",", "warp_shape", ",", "bias_shape", ",", "\n", "nonlin_std_dev", "=", "vel_std", ",", "batch_size", "=", "2", "*", "batch_size", ",", "same_subj", "=", "same_subj", ")", "\n", "split", "=", "lambda", "x", ":", "(", "x", "[", ":", "batch_size", ",", "...", "]", ",", "x", "[", "batch_size", ":", ",", "...", "]", ")", "\n", "zeros", "=", "None", "\n", "while", "True", ":", "\n", "        ", "inputs", "=", "[", "split", "(", "i", ")", "for", "i", "in", "next", "(", "gen", ")", "]", "\n", "in1", ",", "in2", "=", "map", "(", "lambda", "i", ":", "[", "x", "[", "i", "]", "for", "x", "in", "inputs", "]", ",", "range", "(", "2", ")", ")", "\n", "if", "zeros", "is", "None", ":", "\n", "            ", "zeros", "=", "np", ".", "zeros", "(", "in1", "[", "0", "]", ".", "shape", ")", "\n", "", "yield", "(", "*", "in1", ",", "*", "in2", ")", ",", "(", "zeros", ",", "zeros", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.test_unsupervised_segmentation.make_k_functions": [[53, 103], ["len", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.keras.backend.exp", "range", "numpy.max", "min", "tensorflow.placeholder", "voxelmorph.tf.ne.transform", "tensorflow.keras.backend.stack", "funcs.append.append", "funcs.append.append", "tensorflow.keras.backend.function", "tensorflow.keras.backend.function", "len", "range", "len", "tensorflow.keras.backend.sum"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.transform", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["def", "make_k_functions", "(", "vol_shape", ",", "mapping", ",", "max_feats", "=", "None", ",", "norm_post", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Utility to build keras (gpu-runnable) functions that will warp the atlas and compute\n    posteriors given the original full atlas and unnormalized log likelihood.\n\n    norm_post (True): normalize posterior? Thi sis faster on GPU, so if possible should be set to True\n    max_feats (None): since atlas van be very large, warping full atlas can run out of memory on current GPUs. \n        Providing a number here will avoid OOM error, and will return several keras functions that each provide \n        the posterior computation for at most max_feats nb_full_labels. Stacking the result of calling these\n        functions will provide an *unnormalized* posterior (since it can't properly normalize)\n    \"\"\"", "\n", "nb_full_labels", "=", "len", "(", "mapping", ")", "\n", "nb_labels", "=", "np", ".", "max", "(", "mapping", ")", "+", "1", "\n", "\n", "# compute maximum features and whether to return single function", "\n", "return_single_fn", "=", "max_feats", "is", "None", "\n", "if", "max_feats", "is", "None", ":", "\n", "        ", "max_feats", "=", "nb_full_labels", "\n", "", "else", ":", "\n", "        ", "assert", "not", "norm_post", ",", "'cannot do normalized posterior if providing max_feats'", "\n", "\n", "# prepare ull and ", "\n", "", "ull", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "vol_shape", "+", "(", "nb_labels", ",", ")", ")", "\n", "input_flow", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "vol_shape", "+", "(", "len", "(", "vol_shape", ")", ",", ")", ")", "\n", "ul_pred", "=", "K", ".", "exp", "(", "ull", ")", "\n", "\n", "funcs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "nb_full_labels", ",", "max_feats", ")", ":", "\n", "        ", "end", "=", "min", "(", "i", "+", "max_feats", ",", "nb_full_labels", ")", "\n", "this_atlas_full_shape", "=", "vol_shape", "+", "(", "end", "-", "i", ",", ")", "\n", "this_mapping", "=", "mapping", "[", "i", ":", "end", "]", "\n", "\n", "# prepare atlas input", "\n", "input_atlas", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "this_atlas_full_shape", ")", "\n", "\n", "# warp atlas", "\n", "warped", "=", "vxm", ".", "tf", ".", "ne", ".", "transform", "(", "input_atlas", ",", "input_flow", ",", "interp_method", "=", "'linear'", ",", "indexing", "=", "'ij'", ")", "\n", "\n", "# normalized posterior", "\n", "post_lst", "=", "[", "ul_pred", "[", "...", ",", "this_mapping", "[", "j", "]", "]", "*", "warped", "[", "...", ",", "j", "]", "for", "j", "in", "range", "(", "len", "(", "this_mapping", ")", ")", "]", "\n", "posterior", "=", "K", ".", "stack", "(", "post_lst", ",", "-", "1", ")", "\n", "\n", "funcs", ".", "append", "(", "K", ".", "function", "(", "[", "input_atlas", ",", "ull", ",", "input_flow", "]", ",", "[", "posterior", ",", "warped", "]", ")", ")", "\n", "\n", "", "if", "return_single_fn", ":", "\n", "        ", "if", "norm_post", ":", "\n", "            ", "posterior", "=", "posterior", "/", "(", "1e-12", "+", "K", ".", "sum", "(", "posterior", ",", "-", "1", ",", "keepdims", "=", "True", ")", ")", "\n", "", "funcs", "=", "funcs", ".", "append", "(", "K", ".", "function", "(", "[", "input_atlas", ",", "ull", ",", "input_flow", "]", ",", "[", "posterior", ",", "warped", "]", ")", ")", "\n", "\n", "", "return", "funcs", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDense.__init__": [[39, 154], ["len", "networks.Unet", "getattr", "modelio.LoadableModel.__init__", "modelio.LoadableModel.ReferenceContainer", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "getattr.", "tensorflow.concatenate", "tensorflow.concatenate", "tensorflow.concatenate", "tensorflow.concatenate", "layers.SpatialTransformer", "getattr.", "neurite.layers.SampleNormalLogVar", "neurite.layers.Negate", "layers.VecInt", "layers.SpatialTransformer", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "layers.RescaleTransform", "layers.VecInt", "layers.RescaleTransform", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.Constant", "tensorflow.Constant", "tensorflow.Constant", "tensorflow.Constant", "layers.RescaleTransform"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["    ", "\"\"\"Convolution module including convolution followed by leakyrelu.\n    Args:\n        x_in: input feature map\n        nf: number of filters\n        condn_emb: if using FiLM, this is the condition embedding.\n        mode: either upsample, downsample or leave at constant resolution.\n        activation: bool indicating whether to use a leaky relu.\n        sn: bool indicating whether to use spectral norm.\n        instancen: bool for instance norm. Not used in paper.\n        stride: convolutional stride\n        kernel_size: kernel size\n        init: weight initialization. either 'default' or 'orthogonal'\n    \"\"\"", "\n", "\n", "ndims", "=", "len", "(", "x_in", ".", "get_shape", "(", ")", ")", "-", "2", "\n", "assert", "ndims", "in", "[", "1", ",", "2", ",", "3", "]", ",", "\"ndims supported to up to 3. found: %d\"", "%", "ndims", "\n", "\n", "maxpool", "=", "getattr", "(", "KL", ",", "'MaxPooling%dD'", "%", "ndims", ")", "\n", "upsample", "=", "getattr", "(", "KL", ",", "'UpSampling%dD'", "%", "ndims", ")", "\n", "conv", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "\n", "# If unconditional and not using FiLM, then train conv layers with bias:", "\n", "if", "condn_emb", "is", "None", ":", "\n", "        ", "bias", "=", "True", "\n", "", "else", ":", "\n", "        ", "bias", "=", "False", "\n", "\n", "# Reflection pad:", "\n", "", "x_in", "=", "tf", ".", "pad", "(", "\n", "x_in", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\n", "\"REFLECT\"", ",", "\n", ")", "\n", "\n", "# Specify initializations:", "\n", "if", "init", "==", "'default'", "or", "init", "is", "None", ":", "\n", "        ", "initialization", "=", "None", "\n", "", "elif", "init", "==", "'orthogonal'", ":", "\n", "        ", "initialization", "=", "'orthogonal'", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "\n", "# If using spectral normalization:", "\n", "", "if", "sn", ":", "\n", "        ", "x_out", "=", "SpectralNormalization", "(", "conv", "(", "\n", "nf", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "bias", ",", "\n", "strides", "=", "stride", ",", "\n", "kernel_initializer", "=", "initialization", ",", "\n", ")", ")", "(", "x_in", ")", "\n", "", "else", ":", "\n", "        ", "x_out", "=", "conv", "(", "\n", "nf", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "bias", ",", "\n", "strides", "=", "stride", ",", "\n", "kernel_initializer", "=", "initialization", ",", "\n", ")", "(", "x_in", ")", "\n", "\n", "# If using instance normalization. Not used in paper.", "\n", "", "if", "instancen", ":", "\n", "        ", "x_out", "=", "InstanceNormalization", "(", "\n", "center", "=", "True", ",", "\n", "scale", "=", "True", ",", "\n", ")", "(", "x_out", ")", "\n", "\n", "# If using FiLM:", "\n", "", "if", "condn_emb", "is", "not", "None", ":", "\n", "        ", "x_out", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "x_out", ",", "condn_emb", "]", ")", "\n", "\n", "# Nonlinearity:", "\n", "", "if", "activation", ":", "\n", "        ", "x_out", "=", "KL", ".", "LeakyReLU", "(", "0.2", ")", "(", "x_out", ")", "\n", "\n", "# Up/down sample:", "\n", "", "if", "mode", "==", "'up'", ":", "\n", "        ", "x_out", "=", "upsample", "(", ")", "(", "x_out", ")", "\n", "", "elif", "mode", "==", "'down'", ":", "\n", "        ", "x_out", "=", "maxpool", "(", ")", "(", "x_out", ")", "# not used in paper, we used strided convs", "\n", "", "elif", "mode", "==", "'const'", ":", "\n", "        ", "pass", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'mode has to be up/down/const w.r.t. spatial res'", ")", "\n", "\n", "", "return", "x_out", "\n", "\n", "\n", "", "@", "tf", ".", "function", "\n", "def", "const_inp", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"Used to give a layer a constant input of 1.\"\"\"", "\n", "batch_size", "=", "tf", ".", "shape", "(", "tensor", ")", "[", "0", "]", "\n", "constant", "=", "tf", ".", "constant", "(", "1.0", ")", "\n", "constant", "=", "tf", ".", "expand_dims", "(", "constant", ",", "axis", "=", "0", ")", "\n", "return", "tf", ".", "broadcast_to", "(", "constant", ",", "shape", "=", "(", "batch_size", ",", "1", ")", ")", "\n", "\n", "\n", "# ----------------------------------------------------------------------------", "\n", "# Generator architecture", "\n", "\n", "\n", "", "def", "Generator", "(", "\n", "ch", "=", "32", ",", "\n", "full_size", "=", "False", ",", "\n", "conditional", "=", "True", ",", "\n", "normreg", "=", "False", ",", "\n", "atlas_model", "=", "'ours'", ",", "\n", "input_resolution", "=", "[", "160", ",", "192", ",", "160", ",", "1", "]", ",", "\n", "clip_bckgnd", "=", "True", ",", "\n", "initialization", "=", "'default'", ",", "\n", "n_condns", "=", "1", ",", "\n", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDense.get_registration_model": [[155, 160], ["tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDense.register": [[161, 166], ["networks.VxmDense.get_registration_model().predict", "networks.VxmDense.get_registration_model"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.get_registration_model"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDense.apply_transform": [[167, 175], ["networks.VxmDense.get_registration_model", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Model().predict", "tensorflow.keras.Model().predict", "tensorflow.keras.Model().predict", "tensorflow.keras.Model().predict", "layers.SpatialTransformer", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.get_registration_model"], ["\n", "image_inputs", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "input_resolution", ")", "\n", "atlas_inputs", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "input_resolution", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedSeg.__init__": [[182, 214], ["networks.VxmDense", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "modelio.LoadableModel.__init__", "modelio.LoadableModel.ReferenceContainer", "layers.RescaleTransform", "layers.SpatialTransformer", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["", "if", "initialization", "==", "'orthogonal'", ":", "\n", "        ", "init", "=", "'orthogonal'", "\n", "vel_init", "=", "'orthogonal'", "\n", "", "elif", "initialization", "==", "'default'", ":", "\n", "        ", "init", "=", "None", "\n", "vel_init", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1e-5", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "\n", "# Atlas sharpening branch:", "\n", "# TODO: Long if/else sequence, abstract out and make cleaner.", "\n", "# VXM archs taken verbatim from their repos", "\n", "", "if", "atlas_model", "==", "'voxelmorph'", "and", "conditional", "is", "False", ":", "\n", "# vxm unconditional model:", "\n", "        ", "atlas_layer", "=", "LocalParamWithInput", "(", "\n", "name", "=", "'atlas'", ",", "\n", "shape", "=", "input_resolution", ",", "\n", "mult", "=", "1.0", ",", "\n", "initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1e-7", ",", "\n", ")", ",", "\n", ")", "\n", "\n", "new_atlas", "=", "atlas_layer", "(", "atlas_inputs", ")", "\n", "\n", "", "elif", "atlas_model", "==", "'voxelmorph'", "and", "conditional", "is", "True", ":", "\n", "# vxm conditional model:", "\n", "# TODO: fix hardcoding", "\n", "        ", "condn_emb_vxm", "=", "KL", ".", "Dense", "(", "(", "80", "*", "96", "*", "80", "*", "8", ")", ",", "activation", "=", "'elu'", ")", "(", "condn", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedSeg.get_registration_model": [[215, 220], ["tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model"], "methods", ["None"], ["condn_emb_vxm", "=", "KL", ".", "Reshape", "(", "(", "80", ",", "96", ",", "80", ",", "8", ")", ")", "(", "condn_emb_vxm", ")", "\n", "\n", "# Atlas sharpening branch:", "\n", "dec_out", "=", "conv_dec", "(", "\n", "condn_emb_vxm", ",", "# vxm optimized parameters", "\n", "8", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedSeg.register": [[221, 226], ["networks.VxmDenseSemiSupervisedSeg.get_registration_model().predict", "networks.VxmDenseSemiSupervisedSeg.get_registration_model"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.get_registration_model"], ["(", "80", ",", "96", ",", "80", ",", "8", ")", ",", "\n", "2", ",", "\n", "[", "3", ",", "3", ",", "3", "]", ",", "\n", "8", ",", "\n", ")", "\n", "last_tensor", "=", "dec_out", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedSeg.apply_transform": [[227, 235], ["networks.VxmDenseSemiSupervisedSeg.get_registration_model", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Model().predict", "tensorflow.keras.Model().predict", "tensorflow.keras.Model().predict", "tensorflow.keras.Model().predict", "layers.SpatialTransformer", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.get_registration_model"], ["for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "last_tensor", "=", "KL", ".", "Conv3D", "(", "\n", "8", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlas_ec_%d'", "%", "i", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "", "pout", "=", "KL", ".", "Conv3D", "(", "\n", "1", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlasmodel_c'", ",", "\n", "kernel_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "stddev", "=", "1e-7", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.__init__": [[242, 303], ["networks.VxmDense", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "modelio.LoadableModel.__init__", "modelio.LoadableModel.ReferenceContainer", "int", "utils.point_spatial_transformer", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "len", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.point_spatial_transformer"], ["new_atlas", "=", "atlas_inputs", "+", "pout", "\n", "\n", "", "elif", "atlas_model", "==", "'ours'", "and", "conditional", "is", "True", ":", "\n", "        ", "\"\"\"Start from a learned vector which is then conditioned.\"\"\"", "\n", "\n", "# FiLM branch:", "\n", "# TODO: fix hardcoding", "\n", "condn_vec", "=", "1.0", "*", "condn", "\n", "for", "_", "in", "range", "(", "4", ")", ":", "\n", "            ", "condn_vec", "=", "KL", ".", "Dense", "(", "\n", "64", ",", "\n", "kernel_initializer", "=", "init", ",", "\n", ")", "(", "condn_vec", ")", "\n", "condn_vec", "=", "KL", ".", "LeakyReLU", "(", "0.2", ")", "(", "condn_vec", ")", "\n", "\n", "# Input layer of decoder: learned parameter vector", "\n", "", "const_vec", "=", "KL", ".", "Lambda", "(", "const_inp", ")", "(", "condn", ")", "# use condn to get batch info", "\n", "condn_emb_vxm", "=", "KL", ".", "Dense", "(", "\n", "(", "80", "*", "96", "*", "80", "*", "8", ")", ",", "\n", "kernel_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "0.02", ",", "\n", ")", ",", "\n", "bias_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "0.02", ",", "\n", ")", ",", "\n", ")", "(", "const_vec", ")", "\n", "\n", "# Reshape to feature map and FiLM for convolutional processing:", "\n", "condn_emb_vxm", "=", "KL", ".", "Reshape", "(", "(", "80", ",", "96", ",", "80", ",", "8", ")", ")", "(", "condn_emb_vxm", ")", "\n", "condn_emb_vxm", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "condn_emb_vxm", ",", "condn_vec", "]", ")", "\n", "\n", "# 5 ResBlocks at lower resolution:", "\n", "s1", "=", "conv_block", "(", "\n", "condn_emb_vxm", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "1.0", "*", "s1", "\n", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "            ", "sip", "=", "sres", "\n", "sres", "=", "conv_block", "(", "\n", "sres", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "conv_block", "(", "\n", "sres", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "sres", "+", "sip", "\n", "\n", "# Upsample --> More Conv+FiLM+LeakyReLU blocks:", "\n", "", "dec_out", "=", "conv_dec_film", "(", "\n", "sres", ",", "\n", "condn_vec", ",", "\n", "8", ",", "\n", "(", "80", ",", "96", ",", "80", ",", "8", ")", ",", "\n", "2", ",", "\n", "[", "3", ",", "3", ",", "3", "]", ",", "\n", "8", ",", "\n", "sn", "=", "True", ",", "\n", "init", "=", "init", ",", "\n", ")", "\n", "last_tensor", "=", "dec_out", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.get_registration_model": [[304, 309], ["tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model"], "methods", ["None"], ["\n", "pout", "=", "KL", ".", "Conv3D", "(", "\n", "1", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlasmodel_c'", ",", "\n", "kernel_initializer", "=", "init", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.register": [[310, 315], ["networks.VxmDenseSemiSupervisedPointCloud.get_registration_model().predict", "networks.VxmDenseSemiSupervisedPointCloud.get_registration_model"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.get_registration_model"], ["pout", "=", "KL", ".", "Activation", "(", "'tanh'", ")", "(", "pout", ")", "\n", "\n", "# Add to linear average:", "\n", "new_atlas", "=", "atlas_inputs", "+", "pout", "\n", "\n", "", "elif", "atlas_model", "==", "'ours'", "and", "conditional", "is", "False", ":", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.apply_transform": [[316, 324], ["networks.VxmDenseSemiSupervisedPointCloud.get_registration_model", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Model().predict", "tensorflow.keras.Model().predict", "tensorflow.keras.Model().predict", "tensorflow.keras.Model().predict", "layers.SpatialTransformer", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSemiSupervisedPointCloud.get_registration_model"], ["        ", "\"\"\"Start from a learned vector.\"\"\"", "\n", "\n", "condn_vec", "=", "None", "\n", "\n", "# Input layer of decoder: learned parameter vector", "\n", "const_vec", "=", "KL", ".", "Lambda", "(", "const_inp", ")", "(", "image_inputs", ")", "# use ip for batch info", "\n", "condn_emb_vxm", "=", "KL", ".", "Dense", "(", "\n", "(", "80", "*", "96", "*", "80", "*", "8", ")", ",", "\n", "kernel_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.VxmDenseSynth.__init__": [[331, 385], ["make_im_model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "networks.VxmDense", "modelio.LoadableModel.__init__", "modelio.LoadableModel.ReferenceContainer", "synthseg.labels_to_image_model.labels_to_image_model", "make_im_model", "tensorflow.one_hot", "tensorflow.one_hot", "tensorflow.one_hot", "tensorflow.one_hot", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "layers.SpatialTransformer", "tensorflow.Concatenate", "tensorflow.Concatenate", "tensorflow.Concatenate", "tensorflow.Concatenate", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.labels_to_image_model.labels_to_image_model"], [")", ",", "\n", ")", "(", "const_vec", ")", "\n", "\n", "condn_emb_vxm", "=", "KL", ".", "Reshape", "(", "(", "80", ",", "96", ",", "80", ",", "8", ")", ")", "(", "condn_emb_vxm", ")", "\n", "\n", "# 5 ResBlocks at lower resolution:", "\n", "s1", "=", "conv_block", "(", "\n", "condn_emb_vxm", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "1.0", "*", "s1", "\n", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "            ", "sip", "=", "sres", "\n", "sres", "=", "conv_block", "(", "\n", "sres", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "conv_block", "(", "\n", "sres", ",", "ch", ",", "condn_emb", "=", "condn_vec", ",", "sn", "=", "True", ",", "init", "=", "init", ",", "\n", ")", "\n", "sres", "=", "sres", "+", "sip", "\n", "\n", "# Upsample --> More Conv+FiLM+LeakyReLU blocks:", "\n", "", "dec_out", "=", "conv_dec_film", "(", "\n", "sres", ",", "\n", "condn_vec", ",", "\n", "8", ",", "\n", "(", "80", ",", "96", ",", "80", ",", "8", ")", ",", "\n", "2", ",", "\n", "[", "3", ",", "3", ",", "3", "]", ",", "\n", "8", ",", "\n", "sn", "=", "True", ",", "\n", "conditional", "=", "False", ",", "\n", "init", "=", "init", ",", "\n", ")", "\n", "last_tensor", "=", "dec_out", "\n", "\n", "pout", "=", "KL", ".", "Conv3D", "(", "\n", "1", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlasmodel_c'", ",", "\n", "kernel_initializer", "=", "init", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "pout", "=", "KL", ".", "Activation", "(", "'tanh'", ")", "(", "pout", ")", "\n", "\n", "# Add to linear average:", "\n", "new_atlas", "=", "atlas_inputs", "+", "pout", "\n", "\n", "", "if", "clip_bckgnd", ":", "\n", "        ", "new_atlas", "=", "new_atlas", "*", "tf", ".", "cast", "(", "\n", "tf", ".", "math", ".", "greater", "(", "atlas_inputs", ",", "1e-2", ")", ",", "tf", ".", "float32", ",", "\n", ")", "\n", "\n", "# Registration network. Taken from vxm:", "\n", "# Encoder:", "\n", "", "inp", "=", "KL", ".", "concatenate", "(", "[", "image_inputs", ",", "new_atlas", "]", ")", "\n", "d1", "=", "conv_block", "(", "inp", ",", "ch", ",", "stride", "=", "2", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.InstanceDense.__init__": [[396, 410], ["tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "neurite.layers.LocalParamWithInput", "neurite.layers.LocalParamWithInput.", "modelio.LoadableModel.__init__", "modelio.LoadableModel.ReferenceContainer", "vxm.layers.SpatialTransformer", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["\n", "d6", "=", "conv_block", "(", "d5", ",", "ch", ",", "mode", "=", "'up'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "d6", "=", "KL", ".", "concatenate", "(", "[", "d6", ",", "d2", "]", ")", "\n", "\n", "d7", "=", "conv_block", "(", "d6", ",", "ch", ",", "mode", "=", "'up'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ")", "\n", "d7", "=", "KL", ".", "concatenate", "(", "[", "d7", ",", "d1", "]", ")", "\n", "\n", "if", "full_size", ":", "# if estimating displacements at half-resolution for speed", "\n", "        ", "d7", "=", "conv_block", "(", "\n", "d7", ",", "ch", ",", "mode", "=", "'up'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ",", "\n", ")", "\n", "d7", "=", "KL", ".", "concatenate", "(", "[", "d7", ",", "inp", "]", ")", "\n", "\n", "", "d7", "=", "conv_block", "(", "\n", "d7", ",", "ch", ",", "mode", "=", "'const'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.InstanceDense.set_flow": [[411, 416], ["networks.InstanceDense.references.flow_layer.set_weights"], "methods", ["None"], [")", "\n", "d7", "=", "conv_block", "(", "\n", "d7", ",", "ch", ",", "mode", "=", "'const'", ",", "instancen", "=", "normreg", ",", "init", "=", "init", ",", "\n", ")", "\n", "d7", "=", "conv_block", "(", "d7", ",", "ch", "//", "2", ",", "mode", "=", "'const'", ",", "activation", "=", "False", ",", "init", "=", "init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.ProbAtlasSegmentation.__init__": [[427, 523], ["len", "networks.VxmDense", "networks._conv_block", "networks._conv_block", "getattr", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "modelio.LoadableModel.__init__", "modelio.LoadableModel.ReferenceContainer", "tensorflow.concatenate", "tensorflow.concatenate", "tensorflow.concatenate", "tensorflow.concatenate", "getattr.", "getattr.", "tensorflow.GlobalMaxPooling3D", "tensorflow.GlobalMaxPooling3D", "tensorflow.GlobalMaxPooling3D", "tensorflow.GlobalMaxPooling3D", "tensorflow.GlobalMaxPooling3D", "tensorflow.GlobalMaxPooling3D", "tensorflow.GlobalMaxPooling3D", "tensorflow.GlobalMaxPooling3D", "numpy.array", "numpy.array", "tensorflow.distributions.Normal", "tensorflow.distributions.Normal", "tensorflow.distributions.Normal", "tensorflow.distributions.Normal", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.reduce_max", "tensorflow.reduce_max", "tensorflow.reduce_max", "tensorflow.reduce_max", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.exp", "tensorflow.exp", "tensorflow.exp", "tensorflow.exp", "tensorflow.distributions.Normal.log_prob", "tensorflow.distributions.Normal.prob", "tensorflow.log", "tensorflow.log", "tensorflow.log", "tensorflow.log", "tensorflow.log", "tensorflow.log", "tensorflow.log", "tensorflow.log", "networks.ProbAtlasSegmentation.__init__.unnorm_loglike"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks._conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks._conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], [")", "(", "d7", ")", "\n", "\n", "# Get diffeomorphic displacement field:", "\n", "diff_field", "=", "VecInt", "(", "method", "=", "'ss'", ",", "int_steps", "=", "5", ",", "name", "=", "'def_field'", ")", "(", "vel", ")", "\n", "\n", "# Get moving average of deformations:", "\n", "diff_field_ms", "=", "MeanStream", "(", "name", "=", "'mean_stream'", ",", "cap", "=", "100", ")", "(", "diff_field", ")", "\n", "\n", "if", "full_size", "is", "False", ":", "# i.e. rescale displacement field to full size", "\n", "# compute regularizers on diff_field_half for efficiency:", "\n", "        ", "diff_field_half", "=", "1.0", "*", "diff_field", "\n", "diff_field", "=", "RescaleTransform", "(", "2.0", ",", "name", "=", "'flowup'", ")", "(", "diff_field", ")", "\n", "moved_atlas", "=", "SpatialTransformer", "(", ")", "(", "[", "new_atlas", ",", "diff_field", "]", ")", "\n", "ops", "=", "[", "moved_atlas", ",", "diff_field_ms", ",", "new_atlas", ",", "diff_field_half", "]", "\n", "", "else", ":", "\n", "        ", "moved_atlas", "=", "SpatialTransformer", "(", ")", "(", "[", "new_atlas", ",", "diff_field", "]", ")", "\n", "ops", "=", "[", "moved_atlas", ",", "diff_field_ms", ",", "new_atlas", ",", "diff_field", "]", "\n", "\n", "", "if", "conditional", ":", "\n", "        ", "return", "tf", ".", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "image_inputs", ",", "atlas_inputs", ",", "condn", "]", ",", "\n", "outputs", "=", "ops", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "return", "tf", ".", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "image_inputs", ",", "atlas_inputs", "]", ",", "\n", "outputs", "=", "ops", ",", "\n", ")", "\n", "\n", "\n", "# ----------------------------------------------------------------------------", "\n", "# Discriminator architecture", "\n", "\n", "\n", "", "", "def", "Discriminator", "(", "\n", "ch", "=", "32", ",", "\n", "conditional", "=", "True", ",", "\n", "input_resolution", "=", "[", "160", ",", "192", ",", "160", ",", "1", "]", ",", "\n", "sn_out", "=", "True", ",", "\n", "initialization", "=", "'orthogonal'", ",", "\n", "n_condns", "=", "1", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        ch : int\n            Channel multiplier.\n        conditional : bool\n            Flag indicating whether generator model is conditional.\n        input_resolution: list\n            Input image dimensions.\n        sn_out: bool\n            Whether to use SpectralNorm of last layer of discriminator.\n        initialization: str\n            Weight init. One of \"default\" or \"orthogonal\".\n        n_condns: int\n            Number of conditions if training conditionally.\n    \"\"\"", "\n", "inp", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "input_resolution", ",", "name", "=", "'input_image'", ")", "\n", "\n", "if", "initialization", "==", "'orthogonal'", ":", "\n", "        ", "init", "=", "'orthogonal'", "\n", "", "elif", "initialization", "==", "'default'", "or", "initialization", "is", "None", ":", "\n", "        ", "init", "=", "None", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "\n", "# If training conditionally:", "\n", "", "if", "conditional", ":", "\n", "        ", "condn", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "n_condns", ",", ")", ")", "\n", "# If n_condns > 1 with both continuous and categorical attributes,", "\n", "# then continuous attributes can be linearly projected, but categorical", "\n", "# attributes need an embedding matrix, equivalently implemented here", "\n", "# with a bias-free dense layer acting on a one-hot representation:", "\n", "if", "n_condns", "==", "1", ":", "\n", "            ", "condn_age_emb", "=", "KL", ".", "Dense", "(", "ch", ",", "kernel_initializer", "=", "init", ")", "(", "condn", ")", "\n", "", "elif", "n_condns", ">", "1", ":", "# Assumes that 1st idx of condn vector is cont. age", "\n", "            ", "condn_age", ",", "condn_cat", "=", "tf", ".", "split", "(", "condn", ",", "[", "1", ",", "-", "1", "]", ",", "axis", "=", "-", "1", ")", "\n", "condn_age_emb", "=", "KL", ".", "Dense", "(", "ch", ",", "kernel_initializer", "=", "init", ")", "(", "condn_age", ")", "\n", "condn_cat_emb", "=", "KL", ".", "Dense", "(", "\n", "ch", ",", "use_bias", "=", "False", ",", "kernel_initializer", "=", "init", ",", "\n", ")", "(", "condn_cat", ")", "\n", "\n", "# If using spectralnorm:", "\n", "", "", "if", "sn_out", ":", "\n", "        ", "dOP", "=", "SpectralNormalization", "\n", "", "else", ":", "\n", "        ", "dOP", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", ")", "# basically no-op", "\n", "\n", "# Convolutional sequence:", "\n", "", "down1", "=", "conv_block", "(", "inp", ",", "ch", ",", "sn", "=", "True", ",", "stride", "=", "2", ",", "init", "=", "init", ")", "\n", "down2", "=", "conv_block", "(", "down1", ",", "ch", "*", "2", ",", "sn", "=", "True", ",", "stride", "=", "2", ",", "init", "=", "init", ")", "\n", "down3", "=", "conv_block", "(", "down2", ",", "ch", "*", "4", ",", "sn", "=", "True", ",", "stride", "=", "2", ",", "init", "=", "init", ")", "\n", "fin1", "=", "conv_block", "(", "down3", ",", "ch", "*", "8", ",", "sn", "=", "True", ",", "stride", "=", "2", ",", "init", "=", "init", ")", "\n", "\n", "# If using SN on discriminator output:", "\n", "fin1", "=", "conv_block", "(", "fin1", ",", "ch", ",", "sn", "=", "sn_out", ",", "activation", "=", "False", ",", "init", "=", "init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.ProbAtlasSegmentation.get_gaussian_warp_model": [[524, 536], ["tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model"], "methods", ["None"], ["if", "conditional", ":", "\n", "# Local projection discriminator feedback:", "\n", "        ", "op_age", "=", "dOP", "(", "KL", ".", "Conv3D", "(", "\n", "1", ",", "1", ",", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "True", ",", "kernel_initializer", "=", "init", ",", "\n", ")", ")", "(", "fin1", ")", "\n", "\n", "condn_emb_spatial_age", "=", "tf", ".", "tile", "(", "\n", "tf", ".", "reshape", "(", "\n", "condn_age_emb", ",", "\n", "(", "tf", ".", "shape", "(", "condn_age_emb", ")", "[", "0", "]", ",", "1", ",", "1", ",", "\n", "1", ",", "tf", ".", "shape", "(", "condn_age_emb", ")", "[", "-", "1", "]", ")", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.TemplateCreation.__init__": [[547, 587], ["tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "neurite.layers.LocalParamWithInput", "neurite.layers.LocalParamWithInput.", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "networks.VxmDense", "modelio.LoadableModel.__init__", "modelio.LoadableModel.ReferenceContainer", "neurite.layers.MeanStream", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], [")", ",", "\n", "(", "1", ",", "tf", ".", "shape", "(", "op_age", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "op_age", ")", "[", "2", "]", ",", "\n", "tf", ".", "shape", "(", "op_age", ")", "[", "3", "]", ",", "1", ")", ",", "\n", ")", "\n", "\n", "op", "=", "(", "\n", "op_age", "+", "\n", "tf", ".", "reduce_sum", "(", "\n", "condn_emb_spatial_cat", "*", "fin1", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ",", "\n", ")", "+", "\n", "tf", ".", "reduce_sum", "(", "\n", "condn_emb_spatial_age", "*", "fin1", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "op", "=", "op_age", "+", "tf", ".", "reduce_sum", "(", "\n", "condn_emb_spatial_age", "*", "fin1", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ",", "\n", ")", "\n", "\n", "", "return", "tf", ".", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "inp", ",", "condn", "]", ",", "outputs", "=", "[", "op", "]", ",", "\n", ")", "\n", "", "else", ":", "# Unconditional", "\n", "        ", "op", "=", "dOP", "(", "KL", ".", "Conv3D", "(", "\n", "1", ",", "1", ",", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "True", ",", "kernel_initializer", "=", "init", ",", "\n", ")", ")", "(", "fin1", ")", "\n", "return", "tf", ".", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "inp", "]", ",", "outputs", "=", "[", "op", "]", ",", "\n", ")", "\n", "\n", "\n", "# ----------------------------------------------------------------------------", "\n", "# Decoder for conditional voxelmorph architectures", "\n", "\n", "", "", "def", "conv_dec", "(", "\n", "input_tensor", ",", "\n", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.ConditionalTemplateCreation.__init__": [[594, 695], ["tensorflow.Input", "tensorflow.Input", "tensorflow.Input", "tensorflow.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model", "neurite.models.conv_dec", "getattr", "range", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "tensorflow.keras.Model", "networks.VxmDense", "modelio.LoadableModel.__init__", "tensorflow.Dense", "tensorflow.Dense", "tensorflow.Dense", "tensorflow.Dense", "tensorflow.Reshape", "tensorflow.Reshape", "tensorflow.Reshape", "tensorflow.Reshape", "getattr.", "getattr.", "getattr.", "numpy.prod", "len", "getattr.", "tensorflow.Add", "tensorflow.Add", "tensorflow.Add", "tensorflow.Add", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "getattr.get_weights", "templcondsi_init.reshape", "getattr.set_weights", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Add", "tensorflow.Add", "tensorflow.Add", "tensorflow.Add", "neurite.layers.MeanStream", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.RandomNormal", "tensorflow.softmax", "tensorflow.softmax", "tensorflow.softmax", "tensorflow.softmax", "tensorflow.concatenate", "tensorflow.concatenate", "tensorflow.concatenate", "tensorflow.concatenate"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.models.conv_dec", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.softmax", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.softmax", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.softmax", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.softmax"], ["dilation_rate_mult", "=", "1", ",", "\n", "activation", "=", "'elu'", ",", "\n", "use_residuals", "=", "False", ",", "\n", "final_pred_activation", "=", "'linear'", ",", "\n", "nb_conv_per_level", "=", "2", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "batch_norm", "=", "None", ",", "\n", "convL", "=", "None", ",", "\n", "input_model", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Decoder for conditional vxm architecture.\n\n    Taken directly from vxm/neurite,\n    https://github.com/adalca/neurite/blob/master/neurite/tf/models.py#L725\n\n    \"\"\"", "\n", "\n", "# vol size info", "\n", "ndims", "=", "len", "(", "input_shape", ")", "-", "1", "\n", "input_shape", "=", "tuple", "(", "input_shape", ")", "\n", "if", "isinstance", "(", "pool_size", ",", "int", ")", ":", "\n", "        ", "if", "ndims", ">", "1", ":", "\n", "            ", "pool_size", "=", "(", "pool_size", ",", ")", "*", "ndims", "\n", "", "", "if", "ndims", "==", "1", "and", "isinstance", "(", "pool_size", ",", "tuple", ")", ":", "\n", "        ", "pool_size", "=", "pool_size", "[", "0", "]", "# 1D upsampling takes int not tuple", "\n", "\n", "# prepare layers", "\n", "", "if", "convL", "is", "None", ":", "\n", "        ", "convL", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "", "conv_kwargs", "=", "{", "'padding'", ":", "padding", ",", "'activation'", ":", "activation", "}", "\n", "upsample", "=", "getattr", "(", "KL", ",", "'UpSampling%dD'", "%", "ndims", ")", "\n", "\n", "# up arm:", "\n", "# nb_levels - 1 layers of Deconvolution3D", "\n", "#    (approx via up + conv + ReLu) + merge + conv + ReLu + conv + ReLu", "\n", "lfidx", "=", "0", "\n", "for", "level", "in", "range", "(", "nb_levels", "-", "1", ")", ":", "\n", "        ", "nb_lvl_feats", "=", "np", ".", "round", "(", "\n", "nb_features", "*", "feat_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", ",", "\n", ")", ".", "astype", "(", "int", ")", "\n", "conv_kwargs", "[", "'dilation_rate'", "]", "=", "dilation_rate_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", "\n", "\n", "# upsample matching the max pooling layers size", "\n", "name", "=", "'%s_up_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ")", "\n", "last_tensor", "=", "upsample", "(", "size", "=", "pool_size", ",", "name", "=", "name", ")", "(", "input_tensor", ")", "\n", "\n", "# convolution layers", "\n", "for", "conv", "in", "range", "(", "nb_conv_per_level", ")", ":", "\n", "            ", "if", "layer_nb_feats", "is", "not", "None", ":", "\n", "                ", "nb_lvl_feats", "=", "layer_nb_feats", "[", "lfidx", "]", "\n", "lfidx", "+=", "1", "\n", "\n", "", "name", "=", "'%s_conv_uparm_%d_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ",", "conv", ")", "\n", "if", "conv", "<", "(", "nb_conv_per_level", "-", "1", ")", "or", "(", "not", "use_residuals", ")", ":", "\n", "                ", "last_tensor", "=", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ",", "\n", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "                ", "last_tensor", "=", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "padding", "=", "padding", ",", "name", "=", "name", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "", "", "", "pred_tensor", "=", "convL", "(", "nb_labels", ",", "1", ",", "activation", "=", "None", ")", "(", "last_tensor", ")", "\n", "\n", "return", "pred_tensor", "\n", "\n", "\n", "# ----------------------------------------------------------------------------", "\n", "# Decoder for custom architectures", "\n", "\n", "", "def", "conv_dec_film", "(", "\n", "condn_emb", ",", "\n", "condn_vec", ",", "\n", "nb_features", ",", "\n", "input_shape", ",", "\n", "nb_levels", ",", "\n", "conv_size", ",", "\n", "nb_labels", ",", "\n", "sn", "=", "False", ",", "\n", "conditional", "=", "True", ",", "\n", "name", "=", "None", ",", "\n", "prefix", "=", "None", ",", "\n", "feat_mult", "=", "1", ",", "\n", "pool_size", "=", "2", ",", "\n", "padding", "=", "'valid'", ",", "\n", "dilation_rate_mult", "=", "1", ",", "\n", "use_residuals", "=", "False", ",", "\n", "final_pred_activation", "=", "'linear'", ",", "\n", "nb_conv_per_level", "=", "2", ",", "\n", "layer_nb_feats", "=", "None", ",", "\n", "convL", "=", "None", ",", "\n", "init", "=", "'default'", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Modified from VXM/neurite to use FiLM layers instead of bias params,\n    https://github.com/adalca/neurite/blob/master/neurite/tf/models.py#L725\n\n    As this function was taken from VXM, it has a lot of inapplicable\n    functionality which will be fixed prior to public release.\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.Transform.__init__": [[706, 736], ["len", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "layers.SpatialTransformer", "layers.SpatialTransformer.", "super().__init__", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "layers.RescaleTransform"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["", "if", "convL", "is", "None", ":", "\n", "        ", "convL", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "\n", "# If conditional:", "\n", "", "if", "conditional", "is", "True", ":", "\n", "        ", "conv_kwargs", "=", "{", "\n", "'use_bias'", ":", "False", ",", "\n", "'kernel_initializer'", ":", "init", ",", "\n", "}", "\n", "", "else", ":", "\n", "       ", "conv_kwargs", "=", "{", "\n", "'use_bias'", ":", "True", ",", "\n", "'kernel_initializer'", ":", "init", ",", "\n", "}", "\n", "\n", "", "up_shape", "=", "tuple", "(", "2", "*", "np", ".", "array", "(", "K", ".", "int_shape", "(", "condn_emb", ")", "[", "1", ":", "-", "1", "]", ")", ")", "# TODO: ugly", "\n", "\n", "# up arm:", "\n", "# nb_levels - 1 layers of Deconvolution3D", "\n", "#    (approx via up + conv + ReLu) + merge + conv + ReLu + conv + ReLu", "\n", "lfidx", "=", "0", "\n", "\n", "last_tensor", "=", "1.0", "*", "condn_emb", "\n", "\n", "for", "level", "in", "range", "(", "nb_levels", "-", "1", ")", ":", "\n", "        ", "nb_lvl_feats", "=", "np", ".", "round", "(", "\n", "nb_features", "*", "feat_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", ",", "\n", ")", ".", "astype", "(", "int", ")", "\n", "conv_kwargs", "[", "'dilation_rate'", "]", "=", "dilation_rate_mult", "**", "(", "nb_levels", "-", "2", "-", "level", ")", "\n", "\n", "# upsample matching the max pooling layers size", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks.Unet.__init__": [[751, 831], ["isinstance", "getattr", "len", "range", "range", "enumerate", "super().__init__", "tensorflow.Input", "tensorflow.Input", "tensorflow.Input", "tensorflow.Input", "tensorflow.concatenate", "tensorflow.concatenate", "tensorflow.concatenate", "tensorflow.concatenate", "default_unet_features", "numpy.round().astype", "len", "int", "range", "enc_layers.append", "range", "networks._conv_block", "ValueError", "ValueError", "numpy.repeat", "numpy.repeat", "ValueError", "tensorflow.concatenate.get_shape", "networks._conv_block", "getattr.", "networks._conv_block", "networks._upsample_block", "str", "numpy.round", "numpy.flip", "str", "enc_layers.pop", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.default_unet_features", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks._conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks._conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks._conv_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks._upsample_block", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange"], ["\n", "", "name", "=", "'%s_conv_uparm_%d_%d'", "%", "(", "prefix", ",", "nb_levels", "+", "level", ",", "conv", ")", "\n", "if", "conv", "<", "(", "nb_conv_per_level", "-", "1", ")", "or", "(", "not", "use_residuals", ")", ":", "\n", "                ", "last_tensor", "=", "tf", ".", "pad", "(", "\n", "last_tensor", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\n", "\"REFLECT\"", ",", "\n", ")", "\n", "if", "sn", ":", "\n", "                    ", "last_tensor", "=", "SpectralNormalization", "(", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ",", "\n", ")", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "                    ", "last_tensor", "=", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "**", "conv_kwargs", ",", "name", "=", "name", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "conditional", ":", "\n", "                    ", "last_tensor", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "last_tensor", ",", "condn_vec", "]", ")", "\n", "", "last_tensor", "=", "KL", ".", "LeakyReLU", "(", "0.2", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "                ", "last_tensor", "=", "tf", ".", "pad", "(", "\n", "last_tensor", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\n", "\"REFLECT\"", ",", "\n", ")", "\n", "if", "sn", ":", "\n", "                    ", "last_tensor", "=", "SpectralNormalization", "(", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "padding", "=", "padding", ",", "name", "=", "name", ",", "\n", ")", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "                    ", "last_tensor", "=", "convL", "(", "\n", "nb_lvl_feats", ",", "conv_size", ",", "padding", "=", "padding", ",", "name", "=", "name", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "conditional", ":", "\n", "                    ", "last_tensor", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "last_tensor", ",", "condn_vec", "]", ")", "\n", "\n", "", "", "", "", "if", "sn", ":", "\n", "        ", "pred_tensor", "=", "SpectralNormalization", "(", "convL", "(", "\n", "nb_labels", ",", "1", ",", "activation", "=", "None", ",", "\n", ")", ")", "(", "last_tensor", ")", "\n", "", "else", ":", "\n", "        ", "pred_tensor", "=", "convL", "(", "nb_labels", ",", "1", ",", "activation", "=", "None", ")", "(", "last_tensor", ")", "\n", "\n", "", "if", "conditional", ":", "\n", "        ", "pred_tensor", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "pred_tensor", ",", "condn_vec", "]", ")", "\n", "\n", "", "return", "pred_tensor", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks._conv_block": [[837, 848], ["getattr", "len", "getattr.", "tensorflow.LeakyReLU", "x.get_shape"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.networks._upsample_block": [[850, 861], ["getattr", "tensorflow.concatenate", "len", "getattr.", "x.get_shape"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatialTransformer.__init__": [[52, 86], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["        ", "return", "-", "x", "\n", "\n", "", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n", "\n", "", "", "class", "RescaleValues", "(", "Layer", ")", ":", "\n", "    ", "\"\"\" \n    Very simple Keras layer to rescale data values (e.g. intensities) by fixed factor\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "resize", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "resize", "=", "resize", "\n", "super", "(", "RescaleValues", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", ".", "copy", "(", ")", "\n", "config", ".", "update", "(", "{", "'resize'", ":", "self", ".", "resize", "}", ")", "\n", "return", "config", "\n", "\n", "", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "RescaleValues", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n", "", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "resize", "\n", "\n", "", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n", "\n", "", "", "class", "Resize", "(", "Layer", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatialTransformer.get_config": [[87, 98], ["super().get_config().copy", "super().get_config().copy.update", "super().get_config"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.LoadableModel.get_config"], ["\n", "\n", "def", "__init__", "(", "self", ",", "\n", "zoom_factor", ",", "\n", "interp_method", "=", "'linear'", ",", "\n", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatialTransformer.build": [[99, 142], ["len", "Exception", "len", "len", "len", "len", "Exception", "Exception"], "methods", ["None"], ["        ", "\"\"\"\n        Parameters: \n            interp_method: 'linear' or 'nearest'\n                'xy' indexing will have the first two entries of the flow \n                (along last axis) flipped compared to 'ij' indexing\n        \"\"\"", "\n", "self", ".", "zoom_factor", "=", "zoom_factor", "\n", "self", ".", "interp_method", "=", "interp_method", "\n", "self", ".", "ndims", "=", "None", "\n", "self", ".", "inshape", "=", "None", "\n", "super", "(", "Resize", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", ".", "copy", "(", ")", "\n", "config", ".", "update", "(", "{", "\n", "'zoom_factor'", ":", "self", ".", "zoom_factor", ",", "\n", "'interp_method'", ":", "self", ".", "interp_method", ",", "\n", "}", ")", "\n", "return", "config", "\n", "\n", "", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "\"\"\"\n        input_shape should be an element of list of one inputs:\n        input1: volume\n                should be a *vol_shape x N\n        \"\"\"", "\n", "\n", "if", "isinstance", "(", "input_shape", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", "and", "len", "(", "input_shape", ")", ">", "1", ":", "\n", "            ", "raise", "Exception", "(", "'Resize must be called on a list of length 1.'", ")", "\n", "\n", "", "if", "isinstance", "(", "input_shape", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "input_shape", "=", "input_shape", "[", "0", "]", "\n", "\n", "# set up number of dimensions", "\n", "", "self", ".", "ndims", "=", "len", "(", "input_shape", ")", "-", "2", "\n", "self", ".", "inshape", "=", "input_shape", "\n", "if", "not", "isinstance", "(", "self", ".", "zoom_factor", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "self", ".", "zoom_factor", "=", "[", "self", ".", "zoom_factor", "]", "*", "self", ".", "ndims", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "self", ".", "zoom_factor", ")", "==", "self", ".", "ndims", ",", "'zoom factor length {} does not match number of dimensions {}'", ".", "format", "(", "len", "(", "self", ".", "zoom_factor", ")", ",", "self", ".", "ndims", ")", "\n", "\n", "# confirm built", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatialTransformer.call": [[143, 183], ["tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "len", "len", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.split", "tensorflow.split", "tensorflow.concat", "tensorflow.concat", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.map_fn", "numpy.prod", "len", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.eye", "tensorflow.eye", "utils.affine_to_shift", "layers.SpatialTransformer._single_transform", "tensorflow.reshape.shape.as_list", "tensorflow.shape", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_to_shift", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatialTransformer._single_transform"], ["", "self", ".", "built", "=", "True", "\n", "\n", "super", "(", "Resize", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n", "\n", "", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n            inputs: volume of list with one volume\n        \"\"\"", "\n", "\n", "# check shapes", "\n", "if", "isinstance", "(", "inputs", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "assert", "len", "(", "inputs", ")", "==", "1", ",", "\"inputs has to be len 1. found: %d\"", "%", "len", "(", "inputs", ")", "\n", "vol", "=", "inputs", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "vol", "=", "inputs", "\n", "\n", "# necessary for multi_gpu models...", "\n", "", "vol", "=", "K", ".", "reshape", "(", "vol", ",", "[", "-", "1", ",", "*", "self", ".", "inshape", "[", "1", ":", "]", "]", ")", "\n", "\n", "# map transform across batch", "\n", "return", "tf", ".", "map_fn", "(", "self", ".", "_single_resize", ",", "vol", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "\n", "        ", "output_shape", "=", "[", "input_shape", "[", "0", "]", "]", "\n", "output_shape", "+=", "[", "int", "(", "input_shape", "[", "1", ":", "-", "1", "]", "[", "f", "]", "*", "self", ".", "zoom_factor", "[", "f", "]", ")", "for", "f", "in", "range", "(", "self", ".", "ndims", ")", "]", "\n", "output_shape", "+=", "[", "input_shape", "[", "-", "1", "]", "]", "\n", "return", "tuple", "(", "output_shape", ")", "\n", "\n", "", "def", "_single_resize", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "return", "utils", ".", "resize", "(", "inputs", ",", "self", ".", "zoom_factor", ",", "interp_method", "=", "self", ".", "interp_method", ")", "\n", "\n", "# Zoom naming of resize, to match scipy's naming", "\n", "", "", "Zoom", "=", "Resize", "\n", "\n", "\n", "class", "MSE", "(", "Layer", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.SpatialTransformer._single_transform": [[184, 186], ["utils.transform"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.transform"], ["\n", "\n", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.VecInt.__init__": [[202, 224], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["\n", "\n", "def", "__init__", "(", "self", ",", "level", "=", "None", ",", "sigma", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "sigma", "is", "not", "None", "or", "level", "is", "not", "None", ",", "'sigma or level must be provided'", "\n", "assert", "not", "(", "sigma", "is", "not", "None", "and", "level", "is", "not", "None", ")", ",", "'only sigma or level must be provided'", "\n", "\n", "if", "level", "is", "not", "None", ":", "\n", "            ", "if", "level", "<", "1", ":", "\n", "                ", "raise", "ValueError", "(", "'Gaussian blur level must not be less than 1'", ")", "\n", "\n", "", "self", ".", "sigma", "=", "(", "level", "-", "1", ")", "**", "2", "\n", "\n", "", "else", ":", "\n", "            ", "if", "sigma", "<", "0", ":", "\n", "                ", "raise", "ValueError", "(", "'Gaussian blur sigma must not be less than 0'", ")", "\n", "\n", "", "self", ".", "sigma", "=", "sigma", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "ndims", "=", "len", "(", "input_shape", ")", "-", "2", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.VecInt.get_config": [[225, 236], ["super().get_config().copy", "super().get_config().copy.update", "super().get_config"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.LoadableModel.get_config"], ["\n", "# prepare kernel", "\n", "kernel", "=", "utils", ".", "gaussian_kernel", "(", "[", "self", ".", "sigma", "]", "*", "ndims", ")", "\n", "kernel", "=", "tf", ".", "reshape", "(", "kernel", ",", "kernel", ".", "shape", ".", "as_list", "(", ")", "+", "[", "1", ",", "1", "]", ")", "\n", "\n", "# prepare convoperation", "\n", "convnd", "=", "getattr", "(", "tf", ".", "nn", ",", "'conv%dd'", "%", "ndims", ")", "\n", "self", ".", "conv", "=", "lambda", "x", ":", "convnd", "(", "tf", ".", "expand_dims", "(", "x", ",", "-", "1", ")", ",", "kernel", ",", "[", "1", "]", "*", "(", "ndims", "+", "2", ")", ",", "padding", "=", "'SAME'", ")", "\n", "self", ".", "nfeat", "=", "input_shape", "[", "-", "1", "]", "\n", "\n", "", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "# TODO: switch to mutli-line if statement", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.VecInt.build": [[237, 249], ["isinstance", "Exception", "len", "len"], "methods", ["None"], ["        ", "return", "x", "if", "self", ".", "sigma", "==", "0", "else", "tf", ".", "concat", "(", "[", "self", ".", "conv", "(", "x", "[", "...", ",", "n", "]", ")", "for", "n", "in", "range", "(", "self", ".", "nfeat", ")", "]", ",", "-", "1", ")", "\n", "\n", "", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n", "\n", "\n", "#########################################################", "\n", "# Sparse layers", "\n", "#########################################################", "\n", "\n", "", "", "class", "SpatiallySparse_Dense", "(", "Layer", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.VecInt.call": [[250, 274], ["tensorflow.reshape", "tensorflow.reshape", "hasattr", "tensorflow.map_fn", "tensorflow.map_fn", "hasattr", "isinstance", "tensorflow.split", "tensorflow.split", "tensorflow.concat", "tensorflow.concat", "len"], "methods", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "input_shape", ",", "output_len", ",", "use_bias", "=", "False", ",", "\n", "kernel_initializer", "=", "'RandomNormal'", ",", "\n", "bias_initializer", "=", "'RandomNormal'", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "kernel_initializer", "=", "kernel_initializer", "\n", "self", ".", "bias_initializer", "=", "bias_initializer", "\n", "self", ".", "output_len", "=", "output_len", "\n", "self", ".", "cargs", "=", "0", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "self", ".", "orig_input_shape", "=", "input_shape", "# just the image size", "\n", "super", "(", "SpatiallySparse_Dense", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.VecInt._single_int": [[275, 286], ["utils.integrate_vec", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.integrate_vec"], ["\n", "\n", "# Create a trainable weight variable for this layer.", "\n", "        ", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "name", "=", "'mult-kernel'", ",", "\n", "shape", "=", "(", "np", ".", "prod", "(", "self", ".", "orig_input_shape", ")", ",", "\n", "self", ".", "output_len", ")", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "\n", "M", "=", "K", ".", "reshape", "(", "self", ".", "kernel", ",", "[", "-", "1", ",", "self", ".", "output_len", "]", ")", "# D x d", "\n", "mt", "=", "K", ".", "transpose", "(", "M", ")", "# d x D", "\n", "mtm_inv", "=", "tf", ".", "matrix_inverse", "(", "K", ".", "dot", "(", "mt", ",", "M", ")", ")", "# d x d", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleTransform.__init__": [[297, 302], ["tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["#                                 initializer=self.initializer,", "\n", "#                                 trainable=True)", "\n", "\n", "", "super", "(", "SpatiallySparse_Dense", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n", "", "def", "call", "(", "self", ",", "args", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleTransform.get_config": [[303, 305], ["None"], "methods", ["None"], ["\n", "        ", "if", "not", "isinstance", "(", "args", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "args", "=", "[", "args", "]", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleTransform.build": [[306, 318], ["isinstance", "utils.is_affine", "super().build", "isinstance", "Exception", "utils.extract_affine_ndims", "int", "len"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.is_affine", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.extract_affine_ndims"], ["", "self", ".", "cargs", "=", "len", "(", "args", ")", "\n", "\n", "# flatten", "\n", "if", "len", "(", "args", ")", "==", "2", ":", "# input y, m", "\n", "# get inputs", "\n", "            ", "y", ",", "y_mask", "=", "args", "\n", "a_fact", "=", "int", "(", "y", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", "/", "y_mask", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", ")", "\n", "y_mask", "=", "K", ".", "repeat_elements", "(", "y_mask", ",", "a_fact", ",", "-", "1", ")", "\n", "y_flat", "=", "K", ".", "batch_flatten", "(", "y", ")", "# N x D", "\n", "y_mask_flat", "=", "K", ".", "batch_flatten", "(", "y_mask", ")", "# N x D", "\n", "\n", "# prepare switching matrix", "\n", "W", "=", "self", ".", "W", "# d x D", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleTransform.call": [[319, 339], ["isinstance", "tensorflow.map_fn", "tensorflow.map_fn", "len", "len", "neurite.layers.Resize", "neurite.layers.RescaleValues", "neurite.layers.RescaleValues", "neurite.layers.Resize"], "methods", ["None"], ["\n", "w_tmp", "=", "K", ".", "expand_dims", "(", "W", ",", "0", ")", "# 1 x d x D", "\n", "Wo", "=", "K", ".", "permute_dimensions", "(", "w_tmp", ",", "[", "0", ",", "2", ",", "1", "]", ")", "*", "K", ".", "expand_dims", "(", "y_mask_flat", ",", "-", "1", ")", "# N x D x d", "\n", "WoT", "=", "K", ".", "permute_dimensions", "(", "Wo", ",", "[", "0", ",", "2", ",", "1", "]", ")", "# N x d x D", "\n", "WotWo_inv", "=", "tf", ".", "matrix_inverse", "(", "K", ".", "batch_dot", "(", "WoT", ",", "Wo", ")", ")", "# N x d x d", "\n", "pre", "=", "K", ".", "batch_dot", "(", "WotWo_inv", ",", "WoT", ")", "# N x d x D", "\n", "res", "=", "K", ".", "batch_dot", "(", "pre", ",", "y_flat", ")", "# N x d", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "                ", "res", "+=", "K", ".", "expand_dims", "(", "self", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "x_data", "=", "args", "[", "0", "]", "\n", "shape", "=", "K", ".", "shape", "(", "x_data", ")", "\n", "\n", "x_data", "=", "K", ".", "batch_flatten", "(", "x_data", ")", "# N x d", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "                ", "x_data", "-=", "self", ".", "bias", "\n", "\n", "", "res", "=", "K", ".", "dot", "(", "x_data", ",", "self", ".", "W", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleTransform._single_affine_rescale": [[340, 345], ["utils.affine_shift_to_identity", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.concat", "tensorflow.concat", "utils.affine_identity_to_shift"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_shift_to_identity", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_identity_to_shift"], ["\n", "# reshape", "\n", "# Here you can mix integers and symbolic elements of `shape`", "\n", "pool_shape", "=", "tf", ".", "stack", "(", "[", "shape", "[", "0", "]", ",", "*", "self", ".", "orig_input_shape", "]", ")", "\n", "res", "=", "K", ".", "reshape", "(", "res", ",", "pool_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.RescaleTransform.compute_output_shape": [[346, 352], ["int"], "methods", ["None"], ["", "return", "res", "\n", "\n", "", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "# print(self.cargs, input_shape, self.output_len, self.orig_input_shape)", "\n", "        ", "if", "self", ".", "cargs", "==", "2", ":", "\n", "            ", "return", "(", "input_shape", "[", "0", "]", "[", "0", "]", ",", "self", ".", "output_len", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ComposeTransform.build": [[370, 395], ["utils.is_affine", "utils.is_affine", "super().build", "len", "Exception", "len", "int", "int", "numpy.sqrt", "int"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.is_affine", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.is_affine", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], ["\n", "", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# Create a trainable weight variable for this layer.", "\n", "        ", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "name", "=", "'kernel'", ",", "\n", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "\n", "initializer", "=", "self", ".", "initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "super", "(", "LocalBias", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n", "", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "+", "self", ".", "kernel", "*", "self", ".", "biasmult", "# weights are difference from input", "\n", "\n", "", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n", "\n", "", "", "class", "LocalLinear", "(", "Layer", ")", ":", "\n", "    ", "\"\"\" \n    Local linear layer: each pixel/voxel has its own linear operation (two parameters)\n    out[v] = a * in[v] + b\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "initializer", "=", "'RandomNormal'", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "initializer", "=", "initializer", "\n", "super", "(", "LocalLinear", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ComposeTransform.call": [[396, 417], ["len", "len", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.map_fn", "layers.AffineToDense", "layers.AffineToDense"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "# Create a trainable weight variable for this layer.", "\n", "        ", "self", ".", "mult", "=", "self", ".", "add_weight", "(", "name", "=", "'mult-kernel'", ",", "\n", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "\n", "initializer", "=", "self", ".", "initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "self", ".", "bias", "=", "self", ".", "add_weight", "(", "name", "=", "'bias-kernel'", ",", "\n", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "\n", "initializer", "=", "self", ".", "initializer", ",", "\n", "trainable", "=", "True", ")", "\n", "super", "(", "LocalLinear", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n", "\n", "", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "mult", "+", "self", ".", "bias", "\n", "\n", "", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n", "\n", "", "", "class", "LocallyConnected3D", "(", "Layer", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ComposeTransform._single_dense_compose": [[418, 420], ["neurite.utils.compose"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.compose"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ComposeTransform._single_affine_compose": [[421, 426], ["utils.affine_shift_to_identity", "utils.affine_shift_to_identity", "tensorflow.linalg.matmul", "tensorflow.linalg.matmul", "utils.affine_identity_to_shift"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_shift_to_identity", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_shift_to_identity", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_identity_to_shift"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.ComposeTransform.compute_output_shape": [[427, 432], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineToDense.__init__": [[440, 444], ["len", "tensorflow.keras.layers.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineToDense.build": [[445, 459], ["super().build", "len", "ValueError", "ValueError", "len", "str", "str"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineToDense.call": [[460, 468], ["tensorflow.map_fn", "tensorflow.map_fn"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineToDense._single_aff_to_shift": [[469, 476], ["utils.affine_to_shift", "len", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.eye", "tensorflow.eye"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_to_shift"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineToDense.compute_output_shape": [[477, 479], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build": [[487, 490], ["utils.extract_affine_ndims", "super().build"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.extract_affine_ndims", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.build"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.compute_output_shape": [[491, 493], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine.call": [[494, 501], ["tensorflow.map_fn", "tensorflow.map_fn"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.InvertAffine._single_invert": [[502, 506], ["utils.affine_shift_to_identity", "tensorflow.linalg.inv", "tensorflow.linalg.inv", "utils.affine_identity_to_shift"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_shift_to_identity", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_identity_to_shift"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineTransformationsToMatrix.__init__": [[518, 525], ["tensorflow.keras.layers.Layer.__init__", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "padding", "=", "'valid'", ",", "\n", "data_format", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineTransformationsToMatrix.compute_output_shape": [[526, 528], ["None"], "methods", ["None"], ["kernel_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineTransformationsToMatrix.call": [[529, 535], ["tensorflow.map_fn", "tensorflow.map_fn"], "methods", ["None"], ["kernel_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "implementation", "=", "1", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "LocallyConnected3D", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "filters", "=", "filters", "\n", "self", ".", "kernel_size", "=", "conv_utils", ".", "normalize_tuple", "(", "kernel_size", ",", "3", ",", "'kernel_size'", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.layers.AffineTransformationsToMatrix._single_conversion": [[536, 615], ["tensorflow.eye", "tensorflow.eye", "tensorflow.tensordot", "tensorflow.tensordot", "tensorflow.concat", "tensorflow.concat", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.math.cos", "tensorflow.math.cos", "tensorflow.math.sin", "tensorflow.math.sin", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.math.cos", "tensorflow.math.cos", "tensorflow.math.sin", "tensorflow.math.sin", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.math.cos", "tensorflow.math.cos", "tensorflow.math.sin", "tensorflow.math.sin", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.tensordot", "tensorflow.tensordot", "tensorflow.tensordot", "tensorflow.tensordot", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.math.cos", "tensorflow.math.cos", "tensorflow.math.sin", "tensorflow.math.sin", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.expand_dims", "tensorflow.expand_dims"], "methods", ["None"], ["self", ".", "strides", "=", "conv_utils", ".", "normalize_tuple", "(", "strides", ",", "3", ",", "'strides'", ")", "\n", "self", ".", "padding", "=", "conv_utils", ".", "normalize_padding", "(", "padding", ")", "\n", "if", "self", ".", "padding", "!=", "'valid'", "and", "implementation", "==", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Invalid border mode for LocallyConnected3D '", "\n", "'(only \"valid\" is supported if implementation is 1): '", "\n", "+", "padding", ")", "\n", "", "self", ".", "data_format", "=", "conv_utils", ".", "normalize_data_format", "(", "data_format", ")", "\n", "self", ".", "activation", "=", "tf", ".", "keras", ".", "activations", ".", "get", "(", "activation", ")", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "self", ".", "kernel_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "get", "(", "kernel_initializer", ")", "\n", "self", ".", "bias_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "get", "(", "bias_initializer", ")", "\n", "self", ".", "kernel_regularizer", "=", "tf", ".", "keras", ".", "regularizers", ".", "get", "(", "kernel_regularizer", ")", "\n", "self", ".", "bias_regularizer", "=", "tf", ".", "keras", ".", "regularizers", ".", "get", "(", "bias_regularizer", ")", "\n", "self", ".", "activity_regularizer", "=", "tf", ".", "keras", ".", "regularizers", ".", "get", "(", "activity_regularizer", ")", "\n", "self", ".", "kernel_constraint", "=", "tf", ".", "keras", ".", "constraints", ".", "get", "(", "kernel_constraint", ")", "\n", "self", ".", "bias_constraint", "=", "tf", ".", "keras", ".", "constraints", ".", "get", "(", "bias_constraint", ")", "\n", "self", ".", "implementation", "=", "implementation", "\n", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "5", ")", "\n", "\n", "", "@", "tf_utils", ".", "shape_type_conversion", "\n", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "if", "self", ".", "data_format", "==", "'channels_last'", ":", "\n", "            ", "input_row", ",", "input_col", ",", "input_z", "=", "input_shape", "[", "1", ":", "-", "1", "]", "\n", "input_filter", "=", "input_shape", "[", "4", "]", "\n", "", "else", ":", "\n", "            ", "input_row", ",", "input_col", ",", "input_z", "=", "input_shape", "[", "2", ":", "]", "\n", "input_filter", "=", "input_shape", "[", "1", "]", "\n", "", "if", "input_row", "is", "None", "or", "input_col", "is", "None", "or", "input_z", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'The spatial dimensions of the inputs to '", "\n", "' a LocallyConnected3D layer '", "\n", "'should be fully-defined, but layer received '", "\n", "'the inputs shape '", "+", "str", "(", "input_shape", ")", ")", "\n", "", "output_row", "=", "conv_utils", ".", "conv_output_length", "(", "\n", "input_row", ",", "self", ".", "kernel_size", "[", "0", "]", ",", "self", ".", "padding", ",", "self", ".", "strides", "[", "0", "]", ")", "\n", "output_col", "=", "conv_utils", ".", "conv_output_length", "(", "\n", "input_col", ",", "self", ".", "kernel_size", "[", "1", "]", ",", "self", ".", "padding", ",", "self", ".", "strides", "[", "1", "]", ")", "\n", "output_z", "=", "conv_utils", ".", "conv_output_length", "(", "\n", "input_z", ",", "self", ".", "kernel_size", "[", "2", "]", ",", "self", ".", "padding", ",", "self", ".", "strides", "[", "2", "]", ")", "\n", "self", ".", "output_row", "=", "output_row", "\n", "self", ".", "output_col", "=", "output_col", "\n", "self", ".", "output_z", "=", "output_z", "\n", "\n", "if", "self", ".", "implementation", "==", "1", ":", "\n", "            ", "self", ".", "kernel_shape", "=", "(", "\n", "output_row", "*", "output_col", "*", "output_z", ",", "\n", "self", ".", "kernel_size", "[", "0", "]", "*", "self", ".", "kernel_size", "[", "1", "]", "*", "self", ".", "kernel_size", "[", "2", "]", "*", "input_filter", ",", "\n", "self", ".", "filters", ")", "\n", "\n", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "\n", "shape", "=", "self", ".", "kernel_shape", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "name", "=", "'kernel'", ",", "\n", "regularizer", "=", "self", ".", "kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "kernel_constraint", ")", "\n", "\n", "", "elif", "self", ".", "implementation", "==", "2", ":", "\n", "            ", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "              ", "self", ".", "kernel_shape", "=", "(", "input_filter", ",", "input_row", ",", "input_col", ",", "input_z", ",", "\n", "self", ".", "filters", ",", "self", ".", "output_row", ",", "self", ".", "output_col", ",", "self", ".", "output_z", ")", "\n", "", "else", ":", "\n", "              ", "self", ".", "kernel_shape", "=", "(", "input_row", ",", "input_col", ",", "input_z", ",", "input_filter", ",", "\n", "self", ".", "output_row", ",", "self", ".", "output_col", ",", "self", ".", "output_z", ",", "self", ".", "filters", ")", "\n", "\n", "", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "self", ".", "kernel_shape", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "name", "=", "'kernel'", ",", "\n", "regularizer", "=", "self", ".", "kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "kernel_constraint", ")", "\n", "\n", "self", ".", "kernel_mask", "=", "LocallyConnected3D", ".", "get_locallyconnected_mask", "(", "\n", "input_shape", "=", "(", "input_row", ",", "input_col", ",", "input_z", ")", ",", "\n", "kernel_shape", "=", "self", ".", "kernel_size", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "data_format", "=", "self", ".", "data_format", "\n", ")", "\n", "\n", "", "elif", "self", ".", "implementation", "==", "3", ":", "\n", "            ", "self", ".", "kernel_shape", "=", "(", "self", ".", "output_row", "*", "self", ".", "output_col", "*", "self", ".", "output_z", "*", "self", ".", "filters", ",", "\n", "input_row", "*", "input_col", "*", "input_z", "*", "input_filter", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.ModelConfig.__init__": [[52, 54], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "'config'", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'models that inherit from LoadableModel must decorate the constructor with @store_config_args'", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.LoadableModel.get_config": [[69, 77], ["hasattr", "RuntimeError"], "methods", ["None"], ["def", "load", "(", "cls", ",", "path", ",", "device", ")", ":", "\n", "        ", "\"\"\"\n        Load a python model configuration and weights.\n        \"\"\"", "\n", "checkpoint", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "torch", ".", "device", "(", "device", ")", ")", "\n", "model", "=", "cls", "(", "**", "checkpoint", "[", "'config'", "]", ")", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'model_state'", "]", ",", "strict", "=", "False", ")", "\n", "return", "model", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.LoadableModel.from_config": [[78, 84], ["cls"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.LoadableModel.load": [[85, 106], ["cls", "cls.load_weights", "h5py.File", "config.get", "config.get", "json.loads", "config.pop", "config.pop", "f.attrs[].decode"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.modelio.store_config_args": [[8, 44], ["inspect.getargspec", "functools.wraps", "func", "zip", "modelio.ModelConfig", "zip", "kwargs.items", "reversed", "reversed"], "function", ["None"], ["    ", "\"\"\"\n    Class-method decorator that saves every argument provided to the\n    function as a dictionary in 'self.config'. This is used to assist\n    model loading - see LoadableModel.\n    \"\"\"", "\n", "\n", "attrs", ",", "varargs", ",", "varkw", ",", "defaults", "=", "inspect", ".", "getargspec", "(", "func", ")", "\n", "\n", "@", "functools", ".", "wraps", "(", "func", ")", "\n", "def", "wrapper", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "config", "=", "{", "}", "\n", "\n", "# first save the default values", "\n", "if", "defaults", ":", "\n", "            ", "for", "attr", ",", "val", "in", "zip", "(", "reversed", "(", "attrs", ")", ",", "reversed", "(", "defaults", ")", ")", ":", "\n", "                ", "self", ".", "config", "[", "attr", "]", "=", "val", "\n", "\n", "# next handle positional args", "\n", "", "", "for", "attr", ",", "val", "in", "zip", "(", "attrs", "[", "1", ":", "]", ",", "args", ")", ":", "\n", "            ", "self", ".", "config", "[", "attr", "]", "=", "val", "\n", "\n", "# lastly handle keyword args", "\n", "", "if", "kwargs", ":", "\n", "            ", "for", "attr", ",", "val", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                ", "self", ".", "config", "[", "attr", "]", "=", "val", "\n", "\n", "", "", "return", "func", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "return", "wrapper", "\n", "\n", "\n", "", "class", "LoadableModel", "(", "nn", ".", "Module", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.setup_device": [[25, 58], ["str", "len", "hasattr", "isinstance", "str.split", "tensorflow.ConfigProto", "tensorflow.keras.backend.set_session", "tensorflow.config.set_soft_device_placement", "tensorflow.config.list_physical_devices", "tensorflow.Session", "tensorflow.config.experimental.set_memory_growth"], "function", ["None"], ["\n", "\n", "return", "np", ".", "exp", "(", "x", ")", "/", "np", ".", "sum", "(", "np", ".", "exp", "(", "x", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_to_shift": [[65, 128], ["isinstance", "len", "neurite.utils.volshape_to_meshgrid", "flat_mesh.append", "tensorflow.transpose", "tensorflow.matmul", "tensorflow.transpose", "tensorflow.reshape", "volshape.as_list.as_list", "tensorflow.cast", "len", "tensorflow.reshape", "str", "Exception", "tensorflow.cast", "neurite.utils.flatten", "tensorflow.ones", "tensorflow.stack", "tensorflow.stack", "len", "ValueError", "list", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.volshape_to_meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.transform": [[130, 168], ["isinstance", "len", "neurite.utils.volshape_to_meshgrid", "neurite.utils.interpn", "loc_shift.shape[].as_list", "tensorflow.cast", "range"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.volshape_to_meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.interpn", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.compose": [[170, 194], ["utils.transform"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.transform"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.integrate_vec": [[196, 308], ["ValueError", "tensorflow.permute_dimensions", "range", "range", "tensorflow.cast", "tensorflow.concatenate", "odeint_fn", "tensorflow.permute_dimensions", "utils.transform", "range", "range", "utils.transform", "tensorflow.flatten", "tf.cast.get_shape().as_list", "ValueError", "kwargs.keys", "tensorflow.map_fn", "utils.transform", "utils.transform", "kwargs.keys", "kwargs.keys", "kwargs.keys", "range", "tf.cast.get_shape", "range", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.transform", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.transform", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.transform", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.transform", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.is_affine": [[310, 316], ["len", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.extract_affine_ndims": [[318, 328], ["len", "int", "int", "numpy.sqrt", "int"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_shift_to_identity": [[330, 340], ["utils.extract_affine_ndims", "tensorflow.reshape", "tensorflow.concat", "tensorflow.eye", "tf.concat.shape.as_list", "tensorflow.zeros"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.extract_affine_ndims"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.affine_identity_to_shift": [[342, 351], ["tensorflow.reshape", "int", "tensorflow.eye", "trf.shape.as_list"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.value_at_location": [[353, 371], ["tensorflow.map_fn", "neurite.utils.interpn", "tensorflow.abs"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.interpn"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.point_spatial_transformer": [[373, 407], ["tensorflow.map_fn", "surface_points.get_shape().as_list", "trf.get_shape().as_list", "tensorflow.expand_dims", "neurite.utils.interpn", "tensorflow.concat", "surface_points.get_shape", "trf.get_shape"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.interpn"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.utils.keras_transform": [[411, 425], ["tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Model().predict", "layers.SpatialTransformer", "layers.RescaleTransform", "tensorflow.keras.Model"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NCC.__init__": [[13, 16], ["None"], "methods", ["None"], ["loss_object_NonSquareNCC", "=", "NonSquareNCC", "(", "win", "=", "[", "9", "]", "*", "3", ")", "# not used in paper", "\n", "\n", "\n", "# ----------------------------------------------------------------------------", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NCC.ncc": [[17, 63], ["getattr", "tensorflow.ones", "tensorflow.ones", "tensorflow.ones", "getattr.", "getattr.", "getattr.", "getattr.", "getattr.", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "len", "J.get_shape().as_list", "numpy.prod", "tensorflow.batch_flatten", "tensorflow.batch_flatten", "tensorflow.batch_flatten", "I.get_shape().as_list", "J.get_shape", "I.get_shape"], "methods", ["None"], ["# Generator losses", "\n", "\n", "@", "tf", ".", "function", "\n", "def", "total_variation3D", "(", "ypred", ")", ":", "\n", "    ", "\"\"\"\n    Not used in paper.\n    Calculates anisotropic total variation for a 3D image ypred.\n    \"\"\"", "\n", "\n", "pixel_dif1", "=", "ypred", "[", ":", ",", "1", ":", ",", ":", ",", ":", ",", ":", "]", "-", "ypred", "[", ":", ",", ":", "-", "1", ",", ":", ",", ":", ",", ":", "]", "\n", "pixel_dif2", "=", "ypred", "[", ":", ",", ":", ",", "1", ":", ",", ":", ",", ":", "]", "-", "ypred", "[", ":", ",", ":", ",", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "pixel_dif3", "=", "ypred", "[", ":", ",", ":", ",", ":", ",", "1", ":", ",", ":", "]", "-", "ypred", "[", ":", ",", ":", ",", ":", ",", ":", "-", "1", ",", ":", "]", "\n", "\n", "tot_var", "=", "(", "\n", "tf", ".", "reduce_mean", "(", "tf", ".", "math", ".", "abs", "(", "pixel_dif1", ")", ")", "+", "\n", "tf", ".", "reduce_mean", "(", "tf", ".", "math", ".", "abs", "(", "pixel_dif2", ")", ")", "+", "\n", "tf", ".", "reduce_mean", "(", "tf", ".", "math", ".", "abs", "(", "pixel_dif3", ")", ")", "\n", ")", "\n", "return", "tf", ".", "reduce_mean", "(", "tot_var", ")", "\n", "\n", "\n", "", "@", "tf", ".", "function", "\n", "def", "generator_loss", "(", "\n", "disc_opinion_fake_local", ",", "\n", "disp_ms", ",", "\n", "disp", ",", "\n", "moved_atlases", ",", "\n", "fixed_images", ",", "\n", "epoch", ",", "\n", "sharp_atlases", ",", "\n", "loss_wts", ",", "\n", "start_step", "=", "0", ",", "\n", "reg_loss_type", "=", "'NCC'", ",", "\n", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NCC.loss": [[64, 66], ["losses.NCC.ncc"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NonSquareNCC.ncc"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.MSE.__init__": [[73, 75], ["None"], "methods", ["None"], ["lambda_gan", ",", "lambda_reg", ",", "lambda_tv", "=", "loss_wts", "\n", "\n", "# If training registration only, without GAN loss.", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.MSE.loss": [[76, 78], ["tensorflow.mean", "tensorflow.mean", "tensorflow.mean", "tensorflow.square", "tensorflow.square", "tensorflow.square"], "methods", ["None"], ["# Need to do this, otherwise graph detaches:", "\n", "if", "epoch", ">=", "start_step", ":", "\n", "        ", "gan_loss", "=", "loss_object", "(", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.TukeyBiweight.__init__": [[93, 95], ["None"], "methods", ["None"], [")", "\n", "", "elif", "reg_loss_type", "==", "'NonSquareNCC'", ":", "# Not used in paper.", "\n", "        ", "similarity_loss", "=", "tf", ".", "reduce_mean", "(", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.TukeyBiweight.loss": [[96, 104], ["tensorflow.where", "tensorflow.where", "tensorflow.where", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.reduce_prod", "tensorflow.reduce_prod", "tensorflow.reduce_prod", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.gather_nd", "tensorflow.gather_nd", "tensorflow.gather_nd"], "methods", ["None"], ["loss_object_NonSquareNCC", ".", "loss", "(", "moved_atlases", ",", "fixed_images", ")", ",", "\n", ")", "\n", "\n", "# smoothness terms:", "\n", "", "smoothness_loss", "=", "tf", ".", "reduce_mean", "(", "\n", "Grad", "(", "'l2'", ")", ".", "loss", "(", "tf", ".", "zeros_like", "(", "disp", ")", ",", "disp", ")", ",", "\n", ")", "\n", "\n", "# magnitude terms:", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.Dice.loss": [[111, 119], ["list", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "len", "range", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.div_no_nan", "tensorflow.div_no_nan", "tensorflow.div_no_nan", "y_pred.get_shape().as_list", "y_pred.get_shape"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["(", "lambda_reg", "*", "smoothness_loss", ")", "+", "\n", "(", "0.01", "*", "lambda_reg", "*", "magnitude_loss", ")", "+", "\n", "(", "lambda_reg", "*", "moving_magnitude_loss", ")", "+", "\n", "1", "*", "similarity_loss", "\n", ")", "\n", "", "else", ":", "\n", "        ", "total_gen_loss", "=", "(", "\n", "lambda_gan", "*", "gan_loss", "+", "\n", "(", "lambda_reg", "*", "smoothness_loss", ")", "+", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.Grad.__init__": [[129, 132], ["None"], "methods", ["None"], [")", "\n", "\n", "# ----------------------------------------------------------------------------", "\n", "# Discriminator losses", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.Grad._diffs": [[133, 153], ["len", "range", "tensorflow.permute_dimensions.get_shape().as_list", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions.get_shape", "range", "range", "range", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["\n", "\n", "", "@", "tf", ".", "function", "\n", "def", "discriminator_loss", "(", "\n", "disc_opinion_real_local", ",", "\n", "disc_opinion_fake_local", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Loss function for Generator:\n    Args:\n        disc_opinion_fake_local: tf float\n            Local feedback from discriminator on moved templates.\n        disc_opinion_real_local: tf float\n            Local feedback from discriminator on real fixed images.\n    \"\"\"", "\n", "\n", "gan_fake_loss", "=", "loss_object", "(", "\n", "tf", ".", "zeros_like", "(", "disc_opinion_fake_local", ")", ",", "\n", "disc_opinion_fake_local", ",", "\n", ")", "\n", "\n", "gan_real_loss", "=", "loss_object", "(", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.Grad.loss": [[154, 169], ["tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.add_n", "tensorflow.add_n", "tensorflow.add_n", "len", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs", "tensorflow.batch_flatten", "tensorflow.batch_flatten", "tensorflow.batch_flatten", "losses.Grad._diffs", "losses.Grad._diffs"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.Grad._diffs", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.Grad._diffs"], ["tf", ".", "ones_like", "(", "disc_opinion_real_local", ")", ",", "\n", "disc_opinion_real_local", ",", "\n", ")", "\n", "\n", "total_loss", "=", "0.5", "*", "(", "gan_fake_loss", "+", "gan_real_loss", ")", "\n", "\n", "return", "total_loss", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.KL.__init__": [[176, 180], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.KL._adj_filt": [[181, 203], ["numpy.zeros", "range", "numpy.zeros", "range", "numpy.ix_"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.KL._degree_matrix": [[204, 217], ["len", "getattr", "tensorflow.ones", "tensorflow.ones", "tensorflow.ones", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "getattr.", "losses.KL._adj_filt"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.KL._adj_filt"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.KL.prec_loss": [[218, 242], ["len", "range", "y_pred.get_shape().as_list", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.mean", "tensorflow.mean", "tensorflow.mean", "y_pred.get_shape", "range", "range"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.KL.loss": [[243, 273], ["tensorflow.mean", "tensorflow.mean", "tensorflow.mean", "len", "losses.KL._degree_matrix", "losses.KL.prec_loss", "y_pred.get_shape", "tensorflow.exp", "tensorflow.exp", "tensorflow.exp"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.KL._degree_matrix", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.KL.prec_loss"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NMI.__init__": [[277, 300], ["print", "tensorflow.variable", "tensorflow.variable", "tensorflow.variable", "len", "tensorflow.variable", "tensorflow.variable", "tensorflow.variable", "numpy.mean", "numpy.diff", "numpy.square"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NMI.local_mi": [[301, 344], ["tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "pad_dims.append", "pad_dims.append", "pad_dims.append", "pad_dims.append", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.exp", "tensorflow.exp", "tensorflow.exp", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.exp", "tensorflow.exp", "tensorflow.exp", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.batch_dot", "tensorflow.batch_dot", "tensorflow.batch_dot", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.mean", "tensorflow.mean", "tensorflow.mean", "tensorflow.batch_dot", "tensorflow.batch_dot", "tensorflow.batch_dot", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.pad", "tensorflow.pad", "tensorflow.pad", "tensorflow.pad", "tensorflow.pad", "tensorflow.pad", "tensorflow.log", "tensorflow.log", "tensorflow.log", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.epsilon"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NMI.global_mi": [[345, 389], ["tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.exp", "tensorflow.exp", "tensorflow.exp", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.exp", "tensorflow.exp", "tensorflow.exp", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.batch_dot", "tensorflow.batch_dot", "tensorflow.batch_dot", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.ones", "tensorflow.ones", "tensorflow.ones", "tensorflow.nn.conv3d", "tensorflow.nn.conv3d", "tensorflow.nn.conv3d", "tensorflow.boolean_mask", "tensorflow.boolean_mask", "tensorflow.boolean_mask", "tensorflow.boolean_mask", "tensorflow.boolean_mask", "tensorflow.boolean_mask", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "numpy.prod", "tensorflow.batch_dot", "tensorflow.batch_dot", "tensorflow.batch_dot", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "losses.NMI.vol_bin_centers.get_shape().as_list", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.square", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.permute_dimensions", "tensorflow.prod", "tensorflow.prod", "tensorflow.prod", "tensorflow.prod", "tensorflow.prod", "tensorflow.prod", "tensorflow.log", "tensorflow.log", "tensorflow.log", "losses.NMI.vol_bin_centers.get_shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.epsilon"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NMI.loss": [[390, 394], ["tensorflow.clip", "tensorflow.clip", "tensorflow.clip", "tensorflow.clip", "tensorflow.clip", "tensorflow.clip", "losses.NMI.mi"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.LossTuner.__init__": [[401, 404], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.LossTuner.loss": [[405, 407], ["losses.LossTuner.loss_func"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NonSquareNCC.__init__": [[415, 418], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NonSquareNCC.ncc": [[419, 465], ["getattr", "tensorflow.ones", "tensorflow.ones", "tensorflow.ones", "getattr.", "getattr.", "getattr.", "getattr.", "getattr.", "tensorflow.sqrt", "tensorflow.sqrt", "tensorflow.sqrt", "tensorflow.sqrt", "tensorflow.sqrt", "tensorflow.sqrt", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "len", "J.get_shape().as_list", "numpy.prod", "tensorflow.batch_flatten", "tensorflow.batch_flatten", "tensorflow.batch_flatten", "I.get_shape().as_list", "J.get_shape", "I.get_shape"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NonSquareNCC.loss": [[466, 468], ["losses.NonSquareNCC.ncc"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.tf.losses.NonSquareNCC.ncc"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.extract_z_dec": [[25, 69], ["tensorflow.keras.models.Model", "model.get_layer", "tensorflow.keras.layers.Input", "neurite.utils.mod_submodel", "tensorflow.keras.models.Model", "model.get_layer.get_output_at().get_shape().as_list", "tensorflow.keras.utils.plot_model", "IPython.display.Image", "layer.get_weights", "model.get_layer().get_weights", "model.get_layer.get_output_at().get_shape", "tempfile.NamedTemporaryFile", "len", "numpy.all", "model.get_layer", "model.get_layer.get_output_at", "numpy.mean", "enumerate"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.model.mod_submodel"], ["def", "extract_z_dec", "(", "model", ",", "sample_layer_name", ",", "vis", "=", "False", ",", "wt_chk", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    extract the z_decoder [z = p(x)] and return it as a keras model\n\n    Example Layer name:\n    sample_layer_name = 'img-img-dense-vae_ae_dense_sample'\n    \"\"\"", "\n", "\n", "# need to make new model to avoid mu, sigma outputs", "\n", "tmp_model", "=", "keras", ".", "models", ".", "Model", "(", "model", ".", "inputs", ",", "model", ".", "outputs", "[", "0", "]", ")", "\n", "\n", "# get new input", "\n", "sample_layer", "=", "model", ".", "get_layer", "(", "sample_layer_name", ")", "\n", "enc_size", "=", "sample_layer", ".", "get_output_at", "(", "0", ")", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", "\n", "new_z_input", "=", "KL", ".", "Input", "(", "enc_size", ",", "name", "=", "'z_input'", ")", "\n", "\n", "# prepare outputs", "\n", "# assumes z was first input.", "\n", "new_inputs", "=", "[", "new_z_input", ",", "*", "model", ".", "inputs", "[", "1", ":", "]", "]", "\n", "input_layers", "=", "[", "sample_layer_name", ",", "*", "model", ".", "input_layers", "[", "1", ":", "]", "]", "\n", "z_dec_model_outs", "=", "ne", ".", "utils", ".", "mod_submodel", "(", "tmp_model", ",", "\n", "new_input_nodes", "=", "new_inputs", ",", "\n", "input_layers", "=", "input_layers", ")", "\n", "\n", "# get new model", "\n", "z_dec_model", "=", "keras", ".", "models", ".", "Model", "(", "new_inputs", ",", "z_dec_model_outs", ")", "\n", "\n", "if", "vis", ":", "\n", "        ", "outfile", "=", "NamedTemporaryFile", "(", ")", ".", "name", "+", "'.png'", "\n", "plot_model", "(", "z_dec_model", ",", "to_file", "=", "outfile", ",", "show_shapes", "=", "True", ")", "\n", "Image", "(", "outfile", ",", "width", "=", "100", ")", "\n", "\n", "# check model weights:", "\n", "", "if", "wt_chk", ":", "\n", "        ", "for", "layer", "in", "z_dec_model", ".", "layers", ":", "\n", "            ", "wts1", "=", "layer", ".", "get_weights", "(", ")", "\n", "if", "layer", ".", "name", "not", "in", "[", "l", ".", "name", "for", "l", "in", "model", ".", "layers", "]", ":", "\n", "                ", "continue", "\n", "", "wts2", "=", "model", ".", "get_layer", "(", "layer", ".", "name", ")", ".", "get_weights", "(", ")", "\n", "if", "len", "(", "wts1", ")", ">", "0", ":", "\n", "                ", "assert", "np", ".", "all", "(", "[", "np", ".", "mean", "(", "wts1", "[", "i", "]", "-", "wts2", "[", "i", "]", ")", "<", "1e-9", "for", "i", ",", "\n", "_", "in", "enumerate", "(", "wts1", ")", "]", ")", ",", "\"model copy failed\"", "\n", "\n", "", "", "", "return", "z_dec_model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.z_effect": [[71, 107], ["model.get_layer().get_output_at", "tensorflow.keras.backend.gradients", "numpy.mean", "len", "tensorflow.Session", "sess.run", "tqdm.tqdm", "numpy.abs", "matplotlib.figure", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.show", "model.get_layer", "tensorflow.initialize_all_variables", "range", "next", "numpy.vstack", "numpy.sort", "model.get_input_at", "sess.run"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "z_effect", "(", "model", ",", "gen", ",", "z_layer_name", ",", "nb_samples", "=", "100", ",", "do_plot", "=", "False", ",", "tqdm", "=", "tqdm", ")", ":", "\n", "    ", "\"\"\"\n    compute the effect of each z dimension on the final outcome via derivatives\n    we attempt this by taking gradients as in\n    https://stackoverflow.com/questions/39561560/getting-gradient-of-model-output-w-r-t-weights-using-keras\n\n    e.g. layer name: 'img-img-dense-vae_ae_dense_sample'\n    \"\"\"", "\n", "\n", "outputTensor", "=", "model", ".", "outputs", "[", "0", "]", "\n", "inner", "=", "model", ".", "get_layer", "(", "z_layer_name", ")", ".", "get_output_at", "(", "1", ")", "\n", "\n", "# compute gradients", "\n", "gradients", "=", "K", ".", "gradients", "(", "outputTensor", ",", "inner", ")", "\n", "assert", "len", "(", "gradients", ")", "==", "1", ",", "\"wrong gradients\"", "\n", "\n", "# would be nice to be able to do this with K.eval() as opposed to explicit tensorflow sessions.", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "        ", "sess", ".", "run", "(", "tf", ".", "initialize_all_variables", "(", ")", ")", "\n", "\n", "evaluated_gradients", "=", "[", "None", "]", "*", "nb_samples", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "nb_samples", ")", ")", ":", "\n", "            ", "sample", "=", "next", "(", "gen", ")", "\n", "fdct", "=", "{", "model", ".", "get_input_at", "(", "0", ")", ":", "sample", "[", "0", "]", "}", "\n", "evaluated_gradients", "[", "i", "]", "=", "sess", ".", "run", "(", "gradients", ",", "feed_dict", "=", "fdct", ")", "[", "0", "]", "\n", "\n", "", "", "all_gradients", "=", "np", ".", "mean", "(", "np", ".", "abs", "(", "np", ".", "vstack", "(", "evaluated_gradients", ")", ")", ",", "0", ")", "\n", "\n", "if", "do_plot", ":", "\n", "        ", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "plot", "(", "np", ".", "sort", "(", "all_gradients", ")", ")", "\n", "plt", ".", "xlabel", "(", "'sorted z index'", ")", "\n", "plt", ".", "ylabel", "(", "'mean(|grad|)'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "return", "all_gradients", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.sample_dec": [[109, 172], ["[].as_list", "numpy.exp", "enumerate", "numpy.zeros", "numpy.reshape", "numpy.zeros", "numpy.reshape", "numpy.linspace", "numpy.copy", "tqdm.tqdm", "z_dec_model.predict", "numpy.random.normal", "z_dec_model.inputs[].get_shape", "numpy.ones", "range", "len", "numpy.finfo"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "sample_dec", "(", "z_dec_model", ",", "\n", "z_mu", "=", "None", ",", "\n", "z_logvar", "=", "None", ",", "\n", "nb_samples", "=", "5", ",", "\n", "tqdm", "=", "tqdm", ",", "\n", "z_id", "=", "None", ",", "\n", "do_sweep", "=", "False", ",", "\n", "nb_sweep_stds", "=", "3", ",", "\n", "extra_inputs", "=", "[", "]", ",", "\n", "nargout", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    sample from the decoder (i.e. sample z, compute x_mu|z)\n\n    use z_id if you want to vary only a specific z index\n\n    use sweep parameters if you want to sweep around mu from one end to another.\n    \"\"\"", "\n", "\n", "input_shape", "=", "z_dec_model", ".", "inputs", "[", "0", "]", ".", "get_shape", "(", ")", "[", "1", ":", "]", ".", "as_list", "(", ")", "\n", "if", "z_mu", "is", "None", ":", "\n", "        ", "z_mu", "=", "np", ".", "zeros", "(", "[", "1", ",", "*", "input_shape", "]", ")", "\n", "", "else", ":", "\n", "        ", "z_mu", "=", "np", ".", "reshape", "(", "z_mu", ",", "[", "1", ",", "*", "input_shape", "]", ")", "\n", "\n", "", "if", "z_logvar", "is", "None", ":", "\n", "        ", "z_logvar", "=", "np", ".", "zeros", "(", "[", "1", ",", "*", "input_shape", "]", ")", "\n", "", "else", ":", "\n", "        ", "z_logvar", "=", "np", ".", "reshape", "(", "z_logvar", ",", "[", "1", ",", "*", "input_shape", "]", ")", "\n", "\n", "# get standard deviation", "\n", "", "z_std", "=", "np", ".", "exp", "(", "z_logvar", "/", "2", ")", "\n", "\n", "# get samples", "\n", "if", "do_sweep", ":", "\n", "        ", "if", "z_id", "is", "not", "None", ":", "\n", "            ", "low", "=", "z_mu", "\n", "high", "=", "z_mu", "\n", "low", "[", "0", ",", "z_id", "]", "=", "z_mu", "[", "0", ",", "z_id", "]", "-", "nb_sweep_stds", "*", "z_std", "[", "0", ",", "z_id", "]", "\n", "high", "[", "0", ",", "z_id", "]", "=", "z_mu", "[", "0", ",", "z_id", "]", "-", "nb_sweep_stds", "*", "z_std", "[", "0", ",", "z_id", "]", "\n", "", "else", ":", "\n", "            ", "low", "=", "z_mu", "-", "nb_sweep_stds", "*", "z_std", "\n", "high", "=", "z_mu", "-", "nb_sweep_stds", "*", "z_std", "\n", "\n", "", "x_sweep", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "nb_samples", ")", "\n", "z_samples", "=", "[", "x", "*", "high", "+", "(", "1", "-", "x", ")", "*", "low", "for", "x", "in", "x_sweep", "]", "\n", "\n", "", "else", ":", "\n", "        ", "std", "=", "np", ".", "copy", "(", "z_std", ")", "\n", "if", "z_id", "is", "not", "None", ":", "\n", "            ", "std", "=", "np", ".", "ones", "(", "len", "(", "z_std", ")", ")", "*", "np", ".", "finfo", "(", "'float'", ")", ".", "eps", "\n", "std", "[", "0", ",", "z_id", "]", "=", "z_std", "[", "0", ",", "z_id", "]", "\n", "", "z_samples", "=", "[", "np", ".", "random", ".", "normal", "(", "loc", "=", "z_mu", ",", "scale", "=", "z_std", ")", "\n", "for", "_", "in", "range", "(", "nb_samples", ")", "]", "\n", "\n", "# propagate", "\n", "", "outs", "=", "[", "None", "]", "*", "nb_samples", "\n", "for", "zi", ",", "z_sample", "in", "enumerate", "(", "tqdm", "(", "z_samples", ")", ")", ":", "\n", "        ", "outs", "[", "zi", "]", "=", "z_dec_model", ".", "predict", "(", "[", "z_sample", ",", "*", "extra_inputs", "]", ")", "\n", "\n", "", "if", "nargout", "==", "1", ":", "\n", "        ", "return", "outs", "\n", "", "else", ":", "\n", "        ", "return", "(", "outs", ",", "z_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.sweep_dec_given_x": [[174, 220], ["tensorflow.keras.models.Model", "keras.models.Model.predict", "keras.models.Model.predict", "numpy.linspace", "enumerate", "full_model.get_layer().get_output_at", "tqdm.tqdm", "isinstance", "z_dec_model.predict", "z_dec_model.predict", "full_model.get_layer"], "function", ["None"], ["", "", "def", "sweep_dec_given_x", "(", "full_model", ",", "z_dec_model", ",", "sample1", ",", "sample2", ",", "sample_layer_name", ",", "\n", "sweep_z_samples", "=", "False", ",", "\n", "nb_samples", "=", "10", ",", "\n", "nargout", "=", "1", ",", "\n", "tqdm", "=", "tqdm", ")", ":", "\n", "    ", "\"\"\"\n    sweep the latent space given two samples in the original space\n    specificaly, get z_mu = enc(x) for both samples, and sweep between those z_mus\n\n    \"sweep_z_samples\" does a sweep between two samples, rather than between two z_mus.\n\n    Example:\n    sample_layer_name='img-img-dense-vae_ae_dense_sample'\n    \"\"\"", "\n", "\n", "# get a model that also outputs the samples z", "\n", "full_output", "=", "[", "*", "full_model", ".", "outputs", ",", "\n", "full_model", ".", "get_layer", "(", "sample_layer_name", ")", ".", "get_output_at", "(", "1", ")", "]", "\n", "full_model_plus", "=", "keras", ".", "models", ".", "Model", "(", "full_model", ".", "inputs", ",", "full_output", ")", "\n", "\n", "# get full predictions for these samples", "\n", "pred1", "=", "full_model_plus", ".", "predict", "(", "sample1", "[", "0", "]", ")", "\n", "pred2", "=", "full_model_plus", ".", "predict", "(", "sample2", "[", "0", "]", ")", "\n", "img1", "=", "sample1", "[", "0", "]", "\n", "img2", "=", "sample2", "[", "0", "]", "\n", "\n", "# sweep range", "\n", "x_range", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "nb_samples", ")", "\n", "\n", "# prepare outputs", "\n", "outs", "=", "[", "None", "]", "*", "nb_samples", "\n", "for", "xi", ",", "x", "in", "enumerate", "(", "tqdm", "(", "x_range", ")", ")", ":", "\n", "        ", "if", "sweep_z_samples", ":", "\n", "            ", "z", "=", "x", "*", "pred1", "[", "3", "]", "+", "(", "1", "-", "x", ")", "*", "pred2", "[", "3", "]", "\n", "", "else", ":", "\n", "            ", "z", "=", "x", "*", "pred1", "[", "1", "]", "+", "(", "1", "-", "x", ")", "*", "pred2", "[", "1", "]", "\n", "\n", "", "if", "isinstance", "(", "sample1", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "# assuming prior or something like that", "\n", "            ", "outs", "[", "xi", "]", "=", "z_dec_model", ".", "predict", "(", "[", "z", ",", "*", "sample1", "[", "0", "]", "[", "1", ":", "]", "]", ")", "\n", "", "else", ":", "\n", "            ", "outs", "[", "xi", "]", "=", "z_dec_model", ".", "predict", "(", "z", ")", "\n", "\n", "", "", "if", "nargout", "==", "1", ":", "\n", "        ", "return", "outs", "\n", "", "else", ":", "\n", "        ", "return", "(", "outs", ",", "[", "pred1", ",", "pred2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.pca_init_dense": [[222, 299], ["model.get_layer", "model.get_layer", "len", "range", "vae.model_output_pca", "model.get_layer.set_weights", "model.get_layer.set_weights", "model.get_layer.get_output_at().get_shape().as_list", "len", "numpy.maximum", "model.get_layer().set_weights", "model.get_layer.get_input_at", "tensorflow.keras.models.Model", "model.get_layer.get_input_at().get_shape().as_list", "len", "numpy.transpose", "model.get_layer.get_output_at().get_shape", "model.get_layer", "numpy.transpose", "Exception", "model.get_layer.get_input_at().get_shape", "model.get_layer.get_weights", "model.get_layer.get_output_at", "model.get_layer.get_input_at"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.model_output_pca"], ["", "", "def", "pca_init_dense", "(", "model", ",", "mu_dense_layer_name", ",", "undense_layer_name", ",", "generator", ",", "\n", "input_len", "=", "None", ",", "\n", "do_vae", "=", "True", ",", "\n", "logvar_dense_layer_name", "=", "None", ",", "\n", "nb_samples", "=", "None", ",", "\n", "tqdm", "=", "tqdm", ",", "\n", "vis", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    initialize the (V)AE middle *dens*e layer with PCA\n    Warning: this modifies the weights in your model!\n\n    model should take input the same as the normal (V)AE, and output a flat layer before the mu dense layer\n    if nb_samples is None, we will compute at least as many as there are initial dimension (Which might be a lot)\n\n    assumes mu_dense_layer_name is of input size [None, pre_mu_len] and output size [None, enc_len]\n\n    example\n    mu_dense_layer_name = 'img-img-dense-ae_ae_mu_enc_1000'\n    undense_layer_name = 'img-img-dense-ae_ae_dense_dec_flat_1000'\n    \"\"\"", "\n", "\n", "# extract important layer", "\n", "mu_dense_layer", "=", "model", ".", "get_layer", "(", "mu_dense_layer_name", ")", "\n", "mu_undense_layer", "=", "model", ".", "get_layer", "(", "undense_layer_name", ")", "\n", "\n", "# prepare model that outputs the pre_mu flat", "\n", "nb_inbound_nodes", "=", "len", "(", "mu_dense_layer", ".", "_inbound_nodes", ")", "\n", "for", "i", "in", "range", "(", "nb_inbound_nodes", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "out_tensor", "=", "mu_dense_layer", ".", "get_input_at", "(", "i", ")", "\n", "pre_mu_model", "=", "keras", ".", "models", ".", "Model", "(", "model", ".", "inputs", ",", "out_tensor", ")", "\n", "\n", "# save the node index", "\n", "node_idx", "=", "i", "\n", "break", "\n", "\n", "", "except", ":", "\n", "            ", "if", "i", "==", "nb_inbound_nodes", "-", "1", ":", "\n", "                ", "raise", "Exception", "(", "\n", "'Could not initialize pre_mu model. Something went wrong :('", ")", "\n", "\n", "# extract PCA sizes", "\n", "", "", "", "if", "input_len", "is", "None", ":", "\n", "        ", "input_len", "=", "mu_dense_layer", ".", "get_input_at", "(", "\n", "node_idx", ")", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", "\n", "assert", "len", "(", "input_len", ")", "==", "1", ",", "'layer input size is not 0'", "\n", "input_len", "=", "input_len", "[", "0", "]", "\n", "if", "input_len", "is", "None", ":", "\n", "            ", "input_len", "=", "mu_dense_layer", ".", "get_weights", "(", ")", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "", "assert", "input_len", "is", "not", "None", ",", "\"could not figure out input len\"", "\n", "\n", "", "enc_size", "=", "mu_dense_layer", ".", "get_output_at", "(", "node_idx", ")", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", "\n", "assert", "len", "(", "enc_size", ")", "==", "1", ",", "'encoding size is not 0'", "\n", "enc_len", "=", "enc_size", "[", "0", "]", "\n", "\n", "# number of samples", "\n", "if", "nb_samples", "is", "None", ":", "\n", "        ", "nb_samples", "=", "np", ".", "maximum", "(", "enc_len", ",", "input_len", ")", "\n", "\n", "# mu pca", "\n", "", "pca_mu", ",", "x", ",", "y", "=", "model_output_pca", "(", "\n", "pre_mu_model", ",", "generator", ",", "nb_samples", ",", "enc_len", ",", "vis", "=", "vis", ",", "tqdm", "=", "tqdm", ")", "\n", "W_mu", "=", "pca_mu", ".", "components_", "# enc_size * input_len", "\n", "\n", "# fix pca", "\n", "# y = x @ W + y_mean = (x + x_mu) @ W", "\n", "# x = y @ np.transpose(W) - x_mu", "\n", "mu_dense_layer", ".", "set_weights", "(", "[", "np", ".", "transpose", "(", "W_mu", ")", ",", "-", "(", "W_mu", "@", "pca_mu", ".", "mean_", ")", "]", ")", "\n", "mu_undense_layer", ".", "set_weights", "(", "[", "W_mu", ",", "+", "pca_mu", ".", "mean_", "]", ")", "\n", "\n", "# set var components with mu pca as well.", "\n", "if", "do_vae", ":", "\n", "        ", "model", ".", "get_layer", "(", "logvar_dense_layer_name", ")", ".", "set_weights", "(", "\n", "[", "np", ".", "transpose", "(", "W_mu", ")", ",", "-", "x_mu", "]", ")", "\n", "\n", "# return pca data at least for debugging", "\n", "", "return", "(", "pca_mu", ",", "x", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.model_output_pca": [[301, 351], ["next", "vae._sample_batch_size", "sklearn.decomposition.PCA", "sklearn.decomposition.PCA.fit_transform", "pre_mu_model.predict", "tqdm.tqdm", "numpy.vstack", "pre_mu_model.predict", "neurite.plt.pca", "range", "next", "pre_mu_model.predict"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae._sample_batch_size", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.plot.pca", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "model_output_pca", "(", "pre_mu_model", ",", "generator", ",", "nb_samples", ",", "nb_components", ",", "\n", "vis", "=", "False", ",", "\n", "tqdm", "=", "tqdm", ")", ":", "\n", "    ", "\"\"\"\n    compute PCA of model outputs\n    \"\"\"", "\n", "\n", "# go through", "\n", "sample", "=", "next", "(", "generator", ")", "\n", "nb_batch_samples", "=", "_sample_batch_size", "(", "sample", ")", "\n", "if", "nb_batch_samples", "==", "1", ":", "\n", "        ", "zs", "=", "[", "None", "]", "*", "nb_samples", "\n", "zs", "[", "0", "]", "=", "pre_mu_model", ".", "predict", "(", "sample", "[", "0", "]", ")", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "1", ",", "nb_samples", ")", ")", ":", "\n", "            ", "sample", "=", "next", "(", "generator", ")", "\n", "zs", "[", "i", "]", "=", "pre_mu_model", ".", "predict", "(", "sample", "[", "0", "]", ")", "\n", "", "y", "=", "np", ".", "vstack", "(", "zs", ")", "\n", "\n", "", "else", ":", "\n", "        ", "assert", "nb_batch_samples", "==", "nb_samples", ",", "\"generator should either give us 1 sample or %d samples at once. got: %d\"", "%", "(", "nb_samples", ",", "nb_batch_samples", ")", "\n", "y", "=", "pre_mu_model", ".", "predict", "(", "sample", "[", "0", "]", ")", "\n", "\n", "# pca", "\n", "", "pca", "=", "PCA", "(", "n_components", "=", "nb_components", ")", "\n", "x", "=", "pca", ".", "fit_transform", "(", "y", ")", "\n", "\n", "# make sure we can recover", "\n", "if", "vis", ":", "\n", "        ", "ne", ".", "plt", ".", "pca", "(", "pca", ",", "x", ",", "y", ")", "\n", "\n", "", "\"\"\" \n    Test pca model assaignment:\n    # make input, then dense, then dense, then output, and see if input is output for y samples.\n    inp = KL.Input(pca.mean_.shape)\n    den = KL.Dense(x_mu.shape[0])\n    den_o = den(inp)\n    unden = KL.Dense(pca.mean_.shape[0])\n    unden_o = unden(den_o)\n    test_ae = keras.models.Model(inp, [den_o, unden_o])\n\n    den.set_weights([np.transpose(W), - x_mu])\n    unden.set_weights([W, + pca.mean_])\n\n    x_pred, y_pred = test_ae.predict(y)\n    x_pred - x\n    y_pred - y\n    \"\"\"", "\n", "\n", "return", "(", "pca", ",", "x", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.latent_stats": [[353, 378], ["tqdm.tqdm", "numpy.vstack", "numpy.reshape", "numpy.vstack", "numpy.reshape", "range", "next", "model.predict"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "latent_stats", "(", "model", ",", "gen", ",", "nb_reps", "=", "100", ",", "tqdm", "=", "tqdm", ")", ":", "\n", "    ", "\"\"\"\n    Gather several latent_space statistics (mu, var)\n\n    Parameters:\n        gen: generator (will call next() on this a few times)\n        model: model (will predict from generator samples)\n    \"\"\"", "\n", "\n", "mu_data", "=", "[", "None", "]", "*", "nb_reps", "\n", "logvar_data", "=", "[", "None", "]", "*", "nb_reps", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "nb_reps", ")", ")", ":", "\n", "        ", "sample", "=", "next", "(", "gen", ")", "\n", "p", "=", "model", ".", "predict", "(", "sample", "[", "0", "]", ")", "\n", "mu_data", "[", "i", "]", "=", "p", "[", "1", "]", "\n", "logvar_data", "[", "i", "]", "=", "p", "[", "2", "]", "\n", "\n", "", "mu_data", "=", "np", ".", "vstack", "(", "mu_data", ")", "\n", "mu_data", "=", "np", ".", "reshape", "(", "mu_data", ",", "(", "mu_data", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "\n", "logvar_data", "=", "np", ".", "vstack", "(", "logvar_data", ")", "\n", "logvar_data", "=", "np", ".", "reshape", "(", "logvar_data", ",", "(", "logvar_data", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "\n", "data", "=", "{", "'mu'", ":", "mu_data", ",", "'logvar'", ":", "logvar_data", "}", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.latent_stats_plots": [[380, 473], ["vae.latent_stats", "numpy.arange", "print", "print", "numpy.zeros", "tqdm.tqdm", "matplotlib.figure", "matplotlib.subplot", "matplotlib.scatter", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.subplot", "numpy.mean", "numpy.argsort", "matplotlib.scatter", "matplotlib.plot", "matplotlib.plot", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.figure", "matplotlib.subplot", "matplotlib.scatter", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.subplot", "matplotlib.scatter", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.show", "numpy.linspace", "matplotlib.figure", "matplotlib.subplot", "numpy.mean", "numpy.argsort", "matplotlib.scatter", "matplotlib.plot", "matplotlib.plot", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.subplot", "numpy.mean", "matplotlib.scatter", "matplotlib.plot", "matplotlib.plot", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.show", "numpy.linspace", "enumerate", "numpy.random.normal", "numpy.std", "numpy.std", "numpy.std", "numpy.exp"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae.latent_stats", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange"], ["", "def", "latent_stats_plots", "(", "model", ",", "gen", ",", "nb_reps", "=", "100", ",", "dim_1", "=", "0", ",", "dim_2", "=", "1", ",", "figsize", "=", "(", "15", ",", "7", ")", ",", "colors", "=", "None", ",", "tqdm", "=", "tqdm", ")", ":", "\n", "    ", "\"\"\"\n    Make some debug/info (mostly latent-stats-related) plots\n\n    Parameters:\n        gen: generator (will call next() on this a few times)\n        model: model (will predict from generator samples)\n    \"\"\"", "\n", "\n", "data", "=", "latent_stats", "(", "model", ",", "gen", ",", "nb_reps", "=", "nb_reps", ",", "tqdm", "=", "tqdm", ")", "\n", "mu_data", "=", "data", "[", "'mu'", "]", "\n", "logvar_data", "=", "data", "[", "'logvar'", "]", "\n", "\n", "z", "=", "mu_data", ".", "shape", "[", "0", "]", "\n", "if", "colors", "is", "None", ":", "\n", "        ", "colors", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "z", ")", "\n", "", "x", "=", "np", ".", "arange", "(", "mu_data", ".", "shape", "[", "1", "]", ")", "\n", "print", "(", "'VAE plots: colors represent sample index'", ")", "\n", "\n", "\n", "print", "(", "'Sample plots (colors represent sample index)'", ")", "\n", "datapoints", "=", "np", ".", "zeros", "(", "data", "[", "'mu'", "]", ".", "shape", ")", "\n", "for", "di", ",", "mu", "in", "tqdm", "(", "enumerate", "(", "data", "[", "'mu'", "]", ")", ",", "leave", "=", "False", ")", ":", "\n", "        ", "logvar", "=", "data", "[", "'logvar'", "]", "[", "di", ",", "...", "]", "\n", "eps", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "0", ",", "scale", "=", "1", ",", "size", "=", "(", "data", "[", "'mu'", "]", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "datapoints", "[", "di", ",", "...", "]", "=", "mu", "+", "np", ".", "exp", "(", "logvar", "/", "2", ")", "*", "eps", "\n", "", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "1", ")", "\n", "plt", ".", "scatter", "(", "datapoints", "[", ":", ",", "dim_1", "]", ",", "datapoints", "[", ":", ",", "dim_2", "]", ",", "c", "=", "colors", ")", "\n", "plt", ".", "title", "(", "'sample dist. nb_reps=%d. colors = sample idx.'", "%", "nb_reps", ")", "\n", "plt", ".", "xlabel", "(", "'dim %d'", "%", "dim_1", ")", "\n", "plt", ".", "ylabel", "(", "'dim %d'", "%", "dim_2", ")", "\n", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "2", ")", "\n", "d_mean", "=", "np", ".", "mean", "(", "datapoints", ",", "0", ")", "\n", "d_idx", "=", "np", ".", "argsort", "(", "d_mean", ")", "\n", "d_mean_sort", "=", "d_mean", "[", "d_idx", "]", "\n", "d_std_sort", "=", "np", ".", "std", "(", "datapoints", ",", "0", ")", "[", "d_idx", "]", "\n", "plt", ".", "scatter", "(", "x", ",", "d_mean_sort", ",", "c", "=", "colors", "[", "d_idx", "]", ")", "\n", "plt", ".", "plot", "(", "x", ",", "d_mean_sort", "+", "d_std_sort", ",", "'k'", ")", "\n", "plt", ".", "plot", "(", "x", ",", "d_mean_sort", "-", "d_std_sort", ",", "'k'", ")", "\n", "plt", ".", "title", "(", "'mean sample z. nb_reps=%d. colors = sorted dim.'", "%", "nb_reps", ")", "\n", "plt", ".", "xlabel", "(", "'sorted dims'", ")", "\n", "plt", ".", "ylabel", "(", "'mean sample z'", ")", "\n", "\n", "\n", "# plot", "\n", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "1", ")", "\n", "plt", ".", "scatter", "(", "mu_data", "[", ":", ",", "dim_1", "]", ",", "mu_data", "[", ":", ",", "dim_2", "]", ",", "c", "=", "colors", ")", "\n", "plt", ".", "title", "(", "'mu dist. nb_reps=%d. colors = sample idx.'", "%", "nb_reps", ")", "\n", "plt", ".", "xlabel", "(", "'dim %d'", "%", "dim_1", ")", "\n", "plt", ".", "ylabel", "(", "'dim %d'", "%", "dim_2", ")", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "2", ")", "\n", "plt", ".", "scatter", "(", "logvar_data", "[", ":", ",", "dim_1", "]", ",", "logvar_data", "[", ":", ",", "dim_2", "]", ",", "c", "=", "colors", ")", "\n", "plt", ".", "title", "(", "'logvar_data dist. nb_reps=%d. colors = sample idx.'", "%", "nb_reps", ")", "\n", "plt", ".", "xlabel", "(", "'dim %d'", "%", "dim_1", ")", "\n", "plt", ".", "ylabel", "(", "'dim %d'", "%", "dim_2", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "# plot means and variances", "\n", "z", "=", "mu_data", ".", "shape", "[", "1", "]", "\n", "colors", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "z", ")", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "1", ")", "\n", "mu_mean", "=", "np", ".", "mean", "(", "mu_data", ",", "0", ")", "\n", "mu_idx", "=", "np", ".", "argsort", "(", "mu_mean", ")", "\n", "mu_mean_sort", "=", "mu_mean", "[", "mu_idx", "]", "\n", "mu_std_sort", "=", "np", ".", "std", "(", "mu_data", ",", "0", ")", "[", "mu_idx", "]", "\n", "plt", ".", "scatter", "(", "x", ",", "mu_mean_sort", ",", "c", "=", "colors", "[", "mu_idx", "]", ")", "\n", "plt", ".", "plot", "(", "x", ",", "mu_mean_sort", "+", "mu_std_sort", ",", "'k'", ")", "\n", "plt", ".", "plot", "(", "x", ",", "mu_mean_sort", "-", "mu_std_sort", ",", "'k'", ")", "\n", "plt", ".", "title", "(", "'mean mu. nb_reps=%d. colors = sorted dim.'", "%", "nb_reps", ")", "\n", "plt", ".", "xlabel", "(", "'sorted dims'", ")", "\n", "plt", ".", "ylabel", "(", "'mean mu'", ")", "\n", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "2", ")", "\n", "logvar_mean", "=", "np", ".", "mean", "(", "logvar_data", ",", "0", ")", "\n", "logvar_mean_sort", "=", "logvar_mean", "[", "mu_idx", "]", "\n", "logvar_std_sort", "=", "np", ".", "std", "(", "logvar_data", ",", "0", ")", "[", "mu_idx", "]", "\n", "plt", ".", "scatter", "(", "x", ",", "logvar_mean_sort", ",", "c", "=", "colors", "[", "mu_idx", "]", ")", "\n", "plt", ".", "plot", "(", "x", ",", "logvar_mean_sort", "+", "logvar_std_sort", ",", "'k'", ")", "\n", "plt", ".", "plot", "(", "x", ",", "logvar_mean_sort", "-", "logvar_std_sort", ",", "'k'", ")", "\n", "plt", ".", "title", "(", "'mean logvar. nb_reps=%d'", "%", "nb_reps", ")", "\n", "plt", ".", "xlabel", "(", "'sorted dims (diff than mu)'", ")", "\n", "plt", ".", "ylabel", "(", "'mean std'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "\n", "\n", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae._sample_batch_size": [[480, 488], ["isinstance", "vae._sample_batch_size"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.vae._sample_batch_size"], ["", "def", "_sample_batch_size", "(", "sample", ")", ":", "\n", "    ", "\"\"\"\n    get the batch size of a sample, while not knowing how many lists are in the input object.\n    \"\"\"", "\n", "if", "isinstance", "(", "sample", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "return", "_sample_batch_size", "(", "sample", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "sample", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.model.stack_models": [[24, 71], ["range", "tensorflow.keras.models.Model", "len", "list", "list", "enumerate", "model.mod_submodel", "list", "stacked_inputs.append", "range", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.model.mod_submodel", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["def", "stack_models", "(", "models", ",", "connecting_node_ids", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    stacks keras models sequentially without nesting the models into layers\n        (the nominal behaviour in keras as of 1/13/2018 is to nest models)\n    This preserves the layers (i.e. does not copy layers). This means that if you modify the\n    original layer weights, you are automatically affecting the new stacked model.\n\n    Parameters:\n        models: a list of models, in order of: [input_model, second_model, ..., final_output_model]\n        connecting_node_ids (optional): a list of connecting node pointers from Nth model to N+1th model\n\n    Returns:\n        new stacked model pointer\n    \"\"\"", "\n", "\n", "output_tensors", "=", "models", "[", "0", "]", ".", "outputs", "\n", "stacked_inputs", "=", "[", "*", "models", "[", "0", "]", ".", "inputs", "]", "\n", "\n", "# go through models 1 onwards and stack with current graph", "\n", "for", "mi", "in", "range", "(", "1", ",", "len", "(", "models", ")", ")", ":", "\n", "\n", "# prepare input nodes - a combination of ", "\n", "        ", "new_input_nodes", "=", "list", "(", "models", "[", "mi", "]", ".", "inputs", ")", "\n", "stacked_inputs_contrib", "=", "list", "(", "models", "[", "mi", "]", ".", "inputs", ")", "\n", "\n", "if", "connecting_node_ids", "is", "None", ":", "\n", "            ", "conn_id", "=", "list", "(", "range", "(", "len", "(", "new_input_nodes", ")", ")", ")", "\n", "assert", "len", "(", "new_input_nodes", ")", "==", "len", "(", "models", "[", "mi", "-", "1", "]", ".", "outputs", ")", ",", "'argument count does not match'", "\n", "", "else", ":", "\n", "            ", "conn_id", "=", "connecting_node_ids", "[", "mi", "-", "1", "]", "\n", "\n", "", "for", "out_idx", ",", "ii", "in", "enumerate", "(", "conn_id", ")", ":", "\n", "            ", "new_input_nodes", "[", "ii", "]", "=", "output_tensors", "[", "out_idx", "]", "\n", "stacked_inputs_contrib", "[", "ii", "]", "=", "None", "\n", "\n", "", "output_tensors", "=", "mod_submodel", "(", "models", "[", "mi", "]", ",", "new_input_nodes", "=", "new_input_nodes", ")", "\n", "stacked_inputs", "=", "stacked_inputs", "+", "stacked_inputs_contrib", "\n", "\n", "", "stacked_inputs_", "=", "[", "i", "for", "i", "in", "stacked_inputs", "if", "i", "is", "not", "None", "]", "\n", "# check for unique, but keep order:", "\n", "stacked_inputs", "=", "[", "]", "\n", "for", "inp", "in", "stacked_inputs_", ":", "\n", "        ", "if", "inp", "not", "in", "stacked_inputs", ":", "\n", "            ", "stacked_inputs", ".", "append", "(", "inp", ")", "\n", "", "", "new_model", "=", "keras", ".", "models", ".", "Model", "(", "stacked_inputs", ",", "output_tensors", ")", "\n", "return", "new_model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.model.mod_submodel": [[73, 234], ["model.mod_submodel._layer_dependency_dict"], "function", ["None"], ["", "def", "mod_submodel", "(", "orig_model", ",", "\n", "new_input_nodes", "=", "None", ",", "\n", "input_layers", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    modify (cut and/or stitch) keras submodel\n\n    layer objects themselved will be untouched - the new model, even if it includes, \n    say, a subset of the previous layers, those layer objects will be shared with\n    the original model\n\n    given an original model:\n        model stitching: given new input node(s), get output tensors of having pushed these \n        nodes through the model\n        \n        model cutting: given input layer (pointers) inside the model, the new input nodes\n        will match the new input layers, hence allowing cutting the model\n\n    Parameters:\n        orig_model: original keras model pointer\n        new_input_nodes: a pointer to a new input node replacement\n        input_layers: the name of the layer in the original model to replace input nodes\n    \n    Returns:\n        pointer to modified model\n    \"\"\"", "\n", "\n", "def", "_layer_dependency_dict", "(", "orig_model", ")", ":", "\n", "        ", "\"\"\"\n        output: a dictionary of all layers in the orig_model\n        for each layer:\n            dct[layer] is a list of lists of layers.\n        \"\"\"", "\n", "\n", "if", "hasattr", "(", "orig_model", ",", "'output_layers'", ")", ":", "\n", "            ", "out_layers", "=", "orig_model", ".", "output_layers", "\n", "out_node_idx", "=", "orig_model", ".", "output_layers_node_indices", "\n", "node_list", "=", "[", "ol", ".", "_inbound_nodes", "[", "out_node_idx", "[", "i", "]", "]", "for", "i", ",", "ol", "in", "enumerate", "(", "out_layers", ")", "]", "\n", "\n", "", "else", ":", "\n", "            ", "out_layers", "=", "orig_model", ".", "_output_layers", "\n", "\n", "node_list", "=", "[", "]", "\n", "for", "i", ",", "ol", "in", "enumerate", "(", "orig_model", ".", "_output_layers", ")", ":", "\n", "                ", "node_list", "+=", "ol", ".", "_inbound_nodes", "\n", "", "node_list", "=", "list", "(", "set", "(", "node_list", ")", ")", "\n", "\n", "", "dct", "=", "{", "}", "\n", "dct_node_idx", "=", "{", "}", "\n", "while", "len", "(", "node_list", ")", ">", "0", ":", "\n", "            ", "node", "=", "node_list", ".", "pop", "(", "0", ")", "\n", "node_input_layers", "=", "node", ".", "inbound_layers", "\n", "node_indices", "=", "node", ".", "node_indices", "\n", "if", "not", "isinstance", "(", "node_input_layers", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "                ", "node_input_layers", "=", "[", "node_input_layers", "]", "\n", "node_indices", "=", "[", "node_indices", "]", "\n", "\n", "", "add", "=", "True", "\n", "# if not empty. we need to check that we're not adding the same layers through the same node.", "\n", "if", "len", "(", "dct", ".", "setdefault", "(", "node", ".", "outbound_layer", ",", "[", "]", ")", ")", ">", "0", ":", "\n", "                ", "for", "li", ",", "layers", "in", "enumerate", "(", "dct", "[", "node", ".", "outbound_layer", "]", ")", ":", "\n", "                    ", "if", "layers", "==", "node", ".", "inbound_layers", "and", "dct_node_idx", "[", "node", ".", "outbound_layer", "]", "[", "li", "]", "==", "node_indices", ":", "\n", "                        ", "add", "=", "False", "\n", "break", "\n", "", "", "", "if", "add", ":", "\n", "                ", "dct", "[", "node", ".", "outbound_layer", "]", ".", "append", "(", "node_input_layers", ")", "\n", "dct_node_idx", ".", "setdefault", "(", "node", ".", "outbound_layer", ",", "[", "]", ")", ".", "append", "(", "node_indices", ")", "\n", "# append is in place", "\n", "\n", "# add new node", "\n", "\n", "", "for", "li", ",", "layer", "in", "enumerate", "(", "node_input_layers", ")", ":", "\n", "                ", "if", "hasattr", "(", "layer", ",", "'_inbound_nodes'", ")", ":", "\n", "                    ", "node_list", ".", "append", "(", "layer", ".", "_inbound_nodes", "[", "node_indices", "[", "li", "]", "]", ")", "\n", "\n", "", "", "", "return", "dct", "\n", "\n", "", "def", "_get_new_layer_output", "(", "layer", ",", "new_layer_outputs", ",", "inp_layers", ")", ":", "\n", "        ", "\"\"\"\n        (recursive) given a layer, get new outbound_nodes based on new inbound_nodes\n\n        new_layer_outputs is a (reference) dictionary that we will be adding\n        to within the recursion stack.\n        \"\"\"", "\n", "\n", "if", "layer", "not", "in", "new_layer_outputs", ":", "\n", "\n", "            ", "if", "layer", "not", "in", "inp_layers", ":", "\n", "                ", "raise", "Exception", "(", "'layer %s is not in inp_layers'", "%", "layer", ".", "name", ")", "\n", "\n", "# for all input layers to this layer, gather their output (our input)", "\n", "", "for", "group", "in", "inp_layers", "[", "layer", "]", ":", "\n", "                ", "input_nodes", "=", "[", "None", "]", "*", "len", "(", "group", ")", "\n", "for", "li", ",", "inp_layer", "in", "enumerate", "(", "group", ")", ":", "\n", "                    ", "if", "inp_layer", "in", "new_layer_outputs", ":", "\n", "                        ", "input_nodes", "[", "li", "]", "=", "new_layer_outputs", "[", "inp_layer", "]", "\n", "", "else", ":", "# recursive call", "\n", "                        ", "input_nodes", "[", "li", "]", "=", "_get_new_layer_output", "(", "inp_layer", ",", "new_layer_outputs", ",", "inp_layers", ")", "\n", "\n", "# layer call", "\n", "", "", "if", "len", "(", "input_nodes", ")", "==", "1", ":", "\n", "                    ", "new_layer_outputs", "[", "layer", "]", "=", "layer", "(", "*", "input_nodes", ")", "\n", "", "else", ":", "\n", "                    ", "new_layer_outputs", "[", "layer", "]", "=", "layer", "(", "input_nodes", ")", "\n", "\n", "", "", "", "return", "new_layer_outputs", "[", "layer", "]", "\n", "\n", "\n", "\n", "# for each layer create list of input layers", "\n", "", "inp_layers", "=", "_layer_dependency_dict", "(", "orig_model", ")", "\n", "\n", "# get input layers", "\n", "#   These layers will be 'ignored' in that they will not be called!", "\n", "#   instead, the outbound nodes of the layers will be the input nodes", "\n", "#   computed below or passed in", "\n", "if", "input_layers", "is", "None", ":", "# if none provided, search for them", "\n", "# InputLayerClass = keras.engine.topology.InputLayer", "\n", "        ", "InputLayerClass", "=", "type", "(", "tf", ".", "keras", ".", "layers", ".", "InputLayer", "(", ")", ")", "\n", "input_layers", "=", "[", "l", "for", "l", "in", "orig_model", ".", "layers", "if", "isinstance", "(", "l", ",", "InputLayerClass", ")", "]", "\n", "\n", "", "else", ":", "\n", "        ", "if", "not", "isinstance", "(", "input_layers", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "            ", "input_layers", "=", "[", "input_layers", "]", "\n", "", "for", "idx", ",", "input_layer", "in", "enumerate", "(", "input_layers", ")", ":", "\n", "# if it's a string, assume it's layer name, and get the layer pointer", "\n", "            ", "if", "isinstance", "(", "input_layer", ",", "str", ")", ":", "\n", "                ", "input_layers", "[", "idx", "]", "=", "orig_model", ".", "get_layer", "(", "input_layer", ")", "\n", "\n", "# process new input nodes", "\n", "", "", "", "if", "new_input_nodes", "is", "None", ":", "\n", "        ", "input_nodes", "=", "list", "(", "orig_model", ".", "inputs", ")", "\n", "", "else", ":", "\n", "        ", "input_nodes", "=", "new_input_nodes", "\n", "", "assert", "len", "(", "input_nodes", ")", "==", "len", "(", "input_layers", ")", ",", "'input_nodes (%d) and input_layers (%d) have to match'", "%", "(", "len", "(", "input_nodes", ")", ",", "len", "(", "input_layers", ")", ")", "\n", "\n", "# initialize dictionary of layer:new_output_node", "\n", "#   note: the input layers are not called, instead their outbound nodes", "\n", "#   are assumed to be the given input nodes. If we call the nodes, we can run", "\n", "#   into multiple-inbound-nodes problems, or if we completely skip the layers altogether", "\n", "#   we have problems with multiple inbound input layers into subsequent layers", "\n", "new_layer_outputs", "=", "{", "}", "\n", "for", "i", ",", "input_layer", "in", "enumerate", "(", "input_layers", ")", ":", "\n", "        ", "new_layer_outputs", "[", "input_layer", "]", "=", "input_nodes", "[", "i", "]", "\n", "\n", "# recursively go back from output layers and request new input nodes", "\n", "", "output_layers", "=", "[", "]", "\n", "for", "layer", "in", "orig_model", ".", "layers", ":", "\n", "        ", "if", "hasattr", "(", "layer", ",", "'_inbound_nodes'", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "layer", ".", "_inbound_nodes", ")", ")", ":", "\n", "                ", "if", "layer", ".", "get_output_at", "(", "i", ")", "in", "orig_model", ".", "outputs", ":", "\n", "                    ", "output_layers", ".", "append", "(", "layer", ")", "\n", "break", "\n", "", "", "", "", "assert", "len", "(", "output_layers", ")", "==", "len", "(", "orig_model", ".", "outputs", ")", ",", "\"Number of output layers don't match\"", "\n", "\n", "outputs", "=", "[", "None", "]", "*", "len", "(", "output_layers", ")", "\n", "for", "li", ",", "output_layer", "in", "enumerate", "(", "output_layers", ")", ":", "\n", "        ", "outputs", "[", "li", "]", "=", "_get_new_layer_output", "(", "output_layer", ",", "new_layer_outputs", ",", "inp_layers", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.model.reset_weights": [[236, 265], ["tensorflow.get_session", "hasattr", "hasattr", "layer.kernel.initializer.run", "layer.bias.initializer.run", "print"], "function", ["None"], ["", "def", "reset_weights", "(", "model", ",", "session", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    reset weights of model with the appropriate initializer.\n    Note: only uses \"kernel_initializer\" and \"bias_initializer\"\n    does not close session.\n\n    Reference:\n    https://www.codementor.io/nitinsurya/how-to-re-initialize-keras-model-weights-et41zre2g\n\n    Parameters:\n        model: keras model to reset\n        session (optional): the current session\n    \"\"\"", "\n", "\n", "if", "session", "is", "None", ":", "\n", "        ", "session", "=", "K", ".", "get_session", "(", ")", "\n", "\n", "", "for", "layer", "in", "model", ".", "layers", ":", "\n", "        ", "reset", "=", "False", "\n", "if", "hasattr", "(", "layer", ",", "'kernel_initializer'", ")", ":", "\n", "            ", "layer", ".", "kernel", ".", "initializer", ".", "run", "(", "session", "=", "session", ")", "\n", "reset", "=", "True", "\n", "\n", "", "if", "hasattr", "(", "layer", ",", "'bias_initializer'", ")", ":", "\n", "            ", "layer", ".", "bias", ".", "initializer", ".", "run", "(", "session", "=", "session", ")", "\n", "reset", "=", "True", "\n", "\n", "", "if", "not", "reset", ":", "\n", "            ", "print", "(", "'Could not find initializer for layer %s. skipping'", ",", "layer", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.model.copy_weights": [[267, 283], ["tqdm.tqdm_notebook", "src_model.get_layer().get_weights", "layer.set_weights", "print", "src_model.get_layer"], "function", ["None"], ["", "", "", "def", "copy_weights", "(", "src_model", ",", "dst_model", ")", ":", "\n", "    ", "\"\"\"\n    copy weights from the src keras model to the dst keras model via layer names\n\n    Parameters:\n        src_model: source keras model to copy from\n        dst_model: destination keras model to copy to\n    \"\"\"", "\n", "\n", "for", "layer", "in", "tqdm", "(", "dst_model", ".", "layers", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "wts", "=", "src_model", ".", "get_layer", "(", "layer", ".", "name", ")", ".", "get_weights", "(", ")", "\n", "layer", ".", "set_weights", "(", "wts", ")", "\n", "", "except", ":", "\n", "            ", "print", "(", "'Could not copy weights of %s'", "%", "layer", ".", "name", ")", "\n", "continue", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.model.robust_multi_gpu": [[285, 309], ["isinstance", "print", "tensorflow.keras.utils.multi_gpu_model", "print", "len", "len"], "function", ["None"], ["", "", "", "def", "robust_multi_gpu", "(", "model", ",", "gpus", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    re-work keras model for multi-gpus if number of gpus is > 1\n\n    Parameters:\n        model: keras Model\n        gpus: list of gpus to split to (e.g. [1, 4, 6]), or count of gpus available (e.g. 3)\n            Note: if given int, assume that is the count of gpus, \n            so if you want a single specific gpu, this function will not do that.\n        verbose: whether to display what happened (default: True)\n    \n    Returns:\n        keras model\n    \"\"\"", "\n", "\n", "islist", "=", "isinstance", "(", "gpus", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "(", "islist", "and", "len", "(", "gpus", ")", ">", "1", ")", "or", "(", "not", "islist", "and", "gpus", ">", "1", ")", ":", "\n", "        ", "count", "=", "gpus", "if", "not", "islist", "else", "len", "(", "gpus", ")", "\n", "print", "(", "\"Returning multi-gpu (%d) model\"", "%", "count", ")", "\n", "return", "keras", ".", "utils", ".", "multi_gpu_model", "(", "model", ",", "count", ")", "\n", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Returning keras model back (single gpu found)\"", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.model.diagram": [[311, 315], ["tensorflow.keras.utils.plot_model", "IPython.display.Image", "tempfile.NamedTemporaryFile"], "function", ["None"], ["", "", "def", "diagram", "(", "model", ")", ":", "\n", "    ", "outfile", "=", "NamedTemporaryFile", "(", ")", ".", "name", "+", "'.png'", "\n", "tf", ".", "keras", ".", "utils", ".", "plot_model", "(", "model", ",", "to_file", "=", "outfile", ",", "show_shapes", "=", "True", ")", "\n", "Image", "(", "outfile", ",", "width", "=", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.predict_volumes": [[24, 119], ["enumerate", "isinstance", "pytools.Timer", "seg.predict_volume_stack", "len", "seg.pred_to_label", "_quilt().astype", "_quilt().astype", "len", "len", "len", "seg._quilt", "seg.prob_of_label", "seg._quilt", "len", "seg._quilt", "seg._quilt", "seg.pred_to_label", "_quilt().astype", "seg.prob_of_label", "seg._quilt", "seg._quilt"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.predict_volume_stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.pred_to_label", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg._quilt", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.prob_of_label", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg._quilt", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg._quilt", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg._quilt", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.pred_to_label", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.prob_of_label", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg._quilt", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg._quilt"], ["def", "predict_volumes", "(", "models", ",", "\n", "data_generator", ",", "\n", "batch_size", ",", "\n", "patch_size", ",", "\n", "patch_stride", ",", "\n", "grid_size", ",", "\n", "nan_func", "=", "np", ".", "nanmedian", ",", "\n", "do_extra_vol", "=", "False", ",", "# should compute vols beyond label", "\n", "do_prob_of_true", "=", "False", ",", "# should compute prob_of_true vols", "\n", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Note: we allow models to be a list or a single model.\n    Normally, if you'd like to run a function over a list for some param,\n    you can simply loop outside of the function. here, however, we are dealing with a generator,\n    and want the output of that generator to be consistent for each model.\n\n    Returns:\n    if models isa list of more than one model:\n        a tuple of model entried, each entry is a tuple of:\n        true_label, pred_label, <vol>, <prior_label>, <pred_prob_of_true>, <prior_prob_of_true>\n    if models is just one model:\n        a tuple of\n        (true_label, pred_label, <vol>, <prior_label>, <pred_prob_of_true>, <prior_prob_of_true>)\n\n    TODO: could add prior\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "models", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "models", "=", "(", "models", ",", ")", "\n", "\n", "# get the input and prediction stack", "\n", "", "with", "timer", ".", "Timer", "(", "'predict_volume_stack'", ",", "verbose", ")", ":", "\n", "        ", "vol_stack", "=", "predict_volume_stack", "(", "models", ",", "\n", "data_generator", ",", "\n", "batch_size", ",", "\n", "grid_size", ",", "\n", "verbose", ")", "\n", "", "if", "len", "(", "models", ")", "==", "1", ":", "\n", "        ", "do_prior", "=", "len", "(", "vol_stack", ")", "==", "4", "\n", "", "else", ":", "\n", "        ", "do_prior", "=", "len", "(", "vol_stack", "[", "0", "]", ")", "==", "4", "\n", "\n", "# go through models and volumes", "\n", "", "ret", "=", "(", ")", "\n", "for", "midx", ",", "_", "in", "enumerate", "(", "models", ")", ":", "\n", "\n", "        ", "stack", "=", "vol_stack", "if", "len", "(", "models", ")", "==", "1", "else", "vol_stack", "[", "midx", "]", "\n", "\n", "if", "do_prior", ":", "\n", "            ", "all_true", ",", "all_pred", ",", "all_vol", ",", "all_prior", "=", "stack", "\n", "", "else", ":", "\n", "            ", "all_true", ",", "all_pred", ",", "all_vol", "=", "stack", "\n", "\n", "# get max labels", "\n", "", "all_true_label", ",", "all_pred_label", "=", "pred_to_label", "(", "all_true", ",", "all_pred", ")", "\n", "\n", "# quilt volumes and aggregate overlapping patches, if any", "\n", "args", "=", "[", "patch_size", ",", "grid_size", ",", "patch_stride", "]", "\n", "label_kwargs", "=", "{", "'nan_func_layers'", ":", "nan_func", ",", "'nan_func_K'", ":", "nan_func", ",", "'verbose'", ":", "verbose", "}", "\n", "vol_true_label", "=", "_quilt", "(", "all_true_label", ",", "*", "args", ",", "**", "label_kwargs", ")", ".", "astype", "(", "'int'", ")", "\n", "vol_pred_label", "=", "_quilt", "(", "all_pred_label", ",", "*", "args", ",", "**", "label_kwargs", ")", ".", "astype", "(", "'int'", ")", "\n", "\n", "ret_set", "=", "(", "vol_true_label", ",", "vol_pred_label", ")", "\n", "\n", "if", "do_extra_vol", ":", "\n", "            ", "vol_input", "=", "_quilt", "(", "all_vol", ",", "*", "args", ")", "\n", "ret_set", "+=", "(", "vol_input", ",", ")", "\n", "\n", "if", "do_prior", ":", "\n", "                ", "all_prior_label", ",", "=", "pred_to_label", "(", "all_prior", ")", "\n", "vol_prior_label", "=", "_quilt", "(", "all_prior_label", ",", "*", "args", ",", "**", "label_kwargs", ")", ".", "astype", "(", "'int'", ")", "\n", "ret_set", "+=", "(", "vol_prior_label", ",", ")", "\n", "\n", "# compute the probability of prediction and prior", "\n", "# instead of quilting the probabilistic volumes and then computing the probability", "\n", "# of true label, which takes a long time, we'll first compute the probability of label,", "\n", "# and then quilt. This is faster, but we'll need to take median votes", "\n", "", "", "if", "do_extra_vol", "and", "do_prob_of_true", ":", "\n", "            ", "all_pp", "=", "prob_of_label", "(", "all_pred", ",", "all_true_label", ")", "\n", "pred_prob_of_true", "=", "_quilt", "(", "all_pp", ",", "*", "args", ",", "**", "label_kwargs", ")", "\n", "ret_set", "+=", "(", "pred_prob_of_true", ",", ")", "\n", "\n", "if", "do_prior", ":", "\n", "                ", "all_pp", "=", "prob_of_label", "(", "all_prior", ",", "all_true_label", ")", "\n", "prior_prob_of_true", "=", "_quilt", "(", "all_pp", ",", "*", "args", ",", "**", "label_kwargs", ")", "\n", "\n", "ret_set", "+=", "(", "prior_prob_of_true", ",", ")", "\n", "\n", "", "", "ret", "+=", "(", "ret_set", ",", ")", "\n", "\n", "", "if", "len", "(", "models", ")", "==", "1", ":", "\n", "        ", "ret", "=", "ret", "[", "0", "]", "\n", "\n", "# return", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.predict_volume_stack": [[121, 210], ["numpy.prod", "enumerate", "enumerate", "isinstance", "tqdm.tqdm_notebook", "range", "next", "numpy.prod", "isinstance", "enumerate", "numpy.reshape", "numpy.reshape", "len", "range", "model.predict", "numpy.minimum", "numpy.arange", "numpy.reshape", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "tensorflow.batch_flatten", "tensorflow.batch_flatten", "tensorflow._batch_flatten", "tensorflow.batch_flatten"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange"], ["", "def", "predict_volume_stack", "(", "models", ",", "\n", "data_generator", ",", "\n", "batch_size", ",", "\n", "grid_size", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    predict all the patches in a volume\n\n    requires batch_size to be a divisor of the number of patches (prod(grid_size))\n\n    Note: we allow models to be a list or a single model.\n    Normally, if you'd like to run a function over a list for some param,\n    you can simply loop outside of the function. here, however, we are dealing with a generator,\n    and want the output of that generator to be consistent for each model.\n\n    Returns:\n    if models isa list of more than one model:\n        a tuple of model entried, each entry is a tuple of:\n        all_true, all_pred, all_vol, <all_prior>\n    if models is just one model:\n        a tuple of\n        all_true, all_pred, all_vol, <all_prior>\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "models", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "models", "=", "(", "models", ",", ")", "\n", "\n", "# compute the number of batches we need for one volume", "\n", "# we need the batch_size to be a divisor of nb_patches,", "\n", "# in order to loop through batches and form full volumes", "\n", "", "nb_patches", "=", "np", ".", "prod", "(", "grid_size", ")", "\n", "# assert np.mod(nb_patches, batch_size) == 0, \\", "\n", "# \"batch_size %d should be a divisor of nb_patches %d\" %(batch_size, nb_patches)", "\n", "nb_batches", "=", "(", "(", "nb_patches", "-", "1", ")", "//", "batch_size", ")", "+", "1", "\n", "\n", "# go through the patches", "\n", "batch_gen", "=", "tqdm", "(", "range", "(", "nb_batches", ")", ")", "if", "verbose", "else", "range", "(", "nb_batches", ")", "\n", "for", "batch_idx", "in", "batch_gen", ":", "\n", "        ", "sample", "=", "next", "(", "data_generator", ")", "\n", "nb_vox", "=", "np", ".", "prod", "(", "sample", "[", "1", "]", ".", "shape", "[", "1", ":", "-", "1", "]", ")", "\n", "do_prior", "=", "isinstance", "(", "sample", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", "\n", "\n", "# pre-allocate all the data", "\n", "if", "batch_idx", "==", "0", ":", "\n", "            ", "nb_labels", "=", "sample", "[", "1", "]", ".", "shape", "[", "-", "1", "]", "\n", "all_vol", "=", "[", "np", ".", "zeros", "(", "(", "nb_patches", ",", "nb_vox", ")", ")", "for", "f", "in", "models", "]", "\n", "all_true", "=", "[", "np", ".", "zeros", "(", "(", "nb_patches", ",", "nb_vox", "*", "nb_labels", ")", ")", "for", "f", "in", "models", "]", "\n", "all_pred", "=", "[", "np", ".", "zeros", "(", "(", "nb_patches", ",", "nb_vox", "*", "nb_labels", ")", ")", "for", "f", "in", "models", "]", "\n", "all_prior", "=", "[", "np", ".", "zeros", "(", "(", "nb_patches", ",", "nb_vox", "*", "nb_labels", ")", ")", "for", "f", "in", "models", "]", "\n", "\n", "# get in_vol, y_true, y_pred", "\n", "", "for", "idx", ",", "model", "in", "enumerate", "(", "models", ")", ":", "\n", "# with timer.Timer('prediction', verbose):", "\n", "            ", "pred", "=", "model", ".", "predict", "(", "sample", "[", "0", "]", ")", "\n", "assert", "pred", ".", "shape", "[", "0", "]", "==", "batch_size", ",", "\"batch size mismatch. sample has batch size %d, given batch size is %d\"", "%", "(", "pred", ".", "shape", "[", "0", "]", ",", "batch_size", ")", "\n", "input_batch", "=", "sample", "[", "0", "]", "if", "not", "do_prior", "else", "sample", "[", "0", "]", "[", "0", "]", "\n", "\n", "# compute batch range", "\n", "batch_start", "=", "batch_idx", "*", "batch_size", "\n", "batch_end", "=", "np", ".", "minimum", "(", "batch_start", "+", "batch_size", ",", "nb_patches", ")", "\n", "batch_range", "=", "np", ".", "arange", "(", "batch_start", ",", "batch_end", ")", "\n", "batch_vox_idx", "=", "batch_end", "-", "batch_start", "\n", "\n", "# update stacks", "\n", "all_vol", "[", "idx", "]", "[", "batch_range", ",", ":", "]", "=", "K", ".", "batch_flatten", "(", "input_batch", ")", "[", "0", ":", "batch_vox_idx", ",", ":", "]", "\n", "all_true", "[", "idx", "]", "[", "batch_range", ",", ":", "]", "=", "K", ".", "batch_flatten", "(", "sample", "[", "1", "]", ")", "[", "0", ":", "batch_vox_idx", ",", ":", "]", "\n", "all_pred", "[", "idx", "]", "[", "batch_range", ",", ":", "]", "=", "K", ".", "_batch_flatten", "(", "pred", ")", "[", "0", ":", "batch_vox_idx", ",", ":", "]", "\n", "if", "do_prior", ":", "\n", "                ", "all_prior", "[", "idx", "]", "[", "batch_range", ",", ":", "]", "=", "K", ".", "batch_flatten", "(", "sample", "[", "0", "]", "[", "1", "]", ")", "[", "0", ":", "batch_vox_idx", ",", ":", "]", "\n", "\n", "# reshape probabilistic answers", "\n", "", "", "", "for", "idx", ",", "_", "in", "enumerate", "(", "models", ")", ":", "\n", "        ", "all_true", "[", "idx", "]", "=", "np", ".", "reshape", "(", "all_true", "[", "idx", "]", ",", "[", "nb_patches", ",", "nb_vox", ",", "nb_labels", "]", ")", "\n", "all_pred", "[", "idx", "]", "=", "np", ".", "reshape", "(", "all_pred", "[", "idx", "]", ",", "[", "nb_patches", ",", "nb_vox", ",", "nb_labels", "]", ")", "\n", "if", "do_prior", ":", "\n", "            ", "all_prior", "[", "idx", "]", "=", "np", ".", "reshape", "(", "all_prior", "[", "idx", "]", ",", "[", "nb_patches", ",", "nb_vox", ",", "nb_labels", "]", ")", "\n", "\n", "# prepare output tuple", "\n", "", "", "ret", "=", "(", ")", "\n", "for", "midx", ",", "_", "in", "enumerate", "(", "models", ")", ":", "\n", "        ", "if", "do_prior", ":", "\n", "            ", "ret", "+=", "(", "(", "all_true", "[", "midx", "]", ",", "all_pred", "[", "midx", "]", ",", "all_vol", "[", "midx", "]", ",", "all_prior", "[", "midx", "]", ")", ",", ")", "\n", "", "else", ":", "\n", "            ", "ret", "+=", "(", "(", "all_true", "[", "midx", "]", ",", "all_pred", "[", "midx", "]", ",", "all_vol", "[", "midx", "]", ")", ",", ")", "\n", "\n", "", "", "if", "len", "(", "models", ")", "==", "1", ":", "\n", "        ", "ret", "=", "ret", "[", "0", "]", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.prob_of_label": [[212, 242], ["numpy.ndim", "numpy.prod", "numpy.reshape", "np.reshape.sum", "list", "numpy.reshape", "numpy.ndim", "range", "numpy.ndim"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "prob_of_label", "(", "vol", ",", "labelvol", ")", ":", "\n", "    ", "\"\"\"\n    compute the probability of the labels in labelvol in each of the volumes in vols\n\n    Parameters:\n        vol (float numpy array of dim (nd + 1): volume with a prob dist at each voxel in a nd vols\n        labelvol (int numpy array of dim nd): nd volume of labels\n\n    Returns:\n        nd volume of probabilities\n    \"\"\"", "\n", "\n", "# check dimensions", "\n", "nb_dims", "=", "np", ".", "ndim", "(", "labelvol", ")", "\n", "assert", "np", ".", "ndim", "(", "vol", ")", "==", "nb_dims", "+", "1", ",", "\"vol dimensions do not match [%d] vs [%d]\"", "%", "(", "np", ".", "ndim", "(", "vol", ")", "-", "1", ",", "nb_dims", ")", "\n", "shp", "=", "vol", ".", "shape", "\n", "nb_voxels", "=", "np", ".", "prod", "(", "shp", "[", "0", ":", "nb_dims", "]", ")", "\n", "nb_labels", "=", "shp", "[", "-", "1", "]", "\n", "\n", "# reshape volume to be [nb_voxels, nb_labels]", "\n", "flat_vol", "=", "np", ".", "reshape", "(", "vol", ",", "(", "nb_voxels", ",", "nb_labels", ")", ")", "\n", "\n", "# normalize accross second dimension", "\n", "rows_sums", "=", "flat_vol", ".", "sum", "(", "axis", "=", "1", ")", "\n", "flat_vol_norm", "=", "flat_vol", "/", "rows_sums", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "# index into the flattened volume", "\n", "idx", "=", "list", "(", "range", "(", "nb_voxels", ")", ")", "\n", "v", "=", "flat_vol_norm", "[", "idx", ",", "labelvol", ".", "flat", "]", "\n", "return", "np", ".", "reshape", "(", "v", ",", "labelvol", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.next_pred_label": [[244, 255], ["next", "seg.pred_to_label", "pytools.Timer", "model.predict", "isinstance"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.pred_to_label"], ["", "def", "next_pred_label", "(", "model", ",", "data_generator", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    predict the next sample batch from the generator, and compute max labels\n    return sample, prediction, max_labels\n    \"\"\"", "\n", "sample", "=", "next", "(", "data_generator", ")", "\n", "with", "timer", ".", "Timer", "(", "'prediction'", ",", "verbose", ")", ":", "\n", "        ", "pred", "=", "model", ".", "predict", "(", "sample", "[", "0", "]", ")", "\n", "", "sample_input", "=", "sample", "[", "0", "]", "if", "not", "isinstance", "(", "sample", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", "else", "sample", "[", "0", "]", "[", "0", "]", "\n", "max_labels", "=", "pred_to_label", "(", "sample_input", ",", "pred", ")", "\n", "return", "(", "sample", ",", "pred", ")", "+", "max_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.next_label": [[257, 264], ["seg.next_pred_label"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.next_pred_label"], ["", "def", "next_label", "(", "model", ",", "data_generator", ")", ":", "\n", "    ", "\"\"\"\n    predict the next sample batch from the generator, and compute max labels\n    return max_labels\n    \"\"\"", "\n", "batch_proc", "=", "next_pred_label", "(", "model", ",", "data_generator", ")", "\n", "return", "(", "batch_proc", "[", "2", "]", ",", "batch_proc", "[", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.sample_to_label": [[266, 275], ["model.predict", "seg.pred_to_label"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.pred_to_label"], ["", "def", "sample_to_label", "(", "model", ",", "sample", ")", ":", "\n", "    ", "\"\"\"\n    redict a sample batch and compute max labels\n    return max_labels\n    \"\"\"", "\n", "# predict output for a new sample", "\n", "res", "=", "model", ".", "predict", "(", "sample", "[", "0", "]", ")", "\n", "# return", "\n", "return", "pred_to_label", "(", "sample", "[", "1", "]", ",", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.pred_to_label": [[277, 283], ["tuple", "numpy.argmax().astype", "numpy.argmax"], "function", ["None"], ["", "def", "pred_to_label", "(", "*", "y", ")", ":", "\n", "    ", "\"\"\"\n    return the true and predicted labels given true and predicted nD+1 volumes\n    \"\"\"", "\n", "# compute resulting volume(s)", "\n", "return", "tuple", "(", "np", ".", "argmax", "(", "f", ",", "-", "1", ")", ".", "astype", "(", "int", ")", "for", "f", "in", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg.next_vol_pred": [[285, 301], ["next", "isinstance", "pytools.Timer", "model.predict"], "function", ["None"], ["", "def", "next_vol_pred", "(", "model", ",", "data_generator", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    get the next batch, predict model output\n\n    returns (input_vol, y_true, y_pred, <prior>)\n    \"\"\"", "\n", "\n", "# batch to input, output and prediction", "\n", "sample", "=", "next", "(", "data_generator", ")", "\n", "with", "timer", ".", "Timer", "(", "'prediction'", ",", "verbose", ")", ":", "\n", "        ", "pred", "=", "model", ".", "predict", "(", "sample", "[", "0", "]", ")", "\n", "", "data", "=", "(", "sample", "[", "0", "]", ",", "sample", "[", "1", "]", ",", "pred", ")", "\n", "if", "isinstance", "(", "sample", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "# if given prior, might be a list", "\n", "        ", "data", "=", "(", "sample", "[", "0", "]", "[", "0", "]", ",", "sample", "[", "1", "]", ",", "pred", ",", "sample", "[", "0", "]", "[", "1", "]", ")", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.seg._quilt": [[307, 319], ["numpy.reshape", "pytools.quilt", "len", "pprint.pformat", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.quilt"], ["", "def", "_quilt", "(", "patches", ",", "patch_size", ",", "grid_size", ",", "patch_stride", ",", "verbose", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "assert", "len", "(", "patches", ".", "shape", ")", ">=", "2", ",", "\"patches has bad shape %s\"", "%", "pformat", "(", "patches", ".", "shape", ")", "\n", "\n", "# reshape to be [nb_patches x nb_vox]", "\n", "patches", "=", "np", ".", "reshape", "(", "patches", ",", "(", "patches", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "1", ")", ")", "\n", "\n", "# quilt", "\n", "quilted_vol", "=", "pl", ".", "quilt", "(", "patches", ",", "patch_size", ",", "grid_size", ",", "patch_stride", "=", "patch_stride", ",", "**", "kwargs", ")", "\n", "assert", "quilted_vol", ".", "ndim", "==", "len", "(", "patch_size", ")", ",", "\"problem with dimensions after quilt\"", "\n", "\n", "# return", "\n", "return", "quilted_vol", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.interpn": [[35, 163], ["isinstance", "isinstance", "tensorflow.stack", "len", "Exception", "len", "Exception", "len", "tensorflow.expand_dims", "tensorflow.cast", "K.expand_dims.shape.as_list", "tensorflow.floor", "list", "tensorflow.cast", "utils.sub2ind2d", "tensorflow.gather", "tensorflow.constant", "tensorflow.reduce_any", "tensorflow.cast", "K.expand_dims.get_shape().as_list", "tensorflow.clip_by_value", "tensorflow.clip_by_value", "tensorflow.clip_by_value", "itertools.product", "utils.sub2ind2d", "tensorflow.gather", "utils.prod_n", "tensorflow.expand_dims", "tensorflow.round", "tensorflow.clip_by_value", "tensorflow.reshape", "tensorflow.less", "tensorflow.greater", "tensorflow.stack", "tensorflow.logical_not", "tensorflow.cast", "range", "range", "range", "tensorflow.cast", "tensorflow.cast", "range", "tensorflow.reshape", "range", "range", "range", "len", "len", "K.expand_dims.get_shape", "range", "range"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.sub2ind2d", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.sub2ind2d", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.prod_n", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.resize": [[165, 194], ["isinstance", "neurite.utils.ndgrid", "neurite.utils.interpn", "len", "len", "isinstance", "vol_shape.as_list.as_list", "int", "tensorflow.linspace", "len", "range", "range", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ndgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.interpn", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.tf_map_fn_axis": [[203, 258], ["isinstance", "enumerate", "tensorflow.map_fn", "enumerate", "len", "elems_perm.append", "len", "elems_trf.append", "isinstance", "x.get_shape().as_list", "list", "tensorflow.permute_dimensions", "x.get_shape().as_list", "list", "tensorflow.permute_dimensions", "list", "range", "list", "range", "x.get_shape", "range", "x.get_shape", "range"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.volshape_to_ndgrid": [[260, 281], ["utils.ndgrid", "float().is_integer", "all", "ValueError", "tensorflow.range", "float"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ndgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.volshape_to_meshgrid": [[283, 307], ["utils.meshgrid", "float().is_integer", "all", "ValueError", "tensorflow.range", "float"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.ndgrid": [[309, 323], ["utils.meshgrid"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid": [[325, 404], ["kwargs.pop", "kwargs.pop", "len", "enumerate", "range", "TypeError", "ValueError", "output.append", "tensorflow.size", "tensorflow.reshape", "tensorflow.reshape", "len", "tensorflow.tile", "list", "tensorflow.reshape", "x.get_shape().as_list", "tensorflow.stack", "kwargs.keys", "tensorflow.stack", "x.get_shape"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten": [[406, 418], ["tensorflow.reshape"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.softmax": [[424, 448], ["tensorflow.ndim", "tensorflow.softmax", "tensorflow.exp", "tensorflow.sum", "ValueError", "tensorflow.max"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.softmax"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logtanh": [[450, 457], ["tensorflow.tanh", "tensorflow.log", "abs"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.arcsinh": [[459, 466], ["tensorflow.asinh"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logistic": [[468, 476], ["tensorflow.exp"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.sigmoid": [[478, 480], ["utils.logistic"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logistic"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logistic_fixed_ends": [[482, 506], ["tensorflow.clip_by_value", "utils.logistic", "utils.logistic", "utils.logistic"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logistic", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logistic", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logistic"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.sigmoid_fixed_ends": [[508, 510], ["utils.logistic_fixed_ends"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logistic_fixed_ends"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.soft_round": [[512, 516], ["tensorflow.floor", "utils.logistic_fixed_ends"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logistic_fixed_ends"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.soft_delta": [[518, 530], ["tensorflow.abs", "tensorflow.square", "utils.logistic"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.logistic"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.odd_shifted_relu": [[532, 541], ["float", "float", "tensorflow.relu", "tensorflow.relu"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.perlin_vol": [[547, 613], ["range", "tensorflow.cast", "tensorflow.zeros", "enumerate", "numpy.max", "numpy.ceil().astype", "scale_shapes.append", "tensorflow.stack", "tensorflow.sum", "tensorflow.random_uniform", "numpy.ceil().astype", "tf.cast.append", "tf.cast.append", "zoom", "numpy.ceil", "range", "numpy.log2", "numpy.ceil", "tensorflow.random_uniform", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.gaussian_kernel": [[615, 666], ["len", "utils.volshape_to_meshgrid", "tensorflow.stack", "tensorflow.sum", "tensorflow.exp", "tensorflow.reduce_sum", "isinstance", "numpy.maximum", "len", "len", "ValueError", "tensorflow.cast", "range", "range", "numpy.log", "range", "numpy.finfo", "str", "len", "tensorflow.square", "numpy.round", "numpy.sqrt", "str"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.volshape_to_meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.sub2ind2d": [[668, 683], ["numpy.cumprod", "enumerate", "len", "len", "len", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.prod_n": [[685, 693], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.batch_gather": [[699, 731], ["tensorflow.stack", "tensorflow.gather_nd", "tensorflow.shape", "tensorflow.range"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.segutils.seg2contour": [[10, 54], ["numpy.unique", "numpy.delete", "ndutils.bw2contour", "numpy.where"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.bw2contour"], ["def", "seg2contour", "(", "seg", ",", "exclude_zero", "=", "True", ",", "contour_type", "=", "'inner'", ",", "thickness", "=", "1", ")", ":", "\n", "    ", "'''\n    transform nd segmentation (label maps) to contour maps\n\n    Parameters\n    ----------\n    seg : nd array\n        volume of labels/segmentations\n    exclude_zero : optional logical\n        whether to exclude the zero label.\n        default True\n    contour_type : string\n        where to draw contour voxels relative to label 'inner','outer', or 'both'\n\n    Output\n    ------\n    con : nd array\n        nd array (volume) of contour maps\n\n    See Also\n    --------\n    seg_overlap\n    '''", "\n", "\n", "# extract unique labels", "\n", "labels", "=", "np", ".", "unique", "(", "seg", ")", "\n", "if", "exclude_zero", ":", "\n", "        ", "labels", "=", "np", ".", "delete", "(", "labels", ",", "np", ".", "where", "(", "labels", "==", "0", ")", ")", "\n", "\n", "# get the contour of each label", "\n", "", "contour_map", "=", "seg", "*", "0", "\n", "for", "lab", "in", "labels", ":", "\n", "\n", "# extract binary label map for this label", "\n", "        ", "label_map", "=", "seg", "==", "lab", "\n", "\n", "# extract contour map for this label", "\n", "thickness", "=", "thickness", "+", "0.01", "\n", "label_contour_map", "=", "nd", ".", "bw2contour", "(", "label_map", ",", "type", "=", "contour_type", ",", "thr", "=", "thickness", ")", "\n", "\n", "# assign contour to this label", "\n", "contour_map", "[", "label_contour_map", "]", "=", "lab", "\n", "\n", "", "return", "contour_map", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.segutils.seg_overlap": [[57, 92], ["segutils.seg2contour", "range", "numpy.reshape", "isinstance", "numpy.max().astype", "numpy.random.random", "numpy.max"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.segutils.seg2contour", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "seg_overlap", "(", "vol", ",", "seg", ",", "do_contour", "=", "True", ",", "do_rgb", "=", "True", ",", "cmap", "=", "None", ",", "thickness", "=", "1.0", ")", ":", "\n", "    ", "'''\n    overlap a nd volume and nd segmentation (label map)\n\n    do_contour should be None, boolean, or contour_type from seg2contour\n\n    not well tested yet.\n    '''", "\n", "\n", "# compute contours for each label if necessary", "\n", "if", "do_contour", "is", "not", "None", "and", "do_contour", "is", "not", "False", ":", "\n", "        ", "if", "not", "isinstance", "(", "do_contour", ",", "str", ")", ":", "\n", "            ", "do_contour", "=", "'inner'", "\n", "", "seg", "=", "seg2contour", "(", "seg", ",", "contour_type", "=", "do_contour", ",", "thickness", "=", "thickness", ")", "\n", "\n", "# compute a rgb-contour map", "\n", "", "if", "do_rgb", ":", "\n", "        ", "if", "cmap", "is", "None", ":", "\n", "            ", "nb_labels", "=", "np", ".", "max", "(", "seg", ")", ".", "astype", "(", "int", ")", "+", "1", "\n", "colors", "=", "np", ".", "random", ".", "random", "(", "(", "nb_labels", ",", "3", ")", ")", "*", "0.5", "+", "0.5", "\n", "colors", "[", "0", ",", ":", "]", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "colors", "=", "cmap", "[", ":", ",", "0", ":", "3", "]", "\n", "\n", "", "olap", "=", "colors", "[", "seg", ".", "flat", ",", ":", "]", "\n", "sf", "=", "seg", ".", "flat", "==", "0", "\n", "for", "d", "in", "range", "(", "3", ")", ":", "\n", "            ", "olap", "[", "sf", ",", "d", "]", "=", "vol", ".", "flat", "[", "sf", "]", "\n", "", "olap", "=", "np", ".", "reshape", "(", "olap", ",", "vol", ".", "shape", "+", "(", "3", ",", ")", ")", "\n", "\n", "", "else", ":", "\n", "        ", "olap", "=", "seg", "\n", "olap", "[", "seg", "==", "0", "]", "=", "vol", "[", "seg", "==", "0", "]", "\n", "\n", "", "return", "olap", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.segutils.seg_overlay": [[94, 122], ["numpy.reshape", "numpy.max", "numpy.expand_dims", "numpy.random.random"], "function", ["None"], ["", "def", "seg_overlay", "(", "vol", ",", "seg", ",", "do_rgb", "=", "True", ",", "seg_wt", "=", "0.5", ",", "cmap", "=", "None", ")", ":", "\n", "    ", "'''\n    overlap a nd volume and nd segmentation (label map)\n\n    not well tested yet.\n    '''", "\n", "\n", "# compute contours for each label if necessary", "\n", "\n", "# compute a rgb-contour map", "\n", "if", "do_rgb", ":", "\n", "        ", "if", "cmap", "is", "None", ":", "\n", "            ", "nb_labels", "=", "np", ".", "max", "(", "seg", ")", "+", "1", "\n", "colors", "=", "np", ".", "random", ".", "random", "(", "(", "nb_labels", ",", "3", ")", ")", "*", "0.5", "+", "0.5", "\n", "colors", "[", "0", ",", ":", "]", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "colors", "=", "cmap", "[", ":", ",", "0", ":", "3", "]", "\n", "\n", "", "seg_flat", "=", "colors", "[", "seg", ".", "flat", ",", ":", "]", "\n", "seg_rgb", "=", "np", ".", "reshape", "(", "seg_flat", ",", "vol", ".", "shape", "+", "(", "3", ",", ")", ")", "\n", "\n", "# get the overlap image", "\n", "olap", "=", "seg_rgb", "*", "seg_wt", "+", "np", ".", "expand_dims", "(", "vol", ",", "-", "1", ")", "*", "(", "1", "-", "seg_wt", ")", "\n", "\n", "", "else", ":", "\n", "        ", "olap", "=", "seg", "*", "seg_wt", "+", "vol", "*", "(", "1", "-", "seg_wt", ")", "\n", "\n", "", "return", "olap", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.boundingbox": [[15, 41], ["numpy.where", "numpy.concatenate", "numpy.min", "numpy.max"], "function", ["None"], ["def", "boundingbox", "(", "bwvol", ")", ":", "\n", "    ", "\"\"\"\n    bounding box coordinates of a nd volume\n\n    Parameters\n    ----------\n    vol : nd array\n        the binary (black/white) array for which to compute the boundingbox\n\n    Returns\n    -------\n    boundingbox : 1-by-(nd*2) array\n        [xstart ystart ... xend yend ...]\n    \"\"\"", "\n", "\n", "# find indices where bwvol is True", "\n", "idx", "=", "np", ".", "where", "(", "bwvol", ")", "\n", "\n", "# get the starts", "\n", "starts", "=", "[", "np", ".", "min", "(", "x", ")", "for", "x", "in", "idx", "]", "\n", "\n", "# get the ends", "\n", "ends", "=", "[", "np", ".", "max", "(", "x", ")", "for", "x", "in", "idx", "]", "\n", "\n", "# concatinate [starts, ends]", "\n", "return", "np", ".", "concatenate", "(", "(", "starts", ",", "ends", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.bwdist": [[44, 68], ["numpy.logical_not", "scipy.ndimage.morphology.distance_transform_edt", "scipy.ndimage.morphology.distance_transform_edt"], "function", ["None"], ["", "def", "bwdist", "(", "bwvol", ")", ":", "\n", "    ", "\"\"\"\n    positive distance transform from positive entries in logical image\n\n    Parameters\n    ----------\n    bwvol : nd array\n        The logical volume\n\n    Returns\n    -------\n    possdtrf : nd array\n        the positive distance transform\n\n    See Also\n    --------\n    bw2sdtrf\n    \"\"\"", "\n", "\n", "# reverse volume to run scipy function", "\n", "revbwvol", "=", "np", ".", "logical_not", "(", "bwvol", ")", "\n", "\n", "# get distance", "\n", "return", "scipy", ".", "ndimage", ".", "morphology", ".", "distance_transform_edt", "(", "revbwvol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.bw2sdtrf": [[71, 106], ["ndutils.bwdist", "numpy.logical_not", "ndutils.bwdist"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.bwdist", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.bwdist"], ["", "def", "bw2sdtrf", "(", "bwvol", ")", ":", "\n", "    ", "\"\"\"\n    computes the signed distance transform from the surface between the\n    binary True/False elements of logical bwvol\n\n    Note: the distance transform on either side of the surface will be +1/-1\n    - i.e. there are no voxels for which the dst should be 0.\n\n    Runtime: currently the function uses bwdist twice. If there is a quick way to\n    compute the surface, bwdist could be used only once.\n\n    Parameters\n    ----------\n    bwvol : nd array\n        The logical volume\n\n    Returns\n    -------\n    sdtrf : nd array\n        the signed distance transform\n\n    See Also\n    --------\n    bwdist\n    \"\"\"", "\n", "\n", "# get the positive transform (outside the positive island)", "\n", "posdst", "=", "bwdist", "(", "bwvol", ")", "\n", "\n", "# get the negative transform (distance inside the island)", "\n", "notbwvol", "=", "np", ".", "logical_not", "(", "bwvol", ")", "\n", "negdst", "=", "bwdist", "(", "notbwvol", ")", "\n", "\n", "# combine the positive and negative map", "\n", "return", "posdst", "*", "notbwvol", "-", "negdst", "*", "bwvol", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.bw_convex_hull": [[108, 114], ["ndutils.volsize2ndgrid", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.volsize2ndgrid"], ["", "def", "bw_convex_hull", "(", "bwvol", ")", ":", "\n", "# transform bw to mesh.", "\n", "    ", "grid", "=", "volsize2ndgrid", "(", "bwvol", ".", "shape", ")", "\n", "# get the 1 points", "\n", "q", "=", "np", ".", "concatenate", "(", "[", "grid", "[", "d", "]", ".", "flat", "for", "d", "in", "bwvol", ".", "ndims", "]", ",", "1", ")", "\n", "return", "q", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.bw2contour": [[115, 148], ["ndutils.bw2sdtrf", "numpy.logical_and", "numpy.logical_and", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.bw2sdtrf"], ["", "def", "bw2contour", "(", "bwvol", ",", "type", "=", "'both'", ",", "thr", "=", "1.01", ")", ":", "\n", "    ", "\"\"\"\n    computes the contour of island(s) on a nd logical volume\n\n    Parameters\n    ----------\n    bwvol : nd array\n        The logical volume\n    type : optional string\n        since the contour is drawn on voxels, it can be drawn on the inside\n        of the island ('inner'), outside of the island ('outer'), or both\n        ('both' - default)\n\n    Returns\n    -------\n    contour : nd array\n        the contour map of the same size of the input\n\n    See Also\n    --------\n    bwdist, bw2dstrf\n    \"\"\"", "\n", "\n", "# obtain a signed distance transform for the bw volume", "\n", "sdtrf", "=", "bw2sdtrf", "(", "bwvol", ")", "\n", "\n", "if", "type", "==", "'inner'", ":", "\n", "        ", "return", "np", ".", "logical_and", "(", "sdtrf", "<=", "0", ",", "sdtrf", ">", "-", "thr", ")", "\n", "", "elif", "type", "==", "'outer'", ":", "\n", "        ", "return", "np", ".", "logical_and", "(", "sdtrf", ">=", "0", ",", "sdtrf", "<", "thr", ")", "\n", "", "else", ":", "\n", "        ", "assert", "type", "==", "'both'", ",", "'type should only be inner, outer or both'", "\n", "return", "np", ".", "abs", "(", "sdtrf", ")", "<", "thr", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ndgrid": [[150, 161], ["numpy.meshgrid"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid"], ["", "", "def", "ndgrid", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Disclaimer: This code is taken directly from the scitools package [1]\n    Since at the time of writing scitools predominantly requires python 2.7 while we work with 3.5+\n    To avoid issues, we copy the quick code here.\n\n    Same as calling ``meshgrid`` with *indexing* = ``'ij'`` (see\n    ``meshgrid`` for documentation).\n    \"\"\"", "\n", "kwargs", "[", "'indexing'", "]", "=", "'ij'", "\n", "return", "np", ".", "meshgrid", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.volsize2ndgrid": [[163, 170], ["ndutils.ndgrid", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ndgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange"], ["", "def", "volsize2ndgrid", "(", "volsize", ")", ":", "\n", "    ", "\"\"\"\n    return the dense nd-grid for the volume with size volsize\n    essentially return the ndgrid fpr\n    \"\"\"", "\n", "ranges", "=", "[", "np", ".", "arange", "(", "e", ")", "for", "e", "in", "volsize", "]", "\n", "return", "ndgrid", "(", "*", "ranges", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.bw_sphere": [[172, 191], ["ndutils.volsize2ndgrid", "numpy.sqrt", "len", "len", "numpy.square", "numpy.sum", "len", "len", "ndutils.range", "len", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.volsize2ndgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "bw_sphere", "(", "volshape", ",", "rad", ",", "loc", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    compute a logical (black/white) image of a sphere\n    \"\"\"", "\n", "\n", "# if the location is not given, use the center of the volume.", "\n", "if", "loc", "is", "None", ":", "\n", "        ", "loc", "=", "1.0", "*", "(", "np", ".", "array", "(", "volshape", ")", "-", "1", ")", "/", "2", "\n", "", "assert", "len", "(", "loc", ")", "==", "len", "(", "volshape", ")", ",", "'Location (%d) and volume dimensions (%d) do not match'", "%", "(", "len", "(", "loc", ")", ",", "len", "(", "volshape", ")", ")", "\n", "\n", "\n", "# compute distances between each location in the volume and ``loc``", "\n", "volgrid", "=", "volsize2ndgrid", "(", "volshape", ")", "\n", "dst", "=", "[", "np", ".", "square", "(", "loc", "[", "d", "]", "-", "volgrid", "[", "d", "]", ")", "for", "d", "in", "range", "(", "len", "(", "volshape", ")", ")", "]", "\n", "dst", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "dst", ",", "0", ")", ")", "\n", "\n", "# draw the sphere", "\n", "return", "dst", "<=", "rad", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.volcrop": [[193, 275], ["numpy.asarray", "ndutils.range", "numpy.ix_", "isinstance", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "volcrop", "(", "vol", ",", "new_vol_size", "=", "None", ",", "start", "=", "None", ",", "end", "=", "None", ",", "crop", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    crop a nd volume.\n\n    Parameters\n    ----------\n    vol : nd array\n        the nd-dimentional volume to crop. If only specified parameters, is returned intact\n    new_vol_size : nd vector, optional\n        the new size of the cropped volume\n    crop : nd tuple, optional\n        either tuple of integers or tuple of tuples.\n        If tuple of integers, will crop that amount from both sides.\n        if tuple of tuples, expect each inner tuple to specify (crop from start, crop from end)\n    start : int, optional\n        start of cropped volume\n    end : int, optional\n        end of cropped volume\n\n    Returns\n    ------\n    cropped_vol : nd array\n    \"\"\"", "\n", "\n", "vol_size", "=", "np", ".", "asarray", "(", "vol", ".", "shape", ")", "\n", "\n", "# check which parameters are passed", "\n", "passed_new_vol_size", "=", "new_vol_size", "is", "not", "None", "\n", "passed_start", "=", "start", "is", "not", "None", "\n", "passed_end", "=", "end", "is", "not", "None", "\n", "passed_crop", "=", "crop", "is", "not", "None", "\n", "\n", "# from whatever is passed, we want to obtain start and end.", "\n", "if", "passed_start", "and", "passed_end", ":", "\n", "        ", "assert", "not", "(", "passed_new_vol_size", "or", "passed_crop", ")", ",", "\"If passing start and end, don't pass anything else\"", "\n", "\n", "", "elif", "passed_new_vol_size", ":", "\n", "# compute new volume size and crop_size", "\n", "        ", "assert", "not", "passed_crop", ",", "\"Cannot use both new volume size and crop info\"", "\n", "\n", "# compute start and end", "\n", "if", "passed_start", ":", "\n", "            ", "assert", "not", "passed_end", ",", "\"When giving passed_new_vol_size, cannot pass both start and end\"", "\n", "end", "=", "start", "+", "new_vol_size", "\n", "\n", "", "elif", "passed_end", ":", "\n", "            ", "assert", "not", "passed_start", ",", "\"When giving passed_new_vol_size, cannot pass both start and end\"", "\n", "start", "=", "end", "-", "new_vol_size", "\n", "\n", "", "else", ":", "# none of crop_size, crop, start or end are passed", "\n", "            ", "mid", "=", "np", ".", "asarray", "(", "vol_size", ")", "//", "2", "\n", "start", "=", "mid", "-", "(", "new_vol_size", "//", "2", ")", "\n", "end", "=", "start", "+", "new_vol_size", "\n", "\n", "", "", "elif", "passed_crop", ":", "\n", "        ", "assert", "not", "(", "passed_start", "or", "passed_end", "or", "new_vol_size", ")", ",", "\"Cannot pass both passed_crop and start or end or new_vol_size\"", "\n", "\n", "if", "isinstance", "(", "crop", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "end", "=", "vol_size", "-", "[", "val", "[", "1", "]", "for", "val", "in", "crop", "]", "\n", "start", "=", "[", "val", "[", "0", "]", "for", "val", "in", "crop", "]", "\n", "", "else", ":", "\n", "            ", "end", "=", "vol_size", "-", "crop", "\n", "start", "=", "crop", "\n", "\n", "", "", "elif", "passed_start", ":", "# nothing else is passed", "\n", "        ", "end", "=", "vol_size", "\n", "\n", "", "else", ":", "\n", "        ", "assert", "passed_end", "\n", "start", "=", "vol_size", "*", "0", "\n", "\n", "# get indices. Since we want this to be an nd-volume crop function, we", "\n", "# idx = []", "\n", "# for i in range(len(end)):", "\n", "#     idx.append(slice(start[i], end[i]))", "\n", "", "idx", "=", "range", "(", "start", ",", "end", ")", "\n", "\n", "return", "vol", "[", "np", ".", "ix_", "(", "*", "idx", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice": [[277, 296], ["ndutils._prep_range", "isinstance", "builtins.slice", "ndutils.slice", "ndutils.range", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils._prep_range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "slice", "(", "*", "args", ")", ":", "\n", "    ", "\"\"\"\n    slice([start], end [,step])\n    nd version of slice, where each arg can be a vector of the same length\n\n    Parameters:\n        [start] (vector): the start\n\n    \"\"\"", "\n", "\n", "# if passed in scalars call the built-in range", "\n", "if", "not", "isinstance", "(", "args", "[", "0", "]", ",", "(", "list", ",", "tuple", ",", "np", ".", "ndarray", ")", ")", ":", "\n", "        ", "return", "builtins", ".", "slice", "(", "*", "args", ")", "\n", "\n", "", "start", ",", "end", ",", "step", "=", "_prep_range", "(", "*", "args", ")", "\n", "\n", "# prepare", "\n", "idx", "=", "[", "slice", "(", "start", "[", "i", "]", ",", "end", "[", "i", "]", ",", "step", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "end", ")", ")", "]", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range": [[297, 316], ["ndutils._prep_range", "isinstance", "numpy.arange", "ndutils.range", "ndutils.range", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils._prep_range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "range", "(", "*", "args", ")", ":", "\n", "    ", "\"\"\"\n    range([start], end [,step])\n    nd version of range, where each arg can be a vector of the same length\n\n    Parameters:\n        [start] (vector): the start\n\n    \"\"\"", "\n", "\n", "# if passed in scalars call the built-in range", "\n", "if", "not", "isinstance", "(", "args", "[", "0", "]", ",", "(", "list", ",", "tuple", ",", "np", ".", "ndarray", ")", ")", ":", "\n", "        ", "return", "np", ".", "arange", "(", "*", "args", ")", "\n", "\n", "", "start", ",", "end", ",", "step", "=", "_prep_range", "(", "*", "args", ")", "\n", "\n", "# prepare", "\n", "idx", "=", "[", "range", "(", "start", "[", "i", "]", ",", "end", "[", "i", "]", ",", "step", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "end", ")", ")", "]", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange": [[318, 337], ["ndutils._prep_range", "isinstance", "builtins.range", "numpy.arange", "ndutils.range", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils._prep_range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "arange", "(", "*", "args", ")", ":", "\n", "    ", "\"\"\"\n    aange([start], end [,step])\n    nd version of arange, where each arg can be a vector of the same length\n\n    Parameters:\n        [start] (vector): the start\n\n    \"\"\"", "\n", "\n", "# if passed in scalars call the built-in range", "\n", "if", "not", "isinstance", "(", "args", "[", "0", "]", ",", "(", "list", ",", "tuple", ",", "np", ".", "ndarray", ")", ")", ":", "\n", "        ", "return", "builtins", ".", "range", "(", "*", "args", ")", "\n", "\n", "", "start", ",", "end", ",", "step", "=", "_prep_range", "(", "*", "args", ")", "\n", "\n", "# prepare", "\n", "idx", "=", "[", "np", ".", "arange", "(", "start", "[", "i", "]", ",", "end", "[", "i", "]", ",", "step", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "end", ")", ")", "]", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.axissplit": [[340, 361], ["numpy.split"], "function", ["None"], ["", "def", "axissplit", "(", "arr", ",", "axis", ")", ":", "\n", "    ", "\"\"\"\n    Split a nd volume along an exis into n volumes, where n is the size of the axis dim.\n\n    Parameters\n    ----------\n    arr : nd array\n        array to split\n    axis : integer\n        indicating axis to split\n\n    Output\n    ------\n    outarr : 1-by-n array\n        where n is the size of the axis dim in original volume.\n        each entry is a sub-volume of the original volume\n\n    See also numpy.split()\n    \"\"\"", "\n", "nba", "=", "arr", ".", "shape", "[", "axis", "]", "\n", "return", "np", ".", "split", "(", "arr", ",", "nba", ",", "axis", "=", "axis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.sub2ind": [[365, 372], ["numpy.ravel_multi_index"], "function", ["None"], ["", "def", "sub2ind", "(", "arr", ",", "size", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    similar to MATLAB's sub2ind\n\n    Note default order is C-style, not F-style (Fortran/MATLAB)\n    \"\"\"", "\n", "return", "np", ".", "ravel_multi_index", "(", "arr", ",", "size", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ind2sub": [[374, 381], ["numpy.unravel_index"], "function", ["None"], ["", "def", "ind2sub", "(", "indices", ",", "size", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    similar to MATLAB's ind2sub\n\n    Note default order is C-style, not F-style (Fortran/MATLAB)\n    \"\"\"", "\n", "return", "np", ".", "unravel_index", "(", "indices", ",", "size", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.centroid": [[383, 390], ["ndutils.volsize2ndgrid", "numpy.array", "numpy.array", "ndutils.range", "numpy.sum", "numpy.sum", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.volsize2ndgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["", "def", "centroid", "(", "im", ")", ":", "\n", "    ", "\"\"\"\n    compute centroid of a probability ndimage in 0/1\n    \"\"\"", "\n", "volgrid", "=", "volsize2ndgrid", "(", "im", ".", "shape", ")", "\n", "prob", "=", "[", "np", ".", "array", "(", "im", ")", "*", "np", ".", "array", "(", "volgrid", "[", "d", "]", ")", "for", "d", "in", "range", "(", "len", "(", "im", ".", "shape", ")", ")", "]", "\n", "return", "[", "np", ".", "sum", "(", "p", ".", "flat", ")", "/", "np", ".", "sum", "(", "im", ".", "shape", ")", "for", "p", "in", "prob", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ind2sub_entries": [[393, 406], ["ndutils.ind2sub", "numpy.vstack().transpose", "numpy.array().flatten", "numpy.vstack", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.ind2sub", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten"], ["", "def", "ind2sub_entries", "(", "indices", ",", "size", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    returns a nb_entries -by- nb_dims (essentially the transpose of ind2sub)\n\n    somewhat similar to MATLAB's ind2subvec\n    https://github.com/adalca/mgt/blob/master/src/ind2subvec.m\n\n    Note default order is C-style, not F-style (Fortran/MATLAB)\n    \"\"\"", "\n", "sub", "=", "ind2sub", "(", "np", ".", "array", "(", "indices", ")", ".", "flatten", "(", ")", ",", "size", ",", "**", "kwargs", ")", "\n", "subvec", "=", "np", ".", "vstack", "(", "sub", ")", ".", "transpose", "(", ")", "\n", "# Warning this might be F-style-like stacking... it's a bit confusing", "\n", "return", "subvec", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils._prep_range": [[411, 437], ["numpy.ones", "len", "len", "numpy.zeros", "len", "len", "len", "len", "len", "ValueError", "len", "len", "len", "len"], "function", ["None"], ["", "def", "_prep_range", "(", "*", "args", ")", ":", "\n", "    ", "\"\"\"\n    _prep_range([start], end [,step])\n    prepare the start, end and step for range and arange\n\n    Parameters:\n        [start] (vector): the start\n\n    \"\"\"", "\n", "\n", "# prepare the start, step and end", "\n", "step", "=", "np", ".", "ones", "(", "len", "(", "args", "[", "0", "]", ")", ",", "'int'", ")", "\n", "if", "len", "(", "args", ")", "==", "1", ":", "\n", "        ", "end", "=", "args", "[", "0", "]", "\n", "start", "=", "np", ".", "zeros", "(", "len", "(", "end", ")", ",", "'int'", ")", "\n", "", "elif", "len", "(", "args", ")", "==", "2", ":", "\n", "        ", "assert", "len", "(", "args", "[", "0", "]", ")", "==", "len", "(", "args", "[", "1", "]", ")", ",", "\"argument vectors do not match\"", "\n", "start", ",", "end", "=", "args", "\n", "", "elif", "len", "(", "args", ")", "==", "3", ":", "\n", "        ", "assert", "len", "(", "args", "[", "0", "]", ")", "==", "len", "(", "args", "[", "1", "]", ")", ",", "\"argument vectors do not match\"", "\n", "assert", "len", "(", "args", "[", "0", "]", ")", "==", "len", "(", "args", "[", "2", "]", ")", ",", "\"argument vectors do not match\"", "\n", "start", ",", "end", ",", "step", "=", "args", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'unknown arguments'", ")", "\n", "\n", "", "return", "(", "start", ",", "end", ",", "step", ")", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.imutils.gray2color": [[5, 12], ["numpy.np.concatenate"], "function", ["None"], ["def", "gray2color", "(", "gray", ",", "color", ")", ":", "\n", "    ", "''' \n    transform a gray image (2d array) to a color image given the color (1x3 vector) \n    untested\n    '''", "\n", "\n", "return", "np", ".", "concatenate", "(", "(", "gray", "*", "c", "for", "c", "in", "color", ")", ",", "2", ")", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.volgen": [[9, 57], ["isinstance", "os.path.isdir", "glob.glob", "numpy.random.randint", "dict", "os.path.join", "len", "py.utils.load_volfile", "numpy.concatenate", "vols.append", "tuple", "py.utils.load_volfile", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile"], ["import", "numpy", "as", "np", "\n", "import", "nibabel", "as", "nib", "\n", "import", "scipy", "\n", "from", "tensorflow", ".", "python", ".", "keras", ".", "utils", "import", "np_utils", "\n", "from", "tensorflow", ".", "keras", ".", "models", "import", "Model", "\n", "\n", "# local packages", "\n", "import", "pynd", ".", "ndutils", "as", "nd", "\n", "import", "pytools", ".", "patchlib", "as", "pl", "\n", "import", "pytools", ".", "timer", "as", "timer", "\n", "\n", "\n", "# other neuron (this project) packages", "\n", "from", "neurite", "import", "dataproc", "as", "nrn_proc", "\n", "\n", "\n", "class", "Vol", "(", "object", ")", ":", "\n", "\n", "    ", "def", "__init__", "(", "self", ",", "\n", "volpath", ",", "\n", "ext", "=", "'.npz'", ",", "\n", "nb_restart_cycle", "=", "None", ",", "# number of files to restart after", "\n", "name", "=", "'single_vol'", ",", "# name", "\n", "fixed_vol_size", "=", "True", ",", "# assumes each volume is fixed size", "\n", ")", ":", "\n", "\n", "# get filenames at given paths", "\n", "        ", "volfiles", "=", "_get_file_list", "(", "volpath", ",", "ext", ",", "vol_rand_seed", ")", "\n", "nb_files", "=", "len", "(", "volfiles", ")", "\n", "assert", "nb_files", ">", "0", ",", "\"Could not find any files at %s with extension %s\"", "%", "(", "volpath", ",", "ext", ")", "\n", "\n", "# set up restart cycle for volume files --", "\n", "# i.e. after how many volumes do we restart", "\n", "if", "nb_restart_cycle", "is", "None", ":", "\n", "            ", "nb_restart_cycle", "=", "nb_files", "\n", "\n", "# compute subvolume split", "\n", "", "vol_data", "=", "_load_medical_volume", "(", "os", ".", "path", ".", "join", "(", "volpath", ",", "volfiles", "[", "0", "]", ")", ",", "ext", ")", "\n", "# process volume", "\n", "if", "data_proc_fn", "is", "not", "None", ":", "\n", "            ", "vol_data", "=", "data_proc_fn", "(", "vol_data", ")", "\n", "[", "f", "for", "f", "in", "_npz_headers", "(", "npz", ",", "namelist", "=", "[", "'vol_data.npy'", "]", ")", "]", "[", "0", "]", "[", "1", "]", "\n", "\n", "", "nb_patches_per_vol", "=", "1", "\n", "if", "fixed_vol_size", "and", "(", "patch_size", "is", "not", "None", ")", "and", "all", "(", "f", "is", "not", "None", "for", "f", "in", "patch_size", ")", ":", "\n", "            ", "nb_patches_per_vol", "=", "np", ".", "prod", "(", "pl", ".", "gridsize", "(", "vol_data", ".", "shape", ",", "patch_size", ",", "patch_stride", ")", ")", "\n", "\n", "", "assert", "nb_restart_cycle", "<=", "(", "nb_files", "*", "nb_patches_per_vol", ")", ",", "'%s restart cycle (%s) too big (%s) in %s'", "%"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.scan_to_scan": [[59, 95], ["generators.volgen", "next", "next", "numpy.zeros", "outvols.append", "numpy.random.rand", "numpy.random.rand", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.volgen"], ["\n", "\n", "", "", "def", "vol", "(", "volpath", ",", "\n", "ext", "=", "'.npz'", ",", "\n", "batch_size", "=", "1", ",", "\n", "expected_nb_files", "=", "-", "1", ",", "\n", "expected_files", "=", "None", ",", "\n", "data_proc_fn", "=", "None", ",", "# processing function that takes in one arg (the volume)", "\n", "relabel", "=", "None", ",", "# relabeling array", "\n", "nb_labels_reshape", "=", "0", ",", "# reshape to categorial format for keras, need # labels", "\n", "keep_vol_size", "=", "False", ",", "# whether to keep the volume size on categorical resizing", "\n", "name", "=", "'single_vol'", ",", "# name, optional", "\n", "nb_restart_cycle", "=", "None", ",", "# number of files to restart after", "\n", "patch_size", "=", "None", ",", "# split the volume in patches? if so, get patch_size", "\n", "patch_stride", "=", "1", ",", "# split the volume in patches? if so, get patch_stride", "\n", "collapse_2d", "=", "None", ",", "\n", "extract_slice", "=", "None", ",", "\n", "force_binary", "=", "False", ",", "\n", "nb_feats", "=", "1", ",", "\n", "patch_rand", "=", "False", ",", "\n", "patch_rand_seed", "=", "None", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "binary", "=", "False", ",", "\n", "yield_incomplete_final_batch", "=", "True", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    generator for single volume (or volume patches) from a list of files\n\n    simple volume generator that loads a volume (via npy/mgz/nii/niigz), processes it,\n    and prepares it for keras model formats\n\n    if a patch size is passed, breaks the volume into patches and generates those\n    \"\"\"", "\n", "\n", "# get filenames at given paths", "\n", "volfiles", "=", "_get_file_list", "(", "volpath", ",", "ext", ",", "vol_rand_seed", ")", "\n", "nb_files", "=", "len", "(", "volfiles", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.scan_to_atlas": [[97, 123], ["numpy.zeros", "numpy.repeat", "generators.volgen", "len", "next", "outvols.append"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.volgen"], ["\n", "# compute subvolume split", "\n", "vol_data", "=", "_load_medical_volume", "(", "os", ".", "path", ".", "join", "(", "volpath", ",", "volfiles", "[", "0", "]", ")", ",", "ext", ")", "\n", "\n", "# process volume", "\n", "if", "data_proc_fn", "is", "not", "None", ":", "\n", "        ", "vol_data", "=", "data_proc_fn", "(", "vol_data", ")", "\n", "\n", "", "nb_patches_per_vol", "=", "1", "\n", "if", "patch_size", "is", "not", "None", "and", "all", "(", "f", "is", "not", "None", "for", "f", "in", "patch_size", ")", ":", "\n", "        ", "if", "relabel", "is", "None", "and", "len", "(", "patch_size", ")", "==", "(", "len", "(", "vol_data", ".", "shape", ")", "-", "1", ")", ":", "\n", "            ", "tmp_patch_size", "=", "[", "f", "for", "f", "in", "patch_size", "]", "\n", "patch_size", "=", "[", "*", "patch_size", ",", "vol_data", ".", "shape", "[", "-", "1", "]", "]", "\n", "patch_stride", "=", "[", "f", "for", "f", "in", "patch_stride", "]", "\n", "patch_stride", "=", "[", "*", "patch_stride", ",", "vol_data", ".", "shape", "[", "-", "1", "]", "]", "\n", "", "assert", "len", "(", "vol_data", ".", "shape", ")", "==", "len", "(", "patch_size", ")", ",", "\"Vol dims %d are  not equal to patch dims %d\"", "%", "(", "len", "(", "vol_data", ".", "shape", ")", ",", "len", "(", "patch_size", ")", ")", "\n", "nb_patches_per_vol", "=", "np", ".", "prod", "(", "pl", ".", "gridsize", "(", "vol_data", ".", "shape", ",", "patch_size", ",", "patch_stride", ")", ")", "\n", "", "if", "nb_restart_cycle", "is", "None", ":", "\n", "        ", "print", "(", "\"setting restart cycle to\"", ",", "nb_files", ")", "\n", "nb_restart_cycle", "=", "nb_files", "\n", "\n", "", "assert", "nb_restart_cycle", "<=", "(", "nb_files", "*", "nb_patches_per_vol", ")", ",", "'%s restart cycle (%s) too big (%s) in %s'", "%", "(", "name", ",", "nb_restart_cycle", ",", "nb_files", "*", "nb_patches_per_vol", ",", "volpath", ")", "\n", "\n", "# check the number of files matches expected (if passed)", "\n", "if", "expected_nb_files", ">=", "0", ":", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.semisupervised": [[125, 172], ["generators.volgen", "numpy.zeros", "enumerate", "py.utils.load_volfile", "py.utils.load_volfile", "generators.semisupervised.split_seg"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.volgen", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile"], ["\"number of files do not match: %d, %d\"", "%", "(", "nb_files", ",", "expected_nb_files", ")", "\n", "", "if", "expected_files", "is", "not", "None", ":", "\n", "        ", "if", "not", "(", "volfiles", "==", "expected_files", ")", ":", "\n", "            ", "print", "(", "'file lists did not match. You should probably stop execution.'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "len", "(", "volfiles", ")", ",", "len", "(", "expected_files", ")", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'nb_restart_cycle:'", ",", "nb_restart_cycle", ")", "\n", "\n", "# iterate through files", "\n", "", "fileidx", "=", "-", "1", "\n", "batch_idx", "=", "-", "1", "\n", "feat_idx", "=", "0", "\n", "batch_shape", "=", "None", "\n", "while", "1", ":", "\n", "        ", "fileidx", "=", "np", ".", "mod", "(", "fileidx", "+", "1", ",", "nb_restart_cycle", ")", "\n", "if", "verbose", "and", "fileidx", "==", "0", ":", "\n", "            ", "print", "(", "'starting %s cycle'", "%", "name", ")", "\n", "\n", "# read next file (circular)", "\n", "\n", "", "try", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "'opening %s'", "%", "os", ".", "path", ".", "join", "(", "volpath", ",", "volfiles", "[", "fileidx", "]", ")", ")", "\n", "", "file_name", "=", "os", ".", "path", ".", "join", "(", "volpath", ",", "volfiles", "[", "fileidx", "]", ")", "\n", "vol_data", "=", "_load_medical_volume", "(", "file_name", ",", "ext", ",", "verbose", ")", "\n", "# print(file_name, \" was loaded\", vol_data.shape)", "\n", "", "except", ":", "\n", "            ", "debug_error_msg", "=", "\"#files: %d, fileidx: %d, nb_restart_cycle: %d. error: %s\"", "\n", "print", "(", "debug_error_msg", "%", "(", "len", "(", "volfiles", ")", ",", "fileidx", ",", "nb_restart_cycle", ",", "sys", ".", "exc_info", "(", ")", "[", "0", "]", ")", ")", "\n", "raise", "\n", "\n", "# process volume", "\n", "", "if", "data_proc_fn", "is", "not", "None", ":", "\n", "            ", "vol_data", "=", "data_proc_fn", "(", "vol_data", ")", "\n", "\n", "# the original segmentation files have non-sequential relabel (i.e. some relabel are", "\n", "# missing to avoid exploding our model, we only care about the relabel that exist.", "\n", "", "if", "relabel", "is", "not", "None", ":", "\n", "            ", "vol_data", "=", "_relabel", "(", "vol_data", ",", "relabel", ")", "\n", "\n", "# split volume into patches if necessary and yield", "\n", "", "if", "patch_size", "is", "None", ":", "\n", "            ", "this_patch_size", "=", "vol_data", ".", "shape", "\n", "patch_stride", "=", "[", "1", "for", "f", "in", "this_patch_size", "]", "\n", "\n", "", "else", ":", "\n", "            ", "this_patch_size", "=", "[", "f", "for", "f", "in", "patch_size", "]", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.template_creation": [[174, 194], ["numpy.zeros", "numpy.repeat", "generators.volgen", "len", "next"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.volgen"], ["                ", "if", "p", "is", "None", ":", "\n", "                    ", "this_patch_size", "[", "pi", "]", "=", "vol_data", ".", "shape", "[", "pi", "]", "\n", "patch_stride", "[", "pi", "]", "=", "1", "\n", "\n", "", "", "", "assert", "~", "np", ".", "any", "(", "np", ".", "isnan", "(", "vol_data", ")", ")", ",", "\"Found a nan for %s\"", "%", "volfiles", "[", "fileidx", "]", "\n", "assert", "np", ".", "all", "(", "np", ".", "isfinite", "(", "vol_data", ")", ")", ",", "\"Found a inf for %s\"", "%", "volfiles", "[", "fileidx", "]", "\n", "\n", "patch_gen", "=", "patch", "(", "vol_data", ",", "this_patch_size", ",", "\n", "patch_stride", "=", "patch_stride", ",", "\n", "nb_labels_reshape", "=", "nb_labels_reshape", ",", "\n", "batch_size", "=", "1", ",", "\n", "infinite", "=", "False", ",", "\n", "collapse_2d", "=", "collapse_2d", ",", "\n", "patch_rand", "=", "patch_rand", ",", "\n", "patch_rand_seed", "=", "patch_rand_seed", ",", "\n", "keep_vol_size", "=", "keep_vol_size", ")", "\n", "\n", "empty_gen", "=", "True", "\n", "patch_idx", "=", "-", "1", "\n", "for", "lpatch", "in", "patch_gen", ":", "\n", "            ", "empty_gen", "=", "False", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.conditional_template_creation": [[196, 226], ["numpy.zeros", "numpy.repeat", "numpy.random.randint", "numpy.stack", "dict", "numpy.concatenate", "len", "len", "py.utils.load_volfile"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile"], ["\n", "# add to feature", "\n", "if", "np", ".", "mod", "(", "feat_idx", ",", "nb_feats", ")", "==", "0", ":", "\n", "                ", "vol_data_feats", "=", "lpatch", "\n", "\n", "", "else", ":", "\n", "                ", "vol_data_feats", "=", "np", ".", "concatenate", "(", "[", "vol_data_feats", ",", "lpatch", "]", ",", "np", ".", "ndim", "(", "lpatch", ")", "-", "1", ")", "\n", "", "feat_idx", "+=", "1", "\n", "\n", "if", "binary", ":", "\n", "                ", "vol_data_feats", "=", "vol_data_feats", ".", "astype", "(", "bool", ")", "\n", "\n", "", "if", "np", ".", "mod", "(", "feat_idx", ",", "nb_feats", ")", "==", "0", ":", "\n", "                ", "feats_shape", "=", "vol_data_feats", "[", "1", ":", "]", "\n", "\n", "# yield previous batch if the new volume has different patch sizes", "\n", "if", "batch_shape", "is", "not", "None", "and", "(", "feats_shape", "!=", "batch_shape", ")", ":", "\n", "                    ", "batch_idx", "=", "-", "1", "\n", "batch_shape", "=", "None", "\n", "print", "(", "'switching patch sizes'", ")", "\n", "yield", "np", ".", "vstack", "(", "vol_data_batch", ")", "\n", "\n", "# add to batch of volume data, unless the batch is currently empty", "\n", "", "if", "batch_idx", "==", "-", "1", ":", "\n", "                    ", "vol_data_batch", "=", "[", "vol_data_feats", "]", "\n", "batch_shape", "=", "vol_data_feats", "[", "1", ":", "]", "\n", "", "else", ":", "\n", "                    ", "vol_data_batch", "=", "[", "*", "vol_data_batch", ",", "vol_data_feats", "]", "\n", "\n", "# yield patch", "\n", "", "batch_idx", "+=", "1", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.surf_semisupervised": [[228, 380], ["numpy.repeat", "numpy.repeat", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "numpy.zeros", "generators.volgen", "int", "py.utils.filter_labels", "len", "py.utils.sdt_to_surface_pts", "len", "len", "len", "py.utils.clean_seg", "py.utils.vol_to_sdt", "numpy.sum", "numpy.sum", "len", "py.utils.get_surface_pts_per_label", "enumerate", "next", "py.utils.filter_labels", "range", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "numpy.sort", "len", "slice", "numpy.repeat", "len", "len", "numpy.sort", "py.utils.get_surface_pts_per_label", "len", "numpy.zeros", "slice", "py.utils.clean_seg_batch", "numpy.unique", "numpy.abs", "len", "std_to_surf", "int", "int", "numpy.random.choice", "int", "int", "len", "numpy.repeat", "py.utils.vol_to_sdt_batch", "numpy.repeat", "numpy.stack", "len", "numpy.sum", "numpy.sum", "range", "len", "numpy.sum", "numpy.sum", "std_to_surf", "std_to_surf", "len", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.voxelmorph.generators.volgen", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.filter_labels", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.sdt_to_surface_pts", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.clean_seg", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.vol_to_sdt", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.get_surface_pts_per_label", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.filter_labels", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.get_surface_pts_per_label", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.clean_seg_batch", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.vol_to_sdt_batch", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["files_done", "=", "np", ".", "mod", "(", "fileidx", "+", "1", ",", "nb_restart_cycle", ")", "==", "0", "\n", "final_batch", "=", "yield_incomplete_final_batch", "and", "files_done", "and", "patch_idx", "==", "(", "nb_patches_per_vol", "-", "1", ")", "\n", "if", "final_batch", ":", "# verbose and ", "\n", "                    ", "print", "(", "'last batch in %s cycle %d. nb_batch:%d'", "%", "(", "name", ",", "fileidx", ",", "len", "(", "vol_data_batch", ")", ")", ")", "\n", "\n", "", "if", "batch_done", "or", "final_batch", ":", "\n", "                    ", "batch_idx", "=", "-", "1", "\n", "q", "=", "np", ".", "vstack", "(", "vol_data_batch", ")", "\n", "yield", "q", "\n", "\n", "", "", "", "if", "empty_gen", ":", "\n", "            ", "raise", "ValueError", "(", "'Patch generator was empty for file %s'", ",", "volfiles", "[", "fileidx", "]", ")", "\n", "\n", "\n", "", "", "", "def", "patch", "(", "vol_data", ",", "# the volume", "\n", "patch_size", ",", "# patch size", "\n", "patch_stride", "=", "1", ",", "# patch stride (spacing)", "\n", "nb_labels_reshape", "=", "1", ",", "# number of labels for categorical resizing. 0 if no resizing", "\n", "keep_vol_size", "=", "False", ",", "# whether to keep the volume size on categorical resizing", "\n", "batch_size", "=", "1", ",", "# batch size", "\n", "collapse_2d", "=", "None", ",", "\n", "patch_rand", "=", "False", ",", "\n", "patch_rand_seed", "=", "None", ",", "\n", "variable_batch_size", "=", "False", ",", "\n", "infinite", "=", "False", ")", ":", "# whether the generator should continue (re)-generating patches", "\n", "    ", "\"\"\"\n    generate patches from volume for keras package\n\n    Yields:\n        patch: nd array of shape [batch_size, *patch_size], unless resized via nb_labels_reshape\n    \"\"\"", "\n", "\n", "# some parameter setup", "\n", "assert", "batch_size", ">=", "1", ",", "\"batch_size should be at least 1\"", "\n", "if", "patch_size", "is", "None", ":", "\n", "        ", "patch_size", "=", "vol_data", ".", "shape", "\n", "", "for", "pi", ",", "p", "in", "enumerate", "(", "patch_size", ")", ":", "\n", "        ", "if", "p", "is", "None", ":", "\n", "            ", "patch_size", "[", "pi", "]", "=", "vol_data", ".", "shape", "[", "pi", "]", "\n", "", "", "batch_idx", "=", "-", "1", "\n", "if", "variable_batch_size", ":", "\n", "        ", "batch_size", "=", "yield", "\n", "\n", "\n", "# do while. if not infinite, will break at the end", "\n", "", "while", "True", ":", "\n", "# create patch generator", "\n", "        ", "gen", "=", "pl", ".", "patch_gen", "(", "vol_data", ",", "patch_size", ",", "\n", "stride", "=", "patch_stride", ",", "\n", "rand", "=", "patch_rand", ",", "\n", "rand_seed", "=", "patch_rand_seed", ")", "\n", "\n", "# go through the patch generator", "\n", "empty_gen", "=", "True", "\n", "for", "lpatch", "in", "gen", ":", "\n", "\n", "            ", "empty_gen", "=", "False", "\n", "# reshape output layer as categorical and prep proper size", "\n", "# print(lpatch.shape, nb_labels_reshape, keep_vol_size, patch_size)", "\n", "lpatch", "=", "_categorical_prep", "(", "lpatch", ",", "nb_labels_reshape", ",", "keep_vol_size", ",", "patch_size", ")", "\n", "\n", "if", "collapse_2d", "is", "not", "None", ":", "\n", "                ", "lpatch", "=", "np", ".", "squeeze", "(", "lpatch", ",", "collapse_2d", "+", "1", ")", "# +1 due to batch in first dim", "\n", "\n", "# add this patch to the stack", "\n", "", "if", "batch_idx", "==", "-", "1", ":", "\n", "                ", "if", "batch_size", "==", "1", ":", "\n", "                    ", "patch_data_batch", "=", "lpatch", "\n", "", "else", ":", "\n", "                    ", "patch_data_batch", "=", "np", ".", "zeros", "(", "[", "batch_size", ",", "*", "lpatch", ".", "shape", "[", "1", ":", "]", "]", ")", "\n", "patch_data_batch", "[", "0", ",", ":", "]", "=", "lpatch", "\n", "\n", "", "", "else", ":", "\n", "                ", "patch_data_batch", "[", "batch_idx", "+", "1", ",", ":", "]", "=", "lpatch", "\n", "\n", "# yield patch", "\n", "", "batch_idx", "+=", "1", "\n", "if", "batch_idx", "==", "batch_size", "-", "1", ":", "\n", "                ", "batch_idx", "=", "-", "1", "\n", "batch_size_y", "=", "yield", "patch_data_batch", "\n", "if", "variable_batch_size", ":", "\n", "                    ", "batch_size", "=", "batch_size_y", "\n", "\n", "", "", "", "assert", "not", "empty_gen", ",", "'generator was empty. vol size was %s'", "%", "''", ".", "join", "(", "[", "'%d '", "%", "d", "for", "d", "in", "vol_data", ".", "shape", "]", ")", "\n", "\n", "# if not infinite generation, yield the last batch and break the while", "\n", "if", "not", "infinite", ":", "\n", "            ", "if", "batch_idx", ">=", "0", ":", "\n", "                ", "patch_data_batch", "=", "patch_data_batch", "[", ":", "(", "batch_idx", "+", "1", ")", ",", ":", "]", "\n", "yield", "patch_data_batch", "\n", "", "break", "\n", "\n", "\n", "", "", "", "def", "vol_seg", "(", "volpath", ",", "\n", "segpath", ",", "\n", "proc_vol_fn", "=", "None", ",", "\n", "proc_seg_fn", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", "name", "=", "'vol_seg'", ",", "# name, optional", "\n", "ext", "=", "'.npz'", ",", "\n", "nb_restart_cycle", "=", "None", ",", "# number of files to restart after", "\n", "nb_labels_reshape", "=", "-", "1", ",", "\n", "collapse_2d", "=", "None", ",", "\n", "force_binary", "=", "False", ",", "\n", "nb_input_feats", "=", "1", ",", "\n", "relabel", "=", "None", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n", "seg_binary", "=", "False", ",", "\n", "vol_subname", "=", "'norm'", ",", "# subname of volume", "\n", "seg_subname", "=", "'aseg'", ",", "# subname of segmentation", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    generator with (volume, segmentation)\n\n    verbose is passed down to the base generators.py primitive generator (e.g. vol, here)\n\n    ** kwargs are any named arguments for vol(...),\n        except verbose, data_proc_fn, ext, nb_labels_reshape and name\n            (which this function will control when calling vol())\n    \"\"\"", "\n", "\n", "# get vol generator", "\n", "vol_gen", "=", "vol", "(", "volpath", ",", "**", "kwargs", ",", "ext", "=", "ext", ",", "\n", "nb_restart_cycle", "=", "nb_restart_cycle", ",", "collapse_2d", "=", "collapse_2d", ",", "force_binary", "=", "False", ",", "\n", "relabel", "=", "None", ",", "data_proc_fn", "=", "proc_vol_fn", ",", "nb_labels_reshape", "=", "1", ",", "name", "=", "name", "+", "' vol'", ",", "\n", "verbose", "=", "verbose", ",", "nb_feats", "=", "nb_input_feats", ",", "vol_rand_seed", "=", "vol_rand_seed", ")", "\n", "\n", "# get seg generator, matching nb_files", "\n", "# vol_files = [f.replace('norm', 'aseg') for f in _get_file_list(volpath, ext)]", "\n", "# vol_files = [f.replace('orig', 'aseg') for f in vol_files]", "\n", "vol_files", "=", "[", "f", ".", "replace", "(", "vol_subname", ",", "seg_subname", ")", "for", "f", "in", "_get_file_list", "(", "volpath", ",", "ext", ",", "vol_rand_seed", ")", "]", "\n", "seg_gen", "=", "vol", "(", "segpath", ",", "**", "kwargs", ",", "ext", "=", "ext", ",", "nb_restart_cycle", "=", "nb_restart_cycle", ",", "collapse_2d", "=", "collapse_2d", ",", "\n", "force_binary", "=", "force_binary", ",", "relabel", "=", "relabel", ",", "vol_rand_seed", "=", "vol_rand_seed", ",", "\n", "data_proc_fn", "=", "proc_seg_fn", ",", "nb_labels_reshape", "=", "nb_labels_reshape", ",", "keep_vol_size", "=", "True", ",", "\n", "expected_files", "=", "vol_files", ",", "name", "=", "name", "+", "' seg'", ",", "binary", "=", "seg_binary", ",", "verbose", "=", "False", ")", "\n", "\n", "# on next (while):", "\n", "while", "1", ":", "\n", "# get input and output (seg) vols", "\n", "        ", "input_vol", "=", "next", "(", "vol_gen", ")", ".", "astype", "(", "'float16'", ")", "\n", "output_vol", "=", "next", "(", "seg_gen", ")", ".", "astype", "(", "'float16'", ")", "# was int8. Why? need float possibility...", "\n", "\n", "# output input and output", "\n", "yield", "(", "input_vol", ",", "output_vol", ")", "\n", "\n", "\n", "", "", "def", "vol_cat", "(", "volpaths", ",", "# expect two folders in here", "\n", "crop", "=", "None", ",", "resize_shape", "=", "None", ",", "rescale", "=", "None", ",", "# processing parameters", "\n", "verbose", "=", "False", ",", "\n", "name", "=", "'vol_cat'", ",", "# name, optional", "\n", "ext", "=", "'.npz'", ",", "\n", "nb_labels_reshape", "=", "-", "1", ",", "\n", "vol_rand_seed", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.networks.Unet.__init__": [[21, 76], ["torch.Module.__init__", "len", "isinstance", "torch.Upsample", "torch.Upsample", "torch.Upsample", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "list", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "enumerate", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "default_unet_features", "np.round().astype", "np.flip", "networks.Unet.downarm.append", "reversed", "networks.Unet.uparm.append", "networks.Unet.extras.append", "ValueError", "ValueError", "networks.ConvBlock", "networks.ConvBlock", "len", "networks.ConvBlock", "np.round", "len", "np.arange"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.default_unet_features", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange"], ["from", "voxelmorph", ".", "tf", ".", "layers", "import", "SpatialTransformer", ",", "VecInt", ",", "RescaleTransform", "\n", "\n", "\n", "# ----------------------------------------------------------------------------", "\n", "# Common network block:", "\n", "\n", "def", "conv_block", "(", "\n", "x_in", ",", "\n", "nf", ",", "\n", "condn_emb", "=", "None", ",", "\n", "mode", "=", "'const'", ",", "\n", "activation", "=", "True", ",", "\n", "sn", "=", "False", ",", "\n", "instancen", "=", "False", ",", "\n", "stride", "=", "1", ",", "\n", "kernel_size", "=", "3", ",", "\n", "init", "=", "'default'", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Convolution module including convolution followed by leakyrelu.\n    Args:\n        x_in: input feature map\n        nf: number of filters\n        condn_emb: if using FiLM, this is the condition embedding.\n        mode: either upsample, downsample or leave at constant resolution.\n        activation: bool indicating whether to use a leaky relu.\n        sn: bool indicating whether to use spectral norm.\n        instancen: bool for instance norm. Not used in paper.\n        stride: convolutional stride\n        kernel_size: kernel size\n        init: weight initialization. either 'default' or 'orthogonal'\n    \"\"\"", "\n", "\n", "ndims", "=", "len", "(", "x_in", ".", "get_shape", "(", ")", ")", "-", "2", "\n", "assert", "ndims", "in", "[", "1", ",", "2", ",", "3", "]", ",", "\"ndims supported to up to 3. found: %d\"", "%", "ndims", "\n", "\n", "maxpool", "=", "getattr", "(", "KL", ",", "'MaxPooling%dD'", "%", "ndims", ")", "\n", "upsample", "=", "getattr", "(", "KL", ",", "'UpSampling%dD'", "%", "ndims", ")", "\n", "conv", "=", "getattr", "(", "KL", ",", "'Conv%dD'", "%", "ndims", ")", "\n", "\n", "# If unconditional and not using FiLM, then train conv layers with bias:", "\n", "if", "condn_emb", "is", "None", ":", "\n", "        ", "bias", "=", "True", "\n", "", "else", ":", "\n", "        ", "bias", "=", "False", "\n", "\n", "# Reflection pad:", "\n", "", "x_in", "=", "tf", ".", "pad", "(", "\n", "x_in", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ",", "\n", "\"REFLECT\"", ",", "\n", ")", "\n", "\n", "# Specify initializations:", "\n", "if", "init", "==", "'default'", "or", "init", "is", "None", ":", "\n", "        ", "initialization", "=", "None", "\n", "", "elif", "init", "==", "'orthogonal'", ":", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.networks.Unet.forward": [[77, 96], ["x_enc.pop", "x_enc.append", "layer", "networks.Unet.upsample", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "layer", "layer", "x_enc.pop"], "methods", ["None"], ["        ", "initialization", "=", "'orthogonal'", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "\n", "# If using spectral normalization:", "\n", "", "if", "sn", ":", "\n", "        ", "x_out", "=", "SpectralNormalization", "(", "conv", "(", "\n", "nf", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "bias", ",", "\n", "strides", "=", "stride", ",", "\n", "kernel_initializer", "=", "initialization", ",", "\n", ")", ")", "(", "x_in", ")", "\n", "", "else", ":", "\n", "        ", "x_out", "=", "conv", "(", "\n", "nf", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "bias", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.networks.VxmDense.__init__": [[103, 170], ["modelio.LoadableModel.__init__", "len", "networks.Unet", "getattr", "getattr.", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "layers.SpatialTransformer", "torch.distributions.normal.Normal().sample", "torch.distributions.normal.Normal().sample", "torch.distributions.normal.Normal().sample", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "NotImplementedError", "layers.ResizeTransform", "layers.ResizeTransform", "int", "layers.VecInt", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["        ", "x_out", "=", "InstanceNormalization", "(", "\n", "center", "=", "True", ",", "\n", "scale", "=", "True", ",", "\n", ")", "(", "x_out", ")", "\n", "\n", "# If using FiLM:", "\n", "", "if", "condn_emb", "is", "not", "None", ":", "\n", "        ", "x_out", "=", "FiLM", "(", "init", "=", "init", ")", "(", "[", "x_out", ",", "condn_emb", "]", ")", "\n", "\n", "# Nonlinearity:", "\n", "", "if", "activation", ":", "\n", "        ", "x_out", "=", "KL", ".", "LeakyReLU", "(", "0.2", ")", "(", "x_out", ")", "\n", "\n", "# Up/down sample:", "\n", "", "if", "mode", "==", "'up'", ":", "\n", "        ", "x_out", "=", "upsample", "(", ")", "(", "x_out", ")", "\n", "", "elif", "mode", "==", "'down'", ":", "\n", "        ", "x_out", "=", "maxpool", "(", ")", "(", "x_out", ")", "# not used in paper, we used strided convs", "\n", "", "elif", "mode", "==", "'const'", ":", "\n", "        ", "pass", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'mode has to be up/down/const w.r.t. spatial res'", ")", "\n", "\n", "", "return", "x_out", "\n", "\n", "\n", "", "@", "tf", ".", "function", "\n", "def", "const_inp", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"Used to give a layer a constant input of 1.\"\"\"", "\n", "batch_size", "=", "tf", ".", "shape", "(", "tensor", ")", "[", "0", "]", "\n", "constant", "=", "tf", ".", "constant", "(", "1.0", ")", "\n", "constant", "=", "tf", ".", "expand_dims", "(", "constant", ",", "axis", "=", "0", ")", "\n", "return", "tf", ".", "broadcast_to", "(", "constant", ",", "shape", "=", "(", "batch_size", ",", "1", ")", ")", "\n", "\n", "\n", "# ----------------------------------------------------------------------------", "\n", "# Generator architecture", "\n", "\n", "\n", "", "def", "Generator", "(", "\n", "ch", "=", "32", ",", "\n", "full_size", "=", "False", ",", "\n", "conditional", "=", "True", ",", "\n", "normreg", "=", "False", ",", "\n", "atlas_model", "=", "'ours'", ",", "\n", "input_resolution", "=", "[", "160", ",", "192", ",", "160", ",", "1", "]", ",", "\n", "clip_bckgnd", "=", "True", ",", "\n", "initialization", "=", "'default'", ",", "\n", "n_condns", "=", "1", ",", "\n", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.networks.VxmDense.forward": [[171, 215], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "networks.VxmDense.unet_model", "networks.VxmDense.flow", "networks.VxmDense.transformer", "networks.VxmDense.resize", "networks.VxmDense.integrate", "networks.VxmDense.transformer", "networks.VxmDense.integrate", "networks.VxmDense.fullsize", "networks.VxmDense.fullsize"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.plot.flow", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.resize"], ["\n", "image_inputs", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "input_resolution", ")", "\n", "atlas_inputs", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "input_resolution", ")", "\n", "\n", "if", "conditional", ":", "\n", "        ", "condn", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "n_condns", ",", ")", ")", "\n", "\n", "# These are used in the template generation branch only for Atlas-HQ", "\n", "# Also for the registration sub-network.", "\n", "", "if", "initialization", "==", "'orthogonal'", ":", "\n", "        ", "init", "=", "'orthogonal'", "\n", "vel_init", "=", "'orthogonal'", "\n", "", "elif", "initialization", "==", "'default'", ":", "\n", "        ", "init", "=", "None", "\n", "vel_init", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1e-5", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "\n", "# Atlas sharpening branch:", "\n", "# TODO: Long if/else sequence, abstract out and make cleaner.", "\n", "# VXM archs taken verbatim from their repos", "\n", "", "if", "atlas_model", "==", "'voxelmorph'", "and", "conditional", "is", "False", ":", "\n", "# vxm unconditional model:", "\n", "        ", "atlas_layer", "=", "LocalParamWithInput", "(", "\n", "name", "=", "'atlas'", ",", "\n", "shape", "=", "input_resolution", ",", "\n", "mult", "=", "1.0", ",", "\n", "initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "RandomNormal", "(", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1e-7", ",", "\n", ")", ",", "\n", ")", "\n", "\n", "new_atlas", "=", "atlas_layer", "(", "atlas_inputs", ")", "\n", "\n", "", "elif", "atlas_model", "==", "'voxelmorph'", "and", "conditional", "is", "True", ":", "\n", "# vxm conditional model:", "\n", "# TODO: fix hardcoding", "\n", "        ", "condn_emb_vxm", "=", "KL", ".", "Dense", "(", "(", "80", "*", "96", "*", "80", "*", "8", ")", ",", "activation", "=", "'elu'", ")", "(", "condn", ")", "\n", "condn_emb_vxm", "=", "KL", ".", "Reshape", "(", "(", "80", ",", "96", ",", "80", ",", "8", ")", ")", "(", "condn_emb_vxm", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.networks.ConvBlock.__init__": [[222, 228], ["torch.Module.__init__", "getattr", "getattr.", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["2", ",", "\n", "[", "3", ",", "3", ",", "3", "]", ",", "\n", "8", ",", "\n", ")", "\n", "last_tensor", "=", "dec_out", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "last_tensor", "=", "KL", ".", "Conv3D", "(", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.networks.ConvBlock.forward": [[229, 233], ["networks.ConvBlock.main", "networks.ConvBlock.activation"], "methods", ["None"], ["8", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlas_ec_%d'", "%", "i", ",", "\n", ")", "(", "last_tensor", ")", "\n", "\n", "", "pout", "=", "KL", ".", "Conv3D", "(", "\n", "1", ",", "kernel_size", "=", "3", ",", "padding", "=", "'same'", ",", "name", "=", "'atlasmodel_c'", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.layers.SpatialTransformer.__init__": [[11, 29], ["torch.Module.__init__", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "grid.type.type.type", "layers.SpatialTransformer.register_buffer", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange"], ["\n", "\n", "# internal python imports", "\n", "import", "sys", "\n", "import", "itertools", "\n", "\n", "# third party", "\n", "import", "numpy", "as", "np", "\n", "import", "tensorflow", "as", "tf", "\n", "from", "tensorflow", "import", "keras", "\n", "from", "tensorflow", ".", "keras", "import", "backend", "as", "K", "\n", "from", "tensorflow", ".", "keras", ".", "layers", "import", "Layer", ",", "InputLayer", ",", "Input", "\n", "from", "tensorflow", ".", "python", ".", "keras", ".", "engine", "import", "base_layer", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.layers.SpatialTransformer.forward": [[30, 49], ["range", "torch.grid_sample", "torch.grid_sample", "torch.grid_sample", "len", "len", "new_locs.permute.permute.permute", "len", "new_locs.permute.permute.permute"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["from", "tensorflow", ".", "python", ".", "keras", ".", "utils", "import", "conv_utils", "\n", "from", "tensorflow", ".", "python", ".", "keras", ".", "engine", ".", "input_spec", "import", "InputSpec", "\n", "from", "tensorflow", ".", "python", ".", "keras", ".", "utils", "import", "tf_utils", "\n", "from", "tensorflow", ".", "python", ".", "keras", "import", "backend", "\n", "from", "tensorflow", ".", "python", "import", "roll", "as", "_roll", "\n", "\n", "# local imports", "\n", "from", ".", "import", "utils", "\n", "\n", "\n", "class", "Negate", "(", "Layer", ")", ":", "\n", "    ", "\"\"\" \n    Keras Layer: negative of the input\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Negate", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "Negate", ",", "self", ")", ".", "build", "(", "input_shape", ")", "# Be sure to call this somewhere!", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.layers.VecInt.__init__": [[56, 63], ["torch.Module.__init__", "layers.SpatialTransformer"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["\n", "\n", "", "", "class", "RescaleValues", "(", "Layer", ")", ":", "\n", "    ", "\"\"\" \n    Very simple Keras layer to rescale data values (e.g. intensities) by fixed factor\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "resize", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.layers.VecInt.forward": [[64, 69], ["range", "layers.VecInt.transformer"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["        ", "self", ".", "resize", "=", "resize", "\n", "super", "(", "RescaleValues", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", ".", "copy", "(", ")", "\n", "config", ".", "update", "(", "{", "'resize'", ":", "self", ".", "resize", "}", ")", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.layers.ResizeTransform.__init__": [[76, 84], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["        ", "return", "x", "*", "self", ".", "resize", "\n", "\n", "", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n", "\n", "", "", "class", "Resize", "(", "Layer", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.layers.ResizeTransform.forward": [[85, 98], ["torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate"], "methods", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "\n", "zoom_factor", ",", "\n", "interp_method", "=", "'linear'", ",", "\n", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.__init__": [[52, 56], ["torch.Module.__init__", "hasattr", "RuntimeError"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "'config'", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'models that inherit from LoadableModel must decorate the constructor with @store_config_args'", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save": [[57, 67], ["modelio.LoadableModel.state_dict().copy", "torch.save", "torch.save", "torch.save", "torch.save", "modelio.LoadableModel.pop", "modelio.LoadableModel.state_dict", "modelio.LoadableModel.keys", "key.endswith"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save"], ["", "def", "save", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"\n        Saves the model configuration and weights to a pytorch file.\n        \"\"\"", "\n", "# don't save the transformer_grid buffers - see SpatialTransformer doc for more info", "\n", "sd", "=", "self", ".", "state_dict", "(", ")", ".", "copy", "(", ")", "\n", "grid_buffers", "=", "[", "key", "for", "key", "in", "sd", ".", "keys", "(", ")", "if", "key", ".", "endswith", "(", "'.grid'", ")", "]", "\n", "for", "key", "in", "grid_buffers", ":", "\n", "            ", "sd", ".", "pop", "(", "key", ")", "\n", "", "torch", ".", "save", "(", "{", "'config'", ":", "self", ".", "config", ",", "'model_state'", ":", "sd", "}", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load": [[68, 77], ["torch.load", "torch.load", "torch.load", "torch.load", "cls", "cls.load_state_dict", "torch.device", "torch.device", "torch.device", "torch.device"], "methods", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], ["", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "path", ",", "device", ")", ":", "\n", "        ", "\"\"\"\n        Load a python model configuration and weights.\n        \"\"\"", "\n", "checkpoint", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "torch", ".", "device", "(", "device", ")", ")", "\n", "model", "=", "cls", "(", "**", "checkpoint", "[", "'config'", "]", ")", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'model_state'", "]", ",", "strict", "=", "False", ")", "\n", "return", "model", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.store_config_args": [[7, 36], ["inspect.getargspec", "functools.wraps", "zip", "func", "zip", "kwargs.items", "reversed", "reversed"], "function", ["None"], ["def", "store_config_args", "(", "func", ")", ":", "\n", "    ", "\"\"\"\n    Class-method decorator that saves every argument provided to the\n    function as a dictionary in 'self.config'. This is used to assist\n    model loading - see LoadableModel.\n    \"\"\"", "\n", "\n", "attrs", ",", "varargs", ",", "varkw", ",", "defaults", "=", "inspect", ".", "getargspec", "(", "func", ")", "\n", "\n", "@", "functools", ".", "wraps", "(", "func", ")", "\n", "def", "wrapper", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "config", "=", "{", "}", "\n", "\n", "# first save the default values", "\n", "if", "defaults", ":", "\n", "            ", "for", "attr", ",", "val", "in", "zip", "(", "reversed", "(", "attrs", ")", ",", "reversed", "(", "defaults", ")", ")", ":", "\n", "                ", "self", ".", "config", "[", "attr", "]", "=", "val", "\n", "\n", "# next handle positional args", "\n", "", "", "for", "attr", ",", "val", "in", "zip", "(", "attrs", "[", "1", ":", "]", ",", "args", ")", ":", "\n", "            ", "self", ".", "config", "[", "attr", "]", "=", "val", "\n", "\n", "# lastly handle keyword args", "\n", "", "if", "kwargs", ":", "\n", "            ", "for", "attr", ",", "val", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                ", "self", ".", "config", "[", "attr", "]", "=", "val", "\n", "\n", "", "", "return", "func", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.NCC.__init__": [[12, 14], ["None"], "methods", ["None"], ["loss_object_NCC", "=", "NCC", "(", "win", "=", "[", "9", "]", "*", "3", ")", "# used for registration", "\n", "loss_object_NonSquareNCC", "=", "NonSquareNCC", "(", "win", "=", "[", "9", "]", "*", "3", ")", "# not used in paper", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.NCC.loss": [[15, 56], ["getattr", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "math.floor", "compute_local_sums", "len", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "list", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "I.size"], "methods", ["None"], ["\n", "# ----------------------------------------------------------------------------", "\n", "# Generator losses", "\n", "\n", "@", "tf", ".", "function", "\n", "def", "total_variation3D", "(", "ypred", ")", ":", "\n", "    ", "\"\"\"\n    Not used in paper.\n    Calculates anisotropic total variation for a 3D image ypred.\n    \"\"\"", "\n", "\n", "pixel_dif1", "=", "ypred", "[", ":", ",", "1", ":", ",", ":", ",", ":", ",", ":", "]", "-", "ypred", "[", ":", ",", ":", "-", "1", ",", ":", ",", ":", ",", ":", "]", "\n", "pixel_dif2", "=", "ypred", "[", ":", ",", ":", ",", "1", ":", ",", ":", ",", ":", "]", "-", "ypred", "[", ":", ",", ":", ",", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "pixel_dif3", "=", "ypred", "[", ":", ",", ":", ",", ":", ",", "1", ":", ",", ":", "]", "-", "ypred", "[", ":", ",", ":", ",", ":", ",", ":", "-", "1", ",", ":", "]", "\n", "\n", "tot_var", "=", "(", "\n", "tf", ".", "reduce_mean", "(", "tf", ".", "math", ".", "abs", "(", "pixel_dif1", ")", ")", "+", "\n", "tf", ".", "reduce_mean", "(", "tf", ".", "math", ".", "abs", "(", "pixel_dif2", ")", ")", "+", "\n", "tf", ".", "reduce_mean", "(", "tf", ".", "math", ".", "abs", "(", "pixel_dif3", ")", ")", "\n", ")", "\n", "return", "tf", ".", "reduce_mean", "(", "tot_var", ")", "\n", "\n", "\n", "", "@", "tf", ".", "function", "\n", "def", "generator_loss", "(", "\n", "disc_opinion_fake_local", ",", "\n", "disp_ms", ",", "\n", "disp", ",", "\n", "moved_atlases", ",", "\n", "fixed_images", ",", "\n", "epoch", ",", "\n", "sharp_atlases", ",", "\n", "loss_wts", ",", "\n", "start_step", "=", "0", ",", "\n", "reg_loss_type", "=", "'NCC'", ",", "\n", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.MSE.loss": [[63, 65], ["torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.__init__": [[72, 75], ["None"], "methods", ["None"], ["\n", "lambda_gan", ",", "lambda_reg", ",", "lambda_tv", "=", "loss_wts", "\n", "\n", "# If training registration only, without GAN loss.", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.losses.Grad.loss": [[76, 92], ["torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["None"], ["# Need to do this, otherwise graph detaches:", "\n", "if", "epoch", ">=", "start_step", ":", "\n", "        ", "gan_loss", "=", "loss_object", "(", "\n", "tf", ".", "ones_like", "(", "disc_opinion_fake_local", ")", ",", "disc_opinion_fake_local", ",", "\n", ")", "\n", "if", "lambda_tv", ">", "0.0", ":", "# never happens as TV loss not used in paper", "\n", "            ", "tv_loss", "=", "total_variation3D", "(", "sharp_atlases", ")", "\n", "", "else", ":", "\n", "            ", "tv_loss", "=", "0.0", "\n", "", "", "else", ":", "\n", "        ", "gan_loss", "=", "0.0", "\n", "tv_loss", "=", "0.0", "\n", "\n", "# Similarity terms:", "\n", "", "if", "reg_loss_type", "==", "'NCC'", ":", "\n", "        ", "similarity_loss", "=", "tf", ".", "reduce_mean", "(", "\n", "loss_object_NCC", ".", "loss", "(", "moved_atlases", ",", "fixed_images", ")", ",", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.build_model_input_generator": [[11, 160], ["numpy.size", "len", "numpy.arange", "isinstance", "isinstance", "utils.load_volfile", "isinstance", "numpy.randint().repeat", "numpy.randint", "numpy.full", "numpy.flip", "y_all.append", "numpy.empty", "numpy.empty", "range", "means_all.append", "std_devs_all.append", "inputs_vals.append", "inputs_vals.append", "inputs_vals.append", "len", "numpy.random.randn", "utils.load_volfile", "utils.add_axis", "model_input_generator.means_stds_no_rules", "numpy.concatenate", "numpy.concatenate", "utils.add_axis", "utils.add_axis", "numpy.uniform", "model_input_generator.draw_rotation_angle", "numpy.uniform", "utils.create_affine_transformation_matrix", "aff_all.append", "numpy.normal", "nonlinear_field_all.append", "numpy.normal", "bias_field_all.append", "numpy.concatenate", "numpy.randint", "numpy.where", "numpy.any", "numpy.random.uniform", "numpy.random.uniform", "utils.add_axis", "len", "utils.add_axis", "len", "utils.add_axis", "len", "numpy.randint", "numpy.squeeze", "numpy.all", "numpy.rand", "numpy.rand", "len", "utils.load_volfile", "numpy.flip", "numpy.array", "tuple", "range", "numpy.random.normal"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.means_stds_no_rules", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.draw_rotation_angle", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.create_affine_transformation_matrix", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], ["def", "build_model_input_generator", "(", "labels_paths", ",", "\n", "generation_label_list", ",", "\n", "warp_shape", ",", "\n", "bias_shape", ",", "\n", "n_channels", "=", "1", ",", "\n", "classes_list", "=", "None", ",", "\n", "means_range", "=", "None", ",", "\n", "std_devs_range", "=", "None", ",", "\n", "use_specific_stats_for_channel", "=", "False", ",", "\n", "apply_affine_trans", "=", "False", ",", "\n", "scaling_range", "=", "None", ",", "\n", "rotation_range", "=", "None", ",", "\n", "shearing_range", "=", "None", ",", "\n", "apply_nonlin_trans", "=", "True", ",", "\n", "nonlin_std_dev", "=", "3", ",", "\n", "apply_bias_field", "=", "True", ",", "\n", "bias_field_std_dev", "=", "0.3", ",", "\n", "blur_background", "=", "True", ",", "\n", "background_paths", "=", "None", ",", "\n", "head", "=", "True", ",", "\n", "batch_size", "=", "1", ",", "\n", "same_subj", "=", "False", ",", "\n", "flipping", "=", "True", ",", "\n", "rand_scale", "=", "True", ")", ":", "\n", "\n", "    ", "if", "scaling_range", "is", "None", ":", "\n", "        ", "scaling_range", "=", "[", "0.93", ",", "1.07", "]", "\n", "", "elif", "isinstance", "(", "scaling_range", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "        ", "scaling_range", "=", "[", "1", "-", "scaling_range", ",", "1", "+", "scaling_range", "]", "\n", "", "if", "shearing_range", "is", "None", ":", "\n", "        ", "shearing_range", "=", "[", "-", "0.01", ",", "0.01", "]", "\n", "", "elif", "isinstance", "(", "shearing_range", ",", "(", "int", ",", "float", ")", ")", "!=", "'list'", ":", "\n", "        ", "shearing_range", "=", "[", "-", "shearing_range", ",", "shearing_range", "]", "\n", "\n", "# get label info", "\n", "", "n_lab", "=", "np", ".", "size", "(", "generation_label_list", ")", "\n", "dataset", "=", "[", "]", "if", "isinstance", "(", "labels_paths", "[", "0", "]", ",", "str", ")", "else", "labels_paths", "\n", "\n", "# Generate!", "\n", "sample", "=", "dataset", "[", "0", "]", "if", "dataset", "else", "load_volfile", "(", "labels_paths", "[", "0", "]", ")", "\n", "n_dims", "=", "len", "(", "sample", ".", "shape", ")", "\n", "dims", "=", "np", ".", "arange", "(", "n_dims", ")", "\n", "while", "True", ":", "\n", "\n", "# Generate all images within a batch from the same file.", "\n", "        ", "if", "same_subj", ":", "\n", "            ", "indices", "=", "npr", ".", "randint", "(", "len", "(", "labels_paths", ")", ",", "size", "=", "1", ")", ".", "repeat", "(", "batch_size", ")", "\n", "", "else", ":", "\n", "            ", "indices", "=", "npr", ".", "randint", "(", "len", "(", "labels_paths", ")", ",", "size", "=", "batch_size", ")", "\n", "\n", "# initialise input tensors", "\n", "", "y_all", "=", "[", "]", "\n", "means_all", "=", "[", "]", "\n", "std_devs_all", "=", "[", "]", "\n", "aff_all", "=", "[", "]", "\n", "nonlinear_field_all", "=", "[", "]", "\n", "bias_field_all", "=", "[", "]", "\n", "\n", "# Flip each segmentation in batch identically.", "\n", "is_flip", "=", "np", ".", "random", ".", "randn", "(", "n_dims", ")", ">", "0", "if", "flipping", "else", "np", ".", "full", "(", "n_dims", ",", "False", ")", "\n", "\n", "for", "idx", "in", "indices", ":", "\n", "\n", "# add labels to inputs", "\n", "            ", "if", "dataset", ":", "\n", "                ", "y", "=", "dataset", "[", "idx", "]", "\n", "", "else", ":", "\n", "                ", "y", "=", "load_volfile", "(", "labels_paths", "[", "idx", "]", ",", "dtype", "=", "'int'", ",", "squeeze", "=", "True", ")", "\n", "if", "background_paths", "is", "not", "None", ":", "\n", "                    ", "idx_258", "=", "np", ".", "where", "(", "y", "==", "258", ")", "\n", "if", "np", ".", "any", "(", "idx_258", ")", ":", "\n", "                        ", "background_idx", "=", "npr", ".", "randint", "(", "len", "(", "background_paths", ")", ")", "\n", "background", "=", "np", ".", "squeeze", "(", "load_volfile", "(", "background_paths", "[", "background_idx", "]", ",", "dtype", "=", "'int'", ")", ")", "\n", "background_shape", "=", "background", ".", "shape", "\n", "if", "np", ".", "all", "(", "np", ".", "array", "(", "background_shape", ")", "==", "background_shape", "[", "0", "]", ")", ":", "# flip if same dimensions", "\n", "                            ", "background", "=", "np", ".", "flip", "(", "background", ",", "tuple", "(", "[", "i", "for", "i", "in", "range", "(", "3", ")", "if", "np", ".", "random", ".", "normal", "(", ")", ">", "0", "]", ")", ")", "\n", "", "assert", "background", ".", "shape", "==", "y", ".", "shape", ",", "'background patches should have same shape than training labels. '", "'Had {0} and {1}'", ".", "format", "(", "background", ".", "shape", ",", "y", ".", "shape", ")", "\n", "y", "[", "idx_258", "]", "=", "background", "[", "idx_258", "]", "\n", "\n", "", "", "", "y", "=", "np", ".", "flip", "(", "y", ",", "axis", "=", "dims", "[", "is_flip", "]", ")", "\n", "y_all", ".", "append", "(", "add_axis", "(", "y", ",", "axis", "=", "-", "2", ")", ")", "\n", "\n", "# add means and standard deviations to inputs", "\n", "means", "=", "np", ".", "empty", "(", "(", "n_lab", ",", "0", ")", ")", "\n", "std_devs", "=", "np", ".", "empty", "(", "(", "n_lab", ",", "0", ")", ")", "\n", "for", "channel", "in", "range", "(", "n_channels", ")", ":", "\n", "# retrieve channel specifi stats if necessary", "\n", "                ", "if", "use_specific_stats_for_channel", ":", "\n", "                    ", "tmp_means_range", "=", "means_range", "[", "2", "*", "channel", ":", "2", "*", "channel", "+", "2", ",", ":", "]", "\n", "tmp_std_devs_range", "=", "std_devs_range", "[", "2", "*", "channel", ":", "2", "*", "channel", "+", "2", ",", ":", "]", "\n", "", "else", ":", "\n", "                    ", "tmp_means_range", "=", "means_range", "\n", "tmp_std_devs_range", "=", "std_devs_range", "\n", "# draw means and std devs from priors", "\n", "", "tmp_means", ",", "tmp_stds", "=", "means_stds_no_rules", "(", "n_lab", ",", "\n", "tmp_means_range", ",", "\n", "tmp_std_devs_range", ")", "\n", "if", "blur_background", ":", "\n", "                    ", "tmp_means", "[", "0", "]", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0", ",", "high", "=", "225", ")", "\n", "tmp_stds", "[", "0", "]", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0", ",", "high", "=", "25", ")", "\n", "", "else", ":", "\n", "                    ", "tmp_means", "[", "0", "]", "=", "0", "\n", "tmp_stds", "[", "0", "]", "=", "0", "\n", "", "means", "=", "np", ".", "concatenate", "(", "[", "means", ",", "tmp_means", "]", ",", "axis", "=", "1", ")", "\n", "std_devs", "=", "np", ".", "concatenate", "(", "[", "std_devs", ",", "tmp_stds", "]", ",", "axis", "=", "1", ")", "\n", "", "means_all", ".", "append", "(", "add_axis", "(", "means", ")", ")", "\n", "std_devs_all", ".", "append", "(", "add_axis", "(", "std_devs", ")", ")", "\n", "\n", "# add inputs according to augmentation specification", "\n", "if", "apply_affine_trans", ":", "\n", "# get affine transformation: rotate, scale, shear (translation done during random cropping)", "\n", "                ", "scaling", "=", "npr", ".", "uniform", "(", "low", "=", "scaling_range", "[", "0", "]", ",", "high", "=", "scaling_range", "[", "1", "]", ",", "size", "=", "n_dims", ")", "\n", "rotation_angle", "=", "draw_rotation_angle", "(", "rotation_range", ",", "n_dims", ")", "\n", "shearing", "=", "npr", ".", "uniform", "(", "low", "=", "shearing_range", "[", "0", "]", ",", "high", "=", "shearing_range", "[", "1", "]", ",", "size", "=", "n_dims", "**", "2", "-", "n_dims", ")", "\n", "aff", "=", "create_affine_transformation_matrix", "(", "n_dims", ",", "scaling", ",", "rotation_angle", ",", "shearing", ")", "\n", "aff_all", ".", "append", "(", "add_axis", "(", "aff", ")", ")", "\n", "\n", "", "if", "apply_nonlin_trans", ":", "\n", "                ", "if", "len", "(", "warp_shape", ")", "==", "n_dims", ":", "\n", "                    ", "warp_shape", "=", "[", "*", "warp_shape", ",", "n_dims", "]", "\n", "", "scale", "=", "nonlin_std_dev", "*", "(", "npr", ".", "rand", "(", ")", "if", "rand_scale", "else", "1", ")", "\n", "nonlinear_field", "=", "npr", ".", "normal", "(", "scale", "=", "scale", ",", "size", "=", "warp_shape", ")", "\n", "nonlinear_field_all", ".", "append", "(", "add_axis", "(", "nonlinear_field", ")", ")", "\n", "\n", "", "if", "apply_bias_field", ":", "\n", "                ", "if", "len", "(", "bias_shape", ")", "==", "n_dims", ":", "\n", "                    ", "bias_shape", "=", "[", "*", "bias_shape", ",", "1", "]", "\n", "", "scale", "=", "bias_field_std_dev", "*", "(", "npr", ".", "rand", "(", ")", "if", "rand_scale", "else", "1", ")", "\n", "bias_field", "=", "npr", ".", "normal", "(", "scale", "=", "scale", ",", "size", "=", "bias_shape", ")", "\n", "bias_field_all", ".", "append", "(", "add_axis", "(", "bias_field", ")", ")", "\n", "\n", "# build list of inputs to augmentation model", "\n", "", "", "inputs_vals", "=", "[", "y_all", ",", "means_all", ",", "std_devs_all", "]", "\n", "if", "apply_affine_trans", ":", "\n", "            ", "inputs_vals", ".", "append", "(", "aff_all", ")", "\n", "", "if", "apply_nonlin_trans", ":", "\n", "            ", "inputs_vals", ".", "append", "(", "nonlinear_field_all", ")", "\n", "", "if", "apply_bias_field", ":", "\n", "            ", "inputs_vals", ".", "append", "(", "bias_field_all", ")", "\n", "\n", "# put images and labels (concatenated if batch_size>1) into a tuple of 2 elements: (cat_images, cat_labels)", "\n", "", "if", "batch_size", ">", "1", ":", "\n", "            ", "inputs_vals", "=", "[", "np", ".", "concatenate", "(", "item", ",", "0", ")", "for", "item", "in", "inputs_vals", "]", "\n", "", "else", ":", "\n", "            ", "inputs_vals", "=", "[", "item", "[", "0", "]", "for", "item", "in", "inputs_vals", "]", "\n", "\n", "", "yield", "inputs_vals", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.means_stds_no_rules": [[162, 169], ["utils.draw_values", "utils.draw_values"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values"], ["", "", "def", "means_stds_no_rules", "(", "n_lab", ",", "means_range", ",", "std_devs_range", ")", ":", "\n", "\n", "# draw values", "\n", "    ", "means", "=", "draw_values", "(", "means_range", ",", "n_lab", ",", "'means_range'", ")", "\n", "stds", "=", "draw_values", "(", "std_devs_range", ",", "n_lab", ",", "'std_devs_range'", ")", "\n", "\n", "return", "means", ",", "stds", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.means_stds_with_rl_grouping": [[171, 182], ["utils.draw_values", "utils.draw_values", "numpy.concatenate", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values"], ["", "def", "means_stds_with_rl_grouping", "(", "n_sided", ",", "n_neutral", ",", "means_range", ",", "std_devs_range", ")", ":", "\n", "\n", "# draw values", "\n", "    ", "means", "=", "draw_values", "(", "means_range", ",", "n_sided", "+", "n_neutral", ",", "'means_range'", ")", "\n", "stds", "=", "draw_values", "(", "std_devs_range", ",", "n_sided", "+", "n_neutral", ",", "'std_devs_range'", ")", "\n", "\n", "# regroup neutral and sided labels", "\n", "means", "=", "np", ".", "concatenate", "(", "[", "means", "[", ":", "n_neutral", "]", ",", "means", "[", "n_neutral", ":", "]", ",", "means", "[", "n_neutral", ":", "]", "]", ")", "\n", "stds", "=", "np", ".", "concatenate", "(", "[", "stds", "[", ":", "n_neutral", "]", ",", "stds", "[", "n_neutral", ":", "]", ",", "stds", "[", "n_neutral", ":", "]", "]", ")", "\n", "\n", "return", "means", ",", "stds", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.means_stds_with_classes": [[184, 206], ["numpy.zeros", "numpy.unique", "numpy.sort", "len", "range", "classes_lut[].astype", "utils.draw_values", "utils.draw_values", "numpy.max().astype", "numpy.sort", "unique_classes[].astype", "numpy.max"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values"], ["", "def", "means_stds_with_classes", "(", "classes_list", ",", "means_range", ",", "std_devs_range", ")", ":", "\n", "\n", "# get unique list of classes and reorder them from 0 to N-1", "\n", "    ", "classes_lut", "=", "np", ".", "zeros", "(", "np", ".", "max", "(", "classes_list", ")", ".", "astype", "(", "'int'", ")", "+", "1", ")", "\n", "_", ",", "idx", "=", "np", ".", "unique", "(", "classes_list", ",", "return_index", "=", "True", ")", "\n", "unique_classes", "=", "np", ".", "sort", "(", "classes_list", "[", "np", ".", "sort", "(", "idx", ")", "]", ")", "\n", "n_stats", "=", "len", "(", "unique_classes", ")", "\n", "\n", "# reformat classes_list", "\n", "for", "n", "in", "range", "(", "n_stats", ")", ":", "\n", "        ", "classes_lut", "[", "unique_classes", "[", "n", "]", ".", "astype", "(", "'int'", ")", "]", "=", "n", "\n", "", "classes_list", "=", "(", "classes_lut", "[", "classes_list", "]", ")", ".", "astype", "(", "'int'", ")", "\n", "\n", "# draw values", "\n", "means", "=", "draw_values", "(", "means_range", ",", "n_stats", ",", "'means_range'", ")", "\n", "stds", "=", "draw_values", "(", "std_devs_range", ",", "n_stats", ",", "'std_devs_range'", ")", "\n", "\n", "# reorder values", "\n", "means", "=", "means", "[", "classes_list", "]", "\n", "stds", "=", "stds", "[", "classes_list", "]", "\n", "\n", "return", "means", ",", "stds", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.means_stds_fs_labels_with_relations": [[208, 269], ["numpy.zeros", "numpy.uniform", "numpy.uniform", "numpy.uniform", "utils.draw_values", "numpy.concatenate", "numpy.concatenate", "utils.draw_values", "numpy.uniform", "numpy.uniform", "numpy.uniform", "numpy.uniform", "numpy.uniform", "numpy.uniform", "numpy.uniform", "numpy.uniform", "numpy.uniform", "numpy.uniform", "numpy.zeros", "numpy.zeros", "utils.draw_values", "sided_means.insert", "utils.draw_values", "sided_stds.insert", "abs", "numpy.uniform", "numpy.uniform", "numpy.uniform", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values"], ["", "def", "means_stds_fs_labels_with_relations", "(", "means_range", ",", "std_devs_range", ",", "min_diff", "=", "15", ",", "head", "=", "True", ")", ":", "\n", "\n", "# draw gm wm and csf means", "\n", "    ", "gm_wm_csf_means", "=", "np", ".", "zeros", "(", "3", ")", "\n", "while", "(", "abs", "(", "gm_wm_csf_means", "[", "1", "]", "-", "gm_wm_csf_means", "[", "0", "]", ")", "<", "min_diff", ")", "|", "(", "abs", "(", "gm_wm_csf_means", "[", "1", "]", "-", "gm_wm_csf_means", "[", "2", "]", ")", "<", "min_diff", ")", "|", "(", "abs", "(", "gm_wm_csf_means", "[", "0", "]", "-", "gm_wm_csf_means", "[", "2", "]", ")", "<", "min_diff", ")", ":", "\n", "        ", "gm_wm_csf_means", "=", "draw_values", "(", "means_range", ",", "3", ",", "'means_range'", ")", "\n", "\n", "# apply relations", "\n", "", "wm", "=", "gm_wm_csf_means", "[", "0", "]", "\n", "gm", "=", "gm_wm_csf_means", "[", "1", "]", "\n", "csf", "=", "gm_wm_csf_means", "[", "2", "]", "\n", "csf_like", "=", "csf", "*", "npr", ".", "uniform", "(", "low", "=", "0.95", ",", "high", "=", "1.05", ")", "\n", "alpha_thalamus", "=", "npr", ".", "uniform", "(", "low", "=", "0.4", ",", "high", "=", "0.9", ")", "\n", "thalamus", "=", "alpha_thalamus", "*", "gm", "+", "(", "1", "-", "alpha_thalamus", ")", "*", "wm", "\n", "cerebellum_wm", "=", "wm", "*", "npr", ".", "uniform", "(", "low", "=", "0.7", ",", "high", "=", "1.3", ")", "\n", "cerebellum_gm", "=", "gm", "*", "npr", ".", "uniform", "(", "low", "=", "0.7", ",", "high", "=", "1.3", ")", "\n", "caudate", "=", "gm", "*", "npr", ".", "uniform", "(", "low", "=", "0.9", ",", "high", "=", "1.1", ")", "\n", "putamen", "=", "gm", "*", "npr", ".", "uniform", "(", "low", "=", "0.9", ",", "high", "=", "1.1", ")", "\n", "hippocampus", "=", "gm", "*", "npr", ".", "uniform", "(", "low", "=", "0.9", ",", "high", "=", "1.1", ")", "\n", "amygdala", "=", "gm", "*", "npr", ".", "uniform", "(", "low", "=", "0.9", ",", "high", "=", "1.1", ")", "\n", "accumbens", "=", "caudate", "*", "npr", ".", "uniform", "(", "low", "=", "0.9", ",", "high", "=", "1.1", ")", "\n", "pallidum", "=", "wm", "*", "npr", ".", "uniform", "(", "low", "=", "0.8", ",", "high", "=", "1.2", ")", "\n", "brainstem", "=", "wm", "*", "npr", ".", "uniform", "(", "low", "=", "0.8", ",", "high", "=", "1.2", ")", "\n", "alpha_ventralDC", "=", "npr", ".", "uniform", "(", "low", "=", "0.1", ",", "high", "=", "0.6", ")", "\n", "ventralDC", "=", "alpha_ventralDC", "*", "gm", "+", "(", "1", "-", "alpha_ventralDC", ")", "*", "wm", "\n", "alpha_choroid", "=", "npr", ".", "uniform", "(", "low", "=", "0.0", ",", "high", "=", "1.0", ")", "\n", "choroid", "=", "alpha_choroid", "*", "csf", "+", "(", "1", "-", "alpha_choroid", ")", "*", "wm", "\n", "\n", "# regroup structures", "\n", "neutral_means", "=", "[", "np", ".", "zeros", "(", "1", ")", ",", "csf_like", ",", "csf_like", ",", "brainstem", ",", "csf", "]", "\n", "sided_means", "=", "[", "wm", ",", "gm", ",", "csf_like", ",", "csf_like", ",", "cerebellum_wm", ",", "cerebellum_gm", ",", "thalamus", ",", "caudate", ",", "putamen", ",", "pallidum", ",", "\n", "hippocampus", ",", "amygdala", ",", "accumbens", ",", "ventralDC", ",", "choroid", "]", "\n", "\n", "# draw std deviations", "\n", "std", "=", "draw_values", "(", "std_devs_range", ",", "17", ",", "'std_devs_range'", ")", "\n", "neutral_stds", "=", "[", "np", ".", "zeros", "(", "1", ")", ",", "std", "[", "1", "]", ",", "std", "[", "1", "]", ",", "std", "[", "2", "]", ",", "std", "[", "3", "]", "]", "\n", "sided_stds", "=", "[", "std", "[", "4", "]", ",", "std", "[", "5", "]", ",", "std", "[", "1", "]", ",", "std", "[", "1", "]", ",", "std", "[", "6", "]", ",", "std", "[", "7", "]", ",", "std", "[", "8", "]", ",", "std", "[", "9", "]", ",", "std", "[", "10", "]", ",", "std", "[", "11", "]", ",", "std", "[", "12", "]", ",", "std", "[", "13", "]", ",", "\n", "std", "[", "14", "]", ",", "std", "[", "15", "]", ",", "std", "[", "16", "]", "]", "\n", "\n", "# add means and variances for extra head labels if necessary", "\n", "if", "head", ":", "\n", "# means", "\n", "        ", "extra_means", "=", "draw_values", "(", "means_range", ",", "2", ",", "'means_range'", ")", "\n", "skull", "=", "extra_means", "[", "0", "]", "\n", "soft_non_brain", "=", "extra_means", "[", "1", "]", "\n", "eye", "=", "csf", "*", "npr", ".", "uniform", "(", "low", "=", "0.95", ",", "high", "=", "1.05", ")", "\n", "optic_chiasm", "=", "wm", "*", "npr", ".", "uniform", "(", "low", "=", "0.8", ",", "high", "=", "1.2", ")", "\n", "vessel", "=", "csf", "*", "npr", ".", "uniform", "(", "low", "=", "0.7", ",", "high", "=", "1.3", ")", "\n", "neutral_means", "+=", "[", "csf_like", ",", "optic_chiasm", ",", "skull", ",", "soft_non_brain", ",", "eye", "]", "\n", "sided_means", ".", "insert", "(", "-", "1", ",", "vessel", ")", "\n", "# std dev", "\n", "extra_std", "=", "draw_values", "(", "std_devs_range", ",", "4", ",", "'std_devs_range'", ")", "\n", "neutral_stds", "+=", "[", "std", "[", "1", "]", ",", "extra_std", "[", "0", "]", ",", "extra_std", "[", "1", "]", ",", "extra_std", "[", "2", "]", ",", "std", "[", "1", "]", "]", "\n", "sided_stds", ".", "insert", "(", "-", "1", ",", "extra_std", "[", "3", "]", ")", "\n", "\n", "", "means", "=", "np", ".", "concatenate", "(", "[", "np", ".", "array", "(", "neutral_means", ")", ",", "np", ".", "array", "(", "sided_means", ")", ",", "np", ".", "array", "(", "sided_means", ")", "]", ")", "\n", "stds", "=", "np", ".", "concatenate", "(", "[", "np", ".", "array", "(", "neutral_stds", ")", ",", "np", ".", "array", "(", "sided_stds", ")", ",", "np", ".", "array", "(", "sided_stds", ")", "]", ")", "\n", "\n", "return", "means", ",", "stds", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.means_stds_with_stats": [[271, 282], ["utils.draw_values", "utils.draw_values", "numpy.concatenate", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values"], ["", "def", "means_stds_with_stats", "(", "n_sided", ",", "n_neutral", ",", "means_range", ",", "std_devs_range", ")", ":", "\n", "\n", "# draw values", "\n", "    ", "means", "=", "draw_values", "(", "means_range", "[", ":", ",", ":", "n_sided", "+", "n_neutral", "]", ",", "n_sided", "+", "n_neutral", ",", "'means_range'", ")", "\n", "stds", "=", "draw_values", "(", "std_devs_range", "[", ":", ",", ":", "n_sided", "+", "n_neutral", "]", ",", "n_sided", "+", "n_neutral", ",", "'std_devs_range'", ")", "\n", "\n", "# regroup neutral and sided labels", "\n", "means", "=", "np", ".", "concatenate", "(", "[", "means", "[", ":", "n_neutral", "]", ",", "means", "[", "n_neutral", ":", "]", ",", "means", "[", "n_neutral", ":", "]", "]", ")", "\n", "stds", "=", "np", ".", "concatenate", "(", "[", "stds", "[", ":", "n_neutral", "]", ",", "stds", "[", "n_neutral", ":", "]", ",", "stds", "[", "n_neutral", ":", "]", "]", ")", "\n", "\n", "return", "means", ",", "stds", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.means_stds_classes_with_stats": [[284, 305], ["numpy.unique", "utils.draw_values", "utils.draw_values", "numpy.zeros", "numpy.zeros", "enumerate"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values"], ["", "def", "means_stds_classes_with_stats", "(", "classes_list", ",", "means_range", ",", "std_devs_range", ")", ":", "\n", "\n", "# get unique classes and corresponding stats", "\n", "    ", "unique_classes", ",", "unique_idx", "=", "np", ".", "unique", "(", "classes_list", ",", "return_index", "=", "True", ")", "\n", "n_unique", "=", "unique_classes", ".", "shape", "[", "0", "]", "\n", "unique_means_range", "=", "means_range", "[", ":", ",", "unique_idx", "]", "\n", "unique_std_devs_range", "=", "std_devs_range", "[", ":", ",", "unique_idx", "]", "\n", "\n", "# draw values", "\n", "unique_means", "=", "draw_values", "(", "unique_means_range", ",", "n_unique", ",", "'means_range'", ")", "\n", "unique_stds", "=", "draw_values", "(", "unique_std_devs_range", ",", "n_unique", ",", "'std_devs_range'", ")", "\n", "\n", "# put stats back in order", "\n", "n_classes", "=", "classes_list", ".", "shape", "[", "0", "]", "\n", "means", "=", "np", ".", "zeros", "(", "(", "n_classes", ",", "1", ")", ")", "\n", "stds", "=", "np", ".", "zeros", "(", "(", "n_classes", ",", "1", ")", ")", "\n", "for", "idx_class", ",", "tmp_class", "in", "enumerate", "(", "unique_classes", ")", ":", "\n", "        ", "means", "[", "classes_list", "==", "tmp_class", "]", "=", "unique_means", "[", "idx_class", "]", "\n", "stds", "[", "classes_list", "==", "tmp_class", "]", "=", "unique_stds", "[", "idx_class", "]", "\n", "\n", "", "return", "means", ",", "stds", "\n", "\n"]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.model_input_generator.draw_rotation_angle": [[307, 331], ["isinstance", "isinstance", "isinstance", "numpy.uniform", "numpy.uniform", "numpy.uniform", "Exception", "isinstance", "Exception", "len"], "function", ["None"], ["", "def", "draw_rotation_angle", "(", "rotation_range", ",", "n_dims", ")", ":", "\n", "# reformat rotation_range", "\n", "    ", "if", "not", "isinstance", "(", "rotation_range", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "if", "rotation_range", "is", "None", ":", "\n", "            ", "rotation_range", "=", "[", "-", "10", ",", "10", "]", "\n", "", "elif", "isinstance", "(", "rotation_range", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "rotation_range", "=", "[", "-", "rotation_range", ",", "rotation_range", "]", "\n", "", "elif", "isinstance", "(", "rotation_range", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "assert", "len", "(", "rotation_range", ")", "==", "2", ",", "'if list, rotation_range should be of length 2.'", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'If not numpy array, rotation_range should be None, int, float or list.'", ")", "\n", "", "if", "n_dims", "==", "2", ":", "\n", "            ", "rotation_angle", "=", "npr", ".", "uniform", "(", "low", "=", "rotation_range", "[", "0", "]", ",", "high", "=", "rotation_range", "[", "1", "]", ",", "size", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "rotation_angle", "=", "npr", ".", "uniform", "(", "low", "=", "rotation_range", "[", "0", "]", ",", "high", "=", "rotation_range", "[", "1", "]", ",", "size", "=", "n_dims", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "rotation_range", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "assert", "rotation_range", ".", "shape", "==", "(", "2", ",", "n_dims", ")", ",", "'rotation_range should be array of size {}'", ".", "format", "(", "(", "2", ",", "n_dims", ")", ")", "\n", "rotation_angle", "=", "npr", ".", "uniform", "(", "low", "=", "rotation_range", "[", "0", ",", ":", "]", ",", "high", "=", "rotation_range", "[", "1", ",", ":", "]", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'rotation_range should be None, int, float, list or numpy array'", ")", "\n", "\n", "", "return", "rotation_angle", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.labels_to_image_model.labels_to_image_model": [[13, 314], ["len", "utils.format_target_res", "utils.get_shapes", "numpy.arange", "numpy.zeros", "range", "tensorflow.Input", "tensorflow.Input", "tensorflow.Input", "tensorflow.Model", "tensorflow.Lambda", "numpy.transpose", "enumerate", "tensorflow.Lambda", "tuple", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.concat", "tensorflow.Lambda", "tensorflow.gather", "tensorflow.map_fn", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Multiply", "tensorflow.Add", "numpy.meshgrid", "range", "utils.get_bias_field_shape", "tensorflow.Input", "list_inputs.append", "tuple", "tuple", "tensorflow.multiply", "tensorflow.Lambda", "tensorflow.Lambda", "enumerate", "tensorflow.Lambda", "tensorflow.Lambda", "outputs.append", "numpy.max().astype", "numpy.array", "tensorflow.Lambda", "labels.get_shape().as_list", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "neurite.layers.Resize", "labels.get_shape().as_list", "tensorflow.Input", "list_inputs.append", "trans_inputs.append", "utils.get_nonlin_field_shape", "tensorflow.Input", "list_inputs.append", "trans_inputs.append", "neurite.layers.SpatialTransformer", "tensorflow.reshape", "tensorflow.cast", "numpy.arange", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "neurite.layers.Resize", "tensorflow.Lambda", "KL.multiply.get_shape().as_list", "bias_field.get_shape().as_list", "len", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "generation_label_list[].astype", "tensorflow.gather", "range", "tensorflow.cast", "zip", "neurite.layers.Resize", "neurite.layers.VecInt", "neurite.layers.Resize", "tensorflow.cast", "tensorflow.random.normal", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "zip", "tensorflow.clip", "tensorflow.gather", "tensorflow.math.pow", "numpy.max", "tensorflow.convert_to_tensor", "tensorflow.cast", "tensorflow.pad", "labels.get_shape", "tensorflow.zeros", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.concat", "tensorflow.convert_to_tensor", "tensorflow.slice", "tensorflow.cast", "labels.get_shape", "zip", "tensorflow.shape", "range", "tensorflow.constant", "tensorflow.random.uniform", "tensorflow.map_fn", "tensorflow.exp", "range", "tensorflow.convert_to_tensor", "tensorflow.nn.convolution", "tensorflow.where", "tensorflow.split", "tensorflow.nn.convolution", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.exp", "KL.multiply.get_shape", "bias_field.get_shape", "tensorflow.random.uniform", "tensorflow.cast", "tensorflow.cast", "tensorflow.min", "tensorflow.max", "tensorflow.math.exp", "tensorflow.cast", "numpy.stack", "tensorflow.reduce_sum", "utils.add_axis", "tensorflow.greater", "tensorflow.ones_like", "tensorflow.zeros_like", "tensorflow.nn.convolution", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.greater", "tensorflow.switch", "tensorflow.switch", "tensorflow.where", "tensorflow.greater", "tensorflow.switch", "tensorflow.nn.convolution", "tensorflow.where", "tensorflow.concat", "tensorflow.random.uniform", "tensorflow.zeros", "tensorflow.random.normal", "tensorflow.convert_to_tensor", "tensorflow.concat", "tensorflow.concat", "tensorflow.cast", "tensorflow.zeros", "tensorflow.cast", "tensorflow.cast", "tensorflow.reduce_sum", "utils.add_axis", "tensorflow.random.uniform", "tensorflow.cast", "tensorflow.random.uniform", "tensorflow.greater", "tensorflow.ones_like", "tensorflow.zeros_like", "tensorflow.nn.convolution", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.greater", "tensorflow.switch", "tensorflow.switch", "tensorflow.where", "tensorflow.greater", "tensorflow.switch", "utils.gauss_kernel", "tensorflow.epsilon", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.random.normal", "tensorflow.Lambda", "tensorflow.random.uniform", "tensorflow.cast", "tensorflow.random.uniform", "tensorflow.cast", "tensorflow.random_uniform", "tensorflow.cast", "tensorflow.zeros", "tensorflow.shape", "tensorflow.epsilon", "tensorflow.Lambda", "tensorflow.Lambda", "tensorflow.random.normal", "tensorflow.Lambda", "tensorflow.zeros_like", "tensorflow.zeros_like", "tensorflow.where", "tensorflow.shape", "tensorflow.cast", "tensorflow.zeros_like", "tensorflow.zeros_like", "tensorflow.zeros_like", "tensorflow.where", "tensorflow.cast", "tensorflow.zeros_like"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.format_target_res", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_shapes", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.meshgrid", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_bias_field_shape", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_nonlin_field_shape", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.py.utils.pad", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.slice", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.gauss_kernel"], ["def", "labels_to_image_model", "(", "labels_shape", ",", "\n", "crop_shape", ",", "\n", "generation_label_list", ",", "\n", "segmentation_label_list", ",", "\n", "n_channels", "=", "1", ",", "\n", "labels_res", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "target_res", "=", "None", ",", "\n", "padding_margin", "=", "None", ",", "\n", "apply_affine_trans", "=", "False", ",", "\n", "apply_nonlin_trans", "=", "True", ",", "\n", "nonlin_shape_factor", "=", "0.0625", ",", "\n", "apply_bias_field", "=", "True", ",", "\n", "bias_shape_factor", "=", "0.025", ",", "\n", "blur_background", "=", "True", ",", "\n", "normalise", "=", "True", ",", "\n", "out_div_32", "=", "False", ",", "\n", "convert_back", "=", "False", ",", "\n", "id", "=", "0", ",", "# For different layer names if several models.", "\n", "rand_blur", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n        This function builds a keras/tensorflow model to generate brain images from supplied labels.\n        It returns the model as well as the shape ouf the output images without batch and channel dimensions\n        (height*width*depth).\n        The model takes as inputs:\n            -a label image\n            -a vector containing the means of the Gaussian distributions to sample for each label,\n            -a similar vector for the associated standard deviations.\n            -if apply_affine_deformation=True: a (n_dims+1)x(n_dims+1) affine matrix\n            -if apply_non_linear_deformation=True: a small non linear field of size batch*x*y*z*n_dims that will be\n             resampled to labels size\n            -if apply_bias_field=True: a small bias field of size batch*x*y*z*1 that will be resampled to labels size\n        The model returns:\n            -the generated image\n            -the corresponding label map\n    :param labels_shape: should be a list or tensor with image dimension plus channel size at the end\n    :param n_channels: number of channels to be synthetised\n    :param labels_res: list of dimension resolutions of model's inputs\n    :param target_res: list of dimension resolutions of model's outputs\n    :param crop_shape: list, shape of model's outputs\n    :param generation_label_list: list of all the labels in the dataset (internally converted to [0...N-1] and converted\n    back to original values at the end of model)\n    :param segmentation_label_list: list of all the labels in the output labels (internally converted to [0...N-1] and\n    converted back to original values at the end of model)\n    :param padding_margin: margin by which the input labels will be 0-padded. This step happens\n    before an eventual cropping. Default is None, no padding.\n    :param apply_affine_trans: whether to apply affine deformation during generation\n    :param apply_nonlin_trans: whether to apply non linear deformation during generation\n    :param nonlin_shape_factor: if apply_non_linear_deformation=True, factor between the shapes of the labels and of\n    the non-linear field that will be sampled\n    :param apply_bias_field: whether to apply a bias field to the created image during generation\n    :param bias_shape_factor: if apply_bias_field=True, factor between the shapes of the labels and of the bias field\n    that will be sampled\n    :param blur_background: Whether background is a regular label, thus blurred with the others.\n    :param normalise: whether to normalise data. Default is False.\n    :param out_div_32: whether model's outputs must be of shape divisible by 32\n    \"\"\"", "\n", "\n", "# get shapes", "\n", "n_dims", "=", "len", "(", "labels_shape", ")", "\n", "target_res", "=", "format_target_res", "(", "target_res", ",", "n_dims", ")", "\n", "crop_shape", ",", "resample_shape", ",", "output_shape", ",", "padding_margin", "=", "get_shapes", "(", "labels_shape", ",", "\n", "crop_shape", ",", "\n", "labels_res", ",", "\n", "target_res", ",", "\n", "padding_margin", ",", "\n", "out_div_32", ")", "\n", "# create new_label_list and corresponding LUT to make sure that labels go from 0 to N-1", "\n", "n_generation_labels", "=", "generation_label_list", ".", "shape", "[", "0", "]", "\n", "new_generation_label_list", "=", "np", ".", "arange", "(", "n_generation_labels", ")", "\n", "lut", "=", "np", ".", "zeros", "(", "np", ".", "max", "(", "generation_label_list", ")", ".", "astype", "(", "'int'", ")", "+", "1", ")", "\n", "for", "n", "in", "range", "(", "n_generation_labels", ")", ":", "\n", "        ", "lut", "[", "generation_label_list", "[", "n", "]", ".", "astype", "(", "'int'", ")", "]", "=", "n", "\n", "\n", "# define mandatory inputs", "\n", "", "labels_input", "=", "KL", ".", "Input", "(", "shape", "=", "(", "*", "labels_shape", ",", "1", ")", ",", "name", "=", "f'labels_input_{id}'", ")", "\n", "means_input", "=", "KL", ".", "Input", "(", "shape", "=", "(", "*", "new_generation_label_list", ".", "shape", ",", "n_channels", ")", ",", "name", "=", "f'means_input_{id}'", ")", "\n", "std_devs_input", "=", "KL", ".", "Input", "(", "shape", "=", "(", "*", "new_generation_label_list", ".", "shape", ",", "n_channels", ")", ",", "name", "=", "f'std_devs_input_{id}'", ")", "\n", "list_inputs", "=", "[", "labels_input", ",", "means_input", ",", "std_devs_input", "]", "\n", "\n", "# convert labels to new_label_list", "\n", "labels", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "gather", "(", "tf", ".", "convert_to_tensor", "(", "lut", ",", "dtype", "=", "'int32'", ")", ",", "\n", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "'int32'", ")", ")", ",", "name", "=", "f'convert_labels_{id}'", ")", "(", "labels_input", ")", "\n", "\n", "# pad labels", "\n", "if", "padding_margin", "is", "not", "None", ":", "\n", "        ", "pad", "=", "np", ".", "transpose", "(", "np", ".", "array", "(", "[", "[", "0", "]", "+", "padding_margin", "+", "[", "0", "]", "]", "*", "2", ")", ")", "\n", "labels", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "pad", "(", "x", ",", "tf", ".", "cast", "(", "tf", ".", "convert_to_tensor", "(", "pad", ")", ",", "dtype", "=", "'int32'", ")", ")", ",", "name", "=", "f'pad_{id}'", ")", "(", "labels", ")", "\n", "labels_shape", "=", "labels", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "-", "1", "]", "\n", "\n", "# cropping", "\n", "", "if", "crop_shape", "is", "not", "None", ":", "\n", "# get maximum cropping indices in each dimension", "\n", "        ", "cropping_max_val", "=", "[", "labels_shape", "[", "i", "]", "-", "crop_shape", "[", "i", "]", "for", "i", "in", "range", "(", "n_dims", ")", "]", "\n", "# prepare cropping indices and tensor's new shape", "\n", "idx", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "zeros", "(", "[", "1", "]", ",", "dtype", "=", "'int32'", ")", ",", "name", "=", "f'no_cropping_batch_{id}'", ")", "(", "means_input", ")", "# no cropping", "\n", "for", "val_idx", ",", "val", "in", "enumerate", "(", "cropping_max_val", ")", ":", "# draw cropping indices for image dimensions", "\n", "            ", "if", "val", ">", "0", ":", "\n", "                ", "idx", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "concat", "(", "\n", "[", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "'int32'", ")", ",", "K", ".", "random_uniform", "(", "[", "1", "]", ",", "minval", "=", "0", ",", "maxval", "=", "val", ",", "dtype", "=", "'int32'", ")", "]", ",", "axis", "=", "0", ")", ",", "\n", "name", "=", "f'pick_cropping_idx_{val_idx}_{id}'", ")", "(", "idx", ")", "\n", "", "else", ":", "\n", "                ", "idx", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "concat", "(", "[", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "'int32'", ")", ",", "tf", ".", "zeros", "(", "[", "1", "]", ",", "dtype", "=", "'int32'", ")", "]", ",", "axis", "=", "0", ")", ",", "\n", "name", "=", "f'pick_cropping_idx_{val_idx}_{id}'", ")", "(", "idx", ")", "\n", "", "", "idx", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "concat", "(", "[", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "'int32'", ")", ",", "tf", ".", "zeros", "(", "[", "1", "]", ",", "dtype", "=", "'int32'", ")", "]", ",", "axis", "=", "0", ")", ",", "\n", "name", "=", "f'no_cropping_channel_{id}'", ")", "(", "idx", ")", "# no cropping for channel dimension", "\n", "patch_shape_tens", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "convert_to_tensor", "(", "[", "-", "1", "]", "+", "crop_shape", "+", "[", "-", "1", "]", ",", "dtype", "=", "'int32'", ")", ",", "\n", "name", "=", "f'tensor_cropping_idx_{id}'", ")", "(", "means_input", ")", "\n", "# perform cropping", "\n", "labels", "=", "KL", ".", "Lambda", "(", "\n", "lambda", "x", ":", "tf", ".", "slice", "(", "x", "[", "0", "]", ",", "begin", "=", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "dtype", "=", "'int32'", ")", ",", "size", "=", "tf", ".", "cast", "(", "x", "[", "2", "]", ",", "dtype", "=", "'int32'", ")", ")", ",", "\n", "name", "=", "f'cropping_{id}'", ")", "(", "[", "labels", ",", "idx", ",", "patch_shape_tens", "]", ")", "\n", "", "else", ":", "\n", "        ", "crop_shape", "=", "labels_shape", "\n", "\n", "", "labels", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "'float'", ")", ")", "(", "labels", ")", "\n", "\n", "# if necessary, resample image and labels at target resolution", "\n", "if", "resample_shape", "is", "not", "None", ":", "\n", "        ", "labels", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "'float32'", ")", ")", "(", "labels", ")", "\n", "zoom_fact", "=", "[", "r", "/", "l", "for", "r", ",", "l", "in", "zip", "(", "resample_shape", ",", "labels_shape", ")", "]", "\n", "labels", "=", "nrn_layers", ".", "Resize", "(", "zoom_fact", ",", "interp_method", "=", "'nearest'", ",", "name", "=", "f'resample_labels_{id}'", ")", "(", "labels", ")", "\n", "\n", "# deform labels", "\n", "", "if", "apply_affine_trans", "|", "apply_nonlin_trans", ":", "\n", "        ", "labels", ".", "_keras_shape", "=", "tuple", "(", "labels", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "\n", "trans_inputs", "=", "[", "labels", "]", "\n", "# add affine deformation to inputs list", "\n", "if", "apply_affine_trans", ":", "\n", "            ", "aff_in", "=", "KL", ".", "Input", "(", "shape", "=", "(", "n_dims", "+", "1", ",", "n_dims", "+", "1", ")", ",", "name", "=", "f'aff_input_{id}'", ")", "\n", "list_inputs", ".", "append", "(", "aff_in", ")", "\n", "trans_inputs", ".", "append", "(", "aff_in", ")", "\n", "# prepare non-linear deformation field and add it to inputs list", "\n", "", "if", "apply_nonlin_trans", ":", "\n", "            ", "def_field_size", "=", "get_nonlin_field_shape", "(", "crop_shape", ",", "nonlin_shape_factor", ")", "\n", "nonlin_field_in", "=", "KL", ".", "Input", "(", "shape", "=", "def_field_size", ",", "name", "=", "f'nonlin_input_{id}'", ")", "\n", "list_inputs", ".", "append", "(", "nonlin_field_in", ")", "\n", "int_at", "=", "2.0", "\n", "zoom", "=", "[", "o", "/", "d", "/", "int_at", "for", "o", ",", "d", "in", "zip", "(", "output_shape", ",", "def_field_size", ")", "]", "\n", "vel_field", "=", "nonlin_field_in", "\n", "vel_field", "=", "nrn_layers", ".", "Resize", "(", "zoom", ",", "interp_method", "=", "'linear'", ",", "name", "=", "f'resize_vel_{id}'", ")", "(", "vel_field", ")", "\n", "def_field", "=", "nrn_layers", ".", "VecInt", "(", "int_steps", "=", "5", ")", "(", "vel_field", ")", "\n", "# def_field = nrn_layers.RescaleValues(int_at)(def_field)", "\n", "def_field", "=", "nrn_layers", ".", "Resize", "(", "int_at", ",", "interp_method", "=", "'linear'", ",", "name", "=", "f'resize_def_{id}'", ")", "(", "def_field", ")", "\n", "trans_inputs", ".", "append", "(", "def_field", ")", "\n", "\n", "# apply deformations", "\n", "", "labels", "=", "nrn_layers", ".", "SpatialTransformer", "(", "interp_method", "=", "'nearest'", ",", "name", "=", "f'trans_{id}'", ")", "(", "trans_inputs", ")", "\n", "", "labels", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "'int32'", ")", ")", "(", "labels", ")", "\n", "\n", "# sample from normal distribution", "\n", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "random", ".", "normal", "(", "tf", ".", "shape", "(", "x", ")", ")", ",", "name", "=", "f'sample_normal_{id}'", ")", "(", "labels", ")", "\n", "\n", "# build synthetic image", "\n", "f_cat", "=", "lambda", "x", ":", "tf", ".", "concat", "(", "[", "x", "+", "n_generation_labels", "*", "i", "for", "i", "in", "range", "(", "n_channels", ")", "]", ",", "-", "1", ")", "\n", "cat_labels", "=", "KL", ".", "Lambda", "(", "f_cat", ",", "name", "=", "f'cat_labels_{id}'", ")", "(", "labels", ")", "\n", "f_gather", "=", "lambda", "x", ":", "tf", ".", "gather", "(", "tf", ".", "reshape", "(", "x", "[", "0", "]", ",", "[", "-", "1", "]", ")", ",", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "dtype", "=", "'int32'", ")", ")", "\n", "f_map", "=", "lambda", "x", ":", "tf", ".", "map_fn", "(", "f_gather", ",", "x", ",", "dtype", "=", "'float32'", ")", "\n", "means", "=", "KL", ".", "Lambda", "(", "f_map", ")", "(", "[", "means_input", ",", "cat_labels", "]", ")", "\n", "std_devs", "=", "KL", ".", "Lambda", "(", "f_map", ")", "(", "[", "std_devs_input", ",", "cat_labels", "]", ")", "\n", "image", "=", "KL", ".", "Multiply", "(", "name", "=", "f'mul_std_dev_{id}'", ")", "(", "[", "image", ",", "std_devs", "]", ")", "\n", "image", "=", "KL", ".", "Add", "(", "name", "=", "f'add_means_{id}'", ")", "(", "[", "image", ",", "means", "]", ")", "\n", "\n", "if", "rand_blur", ":", "\n", "        ", "shape", "=", "[", "5", "]", "*", "n_dims", "\n", "lim", "=", "[", "(", "s", "-", "1", ")", "/", "2", "for", "s", "in", "shape", "]", "\n", "lim", "=", "[", "np", ".", "arange", "(", "-", "l", ",", "l", "+", "1", ")", "for", "l", "in", "lim", "]", "\n", "grid", "=", "np", ".", "meshgrid", "(", "*", "lim", ",", "indexing", "=", "'ij'", ")", "\n", "grid", "=", "[", "g", "**", "2", "for", "g", "in", "grid", "]", "\n", "c_grid", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "constant", "(", "np", ".", "stack", "(", "grid", ")", ",", "dtype", "=", "'float32'", ")", ")", "(", "[", "]", ")", "\n", "sigma", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "random", ".", "uniform", "(", "(", "n_dims", ",", ")", ",", "minval", "=", "1e-6", ",", "maxval", "=", "1", ")", ")", "(", "[", "]", ")", "\n", "f", "=", "lambda", "x", ":", "x", "[", "0", "]", "/", "x", "[", "1", "]", "**", "2", "\n", "kernel", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "map_fn", "(", "f", ",", "x", ",", "dtype", "=", "'float32'", ")", ")", "(", "[", "c_grid", ",", "sigma", "]", ")", "\n", "kernel", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "exp", "(", "-", "tf", ".", "reduce_sum", "(", "x", ",", "axis", "=", "0", ")", ")", ")", "(", "kernel", ")", "\n", "kernel", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "...", ",", "None", ",", "None", "]", "/", "tf", ".", "reduce_sum", "(", "x", ")", ")", "(", "kernel", ")", "\n", "", "else", ":", "\n", "        ", "if", "(", "target_res", "is", "None", ")", "|", "(", "labels_res", "==", "target_res", ")", ":", "\n", "            ", "sigma", "=", "[", "0.55", "]", "*", "n_dims", "\n", "", "else", ":", "\n", "            ", "sigma", "=", "[", "0.85", "*", "labels_res", "[", "i", "]", "/", "target_res", "[", "i", "]", "for", "i", "in", "range", "(", "n_dims", ")", "]", "\n", "", "kernel", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "convert_to_tensor", "(", "add_axis", "(", "add_axis", "(", "gauss_kernel", "(", "sigma", ",", "n_dims", ")", ",", "-", "1", ")", ",", "-", "1", ")", ",", "\n", "dtype", "=", "x", ".", "dtype", ")", ",", "name", "=", "f'gauss_kernel_{id}'", ")", "(", "image", ")", "\n", "\n", "", "if", "n_channels", "==", "1", ":", "\n", "        ", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "nn", ".", "convolution", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "padding", "=", "'SAME'", ",", "strides", "=", "[", "1", "]", "*", "n_dims", ")", ",", "\n", "name", "=", "f'blur_image_{id}'", ")", "(", "[", "image", ",", "kernel", "]", ")", "\n", "mask", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "where", "(", "tf", ".", "greater", "(", "x", ",", "0", ")", ",", "tf", ".", "ones_like", "(", "x", ",", "dtype", "=", "'float32'", ")", ",", "\n", "tf", ".", "zeros_like", "(", "x", ",", "dtype", "=", "'float32'", ")", ")", ",", "name", "=", "f'masking_{id}'", ")", "(", "labels", ")", "\n", "if", "not", "blur_background", ":", "\n", "            ", "blurred_mask", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "nn", ".", "convolution", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "padding", "=", "'SAME'", ",", "strides", "=", "[", "1", "]", "*", "n_dims", ")", ",", "\n", "name", "=", "f'blur_mask_{id}'", ")", "(", "[", "mask", ",", "kernel", "]", ")", "\n", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "0", "]", "/", "(", "x", "[", "1", "]", "+", "K", ".", "epsilon", "(", ")", ")", ",", "name", "=", "f'masked_blurring_{id}'", ")", "(", "[", "image", ",", "blurred_mask", "]", ")", "\n", "bckgd_mean", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", "1", ")", ",", "0", ",", "10", ")", ",", "name", "=", "f'bckgd_mean_{id}'", ")", "(", "[", "]", ")", "\n", "bckgd_std", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", "1", ")", ",", "0", ",", "5", ")", ",", "name", "=", "f'bckgd_std_{id}'", ")", "(", "[", "]", ")", "\n", "rand_flip", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "greater", "(", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", "1", ")", ",", "0", ",", "1", ")", ",", "0.5", ")", ",", "name", "=", "f'bool_{id}'", ")", "(", "[", "]", ")", "\n", "bckgd_mean", "=", "KL", ".", "Lambda", "(", "lambda", "y", ":", "K", ".", "switch", "(", "y", "[", "0", "]", ",", "\n", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "zeros_like", "(", "x", ")", ")", "(", "y", "[", "1", "]", ")", ",", "\n", "y", "[", "1", "]", ")", ",", "name", "=", "f'switch_backgd_mean_{id}'", ")", "(", "[", "rand_flip", ",", "bckgd_mean", "]", ")", "\n", "bckgd_std", "=", "KL", ".", "Lambda", "(", "lambda", "y", ":", "K", ".", "switch", "(", "y", "[", "0", "]", ",", "\n", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "zeros_like", "(", "x", ")", ")", "(", "y", "[", "1", "]", ")", ",", "\n", "y", "[", "1", "]", ")", ",", "name", "=", "f'switch_backgd_std_{id}'", ")", "(", "[", "rand_flip", ",", "bckgd_std", "]", ")", "\n", "background", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "1", "]", "+", "x", "[", "2", "]", "*", "tf", ".", "random", ".", "normal", "(", "tf", ".", "shape", "(", "x", "[", "0", "]", ")", ")", ",", "\n", "name", "=", "f'gaussian_bckgd_{id}'", ")", "(", "[", "image", ",", "bckgd_mean", ",", "bckgd_std", "]", ")", "\n", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "where", "(", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "dtype", "=", "'bool'", ")", ",", "x", "[", "0", "]", ",", "x", "[", "2", "]", ")", ",", "\n", "name", "=", "f'mask_blurred_image_{id}'", ")", "(", "[", "image", ",", "mask", ",", "background", "]", ")", "\n", "", "else", ":", "\n", "            ", "rand_flip", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "greater", "(", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", "1", ")", ",", "0", ",", "1", ")", ",", "0.8", ")", ",", "name", "=", "f'bool_{id}'", ")", "(", "[", "]", ")", "\n", "image", "=", "KL", ".", "Lambda", "(", "lambda", "y", ":", "K", ".", "switch", "(", "y", "[", "0", "]", ",", "KL", ".", "Lambda", "(", "\n", "lambda", "x", ":", "tf", ".", "where", "(", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "dtype", "=", "'bool'", ")", ",", "x", "[", "0", "]", ",", "tf", ".", "zeros_like", "(", "x", "[", "0", "]", ")", ")", ",", "name", "=", "f'mask_image_{id}'", ")", "(", "\n", "[", "y", "[", "1", "]", ",", "y", "[", "2", "]", "]", ")", ",", "y", "[", "1", "]", ")", ",", "name", "=", "f'switch_backgd_reset_{id}'", ")", "(", "[", "rand_flip", ",", "image", ",", "mask", "]", ")", "\n", "\n", "", "", "else", ":", "\n", "# blur each image channel separately", "\n", "        ", "split", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "split", "(", "x", ",", "[", "1", "]", "*", "n_channels", ",", "axis", "=", "-", "1", ")", ")", "(", "image", ")", "\n", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "nn", ".", "convolution", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "padding", "=", "'SAME'", ",", "strides", "=", "[", "1", "]", "*", "n_dims", ")", ",", "\n", "name", "=", "f'blurring_0_{id}'", ")", "(", "[", "split", "[", "0", "]", ",", "kernel", "]", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_channels", ")", ":", "\n", "            ", "temp_blurred", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "nn", ".", "convolution", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "padding", "=", "'SAME'", ",", "strides", "=", "[", "1", "]", "*", "n_dims", ")", ",", "\n", "name", "=", "f'blurring_{i}_{id}'", ")", "(", "[", "split", "[", "i", "]", ",", "kernel", "]", ")", "\n", "mask", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "where", "(", "tf", ".", "greater", "(", "x", ",", "0", ")", ",", "tf", ".", "ones_like", "(", "x", ",", "dtype", "=", "'float32'", ")", ",", "\n", "tf", ".", "zeros_like", "(", "x", ",", "dtype", "=", "'float32'", ")", ")", ",", "name", "=", "f'masking_{i}_{id}'", ")", "(", "labels", ")", "\n", "if", "not", "blur_background", ":", "\n", "                ", "blurred_mask", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "nn", ".", "convolution", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "padding", "=", "'SAME'", ",", "strides", "=", "[", "1", "]", "*", "n_dims", ")", ",", "\n", "name", "=", "f'blur_mask_{i}_{id}'", ")", "(", "[", "mask", ",", "kernel", "]", ")", "\n", "temp_blurred", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "0", "]", "/", "(", "x", "[", "1", "]", "+", "K", ".", "epsilon", "(", ")", ")", ",", "\n", "name", "=", "f'masked_blurring_{i}_{id}'", ")", "(", "[", "temp_blurred", ",", "blurred_mask", "]", ")", "\n", "bckgd_mean", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", "1", ")", ",", "0", ",", "10", ")", ",", "name", "=", "f'bckgd_mean_{i}_{id}'", ")", "(", "[", "]", ")", "\n", "bckgd_std", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", "1", ")", ",", "0", ",", "5", ")", ",", "name", "=", "f'bckgd_std_{i}_{id}'", ")", "(", "[", "]", ")", "\n", "rand_flip", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "greater", "(", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", "1", ")", ",", "0", ",", "1", ")", ",", "0.5", ")", ",", "name", "=", "f'bool{i}_{id}'", ")", "(", "[", "]", ")", "\n", "bckgd_mean", "=", "KL", ".", "Lambda", "(", "lambda", "y", ":", "K", ".", "switch", "(", "y", "[", "0", "]", ",", "\n", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "zeros_like", "(", "x", ",", "dtype", "=", "'float32'", ")", ")", "(", "y", "[", "1", "]", ")", ",", "\n", "y", "[", "1", "]", ")", ",", "name", "=", "f'switch_backgd_mean{i}_{id}'", ")", "(", "[", "rand_flip", ",", "bckgd_mean", "]", ")", "\n", "bckgd_std", "=", "KL", ".", "Lambda", "(", "lambda", "y", ":", "K", ".", "switch", "(", "y", "[", "0", "]", ",", "\n", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "zeros_like", "(", "x", ",", "dtype", "=", "'float32'", ")", ")", "(", "y", "[", "1", "]", ")", ",", "\n", "y", "[", "1", "]", ")", ",", "name", "=", "f'switch_backgd_std_{i}_{id}'", ")", "(", "[", "rand_flip", ",", "bckgd_std", "]", ")", "\n", "background", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "1", "]", "+", "x", "[", "2", "]", "*", "tf", ".", "random", ".", "normal", "(", "tf", ".", "shape", "(", "x", "[", "0", "]", ")", ")", ",", "\n", "name", "=", "f'gaussian_bckgd_{i}_{id}'", ")", "(", "[", "temp_blurred", ",", "bckgd_mean", ",", "bckgd_std", "]", ")", "\n", "temp_blurred", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "where", "(", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "dtype", "=", "'bool'", ")", ",", "x", "[", "0", "]", ",", "x", "[", "2", "]", ")", ",", "\n", "name", "=", "f'mask_blurred_image_{i}_{id}'", ")", "(", "[", "temp_blurred", ",", "mask", ",", "background", "]", ")", "\n", "", "else", ":", "\n", "                ", "rand_flip", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "greater", "(", "tf", ".", "random", ".", "uniform", "(", "(", "1", ",", "1", ")", ",", "0", ",", "1", ")", ",", "0.8", ")", ",", "name", "=", "f'boo{i}_{id}'", ")", "(", "[", "]", ")", "\n", "image", "=", "KL", ".", "Lambda", "(", "lambda", "y", ":", "K", ".", "switch", "(", "y", "[", "0", "]", ",", "KL", ".", "Lambda", "(", "\n", "lambda", "x", ":", "tf", ".", "where", "(", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "dtype", "=", "'bool'", ")", ",", "x", "[", "0", "]", ",", "tf", ".", "zeros_like", "(", "x", "[", "0", "]", ")", ")", ",", "name", "=", "f'mask_image_{i}_{id}'", ")", "(", "\n", "[", "y", "[", "1", "]", ",", "y", "[", "2", "]", "]", ")", ",", "y", "[", "1", "]", ")", ",", "name", "=", "f'switch_backgd_reset_{i}_{id}'", ")", "(", "[", "rand_flip", ",", "image", ",", "mask", "]", ")", "\n", "", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "concat", "(", "[", "x", "[", "0", "]", ",", "x", "[", "1", "]", "]", ",", "-", "1", ")", ",", "\n", "name", "=", "f'cat_blurring_{i}_{id}'", ")", "(", "[", "image", ",", "temp_blurred", "]", ")", "\n", "\n", "# apply bias field", "\n", "", "", "if", "apply_bias_field", ":", "\n", "# format bias field and add it to inputs list", "\n", "        ", "bias_field_size", "=", "get_bias_field_shape", "(", "output_shape", ",", "bias_shape_factor", ")", "\n", "bias_field_in", "=", "KL", ".", "Input", "(", "shape", "=", "bias_field_size", ",", "name", "=", "f'bias_input_{id}'", ")", "\n", "list_inputs", ".", "append", "(", "bias_field_in", ")", "\n", "# resize bias field and apply it to image", "\n", "zoom_fact", "=", "[", "o", "/", "d", "for", "o", ",", "d", "in", "zip", "(", "output_shape", ",", "bias_field_size", ")", "]", "\n", "bias_field", "=", "nrn_layers", ".", "Resize", "(", "zoom_fact", ",", "interp_method", "=", "'linear'", ",", "name", "=", "f'log_bias_{id}'", ")", "(", "bias_field_in", ")", "\n", "bias_field", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "exp", "(", "x", ")", ",", "name", "=", "f'bias_field_{id}'", ")", "(", "bias_field", ")", "\n", "image", ".", "_keras_shape", "=", "tuple", "(", "image", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "\n", "bias_field", ".", "_keras_shape", "=", "tuple", "(", "bias_field", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "\n", "image", "=", "KL", ".", "multiply", "(", "[", "bias_field", ",", "image", "]", ")", "\n", "\n", "# make sure image's intensities are between 0 and 255", "\n", "", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "clip", "(", "x", ",", "0", ",", "255", ")", ",", "name", "=", "f'clipping_{id}'", ")", "(", "image", ")", "\n", "\n", "# contrast stretching", "\n", "image", "=", "KL", ".", "Lambda", "(", "\n", "lambda", "x", ":", "x", "*", "tf", ".", "random", ".", "uniform", "(", "[", "1", "]", ",", "minval", "=", "0.6", ",", "maxval", "=", "1.4", ")", "+", "tf", ".", "random", ".", "uniform", "(", "[", "1", "]", ",", "minval", "=", "-", "30", ",", "maxval", "=", "30", ")", ",", "\n", "name", "=", "f'stretching_{id}'", ")", "(", "image", ")", "\n", "\n", "# convert labels back to original values and remove unwanted labels", "\n", "if", "convert_back", ":", "\n", "        ", "out_lut", "=", "[", "x", "if", "x", "in", "segmentation_label_list", "else", "0", "for", "x", "in", "generation_label_list", "]", "\n", "", "else", ":", "\n", "# Rebase wanted indices into [0, N-1] for one-hot encoding.", "\n", "        ", "n", "=", "0", "\n", "out_lut", "=", "[", "None", "]", "*", "len", "(", "generation_label_list", ")", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "generation_label_list", ")", ":", "\n", "            ", "out", "=", "-", "1", "\n", "if", "x", "in", "segmentation_label_list", ":", "\n", "                ", "out", "=", "n", "\n", "n", "+=", "1", "\n", "", "out_lut", "[", "i", "]", "=", "out", "\n", "", "", "labels", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "gather", "(", "tf", ".", "cast", "(", "out_lut", ",", "dtype", "=", "'int32'", ")", ",", "\n", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "'int32'", ")", ")", ",", "name", "=", "f'labels_back_{id}'", ")", "(", "labels", ")", "\n", "\n", "# normalise the produced image (include labels_out, so this layer is not removed when plugging in other keras model)", "\n", "if", "normalise", ":", "\n", "        ", "m", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "min", "(", "x", ")", ",", "name", "=", "f'min_{id}'", ")", "(", "image", ")", "\n", "M", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "max", "(", "x", ")", ",", "name", "=", "f'max_{id}'", ")", "(", "image", ")", "\n", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "(", "x", "[", "0", "]", "-", "x", "[", "1", "]", ")", "/", "(", "x", "[", "2", "]", "-", "x", "[", "1", "]", ")", ",", "name", "=", "f'normalisation_{id}'", ")", "(", "[", "image", ",", "m", ",", "M", "]", ")", "\n", "", "else", ":", "\n", "        ", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "0", "]", "+", "K", ".", "zeros", "(", "1", ")", ",", "name", "=", "f'dummy_{id}'", ")", "(", "[", "image", "]", ")", "\n", "\n", "# gamma augmentation", "\n", "", "image", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "math", ".", "pow", "(", "x", "[", "0", "]", ",", "tf", ".", "math", ".", "exp", "(", "tf", ".", "random", ".", "normal", "(", "[", "1", "]", ",", "mean", "=", "0", ",", "stddev", "=", "0.25", ")", ")", ")", ",", "\n", "name", "=", "f'gamma_{id}'", ")", "(", "[", "image", ",", "labels", "]", ")", "\n", "\n", "outputs", "=", "[", "image", ",", "labels", "]", "\n", "if", "apply_nonlin_trans", ":", "\n", "        ", "outputs", ".", "append", "(", "vel_field", ")", "\n", "", "brain_model", "=", "keras", ".", "Model", "(", "inputs", "=", "list_inputs", ",", "outputs", "=", "outputs", ")", "\n", "return", "brain_model", ",", "def_field_size", ",", "bias_field_size", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.rescale_volume": [[14, 33], ["numpy.maximum", "numpy.clip", "numpy.sort", "numpy.sort", "np.clip.flatten", "int", "int"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.utils.utils.flatten"], ["def", "get_backend", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns the currently used backend. Default is tensorflow unless the\n    NEURITE_BACKEND environment variable is set to 'pytorch'.\n    \"\"\"", "\n", "return", "'pytorch'", "if", "os", ".", "environ", ".", "get", "(", "'NEURITE_BACKEND'", ")", "==", "'pytorch'", "else", "'tensorflow'", "\n", "\n", "\n", "", "def", "softmax", "(", "x", ",", "axis", ")", ":", "\n", "    ", "\"\"\"\n    softmax of a numpy array along a given dimension\n    \"\"\"", "\n", "\n", "return", "np", ".", "exp", "(", "x", ")", "/", "np", ".", "sum", "(", "np", ".", "exp", "(", "x", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.rescale_images_in_folder": [[35, 46], ["utils.list_images_in_folder", "os.path.exists", "os.mkdir", "os.path.join", "os.path.basename", "utils.load_volfile", "utils.rescale_volume", "utils.save_volfile", "os.path.isfile"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.rescale_volume", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.divisors": [[48, 54], ["range", "sorted", "list", "int", "divs.update", "math.sqrt"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.find_closest_number_divisible_by_m": [[56, 71], ["int", "abs", "abs"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.gauss_kernel": [[73, 109], ["np.exp.sum", "isinstance", "list", "numpy.exp", "numpy.stack", "len", "math.ceil", "len", "len", "numpy.exp", "Exception", "float", "len", "len", "list.append", "list.append", "np.exp.max", "numpy.finfo"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis": [[111, 120], ["Exception"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_resample_factor": [[122, 136], ["isinstance", "len", "len", "len", "float", "range"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.format_target_res": [[138, 150], ["isinstance", "isinstance", "len", "len", "TypeError"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_padding_margin": [[152, 192], ["isinstance", "isinstance", "int", "isinstance", "isinstance", "max", "isinstance", "len", "len", "len", "len", "int", "isinstance", "isinstance", "len", "ValueError", "len", "ValueError", "range", "len", "ValueError", "isinstance", "ValueError", "int", "len", "ValueError", "len", "len", "range", "type", "int", "type", "type", "range", "type"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_shapes": [[194, 257], ["len", "utils.reformat_variable", "utils.reformat_variable", "min", "range", "utils.find_closest_number_divisible_by_m", "print", "int", "range", "int", "utils.find_closest_number_divisible_by_m", "print", "float", "range", "range", "range", "utils.find_closest_number_divisible_by_m"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.reformat_variable", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.reformat_variable", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.find_closest_number_divisible_by_m", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.find_closest_number_divisible_by_m", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.find_closest_number_divisible_by_m"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.build_training_generator": [[259, 267], ["next", "numpy.concatenate", "utils.add_axis", "numpy.zeros", "utils.add_axis", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_values": [[269, 287], ["utils.add_axis", "isinstance", "numpy.array", "numpy.array", "numpy.uniform", "numpy.array", "utils.add_axis", "isinstance", "numpy.uniform", "int", "numpy.randint", "utils.add_axis", "ValueError", "numpy.normal"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.add_axis"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.draw_data_augm_params": [[291, 318], ["numpy.random.uniform", "numpy.random.uniform", "utils.create_affine_transformation_matrix", "numpy.random.normal", "numpy.random.normal", "numpy.random.random", "numpy.random.randint", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.create_affine_transformation_matrix"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.create_affine_transformation_matrix": [[320, 382], ["numpy.eye", "numpy.eye", "numpy.eye", "numpy.append", "numpy.ones", "numpy.zeros", "numpy.zeros", "numpy.eye", "numpy.eye", "numpy.eye", "numpy.eye", "numpy.zeros", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.zeros", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.eye", "numpy.asarray", "numpy.sin", "numpy.asarray", "numpy.sin", "numpy.sin", "numpy.sin", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_nonlin_field_shape": [[384, 386], ["tuple", "math.ceil", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_bias_field_shape": [[388, 390], ["tuple", "math.ceil"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.crop_volume": [[392, 428], ["numpy.nonzero", "numpy.maximum", "numpy.minimum", "numpy.concatenate", "isinstance", "numpy.full", "numpy.array", "isinstance", "numpy.array", "numpy.array", "int", "int", "Exception", "numpy.min", "numpy.max"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.crop_array_with_idx": [[430, 443], ["Exception"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.check_labels": [[447, 488], ["utils.list_images_in_folder", "list", "list", "list", "list", "len", "enumerate", "list", "list", "len", "utils.load_volfile", "numpy.round().tolist", "numpy.unique().tolist", "numpy.around().tolist", "numpy.around().tolist", "print", "numpy.round().tolist", "list.append", "list.append", "list.append", "list.append", "list.append", "list.append", "print", "numpy.round", "numpy.array().tolist", "numpy.unique", "numpy.around", "numpy.around", "numpy.round", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.check_images_and_labels": [[490, 511], ["sorted", "sorted", "zip", "print", "utils.load_volfile", "utils.load_volfile", "numpy.round().tolist", "numpy.round().tolist", "os.path.join", "os.path.join", "print", "print", "print", "print", "print", "print", "os.listdir", "os.path.isfile", "os.listdir", "os.path.isfile", "os.path.basename", "numpy.round", "numpy.round", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.correct_labels": [[513, 563], ["utils.list_images_in_folder", "enumerate", "len", "os.path.exists", "os.mkdir", "os.path.basename", "os.path.join", "utils.load_volfile", "numpy.unique", "zip", "os.path.exists", "print", "utils.save_volfile", "print", "numpy.where", "isinstance", "numpy.savez_compressed", "ValueError", "len", "isinstance", "len", "numpy.stack", "numpy.argmin", "im.astype", "numpy.array", "scipy.ndimage.morphology.distance_transform_edt", "numpy.logical_not"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pytools.patchlib.stack"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.upsample_labels": [[565, 628], ["utils.list_images_in_folder", "numpy.load", "numpy.arange", "numpy.zeros", "range", "utils.get_image_info", "isinstance", "os.system", "os.path.join", "enumerate", "os.path.exists", "os.mkdir", "len", "os.path.join", "print", "utils.load_volfile", "os.path.basename().replace().replace().replace", "os.path.join", "os.path.join", "utils.load_volfile", "numpy.zeros", "utils.save_volfile", "numpy.max().astype", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "os.path.join", "os.path.join", "os.path.join", "utils.load_volfile", "os.path.join", "label_list[].astype", "len", "np.zeros.astype", "os.path.basename().replace().replace", "os.path.join", "os.path.join", "os.path.isfile", "utils.save_volfile", "os.path.isfile", "os.system", "os.path.join", "os.path.basename", "numpy.max", "str", "str", "str", "os.path.basename().replace", "str", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.arange", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_image_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.smooth_labels": [[630, 657], ["utils.list_images_in_folder", "utils.get_image_info", "numpy.load", "numpy.ones", "enumerate", "os.path.exists", "os.mkdir", "tuple", "print", "os.path.join", "os.path.join", "os.path.basename", "utils.load_volfile", "numpy.zeros", "numpy.zeros", "enumerate", "utils.save_volfile", "len", "os.path.isfile", "utils.print_loop_info", "scipy.ndimage.filters.convolve", "len"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_image_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.print_loop_info"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.equalise_dataset_size_by_padding": [[659, 694], ["utils.list_images_in_folder", "enumerate", "os.path.exists", "os.mkdir", "len", "len", "utils.get_image_info", "numpy.asarray", "utils.print_loop_info", "utils.get_image_info", "numpy.asarray", "numpy.round().astype", "padded_labels.astype.astype", "utils.save_volfile", "os.path.join", "utils.get_image_info", "tuple", "len", "numpy.ones", "os.path.join", "os.path.join", "os.path.join", "numpy.maximum", "numpy.round", "os.path.basename", "numpy.asarray", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_image_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.print_loop_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_image_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_image_info"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.crop_dataset": [[696, 743], ["utils.list_images_in_folder", "utils.get_image_info", "print", "enumerate", "os.path.exists", "os.mkdir", "utils.list_images_in_folder", "numpy.array", "numpy.zeros", "print", "enumerate", "numpy.concatenate", "zip", "utils.print_loop_info", "utils.load_volfile", "utils.crop_array_with_idx", "utils.save_volfile", "os.path.exists", "os.mkdir", "len", "utils.print_loop_info", "utils.load_volfile", "utils.crop_volume", "numpy.minimum", "numpy.maximum", "len", "os.path.join", "utils.load_volfile", "utils.crop_array_with_idx", "utils.save_volfile", "len", "os.path.basename", "os.path.join", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_image_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.print_loop_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.crop_array_with_idx", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.print_loop_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.crop_volume", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.crop_array_with_idx", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.mask_dataset_with_labels": [[745, 758], ["utils.list_images_in_folder", "utils.list_images_in_folder", "enumerate", "os.path.exists", "os.mkdir", "zip", "utils.print_loop_info", "utils.load_volfile", "utils.load_volfile", "utils.save_volfile", "len", "os.path.join", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.print_loop_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.subdivide_dataset": [[760, 814], ["sorted", "len", "enumerate", "os.path.exists", "os.mkdir", "os.listdir", "print", "utils.load_volfile", "numpy.array", "numpy.array", "numpy.round().astype", "numpy.concatenate", "range", "os.path.join", "range", "len", "utils.find_closest_number_divisible_by_m", "numpy.round", "Exception", "la_path.replace", "new_filename.replace().replace.replace().replace", "range", "numpy.unique", "range", "new_filename.replace().replace.replace", "temp_la.astype", "utils.save_volfile", "numpy.unique", "numpy.array_equal", "os.path.join", "utils.save_volfile", "temp_la.astype", "utils.save_volfile", "numpy.zeros", "os.path.join", "numpy.array_equal", "os.path.join", "utils.save_volfile", "numpy.zeros", "os.path.join"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.find_closest_number_divisible_by_m", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.pynd.ndutils.range", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.crop_labels_dataset": [[816, 834], ["utils.list_images_in_folder", "utils.get_image_info", "print", "numpy.zeros", "enumerate", "print", "utils.equalise_dataset_size_by_padding", "os.path.exists", "os.mkdir", "utils.print_loop_info", "utils.load_volfile", "utils.crop_volume", "numpy.maximum", "utils.save_volfile", "len", "numpy.array", "os.path.join", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_image_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.equalise_dataset_size_by_padding", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.print_loop_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.crop_volume", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.convert_labels_type": [[836, 845], ["sorted", "os.path.exists", "os.mkdir", "os.path.join", "os.path.join", "utils.load_volfile", "utils.save_volfile", "os.listdir", "os.path.isfile", "os.path.join"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_image_info": [[849, 887], ["list", "len", "utils.load_volfile", "numpy.array().tolist", "numpy.load", "image_path.endswith", "numpy.eye", "nibabel.Nifti1Header", "TypeError", "numpy.array().tolist", "numpy.array", "os.path.basename", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.get_list_labels": [[889, 955], ["os.path.exists", "list", "list", "list", "numpy.concatenate", "len", "numpy.save", "print", "numpy.load", "Exception", "print", "utils.list_images_in_folder", "numpy.empty", "len", "enumerate", "numpy.unique", "Exception", "len", "utils.print_loop_info", "utils.load_volfile", "datasets.append", "list.append", "numpy.squeeze", "list.append", "list.append", "Exception"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.print_loop_info", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile": [[957, 981], ["datafile.endswith", "datafile.endswith", "nibabel.load", "numpy.asarray", "numpy.load", "datafile.endswith", "numpy.eye", "nibabel.Nifti1Header", "np.squeeze.astype", "numpy.squeeze"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile": [[983, 998], ["image.astype.astype", "numpy.savez_compressed", "nibabel.Nifti1Image", "nibabel.save", "nibabel.Nifti1Header", "numpy.eye", "utils.reformat_variable", "nib.Nifti1Image.header.set_zooms"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.save", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.reformat_variable"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.write_object": [[1000, 1004], ["open", "pickle.Pickler", "pickle.Pickler.dump"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.read_object": [[1006, 1010], ["open", "pickle.Unpickler", "pickle.Unpickler.load"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.torch.modelio.LoadableModel.load"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.write_model_summary": [[1012, 1015], ["open", "model.summary", "fh.write"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.reformat_variable": [[1017, 1039], ["isinstance", "isinstance", "TypeError", "len", "int", "len", "ValueError", "type", "float", "ValueError", "bool"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.strip_extension": [[1041, 1047], ["path.replace.replace", "path.replace.replace", "path.replace.replace", "path.replace.replace"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.strip_seg_aseg": [[1049, 1061], ["path.replace.replace", "path.replace.replace", "path.replace.replace", "path.replace.replace", "path.replace.replace", "path.replace.replace", "path.replace.replace", "path.replace.replace", "path.replace.replace", "path.replace.replace"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder": [[1063, 1070], ["os.path.isdir", "sorted", "sum", "glob.glob", "glob.glob", "os.path.join"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_models_in_folder": [[1072, 1075], ["sorted", "glob.glob", "os.path.join"], "function", ["None"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.convert_images_in_folder_to_nifty": [[1077, 1082], ["utils.list_images_in_folder", "utils.load_volfile", "utils.save_volfile", "utils.strip_extension"], "function", ["home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.list_images_in_folder", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.load_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.save_volfile", "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.strip_extension"], []], "home.repos.pwc.inspect_result.neel-dey_Atlas-GAN.synthseg.utils.print_loop_info": [[1084, 1089], ["print", "print"], "function", ["None"], []]}