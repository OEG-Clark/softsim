{"home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.train.Sinusoids.__init__": [[15, 45], ["torch.tensor", "torch.arange", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.zeros", "range", "sum", "torch.FloatTensor", "torch.FloatTensor", "torch.max", "torch.rand", "len", "len", "torch.abs", "torch.sin", "enumerate"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "seq_length", "=", "1000", ",", "num_samples", "=", "2", ",", "num_inputs", "=", "80", ",", "input_freq", "=", "50", ")", ":", "\n", "        ", "''' Initialize the dataset.\n\n        Args:\n          seq_length  : (ms) length of the input sequence\n          num_samples : number of samples\n          num_inputs  : input dimension\n          input_freq  : (Hz) Poisson input spike rate\n\n        '''", "\n", "self", ".", "seq_length", "=", "seq_length", "\n", "self", ".", "num_inputs", "=", "num_inputs", "\n", "self", ".", "num_samples", "=", "num_samples", "\n", "self", ".", "freq_list", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", ",", "3", ",", "5", "]", ")", "# (Hz) frequency of the sinusoids for target signal", "\n", "self", ".", "dt", "=", "1e-3", "# (s) simulation timestep ", "\n", "self", ".", "t", "=", "torch", ".", "arange", "(", "0", ",", "seq_length", "*", "self", ".", "dt", ",", "self", ".", "dt", ")", "# (s) time vector", "\n", "self", ".", "inp_freq", "=", "input_freq", "\n", "\n", "# Random input", "\n", "self", ".", "x", "=", "(", "torch", ".", "rand", "(", "self", ".", "num_samples", ",", "self", ".", "num_inputs", ",", "self", ".", "seq_length", ")", "<", "self", ".", "dt", "*", "self", ".", "inp_freq", ")", ".", "float", "(", ")", "\n", "\n", "# Randomized output amplitude and phase", "\n", "amplitude_list", "=", "torch", ".", "FloatTensor", "(", "self", ".", "num_samples", ",", "len", "(", "self", ".", "freq_list", ")", ")", ".", "uniform_", "(", "0.5", ",", "2", ")", "\n", "phase_list", "=", "torch", ".", "FloatTensor", "(", "self", ".", "num_samples", ",", "len", "(", "self", ".", "freq_list", ")", ")", ".", "uniform_", "(", "0", ",", "2", "*", "math", ".", "pi", ")", "\n", "\n", "# Normalized sum of sinusoids", "\n", "self", ".", "y", "=", "torch", ".", "zeros", "(", "self", ".", "num_samples", ",", "self", ".", "seq_length", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_samples", ")", ":", "\n", "          ", "summed_sinusoid", "=", "sum", "(", "[", "amplitude_list", "[", "i", ",", "ix", "]", "*", "torch", ".", "sin", "(", "2", "*", "math", ".", "pi", "*", "f", "*", "self", ".", "t", "+", "phase_list", "[", "i", ",", "ix", "]", ")", "for", "ix", ",", "f", "in", "enumerate", "(", "self", ".", "freq_list", ")", "]", ")", "\n", "self", ".", "y", "[", "i", ",", ":", "]", "=", "summed_sinusoid", "/", "torch", ".", "max", "(", "torch", ".", "abs", "(", "summed_sinusoid", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.train.Sinusoids.__len__": [[46, 48], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.train.Sinusoids.__getitem__": [[49, 53], ["torch.is_tensor", "idx.tolist.tolist.tolist"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "idx", ".", "tolist", "(", ")", "\n", "", "return", "self", ".", "x", "[", "idx", "]", ",", "self", ".", "y", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.train.train": [[54, 107], ["torch.manual_seed", "torch.cuda.manual_seed", "numpy.random.seed", "train.Sinusoids", "int", "torch.utils.data.random_split", "torch.utils.data.DataLoader", "torch.device", "srnn.SRNN().to", "torch.nn.MSELoss", "range", "SRNN().to.eval", "srnn.SRNN", "torch.no_grad", "enumerate", "print", "len", "len", "torch.cuda.is_available", "y.permute().unsqueeze.permute().unsqueeze", "SRNN().to.", "SRNN().to.calc_traces", "SRNN().to.acc_gradient", "SRNN().to.do_weight_update", "x.to", "y.permute().unsqueeze.to", "torch.sum().cpu", "y.permute().unsqueeze.permute", "nn.MSELoss.item", "torch.sum", "nn.MSELoss."], "function", ["home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.calc_traces", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.acc_gradient", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.do_weight_update"], ["", "", "def", "train", "(", "seed", ",", "inp_dim", ",", "out_dim", ",", "n_rec", ",", "thr", ",", "tau_rec", ",", "tau_out", ",", "\n", "lr_inp", ",", "lr_rec", ",", "lr_out", ",", "w_init_gain", ",", "n_t", ",", "n_b", ",", "gamma", ",", "dt", ",", "reg", ",", "f0", ",", "\n", "xbar", ",", "xbar_n", ",", "perf", ",", "xbar_res", ",", "xbar_scale", ",", "prob_scale", ",", "grad_thr", ",", "method", ",", "cuda", ",", "epochs", ")", ":", "\n", "\n", "# fix seeds", "\n", "    ", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "# data Loader", "\n", "sinusoid_dataset", "=", "Sinusoids", "(", "seq_length", "=", "n_t", ",", "num_samples", "=", "6", ",", "num_inputs", "=", "inp_dim", ",", "input_freq", "=", "50", ")", "\n", "\n", "# parameters", "\n", "train_percentage", "=", "50", "\n", "batch_size", "=", "1", "\n", "\n", "train_size", "=", "int", "(", "len", "(", "sinusoid_dataset", ")", "*", "train_percentage", "/", "100", ")", "\n", "train_set", ",", "_", "=", "random_split", "(", "sinusoid_dataset", ",", "[", "train_size", ",", "len", "(", "sinusoid_dataset", ")", "-", "train_size", "]", ")", "\n", "train_data", "=", "DataLoader", "(", "train_set", ",", "batch_size", ",", "shuffle", "=", "True", ")", "\n", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "(", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "cuda", ")", "else", "\"cpu\"", ")", "\n", "\n", "srnn", "=", "SRNN", "(", "inp_dim", ",", "out_dim", ",", "n_rec", ",", "thr", ",", "tau_rec", ",", "\n", "tau_out", ",", "lr_inp", ",", "lr_rec", ",", "lr_out", ",", "w_init_gain", ",", "n_t", ",", "n_b", ",", "\n", "gamma", ",", "dt", ",", "reg", ",", "f0", ",", "xbar", ",", "xbar_n", ",", "perf", ",", "\n", "xbar_res", ",", "xbar_scale", ",", "prob_scale", ",", "grad_thr", ",", "method", ",", "device", ")", ".", "to", "(", "device", ")", "\n", "\n", "mse_loss", "=", "nn", ".", "MSELoss", "(", ")", "\n", "\n", "tp", "=", "0.", ";", "T0", "=", "38.6", "\n", "for", "epoch", "in", "range", "(", "epochs", ")", ":", "\n", "      ", "srnn", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "_", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "train_data", ")", ":", "\n", "            ", "x", ",", "y", "=", "x", ".", "to", "(", "device", ")", ",", "y", ".", "to", "(", "device", ")", "\n", "y", "=", "y", ".", "permute", "(", "1", ",", "0", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "yhat", "=", "srnn", "(", "x", ",", "tp", "=", "tp", ")", "\n", "srnn", ".", "calc_traces", "(", "x", ")", "\n", "srnn", ".", "acc_gradient", "(", "yhat", "-", "y", ")", "\n", "\n", "# next write after T0 seconds", "\n", "tp", "=", "tp", "+", "T0", "\n", "\n", "# weight update - Apply gradual SETs to differential memristors", "\n", "srnn", ".", "do_weight_update", "(", "tp", "=", "tp", ")", "\n", "\n", "# report", "\n", "", "", "if", "epoch", "%", "10", "==", "0", ":", "\n", "        ", "print", "(", "f'Epoch [{epoch}] - Loss :{mse_loss(yhat, y).item():.4f}'", ")", "\n", "\n", "# stop the training if there is no WRITE update to recurrent layer", "\n", "if", "srnn", ".", "xbar", "and", "torch", ".", "sum", "(", "srnn", ".", "rec_xbar", ".", "count", ")", ".", "cpu", "(", ")", "<", "2", "and", "epoch", "==", "50", ":", "\n", "            ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.__init__": [[16, 73], ["torch.nn.Module.__init__", "numpy.exp", "numpy.exp", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "xbar.XBar", "xbar.XBar", "xbar.XBar", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "srnn.SRNN.initialize_weights", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.__init__", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.initialize_weights"], ["def", "__init__", "(", "self", ",", "inp_dim", ",", "out_dim", ",", "n_rec", ",", "thr", ",", "tau_rec", ",", "tau_out", ",", "\n", "lr_inp", ",", "lr_rec", ",", "lr_out", ",", "w_init_gain", ",", "n_t", ",", "n_b", ",", "gamma", ",", "\n", "dt", ",", "reg", ",", "f0", ",", "xbar", ",", "xbar_n", ",", "perf", ",", "xbar_res", ",", "xbar_scale", ",", "\n", "prob_scale", ",", "grad_thr", ",", "method", ",", "device", ")", ":", "\n", "\n", "        ", "super", "(", "SRNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inp_dim", "=", "inp_dim", "\n", "self", ".", "n_rec", "=", "n_rec", "\n", "self", ".", "out_dim", "=", "out_dim", "\n", "self", ".", "thr", "=", "thr", "\n", "self", ".", "alpha", "=", "np", ".", "exp", "(", "-", "dt", "/", "tau_rec", ")", "\n", "self", ".", "kappa", "=", "np", ".", "exp", "(", "-", "dt", "/", "tau_out", ")", "\n", "self", ".", "lr_inp", "=", "lr_inp", "\n", "self", ".", "lr_rec", "=", "lr_rec", "\n", "self", ".", "lr_out", "=", "lr_out", "\n", "self", ".", "n_t", "=", "n_t", "\n", "self", ".", "n_b", "=", "n_b", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "w_init_gain", "=", "w_init_gain", "\n", "self", ".", "b_o", "=", "0.0", "\n", "self", ".", "reg", "=", "reg", "\n", "self", ".", "f0", "=", "f0", "\n", "self", ".", "dt", "=", "dt", "\n", "self", ".", "xbar", "=", "xbar", "\n", "self", ".", "xbar_res", "=", "xbar_res", "\n", "self", ".", "xbar_scale", "=", "xbar_scale", "\n", "self", ".", "prob_scale", "=", "prob_scale", "\n", "self", ".", "grad_thr", "=", "grad_thr", "\n", "self", ".", "xbar_n", "=", "xbar_n", "\n", "self", ".", "perf", "=", "perf", "\n", "self", ".", "T0", "=", "38.6", "\n", "self", ".", "method", "=", "method", "\n", "self", ".", "device", "=", "device", "\n", "\n", "# Parameters", "\n", "if", "self", ".", "xbar", ":", "# Crossbar array", "\n", "          ", "self", ".", "inp_xbar", "=", "XBar", "(", "G0", "=", "self", ".", "w_init_gain", ",", "N", "=", "self", ".", "xbar_n", ",", "size", "=", "(", "self", ".", "n_rec", ",", "self", ".", "inp_dim", ")", ",", "res", "=", "self", ".", "xbar_res", ",", "scale", "=", "self", ".", "xbar_scale", ",", "prob_scale", "=", "self", ".", "prob_scale", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "rec_xbar", "=", "XBar", "(", "G0", "=", "self", ".", "w_init_gain", ",", "N", "=", "self", ".", "xbar_n", ",", "size", "=", "(", "self", ".", "n_rec", ",", "self", ".", "n_rec", ")", ",", "res", "=", "self", ".", "xbar_res", ",", "scale", "=", "self", ".", "xbar_scale", ",", "prob_scale", "=", "self", ".", "prob_scale", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "out_xbar", "=", "XBar", "(", "G0", "=", "self", ".", "w_init_gain", ",", "N", "=", "self", ".", "xbar_n", ",", "size", "=", "(", "self", ".", "out_dim", ",", "self", ".", "n_rec", ")", ",", "res", "=", "self", ".", "xbar_res", ",", "scale", "=", "self", ".", "xbar_scale", ",", "prob_scale", "=", "self", ".", "prob_scale", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# Feedback path", "\n", "#self.w_fb = torch.normal(self.w_init_gain, self.w_init_gain*0.1, (self.out_dim, self.n_rec)).to(self.device)", "\n", "self", ".", "w_fb", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_dim", ",", "n_rec", ")", ")", "\n", "torch", ".", "nn", ".", "init", ".", "kaiming_normal_", "(", "self", ".", "w_fb", ")", "\n", "self", ".", "w_fb", ".", "data", "=", "self", ".", "w_init_gain", "*", "self", ".", "w_fb", ".", "data", "\n", "\n", "", "else", ":", "# No crossbar array", "\n", "          ", "self", ".", "w_inp", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "n_rec", ",", "self", ".", "inp_dim", ")", ")", "\n", "self", ".", "w_rec", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "n_rec", ",", "self", ".", "n_rec", ")", ")", "\n", "self", ".", "w_out", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "out_dim", ",", "self", ".", "n_rec", ")", ")", "\n", "self", ".", "w_fb", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "out_dim", ",", "self", ".", "n_rec", ")", ")", "\n", "self", ".", "initialize_weights", "(", "self", ".", "w_init_gain", ")", "\n", "\n", "# Accumulator (Mixed-precision training)", "\n", "", "self", ".", "inp_acc", "=", "torch", ".", "zeros", "(", "(", "self", ".", "n_rec", ",", "self", ".", "inp_dim", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "rec_acc", "=", "torch", ".", "zeros", "(", "(", "self", ".", "n_rec", ",", "self", ".", "n_rec", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "out_acc", "=", "torch", ".", "zeros", "(", "(", "self", ".", "out_dim", ",", "self", ".", "n_rec", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.initialize_weights": [[74, 88], ["torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_"], "methods", ["None"], ["", "def", "initialize_weights", "(", "self", ",", "gain", ")", ":", "\n", "        ", "''' Initialize input, recurrent and output weights if no crossbar array is used.\n\n        Args:\n            gain: scaling factor for the weights\n        '''", "\n", "torch", ".", "nn", ".", "init", ".", "kaiming_normal_", "(", "self", ".", "w_inp", ")", "\n", "self", ".", "w_inp", ".", "data", "=", "gain", "*", "self", ".", "w_inp", ".", "data", "\n", "torch", ".", "nn", ".", "init", ".", "kaiming_normal_", "(", "self", ".", "w_rec", ")", "\n", "self", ".", "w_rec", ".", "data", "=", "gain", "*", "self", ".", "w_rec", ".", "data", "\n", "torch", ".", "nn", ".", "init", ".", "kaiming_normal_", "(", "self", ".", "w_out", ")", "\n", "self", ".", "w_out", ".", "data", "=", "gain", "*", "self", ".", "w_out", ".", "data", "\n", "torch", ".", "nn", ".", "init", ".", "kaiming_normal_", "(", "self", ".", "w_fb", ")", "\n", "self", ".", "w_fb", ".", "data", "=", "gain", "*", "self", ".", "w_fb", ".", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.init_CPU_states": [[89, 108], ["torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "init_CPU_states", "(", "self", ",", "n_b", ",", "n_t", ",", "n_rec", ",", "out_dim", ")", ":", "\n", "        ", "''' Initialize network states\n\n        Args:\n            n_b: batch size\n            n_t: number of time steps\n            n_rec: number of recurrent units\n            out_dim: output dimension\n        \n        '''", "\n", "# Hidden state", "\n", "self", ".", "v", "=", "torch", ".", "zeros", "(", "n_t", ",", "n_b", ",", "n_rec", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# Visible state", "\n", "self", ".", "z", "=", "torch", ".", "zeros", "(", "n_t", ",", "n_b", ",", "n_rec", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "vo", "=", "torch", ".", "zeros", "(", "n_t", ",", "n_b", ",", "out_dim", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# Weight gradients", "\n", "self", ".", "w_inp_grad", "=", "torch", ".", "zeros", "(", "self", ".", "n_rec", ",", "self", ".", "inp_dim", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "w_rec_grad", "=", "torch", ".", "zeros", "(", "self", ".", "n_rec", ",", "self", ".", "n_rec", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "w_out_grad", "=", "torch", ".", "zeros", "(", "self", ".", "out_dim", ",", "self", ".", "n_rec", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.reset_diagonal": [[109, 117], ["torch.eye().repeat().bool", "torch.eye().repeat().bool", "torch.eye().repeat().bool", "torch.eye().repeat().bool", "srnn.SRNN.rec_xbar.reset", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye().repeat", "torch.eye().repeat", "torch.eye().repeat", "torch.eye().repeat", "torch.eye", "torch.eye", "torch.eye", "torch.eye"], "methods", ["home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.reset"], ["", "def", "reset_diagonal", "(", "self", ",", "tp", ")", ":", "\n", "        ", "''' Reset diagonal elements of recurrent weights to zero (or the lowest conductance)\n        '''", "\n", "if", "self", ".", "xbar", ":", "\n", "            ", "reset_mask", "=", "torch", ".", "eye", "(", "self", ".", "n_rec", ",", "self", ".", "n_rec", ",", "device", "=", "self", ".", "device", ")", ".", "repeat", "(", "2", ",", "self", ".", "xbar_n", ",", "1", ",", "1", ")", ".", "bool", "(", ")", "\n", "self", ".", "rec_xbar", ".", "reset", "(", "tp", ",", "mask", "=", "reset_mask", ",", "G0", "=", "0.1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "w_rec", "*=", "(", "1", "-", "torch", ".", "eye", "(", "self", ".", "n_rec", ",", "self", ".", "n_rec", ",", "device", "=", "self", ".", "device", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.forward": [[118, 149], ["srnn.SRNN.init_CPU_states", "srnn.SRNN.reset_diagonal", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "torch.diff().squeeze().t", "srnn.SRNN.w_inp.t", "srnn.SRNN.w_rec.t", "srnn.SRNN.w_out.t", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.diff().squeeze", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.diff", "torch.diff", "torch.diff", "torch.diff", "torch.diff", "torch.diff", "torch.diff", "torch.diff", "torch.diff", "torch.diff", "torch.diff", "torch.diff", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "srnn.SRNN.inp_xbar.read", "srnn.SRNN.rec_xbar.read", "srnn.SRNN.out_xbar.read"], "methods", ["home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.init_CPU_states", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.reset_diagonal", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.read", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.read", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.read"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "tp", ")", ":", "\n", "        ", "''' Forward pass of the network\n\n        Args:\n            x  : input spike pattern\n            tp : time point\n        \n        Returns:\n            self.vo : Output units membrane voltages\n        '''", "\n", "self", ".", "n_b", ",", "self", ".", "n_t", "=", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "2", "]", "\n", "\n", "self", ".", "init_CPU_states", "(", "self", ".", "n_b", ",", "self", ".", "n_t", ",", "self", ".", "n_rec", ",", "self", ".", "out_dim", ")", "\n", "self", ".", "reset_diagonal", "(", "tp", ")", "\n", "\n", "for", "t", "in", "range", "(", "0", ",", "self", ".", "n_t", "-", "1", ")", ":", "\n", "            ", "curr_time", "=", "torch", ".", "tensor", "(", "tp", "+", "t", "*", "self", ".", "dt", "+", "EPS", ",", "dtype", "=", "torch", ".", "double", ")", "# current time", "\n", "if", "self", ".", "xbar", ":", "\n", "# Differential read of XBar", "\n", "                ", "inp_weight", "=", "torch", ".", "diff", "(", "-", "torch", ".", "sum", "(", "self", ".", "inp_xbar", ".", "read", "(", "t", "=", "curr_time", ",", "T0", "=", "self", ".", "T0", ",", "perf", "=", "self", ".", "perf", ")", ",", "dim", "=", "1", ")", ",", "dim", "=", "0", ")", ".", "squeeze", "(", "0", ")", ".", "t", "(", ")", "\n", "rec_weight", "=", "torch", ".", "diff", "(", "-", "torch", ".", "sum", "(", "self", ".", "rec_xbar", ".", "read", "(", "t", "=", "curr_time", ",", "T0", "=", "self", ".", "T0", ",", "perf", "=", "self", ".", "perf", ")", ",", "dim", "=", "1", ")", ",", "dim", "=", "0", ")", ".", "squeeze", "(", "0", ")", ".", "t", "(", ")", "\n", "out_weight", "=", "torch", ".", "diff", "(", "-", "torch", ".", "sum", "(", "self", ".", "out_xbar", ".", "read", "(", "t", "=", "curr_time", ",", "T0", "=", "self", ".", "T0", ",", "perf", "=", "self", ".", "perf", ")", ",", "dim", "=", "1", ")", ",", "dim", "=", "0", ")", ".", "squeeze", "(", "0", ")", ".", "t", "(", ")", "\n", "", "else", ":", "\n", "                ", "inp_weight", "=", "self", ".", "w_inp", ".", "t", "(", ")", "\n", "rec_weight", "=", "self", ".", "w_rec", ".", "t", "(", ")", "\n", "out_weight", "=", "self", ".", "w_out", ".", "t", "(", ")", "\n", "\n", "", "self", ".", "v", "[", "t", "+", "1", "]", "=", "(", "self", ".", "alpha", "*", "self", ".", "v", "[", "t", "]", "+", "torch", ".", "mm", "(", "self", ".", "z", "[", "t", "]", ",", "rec_weight", ")", "+", "torch", ".", "mm", "(", "x", "[", ":", ",", ":", ",", "t", "]", ",", "inp_weight", ")", ")", "-", "self", ".", "z", "[", "t", "]", "*", "self", ".", "thr", "\n", "self", ".", "z", "[", "t", "+", "1", "]", "=", "(", "self", ".", "v", "[", "t", "+", "1", "]", ">", "self", ".", "thr", ")", ".", "float", "(", ")", "\n", "self", ".", "vo", "[", "t", "+", "1", "]", "=", "self", ".", "kappa", "*", "self", ".", "vo", "[", "t", "]", "+", "torch", ".", "mm", "(", "self", ".", "z", "[", "t", "+", "1", "]", ",", "out_weight", ")", "+", "self", ".", "b_o", "\n", "", "return", "self", ".", "vo", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.calc_traces": [[150, 184], ["torch.tensor().float().view().to", "torch.tensor().float().view().to", "torch.tensor().float().view().to", "torch.tensor().float().view().to", "[].unsqueeze().expand", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "[].unsqueeze().expand", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.tensor().float().view().to", "torch.tensor().float().view().to", "torch.tensor().float().view().to", "torch.tensor().float().view().to", "[].reshape", "[].reshape", "torch.max", "torch.max", "torch.max", "torch.max", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.conv1d", "torch.conv1d", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.tensor().float().view", "torch.tensor().float().view", "torch.tensor().float().view", "torch.tensor().float().view", "[].unsqueeze", "[].unsqueeze", "torch.tensor().float().view", "torch.tensor().float().view", "torch.tensor().float().view", "torch.tensor().float().view", "srnn.SRNN.z.permute", "torch.tensor().float().view().to.expand", "torch.tensor().float().view().to.expand", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.conv1d", "torch.conv1d", "torch.conv1d", "torch.conv1d", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "srnn.SRNN.trace_in.reshape", "torch.tensor().float().view().to.expand", "torch.tensor().float().view().to.expand", "srnn.SRNN.trace_rec.reshape", "torch.tensor().float().view().to.expand", "torch.tensor().float().view().to.expand", "torch.conv1d", "torch.conv1d", "torch.conv1d", "torch.conv1d", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor().float().view().to.expand", "torch.tensor().float().view().to.expand", "srnn.SRNN.z.permute", "torch.tensor().float().view().to.expand", "torch.tensor().float().view().to.expand", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "range", "range"], "methods", ["None"], ["", "def", "calc_traces", "(", "self", ",", "x", ")", ":", "\n", "        ", "''' Calculate the eligibility traces inside the network\n\n        Args:\n            x  : input spike pattern\n        \n        '''", "\n", "h", "=", "self", ".", "gamma", "*", "torch", ".", "max", "(", "torch", ".", "zeros_like", "(", "self", ".", "v", ")", ",", "1", "-", "torch", ".", "abs", "(", "(", "self", ".", "v", "-", "self", ".", "thr", ")", "/", "self", ".", "thr", ")", ")", "# n_t, n_b, n_rec", "\n", "alpha_conv", "=", "torch", ".", "tensor", "(", "[", "self", ".", "alpha", "**", "(", "self", ".", "n_t", "-", "i", "-", "1", ")", "for", "i", "in", "range", "(", "self", ".", "n_t", ")", "]", ")", ".", "float", "(", ")", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ".", "to", "(", "self", ".", "device", ")", "# 1, 1, n_t", "\n", "\n", "self", ".", "trace_in", "=", "F", ".", "conv1d", "(", "x", ",", "alpha_conv", ".", "expand", "(", "self", ".", "inp_dim", ",", "-", "1", ",", "-", "1", ")", ",", "\n", "padding", "=", "self", ".", "n_t", ",", "groups", "=", "self", ".", "inp_dim", ")", "[", ":", ",", ":", ",", "1", ":", "self", ".", "n_t", "+", "1", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "self", ".", "n_rec", ",", "-", "1", ",", "-", "1", ")", "#n_b, n_rec, inp_dim, n_t", "\n", "self", ".", "trace_in", "=", "torch", ".", "einsum", "(", "'tbr,brit->brit'", ",", "h", ",", "self", ".", "trace_in", ")", "# n_b, n_r, inp_dim, n_t", "\n", "\n", "self", ".", "trace_rec", "=", "F", ".", "conv1d", "(", "self", ".", "z", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ",", "alpha_conv", ".", "expand", "(", "self", ".", "n_rec", ",", "-", "1", ",", "-", "1", ")", ",", "\n", "padding", "=", "self", ".", "n_t", ",", "groups", "=", "self", ".", "n_rec", ")", "[", ":", ",", ":", ",", ":", "self", ".", "n_t", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "self", ".", "n_rec", ",", "-", "1", ",", "-", "1", ")", "\n", "\n", "self", ".", "trace_rec", "=", "torch", ".", "einsum", "(", "'tbr,brit->brit'", ",", "h", ",", "self", ".", "trace_rec", ")", "\n", "\n", "self", ".", "fr", "=", "torch", ".", "sum", "(", "self", ".", "z", ",", "dim", "=", "(", "0", ",", "1", ")", ")", "/", "(", "self", ".", "n_t", "*", "self", ".", "dt", ")", "# Firing rate per neuron", "\n", "\n", "self", ".", "reg_term", "=", "(", "self", ".", "fr", "-", "self", ".", "f0", ")", "\n", "\n", "kappa_conv", "=", "torch", ".", "tensor", "(", "[", "self", ".", "kappa", "**", "(", "self", ".", "n_t", "-", "i", "-", "1", ")", "for", "i", "in", "range", "(", "self", ".", "n_t", ")", "]", ")", ".", "float", "(", ")", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "self", ".", "trace_out", "=", "F", ".", "conv1d", "(", "self", ".", "z", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ",", "kappa_conv", ".", "expand", "(", "self", ".", "n_rec", ",", "-", "1", ",", "-", "1", ")", ",", "\n", "padding", "=", "self", ".", "n_t", ",", "groups", "=", "self", ".", "n_rec", ")", "[", ":", ",", ":", ",", "1", ":", "self", ".", "n_t", "+", "1", "]", "\n", "\n", "self", ".", "trace_in", "=", "F", ".", "conv1d", "(", "self", ".", "trace_in", ".", "reshape", "(", "self", ".", "n_b", ",", "self", ".", "inp_dim", "*", "self", ".", "n_rec", ",", "self", ".", "n_t", ")", ",", "\n", "kappa_conv", ".", "expand", "(", "self", ".", "inp_dim", "*", "self", ".", "n_rec", ",", "-", "1", ",", "-", "1", ")", ",", "\n", "padding", "=", "self", ".", "n_t", ",", "groups", "=", "self", ".", "inp_dim", "*", "self", ".", "n_rec", ")", "[", ":", ",", ":", ",", "1", ":", "self", ".", "n_t", "+", "1", "]", ".", "reshape", "(", "self", ".", "n_b", ",", "self", ".", "n_rec", ",", "self", ".", "inp_dim", ",", "self", ".", "n_t", ")", "\n", "self", ".", "trace_rec", "=", "F", ".", "conv1d", "(", "self", ".", "trace_rec", ".", "reshape", "(", "self", ".", "n_b", ",", "self", ".", "n_rec", "*", "self", ".", "n_rec", ",", "self", ".", "n_t", ")", ",", "\n", "kappa_conv", ".", "expand", "(", "self", ".", "n_rec", "*", "self", ".", "n_rec", ",", "-", "1", ",", "-", "1", ")", ",", "\n", "padding", "=", "self", ".", "n_t", ",", "groups", "=", "self", ".", "n_rec", "*", "self", ".", "n_rec", ")", "[", ":", ",", ":", ",", "1", ":", "self", ".", "n_t", "+", "1", "]", ".", "reshape", "(", "self", ".", "n_b", ",", "self", ".", "n_rec", ",", "self", ".", "n_rec", ",", "self", ".", "n_t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.acc_gradient": [[186, 206], ["torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.sum().clamp", "torch.sum().clamp", "torch.sum().clamp", "torch.sum().clamp", "torch.sum().clamp", "torch.sum().clamp", "torch.sum().clamp", "torch.sum().clamp", "torch.einsum().clamp", "torch.einsum().clamp", "torch.einsum().clamp", "torch.einsum().clamp", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "srnn.SRNN.reg_term.expand().unsqueeze().permute", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "srnn.SRNN.reg_term.expand().unsqueeze", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "srnn.SRNN.reg_term.expand"], "methods", ["None"], ["", "def", "acc_gradient", "(", "self", ",", "err", ",", "targeted_fr", "=", "True", ")", ":", "\n", "        ", "''' Accumulate the gradient in the network\n\n        Args:\n            err         : error between the target signal and the output unit membrane potential\n            targeted_fr : True if weight regularization is used\n        '''", "\n", "L_loss", "=", "torch", ".", "einsum", "(", "'tbo,or->brt'", ",", "err", ",", "self", ".", "w_fb", ")", "\n", "\n", "if", "not", "targeted_fr", ":", "\n", "            ", "L_reg", "=", "torch", ".", "mean", "(", "self", ".", "trace_rec", ",", "dim", "=", "2", ")", "\n", "", "else", ":", "\n", "            ", "L_reg", "=", "self", ".", "reg_term", ".", "expand", "(", "self", ".", "n_t", ",", "self", ".", "n_rec", ")", ".", "unsqueeze", "(", "0", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "#torch.mean(self.reg_term) for MEAN fr", "\n", "\n", "", "L", "=", "L_loss", "+", "self", ".", "reg", "*", "L_reg", "\n", "\n", "# Weight gradient updates", "\n", "self", ".", "w_inp_grad", "+=", "torch", ".", "sum", "(", "torch", ".", "einsum", "(", "'bxt,bxyt->xyt'", ",", "L", ",", "self", ".", "trace_in", ")", ",", "dim", "=", "2", ")", ".", "clamp", "(", "-", "100", ",", "100", ")", "\n", "self", ".", "w_rec_grad", "+=", "torch", ".", "sum", "(", "torch", ".", "einsum", "(", "'bxt,bxyt->xyt'", ",", "L", ",", "self", ".", "trace_rec", ")", ",", "dim", "=", "2", ")", ".", "clamp", "(", "-", "100", ",", "100", ")", "\n", "self", ".", "w_out_grad", "+=", "torch", ".", "einsum", "(", "'tbo,brt->or'", ",", "err", ",", "self", ".", "trace_out", ")", ".", "clamp", "(", "-", "100", ",", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.srnn.SRNN.do_weight_update": [[208, 321], ["print", "srnn.SRNN.inp_xbar.write", "srnn.SRNN.rec_xbar.write", "srnn.SRNN.out_xbar.write", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "srnn.SRNN.inp_xbar.target_write", "srnn.SRNN.rec_xbar.target_write", "srnn.SRNN.out_xbar.target_write", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "torch.stack().unsqueeze().expand", "srnn.SRNN.inp_xbar.target_write", "srnn.SRNN.rec_xbar.target_write", "srnn.SRNN.out_xbar.target_write", "srnn.SRNN.inp_xbar.target_write", "srnn.SRNN.rec_xbar.target_write", "srnn.SRNN.out_xbar.target_write", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.stack().unsqueeze", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.floor_divide", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write"], ["", "def", "do_weight_update", "(", "self", ",", "tp", ")", ":", "\n", "        ", "''' Update the weights in the network\n\n        Args:\n            tp : time point\n        '''", "\n", "if", "(", "tp", ">", "10000", "and", "tp", "<", "10050", ")", "or", "(", "tp", ">", "20000", "and", "tp", "<", "20050", ")", ":", "\n", "            ", "refresh", "=", "True", "\n", "print", "(", "'Refreshing'", ")", "\n", "", "else", ":", "\n", "            ", "refresh", "=", "False", "\n", "\n", "\n", "", "assert", "self", ".", "method", "in", "[", "'sign'", ",", "'stochastic'", ",", "'multi-mem'", ",", "'mixed-precision'", ",", "'vanilla'", ",", "'accumulator'", "]", ",", "\"Invalid update method.\"", "\n", "\n", "if", "self", ".", "xbar", ":", "# PCM Weights", "\n", "            ", "if", "self", ".", "method", "==", "'sign'", ":", "\n", "                ", "''' Update PCM devices according to sign of the gradient\n                '''", "\n", "# Weight update - Apply gradual SET to differential memristors (W -= sign(dW)) if dW > thr", "\n", "self", ".", "inp_xbar", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "torch", ".", "stack", "(", "(", "self", ".", "w_inp_grad", "<", "-", "self", ".", "grad_thr", ",", "self", ".", "w_inp_grad", ">", "self", ".", "grad_thr", ")", ",", "dim", "=", "0", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "self", ".", "xbar_n", ",", "-", "1", ",", "-", "1", ")", ",", "perf", "=", "self", ".", "perf", ")", "\n", "self", ".", "rec_xbar", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "torch", ".", "stack", "(", "(", "self", ".", "w_rec_grad", "<", "-", "self", ".", "grad_thr", ",", "self", ".", "w_rec_grad", ">", "self", ".", "grad_thr", ")", ",", "dim", "=", "0", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "self", ".", "xbar_n", ",", "-", "1", ",", "-", "1", ")", ",", "perf", "=", "self", ".", "perf", ")", "\n", "self", ".", "out_xbar", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "torch", ".", "stack", "(", "(", "self", ".", "w_out_grad", "<", "-", "self", ".", "grad_thr", ",", "self", ".", "w_out_grad", ">", "self", ".", "grad_thr", ")", ",", "dim", "=", "0", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "self", ".", "xbar_n", ",", "-", "1", ",", "-", "1", ")", ",", "perf", "=", "self", ".", "perf", ")", "\n", "\n", "", "elif", "self", ".", "method", "==", "'stochastic'", ":", "\n", "                ", "''' Gradual SET pulse as a function of gradient (not accumulated) amplitude.\n                '''", "\n", "# Current differential conductance of XBar (perfect estimation)", "\n", "inp_G_est", "=", "(", "self", ".", "inp_xbar", ".", "G", "[", "0", "]", "-", "self", ".", "inp_xbar", ".", "G", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "rec_G_est", "=", "(", "self", ".", "rec_xbar", ".", "G", "[", "0", "]", "-", "self", ".", "rec_xbar", ".", "G", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "out_G_est", "=", "(", "self", ".", "out_xbar", ".", "G", "[", "0", "]", "-", "self", ".", "out_xbar", ".", "G", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Target G", "\n", "inp_G_tar", "=", "inp_G_est", "-", "self", ".", "lr_inp", "*", "self", ".", "w_inp_grad", "*", "self", ".", "inp_xbar", ".", "xbar_scale", "\n", "rec_G_tar", "=", "rec_G_est", "-", "self", ".", "lr_rec", "*", "self", ".", "w_rec_grad", "*", "self", ".", "rec_xbar", ".", "xbar_scale", "\n", "out_G_tar", "=", "out_G_est", "-", "self", ".", "lr_out", "*", "self", ".", "w_out_grad", "*", "self", ".", "out_xbar", ".", "xbar_scale", "\n", "\n", "self", ".", "inp_xbar", ".", "target_write", "(", "tp", "=", "tp", ",", "G_target", "=", "inp_G_tar", ",", "G_curr_est", "=", "inp_G_est", ",", "refresh", "=", "False", ",", "perf", "=", "self", ".", "perf", ",", "method", "=", "'stochastic'", ")", "\n", "self", ".", "rec_xbar", ".", "target_write", "(", "tp", "=", "tp", ",", "G_target", "=", "rec_G_tar", ",", "G_curr_est", "=", "rec_G_est", ",", "refresh", "=", "False", ",", "perf", "=", "self", ".", "perf", ",", "method", "=", "'stochastic'", ")", "\n", "self", ".", "out_xbar", ".", "target_write", "(", "tp", "=", "tp", ",", "G_target", "=", "out_G_tar", ",", "G_curr_est", "=", "out_G_est", ",", "refresh", "=", "False", ",", "perf", "=", "self", ".", "perf", ",", "method", "=", "'stochastic'", ")", "\n", "\n", "", "elif", "self", ".", "method", "==", "'multi-mem'", ":", "\n", "                ", "''' Multiple memristor per synapse, updated in turns.\n                '''", "\n", "# Current differential conductance of XBar (perfect estimation)", "\n", "inp_G_est", "=", "(", "torch", ".", "mean", "(", "self", ".", "inp_xbar", ".", "G", ",", "1", ")", "[", "0", "]", "-", "torch", ".", "mean", "(", "self", ".", "inp_xbar", ".", "G", ",", "1", ")", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "rec_G_est", "=", "(", "torch", ".", "mean", "(", "self", ".", "rec_xbar", ".", "G", ",", "1", ")", "[", "0", "]", "-", "torch", ".", "mean", "(", "self", ".", "rec_xbar", ".", "G", ",", "1", ")", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "out_G_est", "=", "(", "torch", ".", "mean", "(", "self", ".", "out_xbar", ".", "G", ",", "1", ")", "[", "0", "]", "-", "torch", ".", "mean", "(", "self", ".", "out_xbar", ".", "G", ",", "1", ")", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Target G", "\n", "inp_G_tar", "=", "inp_G_est", "-", "self", ".", "lr_inp", "*", "self", ".", "w_inp_grad", "*", "self", ".", "inp_xbar", ".", "xbar_scale", "\n", "rec_G_tar", "=", "rec_G_est", "-", "self", ".", "lr_rec", "*", "self", ".", "w_rec_grad", "*", "self", ".", "rec_xbar", ".", "xbar_scale", "\n", "out_G_tar", "=", "out_G_est", "-", "self", ".", "lr_out", "*", "self", ".", "w_out_grad", "*", "self", ".", "out_xbar", ".", "xbar_scale", "\n", "\n", "self", ".", "inp_xbar", ".", "target_write", "(", "tp", "=", "tp", ",", "G_target", "=", "inp_G_tar", ",", "G_curr_est", "=", "inp_G_est", ",", "refresh", "=", "refresh", ",", "perf", "=", "self", ".", "perf", ",", "method", "=", "'multi-mem'", ")", "\n", "self", ".", "rec_xbar", ".", "target_write", "(", "tp", "=", "tp", ",", "G_target", "=", "rec_G_tar", ",", "G_curr_est", "=", "rec_G_est", ",", "refresh", "=", "refresh", ",", "perf", "=", "self", ".", "perf", ",", "method", "=", "'multi-mem'", ")", "\n", "self", ".", "out_xbar", ".", "target_write", "(", "tp", "=", "tp", ",", "G_target", "=", "out_G_tar", ",", "G_curr_est", "=", "out_G_est", ",", "refresh", "=", "refresh", ",", "perf", "=", "self", ".", "perf", ",", "method", "=", "'multi-mem'", ")", "\n", "\n", "", "elif", "self", ".", "method", "==", "'mixed-precision'", ":", "\n", "                ", "''' Accumulate gradient digitally and apply pulses as in mixed-precision paper\n                '''", "\n", "eps", "=", "0.125", "# Step for W in [-1,1]", "\n", "self", ".", "inp_acc", "+=", "self", ".", "lr_inp", "*", "self", ".", "w_inp_grad", "\n", "self", ".", "rec_acc", "+=", "self", ".", "lr_rec", "*", "self", ".", "w_rec_grad", "\n", "self", ".", "out_acc", "+=", "self", ".", "lr_out", "*", "self", ".", "w_out_grad", "\n", "\n", "grad_inp_quant", "=", "torch", ".", "floor_divide", "(", "self", ".", "inp_acc", ",", "eps", ")", "*", "eps", "# (100,4) in 0.125 steps [-1,1]", "\n", "grad_rec_quant", "=", "torch", ".", "floor_divide", "(", "self", ".", "rec_acc", ",", "eps", ")", "*", "eps", "# (100, 100)", "\n", "grad_out_quant", "=", "torch", ".", "floor_divide", "(", "self", ".", "out_acc", ",", "eps", ")", "*", "eps", "\n", "\n", "self", ".", "inp_acc", "-=", "grad_inp_quant", "\n", "self", ".", "rec_acc", "-=", "grad_rec_quant", "\n", "self", ".", "out_acc", "-=", "grad_out_quant", "\n", "\n", "# Current differential conductance of XBar (perfect estimation)", "\n", "inp_G_est", "=", "(", "self", ".", "inp_xbar", ".", "G", "[", "0", "]", "-", "self", ".", "inp_xbar", ".", "G", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "rec_G_est", "=", "(", "self", ".", "rec_xbar", ".", "G", "[", "0", "]", "-", "self", ".", "rec_xbar", ".", "G", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "out_G_est", "=", "(", "self", ".", "out_xbar", ".", "G", "[", "0", "]", "-", "self", ".", "out_xbar", ".", "G", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Target G", "\n", "inp_G_tar", "=", "inp_G_est", "-", "grad_inp_quant", "*", "self", ".", "inp_xbar", ".", "xbar_scale", "\n", "rec_G_tar", "=", "rec_G_est", "-", "grad_rec_quant", "*", "self", ".", "rec_xbar", ".", "xbar_scale", "\n", "out_G_tar", "=", "out_G_est", "-", "grad_out_quant", "*", "self", ".", "out_xbar", ".", "xbar_scale", "\n", "\n", "self", ".", "inp_xbar", ".", "target_write", "(", "tp", "=", "tp", ",", "G_target", "=", "inp_G_tar", ",", "G_curr_est", "=", "inp_G_est", ",", "refresh", "=", "False", ",", "perf", "=", "self", ".", "perf", ",", "method", "=", "'mixed-precision'", ")", "\n", "self", ".", "rec_xbar", ".", "target_write", "(", "tp", "=", "tp", ",", "G_target", "=", "rec_G_tar", ",", "G_curr_est", "=", "rec_G_est", ",", "refresh", "=", "False", ",", "perf", "=", "self", ".", "perf", ",", "method", "=", "'mixed-precision'", ")", "\n", "self", ".", "out_xbar", ".", "target_write", "(", "tp", "=", "tp", ",", "G_target", "=", "out_G_tar", ",", "G_curr_est", "=", "out_G_est", ",", "refresh", "=", "False", ",", "perf", "=", "self", ".", "perf", ",", "method", "=", "'mixed-precision'", ")", "\n", "\n", "", "", "else", ":", "# Digital Weights", "\n", "            ", "if", "self", ".", "method", "==", "'accumulator'", ":", "\n", "                ", "eps", "=", "0.125", "# Step for W in [-1,1] (Dynamic range=8 for PCM)", "\n", "self", ".", "inp_acc", "+=", "self", ".", "lr_inp", "*", "self", ".", "w_inp_grad", "\n", "self", ".", "rec_acc", "+=", "self", ".", "lr_rec", "*", "self", ".", "w_rec_grad", "\n", "self", ".", "out_acc", "+=", "self", ".", "lr_out", "*", "self", ".", "w_out_grad", "\n", "\n", "grad_inp_quant", "=", "torch", ".", "floor_divide", "(", "self", ".", "inp_acc", ",", "eps", ")", "*", "eps", "\n", "grad_rec_quant", "=", "torch", ".", "floor_divide", "(", "self", ".", "rec_acc", ",", "eps", ")", "*", "eps", "\n", "grad_out_quant", "=", "torch", ".", "floor_divide", "(", "self", ".", "out_acc", ",", "eps", ")", "*", "eps", "\n", "\n", "self", ".", "inp_acc", "-=", "grad_inp_quant", "\n", "self", ".", "rec_acc", "-=", "grad_rec_quant", "\n", "self", ".", "out_acc", "-=", "grad_out_quant", "\n", "\n", "self", ".", "w_inp", ".", "data", "=", "torch", ".", "clamp", "(", "self", ".", "w_inp", ".", "data", "-", "grad_inp_quant", ",", "-", "1", ",", "1", ")", "\n", "self", ".", "w_rec", ".", "data", "=", "torch", ".", "clamp", "(", "self", ".", "w_rec", ".", "data", "-", "grad_rec_quant", ",", "-", "1", ",", "1", ")", "\n", "self", ".", "w_out", ".", "data", "=", "torch", ".", "clamp", "(", "self", ".", "w_out", ".", "data", "-", "grad_out_quant", ",", "-", "1", ",", "1", ")", "\n", "\n", "", "elif", "self", ".", "method", "==", "'vanilla'", ":", "\n", "                ", "''' Vanilla e-prop, only restriction is weights are clipped between -1,1.\n                '''", "\n", "self", ".", "w_inp", ".", "data", "=", "torch", ".", "clamp", "(", "self", ".", "w_inp", ".", "data", "-", "self", ".", "lr_inp", "*", "self", ".", "w_inp_grad", ",", "-", "1", ",", "1", ")", "\n", "self", ".", "w_rec", ".", "data", "=", "torch", ".", "clamp", "(", "self", ".", "w_rec", ".", "data", "-", "self", ".", "lr_rec", "*", "self", ".", "w_rec_grad", ",", "-", "1", ",", "1", ")", "\n", "self", ".", "w_out", ".", "data", "=", "torch", ".", "clamp", "(", "self", ".", "w_out", ".", "data", "-", "self", ".", "lr_out", "*", "self", ".", "w_out_grad", ",", "-", "1", ",", "1", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.__init__": [[10, 47], ["torch.device", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.normal().clamp", "torch.normal"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "G0", "=", "0.1", ",", "N", "=", "1", ",", "size", "=", "(", "1024", ",", "1024", ")", ",", "res", "=", "16", ",", "scale", "=", "12", ",", "prob_scale", "=", "120", ",", "device", "=", "torch", ".", "device", "(", "'cuda'", ")", ")", ":", "\n", "        ", "\"\"\" Initializes the PCM crossbar (XBar) object.\n\n        Args:\n            G0         : Initial conductance value\n            N          : Number of (+/-) pairs per synapse\n            size       : Size of the crossbar array\n            res        : Number of bits per PCM device in perf mode\n            scale      : Scaling factor after matmul operation\n            prob_scale : Scaling factor for probability calculation used in stochastic weight update rule\n        \"\"\"", "\n", "# Parameters", "\n", "self", ".", "a", "=", "2.6", "\n", "self", ".", "m1", "=", "-", "0.084", "\n", "self", ".", "c1", "=", "0.880", "\n", "self", ".", "A1", "=", "1.40", "\n", "self", ".", "m2", "=", "0.091", "\n", "self", ".", "c2", "=", "0.260", "\n", "self", ".", "A2", "=", "2.15", "\n", "self", ".", "m3", "=", "0.03", "\n", "self", ".", "c3", "=", "0.13", "\n", "self", ".", "v", "=", "0.04", "\n", "self", ".", "G0", "=", "G0", "\n", "self", ".", "Gmax", "=", "12", "# Maximum conductance value. Use 20 to replicate Fig 5.", "\n", "self", ".", "dt", "=", "1e-3", "\n", "self", ".", "xbar_scale", "=", "scale", "\n", "self", ".", "xbar_res", "=", "res", "\n", "self", ".", "perf_inc", "=", "self", ".", "Gmax", "/", "(", "2", "**", "self", ".", "xbar_res", ")", "# Control number of steps between min/max conductances", "\n", "self", ".", "size", "=", "size", "\n", "self", ".", "xbar_n", "=", "N", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "Pmem", "=", "torch", ".", "ones", "(", "2", ",", "N", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "device", "=", "self", ".", "device", ")", "# (+/-, N, X, Y)", "\n", "self", ".", "tp", "=", "torch", ".", "zeros", "(", "2", ",", "N", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "dtype", "=", "torch", ".", "double", ",", "device", "=", "self", ".", "device", ")", "# (+/-, N, X, Y)", "\n", "self", ".", "count", "=", "torch", ".", "zeros", "(", "2", ",", "N", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "device", "=", "self", ".", "device", ")", "# (+/-, N, X, Y)", "\n", "self", ".", "tracker", "=", "torch", ".", "zeros", "(", "2", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "device", "=", "self", ".", "device", ")", "# (+/-, X, Y)", "\n", "self", ".", "G", "=", "torch", ".", "normal", "(", "self", ".", "G0", ",", "self", ".", "G0", "*", "0.1", ",", "(", "2", ",", "N", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ")", ",", "device", "=", "self", ".", "device", ")", ".", "clamp", "(", "1e-2", ",", "self", ".", "Gmax", ")", "\n", "self", ".", "prob_scale", "=", "prob_scale", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write": [[48, 68], ["math.exp", "torch.clamp", "torch.clamp", "torch.randn", "torch.sum"], "methods", ["None"], ["", "def", "write", "(", "self", ",", "tp", ",", "mask", ",", "perf", ")", ":", "\n", "        ", "''' Emulates a masked WRITE operation on the PCM crossbar.\n\n        Args:\n            tp   : Timing of the applied WRITE pulse\n            mask : Mask for selecting PCM device\n            perf : If True, perform WRITE operation in the performance mode\n        '''", "\n", "self", ".", "Pmem", "[", "mask", "]", "=", "self", ".", "Pmem", "[", "mask", "]", "*", "math", ".", "exp", "(", "-", "1", "/", "self", ".", "a", ")", "\n", "\n", "# Write + noise", "\n", "mu_dgn", "=", "self", ".", "m1", "*", "self", ".", "G", "[", "mask", "]", "+", "(", "self", ".", "c1", "+", "self", ".", "A1", "*", "self", ".", "Pmem", "[", "mask", "]", ")", "\n", "std_dgn", "=", "self", ".", "m2", "*", "self", ".", "G", "[", "mask", "]", "+", "(", "self", ".", "c2", "+", "self", ".", "A2", "*", "self", ".", "Pmem", "[", "mask", "]", ")", "\n", "dgn", "=", "mu_dgn", "+", "std_dgn", "*", "torch", ".", "randn", "(", "torch", ".", "sum", "(", "mask", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "if", "not", "perf", ":", "\n", "            ", "self", ".", "G", "[", "mask", "]", "=", "torch", ".", "clamp", "(", "self", ".", "G", "[", "mask", "]", "+", "dgn", ",", "0.1", ",", "self", ".", "Gmax", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "G", "[", "mask", "]", "=", "torch", ".", "clamp", "(", "self", ".", "G", "[", "mask", "]", "+", "self", ".", "perf_inc", ",", "0.1", ",", "self", ".", "Gmax", ")", "\n", "", "self", ".", "count", "[", "mask", "]", "=", "self", ".", "count", "[", "mask", "]", "+", "1", "\n", "self", ".", "tp", "[", "mask", "]", "=", "tp", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.read": [[69, 89], ["torch.normal", "torch.pow().float", "torch.zeros_like", "torch.clamp", "torch.clamp", "torch.pow"], "methods", ["None"], ["", "def", "read", "(", "self", ",", "t", ",", "T0", ",", "perf", "=", "False", ")", ":", "\n", "        ", "''' Emulates a READ operation on the PCM crossbar.\n\n        Args:\n            t     : Timing of the applied READ pulse\n            T0    : Initial conductance read after WRITE pulse, constant value (For details, Nandakumar et al. 2018, Eq. 3)\n            perf  : If True, perform READ operation in the performance mode\n        '''", "\n", "# Drift", "\n", "Gd", "=", "self", ".", "G", "*", "torch", ".", "pow", "(", "(", "(", "t", "-", "self", ".", "tp", ")", "/", "T0", ")", ",", "-", "self", ".", "v", ")", ".", "float", "(", ")", "\n", "\n", "# Read noise", "\n", "std_nG", "=", "self", ".", "m3", "*", "Gd", "+", "self", ".", "c3", "\n", "nG", "=", "torch", ".", "normal", "(", "torch", ".", "zeros_like", "(", "Gd", ")", ",", "std_nG", ")", "\n", "\n", "Gn", "=", "torch", ".", "clamp", "(", "Gd", "+", "nG", ",", "0.1", ",", "self", ".", "Gmax", ")", "/", "self", ".", "xbar_scale", "\n", "\n", "if", "perf", ":", "\n", "            ", "Gn", "=", "torch", ".", "clamp", "(", "self", ".", "G", ",", "0.1", ",", "self", ".", "Gmax", ")", "/", "self", ".", "xbar_scale", "\n", "", "return", "Gn", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.reset": [[90, 102], ["torch.normal().clamp", "torch.normal", "torch.sum"], "methods", ["None"], ["", "def", "reset", "(", "self", ",", "tp", ",", "mask", ",", "G0", "=", "0.1", ")", ":", "\n", "        ", "''' Emulates a masked RESET operation on the PCM crossbar.\n\n        Args:\n            mask : Mask for selecting PCM device\n            G0   : Initial conductance value\n        '''", "\n", "self", ".", "Pmem", "[", "mask", "]", "=", "1", "\n", "self", ".", "tp", "[", "mask", "]", "=", "tp", "# Please read Issue #1 regarding the change in this line (this is corrected version). ", "\n", "self", ".", "count", "[", "mask", "]", "=", "0", "\n", "self", ".", "G", "[", "mask", "]", "=", "torch", ".", "normal", "(", "G0", ",", "G0", "*", "0.1", ",", "(", "(", "torch", ".", "sum", "(", "mask", ")", ",", ")", ")", ",", "device", "=", "self", ".", "device", ")", ".", "clamp", "(", "1e-2", ",", "self", ".", "Gmax", ")", "\n", "self", ".", "tracker", "[", "mask", "[", ":", ",", "0", ",", ":", ",", ":", "]", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.G_to_numpulse": [[103, 118], ["torch.floor", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["None"], ["", "def", "G_to_numpulse", "(", "self", ",", "G_curr", ",", "G_target", ")", ":", "\n", "        ", "''' Calculates the number of WRITE pulses to apply for increasing conductance \n            from the current conductance (G_curr) to the target conductance (G_target).\n\n        Args:\n            G_curr  : Current conductance value\n            G_target: Target conductance value\n\n        Returns:\n            numpulse: Number of WRITE pulses to apply\n        '''", "\n", "P_target", "=", "0.027", "*", "torch", ".", "pow", "(", "G_target", ",", "3", ")", "-", "0.15", "*", "torch", ".", "pow", "(", "G_target", ",", "2", ")", "+", "0.81", "*", "G_target", "\n", "P_curr", "=", "0.027", "*", "torch", ".", "pow", "(", "G_curr", ",", "3", ")", "-", "0.15", "*", "torch", ".", "pow", "(", "G_curr", ",", "2", ")", "+", "0.81", "*", "G_curr", "\n", "numpulse", "=", "torch", ".", "floor", "(", "P_target", "-", "P_curr", ")", "\n", "return", "numpulse", "\n", "\n"]], "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.target_write": [[119, 301], ["torch.zeros_like", "torch.zeros_like", "xbar.XBar.write", "torch.zeros", "torch.zeros_like", "range", "torch.zeros_like", "range", "torch.zeros_like", "torch.zeros_like", "torch.stack", "torch.stack", "xbar.XBar.reset", "range", "torch.logical_or", "torch.logical_and().unsqueeze().repeat", "xbar.XBar.reset", "range", "torch.rand", "torch.rand", "int", "torch.zeros_like().bool", "range", "xbar.XBar.write", "torch.relu", "torch.logical_or", "torch.logical_and", "xbar.XBar.reset", "torch.zeros", "range", "torch.logical_or", "torch.logical_and().unsqueeze().repeat", "xbar.XBar.reset", "range", "int", "xbar.XBar.write", "torch.relu", "torch.gather", "torch.abs", "torch.logical_or", "torch.logical_and().unsqueeze().repeat", "xbar.XBar.reset", "range", "int", "xbar.XBar.write", "torch.relu", "torch.abs", "int", "torch.logical_and", "xbar.XBar.write", "torch.relu", "torch.relu.bool", "torch.max", "torch.logical_and", "torch.abs", "int", "torch.zeros_like().bool", "range", "xbar.XBar.write", "torch.relu", "torch.abs", "int", "torch.logical_and", "xbar.XBar.write", "torch.relu", "torch.max", "torch.abs", "torch.stack.unsqueeze", "torch.logical_and", "torch.logical_and", "torch.abs", "int", "torch.logical_and", "xbar.XBar.write", "torch.relu", "torch.max", "torch.logical_and().unsqueeze", "torch.max", "torch.zeros_like", "torch.mean", "torch.mean", "torch.logical_and().unsqueeze().repeat.unsqueeze().repeat", "torch.max", "torch.logical_and", "torch.logical_and().unsqueeze", "torch.max", "torch.sign", "torch.abs", "torch.logical_and().unsqueeze", "torch.max", "torch.mean", "torch.mean", "torch.zeros_like", "torch.logical_and", "torch.logical_and().unsqueeze().repeat.unsqueeze", "torch.logical_and", "torch.logical_and"], "methods", ["home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.reset", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.reset", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.reset", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.reset", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.reset", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write", "home.repos.pwc.inspect_result.YigitDemirag_srnn-pcm.None.xbar.XBar.write"], ["", "def", "target_write", "(", "self", ",", "tp", ",", "G_target", ",", "G_curr_est", "=", "None", ",", "refresh", "=", "False", ",", "perf", "=", "False", ",", "method", "=", "'stochastic'", ")", ":", "\n", "        ", "''' Implements four different weight update mechanisms.\n\n        Args:\n            tp        : Timing of the applied WRITE pulses\n            G_target  : Target conductance value\n            G_curr_est: Current conductance estimate\n            refresh   : If True, refresh the differential pairs matching the refresh criteria\n            perf      : If True, perform WRITE operation in the performance mode\n            method    : Synaptic update mechanisms i.e., `stochastic`, `multi-mem`, `mixed-precision`, `upd-ready`.\n        '''", "\n", "\n", "if", "method", "==", "'stochastic'", ":", "\n", "# PARAMETERS", "\n", "           ", "reset_thr", "=", "9", "# (\u00b5S) condition indicating PCM conductance saturation", "\n", "eps", "=", "0.75", "# (\u00b5S) estimated minimum achivable conductance jump", "\n", "\n", "num_pulse", "=", "torch", ".", "zeros_like", "(", "self", ".", "G", ",", "device", "=", "self", ".", "device", ")", "\n", "prob", "=", "torch", ".", "zeros_like", "(", "self", ".", "G", ",", "device", "=", "self", ".", "device", ")", "\n", "dG", "=", "G_target", "-", "G_curr_est", "\n", "\n", "# refresh (if weights are saturated at high G)", "\n", "if", "refresh", ":", "\n", "               ", "amp_mask", "=", "torch", ".", "logical_or", "(", "self", ".", "G", "[", "0", "]", ">", "reset_thr", ",", "self", ".", "G", "[", "1", "]", ">", "reset_thr", ")", "\n", "diff_mask", "=", "torch", ".", "abs", "(", "self", ".", "G", "[", "0", "]", "-", "self", ".", "G", "[", "1", "]", ")", "<", "(", "reset_thr", "/", "4", ")", "\n", "ref_mask", "=", "torch", ".", "logical_and", "(", "amp_mask", ",", "diff_mask", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "2", ",", "1", ",", "1", ",", "1", ")", "\n", "# back up weight", "\n", "G_tmp", "=", "self", ".", "G", "[", "0", "]", "-", "self", ".", "G", "[", "1", "]", "\n", "# reset the synapses", "\n", "self", ".", "reset", "(", "tp", "=", "tp", ",", "mask", "=", "ref_mask", ")", "\n", "\n", "# calculate number of pulses for each pair", "\n", "num_pulse", "[", "0", "]", "=", "(", "G_tmp", "*", "(", "G_tmp", ">", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "num_pulse", "[", "1", "]", "=", "(", "-", "G_tmp", "*", "(", "G_tmp", "<", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# load old weight values back to single PCM", "\n", "for", "_", "in", "range", "(", "int", "(", "torch", ".", "max", "(", "num_pulse", ")", ")", ")", ":", "\n", "                   ", "update_mask", "=", "torch", ".", "logical_and", "(", "num_pulse", ">", "0", ",", "ref_mask", ")", "\n", "self", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "update_mask", ",", "perf", "=", "perf", ")", "\n", "num_pulse", "=", "torch", ".", "relu", "(", "num_pulse", "-", "1", ")", "\n", "\n", "# calculate update probability", "\n", "", "", "prob", "[", "0", "]", "=", "(", "dG", "*", "(", "dG", ">", "0", ")", "/", "self", ".", "prob_scale", ")", ".", "unsqueeze", "(", "0", ")", "\n", "prob", "[", "1", "]", "=", "(", "-", "dG", "*", "(", "dG", "<", "0", ")", "/", "self", ".", "prob_scale", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# calculate number of pulses to apply for each differential unit", "\n", "num_pulse", "[", "0", "]", "=", "prob", "[", "0", "]", ">", "torch", ".", "rand", "(", "dG", ".", "shape", ",", "device", "=", "self", ".", "device", ")", "\n", "num_pulse", "[", "1", "]", "=", "prob", "[", "1", "]", ">", "torch", ".", "rand", "(", "dG", ".", "shape", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# apply WRITE pulses", "\n", "self", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "num_pulse", ".", "bool", "(", ")", ",", "perf", "=", "perf", ")", "\n", "\n", "", "if", "method", "==", "'multi-mem'", ":", "\n", "# PARAMETERS", "\n", "           ", "reset_thr", "=", "9", "\n", "num_PCM", "=", "self", ".", "xbar_n", "\n", "\n", "num_pulse", "=", "torch", ".", "zeros", "(", "(", "2", ",", "G_target", ".", "shape", "[", "0", "]", ",", "G_target", ".", "shape", "[", "1", "]", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "update_mask", "=", "torch", ".", "zeros_like", "(", "self", ".", "G", ",", "device", "=", "self", ".", "device", ")", "\n", "dG", "=", "G_target", "-", "G_curr_est", "\n", "\n", "# calculate number of pulses for each synapse.", "\n", "eps_per_device", "=", "0.75", "/", "num_PCM", "\n", "num_pulse", "[", "0", "]", "=", "(", "dG", "*", "(", "dG", ">", "0", ")", "/", "eps_per_device", ")", ".", "int", "(", ")", "\n", "num_pulse", "[", "1", "]", "=", "(", "-", "dG", "*", "(", "dG", "<", "0", ")", "/", "eps_per_device", ")", ".", "int", "(", ")", "\n", "# update", "\n", "for", "_", "in", "range", "(", "int", "(", "torch", ".", "max", "(", "num_pulse", ")", ")", ")", ":", "\n", "               ", "update_mask", "=", "torch", ".", "zeros_like", "(", "self", ".", "G", ")", ".", "bool", "(", ")", "\n", "self", ".", "tracker", "=", "self", ".", "tracker", "+", "(", "num_pulse", ">", "0", ")", "\n", "for", "j", "in", "range", "(", "num_PCM", ")", ":", "\n", "                   ", "update_mask", "[", ":", ",", "j", ",", ":", ",", ":", "]", "=", "torch", ".", "logical_and", "(", "(", "num_pulse", ">", "0", ")", ",", "(", "(", "(", "self", ".", "tracker", "-", "1", ")", "%", "num_PCM", ")", "==", "j", ")", ")", "\n", "", "self", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "update_mask", ",", "perf", "=", "perf", ")", "\n", "num_pulse", "=", "torch", ".", "relu", "(", "num_pulse", "-", "1", ")", "\n", "\n", "# refresh", "\n", "", "if", "refresh", ":", "\n", "                ", "Gtmp", "=", "(", "torch", ".", "mean", "(", "self", ".", "G", ",", "1", ")", "[", "0", "]", "-", "torch", ".", "mean", "(", "self", ".", "G", ",", "1", ")", "[", "1", "]", ")", "\n", "ref_mask", "=", "torch", ".", "logical_or", "(", "torch", ".", "mean", "(", "self", ".", "G", ",", "1", ")", "[", "0", "]", ">", "reset_thr", ",", "torch", ".", "mean", "(", "self", ".", "G", ",", "1", ")", "[", "1", "]", ">", "reset_thr", ")", "\n", "diff_mask", "=", "torch", ".", "abs", "(", "Gtmp", ")", "<", "(", "reset_thr", "/", "2", ")", "\n", "ref_mask", "=", "torch", ".", "logical_and", "(", "ref_mask", ",", "diff_mask", ")", "\n", "self", ".", "reset", "(", "mask", "=", "ref_mask", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "2", ",", "num_PCM", ",", "1", ",", "1", ")", ")", "\n", "\n", "# calculate number of pulses", "\n", "num_pulse", "=", "torch", ".", "zeros", "(", "(", "2", ",", "Gtmp", ".", "shape", "[", "0", "]", ",", "Gtmp", ".", "shape", "[", "1", "]", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "eps_per_device", "=", "0.75", "/", "num_PCM", "\n", "num_pulse", "[", "0", "]", "=", "(", "(", "Gtmp", "*", "(", "Gtmp", ">", "0", ")", "/", "eps_per_device", ")", "*", "ref_mask", ")", ".", "int", "(", ")", "\n", "num_pulse", "[", "1", "]", "=", "(", "(", "-", "Gtmp", "*", "(", "Gtmp", "<", "0", ")", "/", "eps_per_device", ")", "*", "ref_mask", ")", ".", "int", "(", ")", "\n", "\n", "# Update xbar", "\n", "for", "_", "in", "range", "(", "int", "(", "torch", ".", "max", "(", "num_pulse", ")", ")", ")", ":", "\n", "                    ", "update_mask", "=", "torch", ".", "zeros_like", "(", "self", ".", "G", ")", ".", "bool", "(", ")", "\n", "self", ".", "tracker", "=", "self", ".", "tracker", "+", "(", "num_pulse", ">", "0", ")", "\n", "for", "j", "in", "range", "(", "num_PCM", ")", ":", "\n", "                        ", "update_mask", "[", ":", ",", "j", ",", ":", ",", ":", "]", "=", "torch", ".", "logical_and", "(", "(", "num_pulse", ">", "0", ")", ",", "(", "(", "(", "self", ".", "tracker", "-", "1", ")", "%", "num_PCM", ")", "==", "j", ")", ")", "\n", "", "self", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "update_mask", ",", "perf", "=", "perf", ")", "\n", "num_pulse", "=", "torch", ".", "relu", "(", "num_pulse", "-", "1", ")", "\n", "\n", "", "", "", "if", "method", "==", "'mixed-precision'", ":", "\n", "# PARAMETERS", "\n", "           ", "reset_thr", "=", "6", "\n", "num_pulse", "=", "torch", ".", "zeros_like", "(", "self", ".", "G", ",", "device", "=", "self", ".", "device", ")", "\n", "dG", "=", "G_target", "-", "G_curr_est", "\n", "eps", "=", "0.75", "\n", "\n", "# refresh (If weights are saturated at high G)", "\n", "if", "refresh", ":", "\n", "               ", "amp_mask", "=", "torch", ".", "logical_or", "(", "self", ".", "G", "[", "0", "]", ">", "reset_thr", ",", "self", ".", "G", "[", "1", "]", ">", "reset_thr", ")", "\n", "diff_mask", "=", "torch", ".", "abs", "(", "self", ".", "G", "[", "0", "]", "-", "self", ".", "G", "[", "1", "]", ")", "<", "(", "reset_thr", "/", "4", ")", "\n", "ref_mask", "=", "torch", ".", "logical_and", "(", "amp_mask", ",", "diff_mask", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "2", ",", "1", ",", "1", ",", "1", ")", "\n", "# back up weight", "\n", "G_tmp", "=", "self", ".", "G", "[", "0", "]", "-", "self", ".", "G", "[", "1", "]", "\n", "# reset the synapse", "\n", "self", ".", "reset", "(", "tp", "=", "tp", ",", "mask", "=", "ref_mask", ")", "\n", "\n", "# calculate number of pulses for each pair", "\n", "num_pulse", "[", "0", "]", "=", "(", "G_tmp", "*", "(", "G_tmp", ">", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "num_pulse", "[", "1", "]", "=", "(", "-", "G_tmp", "*", "(", "G_tmp", "<", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# load old  weight values back to single PCM", "\n", "for", "_", "in", "range", "(", "int", "(", "torch", ".", "max", "(", "num_pulse", ")", ")", ")", ":", "\n", "                   ", "update_mask", "=", "torch", ".", "logical_and", "(", "num_pulse", ">", "0", ",", "ref_mask", ")", "\n", "self", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "update_mask", ",", "perf", "=", "perf", ")", "\n", "num_pulse", "=", "torch", ".", "relu", "(", "num_pulse", "-", "1", ")", "\n", "\n", "# calculate number of pulses to apply for each differential unit", "\n", "", "", "num_pulse", "[", "0", "]", "=", "(", "dG", "*", "(", "dG", ">", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "num_pulse", "[", "1", "]", "=", "(", "-", "dG", "*", "(", "dG", "<", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# apply pulses", "\n", "for", "i", "in", "range", "(", "int", "(", "torch", ".", "max", "(", "num_pulse", ")", ")", ")", ":", "\n", "               ", "update_mask", "=", "num_pulse", ">", "0", "\n", "self", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "update_mask", ",", "perf", "=", "perf", ")", "\n", "num_pulse", "=", "torch", ".", "relu", "(", "num_pulse", "-", "1", ")", "\n", "\n", "", "", "if", "method", "==", "'upd-ready'", ":", "\n", "# PARAMETERS", "\n", "           ", "reset_thr", "=", "6", "\n", "eps", "=", "0.75", "\n", "\n", "num_pulse", "=", "torch", ".", "zeros_like", "(", "self", ".", "G", ",", "device", "=", "self", ".", "device", ")", "\n", "dG", "=", "G_target", "-", "G_curr_est", "\n", "\n", "# update-ready scheme (RESET if targeted update is not possible in single shot)", "\n", "corr", "=", "torch", ".", "zeros_like", "(", "dG", ",", "device", "=", "self", ".", "device", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "corr", "[", "torch", ".", "sign", "(", "dG", ")", "==", "-", "1", "]", "=", "1", "\n", "meme", "=", "torch", ".", "stack", "(", "(", "corr", ",", "torch", ".", "abs", "(", "1", "-", "corr", ")", ")", ")", "\n", "Gsign_pos", "=", "torch", ".", "gather", "(", "self", ".", "G", ",", "0", ",", "meme", ".", "unsqueeze", "(", "1", ")", ")", "[", "0", "]", "\n", "cond", "=", "torch", ".", "abs", "(", "dG", ")", ">", "(", "10", "-", "Gsign_pos", ")", "\n", "reset_ind", "=", "torch", ".", "stack", "(", "(", "torch", ".", "logical_and", "(", "cond", ",", "corr", ")", ",", "torch", ".", "logical_and", "(", "torch", ".", "abs", "(", "1", "-", "corr", ")", ",", "cond", ")", ")", ")", "\n", "self", ".", "reset", "(", "tp", "=", "tp", ",", "mask", "=", "reset_ind", ")", "\n", "dG", "=", "G_target", "-", "(", "self", ".", "G", "[", "0", "]", "-", "self", ".", "G", "[", "1", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "# refresh (If weights are saturated at high G, rewrite)", "\n", "if", "refresh", ":", "\n", "               ", "amp_mask", "=", "torch", ".", "logical_or", "(", "self", ".", "G", "[", "0", "]", ">", "reset_thr", ",", "self", ".", "G", "[", "1", "]", ">", "reset_thr", ")", "\n", "diff_mask", "=", "torch", ".", "abs", "(", "self", ".", "G", "[", "0", "]", "-", "self", ".", "G", "[", "1", "]", ")", "<", "(", "reset_thr", "/", "4", ")", "\n", "ref_mask", "=", "torch", ".", "logical_and", "(", "amp_mask", ",", "diff_mask", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "2", ",", "1", ",", "1", ",", "1", ")", "\n", "# back up weight", "\n", "G_tmp", "=", "(", "self", ".", "G", "[", "0", "]", "-", "self", ".", "G", "[", "1", "]", ")", "# 1,3,3", "\n", "# reset the synapse", "\n", "self", ".", "reset", "(", "tp", "=", "tp", ",", "mask", "=", "ref_mask", ")", "\n", "\n", "# calculate number of pulses for each pair", "\n", "num_pulse", "[", "0", "]", "=", "(", "G_tmp", "*", "(", "G_tmp", ">", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "num_pulse", "[", "1", "]", "=", "(", "-", "G_tmp", "*", "(", "G_tmp", "<", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# load old  weight values back to single PCM", "\n", "for", "i", "in", "range", "(", "int", "(", "torch", ".", "max", "(", "num_pulse", ")", ")", ")", ":", "\n", "                   ", "update_mask", "=", "torch", ".", "logical_and", "(", "num_pulse", ">", "0", ",", "ref_mask", ")", "\n", "self", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "update_mask", ",", "perf", "=", "perf", ")", "\n", "num_pulse", "=", "torch", ".", "relu", "(", "num_pulse", "-", "1", ")", "\n", "\n", "\n", "# calculate number of pulses to apply for each differential unit", "\n", "", "", "num_pulse", "[", "0", "]", "=", "(", "dG", "*", "(", "dG", ">", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "num_pulse", "[", "1", "]", "=", "(", "-", "dG", "*", "(", "dG", "<", "0", ")", "/", "eps", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# apply pulses", "\n", "for", "i", "in", "range", "(", "int", "(", "torch", ".", "max", "(", "num_pulse", ")", ")", ")", ":", "\n", "               ", "update_mask", "=", "num_pulse", ">", "0", "\n", "self", ".", "write", "(", "tp", "=", "tp", ",", "mask", "=", "update_mask", ",", "perf", "=", "perf", ")", "\n", "num_pulse", "=", "torch", ".", "relu", "(", "num_pulse", "-", "1", ")", "\n", "\n"]]}