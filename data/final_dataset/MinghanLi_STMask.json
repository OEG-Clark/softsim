{"home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.CustomDataParallel.gather": [[498, 501], ["sum"], "methods", ["None"], ["def", "gather", "(", "self", ",", "outputs", ",", "output_device", ")", ":", "\n", "# Note that I don't actually want to convert everything to the output_device", "\n", "        ", "return", "sum", "(", "outputs", ",", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.str2bool": [[30, 37], ["v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["def", "str2bool", "(", "v", ")", ":", "\n", "    ", "if", "v", ".", "lower", "(", ")", "in", "(", "'yes'", ",", "'true'", ",", "'t'", ",", "'y'", ",", "'1'", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "'no'", ",", "'false'", ",", "'f'", ",", "'n'", ",", "'0'", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'Boolean value expected.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.parse_args": [[39, 135], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.parse_args", "random.seed"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.parse_args"], ["", "", "def", "parse_args", "(", "argv", "=", "None", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'YOLACT COCO Evaluation'", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "'Batch size for training'", ")", "\n", "parser", ".", "add_argument", "(", "'--trained_model'", ",", "\n", "default", "=", "'weights/ssd300_mAP_77.43_v2.pth'", ",", "type", "=", "str", ",", "\n", "help", "=", "'Trained state_dict file path to open. If \"interrupt\", this will open the interrupt file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--clip_eval_mode'", ",", "default", "=", "False", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Use cuda to evaulate model'", ")", "\n", "parser", ".", "add_argument", "(", "'--top_k'", ",", "default", "=", "100", ",", "type", "=", "int", ",", "\n", "help", "=", "'Further restrict the number of predictions to parse'", ")", "\n", "parser", ".", "add_argument", "(", "'--cuda'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Use cuda to evaulate model'", ")", "\n", "parser", ".", "add_argument", "(", "'--fast_nms'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether to use a faster, but not entirely correct version of NMS.'", ")", "\n", "parser", ".", "add_argument", "(", "'--cross_class_nms'", ",", "default", "=", "False", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether compute NMS cross-class or per-class.'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_masks'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display masks over bounding boxes'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_bboxes'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display bboxes around masks'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_text'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display text (class [score])'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_scores'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display scores in addition to classes'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_fpn_outs'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display outputs after fpn'", ")", "\n", "parser", ".", "add_argument", "(", "'--display'", ",", "dest", "=", "'display'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Display qualitative results instead of quantitative ones.'", ")", "\n", "parser", ".", "add_argument", "(", "'--shuffle'", ",", "dest", "=", "'shuffle'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Shuffles the images when displaying them. Doesn\\'t have much of an effect when display is off though.'", ")", "\n", "parser", ".", "add_argument", "(", "'--ap_data_file'", ",", "default", "=", "'results/ap_data.pkl'", ",", "type", "=", "str", ",", "\n", "help", "=", "'In quantitative mode, the file to save detections before calculating mAP.'", ")", "\n", "parser", ".", "add_argument", "(", "'--resume'", ",", "dest", "=", "'resume'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'If display not set, this resumes mAP calculations from the ap_data_file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_images'", ",", "default", "=", "-", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "'The maximum number of images from the dataset to consider. Use -1 for all.'", ")", "\n", "parser", ".", "add_argument", "(", "'--output_json'", ",", "default", "=", "True", ",", "dest", "=", "'output_json'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'If display is not set, instead of processing IoU values, this just dumps detections into the coco json file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--bbox_det_file'", ",", "default", "=", "'results/eval_bbox_detections.json'", ",", "type", "=", "str", ",", "\n", "help", "=", "'The output file for coco bbox results if --coco_results is set.'", ")", "\n", "parser", ".", "add_argument", "(", "'--mask_det_file'", ",", "default", "=", "'results/eval_mask_detections.json'", ",", "type", "=", "str", ",", "\n", "help", "=", "'The output file for coco mask results if --coco_results is set.'", ")", "\n", "parser", ".", "add_argument", "(", "'--config'", ",", "default", "=", "None", ",", "\n", "help", "=", "'The config object to use.'", ")", "\n", "parser", ".", "add_argument", "(", "'--output_web_json'", ",", "dest", "=", "'output_web_json'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'If display is not set, instead of processing IoU values, this dumps detections for usage with the detections viewer web thingy.'", ")", "\n", "parser", ".", "add_argument", "(", "'--web_det_path'", ",", "default", "=", "'web/dets/'", ",", "type", "=", "str", ",", "\n", "help", "=", "'If output_web_json is set, this is the path to dump detections into.'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_bar'", ",", "dest", "=", "'no_bar'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Do not output the status bar. This is useful for when piping to a file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_lincomb'", ",", "default", "=", "False", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'If the config uses lincomb masks, output a visualization of how those masks are created.'", ")", "\n", "parser", ".", "add_argument", "(", "'--benchmark'", ",", "default", "=", "False", ",", "dest", "=", "'benchmark'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Equivalent to running display mode but without displaying an image.'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_sort'", ",", "default", "=", "True", ",", "dest", "=", "'no_sort'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Do not sort images by hashed image ID.'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "default", "=", "None", ",", "type", "=", "int", ",", "\n", "help", "=", "'The seed to pass into random.seed. Note: this is only really for the shuffle and does not (I think) affect cuda stuff.'", ")", "\n", "parser", ".", "add_argument", "(", "'--mask_proto_debug'", ",", "default", "=", "False", ",", "dest", "=", "'mask_proto_debug'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Outputs stuff for scripts/compute_mask.py.'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_crop'", ",", "default", "=", "False", ",", "dest", "=", "'crop'", ",", "action", "=", "'store_false'", ",", "\n", "help", "=", "'Do not crop output masks with the predicted bounding box.'", ")", "\n", "parser", ".", "add_argument", "(", "'--image'", ",", "default", "=", "None", ",", "type", "=", "str", ",", "\n", "help", "=", "'A path to an image to use for display.'", ")", "\n", "parser", ".", "add_argument", "(", "'--images'", ",", "default", "=", "None", ",", "type", "=", "str", ",", "\n", "help", "=", "'An input folder of images and output folder to save detected images. Should be in the format input->output.'", ")", "\n", "parser", ".", "add_argument", "(", "'--video'", ",", "default", "=", "None", ",", "type", "=", "str", ",", "\n", "help", "=", "'A path to a video to evaluate on. Passing in a number will use that index webcam.'", ")", "\n", "parser", ".", "add_argument", "(", "'--video_multiframe'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of frames to evaluate in parallel to make videos play at higher fps.'", ")", "\n", "parser", ".", "add_argument", "(", "'--score_threshold'", ",", "default", "=", "0", ",", "type", "=", "float", ",", "\n", "help", "=", "'Detections with a score under this threshold will not be considered. This currently only works in display mode.'", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_dataset'", ",", "default", "=", "None", ",", "type", "=", "str", ",", "\n", "help", "=", "'If specified, override the dataset specified in the config with this one (example: coco2017_dataset).'", ")", "\n", "parser", ".", "add_argument", "(", "'--detect'", ",", "default", "=", "False", ",", "dest", "=", "'detect'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Don\\'t evauluate the mask branch at all and only do object detection. This only works for --display and --benchmark.'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_fps'", ",", "default", "=", "False", ",", "dest", "=", "'display_fps'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'When displaying / saving video, draw the FPS on the frame'", ")", "\n", "parser", ".", "add_argument", "(", "'--emulate_playback'", ",", "default", "=", "False", ",", "dest", "=", "'emulate_playback'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'When saving a video, emulate the framerate that you\\'d get running in real-time mode.'", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_types'", ",", "type", "=", "str", ",", "nargs", "=", "'+'", ",", "choices", "=", "[", "'bbox'", ",", "'segm'", "]", ",", "help", "=", "'eval types'", ")", "\n", "parser", ".", "set_defaults", "(", "no_bar", "=", "False", ",", "display", "=", "False", ",", "resume", "=", "False", ",", "output_coco_json", "=", "False", ",", "output_web_json", "=", "False", ",", "\n", "shuffle", "=", "False", ",", "\n", "benchmark", "=", "False", ",", "no_sort", "=", "False", ",", "no_hash", "=", "False", ",", "mask_proto_debug", "=", "False", ",", "crop", "=", "True", ",", "detect", "=", "False", ",", "\n", "display_fps", "=", "False", ",", "emulate_playback", "=", "False", ")", "\n", "\n", "global", "args", "\n", "args", "=", "parser", ".", "parse_args", "(", "argv", ")", "\n", "\n", "if", "args", ".", "output_web_json", ":", "\n", "        ", "args", ".", "output_coco_json", "=", "True", "\n", "\n", "", "if", "args", ".", "seed", "is", "not", "None", ":", "\n", "        ", "random", ".", "seed", "(", "args", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.prep_display": [[143, 317], ["[].detach().cpu().numpy", "min", "range", "layers.output_utils.undo_image_transformation", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "utils.timer.env", "layers.output_utils.postprocess_ytbvis", "torch.cuda.synchronize", "torch.cuda.synchronize", "torch.cuda.synchronize", "[].detach().cpu().numpy", "[].detach().cpu().numpy", "torch.cat", "torch.cat", "torch.cat", "cv2.putText", "reversed", "[].detach().cpu", "inv_alph_masks[].cumprod", "masks_color_cumul.sum", "cv2.getTextSize", "range", "eval.get_color", "torch.Tensor", "torch.Tensor", "torch.Tensor", "[].detach().cpu", "[].detach().cpu", "get_color().view", "masks.repeat", "inv_alph_masks.prod", "layers.output_utils.postprocess_ytbvis.keys", "dets_out[].view().detach().cpu().numpy", "torch.clamp().tolist", "torch.clamp().tolist", "torch.clamp().tolist", "torch.clamp().tolist", "torch.clamp().tolist", "torch.clamp().tolist", "cv2.rectangle", "cv2.rectangle", "cv2.putText", "[].detach", "range", "dets_out[].size", "cv2.getTextSize", "max", "max", "[].detach", "[].detach", "eval.get_color", "dets_out[].view().detach().cpu", "int", "int", "int", "int", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "max", "max", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "dets_out[].view().detach", "str", "str", "dets_out[].view", "color_type[].cpu().numpy", "color_type[].cpu().numpy", "color_type[].cpu", "color_type[].cpu"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.undo_image_transformation", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.postprocess_ytbvis", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.get_color", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.get_color"], ["def", "prep_display", "(", "dets_out", ",", "img", ",", "img_ids", "=", "None", ",", "img_meta", "=", "None", ",", "undo_transform", "=", "True", ",", "mask_alpha", "=", "0.45", ",", "\n", "fps_str", "=", "''", ")", ":", "\n", "    ", "\"\"\"\n    Note: If undo_transform=False then im_h and im_w are allowed to be None.\n    -- display_model: 'train', 'test', 'None' means groundtruth results\n    \"\"\"", "\n", "\n", "pad_h", ",", "pad_w", "=", "img_meta", "[", "'pad_shape'", "]", "[", ":", "2", "]", "\n", "if", "undo_transform", ":", "\n", "        ", "img_numpy", "=", "undo_image_transformation", "(", "img", ",", "img_meta", ",", "pad_h", ",", "pad_w", ")", "\n", "img_gpu", "=", "torch", ".", "Tensor", "(", "img_numpy", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "        ", "img_gpu", "=", "img", "/", "255.0", "\n", "pad_h", ",", "pad_w", ",", "_", "=", "img", ".", "shape", "\n", "", "ori_h", ",", "ori_w", ",", "_", "=", "img_meta", "[", "'ori_shape'", "]", "\n", "\n", "with", "timer", ".", "env", "(", "'Postprocess'", ")", ":", "\n", "        ", "cfg", ".", "mask_proto_debug", "=", "args", ".", "mask_proto_debug", "\n", "# cfg.preserve_aspect_ratio = False", "\n", "dets_out", "=", "postprocess_ytbvis", "(", "dets_out", ",", "img_meta", ",", "display_mask", "=", "True", ",", "\n", "visualize_lincomb", "=", "args", ".", "display_lincomb", ",", "\n", "crop_masks", "=", "args", ".", "crop", ",", "\n", "score_threshold", "=", "cfg", ".", "eval_conf_thresh", ",", "\n", "img_ids", "=", "img_ids", ",", "\n", "mask_det_file", "=", "args", ".", "mask_det_file", ")", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "scores", "=", "dets_out", "[", "'score'", "]", "[", ":", "args", ".", "top_k", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "boxes", "=", "dets_out", "[", "'box'", "]", "[", ":", "args", ".", "top_k", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "if", "'segm'", "in", "dets_out", ":", "\n", "        ", "masks", "=", "dets_out", "[", "'segm'", "]", "[", ":", "args", ".", "top_k", "]", "\n", "args", ".", "display_masks", "=", "True", "\n", "", "else", ":", "\n", "        ", "args", ".", "display_masks", "=", "False", "\n", "\n", "", "classes", "=", "dets_out", "[", "'class'", "]", "[", ":", "args", ".", "top_k", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "num_dets_to_consider", "=", "min", "(", "args", ".", "top_k", ",", "classes", ".", "shape", "[", "0", "]", ")", "\n", "color_type", "=", "dets_out", "[", "'box_ids'", "]", "\n", "for", "j", "in", "range", "(", "num_dets_to_consider", ")", ":", "\n", "        ", "if", "scores", "[", "j", "]", "<", "args", ".", "score_threshold", ":", "\n", "            ", "num_dets_to_consider", "=", "j", "\n", "break", "\n", "\n", "", "", "if", "num_dets_to_consider", "==", "0", ":", "\n", "# No detections found so just output the original image", "\n", "        ", "return", "(", "img_gpu", "*", "255", ")", ".", "byte", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# First, draw the masks on the GPU where we can do it really fast", "\n", "# Beware: very fast but possibly unintelligible mask-drawing code ahead", "\n", "# I wish I had access to OpenGL or Vulkan but alas, I guess Pytorch tensor operations will have to suffice", "\n", "", "if", "args", ".", "display_masks", "and", "cfg", ".", "eval_mask_branch", ":", "\n", "# After this, mask is of size [num_dets, h, w, 1]", "\n", "        ", "masks", "=", "masks", "[", ":", "num_dets_to_consider", ",", ":", ",", ":", ",", "None", "]", "\n", "\n", "# Prepare the RGB images for each mask given their color (size [num_dets, h, w, 1])", "\n", "colors", "=", "torch", ".", "cat", "(", "\n", "[", "get_color", "(", "j", ",", "color_type", ",", "on_gpu", "=", "img_gpu", ".", "device", ".", "index", ",", "undo_transform", "=", "undo_transform", ")", ".", "view", "(", "1", ",", "1", ",", "1", ",", "3", ")", "\n", "for", "j", "in", "range", "(", "num_dets_to_consider", ")", "]", ",", "dim", "=", "0", ")", "\n", "masks_color", "=", "masks", ".", "repeat", "(", "1", ",", "1", ",", "1", ",", "3", ")", "*", "colors", "*", "mask_alpha", "\n", "\n", "# This is 1 everywhere except for 1-mask_alpha where the mask is", "\n", "inv_alph_masks", "=", "masks", "*", "(", "-", "mask_alpha", ")", "+", "1", "\n", "\n", "# I did the math for this on pen and paper. This whole block should be equivalent to:", "\n", "#    for j in range(num_dets_to_consider):", "\n", "#        img_gpu = img_gpu * inv_alph_masks[j] + masks_color[j]", "\n", "masks_color_summand", "=", "masks_color", "[", "0", "]", "\n", "if", "num_dets_to_consider", ">", "1", ":", "\n", "            ", "inv_alph_cumul", "=", "inv_alph_masks", "[", ":", "(", "num_dets_to_consider", "-", "1", ")", "]", ".", "cumprod", "(", "dim", "=", "0", ")", "\n", "masks_color_cumul", "=", "masks_color", "[", "1", ":", "]", "*", "inv_alph_cumul", "\n", "masks_color_summand", "+=", "masks_color_cumul", ".", "sum", "(", "dim", "=", "0", ")", "\n", "", "img_gpu", "=", "img_gpu", "*", "inv_alph_masks", ".", "prod", "(", "dim", "=", "0", ")", "+", "masks_color_summand", "\n", "\n", "", "if", "args", ".", "display_fps", ":", "\n", "# Draw the box for the fps on the GPU", "\n", "        ", "font_face", "=", "cv2", ".", "FONT_HERSHEY_DUPLEX", "\n", "font_scale", "=", "0.6", "\n", "font_thickness", "=", "1", "\n", "\n", "text_w", ",", "text_h", "=", "cv2", ".", "getTextSize", "(", "fps_str", ",", "font_face", ",", "font_scale", ",", "font_thickness", ")", "[", "0", "]", "\n", "\n", "img_gpu", "[", "0", ":", "text_h", "+", "8", ",", "0", ":", "text_w", "+", "8", "]", "*=", "0.6", "# 1 - Box alpha", "\n", "\n", "# Then draw the stuff that needs to be done on the cpu", "\n", "# Note, make sure this is a uint8 tensor or opencv will not anti alias text for whatever reason", "\n", "", "img_numpy", "=", "(", "img_gpu", "*", "255", ")", ".", "byte", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "if", "args", ".", "display_fps", ":", "\n", "# Draw the text on the CPU", "\n", "        ", "text_pt", "=", "(", "4", ",", "text_h", "+", "2", ")", "\n", "text_color", "=", "[", "255", ",", "255", ",", "255", "]", "\n", "\n", "cv2", ".", "putText", "(", "img_numpy", ",", "fps_str", ",", "text_pt", ",", "font_face", ",", "font_scale", ",", "text_color", ",", "font_thickness", ",", "cv2", ".", "LINE_AA", ")", "\n", "\n", "", "if", "args", ".", "display_text", "or", "args", ".", "display_bboxes", ":", "\n", "        ", "for", "j", "in", "reversed", "(", "range", "(", "num_dets_to_consider", ")", ")", ":", "\n", "# get the bbox_idx to know box's layers (after FPN): p3-p7", "\n", "# box_idx = dets_out['bbox_idx'][j]", "\n", "# p_nums = [34560, 43200, 45360, 45900, 46035]", "\n", "# p_nums = [11520, 14400, 15120, 15300, 15345]", "\n", "# p = 0", "\n", "# for i in range(len(p_nums)):", "\n", "#     if box_idx < p_nums[i]:", "\n", "#         p = i + 3", "\n", "#         break", "\n", "\n", "            ", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "boxes", "[", "j", ",", ":", "]", "\n", "color", "=", "get_color", "(", "j", ",", "color_type", ")", "\n", "# plot priors", "\n", "h", ",", "w", ",", "_", "=", "img_meta", "[", "'img_shape'", "]", "\n", "if", "'priors'", "in", "dets_out", ".", "keys", "(", ")", ":", "\n", "                ", "priors", "=", "dets_out", "[", "'priors'", "]", ".", "view", "(", "-", "1", ",", "4", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "j", "<", "dets_out", "[", "'priors'", "]", ".", "size", "(", "0", ")", ":", "\n", "                    ", "cpx", ",", "cpy", ",", "pw", ",", "ph", "=", "priors", "[", "j", ",", ":", "]", "*", "[", "w", ",", "h", ",", "w", ",", "h", "]", "\n", "px1", ",", "py1", "=", "cpx", "-", "pw", "/", "2.0", ",", "cpy", "-", "ph", "/", "2.0", "\n", "px2", ",", "py2", "=", "cpx", "+", "pw", "/", "2.0", ",", "cpy", "+", "ph", "/", "2.0", "\n", "px1", ",", "py1", ",", "px2", ",", "py2", "=", "int", "(", "px1", ")", ",", "int", "(", "py1", ")", ",", "int", "(", "px2", ")", ",", "int", "(", "py2", ")", "\n", "pcolor", "=", "[", "255", ",", "0", ",", "255", "]", "\n", "\n", "# plot the range of features for classification and regression", "\n", "", "", "pred_scales", "=", "[", "24", ",", "48", ",", "96", ",", "192", ",", "384", "]", "\n", "# cpx, cpy = (px1+px2)/2, (py1+py2)/2", "\n", "# fx1, fy1 = cpx - pred_scales[p - 3] / 2, cpy - pred_scales[p - 3] / 2", "\n", "# fx2, fy2 = cpx + pred_scales[p - 3] / 2, cpy + pred_scales[p - 3] / 2", "\n", "# fx1, fy1, fx2, fy2 = int(fx1), int(fy1), int(fx2), int(fy2)", "\n", "# fcolor = [255, 128, 0]", "\n", "max_w", "=", "ori_w", "if", "cfg", ".", "preserve_aspect_ratio", "else", "pad_w", "\n", "max_h", "=", "ori_h", "if", "cfg", ".", "preserve_aspect_ratio", "else", "pad_h", "\n", "x", "=", "torch", ".", "clamp", "(", "torch", ".", "tensor", "(", "[", "x1", ",", "x2", "]", ")", ",", "min", "=", "2", ",", "max", "=", "max_w", ")", ".", "tolist", "(", ")", ",", "\n", "y", "=", "torch", ".", "clamp", "(", "torch", ".", "tensor", "(", "[", "y1", ",", "y2", "]", ")", ",", "min", "=", "2", ",", "max", "=", "max_h", ")", ".", "tolist", "(", ")", ",", "\n", "x", ",", "y", "=", "x", "[", "0", "]", ",", "y", "[", "0", "]", "\n", "\n", "score", "=", "scores", "[", "j", "]", "\n", "\n", "if", "args", ".", "display_bboxes", ":", "\n", "                ", "cv2", ".", "rectangle", "(", "img_numpy", ",", "(", "x", "[", "0", "]", ",", "y", "[", "0", "]", ")", ",", "(", "x", "[", "1", "]", ",", "y", "[", "1", "]", ")", ",", "color", ",", "2", ")", "\n", "# if 'priors' in dets_out.keys():", "\n", "#     if j < dets_out['priors'].size(0):", "\n", "#         cv2.rectangle(img_numpy, (px1, py1), (px2, py2), pcolor, 2, lineType=8)", "\n", "# cv2.rectangle(img_numpy, (x[4], y[4]), (x[5], y[5]), fcolor, 2)", "\n", "\n", "", "if", "args", ".", "display_text", ":", "\n", "                ", "if", "classes", "[", "j", "]", "-", "1", "<", "0", ":", "\n", "                    ", "_class", "=", "'None'", "\n", "", "else", ":", "\n", "                    ", "_class", "=", "cfg", ".", "classes", "[", "classes", "[", "j", "]", "-", "1", "]", "\n", "\n", "", "if", "score", "is", "not", "None", ":", "\n", "# if cfg.use_maskiou and not cfg.rescore_bbox:", "\n", "                    ", "train_DIoU", "=", "False", "\n", "if", "train_DIoU", ":", "\n", "                        ", "rescore", "=", "dets_out", "[", "'DIoU_score'", "]", "[", "j", "]", "*", "score", "\n", "text_str", "=", "'%s: %.2f: %.2f: %s'", "%", "(", "_class", ",", "score", ",", "rescore", ",", "str", "(", "color_type", "[", "j", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "if", "args", ".", "display_scores", "else", "_class", "\n", "", "else", ":", "\n", "\n", "                        ", "text_str", "=", "'%s: %.2f: %s'", "%", "(", "\n", "_class", ",", "score", ",", "str", "(", "color_type", "[", "j", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "if", "args", ".", "display_scores", "else", "_class", "\n", "", "", "else", ":", "\n", "                    ", "text_str", "=", "'%s'", "%", "_class", "\n", "\n", "", "font_face", "=", "cv2", ".", "FONT_HERSHEY_DUPLEX", "\n", "font_scale", "=", "0.5", "\n", "font_thickness", "=", "1", "\n", "\n", "text_w", ",", "text_h", "=", "cv2", ".", "getTextSize", "(", "text_str", ",", "font_face", ",", "font_scale", ",", "font_thickness", ")", "[", "0", "]", "\n", "\n", "text_pt", "=", "(", "max", "(", "x1", ",", "10", ")", ",", "max", "(", "y1", "-", "3", ",", "10", ")", ")", "\n", "text_color", "=", "[", "255", ",", "255", ",", "255", "]", "\n", "cv2", ".", "rectangle", "(", "img_numpy", ",", "(", "max", "(", "x1", ",", "10", ")", ",", "max", "(", "y1", ",", "10", ")", ")", ",", "(", "x1", "+", "text_w", ",", "y1", "-", "text_h", "-", "4", ")", ",", "color", ",", "-", "1", ")", "\n", "cv2", ".", "putText", "(", "img_numpy", ",", "text_str", ",", "text_pt", ",", "font_face", ",", "font_scale", ",", "text_color", ",", "font_thickness", ",", "\n", "cv2", ".", "LINE_AA", ")", "\n", "\n", "", "", "", "return", "img_numpy", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.get_color": [[321, 336], ["len", "torch.Tensor().to().float", "torch.Tensor().to().float", "torch.Tensor().to().float", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "function", ["None"], ["", "def", "get_color", "(", "j", ",", "color_type", ",", "on_gpu", "=", "None", ",", "undo_transform", "=", "True", ")", ":", "\n", "    ", "global", "color_cache", "\n", "color_idx", "=", "(", "color_type", "[", "j", "]", "*", "5", ")", "%", "len", "(", "cfg", ".", "COLORS", ")", "\n", "\n", "if", "on_gpu", "is", "not", "None", "and", "color_idx", "in", "color_cache", "[", "on_gpu", "]", ":", "\n", "        ", "return", "color_cache", "[", "on_gpu", "]", "[", "color_idx", "]", "\n", "", "else", ":", "\n", "        ", "color", "=", "cfg", ".", "COLORS", "[", "color_idx", "]", "\n", "if", "not", "undo_transform", ":", "\n", "# The image might come in as RGB or BRG, depending", "\n", "            ", "color", "=", "(", "color", "[", "2", "]", ",", "color", "[", "1", "]", ",", "color", "[", "0", "]", ")", "\n", "", "if", "on_gpu", "is", "not", "None", ":", "\n", "            ", "color", "=", "torch", ".", "Tensor", "(", "color", ")", ".", "to", "(", "on_gpu", ")", ".", "float", "(", ")", "/", "255.", "\n", "color_cache", "[", "on_gpu", "]", "[", "color_idx", "]", "=", "color", "\n", "", "return", "color", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.prep_display_single": [[338, 493], ["[].detach().cpu().numpy", "min", "range", "layers.output_utils.undo_image_transformation", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "utils.timer.env", "layers.output_utils.postprocess_ytbvis", "torch.cuda.synchronize", "torch.cuda.synchronize", "torch.cuda.synchronize", "[].detach().cpu().numpy", "[].detach().cpu().numpy", "torch.cat", "torch.cat", "torch.cat", "cv2.putText", "reversed", "[].detach().cpu", "inv_alph_masks[].cumprod", "masks_color_cumul.sum", "cv2.getTextSize", "range", "eval.get_color", "dets_out[].detach().cpu().numpy", "torch.Tensor", "torch.Tensor", "torch.Tensor", "[].detach().cpu", "[].detach().cpu", "get_color().view", "masks.repeat", "inv_alph_masks.prod", "dets_out[].size", "torch.clamp().tolist", "torch.clamp().tolist", "torch.clamp().tolist", "torch.clamp().tolist", "torch.clamp().tolist", "torch.clamp().tolist", "cv2.rectangle", "cv2.rectangle", "cv2.putText", "[].detach", "range", "dets_out[].detach().cpu", "int", "int", "int", "int", "dets_out[].size", "cv2.rectangle", "cv2.getTextSize", "[].detach", "[].detach", "eval.get_color", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "dets_out[].detach", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "str", "str", "color_type[].cpu().numpy", "color_type[].cpu().numpy", "color_type[].cpu", "color_type[].cpu"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.undo_image_transformation", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.postprocess_ytbvis", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.get_color", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.get_color"], ["", "", "def", "prep_display_single", "(", "dets_out", ",", "img", ",", "pad_h", ",", "pad_w", ",", "img_ids", "=", "None", ",", "img_meta", "=", "None", ",", "undo_transform", "=", "True", ",", "mask_alpha", "=", "0.45", ",", "\n", "fps_str", "=", "''", ",", "display_mode", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Note: If undo_transform=False then im_h and im_w are allowed to be None.\n    -- display_model: 'train', 'test', 'None' means groundtruth results\n    \"\"\"", "\n", "\n", "if", "undo_transform", ":", "\n", "        ", "img_numpy", "=", "undo_image_transformation", "(", "img", ",", "img_meta", ",", "pad_h", ",", "pad_w", ")", "\n", "img_gpu", "=", "torch", ".", "Tensor", "(", "img_numpy", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "        ", "img_gpu", "=", "img", "/", "255.0", "\n", "pad_h", ",", "pad_w", ",", "_", "=", "img", ".", "shape", "\n", "\n", "", "with", "timer", ".", "env", "(", "'Postprocess'", ")", ":", "\n", "        ", "cfg", ".", "mask_proto_debug", "=", "args", ".", "mask_proto_debug", "\n", "cfg", ".", "preserve_aspect_ratio", "=", "False", "\n", "dets_out", "=", "postprocess_ytbvis", "(", "dets_out", ",", "img_meta", ",", "display_mask", "=", "True", ",", "\n", "visualize_lincomb", "=", "args", ".", "display_lincomb", ",", "\n", "crop_masks", "=", "args", ".", "crop", ",", "\n", "score_threshold", "=", "cfg", ".", "eval_conf_thresh", ",", "\n", "img_ids", "=", "img_ids", ",", "\n", "mask_det_file", "=", "args", ".", "mask_det_file", ")", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "scores", "=", "dets_out", "[", "'score'", "]", "[", ":", "args", ".", "top_k", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "boxes", "=", "dets_out", "[", "'box'", "]", "[", ":", "args", ".", "top_k", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "if", "'segm'", "in", "dets_out", ":", "\n", "        ", "masks", "=", "dets_out", "[", "'segm'", "]", "[", ":", "args", ".", "top_k", "]", "\n", "args", ".", "display_masks", "=", "True", "\n", "", "else", ":", "\n", "        ", "args", ".", "display_masks", "=", "False", "\n", "\n", "", "classes", "=", "dets_out", "[", "'class'", "]", "[", ":", "args", ".", "top_k", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "num_dets_to_consider", "=", "min", "(", "args", ".", "top_k", ",", "classes", ".", "shape", "[", "0", "]", ")", "\n", "color_type", "=", "dets_out", "[", "'box_ids'", "]", "\n", "for", "j", "in", "range", "(", "num_dets_to_consider", ")", ":", "\n", "        ", "if", "scores", "[", "j", "]", "<", "args", ".", "score_threshold", ":", "\n", "            ", "num_dets_to_consider", "=", "j", "\n", "break", "\n", "\n", "", "", "if", "num_dets_to_consider", "==", "0", ":", "\n", "# No detections found so just output the original image", "\n", "        ", "return", "(", "img_gpu", "*", "255", ")", ".", "byte", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# First, draw the masks on the GPU where we can do it really fast", "\n", "# Beware: very fast but possibly unintelligible mask-drawing code ahead", "\n", "# I wish I had access to OpenGL or Vulkan but alas, I guess Pytorch tensor operations will have to suffice", "\n", "", "if", "args", ".", "display_masks", "and", "cfg", ".", "eval_mask_branch", ":", "\n", "# After this, mask is of size [num_dets, h, w, 1]", "\n", "        ", "masks", "=", "masks", "[", ":", "num_dets_to_consider", ",", ":", ",", ":", ",", "None", "]", "\n", "\n", "# Prepare the RGB images for each mask given their color (size [num_dets, h, w, 1])", "\n", "colors", "=", "torch", ".", "cat", "(", "\n", "[", "get_color", "(", "j", ",", "color_type", ",", "on_gpu", "=", "img_gpu", ".", "device", ".", "index", ",", "undo_transform", "=", "undo_transform", ")", ".", "view", "(", "1", ",", "1", ",", "1", ",", "3", ")", "\n", "for", "j", "in", "range", "(", "num_dets_to_consider", ")", "]", ",", "dim", "=", "0", ")", "\n", "masks_color", "=", "masks", ".", "repeat", "(", "1", ",", "1", ",", "1", ",", "3", ")", "*", "colors", "*", "mask_alpha", "\n", "\n", "# This is 1 everywhere except for 1-mask_alpha where the mask is", "\n", "inv_alph_masks", "=", "masks", "*", "(", "-", "mask_alpha", ")", "+", "1", "\n", "\n", "# I did the math for this on pen and paper. This whole block should be equivalent to:", "\n", "#    for j in range(num_dets_to_consider):", "\n", "#        img_gpu = img_gpu * inv_alph_masks[j] + masks_color[j]", "\n", "masks_color_summand", "=", "masks_color", "[", "0", "]", "\n", "if", "num_dets_to_consider", ">", "1", ":", "\n", "            ", "inv_alph_cumul", "=", "inv_alph_masks", "[", ":", "(", "num_dets_to_consider", "-", "1", ")", "]", ".", "cumprod", "(", "dim", "=", "0", ")", "\n", "masks_color_cumul", "=", "masks_color", "[", "1", ":", "]", "*", "inv_alph_cumul", "\n", "masks_color_summand", "+=", "masks_color_cumul", ".", "sum", "(", "dim", "=", "0", ")", "\n", "", "img_gpu", "=", "img_gpu", "*", "inv_alph_masks", ".", "prod", "(", "dim", "=", "0", ")", "+", "masks_color_summand", "\n", "\n", "", "if", "args", ".", "display_fps", ":", "\n", "# Draw the box for the fps on the GPU", "\n", "        ", "font_face", "=", "cv2", ".", "FONT_HERSHEY_DUPLEX", "\n", "font_scale", "=", "0.6", "\n", "font_thickness", "=", "1", "\n", "\n", "text_w", ",", "text_h", "=", "cv2", ".", "getTextSize", "(", "fps_str", ",", "font_face", ",", "font_scale", ",", "font_thickness", ")", "[", "0", "]", "\n", "\n", "img_gpu", "[", "0", ":", "text_h", "+", "8", ",", "0", ":", "text_w", "+", "8", "]", "*=", "0.6", "# 1 - Box alpha", "\n", "\n", "# Then draw the stuff that needs to be done on the cpu", "\n", "# Note, make sure this is a uint8 tensor or opencv will not anti alias text for whatever reason", "\n", "", "img_numpy", "=", "(", "img_gpu", "*", "255", ")", ".", "byte", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "if", "args", ".", "display_fps", ":", "\n", "# Draw the text on the CPU", "\n", "        ", "text_pt", "=", "(", "4", ",", "text_h", "+", "2", ")", "\n", "text_color", "=", "[", "255", ",", "255", ",", "255", "]", "\n", "\n", "cv2", ".", "putText", "(", "img_numpy", ",", "fps_str", ",", "text_pt", ",", "font_face", ",", "font_scale", ",", "text_color", ",", "font_thickness", ",", "cv2", ".", "LINE_AA", ")", "\n", "\n", "", "if", "args", ".", "display_text", "or", "args", ".", "display_bboxes", ":", "\n", "        ", "for", "j", "in", "reversed", "(", "range", "(", "num_dets_to_consider", ")", ")", ":", "\n", "            ", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "boxes", "[", "j", ",", ":", "]", "\n", "color", "=", "get_color", "(", "j", ",", "color_type", ")", "\n", "# plot priors", "\n", "h", ",", "w", ",", "_", "=", "img_meta", "[", "'img_shape'", "]", "\n", "priors", "=", "dets_out", "[", "'priors'", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "j", "<", "dets_out", "[", "'priors'", "]", ".", "size", "(", "0", ")", ":", "\n", "                ", "cpx", ",", "cpy", ",", "pw", ",", "ph", "=", "priors", "[", "j", ",", ":", "]", "*", "[", "w", ",", "h", ",", "w", ",", "h", "]", "\n", "px1", ",", "py1", "=", "cpx", "-", "pw", "/", "2.0", ",", "cpy", "-", "ph", "/", "2.0", "\n", "px2", ",", "py2", "=", "cpx", "+", "pw", "/", "2.0", ",", "cpy", "+", "ph", "/", "2.0", "\n", "px1", ",", "py1", ",", "px2", ",", "py2", "=", "int", "(", "px1", ")", ",", "int", "(", "py1", ")", ",", "int", "(", "px2", ")", ",", "int", "(", "py2", ")", "\n", "pcolor", "=", "[", "255", ",", "0", ",", "255", "]", "\n", "\n", "# plot the range of features for classification and regression", "\n", "", "pred_scales", "=", "[", "24", ",", "48", ",", "96", ",", "192", ",", "384", "]", "\n", "x", "=", "torch", ".", "clamp", "(", "torch", ".", "tensor", "(", "[", "x1", ",", "x2", "]", ")", ",", "min", "=", "2", ",", "max", "=", "638", ")", ".", "tolist", "(", ")", ",", "\n", "y", "=", "torch", ".", "clamp", "(", "torch", ".", "tensor", "(", "[", "y1", ",", "y2", "]", ")", ",", "min", "=", "2", ",", "max", "=", "358", ")", ".", "tolist", "(", ")", ",", "\n", "x", ",", "y", "=", "x", "[", "0", "]", ",", "y", "[", "0", "]", "\n", "\n", "if", "display_mode", "is", "not", "None", ":", "\n", "                ", "score", "=", "scores", "[", "j", "]", "\n", "\n", "", "if", "args", ".", "display_bboxes", ":", "\n", "                ", "cv2", ".", "rectangle", "(", "img_numpy", ",", "(", "x", "[", "0", "]", ",", "y", "[", "0", "]", ")", ",", "(", "x", "[", "1", "]", ",", "y", "[", "1", "]", ")", ",", "color", ",", "1", ")", "\n", "if", "j", "<", "dets_out", "[", "'priors'", "]", ".", "size", "(", "0", ")", ":", "\n", "                    ", "cv2", ".", "rectangle", "(", "img_numpy", ",", "(", "px1", ",", "py1", ")", ",", "(", "px2", ",", "py2", ")", ",", "pcolor", ",", "2", ",", "lineType", "=", "8", ")", "\n", "# cv2.rectangle(img_numpy, (x[4], y[4]), (x[5], y[5]), fcolor, 2)", "\n", "\n", "", "", "if", "args", ".", "display_text", ":", "\n", "                ", "if", "classes", "[", "j", "]", "-", "1", "<", "0", ":", "\n", "                    ", "_class", "=", "'None'", "\n", "", "else", ":", "\n", "                    ", "_class", "=", "cfg", ".", "classes", "[", "classes", "[", "j", "]", "-", "1", "]", "\n", "\n", "", "if", "display_mode", "==", "'test'", ":", "\n", "# if cfg.use_maskiou and not cfg.rescore_bbox:", "\n", "                    ", "train_centerness", "=", "False", "\n", "if", "train_centerness", ":", "\n", "                        ", "rescore", "=", "dets_out", "[", "'DIoU_score'", "]", "[", "j", "]", "*", "score", "\n", "text_str", "=", "'%s: %.2f: %.2f: %s'", "%", "(", "_class", ",", "score", ",", "rescore", ",", "str", "(", "color_type", "[", "j", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "if", "args", ".", "display_scores", "else", "_class", "\n", "", "else", ":", "\n", "\n", "                        ", "text_str", "=", "'%s: %.2f: %s'", "%", "(", "\n", "_class", ",", "score", ",", "str", "(", "color_type", "[", "j", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "if", "args", ".", "display_scores", "else", "_class", "\n", "", "", "else", ":", "\n", "                    ", "text_str", "=", "'%s'", "%", "_class", "\n", "\n", "", "font_face", "=", "cv2", ".", "FONT_HERSHEY_DUPLEX", "\n", "font_scale", "=", "0.5", "\n", "font_thickness", "=", "1", "\n", "\n", "text_w", ",", "text_h", "=", "cv2", ".", "getTextSize", "(", "text_str", ",", "font_face", ",", "font_scale", ",", "font_thickness", ")", "[", "0", "]", "\n", "\n", "text_pt", "=", "(", "x1", ",", "y1", "-", "3", ")", "\n", "text_color", "=", "[", "255", ",", "255", ",", "255", "]", "\n", "cv2", ".", "rectangle", "(", "img_numpy", ",", "(", "x1", ",", "y1", ")", ",", "(", "x1", "+", "text_w", ",", "y1", "-", "text_h", "-", "4", ")", ",", "color", ",", "-", "1", ")", "\n", "cv2", ".", "putText", "(", "img_numpy", ",", "text_str", ",", "text_pt", ",", "font_face", ",", "font_scale", ",", "text_color", ",", "font_thickness", ",", "\n", "cv2", ".", "LINE_AA", ")", "\n", "\n", "", "", "", "return", "img_numpy", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.validation": [[503, 577], ["utils.functions.MovingAverage", "utils.functions.ProgressBar", "print", "torch.DataLoader", "datasets.get_dataset", "datasets.get_dataset", "math.ceil", "min", "enumerate", "print", "print", "len", "utils.timer.reset", "utils.functions.ProgressBar.set_val", "print", "layers.eval_utils.results2json_videoseg", "print", "layers.eval_utils.calc_metrics", "layers.eval_utils.results2json_videoseg", "print", "len", "utils.timer.env", "datasets.prepare_data", "utils.timer.env", "net", "range", "utils.functions.MovingAverage.add", "output_metrics_file.replace", "images.size", "layers.output_utils.postprocess_ytbvis", "layers.eval_utils.bbox2result_with_id", "results.append", "utils.functions.MovingAverage.get_avg", "utils.functions.MovingAverage.get_avg", "len", "utils.timer.total_time", "repr"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.get_dataset", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.get_dataset", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.reset", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.results2json_videoseg", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.calc_metrics", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.results2json_videoseg", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.prepare_data", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.replace", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.postprocess_ytbvis", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.bbox2result_with_id", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.total_time"], ["", "", "def", "validation", "(", "net", ":", "STMask", ",", "valid_data", "=", "False", ",", "output_metrics_file", "=", "None", ")", ":", "\n", "    ", "cfg", ".", "mask_proto_debug", "=", "args", ".", "mask_proto_debug", "\n", "if", "not", "valid_data", ":", "\n", "        ", "cfg", ".", "valid_sub_dataset", ".", "test_mode", "=", "True", "\n", "dataset", "=", "get_dataset", "(", "cfg", ".", "valid_sub_dataset", ")", "\n", "", "else", ":", "\n", "        ", "cfg", ".", "valid_dataset", ".", "test_mode", "=", "True", "\n", "dataset", "=", "get_dataset", "(", "cfg", ".", "valid_dataset", ")", "\n", "\n", "", "frame_times", "=", "MovingAverage", "(", ")", "\n", "dataset_size", "=", "math", ".", "ceil", "(", "len", "(", "dataset", ")", "/", "args", ".", "batch_size", ")", "if", "args", ".", "max_images", "<", "0", "else", "min", "(", "args", ".", "max_images", ",", "\n", "len", "(", "dataset", ")", ")", "\n", "progress_bar", "=", "ProgressBar", "(", "30", ",", "dataset_size", ")", "\n", "\n", "print", "(", ")", "\n", "data_loader", "=", "data", ".", "DataLoader", "(", "dataset", ",", "args", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "collate_fn", "=", "detection_collate", ",", "\n", "pin_memory", "=", "True", ")", "\n", "results", "=", "[", "]", "\n", "\n", "try", ":", "\n", "# Main eval loop", "\n", "        ", "for", "it", ",", "data_batch", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "            ", "timer", ".", "reset", "(", ")", "\n", "\n", "with", "timer", ".", "env", "(", "'Load Data'", ")", ":", "\n", "                ", "images", ",", "images_meta", ",", "ref_images", ",", "ref_images_meta", "=", "prepare_data", "(", "data_batch", ",", "is_cuda", "=", "True", ",", "\n", "train_mode", "=", "False", ")", "\n", "\n", "", "with", "timer", ".", "env", "(", "'Network Extra'", ")", ":", "\n", "                ", "preds", "=", "net", "(", "images", ",", "img_meta", "=", "images_meta", ",", "ref_x", "=", "ref_images", ",", "ref_imgs_meta", "=", "ref_images_meta", ")", "\n", "\n", "if", "it", "==", "dataset_size", "-", "1", ":", "\n", "                    ", "batch_size", "=", "len", "(", "dataset", ")", "%", "args", ".", "batch_size", "\n", "", "else", ":", "\n", "                    ", "batch_size", "=", "images", ".", "size", "(", "0", ")", "\n", "\n", "", "for", "batch_id", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "cfg", ".", "preserve_aspect_ratio", "=", "True", "\n", "preds_cur", "=", "postprocess_ytbvis", "(", "preds", "[", "batch_id", "]", ",", "images_meta", "[", "batch_id", "]", ",", "\n", "score_threshold", "=", "cfg", ".", "eval_conf_thresh", ")", "\n", "segm_results", "=", "bbox2result_with_id", "(", "preds_cur", ",", "images_meta", "[", "batch_id", "]", ",", "cfg", ".", "classes", ")", "\n", "results", ".", "append", "(", "segm_results", ")", "\n", "\n", "# First couple of images take longer because we're constructing the graph.", "\n", "# Since that's technically initialization, don't include those in the FPS calculations.", "\n", "", "", "if", "it", ">", "1", ":", "\n", "                ", "if", "batch_size", "==", "0", ":", "\n", "                    ", "batch_size", "=", "1", "\n", "", "frame_times", ".", "add", "(", "timer", ".", "total_time", "(", ")", "/", "batch_size", ")", "\n", "\n", "", "if", "it", ">", "1", "and", "frame_times", ".", "get_avg", "(", ")", ">", "0", ":", "\n", "                ", "fps", "=", "1", "/", "frame_times", ".", "get_avg", "(", ")", "\n", "", "else", ":", "\n", "                ", "fps", "=", "0", "\n", "", "progress", "=", "(", "it", "+", "1", ")", "/", "dataset_size", "*", "100", "\n", "progress_bar", ".", "set_val", "(", "it", "+", "1", ")", "\n", "print", "(", "'\\rProcessing Images  %s %6d / %6d (%5.2f%%)    %5.2f fps        '", "\n", "%", "(", "repr", "(", "progress_bar", ")", ",", "it", "+", "1", ",", "dataset_size", ",", "progress", ",", "fps", ")", ",", "end", "=", "''", ")", "\n", "\n", "", "print", "(", ")", "\n", "print", "(", "'Dumping detections...'", ")", "\n", "\n", "if", "not", "valid_data", ":", "\n", "            ", "results2json_videoseg", "(", "results", ",", "args", ".", "mask_det_file", ")", "\n", "print", "(", "'calculate evaluation metrics ...'", ")", "\n", "ann_file", "=", "cfg", ".", "valid_sub_dataset", ".", "ann_file", "\n", "dt_file", "=", "args", ".", "mask_det_file", "\n", "calc_metrics", "(", "ann_file", ",", "dt_file", ",", "output_file", "=", "output_metrics_file", ")", "\n", "", "else", ":", "\n", "            ", "results2json_videoseg", "(", "results", ",", "output_metrics_file", ".", "replace", "(", "'.txt'", ",", "'.json'", ")", ")", "\n", "\n", "", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "print", "(", "'Stopping...'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.evaluate": [[579, 701], ["utils.functions.MovingAverage", "utils.functions.ProgressBar", "print", "torch.DataLoader", "math.ceil", "min", "enumerate", "len", "utils.timer.reset", "range", "print", "print", "len", "utils.timer.env", "datasets.prepare_data", "utils.timer.env", "net", "images.size", "print", "layers.eval_utils.results2json_videoseg", "print", "print", "print", "utils.timer.print_stats", "utils.functions.MovingAverage.get_avg", "print", "len", "layers.output_utils.postprocess_ytbvis", "layers.eval_utils.bbox2result_with_id", "results.append", "utils.functions.MovingAverage.add", "matplotlib.imshow", "matplotlib.axis", "matplotlib.title", "matplotlib.savefig", "matplotlib.clf", "layers.eval_utils.calc_metrics", "eval.prep_display", "range", "print", "str", "os.path.exists", "os.makedirs", "utils.functions.ProgressBar.set_val", "print", "print", "print", "[].size", "torch.tensor", "torch.tensor", "torch.tensor", "eval.prep_display", "matplotlib.imshow", "matplotlib.axis", "matplotlib.savefig", "matplotlib.clf", "utils.timer.total_time", "str", "str", "utils.functions.MovingAverage.get_avg", "utils.functions.MovingAverage.get_avg", "utils.functions.MovingAverage.get_avg", "repr", "str", "str"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.reset", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.prepare_data", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.results2json_videoseg", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.print_stats", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.postprocess_ytbvis", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.bbox2result_with_id", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.calc_metrics", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.prep_display", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.prep_display", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.total_time", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg"], ["", "", "def", "evaluate", "(", "net", ":", "STMask", ",", "dataset", ")", ":", "\n", "    ", "net", ".", "detect", ".", "use_fast_nms", "=", "args", ".", "fast_nms", "\n", "cfg", ".", "mask_proto_debug", "=", "args", ".", "mask_proto_debug", "\n", "\n", "frame_times", "=", "MovingAverage", "(", ")", "\n", "dataset_size", "=", "math", ".", "ceil", "(", "len", "(", "dataset", ")", "/", "args", ".", "batch_size", ")", "if", "args", ".", "max_images", "<", "0", "else", "min", "(", "args", ".", "max_images", ",", "\n", "len", "(", "dataset", ")", ")", "\n", "progress_bar", "=", "ProgressBar", "(", "30", ",", "dataset_size", ")", "\n", "\n", "print", "(", ")", "\n", "\n", "data_loader", "=", "data", ".", "DataLoader", "(", "dataset", ",", "args", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "collate_fn", "=", "detection_collate", ",", "\n", "pin_memory", "=", "True", ")", "\n", "results", "=", "[", "]", "\n", "\n", "try", ":", "\n", "# Main eval loop", "\n", "        ", "for", "it", ",", "data_batch", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "            ", "timer", ".", "reset", "(", ")", "\n", "\n", "with", "timer", ".", "env", "(", "'Load Data'", ")", ":", "\n", "                ", "images", ",", "images_meta", ",", "ref_images", ",", "ref_images_meta", "=", "prepare_data", "(", "data_batch", ",", "is_cuda", "=", "True", ",", "\n", "train_mode", "=", "False", ")", "\n", "\n", "", "with", "timer", ".", "env", "(", "'Network Extra'", ")", ":", "\n", "                ", "preds", "=", "net", "(", "images", ",", "img_meta", "=", "images_meta", ",", "ref_x", "=", "ref_images", ",", "ref_imgs_meta", "=", "ref_images_meta", ")", "\n", "\n", "# Perform the meat of the operation here depending on our mode.", "\n", "", "if", "it", "==", "dataset_size", "-", "1", ":", "\n", "                ", "batch_size", "=", "len", "(", "dataset", ")", "%", "args", ".", "batch_size", "\n", "", "else", ":", "\n", "                ", "batch_size", "=", "images", ".", "size", "(", "0", ")", "\n", "\n", "", "for", "batch_id", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "if", "args", ".", "display", ":", "\n", "                    ", "img_id", "=", "(", "images_meta", "[", "batch_id", "]", "[", "'video_id'", "]", ",", "images_meta", "[", "batch_id", "]", "[", "'frame_id'", "]", ")", "\n", "if", "not", "cfg", ".", "display_mask_single", ":", "\n", "                        ", "img_numpy", "=", "prep_display", "(", "preds", "[", "batch_id", "]", ",", "images", "[", "batch_id", "]", ",", "\n", "img_meta", "=", "images_meta", "[", "batch_id", "]", ",", "img_ids", "=", "img_id", ")", "\n", "", "else", ":", "\n", "                        ", "for", "p", "in", "range", "(", "preds", "[", "batch_id", "]", "[", "'detection'", "]", "[", "'box'", "]", ".", "size", "(", "0", ")", ")", ":", "\n", "                            ", "preds_single", "=", "{", "'detection'", ":", "{", "}", "}", "\n", "for", "k", "in", "preds", "[", "batch_id", "]", "[", "'detection'", "]", ":", "\n", "                                ", "if", "preds", "[", "batch_id", "]", "[", "'detection'", "]", "[", "k", "]", "is", "not", "None", "and", "k", "not", "in", "{", "'proto'", "}", ":", "\n", "                                    ", "preds_single", "[", "'detection'", "]", "[", "k", "]", "=", "preds", "[", "batch_id", "]", "[", "'detection'", "]", "[", "k", "]", "[", "p", "]", "\n", "", "else", ":", "\n", "                                    ", "preds_single", "[", "'detection'", "]", "[", "k", "]", "=", "None", "\n", "", "", "preds_single", "[", "'net'", "]", "=", "preds", "[", "batch_id", "]", "[", "'net'", "]", "\n", "preds_single", "[", "'detection'", "]", "[", "'box_ids'", "]", "=", "torch", ".", "tensor", "(", "-", "1", ")", "\n", "\n", "img_numpy", "=", "prep_display", "(", "preds_single", ",", "images", "[", "batch_id", "]", ",", "\n", "img_meta", "=", "images_meta", "[", "batch_id", "]", ",", "img_ids", "=", "img_id", ")", "\n", "plt", ".", "imshow", "(", "img_numpy", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "args", ".", "mask_det_file", "[", ":", "-", "12", "]", ",", "'out_single/'", ",", "str", "(", "img_id", ")", ",", "'_'", ",", "str", "(", "p", ")", ",", "\n", "'.png'", "]", ")", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n", "", "", "", "else", ":", "\n", "                    ", "cfg", ".", "preserve_aspect_ratio", "=", "True", "\n", "preds_cur", "=", "postprocess_ytbvis", "(", "preds", "[", "batch_id", "]", ",", "images_meta", "[", "batch_id", "]", ",", "\n", "score_threshold", "=", "cfg", ".", "eval_conf_thresh", ")", "\n", "segm_results", "=", "bbox2result_with_id", "(", "preds_cur", ",", "images_meta", "[", "batch_id", "]", ",", "cfg", ".", "classes", ")", "\n", "results", ".", "append", "(", "segm_results", ")", "\n", "\n", "# First couple of images take longer because we're constructing the graph.", "\n", "# Since that's technically initialization, don't include those in the FPS calculations.", "\n", "", "if", "it", ">", "1", ":", "\n", "                    ", "frame_times", ".", "add", "(", "timer", ".", "total_time", "(", ")", "/", "batch_size", ")", "\n", "\n", "", "if", "args", ".", "display", "and", "not", "cfg", ".", "display_mask_single", ":", "\n", "                    ", "if", "it", ">", "1", ":", "\n", "                        ", "print", "(", "'Avg FPS: %.4f'", "%", "(", "1", "/", "frame_times", ".", "get_avg", "(", ")", ")", ")", "\n", "", "plt", ".", "imshow", "(", "img_numpy", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "title", "(", "str", "(", "img_id", ")", ")", "\n", "\n", "root_dir", "=", "''", ".", "join", "(", "[", "args", ".", "mask_det_file", "[", ":", "-", "12", "]", ",", "'out/'", ",", "str", "(", "images_meta", "[", "batch_id", "]", "[", "'video_id'", "]", ")", ",", "'/'", "]", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "root_dir", ")", ":", "\n", "                        ", "os", ".", "makedirs", "(", "root_dir", ")", "\n", "", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "root_dir", ",", "str", "(", "images_meta", "[", "batch_id", "]", "[", "'frame_id'", "]", ")", ",", "'.png'", "]", ")", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "# plt.show()", "\n", "", "elif", "not", "args", ".", "no_bar", ":", "\n", "                    ", "if", "it", ">", "1", ":", "\n", "                        ", "fps", "=", "1", "/", "frame_times", ".", "get_avg", "(", ")", "\n", "", "else", ":", "\n", "                        ", "fps", "=", "0", "\n", "", "progress", "=", "(", "it", "+", "1", ")", "/", "dataset_size", "*", "100", "\n", "progress_bar", ".", "set_val", "(", "it", "+", "1", ")", "\n", "print", "(", "'\\rProcessing Images  %s %6d / %6d (%5.2f%%)    %5.2f fps        '", "\n", "%", "(", "repr", "(", "progress_bar", ")", ",", "it", "+", "1", ",", "dataset_size", ",", "progress", ",", "fps", ")", ",", "end", "=", "''", ")", "\n", "\n", "", "", "", "if", "not", "args", ".", "display", "and", "not", "args", ".", "benchmark", ":", "\n", "            ", "print", "(", ")", "\n", "if", "args", ".", "output_json", ":", "\n", "                ", "print", "(", "'Dumping detections...'", ")", "\n", "results2json_videoseg", "(", "results", ",", "args", ".", "mask_det_file", ")", "\n", "\n", "if", "cfg", ".", "use_valid_sub", "or", "cfg", ".", "use_train_sub", ":", "\n", "                    ", "if", "cfg", ".", "use_valid_sub", ":", "\n", "                        ", "print", "(", "'calculate evaluation metrics ...'", ")", "\n", "ann_file", "=", "cfg", ".", "valid_sub_dataset", ".", "ann_file", "\n", "", "else", ":", "\n", "                        ", "print", "(", "'calculate train_sub metrics ...'", ")", "\n", "ann_file", "=", "cfg", ".", "train_dataset", ".", "ann_file", "\n", "", "dt_file", "=", "args", ".", "mask_det_file", "\n", "metrics", "=", "calc_metrics", "(", "ann_file", ",", "dt_file", ")", "\n", "\n", "return", "metrics", "\n", "\n", "", "", "", "elif", "args", ".", "benchmark", ":", "\n", "            ", "print", "(", ")", "\n", "print", "(", ")", "\n", "print", "(", "'Stats for the last frame:'", ")", "\n", "timer", ".", "print_stats", "(", ")", "\n", "avg_seconds", "=", "frame_times", ".", "get_avg", "(", ")", "\n", "print", "(", "'Average: %5.2f fps, %5.2f ms'", "%", "(", "1", "/", "frame_times", ".", "get_avg", "(", ")", ",", "1000", "*", "avg_seconds", ")", ")", "\n", "\n", "", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "print", "(", "'Stopping...'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.evaluate_single": [[703, 737], ["mmcv.imread", "mmcv.imresize", "mmcv.impad_to_multiple", "torch.tensor().permute().contiguous().unsqueeze().float().cuda", "torch.tensor().permute().contiguous().unsqueeze().float().cuda", "torch.tensor().permute().contiguous().unsqueeze().float().cuda", "net", "torch.arange", "torch.arange", "torch.arange", "eval.prep_display", "torch.tensor().permute().contiguous().unsqueeze().float().cuda.size", "[].size", "matplotlib.imshow", "matplotlib.axis", "matplotlib.show", "cv2.imwrite", "torch.tensor().permute().contiguous().unsqueeze().float", "torch.tensor().permute().contiguous().unsqueeze().float", "torch.tensor().permute().contiguous().unsqueeze().float", "torch.tensor().permute().contiguous().unsqueeze", "torch.tensor().permute().contiguous().unsqueeze", "torch.tensor().permute().contiguous().unsqueeze", "torch.tensor().permute().contiguous", "torch.tensor().permute().contiguous", "torch.tensor().permute().contiguous", "torch.tensor().permute", "torch.tensor().permute", "torch.tensor().permute", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.prep_display"], ["", "", "def", "evaluate_single", "(", "net", ":", "STMask", ",", "im_path", "=", "None", ",", "save_path", "=", "None", ",", "idx", "=", "None", ")", ":", "\n", "    ", "im", "=", "mmcv", ".", "imread", "(", "im_path", ")", "\n", "ori_shape", "=", "im", ".", "shape", "\n", "im", ",", "w_scale", ",", "h_scale", "=", "mmcv", ".", "imresize", "(", "im", ",", "(", "640", ",", "360", ")", ",", "return_scale", "=", "True", ")", "\n", "img_shape", "=", "im", ".", "shape", "\n", "\n", "if", "cfg", ".", "backbone", ".", "transform", ".", "normalize", ":", "\n", "        ", "im", "=", "(", "im", "-", "MEANS", ")", "/", "STD", "\n", "", "elif", "cfg", ".", "backbone", ".", "transform", ".", "subtract_means", ":", "\n", "        ", "im", "=", "(", "im", "-", "MEANS", ")", "\n", "", "elif", "cfg", ".", "backbone", ".", "transform", ".", "to_float", ":", "\n", "        ", "im", "=", "im", "/", "255.", "\n", "", "im", "=", "mmcv", ".", "impad_to_multiple", "(", "im", ",", "32", ")", "\n", "pad_shape", "=", "im", ".", "shape", "\n", "im", "=", "torch", ".", "tensor", "(", "im", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "contiguous", "(", ")", ".", "unsqueeze", "(", "0", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "\n", "pad_h", ",", "pad_w", "=", "im", ".", "size", "(", ")", "[", "2", ":", "4", "]", "\n", "img_meta", "=", "{", "'ori_shape'", ":", "ori_shape", ",", "'img_shape'", ":", "img_shape", ",", "'pad_shape'", ":", "pad_shape", "}", "\n", "if", "idx", "is", "not", "None", ":", "\n", "        ", "img_meta", "[", "'frame_id'", "]", "=", "idx", "\n", "", "if", "idx", "is", "None", "or", "idx", "==", "0", ":", "\n", "        ", "img_meta", "[", "'is_first'", "]", "=", "True", "\n", "", "else", ":", "\n", "        ", "img_meta", "[", "'is_first'", "]", "=", "False", "\n", "\n", "", "preds", "=", "net", "(", "im", ",", "img_meta", "=", "[", "img_meta", "]", ")", "\n", "preds", "[", "0", "]", "[", "'detection'", "]", "[", "'box_ids'", "]", "=", "torch", ".", "arange", "(", "preds", "[", "0", "]", "[", "'detection'", "]", "[", "'box'", "]", ".", "size", "(", "0", ")", ")", "\n", "cfg", ".", "preserve_aspect_ratio", "=", "True", "\n", "img_numpy", "=", "prep_display", "(", "preds", "[", "0", "]", ",", "im", "[", "0", "]", ",", "pad_h", ",", "pad_w", ",", "img_meta", "=", "img_meta", ",", "img_ids", "=", "(", "0", ",", "idx", ")", ")", "\n", "if", "save_path", "is", "None", ":", "\n", "        ", "plt", ".", "imshow", "(", "img_numpy", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "", "else", ":", "\n", "        ", "cv2", ".", "imwrite", "(", "save_path", ",", "img_numpy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.evalimages": [[739, 756], ["print", "os.listdir", "os.listdir.sort", "enumerate", "print", "os.path.exists", "os.mkdir", "str", "os.path.basename", "os.path.join", "os.path.join", "eval.evaluate_single", "print", "int", "os.path.basename.split"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.evaluate_single", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["", "", "def", "evalimages", "(", "net", ":", "STMask", ",", "input_folder", ":", "str", ",", "output_folder", ":", "str", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "output_folder", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "output_folder", ")", "\n", "\n", "", "print", "(", ")", "\n", "path_list", "=", "os", ".", "listdir", "(", "input_folder", ")", "\n", "path_list", ".", "sort", "(", "key", "=", "lambda", "x", ":", "int", "(", "x", "[", ":", "-", "4", "]", ")", ")", "\n", "for", "idx", ",", "p", "in", "enumerate", "(", "path_list", ")", ":", "\n", "        ", "path", "=", "str", "(", "p", ")", "\n", "name", "=", "os", ".", "path", ".", "basename", "(", "path", ")", "\n", "name", "=", "'.'", ".", "join", "(", "name", ".", "split", "(", "'.'", ")", "[", ":", "-", "1", "]", ")", "+", "'.png'", "\n", "out_path", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "name", ")", "\n", "in_path", "=", "os", ".", "path", ".", "join", "(", "input_folder", ",", "path", ")", "\n", "\n", "evaluate_single", "(", "net", ",", "in_path", ",", "out_path", ",", "idx", ")", "\n", "print", "(", "path", "+", "' -> '", "+", "out_path", ")", "\n", "", "print", "(", "'Done.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.evalvideo": [[758, 760], ["None"], "function", ["None"], ["", "def", "evalvideo", "(", "net", ":", "STMask", ",", "input_folder", ":", "str", ",", "output_folder", ":", "str", ")", ":", "\n", "    ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.NetLoss.__init__": [[140, 145], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__"], ["def", "__init__", "(", "self", ",", "net", ":", "STMask", ",", "criterion", ":", "MultiBoxLoss", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "net", "=", "net", "\n", "self", ".", "criterion", "=", "criterion", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.NetLoss.forward": [[146, 151], ["train.NetLoss.net", "train.NetLoss.criterion"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "images", ",", "gt_bboxes", ",", "gt_labels", ",", "gt_masks", ",", "gt_ids", ",", "img_meta", ")", ":", "\n", "        ", "preds", "=", "self", ".", "net", "(", "images", ",", "img_meta", ")", "\n", "losses", "=", "self", ".", "criterion", "(", "self", ".", "net", ",", "preds", ",", "gt_bboxes", ",", "gt_labels", ",", "gt_masks", ",", "gt_ids", ")", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.scatter": [[159, 168], ["datasets.prepare_data", "len", "str", "range", "len"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.prepare_data"], ["def", "scatter", "(", "self", ",", "inputs", ",", "kwargs", ",", "device_ids", ")", ":", "\n", "# More like scatter and data prep at the same time. The point is we prep the data in such a way", "\n", "# that no scatter is necessary, and there's no need to shuffle stuff around different GPUs.", "\n", "        ", "devices", "=", "[", "'cuda:'", "+", "str", "(", "x", ")", "for", "x", "in", "device_ids", "]", "if", "args", ".", "cuda", "else", "None", "\n", "splits", "=", "prepare_data", "(", "inputs", "[", "0", "]", ",", "devices", ",", "allocation", "=", "args", ".", "batch_alloc", ",", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "is_cuda", "=", "args", ".", "cuda", ",", "train_mode", "=", "True", ")", "\n", "\n", "return", "[", "[", "split", "[", "device_idx", "]", "for", "split", "in", "splits", "]", "for", "device_idx", "in", "range", "(", "len", "(", "devices", ")", ")", "]", ",", "[", "kwargs", "]", "*", "len", "(", "devices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather": [[169, 176], ["torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "output[].to"], "methods", ["None"], ["", "def", "gather", "(", "self", ",", "outputs", ",", "output_device", ")", ":", "\n", "        ", "out", "=", "{", "}", "\n", "\n", "for", "k", "in", "outputs", "[", "0", "]", ":", "\n", "            ", "out", "[", "k", "]", "=", "torch", ".", "stack", "(", "[", "output", "[", "k", "]", ".", "to", "(", "output_device", ")", "for", "output", "in", "outputs", "]", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.str2bool": [[22, 24], ["v.lower"], "function", ["None"], ["def", "str2bool", "(", "v", ")", ":", "\n", "    ", "return", "v", ".", "lower", "(", ")", "in", "(", "\"yes\"", ",", "\"true\"", ",", "\"t\"", ",", "\"1\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.replace": [[100, 102], ["getattr", "setattr", "getattr"], "function", ["None"], ["", "def", "replace", "(", "name", ")", ":", "\n", "    ", "if", "getattr", "(", "args", ",", "name", ")", "==", "None", ":", "setattr", "(", "args", ",", "name", ",", "getattr", "(", "cfg", ",", "name", ")", ")", "\n", "", "replace", "(", "'lr'", ")", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.train": [[178, 392], ["datasets.get_dataset", "STMask.STMask", "net.cuda.train", "utils.timer.disable_all", "torch.SGD", "layers.modules.MultiBoxLoss", "train.CustomDataParallel", "torch.DataLoader", "max", "time.time", "math.ceil", "utils.functions.MovingAverage", "print", "print", "STMask.STMask.save_weights", "os.path.exists", "os.mkdir", "utils.logger.Log", "utils.functions.SavePath.get_interrupt", "print", "STMask.STMask.load_weights", "print", "STMask.STMask.init_weights", "net.cuda.parameters", "train.NetLoss", "net.cuda.cuda", "STMask.STMask.freeze_bn", "STMask.STMask.", "STMask.STMask.", "len", "utils.functions.SavePath().get_path", "utils.functions.MovingAverage", "range", "save_path", "dict", "utils.functions.SavePath.get_latest", "int", "sum", "print", "exit", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "enumerate", "print", "utils.functions.SavePath.remove_interrupt", "STMask.STMask.save_weights", "exit", "args._get_kwargs", "utils.functions.SavePath.from_str", "args.batch_alloc.split", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "utils.functions.SavePath", "optim.SGD.zero_grad", "net.cuda.", "sum", "sum.backward", "torch.isfinite().item", "torch.isfinite().item", "torch.isfinite().item", "torch.isfinite().item", "time.time", "save_path", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "train.set_lr", "train.set_lr", "v.mean", "optim.SGD.step", "loss_avgs[].add", "utils.functions.MovingAverage.add", "sum", "sum", "print", "round", "utils.logger.Log.log", "print", "STMask.STMask.save_weights", "train.setup_eval", "save_path().replace", "train.compute_validation_map", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "cfg.replace", "len", "net.items", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "losses[].item", "str().split", "round", "sum.item", "utils.functions.SavePath.get_latest", "save_path", "repr", "avg.reset", "loss_avgs[].get_avg", "tuple", "losses[].item", "round", "print", "os.remove", "save_path", "str", "loss_avgs[].get_avg", "datetime.timedelta", "len", "utils.functions.MovingAverage.get_avg"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.get_dataset", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.train", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.disable_all", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.save_weights", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.get_interrupt", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.load_weights", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.Featurealign.FeatureAlign.init_weights", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.freeze_bn", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.get_path", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.get_latest", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.remove_interrupt", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.save_weights", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.from_str", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.set_lr", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.set_lr", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.step", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.save_weights", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.train_output_utils.setup_eval", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.replace", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.compute_validation_map", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.replace", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.get_latest", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.reset", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg"], ["", "", "def", "train", "(", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "save_folder", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "args", ".", "save_folder", ")", "\n", "\n", "", "train_dataset", "=", "get_dataset", "(", "cfg", ".", "train_dataset", ")", "\n", "\n", "# Parallel wraps the underlying module, but when saving and loading we don't want that", "\n", "STMask_net", "=", "STMask", "(", ")", "\n", "net", "=", "STMask_net", "\n", "net", ".", "train", "(", ")", "\n", "\n", "if", "args", ".", "log", ":", "\n", "        ", "log", "=", "Log", "(", "cfg", ".", "name", ",", "args", ".", "save_folder", ",", "dict", "(", "args", ".", "_get_kwargs", "(", ")", ")", ",", "\n", "overwrite", "=", "(", "args", ".", "resume", "is", "None", ")", ",", "log_gpu_stats", "=", "args", ".", "log_gpu", ")", "\n", "\n", "# I don't use the timer during training (I use a different timing method).", "\n", "# Apparently there's a race condition with multiple GPUs.", "\n", "", "timer", ".", "disable_all", "(", ")", "\n", "\n", "# Both of these can set args.resume to None, so do them before the check", "\n", "if", "args", ".", "resume", "==", "'interrupt'", ":", "\n", "        ", "args", ".", "resume", "=", "SavePath", ".", "get_interrupt", "(", "args", ".", "save_folder", ")", "\n", "", "elif", "args", ".", "resume", "==", "'latest'", ":", "\n", "        ", "args", ".", "resume", "=", "SavePath", ".", "get_latest", "(", "args", ".", "save_folder", ",", "cfg", ".", "name", ")", "\n", "\n", "", "if", "args", ".", "resume", "is", "not", "None", ":", "\n", "        ", "print", "(", "'Resuming training, loading {}...'", ".", "format", "(", "args", ".", "resume", ")", ")", "\n", "STMask_net", ".", "load_weights", "(", "path", "=", "args", ".", "resume", ")", "\n", "\n", "if", "args", ".", "start_iter", "==", "-", "1", ":", "\n", "            ", "args", ".", "start_iter", "=", "SavePath", ".", "from_str", "(", "args", ".", "resume", ")", ".", "iteration", "\n", "", "", "else", ":", "\n", "        ", "print", "(", "'Initializing weights based COCO ...'", ")", "\n", "STMask_net", ".", "init_weights", "(", "backbone_path", "=", "'weights/pretrained_models_coco/'", "+", "cfg", ".", "backbone", ".", "path", ")", "\n", "\n", "", "optimizer", "=", "optim", ".", "SGD", "(", "net", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ",", "momentum", "=", "args", ".", "momentum", ",", "weight_decay", "=", "args", ".", "decay", ")", "\n", "\n", "criterion", "=", "MultiBoxLoss", "(", "num_classes", "=", "cfg", ".", "num_classes", ",", "\n", "pos_threshold", "=", "cfg", ".", "positive_iou_threshold", ",", "\n", "neg_threshold", "=", "cfg", ".", "negative_iou_threshold", ",", "\n", "negpos_ratio", "=", "cfg", ".", "ohem_negpos_ratio", ")", "\n", "\n", "if", "args", ".", "batch_alloc", "is", "not", "None", ":", "\n", "        ", "args", ".", "batch_alloc", "=", "[", "int", "(", "x", ")", "for", "x", "in", "args", ".", "batch_alloc", ".", "split", "(", "','", ")", "]", "\n", "if", "sum", "(", "args", ".", "batch_alloc", ")", "!=", "args", ".", "batch_size", ":", "\n", "            ", "print", "(", "'Error: Batch allocation (%s) does not sum to batch size (%s).'", "%", "(", "args", ".", "batch_alloc", ",", "args", ".", "batch_size", ")", ")", "\n", "exit", "(", "-", "1", ")", "\n", "\n", "", "", "net", "=", "CustomDataParallel", "(", "NetLoss", "(", "net", ",", "criterion", ")", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "        ", "net", "=", "net", ".", "cuda", "(", ")", "\n", "\n", "# Initialize everything", "\n", "", "if", "not", "cfg", ".", "freeze_bn", ":", "STMask_net", ".", "freeze_bn", "(", ")", "# Freeze bn so we don't kill our means", "\n", "if", "args", ".", "cuda", ":", "\n", "        ", "STMask_net", "(", "torch", ".", "ones", "(", "2", ",", "2", ",", "3", ",", "384", ",", "640", ")", ".", "cuda", "(", ")", ",", "[", "torch", ".", "zeros", "(", "1", ",", "4", ")", ".", "cuda", "(", ")", "]", ")", "\n", "", "else", ":", "\n", "        ", "STMask_net", "(", "torch", ".", "ones", "(", "2", ",", "2", ",", "3", ",", "384", ",", "640", ")", ",", "[", "torch", ".", "zeros", "(", "1", ",", "4", ")", "]", ")", "\n", "\n", "", "data_loader", "=", "data", ".", "DataLoader", "(", "train_dataset", ",", "args", ".", "batch_size", ",", "\n", "num_workers", "=", "args", ".", "num_workers", ",", "\n", "shuffle", "=", "True", ",", "\n", "collate_fn", "=", "detection_collate", ",", "\n", "pin_memory", "=", "True", ")", "\n", "\n", "# loss counters", "\n", "iteration", "=", "max", "(", "args", ".", "start_iter", ",", "0", ")", "\n", "last_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "epoch_size", "=", "len", "(", "train_dataset", ")", "//", "args", ".", "batch_size", "\n", "num_epochs", "=", "math", ".", "ceil", "(", "cfg", ".", "max_iter", "/", "epoch_size", ")", "\n", "\n", "# Which learning rate adjustment step are we on? lr' = lr * gamma ^ step_index", "\n", "step_index", "=", "0", "\n", "\n", "save_path", "=", "lambda", "epoch", ",", "iteration", ":", "SavePath", "(", "cfg", ".", "name", ",", "epoch", ",", "iteration", ")", ".", "get_path", "(", "root", "=", "args", ".", "save_folder", ")", "\n", "time_avg", "=", "MovingAverage", "(", ")", "\n", "\n", "global", "loss_types", "# Forms the print order", "\n", "loss_avgs", "=", "{", "k", ":", "MovingAverage", "(", "100", ")", "for", "k", "in", "loss_types", "}", "\n", "\n", "print", "(", "'Begin training!'", ")", "\n", "print", "(", ")", "\n", "# try-except so you can use ctrl+c to save early and stop training", "\n", "try", ":", "\n", "        ", "for", "epoch", "in", "range", "(", "num_epochs", ")", ":", "\n", "# Resume from start_iter", "\n", "            ", "if", "(", "epoch", "+", "1", ")", "*", "epoch_size", "<", "iteration", ":", "\n", "                ", "continue", "\n", "\n", "# for datum in data_loader:", "\n", "", "for", "i", ",", "data_batch", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "# Stop if we've reached an epoch if we're resuming from start_iter", "\n", "                ", "if", "iteration", "==", "(", "epoch", "+", "1", ")", "*", "epoch_size", ":", "\n", "                    ", "break", "\n", "\n", "# Stop at the configured number of iterations even if mid-epoch", "\n", "", "if", "iteration", "==", "cfg", ".", "max_iter", ":", "\n", "                    ", "break", "\n", "\n", "# Change a config setting if we've reached the specified iteration", "\n", "", "changed", "=", "False", "\n", "for", "change", "in", "cfg", ".", "delayed_settings", ":", "\n", "                    ", "if", "iteration", ">=", "change", "[", "0", "]", ":", "\n", "                        ", "changed", "=", "True", "\n", "cfg", ".", "replace", "(", "change", "[", "1", "]", ")", "\n", "\n", "# Reset the loss averages because things might have changed", "\n", "for", "avg", "in", "loss_avgs", ":", "\n", "                            ", "avg", ".", "reset", "(", ")", "\n", "\n", "# If a config setting was changed, remove it from the list so we don't keep checking", "\n", "", "", "", "if", "changed", ":", "\n", "                    ", "cfg", ".", "delayed_settings", "=", "[", "x", "for", "x", "in", "cfg", ".", "delayed_settings", "if", "x", "[", "0", "]", ">", "iteration", "]", "\n", "\n", "# Warm up by linearly interpolating the learning rate from some smaller value", "\n", "", "if", "cfg", ".", "lr_warmup_until", ">", "0", "and", "iteration", "<=", "cfg", ".", "lr_warmup_until", ":", "\n", "                    ", "cur_lr", "=", "(", "args", ".", "lr", "-", "cfg", ".", "lr_warmup_init", ")", "*", "(", "iteration", "/", "cfg", ".", "lr_warmup_until", ")", "+", "cfg", ".", "lr_warmup_init", "\n", "set_lr", "(", "optimizer", ",", "cur_lr", ")", "\n", "\n", "# Adjust the learning rate at the given iterations, but also if we resume from past that iteration", "\n", "", "while", "step_index", "<", "len", "(", "cfg", ".", "lr_steps", ")", "and", "iteration", ">=", "cfg", ".", "lr_steps", "[", "step_index", "]", ":", "\n", "                    ", "step_index", "+=", "1", "\n", "cur_lr", "=", "args", ".", "lr", "*", "(", "args", ".", "gamma", "**", "step_index", ")", "\n", "set_lr", "(", "optimizer", ",", "cur_lr", ")", "\n", "\n", "# Zero the grad to get ready to compute gradients", "\n", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# Forward Pass + Compute loss at the same time (see CustomDataParallel and NetLoss)", "\n", "losses", "=", "net", "(", "data_batch", ")", "\n", "\n", "losses", "=", "{", "k", ":", "v", ".", "mean", "(", ")", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", "}", "# Mean here because Dataparallel", "\n", "loss", "=", "sum", "(", "[", "losses", "[", "k", "]", "for", "k", "in", "losses", "]", ")", "# same weights in three sub-losses", "\n", "\n", "# Backprop", "\n", "loss", ".", "backward", "(", ")", "# Do this to free up vram even if loss is not finite", "\n", "if", "torch", ".", "isfinite", "(", "loss", ")", ".", "item", "(", ")", ":", "\n", "                    ", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Add the loss to the moving average for bookkeeping", "\n", "", "for", "k", "in", "losses", ":", "\n", "                    ", "loss_avgs", "[", "k", "]", ".", "add", "(", "losses", "[", "k", "]", ".", "item", "(", ")", ")", "\n", "\n", "", "cur_time", "=", "time", ".", "time", "(", ")", "\n", "elapsed", "=", "cur_time", "-", "last_time", "\n", "last_time", "=", "cur_time", "\n", "\n", "# Exclude graph setup from the timing information", "\n", "if", "iteration", "!=", "args", ".", "start_iter", ":", "\n", "                    ", "time_avg", ".", "add", "(", "elapsed", ")", "\n", "\n", "", "if", "iteration", "%", "10", "==", "0", ":", "\n", "                    ", "eta_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "(", "cfg", ".", "max_iter", "-", "iteration", ")", "*", "time_avg", ".", "get_avg", "(", ")", ")", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "total", "=", "sum", "(", "[", "loss_avgs", "[", "k", "]", ".", "get_avg", "(", ")", "for", "k", "in", "losses", "]", ")", "\n", "loss_labels", "=", "sum", "(", "[", "[", "k", ",", "loss_avgs", "[", "k", "]", ".", "get_avg", "(", ")", "]", "for", "k", "in", "loss_types", "if", "k", "in", "losses", "]", ",", "[", "]", ")", "\n", "\n", "print", "(", "(", "'[%3d] %7d ||'", "+", "(", "' %s: %.3f |'", "*", "len", "(", "losses", ")", ")", "+", "' Total: %.3f || ETA: %s || timer: %.3f'", ")", "\n", "%", "tuple", "(", "[", "epoch", ",", "iteration", "]", "+", "loss_labels", "+", "[", "total", ",", "eta_str", ",", "elapsed", "]", ")", ",", "flush", "=", "True", ")", "\n", "\n", "", "if", "args", ".", "log", ":", "\n", "                    ", "precision", "=", "5", "\n", "loss_info", "=", "{", "k", ":", "round", "(", "losses", "[", "k", "]", ".", "item", "(", ")", ",", "precision", ")", "for", "k", "in", "losses", "}", "\n", "loss_info", "[", "'Total'", "]", "=", "round", "(", "loss", ".", "item", "(", ")", ",", "precision", ")", "\n", "\n", "if", "args", ".", "log_gpu", ":", "\n", "                        ", "log", ".", "log_gpu_stats", "=", "(", "iteration", "%", "10", "==", "0", ")", "# nvidia-smi is sloooow", "\n", "\n", "", "log", ".", "log", "(", "'train'", ",", "loss", "=", "loss_info", ",", "epoch", "=", "epoch", ",", "iter", "=", "iteration", ",", "\n", "lr", "=", "round", "(", "cur_lr", ",", "10", ")", ",", "elapsed", "=", "elapsed", ")", "\n", "\n", "log", ".", "log_gpu_stats", "=", "args", ".", "log_gpu", "\n", "\n", "", "if", "iteration", "%", "args", ".", "save_interval", "==", "0", "and", "epoch", ">=", "7", ":", "\n", "                    ", "if", "args", ".", "keep_latest", ":", "\n", "                        ", "latest", "=", "SavePath", ".", "get_latest", "(", "args", ".", "save_folder", ",", "cfg", ".", "name", ")", "\n", "\n", "", "print", "(", "'Saving state, iter:'", ",", "iteration", ")", "\n", "STMask_net", ".", "save_weights", "(", "save_path", "(", "epoch", ",", "iteration", ")", ")", "\n", "\n", "if", "args", ".", "keep_latest", "and", "latest", "is", "not", "None", ":", "\n", "                        ", "if", "args", ".", "keep_latest_interval", "<=", "0", "or", "iteration", "%", "args", ".", "keep_latest_interval", "!=", "args", ".", "save_interval", ":", "\n", "                            ", "print", "(", "'Deleting old save...'", ")", "\n", "os", ".", "remove", "(", "latest", ")", "\n", "\n", "# This is done per epoch", "\n", "", "", "", "if", "iteration", "==", "100", ":", "#args.validation_epoch > 0:", "\n", "# if iteration % args.save_interval == 0 and epoch >= 7:", "\n", "                        ", "setup_eval", "(", ")", "\n", "save_path_valid_metrics", "=", "save_path", "(", "epoch", ",", "iteration", ")", ".", "replace", "(", "'.pth'", ",", "'.txt'", ")", "\n", "\n", "# valid_sub", "\n", "# cfg.valid_sub_dataset.test_mode = False", "\n", "# metrics = compute_validation_map(STMask_net, valid_data=False,", "\n", "#                                  output_metrics_file=save_path_valid_metrics)", "\n", "\n", "# valid datasets", "\n", "metrics_valid", "=", "compute_validation_map", "(", "STMask_net", ",", "valid_data", "=", "True", ",", "\n", "output_metrics_file", "=", "save_path_valid_metrics", ")", "\n", "\n", "", "iteration", "+=", "1", "\n", "\n", "", "", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "print", "(", "'Stopping early. Saving network...'", ")", "\n", "\n", "# Delete previous copy of the interrupted network so we don't spam the weights folder", "\n", "SavePath", ".", "remove_interrupt", "(", "args", ".", "save_folder", ")", "\n", "\n", "STMask_net", ".", "save_weights", "(", "save_path", "(", "epoch", ",", "repr", "(", "iteration", ")", "+", "'_interrupt'", ")", ")", "\n", "exit", "(", ")", "\n", "\n", "", "STMask_net", ".", "save_weights", "(", "save_path", "(", "epoch", ",", "iteration", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.set_lr": [[394, 397], ["None"], "function", ["None"], ["", "def", "set_lr", "(", "optimizer", ",", "new_lr", ")", ":", "\n", "    ", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "        ", "param_group", "[", "'lr'", "]", "=", "new_lr", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.compute_validation_loss": [[399, 434], ["print", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "utils.functions.ProgressBar", "enumerate", "sum", "print", "net", "net.items", "utils.functions.ProgressBar.set_val", "print", "v.mean().item.mean().item", "tuple", "v.mean().item.mean", "repr", "len"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print"], ["", "", "def", "compute_validation_loss", "(", "net", ",", "data_loader", ",", "dataset_size", ")", ":", "\n", "    ", "global", "loss_types", "\n", "print", "(", ")", "\n", "print", "(", "'compute_validation_loss, needs few minutes ...'", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "losses", "=", "{", "}", "\n", "progress_bar", "=", "ProgressBar", "(", "30", ",", "dataset_size", ")", "\n", "\n", "# Don't switch to eval mode because we want to get losses", "\n", "iterations", ",", "results", "=", "0", ",", "[", "]", "\n", "for", "i", ",", "data_batch", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "            ", "_losses", "=", "net", "(", "data_batch", ")", "\n", "\n", "for", "k", ",", "v", "in", "_losses", ".", "items", "(", ")", ":", "\n", "                ", "v", "=", "v", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "if", "k", "in", "losses", ":", "\n", "                    ", "losses", "[", "k", "]", "+=", "v", "\n", "", "else", ":", "\n", "                    ", "losses", "[", "k", "]", "=", "v", "\n", "\n", "", "", "progress", "=", "(", "i", "+", "1", ")", "/", "dataset_size", "*", "100", "\n", "progress_bar", ".", "set_val", "(", "i", "+", "1", ")", "\n", "print", "(", "'\\rProcessing Images  %s %6d / %6d (%5.2f%%)'", "\n", "%", "(", "repr", "(", "progress_bar", ")", ",", "i", "+", "1", ",", "dataset_size", ",", "progress", ")", ",", "end", "=", "''", ")", "\n", "\n", "iterations", "+=", "1", "\n", "\n", "", "for", "k", "in", "losses", ":", "\n", "            ", "losses", "[", "k", "]", "/=", "iterations", "\n", "\n", "", "loss_labels", "=", "sum", "(", "[", "[", "k", ",", "losses", "[", "k", "]", "]", "for", "k", "in", "loss_types", "if", "k", "in", "losses", "]", ",", "[", "]", ")", "\n", "print", "(", "(", "'Validation ||'", "+", "(", "' %s: %.3f |'", "*", "len", "(", "losses", ")", ")", "+", "')'", ")", "%", "tuple", "(", "loss_labels", ")", ",", "flush", "=", "True", ")", "\n", "\n", "", "return", "loss_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.compute_validation_map": [[436, 445], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "yolact_net.eval", "print", "print", "eval.validation", "yolact_net.train"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.validation", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.train"], ["", "def", "compute_validation_map", "(", "yolact_net", ",", "valid_data", "=", "False", ",", "output_metrics_file", "=", "None", ")", ":", "\n", "    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "yolact_net", ".", "eval", "(", ")", "\n", "print", "(", ")", "\n", "print", "(", "\"Computing validation mAP (this may take a while)...\"", ",", "flush", "=", "True", ")", "\n", "metrics", "=", "eval_script", ".", "validation", "(", "yolact_net", ",", "valid_data", "=", "valid_data", ",", "output_metrics_file", "=", "output_metrics_file", ")", "\n", "yolact_net", ".", "train", "(", ")", "\n", "\n", "", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.setup_eval": [[447, 453], ["eval.parse_args", "str", "str"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.parse_args"], ["", "def", "setup_eval", "(", ")", ":", "\n", "    ", "eval_script", ".", "parse_args", "(", "[", "'--no_bar'", ",", "\n", "'--batch_size='", "+", "str", "(", "args", ".", "eval_batch_size", ")", ",", "\n", "'--output_json'", ",", "\n", "'--score_threshold='", "+", "str", "(", "cfg", ".", "eval_conf_thresh", ")", ",", "\n", "'--mask_det_file='", "+", "args", ".", "save_folder", "+", "'eval_mask_det.json'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.__init__": [[30, 126], ["torch.Module.__init__", "backbone.construct_backbone", "len", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "len", "enumerate", "layers.Detect", "layers.Track", "STMask.STMask.freeze_bn", "layers.FastMaskIoUNet", "layers.FPN", "layers.PredictionModule_FC", "STMask.STMask.prediction_layers.append", "layers.TemporalNet", "layers.Detect_TF", "layers.Track_TF", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "layers.make_net", "list", "list", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "STMask.STMask.grid.size", "range", "range", "len", "numpy.load", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.construct_backbone", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.freeze_bn", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.make_net.make_net"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "backbone", "=", "construct_backbone", "(", "cfg", ".", "backbone", ")", "\n", "\n", "if", "cfg", ".", "freeze_bn", ":", "\n", "            ", "self", ".", "freeze_bn", "(", ")", "\n", "\n", "# Compute mask_dim here and add it back to the config. Make sure Yolact's constructor is called early!", "\n", "", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "direct", ":", "\n", "            ", "cfg", ".", "mask_dim", "=", "cfg", ".", "mask_size", "**", "2", "\n", "", "elif", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", ":", "\n", "            ", "if", "cfg", ".", "mask_proto_use_grid", ":", "\n", "                ", "self", ".", "grid", "=", "torch", ".", "Tensor", "(", "np", ".", "load", "(", "cfg", ".", "mask_proto_grid_file", ")", ")", "\n", "self", ".", "num_grids", "=", "self", ".", "grid", ".", "size", "(", "0", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "num_grids", "=", "0", "\n", "\n", "", "self", ".", "proto_src", "=", "cfg", ".", "mask_proto_src", "\n", "self", ".", "interpolation_mode", "=", "cfg", ".", "fpn", ".", "interpolation_mode", "\n", "\n", "if", "self", ".", "proto_src", "is", "None", ":", "\n", "                ", "in_channels", "=", "3", "\n", "", "elif", "cfg", ".", "fpn", "is", "not", "None", ":", "\n", "                ", "in_channels", "=", "cfg", ".", "fpn", ".", "num_features", "\n", "", "else", ":", "\n", "                ", "in_channels", "=", "self", ".", "backbone", ".", "channels", "[", "self", ".", "proto_src", "]", "\n", "", "in_channels", "+=", "self", ".", "num_grids", "\n", "\n", "# The include_last_relu=false here is because we might want to change it to another function", "\n", "self", ".", "proto_net", ",", "cfg", ".", "mask_dim", "=", "make_net", "(", "in_channels", ",", "cfg", ".", "mask_proto_net", ",", "include_last_relu", "=", "False", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_bias", ":", "\n", "                ", "cfg", ".", "mask_dim", "+=", "1", "\n", "\n", "", "", "self", ".", "selected_layers", "=", "cfg", ".", "backbone", ".", "selected_layers", "\n", "self", ".", "pred_scales", "=", "cfg", ".", "backbone", ".", "pred_scales", "\n", "self", ".", "pred_aspect_ratios", "=", "cfg", ".", "backbone", ".", "pred_aspect_ratios", "\n", "self", ".", "num_priors", "=", "len", "(", "self", ".", "pred_scales", "[", "0", "]", ")", "\n", "src_channels", "=", "self", ".", "backbone", ".", "channels", "\n", "\n", "if", "cfg", ".", "use_maskiou", ":", "\n", "            ", "self", ".", "maskiou_net", "=", "FastMaskIoUNet", "(", ")", "\n", "\n", "", "if", "cfg", ".", "fpn", "is", "not", "None", ":", "\n", "# Some hacky rewiring to accomodate the FPN", "\n", "            ", "self", ".", "fpn", "=", "FPN", "(", "[", "src_channels", "[", "i", "]", "for", "i", "in", "self", ".", "selected_layers", "]", ")", "\n", "\n", "if", "cfg", ".", "backbone_C2_as_features", ":", "\n", "                ", "self", ".", "selected_layers", "=", "list", "(", "range", "(", "1", ",", "len", "(", "self", ".", "selected_layers", ")", "+", "cfg", ".", "fpn", ".", "num_downsample", ")", ")", "\n", "src_channels", "=", "[", "cfg", ".", "fpn", ".", "num_features", "]", "*", "(", "len", "(", "self", ".", "selected_layers", ")", "+", "1", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "selected_layers", "=", "list", "(", "range", "(", "len", "(", "self", ".", "selected_layers", ")", "+", "cfg", ".", "fpn", ".", "num_downsample", ")", ")", "\n", "src_channels", "=", "[", "cfg", ".", "fpn", ".", "num_features", "]", "*", "len", "(", "self", ".", "selected_layers", ")", "\n", "\n", "# prediction layers for loc, conf, mask", "\n", "", "", "self", ".", "prediction_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "cfg", ".", "num_heads", "=", "len", "(", "self", ".", "selected_layers", ")", "# yolact++", "\n", "for", "idx", ",", "layer_idx", "in", "enumerate", "(", "self", ".", "selected_layers", ")", ":", "\n", "# If we're sharing prediction module weights, have every module's parent be the first one", "\n", "            ", "parent", ",", "parent_t", "=", "None", ",", "None", "\n", "if", "cfg", ".", "share_prediction_module", "and", "idx", ">", "0", ":", "\n", "                ", "parent", "=", "self", ".", "prediction_layers", "[", "0", "]", "\n", "\n", "", "pred", "=", "PredictionModule_FC", "(", "src_channels", "[", "layer_idx", "]", ",", "src_channels", "[", "layer_idx", "]", ",", "\n", "deform_groups", "=", "1", ",", "\n", "pred_aspect_ratios", "=", "self", ".", "pred_aspect_ratios", "[", "idx", "]", ",", "\n", "pred_scales", "=", "self", ".", "pred_scales", "[", "idx", "]", ",", "\n", "parent", "=", "parent", ")", "\n", "\n", "self", ".", "prediction_layers", ".", "append", "(", "pred", ")", "\n", "\n", "# parameters in temporal correlation net", "\n", "", "if", "cfg", ".", "temporal_fusion_module", ":", "\n", "            ", "corr_channels", "=", "2", "*", "in_channels", "+", "cfg", ".", "correlation_patch_size", "**", "2", "\n", "self", ".", "TemporalNet", "=", "TemporalNet", "(", "corr_channels", ",", "cfg", ".", "mask_proto_n", ")", "\n", "self", ".", "correlation_selected_layer", "=", "cfg", ".", "correlation_selected_layer", "\n", "\n", "# evaluation for frame-level tracking", "\n", "self", ".", "Detect_TF", "=", "Detect_TF", "(", "cfg", ".", "num_classes", ",", "bkg_label", "=", "0", ",", "top_k", "=", "cfg", ".", "nms_top_k", ",", "\n", "conf_thresh", "=", "cfg", ".", "nms_conf_thresh", ",", "nms_thresh", "=", "cfg", ".", "nms_thresh", ")", "\n", "self", ".", "Track_TF", "=", "Track_TF", "(", ")", "\n", "\n", "# Extra parameters for the extra losses", "\n", "", "if", "cfg", ".", "use_class_existence_loss", ":", "\n", "# This comes from the smallest layer selected", "\n", "# Also note that cfg.num_classes includes background", "\n", "            ", "self", ".", "class_existence_fc", "=", "nn", ".", "Linear", "(", "src_channels", "[", "-", "1", "]", ",", "cfg", ".", "num_classes", "-", "1", ")", "\n", "\n", "", "if", "cfg", ".", "use_semantic_segmentation_loss", ":", "\n", "            ", "self", ".", "semantic_seg_conv", "=", "nn", ".", "Conv2d", "(", "src_channels", "[", "0", "]", ",", "cfg", ".", "num_classes", "-", "1", ",", "kernel_size", "=", "1", ")", "\n", "\n", "# For use in evaluation", "\n", "", "self", ".", "detect", "=", "Detect", "(", "cfg", ".", "num_classes", ",", "bkg_label", "=", "0", ",", "top_k", "=", "cfg", ".", "nms_top_k", ",", "conf_thresh", "=", "cfg", ".", "nms_conf_thresh", ",", "\n", "nms_thresh", "=", "cfg", ".", "nms_thresh", ")", "\n", "self", ".", "Track", "=", "Track", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.save_weights": [[127, 130], ["torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "STMask.STMask.state_dict"], "methods", ["None"], ["", "def", "save_weights", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Saves the model's weights using compression because the file sizes were getting too big. \"\"\"", "\n", "torch", ".", "save", "(", "self", ".", "state_dict", "(", ")", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.load_weights": [[131, 156], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "STMask.STMask.state_dict", "list", "print", "print", "print", "STMask.STMask.update", "STMask.STMask.load_state_dict", "torch.load.keys", "torch.load.keys", "torch.load.keys", "key.startswith", "key.startswith", "torch.load.items", "torch.load.items", "torch.load.items", "STMask.STMask.items", "torch.load.items", "torch.load.items", "torch.load.items", "key.startswith", "STMask.STMask.keys", "torch.load.keys", "torch.load.keys", "torch.load.keys", "int", "key.split"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["", "def", "load_weights", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Loads weights from a compressed save file. \"\"\"", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ")", "\n", "model_dict", "=", "self", ".", "state_dict", "(", ")", "\n", "\n", "# For backward compatability, remove these (the new variable is called layers)", "\n", "for", "key", "in", "list", "(", "state_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "if", "key", ".", "startswith", "(", "'backbone.layer'", ")", "and", "not", "key", ".", "startswith", "(", "'backbone.layers'", ")", ":", "\n", "                ", "del", "state_dict", "[", "key", "]", "\n", "\n", "# Also for backward compatibility with v1.0 weights, do this check", "\n", "", "if", "key", ".", "startswith", "(", "'fpn.downsample_layers.'", ")", ":", "\n", "                ", "if", "cfg", ".", "fpn", "is", "not", "None", "and", "int", "(", "key", ".", "split", "(", "'.'", ")", "[", "2", "]", ")", ">=", "cfg", ".", "fpn", ".", "num_downsample", ":", "\n", "                    ", "del", "state_dict", "[", "key", "]", "\n", "\n", "", "", "", "diff_layers1", "=", "[", "k", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", "if", "k", "not", "in", "model_dict", ".", "keys", "(", ")", "]", "\n", "print", "(", ")", "\n", "print", "(", "'layers in pre-trained model but not in current model:'", ",", "diff_layers1", ")", "\n", "\n", "diff_layers2", "=", "[", "k", "for", "k", ",", "v", "in", "model_dict", ".", "items", "(", ")", "if", "k", "not", "in", "state_dict", ".", "keys", "(", ")", "]", "\n", "print", "(", "'layers in current model but not in pre-trained model:'", ",", "diff_layers2", ")", "\n", "\n", "state_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", "if", "k", "in", "model_dict", "}", "\n", "model_dict", ".", "update", "(", "state_dict", ")", "\n", "self", ".", "load_state_dict", "(", "model_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.init_weights": [[157, 189], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "STMask.STMask.state_dict", "list", "print", "print", "STMask.STMask.update", "STMask.STMask.items", "STMask.STMask.load_state_dict", "torch.load.keys", "torch.load.keys", "torch.load.keys", "STMask.STMask.keys", "torch.load.items", "torch.load.items", "torch.load.items", "print", "STMask.STMask.items", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model_dict[].zero_", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "torch.tensor().log", "data0.repeat", "data1.repeat", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log"], ["", "def", "init_weights", "(", "self", ",", "backbone_path", ")", ":", "\n", "        ", "\"\"\" Initialize weights for training. \"\"\"", "\n", "state_dict", "=", "torch", ".", "load", "(", "backbone_path", ")", "\n", "model_dict", "=", "self", ".", "state_dict", "(", ")", "\n", "\n", "# only remain same modules and layers between pre-trained model and our model", "\n", "for", "key", "in", "list", "(", "state_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "if", "key", "not", "in", "model_dict", ".", "keys", "(", ")", ":", "\n", "                ", "del", "state_dict", "[", "key", "]", "\n", "", "elif", "model_dict", "[", "key", "]", ".", "shape", "!=", "state_dict", "[", "key", "]", ".", "shape", ":", "\n", "                ", "del", "state_dict", "[", "key", "]", "\n", "\n", "", "", "state_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", "if", "k", "in", "model_dict", "}", "\n", "print", "(", "'parameters without load weights from pre-trained models'", ")", "\n", "print", "(", "[", "k", "for", "k", ",", "v", "in", "model_dict", ".", "items", "(", ")", "if", "k", "not", "in", "state_dict", "]", ")", "\n", "model_dict", ".", "update", "(", "state_dict", ")", "\n", "\n", "# Initialize the rest of the conv layers with xavier", "\n", "for", "k", ",", "v", "in", "model_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "not", "in", "state_dict", ":", "\n", "                ", "print", "(", "'init weights by Xavier:'", ",", "k", ")", "\n", "if", "'weight'", "in", "k", ":", "\n", "                    ", "nn", ".", "init", ".", "xavier_uniform_", "(", "model_dict", "[", "k", "]", ")", "\n", "", "elif", "'bias'", "in", "k", ":", "\n", "                    ", "if", "cfg", ".", "use_sigmoid_focal_loss", "and", "'conf_layer'", "in", "k", ":", "\n", "                        ", "data0", "=", "-", "torch", ".", "tensor", "(", "cfg", ".", "focal_loss_init_pi", "/", "(", "1", "-", "cfg", ".", "focal_loss_init_pi", ")", ")", ".", "log", "(", ")", "\n", "data1", "=", "-", "torch", ".", "tensor", "(", "(", "1", "-", "cfg", ".", "focal_loss_init_pi", ")", "/", "cfg", ".", "focal_loss_init_pi", ")", ".", "log", "(", ")", "\n", "model_dict", "[", "k", "]", "=", "torch", ".", "cat", "(", "[", "data0", ".", "repeat", "(", "self", ".", "num_priors", ")", ",", "data1", ".", "repeat", "(", "(", "cfg", ".", "num_classes", "-", "1", ")", "*", "self", ".", "num_priors", ")", "]", ")", "\n", "", "else", ":", "\n", "                        ", "model_dict", "[", "k", "]", ".", "zero_", "(", ")", "\n", "\n", "", "", "", "", "self", ".", "load_state_dict", "(", "model_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.train": [[190, 195], ["super().train", "STMask.STMask.freeze_bn"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.train", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.freeze_bn"], ["", "def", "train", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "train", "(", "mode", ")", "\n", "\n", "if", "cfg", ".", "freeze_bn", ":", "\n", "            ", "self", ".", "freeze_bn", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.freeze_bn": [[196, 204], ["STMask.STMask.modules", "isinstance", "module.train", "module.eval"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.train"], ["", "", "def", "freeze_bn", "(", "self", ",", "enable", "=", "False", ")", ":", "\n", "        ", "\"\"\" Adapted from https://discuss.pytorch.org/t/how-to-train-with-frozen-batchnorm/12106/8 \"\"\"", "\n", "for", "module", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "module", ".", "train", "(", ")", "if", "enable", "else", "module", ".", "eval", "(", ")", "\n", "\n", "module", ".", "weight", ".", "requires_grad", "=", "enable", "\n", "module", ".", "bias", ".", "requires_grad", "=", "enable", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.forward_single": [[205, 283], ["utils.timer.env", "STMask.STMask.backbone", "utils.timer.env", "zip", "pred_outs.items", "utils.timer.env", "STMask.STMask.fpn", "utils.timer.env", "STMask.STMask.proto_net", "datasets.config.cfg.mask_proto_prototype_activation", "torch.cat.permute().contiguous", "torch.cat.permute().contiguous", "torch.cat.permute().contiguous", "pred_layer", "pred_layer.items", "STMask.STMask.grid.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "pred_outs[].append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.permute", "torch.cat.permute", "torch.cat.permute", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "", "", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" The input should be of size [batch_size, 3, img_h, img_w] \"\"\"", "\n", "\n", "with", "timer", ".", "env", "(", "'backbone'", ")", ":", "\n", "            ", "bb_outs", "=", "self", ".", "backbone", "(", "x", ")", "\n", "\n", "", "if", "cfg", ".", "fpn", "is", "not", "None", ":", "\n", "            ", "with", "timer", ".", "env", "(", "'fpn'", ")", ":", "\n", "# Use backbone.selected_layers because we overwrote self.selected_layers", "\n", "                ", "outs", "=", "[", "bb_outs", "[", "i", "]", "for", "i", "in", "cfg", ".", "backbone", ".", "selected_layers", "]", "\n", "fpn_outs", "=", "self", ".", "fpn", "(", "outs", ")", "\n", "\n", "", "", "proto_out", "=", "None", "\n", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", "and", "cfg", ".", "eval_mask_branch", ":", "\n", "            ", "with", "timer", ".", "env", "(", "'proto'", ")", ":", "\n", "                ", "if", "self", ".", "proto_src", "is", "None", ":", "\n", "                    ", "proto_x", "=", "x", "\n", "", "else", ":", "\n", "# h, w = bb_outs[self.proto_src].size()[2:]", "\n", "# p3_upsample = F.interpolate(fpn_outs[self.proto_src], size=(h, w), mode=self.interpolation_mode,", "\n", "#                             align_corners=False)", "\n", "# proto_x = p3_upsample # + bb_outs[self.proto_src]", "\n", "                    ", "proto_x", "=", "fpn_outs", "[", "self", ".", "proto_src", "]", "\n", "\n", "", "if", "self", ".", "num_grids", ">", "0", ":", "\n", "                    ", "grids", "=", "self", ".", "grid", ".", "repeat", "(", "proto_x", ".", "size", "(", "0", ")", ",", "1", ",", "1", ",", "1", ")", "\n", "proto_x", "=", "torch", ".", "cat", "(", "[", "proto_x", ",", "grids", "]", ",", "dim", "=", "1", ")", "\n", "\n", "", "proto_out", "=", "self", ".", "proto_net", "(", "proto_x", ")", "\n", "proto_out", "=", "cfg", ".", "mask_proto_prototype_activation", "(", "proto_out", ")", "\n", "\n", "# Move the features last so the multiplication is easy", "\n", "proto_out", "=", "proto_out", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_bias", ":", "\n", "                    ", "bias_shape", "=", "[", "x", "for", "x", "in", "proto_out", ".", "size", "(", ")", "]", "\n", "bias_shape", "[", "1", "]", "=", "1", "\n", "proto_out", "=", "torch", ".", "cat", "(", "[", "proto_out", ",", "torch", ".", "ones", "(", "*", "bias_shape", ")", "]", ",", "1", ")", "\n", "\n", "", "", "", "with", "timer", ".", "env", "(", "'pred_heads'", ")", ":", "\n", "            ", "pred_outs", "=", "{", "'mask_coeff'", ":", "[", "]", ",", "'priors'", ":", "[", "]", "}", "\n", "\n", "if", "cfg", ".", "train_boxes", ":", "\n", "                ", "pred_outs", "[", "'loc'", "]", "=", "[", "]", "\n", "", "if", "cfg", ".", "temporal_fusion_module", ":", "\n", "                ", "pred_outs", "[", "'T2S_feat'", "]", "=", "[", "]", "\n", "", "if", "cfg", ".", "train_centerness", ":", "\n", "                ", "pred_outs", "[", "'centerness'", "]", "=", "[", "]", "\n", "\n", "", "if", "cfg", ".", "train_class", ":", "\n", "                ", "pred_outs", "[", "'conf'", "]", "=", "[", "]", "\n", "\n", "", "if", "cfg", ".", "train_track", ":", "\n", "                ", "pred_outs", "[", "'track'", "]", "=", "[", "]", "\n", "\n", "", "for", "idx", ",", "pred_layer", "in", "zip", "(", "self", ".", "selected_layers", ",", "self", ".", "prediction_layers", ")", ":", "\n", "                ", "pred_x", "=", "fpn_outs", "[", "idx", "]", "\n", "\n", "# A hack for the way dataparallel works", "\n", "if", "cfg", ".", "share_prediction_module", "and", "pred_layer", "is", "not", "self", ".", "prediction_layers", "[", "0", "]", ":", "\n", "                    ", "pred_layer", ".", "parent", "=", "[", "self", ".", "prediction_layers", "[", "0", "]", "]", "\n", "\n", "", "p", "=", "pred_layer", "(", "pred_x", ")", "\n", "\n", "for", "k", ",", "v", "in", "p", ".", "items", "(", ")", ":", "\n", "                    ", "pred_outs", "[", "k", "]", ".", "append", "(", "v", ")", "# [batch_size, h*w*anchors, dim]", "\n", "\n", "", "if", "cfg", ".", "backbone_C2_as_features", ":", "\n", "                    ", "idx", "-=", "1", "\n", "\n", "", "", "for", "k", ",", "v", "in", "pred_outs", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", "is", "not", "'T2S_feat'", ":", "\n", "                    ", "pred_outs", "[", "k", "]", "=", "torch", ".", "cat", "(", "v", ",", "1", ")", "\n", "\n", "", "", "", "if", "proto_out", "is", "not", "None", ":", "\n", "            ", "pred_outs", "[", "'proto'", "]", "=", "proto_out", "\n", "\n", "", "return", "fpn_outs", ",", "pred_outs", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.forward": [[284, 330], ["x.size", "STMask.STMask.forward_single", "pred_outs[].repeat", "STMask.STMask.forward_single", "torch.softmax", "torch.softmax", "torch.softmax", "x.view", "[].contiguous", "[].contiguous", "[].contiguous", "[].contiguous", "layers.correlate", "torch.relu", "torch.relu", "torch.relu", "STMask.STMask.class_existence_fc", "STMask.STMask.semantic_seg_conv", "layers.generate_candidate", "STMask.STMask.Detect_TF", "STMask.STMask.Track_TF", "datasets.config.cfg.mask_proto_coeff_activation", "STMask.STMask.detect", "STMask.STMask.Track", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "fpn_outs[].mean"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.forward_single", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.STMask.STMask.forward_single", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.track_to_segment_head.correlate", "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.TF_utils.generate_candidate", "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.detect"], ["", "def", "forward", "(", "self", ",", "x", ",", "img_meta", "=", "None", ",", "ref_x", "=", "None", ",", "ref_imgs_meta", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "training", ":", "\n", "            ", "batch_size", ",", "nf", ",", "c", ",", "h", ",", "w", "=", "x", ".", "size", "(", ")", "\n", "fpn_outs", ",", "pred_outs", "=", "self", ".", "forward_single", "(", "x", ".", "view", "(", "-", "1", ",", "c", ",", "h", ",", "w", ")", ")", "\n", "\n", "if", "cfg", ".", "temporal_fusion_module", ":", "\n", "# calculate correlation map", "\n", "                ", "fpn_ref", "=", "fpn_outs", "[", "self", ".", "correlation_selected_layer", "]", "[", ":", ":", "2", "]", ".", "contiguous", "(", ")", "\n", "fpn_next", "=", "fpn_outs", "[", "self", ".", "correlation_selected_layer", "]", "[", "1", ":", ":", "2", "]", ".", "contiguous", "(", ")", "\n", "x_ref", "=", "pred_outs", "[", "'T2S_feat'", "]", "[", "self", ".", "correlation_selected_layer", "]", "[", ":", ":", "2", "]", ".", "contiguous", "(", ")", "\n", "x_next", "=", "pred_outs", "[", "'T2S_feat'", "]", "[", "self", ".", "correlation_selected_layer", "]", "[", "1", ":", ":", "2", "]", ".", "contiguous", "(", ")", "\n", "x_corr", "=", "correlate", "(", "fpn_ref", ",", "fpn_next", ",", "patch_size", "=", "cfg", ".", "correlation_patch_size", ")", "\n", "pred_outs", "[", "'T2S_concat_feat'", "]", "=", "F", ".", "relu", "(", "torch", ".", "cat", "(", "[", "x_corr", ",", "x_ref", ",", "x_next", "]", ",", "dim", "=", "1", ")", ")", "\n", "del", "pred_outs", "[", "'T2S_feat'", "]", "\n", "\n", "# For the extra loss functions", "\n", "", "if", "cfg", ".", "use_class_existence_loss", ":", "\n", "                ", "pred_outs", "[", "'classes'", "]", "=", "self", ".", "class_existence_fc", "(", "fpn_outs", "[", "-", "1", "]", ".", "mean", "(", "dim", "=", "(", "2", ",", "3", ")", ")", ")", "\n", "\n", "", "if", "cfg", ".", "use_semantic_segmentation_loss", ":", "\n", "                ", "pred_outs", "[", "'segm'", "]", "=", "self", ".", "semantic_seg_conv", "(", "fpn_outs", "[", "0", "]", ")", "\n", "\n", "# for nn.DataParallel", "\n", "", "pred_outs", "[", "'priors'", "]", "=", "pred_outs", "[", "'priors'", "]", ".", "repeat", "(", "batch_size", "*", "nf", ",", "1", ",", "1", ")", "\n", "\n", "return", "pred_outs", "\n", "", "else", ":", "\n", "# track instances frame-by-frame", "\n", "            ", "fpn_outs", ",", "pred_outs", "=", "self", ".", "forward_single", "(", "x", ")", "\n", "pred_outs", "[", "'conf'", "]", "=", "F", ".", "softmax", "(", "pred_outs", "[", "'conf'", "]", ",", "-", "1", ")", "\n", "\n", "if", "cfg", ".", "temporal_fusion_module", ":", "\n", "# we only use the bbox features in the P3 layer", "\n", "                ", "pred_outs", "[", "'fpn_feat'", "]", "=", "fpn_outs", "[", "self", ".", "correlation_selected_layer", "]", "\n", "pred_outs", "[", "'T2S_feat'", "]", "=", "pred_outs", "[", "'T2S_feat'", "]", "[", "self", ".", "correlation_selected_layer", "]", "\n", "candidates", "=", "generate_candidate", "(", "pred_outs", ")", "\n", "candidates_after_NMS", "=", "self", ".", "Detect_TF", "(", "self", ",", "candidates", ",", "is_output_candidate", "=", "True", ")", "\n", "pred_outs_after_NMS", "=", "self", ".", "Track_TF", "(", "self", ",", "candidates_after_NMS", ",", "img_meta", ",", "imgs", "=", "x", ")", "\n", "\n", "", "else", ":", "\n", "                ", "pred_outs", "[", "'mask_coeff'", "]", "=", "cfg", ".", "mask_proto_coeff_activation", "(", "pred_outs", "[", "'mask_coeff'", "]", ")", "\n", "# detect instances by NMS for each single frame", "\n", "pred_outs_after_NMS", "=", "self", ".", "detect", "(", "pred_outs", ",", "self", ")", "\n", "pred_outs_after_NMS", "=", "self", ".", "Track", "(", "pred_outs_after_NMS", ",", "img_meta", ")", "\n", "\n", "", "return", "pred_outs_after_NMS", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.Bottleneck.__init__": [[12, 37], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "norm_layer", "norm_layer", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReLU", "torch.ReLU", "dcn_v2.DCN", "backbone.Bottleneck.conv2.bias.data.zero_", "backbone.Bottleneck.conv2.conv_offset_mask.weight.data.zero_", "backbone.Bottleneck.conv2.conv_offset_mask.bias.data.zero_", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ",", "norm_layer", "=", "nn", ".", "BatchNorm2d", ",", "dilation", "=", "1", ",", "use_dcn", "=", "False", ",", "\n", "n_clip", "=", "4", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "use_dcn", "=", "use_dcn", "\n", "self", ".", "n_clip", "=", "n_clip", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ",", "dilation", "=", "1", ")", "\n", "self", ".", "bn1", "=", "norm_layer", "(", "planes", ")", "\n", "\n", "if", "use_dcn", ":", "\n", "            ", "self", ".", "conv2", "=", "DCN", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ",", "deformable_groups", "=", "1", ")", "\n", "# self.conv2.init_offset()", "\n", "self", ".", "conv2", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv2", ".", "conv_offset_mask", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv2", ".", "conv_offset_mask", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "dilation", ",", "bias", "=", "False", ",", "dilation", "=", "dilation", ")", "\n", "\n", "", "self", ".", "bn2", "=", "norm_layer", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ",", "dilation", "=", "1", ")", "\n", "self", ".", "bn3", "=", "norm_layer", "(", "planes", "*", "4", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.Bottleneck.forward": [[38, 59], ["backbone.Bottleneck.conv1", "backbone.Bottleneck.bn1", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv2", "backbone.Bottleneck.bn2", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv3", "backbone.Bottleneck.bn3", "backbone.Bottleneck.relu", "backbone.Bottleneck.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.ResNetBackbone.__init__": [[64, 104], ["torch.Module.__init__", "len", "torch.ModuleList", "torch.ModuleList", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "backbone.ResNetBackbone._make_layer", "backbone.ResNetBackbone._make_layer", "backbone.ResNetBackbone._make_layer", "backbone.ResNetBackbone._make_layer", "backbone.ResNetBackbone._freeze_stages", "backbone.ResNetBackbone.modules", "isinstance"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.ResNetBackbone._freeze_stages"], ["def", "__init__", "(", "self", ",", "layers", ",", "dcn_layers", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", ",", "dcn_interval", "=", "1", ",", "atrous_layers", "=", "[", "]", ",", "stride_layers", "=", "[", "1", ",", "2", ",", "2", ",", "2", "]", ",", "\n", "block", "=", "Bottleneck", ",", "frozen_stages", "=", "-", "1", ",", "norm_layer", "=", "nn", ".", "BatchNorm2d", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# These will be populated by _make_layer", "\n", "self", ".", "num_base_layers", "=", "len", "(", "layers", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "channels", "=", "[", "]", "\n", "self", ".", "norm_layer", "=", "norm_layer", "\n", "self", ".", "dilation", "=", "1", "\n", "self", ".", "atrous_layers", "=", "atrous_layers", "\n", "self", ".", "frozen_stages", "=", "frozen_stages", "\n", "\n", "# From torchvision.models.resnet.Resnet", "\n", "self", ".", "inplanes", "=", "64", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "norm_layer", "(", "64", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "\n", "# original mask_layer", "\n", "# self._make_layer(block, 64, layers[0])", "\n", "# self._make_layer(block, 128, layers[1], stride=2)", "\n", "# self._make_layer(block, 256, layers[2], stride=2)", "\n", "# self._make_layer(block, 512, layers[3], stride=2)", "\n", "\n", "# add deformable convolutional network on mask_layer", "\n", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ",", "stride", "=", "stride_layers", "[", "0", "]", ",", "dcn_layers", "=", "dcn_layers", "[", "0", "]", ",", "dcn_interval", "=", "dcn_interval", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "stride", "=", "stride_layers", "[", "1", "]", ",", "dcn_layers", "=", "dcn_layers", "[", "1", "]", ",", "dcn_interval", "=", "dcn_interval", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "stride", "=", "stride_layers", "[", "2", "]", ",", "dcn_layers", "=", "dcn_layers", "[", "2", "]", ",", "dcn_interval", "=", "dcn_interval", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "stride", "=", "stride_layers", "[", "3", "]", ",", "dcn_layers", "=", "dcn_layers", "[", "3", "]", ",", "dcn_interval", "=", "dcn_interval", ")", "\n", "\n", "# This contains every module that should be initialized by loading in pretrained weights.", "\n", "# Any extra layers added onto this that won't be initialized by init_backbone will not be", "\n", "# in this list. That way, Yolact::init_weights knows which backbone weights to initialize", "\n", "# with xavier, and which ones to leave alone.", "\n", "self", ".", "backbone_modules", "=", "[", "m", "for", "m", "in", "self", ".", "modules", "(", ")", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "]", "\n", "\n", "self", ".", "_freeze_stages", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.ResNetBackbone._make_layer": [[105, 139], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "backbone.ResNetBackbone.channels.append", "backbone.ResNetBackbone.layers.append", "torch.Sequential", "torch.Sequential", "block", "layers.append", "len", "torch.Conv2d", "torch.Conv2d", "backbone.ResNetBackbone.norm_layer", "block"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ",", "dcn_layers", "=", "0", ",", "dcn_interval", "=", "1", ")", ":", "\n", "        ", "\"\"\" Here one layer means a string of n Bottleneck blocks. \"\"\"", "\n", "downsample", "=", "None", "\n", "\n", "# This is actually just to create the connection between layers, and not necessarily to", "\n", "# downsample. Even if the second condition is met, it only downsamples when stride != 1", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "if", "len", "(", "self", ".", "layers", ")", "in", "self", ".", "atrous_layers", ":", "\n", "                ", "self", ".", "dilation", "*=", "2", "\n", "stride", "=", "1", "\n", "\n", "", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ",", "\n", "dilation", "=", "self", ".", "dilation", ")", ",", "\n", "self", ".", "norm_layer", "(", "planes", "*", "block", ".", "expansion", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "use_dcn", "=", "(", "dcn_layers", ">=", "blocks", ")", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", "=", "stride", ",", "downsample", "=", "downsample", ",", "norm_layer", "=", "self", ".", "norm_layer", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "use_dcn", "=", "use_dcn", ")", ")", "\n", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "use_dcn", "=", "(", "(", "i", "+", "dcn_layers", ")", ">=", "blocks", ")", "and", "(", "i", "%", "dcn_interval", "==", "0", ")", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "dilation", "=", "self", ".", "dilation", ",", "norm_layer", "=", "self", ".", "norm_layer", ",", "use_dcn", "=", "use_dcn", ")", ")", "\n", "\n", "", "layer", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "self", ".", "channels", ".", "append", "(", "planes", "*", "block", ".", "expansion", ")", "\n", "self", ".", "layers", ".", "append", "(", "layer", ")", "\n", "\n", "return", "layer", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.ResNetBackbone.forward": [[140, 154], ["backbone.ResNetBackbone.conv1", "backbone.ResNetBackbone.bn1", "backbone.ResNetBackbone.relu", "backbone.ResNetBackbone.maxpool", "tuple", "layer", "outs.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" Returns a list of convouts for each layer. \"\"\"", "\n", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.ResNetBackbone.init_backbone": [[155, 169], ["torch.load", "torch.load", "torch.load", "torch.load", "list", "backbone.ResNetBackbone.load_state_dict", "key.startswith", "int", "torch.load.pop", "torch.load.pop", "str"], "methods", ["None"], ["", "def", "init_backbone", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Initializes the backbone weights for training. \"\"\"", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ")", "\n", "\n", "# Replace layer1 -> layers.0 etc.", "\n", "keys", "=", "list", "(", "state_dict", ")", "\n", "for", "key", "in", "keys", ":", "\n", "            ", "if", "key", ".", "startswith", "(", "'layer'", ")", ":", "\n", "                ", "idx", "=", "int", "(", "key", "[", "5", "]", ")", "\n", "new_key", "=", "'layers.'", "+", "str", "(", "idx", "-", "1", ")", "+", "key", "[", "6", ":", "]", "\n", "state_dict", "[", "new_key", "]", "=", "state_dict", ".", "pop", "(", "key", ")", "\n", "\n", "# Note: Using strict=False is berry scary. Triple check this.", "\n", "", "", "self", ".", "load_state_dict", "(", "state_dict", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.ResNetBackbone.add_layer": [[170, 173], ["backbone.ResNetBackbone._make_layer"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer"], ["", "def", "add_layer", "(", "self", ",", "conv_channels", "=", "1024", ",", "downsample", "=", "2", ",", "depth", "=", "1", ",", "block", "=", "Bottleneck", ")", ":", "\n", "        ", "\"\"\" Add a downsample layer to the backbone as per what SSD does. \"\"\"", "\n", "self", ".", "_make_layer", "(", "block", ",", "conv_channels", "//", "block", ".", "expansion", ",", "blocks", "=", "depth", ",", "stride", "=", "downsample", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.ResNetBackbone._freeze_stages": [[174, 186], ["range", "backbone.ResNetBackbone.bn1.eval", "getattr", "getattr.eval", "getattr.parameters", "getattr.parameters"], "methods", ["None"], ["", "def", "_freeze_stages", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "frozen_stages", ">=", "0", ":", "\n", "            ", "self", ".", "bn1", ".", "eval", "(", ")", "\n", "for", "m", "in", "[", "self", ".", "conv1", ",", "self", ".", "bn1", "]", ":", "\n", "                ", "for", "param", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                    ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "", "", "for", "i", "in", "range", "(", "self", ".", "frozen_stages", ")", ":", "\n", "            ", "m", "=", "getattr", "(", "self", ".", "layers", ",", "'{}'", ".", "format", "(", "i", ")", ")", "\n", "m", ".", "eval", "(", ")", "\n", "for", "param", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.ResNetBackboneGN.__init__": [[190, 192], ["backbone.ResNetBackbone.__init__", "torch.GroupNorm", "torch.GroupNorm"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__"], ["    ", "def", "__init__", "(", "self", ",", "layers", ",", "num_groups", "=", "32", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "layers", ",", "norm_layer", "=", "lambda", "x", ":", "nn", ".", "GroupNorm", "(", "num_groups", ",", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.ResNetBackboneGN.init_backbone": [[193, 240], ["list", "backbone.ResNetBackboneGN.load_state_dict", "open", "pickle.load", "backbone.ResNetBackboneGN.state_dict().keys", "key.split", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "str", "backbone.ResNetBackboneGN.state_dict", "int", "gn_trans", "layeridx2res", "int", "int", "gn_trans", "block2branch", "gn_trans"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["", "def", "init_backbone", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" The path here comes from detectron. So we load it differently. \"\"\"", "\n", "with", "open", "(", "path", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "state_dict", "=", "pickle", ".", "load", "(", "f", ",", "encoding", "=", "'latin1'", ")", "# From the detectron source", "\n", "state_dict", "=", "state_dict", "[", "'blobs'", "]", "\n", "\n", "", "our_state_dict_keys", "=", "list", "(", "self", ".", "state_dict", "(", ")", ".", "keys", "(", ")", ")", "\n", "new_state_dict", "=", "{", "}", "\n", "\n", "gn_trans", "=", "lambda", "x", ":", "(", "'gn_s'", "if", "x", "==", "'weight'", "else", "'gn_b'", ")", "\n", "layeridx2res", "=", "lambda", "x", ":", "'res'", "+", "str", "(", "int", "(", "x", ")", "+", "2", ")", "\n", "block2branch", "=", "lambda", "x", ":", "'branch2'", "+", "(", "'a'", ",", "'b'", ",", "'c'", ")", "[", "int", "(", "x", "[", "-", "1", ":", "]", ")", "-", "1", "]", "\n", "\n", "# Transcribe each Detectron weights name to a Yolact weights name", "\n", "for", "key", "in", "our_state_dict_keys", ":", "\n", "            ", "parts", "=", "key", ".", "split", "(", "'.'", ")", "\n", "transcribed_key", "=", "''", "\n", "\n", "if", "(", "parts", "[", "0", "]", "==", "'conv1'", ")", ":", "\n", "                ", "transcribed_key", "=", "'conv1_w'", "\n", "", "elif", "(", "parts", "[", "0", "]", "==", "'bn1'", ")", ":", "\n", "                ", "transcribed_key", "=", "'conv1_'", "+", "gn_trans", "(", "parts", "[", "1", "]", ")", "\n", "", "elif", "(", "parts", "[", "0", "]", "==", "'layers'", ")", ":", "\n", "                ", "if", "int", "(", "parts", "[", "1", "]", ")", ">=", "self", ".", "num_base_layers", ":", "continue", "\n", "\n", "transcribed_key", "=", "layeridx2res", "(", "parts", "[", "1", "]", ")", "\n", "transcribed_key", "+=", "'_'", "+", "parts", "[", "2", "]", "+", "'_'", "\n", "\n", "if", "parts", "[", "3", "]", "==", "'downsample'", ":", "\n", "                    ", "transcribed_key", "+=", "'branch1_'", "\n", "\n", "if", "parts", "[", "4", "]", "==", "'0'", ":", "\n", "                        ", "transcribed_key", "+=", "'w'", "\n", "", "else", ":", "\n", "                        ", "transcribed_key", "+=", "gn_trans", "(", "parts", "[", "5", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "transcribed_key", "+=", "block2branch", "(", "parts", "[", "3", "]", ")", "+", "'_'", "\n", "\n", "if", "'conv'", "in", "parts", "[", "3", "]", ":", "\n", "                        ", "transcribed_key", "+=", "'w'", "\n", "", "else", ":", "\n", "                        ", "transcribed_key", "+=", "gn_trans", "(", "parts", "[", "4", "]", ")", "\n", "\n", "", "", "", "new_state_dict", "[", "key", "]", "=", "torch", ".", "Tensor", "(", "state_dict", "[", "transcribed_key", "]", ")", "\n", "\n", "# strict=False because we may have extra unitialized layers at this point", "\n", "", "self", ".", "load_state_dict", "(", "new_state_dict", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.DarkNetBlock.__init__": [[261, 266], ["torch.Module.__init__", "backbone.darknetconvlayer", "backbone.darknetconvlayer"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.darknetconvlayer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.darknetconvlayer"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv1", "=", "darknetconvlayer", "(", "in_channels", ",", "channels", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "conv2", "=", "darknetconvlayer", "(", "channels", ",", "channels", "*", "self", ".", "expansion", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.DarkNetBlock.forward": [[267, 269], ["backbone.DarkNetBlock.conv2", "backbone.DarkNetBlock.conv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "conv2", "(", "self", ".", "conv1", "(", "x", ")", ")", "+", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.DarkNetBackbone.__init__": [[278, 300], ["torch.Module.__init__", "len", "torch.ModuleList", "torch.ModuleList", "backbone.darknetconvlayer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone.modules", "isinstance"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.darknetconvlayer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer"], ["def", "__init__", "(", "self", ",", "layers", "=", "[", "1", ",", "2", ",", "8", ",", "8", ",", "4", "]", ",", "block", "=", "DarkNetBlock", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# These will be populated by _make_layer", "\n", "self", ".", "num_base_layers", "=", "len", "(", "layers", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "channels", "=", "[", "]", "\n", "\n", "self", ".", "_preconv", "=", "darknetconvlayer", "(", "3", ",", "32", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "in_channels", "=", "32", "\n", "\n", "self", ".", "_make_layer", "(", "block", ",", "32", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "1", "]", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "2", "]", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "3", "]", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "4", "]", ")", "\n", "\n", "# This contains every module that should be initialized by loading in pretrained weights.", "\n", "# Any extra layers added onto this that won't be initialized by init_backbone will not be", "\n", "# in this list. That way, Yolact::init_weights knows which backbone weights to initialize", "\n", "# with xavier, and which ones to leave alone.", "\n", "self", ".", "backbone_modules", "=", "[", "m", "for", "m", "in", "self", ".", "modules", "(", ")", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.DarkNetBackbone._make_layer": [[301, 316], ["layer_list.append", "backbone.DarkNetBackbone.channels.append", "backbone.DarkNetBackbone.layers.append", "backbone.darknetconvlayer", "block", "torch.Sequential", "torch.Sequential", "range"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.darknetconvlayer"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "channels", ",", "num_blocks", ",", "stride", "=", "2", ")", ":", "\n", "        ", "\"\"\" Here one layer means a string of n blocks. \"\"\"", "\n", "layer_list", "=", "[", "]", "\n", "\n", "# The downsample layer", "\n", "layer_list", ".", "append", "(", "\n", "darknetconvlayer", "(", "self", ".", "in_channels", ",", "channels", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "stride", "=", "stride", ")", ")", "\n", "\n", "# Each block inputs channels and outputs channels * expansion", "\n", "self", ".", "in_channels", "=", "channels", "*", "block", ".", "expansion", "\n", "layer_list", "+=", "[", "block", "(", "self", ".", "in_channels", ",", "channels", ")", "for", "_", "in", "range", "(", "num_blocks", ")", "]", "\n", "\n", "self", ".", "channels", ".", "append", "(", "self", ".", "in_channels", ")", "\n", "self", ".", "layers", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "layer_list", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.DarkNetBackbone.forward": [[317, 328], ["backbone.DarkNetBackbone._preconv", "tuple", "layer", "outs.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" Returns a list of convouts for each layer. \"\"\"", "\n", "\n", "x", "=", "self", ".", "_preconv", "(", "x", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.DarkNetBackbone.add_layer": [[329, 332], ["backbone.DarkNetBackbone._make_layer"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer"], ["", "def", "add_layer", "(", "self", ",", "conv_channels", "=", "1024", ",", "stride", "=", "2", ",", "depth", "=", "1", ",", "block", "=", "DarkNetBlock", ")", ":", "\n", "        ", "\"\"\" Add a downsample layer to the backbone as per what SSD does. \"\"\"", "\n", "self", ".", "_make_layer", "(", "block", ",", "conv_channels", "//", "block", ".", "expansion", ",", "num_blocks", "=", "depth", ",", "stride", "=", "stride", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.DarkNetBackbone.init_backbone": [[333, 337], ["backbone.DarkNetBackbone.load_state_dict", "torch.load", "torch.load", "torch.load", "torch.load"], "methods", ["None"], ["", "def", "init_backbone", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Initializes the backbone weights for training. \"\"\"", "\n", "# Note: Using strict=False is berry scary. Triple check this.", "\n", "self", ".", "load_state_dict", "(", "torch", ".", "load", "(", "path", ")", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone.__init__": [[350, 373], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "list", "enumerate", "torch.ModuleList", "torch.ModuleList", "reversed", "backbone.VGGBackbone._make_layer", "torch.BatchNorm2d", "torch.BatchNorm2d", "enumerate", "backbone.VGGBackbone.modules", "isinstance"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer"], ["def", "__init__", "(", "self", ",", "cfg", ",", "extra_args", "=", "[", "]", ",", "norm_layers", "=", "[", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "channels", "=", "[", "]", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "in_channels", "=", "3", "\n", "self", ".", "extra_args", "=", "list", "(", "reversed", "(", "extra_args", ")", ")", "# So I can use it as a stack", "\n", "\n", "# Keeps track of what the corresponding key will be in the state dict of the", "\n", "# pretrained model. For instance, layers.0.2 for us is 2 for the pretrained", "\n", "# model but layers.1.1 is 5.", "\n", "self", ".", "total_layer_count", "=", "0", "\n", "self", ".", "state_dict_lookup", "=", "{", "}", "\n", "\n", "for", "idx", ",", "layer_cfg", "in", "enumerate", "(", "cfg", ")", ":", "\n", "            ", "self", ".", "_make_layer", "(", "layer_cfg", ")", "\n", "\n", "", "self", ".", "norms", "=", "nn", ".", "ModuleList", "(", "[", "nn", ".", "BatchNorm2d", "(", "self", ".", "channels", "[", "l", "]", ")", "for", "l", "in", "norm_layers", "]", ")", "\n", "self", ".", "norm_lookup", "=", "{", "l", ":", "idx", "for", "idx", ",", "l", "in", "enumerate", "(", "norm_layers", ")", "}", "\n", "\n", "# These modules will be initialized by init_backbone,", "\n", "# so don't overwrite their initialization later.", "\n", "self", ".", "backbone_modules", "=", "[", "m", "for", "m", "in", "self", ".", "modules", "(", ")", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone._make_layer": [[374, 414], ["len", "backbone.VGGBackbone.channels.append", "backbone.VGGBackbone.layers.append", "isinstance", "torch.Sequential", "torch.Sequential", "layers.append", "layers.append", "layers.append", "torch.MaxPool2d", "torch.MaxPool2d", "len", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "len", "len"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "_make_layer", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Each layer is a sequence of conv layers usually preceded by a max pooling.\n        Adapted from torchvision.models.vgg.make_layers.\n        \"\"\"", "\n", "\n", "layers", "=", "[", "]", "\n", "\n", "for", "v", "in", "cfg", ":", "\n", "# VGG in SSD requires some special layers, so allow layers to be tuples of", "\n", "# (<M or num_features>, kwdargs dict)", "\n", "            ", "args", "=", "None", "\n", "if", "isinstance", "(", "v", ",", "tuple", ")", ":", "\n", "                ", "args", "=", "v", "[", "1", "]", "\n", "v", "=", "v", "[", "0", "]", "\n", "\n", "# v should be either M or a number", "\n", "", "if", "v", "==", "'M'", ":", "\n", "# Set default arguments", "\n", "                ", "if", "args", "is", "None", ":", "\n", "                    ", "args", "=", "{", "'kernel_size'", ":", "2", ",", "'stride'", ":", "2", "}", "\n", "\n", "", "layers", ".", "append", "(", "nn", ".", "MaxPool2d", "(", "**", "args", ")", ")", "\n", "", "else", ":", "\n", "# See the comment in __init__ for an explanation of this", "\n", "                ", "cur_layer_idx", "=", "self", ".", "total_layer_count", "+", "len", "(", "layers", ")", "\n", "self", ".", "state_dict_lookup", "[", "cur_layer_idx", "]", "=", "'%d.%d'", "%", "(", "len", "(", "self", ".", "layers", ")", ",", "len", "(", "layers", ")", ")", "\n", "\n", "# Set default arguments", "\n", "if", "args", "is", "None", ":", "\n", "                    ", "args", "=", "{", "'kernel_size'", ":", "3", ",", "'padding'", ":", "1", "}", "\n", "\n", "# Add the layers", "\n", "", "layers", ".", "append", "(", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "v", ",", "**", "args", ")", ")", "\n", "layers", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "self", ".", "in_channels", "=", "v", "\n", "\n", "", "", "self", ".", "total_layer_count", "+=", "len", "(", "layers", ")", "\n", "self", ".", "channels", ".", "append", "(", "self", ".", "in_channels", ")", "\n", "self", ".", "layers", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "layers", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone.forward": [[415, 429], ["enumerate", "tuple", "layer", "outs.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" Returns a list of convouts for each layer. \"\"\"", "\n", "outs", "=", "[", "]", "\n", "\n", "for", "idx", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "\n", "# Apply an l2norm module to the selected layers", "\n", "# Note that this differs from the original implemenetation", "\n", "if", "idx", "in", "self", ".", "norm_lookup", ":", "\n", "                ", "x", "=", "self", ".", "norms", "[", "self", ".", "norm_lookup", "[", "idx", "]", "]", "(", "x", ")", "\n", "", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone.transform_key": [[430, 435], ["k.split", "int"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["", "def", "transform_key", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\" Transform e.g. features.24.bias to layers.4.1.bias \"\"\"", "\n", "vals", "=", "k", ".", "split", "(", "'.'", ")", "\n", "layerIdx", "=", "self", ".", "state_dict_lookup", "[", "int", "(", "vals", "[", "0", "]", ")", "]", "\n", "return", "'layers.%s.%s'", "%", "(", "layerIdx", ",", "vals", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone.init_backbone": [[436, 442], ["torch.load", "torch.load", "torch.load", "torch.load", "collections.OrderedDict", "backbone.VGGBackbone.load_state_dict", "backbone.VGGBackbone.transform_key", "collections.OrderedDict.items"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone.transform_key"], ["", "def", "init_backbone", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Initializes the backbone weights for training. \"\"\"", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ")", "\n", "state_dict", "=", "OrderedDict", "(", "[", "(", "self", ".", "transform_key", "(", "k", ")", ",", "v", ")", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", "]", ")", "\n", "\n", "self", ".", "load_state_dict", "(", "state_dict", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone.add_layer": [[443, 460], ["torch.Sequential", "torch.Sequential", "backbone.VGGBackbone.channels.append", "backbone.VGGBackbone.layers.append", "len", "backbone.VGGBackbone.extra_args.pop", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "add_layer", "(", "self", ",", "conv_channels", "=", "128", ",", "downsample", "=", "2", ")", ":", "\n", "        ", "\"\"\" Add a downsample layer to the backbone as per what SSD does. \"\"\"", "\n", "if", "len", "(", "self", ".", "extra_args", ")", ">", "0", ":", "\n", "            ", "conv_channels", ",", "downsample", "=", "self", ".", "extra_args", ".", "pop", "(", ")", "\n", "\n", "", "padding", "=", "1", "if", "downsample", ">", "1", "else", "0", "\n", "\n", "layer", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "conv_channels", ",", "kernel_size", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "conv_channels", ",", "conv_channels", "*", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "downsample", ",", "padding", "=", "padding", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", ")", "\n", "\n", "self", ".", "in_channels", "=", "conv_channels", "*", "2", "\n", "self", ".", "channels", ".", "append", "(", "self", ".", "in_channels", ")", "\n", "self", ".", "layers", ".", "append", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.darknetconvlayer": [[242, 253], ["torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d", "torch.LeakyReLU"], "function", ["None"], ["", "", "def", "darknetconvlayer", "(", "in_channels", ",", "out_channels", ",", "*", "args", ",", "**", "kwdargs", ")", ":", "\n", "    ", "\"\"\"\n    Implements a conv, activation, then batch norm.\n    Arguments are passed into the conv layer.\n    \"\"\"", "\n", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "*", "args", ",", "**", "kwdargs", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", ",", "\n", "# Darknet uses 0.1 here.", "\n", "# See https://github.com/pjreddie/darknet/blob/680d3bde1924c8ee2d1c1dea54d3e56a05ca9a26/src/activations.h#L39", "\n", "nn", ".", "LeakyReLU", "(", "0.1", ",", "inplace", "=", "True", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.construct_backbone": [[462, 473], ["cfg.type", "max", "len", "cfg.type.add_layer"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.backbone.VGGBackbone.add_layer"], ["", "", "def", "construct_backbone", "(", "cfg", ")", ":", "\n", "    ", "\"\"\" Constructs a backbone given a backbone config object (see config.py). \"\"\"", "\n", "backbone", "=", "cfg", ".", "type", "(", "*", "cfg", ".", "args", ")", "\n", "\n", "# Add downsampling layers until we reach the number we need", "\n", "num_layers", "=", "max", "(", "cfg", ".", "selected_layers", ")", "+", "1", "\n", "\n", "while", "len", "(", "backbone", ".", "layers", ")", "<", "num_layers", ":", "\n", "        ", "backbone", ".", "add_layer", "(", ")", "\n", "\n", "", "return", "backbone", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo.gpu_info": [[8, 43], ["len", "nvinfo._run_cmd", "range", "re.match().groups", "dict", "int", "int", "nvinfo._run_cmd", "zip", "int", "x.strip", "int", "int", "re.match", "m.strip().replace", "[].strip().split", "pw_tmp_info.split", "mem_info.replace().split", "selected_lines[].split", "len", "util_info.split", "m.strip", "[].strip", "mem_info.replace", "selected_lines[].split"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo._run_cmd", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo._run_cmd", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.match", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.replace", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.replace", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["def", "gpu_info", "(", ")", "->", "list", ":", "\n", "    ", "\"\"\"\n    Returns a dictionary of stats mined from nvidia-smi for each gpu in a list.\n    Adapted from nvgpu: https://pypi.org/project/nvgpu/, but mine has more info.\n    \"\"\"", "\n", "gpus", "=", "[", "line", "for", "line", "in", "_run_cmd", "(", "[", "'nvidia-smi'", ",", "'-L'", "]", ")", "if", "line", "]", "\n", "gpu_infos", "=", "[", "re", ".", "match", "(", "'GPU ([0-9]+): ([^(]+) \\(UUID: ([^)]+)\\)'", ",", "gpu", ")", ".", "groups", "(", ")", "for", "gpu", "in", "gpus", "]", "\n", "gpu_infos", "=", "[", "dict", "(", "zip", "(", "[", "'idx'", ",", "'name'", ",", "'uuid'", "]", ",", "info", ")", ")", "for", "info", "in", "gpu_infos", "]", "\n", "gpu_count", "=", "len", "(", "gpus", ")", "\n", "\n", "lines", "=", "_run_cmd", "(", "[", "'nvidia-smi'", "]", ")", "\n", "selected_lines", "=", "lines", "[", "7", ":", "7", "+", "3", "*", "gpu_count", "]", "\n", "for", "i", "in", "range", "(", "gpu_count", ")", ":", "\n", "        ", "mem_used", ",", "mem_total", "=", "[", "int", "(", "m", ".", "strip", "(", ")", ".", "replace", "(", "'MiB'", ",", "''", ")", ")", "for", "m", "in", "\n", "selected_lines", "[", "3", "*", "i", "+", "1", "]", ".", "split", "(", "'|'", ")", "[", "2", "]", ".", "strip", "(", ")", ".", "split", "(", "'/'", ")", "]", "\n", "\n", "pw_tmp_info", ",", "mem_info", ",", "util_info", "=", "[", "x", ".", "strip", "(", ")", "for", "x", "in", "selected_lines", "[", "3", "*", "i", "+", "1", "]", ".", "split", "(", "'|'", ")", "[", "1", ":", "-", "1", "]", "]", "\n", "\n", "pw_tmp_info", "=", "[", "x", "[", ":", "-", "1", "]", "for", "x", "in", "pw_tmp_info", ".", "split", "(", "' '", ")", "if", "len", "(", "x", ")", ">", "0", "]", "\n", "fan_speed", ",", "temperature", ",", "pwr_used", ",", "pwr_cap", "=", "[", "int", "(", "pw_tmp_info", "[", "i", "]", ")", "for", "i", "in", "(", "0", ",", "1", ",", "3", ",", "5", ")", "]", "\n", "gpu_infos", "[", "i", "]", "[", "'fan_spd'", "]", "=", "fan_speed", "\n", "gpu_infos", "[", "i", "]", "[", "'temp'", "]", "=", "temperature", "\n", "gpu_infos", "[", "i", "]", "[", "'pwr_used'", "]", "=", "pwr_used", "\n", "gpu_infos", "[", "i", "]", "[", "'pwr_cap'", "]", "=", "pwr_cap", "\n", "\n", "mem_used", ",", "mem_total", "=", "[", "int", "(", "x", ")", "for", "x", "in", "mem_info", ".", "replace", "(", "'MiB'", ",", "''", ")", ".", "split", "(", "' / '", ")", "]", "\n", "gpu_infos", "[", "i", "]", "[", "'mem_used'", "]", "=", "mem_used", "\n", "gpu_infos", "[", "i", "]", "[", "'mem_total'", "]", "=", "mem_total", "\n", "\n", "utilization", "=", "int", "(", "util_info", ".", "split", "(", "' '", ")", "[", "0", "]", "[", ":", "-", "1", "]", ")", "\n", "gpu_infos", "[", "i", "]", "[", "'util'", "]", "=", "utilization", "\n", "\n", "gpu_infos", "[", "i", "]", "[", "'idx'", "]", "=", "int", "(", "gpu_infos", "[", "i", "]", "[", "'idx'", "]", ")", "\n", "\n", "", "return", "gpu_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo.nvsmi_available": [[45, 48], ["shutil.which"], "function", ["None"], ["", "def", "nvsmi_available", "(", ")", "->", "bool", ":", "\n", "    ", "\"\"\" Returns whether or not nvidia-smi is present in this system's PATH. \"\"\"", "\n", "return", "shutil", ".", "which", "(", "'nvidia-smi'", ")", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo.visible_gpus": [[50, 57], ["list", "range", "int", "len", "x.strip", "os.environ[].split", "nvinfo.gpu_info"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo.gpu_info"], ["", "def", "visible_gpus", "(", ")", "->", "list", ":", "\n", "    ", "\"\"\" Returns a list of the indexes of all the gpus visible to pytorch. \"\"\"", "\n", "\n", "if", "'CUDA_VISIBLE_DEVICES'", "not", "in", "os", ".", "environ", ":", "\n", "        ", "return", "list", "(", "range", "(", "len", "(", "gpu_info", "(", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "[", "int", "(", "x", ".", "strip", "(", ")", ")", "for", "x", "in", "os", ".", "environ", "[", "'CUDA_VISIBLE_DEVICES'", "]", ".", "split", "(", "','", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo._run_cmd": [[59, 64], ["subprocess.check_output", "output.decode.decode", "output.decode.split"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["", "", "def", "_run_cmd", "(", "cmd", ":", "list", ")", "->", "list", ":", "\n", "    ", "\"\"\" Runs a command and returns a list of output lines. \"\"\"", "\n", "output", "=", "subprocess", ".", "check_output", "(", "cmd", ")", "\n", "output", "=", "output", ".", "decode", "(", "'UTF-8'", ")", "\n", "return", "output", ".", "split", "(", "'\\n'", ")", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.env.__init__": [[122, 125], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "fn_name", ",", "use_stack", "=", "True", ")", ":", "\n", "\t\t", "self", ".", "fn_name", "=", "fn_name", "\n", "self", ".", "use_stack", "=", "use_stack", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.env.__enter__": [[126, 128], ["timer.start"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.start"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "\t\t", "start", "(", "self", ".", "fn_name", ",", "use_stack", "=", "self", ".", "use_stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.env.__exit__": [[129, 131], ["timer.stop"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.stop"], ["", "def", "__exit__", "(", "self", ",", "e", ",", "ev", ",", "t", ")", ":", "\n", "\t\t", "stop", "(", "self", ".", "fn_name", ",", "use_stack", "=", "self", ".", "use_stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.disable_all": [[11, 14], ["None"], "function", ["None"], ["def", "disable_all", "(", ")", ":", "\n", "\t", "global", "_disable_all", "\n", "_disable_all", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.enable_all": [[15, 18], ["None"], "function", ["None"], ["", "def", "enable_all", "(", ")", ":", "\n", "\t", "global", "_disable_all", "\n", "_disable_all", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.disable": [[19, 22], ["_disabled_names.add"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add"], ["", "def", "disable", "(", "fn_name", ")", ":", "\n", "\t", "\"\"\" Disables the given function name fom being considered for the average or outputted in print_stats. \"\"\"", "\n", "_disabled_names", ".", "add", "(", "fn_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.enable": [[23, 26], ["_disabled_names.remove"], "function", ["None"], ["", "def", "enable", "(", "fn_name", ")", ":", "\n", "\t", "\"\"\" Enables function names disabled by disable. \"\"\"", "\n", "_disabled_names", ".", "remove", "(", "fn_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.reset": [[27, 34], ["_total_times.clear", "_start_times.clear", "_timer_stack.clear"], "function", ["None"], ["", "def", "reset", "(", ")", ":", "\n", "\t", "\"\"\" Resets the current timer. Call this at the start of an iteration. \"\"\"", "\n", "global", "_running_timer", "\n", "_total_times", ".", "clear", "(", ")", "\n", "_start_times", ".", "clear", "(", ")", "\n", "_timer_stack", ".", "clear", "(", ")", "\n", "_running_timer", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.start": [[35, 54], ["timer.start", "time.perf_counter", "timer.stop", "_timer_stack.append"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.start", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.stop", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "start", "(", "fn_name", ",", "use_stack", "=", "True", ")", ":", "\n", "\t", "\"\"\"\n\tStart timing the specific function.\n\tNote: If use_stack is True, only one timer can be active at a time.\n\t      Once you stop this timer, the previous one will start again.\n\t\"\"\"", "\n", "global", "_running_timer", ",", "_disable_all", "\n", "\n", "if", "_disable_all", ":", "\n", "\t\t", "return", "\n", "\n", "", "if", "use_stack", ":", "\n", "\t\t", "if", "_running_timer", "is", "not", "None", ":", "\n", "\t\t\t", "stop", "(", "_running_timer", ",", "use_stack", "=", "False", ")", "\n", "_timer_stack", ".", "append", "(", "_running_timer", ")", "\n", "", "start", "(", "fn_name", ",", "use_stack", "=", "False", ")", "\n", "_running_timer", "=", "fn_name", "\n", "", "else", ":", "\n", "\t\t", "_start_times", "[", "fn_name", "]", "=", "time", ".", "perf_counter", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.stop": [[55, 83], ["timer.stop", "print", "print", "len", "_timer_stack.pop", "timer.start", "time.perf_counter"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.stop", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.start"], ["", "", "def", "stop", "(", "fn_name", "=", "None", ",", "use_stack", "=", "True", ")", ":", "\n", "\t", "\"\"\"\n\tIf use_stack is True, this will stop the currently running timer and restore\n\tthe previous timer on the stack if that exists. Note if use_stack is True,\n\tfn_name will be ignored.\n\n\tIf use_stack is False, this will just stop timing the timer fn_name.\n\t\"\"\"", "\n", "global", "_running_timer", ",", "_disable_all", "\n", "\n", "if", "_disable_all", ":", "\n", "\t\t", "return", "\n", "\n", "", "if", "use_stack", ":", "\n", "\t\t", "if", "_running_timer", "is", "not", "None", ":", "\n", "\t\t\t", "stop", "(", "_running_timer", ",", "use_stack", "=", "False", ")", "\n", "if", "len", "(", "_timer_stack", ")", ">", "0", ":", "\n", "\t\t\t\t", "_running_timer", "=", "_timer_stack", ".", "pop", "(", ")", "\n", "start", "(", "_running_timer", ",", "use_stack", "=", "False", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "_running_timer", "=", "None", "\n", "", "", "else", ":", "\n", "\t\t\t", "print", "(", "'Warning: timer stopped with no timer running!'", ")", "\n", "", "", "else", ":", "\n", "\t\t", "if", "_start_times", "[", "fn_name", "]", ">", "-", "1", ":", "\n", "\t\t\t", "_total_times", "[", "fn_name", "]", "+=", "time", ".", "perf_counter", "(", ")", "-", "_start_times", "[", "fn_name", "]", "\n", "", "else", ":", "\n", "\t\t\t", "print", "(", "'Warning: timer for %s stopped before starting!'", "%", "fn_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.print_stats": [[85, 108], ["print", "max", "print", "header.find", "print", "print", "print", "print", "print", "format_str.format", "_total_times.keys", "format_str.format", "len", "timer.total_time", "len"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.total_time"], ["", "", "", "def", "print_stats", "(", ")", ":", "\n", "\t", "\"\"\" Prints the current timing information into a table. \"\"\"", "\n", "print", "(", ")", "\n", "\n", "all_fn_names", "=", "[", "k", "for", "k", "in", "_total_times", ".", "keys", "(", ")", "if", "k", "not", "in", "_disabled_names", "]", "\n", "\n", "max_name_width", "=", "max", "(", "[", "len", "(", "k", ")", "for", "k", "in", "all_fn_names", "]", "+", "[", "4", "]", ")", "\n", "if", "max_name_width", "%", "2", "==", "1", ":", "max_name_width", "+=", "1", "\n", "format_str", "=", "' {:>%d} | {:>10.4f} '", "%", "max_name_width", "\n", "\n", "header", "=", "(", "' {:^%d} | {:^10} '", "%", "max_name_width", ")", ".", "format", "(", "'Name'", ",", "'Time (ms)'", ")", "\n", "print", "(", "header", ")", "\n", "\n", "sep_idx", "=", "header", ".", "find", "(", "'|'", ")", "\n", "sep_text", "=", "(", "'-'", "*", "sep_idx", ")", "+", "'+'", "+", "'-'", "*", "(", "len", "(", "header", ")", "-", "sep_idx", "-", "1", ")", "\n", "print", "(", "sep_text", ")", "\n", "\n", "for", "name", "in", "all_fn_names", ":", "\n", "\t\t", "print", "(", "format_str", ".", "format", "(", "name", ",", "_total_times", "[", "name", "]", "*", "1000", ")", ")", "\n", "\n", "", "print", "(", "sep_text", ")", "\n", "print", "(", "format_str", ".", "format", "(", "'Total'", ",", "total_time", "(", ")", "*", "1000", ")", ")", "\n", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.timer.total_time": [[109, 112], ["sum", "_total_times.items"], "function", ["None"], ["", "def", "total_time", "(", ")", ":", "\n", "\t", "\"\"\" Returns the total amount accumulated across all functions in seconds. \"\"\"", "\n", "return", "sum", "(", "[", "elapsed_time", "for", "name", ",", "elapsed_time", "in", "_total_times", ".", "items", "(", ")", "if", "name", "not", "in", "_disabled_names", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.__init__": [[34, 68], ["os.path.join", "os.path.exists", "logger.Log._log_session_header", "print", "os.path.exists", "os.makedirs", "visible_gpus", "nvsmi_available", "open", "len", "json.loads"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log._log_session_header", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo.visible_gpus", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo.nvsmi_available"], ["def", "__init__", "(", "self", ",", "log_name", ":", "str", ",", "log_dir", ":", "str", "=", "'logs/'", ",", "session_data", ":", "dict", "=", "{", "}", ",", "\n", "overwrite", ":", "bool", "=", "False", ",", "log_gpu_stats", ":", "bool", "=", "True", ",", "log_time", ":", "bool", "=", "True", ")", ":", "\n", "\n", "        ", "if", "log_gpu_stats", "and", "not", "nvsmi_available", "(", ")", ":", "\n", "            ", "print", "(", "'Warning: Log created with log_gpu_stats=True, but nvidia-smi '", "'was not found. Setting log_gpu_stats to False.'", ")", "\n", "log_gpu_stats", "=", "False", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "log_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "log_dir", ")", "\n", "", "self", ".", "log_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "log_name", "+", "'.log'", ")", "\n", "\n", "# if os.path.exists(self.log_path) and overwrite:", "\n", "#     os.unlink(self.log_path)", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "log_path", ")", ":", "\n", "# Log already exists, so we're going to add to it. Increment the session counter.", "\n", "            ", "with", "open", "(", "self", ".", "log_path", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "for", "last", "in", "f", ":", "pass", "\n", "\n", "if", "len", "(", "last", ")", ">", "1", ":", "\n", "                    ", "self", ".", "session", "=", "json", ".", "loads", "(", "last", ")", "[", "'session'", "]", "+", "1", "\n", "", "else", ":", "\n", "                    ", "self", ".", "session", "=", "0", "\n", "", "", "", "else", ":", "\n", "            ", "self", ".", "session", "=", "0", "\n", "\n", "", "self", ".", "log_gpu_stats", "=", "log_gpu_stats", "\n", "self", ".", "log_time", "=", "log_time", "\n", "\n", "if", "self", ".", "log_gpu_stats", ":", "\n", "            ", "self", ".", "visible_gpus", "=", "visible_gpus", "(", ")", "\n", "\n", "", "self", ".", "_log_session_header", "(", "session_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log._log_session_header": [[69, 93], ["gpu_info", "time.time", "json.dumps", "open", "f.write"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo.gpu_info"], ["", "def", "_log_session_header", "(", "self", ",", "session_data", ":", "dict", ")", ":", "\n", "        ", "\"\"\"\n        Log information that does not change between iterations here.\n        This is to cut down on the file size so you're not outputing this every iteration.\n        \"\"\"", "\n", "info", "=", "{", "}", "\n", "info", "[", "'type'", "]", "=", "'session'", "\n", "info", "[", "'session'", "]", "=", "self", ".", "session", "\n", "\n", "info", "[", "'data'", "]", "=", "session_data", "\n", "\n", "if", "self", ".", "log_gpu_stats", ":", "\n", "            ", "keys", "=", "[", "'idx'", ",", "'name'", ",", "'uuid'", ",", "'pwr_cap'", ",", "'mem_total'", "]", "\n", "\n", "gpus", "=", "gpu_info", "(", ")", "\n", "info", "[", "'gpus'", "]", "=", "[", "{", "k", ":", "gpus", "[", "i", "]", "[", "k", "]", "for", "k", "in", "keys", "}", "for", "i", "in", "self", ".", "visible_gpus", "]", "\n", "\n", "", "if", "self", ".", "log_time", ":", "\n", "            ", "info", "[", "'time'", "]", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "out", "=", "json", ".", "dumps", "(", "info", ")", "+", "'\\n'", "\n", "\n", "with", "open", "(", "self", ".", "log_path", ",", "'a'", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log": [[94, 123], ["kwdargs.update", "gpu_info", "time.time", "json.dumps", "open", "f.write"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.nvinfo.gpu_info"], ["", "", "def", "log", "(", "self", ",", "type", ":", "str", ",", "data", ":", "dict", "=", "{", "}", ",", "**", "kwdargs", ")", ":", "\n", "        ", "\"\"\"\n        Add an iteration to the log with the specified data points.\n        Type should be the type of information this is (e.g., train, valid, etc.)\n\n        You can either pass data points as kwdargs, or as a dictionary (or both!).\n        Values should be json-serializable.\n        \"\"\"", "\n", "info", "=", "{", "}", "\n", "\n", "info", "[", "'type'", "]", "=", "type", "\n", "info", "[", "'session'", "]", "=", "self", ".", "session", "\n", "\n", "kwdargs", ".", "update", "(", "data", ")", "\n", "info", "[", "'data'", "]", "=", "kwdargs", "\n", "\n", "if", "self", ".", "log_gpu_stats", ":", "\n", "            ", "keys", "=", "[", "'fan_spd'", ",", "'temp'", ",", "'pwr_used'", ",", "'mem_used'", ",", "'util'", "]", "\n", "\n", "gpus", "=", "gpu_info", "(", ")", "\n", "info", "[", "'gpus'", "]", "=", "[", "{", "k", ":", "gpus", "[", "i", "]", "[", "k", "]", "for", "k", "in", "keys", "}", "for", "i", "in", "self", ".", "visible_gpus", "]", "\n", "\n", "", "if", "self", ".", "log_time", ":", "\n", "            ", "info", "[", "'time'", "]", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "out", "=", "json", ".", "dumps", "(", "info", ")", "+", "'\\n'", "\n", "\n", "with", "open", "(", "self", ".", "log_path", ",", "'a'", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogEntry.__init__": [[128, 130], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "entry", ":", "Union", "[", "dict", ",", "list", "]", ")", ":", "\n", "        ", "self", ".", "_", "=", "entry", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogEntry.__getattr__": [[131, 141], ["logger.LogEntry", "type", "type"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "if", "name", "==", "'_'", ":", "\n", "            ", "return", "self", ".", "__dict__", "[", "'_'", "]", "\n", "\n", "", "res", "=", "self", ".", "__dict__", "[", "'_'", "]", "[", "name", "]", "\n", "\n", "if", "type", "(", "res", ")", "==", "dict", "or", "type", "(", "res", ")", "==", "list", ":", "\n", "            ", "return", "LogEntry", "(", "res", ")", "\n", "", "else", ":", "\n", "            ", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogEntry.__getitem__": [[142, 144], ["logger.LogEntry.__getattr__"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogEntry.__getattr__"], ["", "", "def", "__getitem__", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "self", ".", "__getattr__", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogEntry.__len__": [[145, 147], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "__dict__", "[", "'_'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.__init__": [[164, 168], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "logs", "=", "[", "]", "\n", "self", ".", "total_logs", "=", "[", "]", "\n", "self", ".", "log_names", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._decode": [[169, 183], ["eval.strip", "eval", "eval.strip", "eval", "query.split"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["", "def", "_decode", "(", "self", ",", "query", ":", "str", ")", "->", "list", ":", "\n", "        ", "path", ",", "select", "=", "(", "query", ".", "split", "(", "';'", ")", "+", "[", "''", "]", ")", "[", ":", "2", "]", "\n", "\n", "if", "select", ".", "strip", "(", ")", "==", "''", ":", "\n", "            ", "select", "=", "lambda", "x", ",", "s", ":", "True", "\n", "", "else", ":", "\n", "            ", "select", "=", "eval", "(", "'lambda x, s: '", "+", "select", ")", "\n", "\n", "", "if", "path", ".", "strip", "(", ")", "==", "''", ":", "\n", "            ", "path", "=", "lambda", "x", ",", "s", ":", "x", "\n", "", "else", ":", "\n", "            ", "path", "=", "eval", "(", "'lambda x, s: '", "+", "path", ")", "\n", "\n", "", "return", "path", ",", "select", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._follow": [[184, 199], ["select", "path", "type"], "methods", ["None"], ["", "def", "_follow", "(", "self", ",", "entry", ":", "LogEntry", ",", "query", ":", "list", ")", ":", "\n", "        ", "path", ",", "select", "=", "query", "\n", "\n", "try", ":", "\n", "            ", "if", "select", "(", "entry", ",", "entry", ".", "_s", ")", ":", "\n", "                ", "res", "=", "path", "(", "entry", ",", "entry", ".", "_s", ")", "\n", "\n", "if", "type", "(", "res", ")", "==", "LogEntry", ":", "\n", "                    ", "return", "res", ".", "__dict__", "[", "'_'", "]", "\n", "", "else", ":", "\n", "                    ", "return", "res", "\n", "", "", "else", ":", "\n", "                ", "return", "None", "\n", "", "", "except", "(", "KeyError", ",", "IndexError", ")", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._color": [[200, 202], ["len"], "methods", ["None"], ["", "", "def", "_color", "(", "self", ",", "idx", ":", "int", ")", ":", "\n", "        ", "return", "self", ".", "COLORS", "[", "idx", "%", "len", "(", "self", ".", "COLORS", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.sessions": [[203, 235], ["logger.LogVisualizer.sessions.pop_session"], "methods", ["None"], ["", "def", "sessions", "(", "self", ",", "path", ":", "str", ")", ":", "\n", "        ", "\"\"\" Prints statistics about the sessions in the file. \"\"\"", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "            ", "print", "(", "path", "+", "' doesn\\'t exist!'", ")", "\n", "return", "\n", "\n", "", "cur_session", "=", "None", "\n", "cur_time", "=", "0", "\n", "last_time", "=", "0", "\n", "num_entries", "=", "0", "\n", "\n", "def", "pop_session", "(", ")", ":", "\n", "            ", "delta", "=", "last_time", "-", "cur_time", "\n", "time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "delta", ")", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "print", "(", "'Session % 3d: % 8d entries | %s elapsed'", "%", "(", "cur_session", ",", "num_entries", ",", "time_str", ")", ")", "\n", "\n", "", "with", "open", "(", "path", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "len", "(", "line", ")", ">", "0", ":", "\n", "                    ", "js", "=", "json", ".", "loads", "(", "line", ")", "\n", "if", "js", "[", "'type'", "]", "==", "'session'", ":", "\n", "                        ", "if", "cur_session", "is", "not", "None", ":", "\n", "                            ", "pop_session", "(", ")", "\n", "", "cur_time", "=", "js", "[", "'time'", "]", "\n", "cur_session", "=", "js", "[", "'session'", "]", "\n", "num_entries", "=", "0", "\n", "", "last_time", "=", "js", "[", "'time'", "]", "\n", "num_entries", "+=", "1", "\n", "\n", "", "", "", "pop_session", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.add": [[236, 284], ["collections.defaultdict", "os.path.basename", "logger.LogVisualizer.logs.append", "logger.LogVisualizer.total_logs.append", "logger.LogVisualizer.log_names.append", "os.path.exists", "print", "open", "line.strip.strip.strip", "type", "len", "json.loads", "logger.LogEntry", "log[].append", "total_log.append", "logger.LogVisualizer.add.valid"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "add", "(", "self", ",", "path", ":", "str", ",", "session", ":", "Union", "[", "int", ",", "list", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\" Add a log file to the list of logs being considered. \"\"\"", "\n", "\n", "log", "=", "defaultdict", "(", "lambda", ":", "[", "]", ")", "\n", "total_log", "=", "[", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "            ", "print", "(", "path", "+", "' doesn\\'t exist!'", ")", "\n", "return", "\n", "\n", "", "session_idx", "=", "0", "\n", "ignoring", "=", "True", "\n", "\n", "def", "valid", "(", "idx", ")", ":", "\n", "            ", "if", "session", "is", "None", ":", "\n", "                ", "return", "True", "\n", "", "elif", "type", "(", "session", ")", "==", "int", ":", "\n", "                ", "return", "(", "idx", "==", "session", ")", "\n", "", "else", ":", "\n", "                ", "return", "idx", "in", "session", "\n", "\n", "", "", "with", "open", "(", "path", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "len", "(", "line", ")", ">", "0", ":", "\n", "                    ", "js", "=", "json", ".", "loads", "(", "line", ")", "\n", "\n", "_type", "=", "js", "[", "'type'", "]", "\n", "if", "_type", "==", "'session'", ":", "\n", "                        ", "session_idx", "=", "js", "[", "'session'", "]", "\n", "ignoring", "=", "not", "valid", "(", "session_idx", ")", "\n", "\n", "", "if", "not", "ignoring", ":", "\n", "                        ", "ljs", "=", "LogEntry", "(", "js", ")", "\n", "if", "_type", "==", "'session'", ":", "\n", "                            ", "js", "[", "'_s'", "]", "=", "ljs", "\n", "", "else", ":", "\n", "                            ", "js", "[", "'_s'", "]", "=", "log", "[", "'session'", "]", "[", "-", "1", "]", "\n", "", "log", "[", "_type", "]", ".", "append", "(", "ljs", ")", "\n", "total_log", ".", "append", "(", "ljs", ")", "\n", "\n", "", "", "", "", "name", "=", "os", ".", "path", ".", "basename", "(", "path", ")", "\n", "if", "session", "is", "not", "None", ":", "\n", "            ", "name", "+=", "' (Session %s)'", "%", "session", "\n", "\n", "", "self", ".", "logs", ".", "append", "(", "log", ")", "\n", "self", ".", "total_logs", ".", "append", "(", "total_log", ")", "\n", "self", ".", "log_names", ".", "append", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.query": [[285, 315], ["type", "logger.LogVisualizer._decode", "range", "res.append", "len", "logger.LogVisualizer._follow", "candidates.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._follow", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "query", "(", "self", ",", "x", ":", "Union", "[", "str", ",", "list", "]", ",", "entry_type", ":", "str", "=", "None", ",", "x_idx", ":", "int", "=", "None", ",", "log_idx", ":", "int", "=", "None", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Given a query string (can be already decoded for faster computation), query the entire log\n        and return all values found by that query. If both log_idx and x_idx is None, this will be\n        a list of lists in the form [log_idx][result_idx]. If x_idx is not None, then the result\n        will be a list of [log_idx]. If both are not none, the return value will be a single query\n        return value. With entry_type=None, this will search the entire log.\n        \"\"\"", "\n", "\n", "if", "type", "(", "x", ")", "is", "not", "list", ":", "\n", "            ", "x", "=", "self", ".", "_decode", "(", "x", ")", "\n", "\n", "", "res", "=", "[", "]", "\n", "\n", "for", "idx", "in", "(", "range", "(", "len", "(", "self", ".", "logs", ")", ")", "if", "log_idx", "is", "None", "else", "[", "log_idx", "]", ")", ":", "\n", "            ", "candidates", "=", "[", "]", "\n", "log", "=", "self", ".", "total_logs", "[", "idx", "]", "if", "entry_type", "is", "None", "else", "self", ".", "logs", "[", "idx", "]", "[", "entry_type", "]", "\n", "\n", "for", "entry", "in", "log", ":", "\n", "                ", "candidate", "=", "self", ".", "_follow", "(", "entry", ",", "x", ")", "\n", "if", "candidate", "is", "not", "None", ":", "\n", "                    ", "candidates", ".", "append", "(", "candidate", ")", "\n", "\n", "", "", "if", "x_idx", "is", "not", "None", ":", "\n", "                ", "candidates", "=", "candidates", "[", "x_idx", "]", "\n", "", "res", ".", "append", "(", "candidates", ")", "\n", "\n", "", "if", "log_idx", "is", "not", "None", ":", "\n", "            ", "res", "=", "res", "[", "0", "]", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.check": [[316, 332], ["set", "logger.LogVisualizer._decode", "list", "logger.LogVisualizer._follow", "type", "logger.LogVisualizer.keys", "set.add", "type", "set.add", "len"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._follow", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add"], ["", "def", "check", "(", "self", ",", "entry_type", ":", "str", ",", "x", ":", "str", ")", ":", "\n", "        ", "\"\"\" Checks the log for the valid keys for this input. \"\"\"", "\n", "keys", "=", "set", "(", ")", "\n", "x", "=", "self", ".", "_decode", "(", "x", ")", "\n", "\n", "for", "log", "in", "self", ".", "logs", ":", "\n", "            ", "for", "datum", "in", "log", "[", "entry_type", "]", ":", "\n", "                ", "res", "=", "self", ".", "_follow", "(", "datum", ",", "x", ")", "\n", "\n", "if", "type", "(", "res", ")", "==", "dict", ":", "\n", "                    ", "for", "key", "in", "res", ".", "keys", "(", ")", ":", "\n", "                        ", "keys", ".", "add", "(", "key", ")", "\n", "", "", "elif", "type", "(", "res", ")", "==", "list", ":", "\n", "                    ", "keys", ".", "add", "(", "'< %d'", "%", "len", "(", "res", ")", ")", "\n", "\n", "", "", "", "return", "list", "(", "keys", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.plot": [[333, 369], ["logger.LogVisualizer._decode", "logger.LogVisualizer._decode", "enumerate", "matplotlib.title", "matplotlib.legend", "matplotlib.grid", "matplotlib.show", "zip", "matplotlib.plot", "y.replace", "MovingAverage", "logger.LogVisualizer._follow", "logger.LogVisualizer._follow", "_x.append", "_y.append", "logger.LogVisualizer._color", "MovingAverage.append", "MovingAverage.get_avg", "len"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.plot", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.replace", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._follow", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._follow", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._color", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg"], ["", "def", "plot", "(", "self", ",", "entry_type", ":", "str", ",", "x", ":", "str", ",", "y", ":", "str", ",", "smoothness", ":", "int", "=", "0", ")", ":", "\n", "        ", "\"\"\" Plot sequential log data. \"\"\"", "\n", "\n", "query_x", "=", "self", ".", "_decode", "(", "x", ")", "\n", "query_y", "=", "self", ".", "_decode", "(", "y", ")", "\n", "\n", "for", "idx", ",", "(", "log", ",", "name", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "logs", ",", "self", ".", "log_names", ")", ")", ":", "\n", "            ", "log", "=", "log", "[", "entry_type", "]", "\n", "\n", "if", "smoothness", ">", "1", ":", "\n", "                ", "avg", "=", "MovingAverage", "(", "smoothness", ")", "\n", "\n", "", "_x", "=", "[", "]", "\n", "_y", "=", "[", "]", "\n", "\n", "for", "datum", "in", "log", ":", "\n", "                ", "val_x", "=", "self", ".", "_follow", "(", "datum", ",", "query_x", ")", "\n", "val_y", "=", "self", ".", "_follow", "(", "datum", ",", "query_y", ")", "\n", "\n", "if", "val_x", "is", "not", "None", "and", "val_y", "is", "not", "None", ":", "\n", "                    ", "if", "smoothness", ">", "1", ":", "\n", "                        ", "avg", ".", "append", "(", "val_y", ")", "\n", "val_y", "=", "avg", ".", "get_avg", "(", ")", "\n", "\n", "if", "len", "(", "avg", ")", "<", "smoothness", "//", "10", ":", "\n", "                            ", "continue", "\n", "\n", "", "", "_x", ".", "append", "(", "val_x", ")", "\n", "_y", ".", "append", "(", "val_y", ")", "\n", "\n", "", "", "plt", ".", "plot", "(", "_x", ",", "_y", ",", "color", "=", "self", ".", "_color", "(", "idx", ")", ",", "label", "=", "name", ")", "\n", "\n", "", "plt", ".", "title", "(", "y", ".", "replace", "(", "'x.'", ",", "entry_type", "+", "'.'", ")", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "grid", "(", "linestyle", "=", "':'", ",", "linewidth", "=", "0.5", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.bar": [[370, 444], ["logger.LogVisualizer._decode", "enumerate", "len", "range", "enumerate", "matplotlib.title", "matplotlib.xticks", "matplotlib.legend", "matplotlib.show", "zip", "len", "print", "set", "list", "list.sort", "reversed", "numpy.arange", "positions.append", "zip", "matplotlib.bar", "logger.LogVisualizer._follow", "len", "data_points.append", "range", "range", "len", "x.replace", "type", "candidates.append", "list.add", "len", "len", "logger.LogVisualizer._color", "range", "type", "candidates.append", "len", "enumerate"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.bar", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._follow", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.replace", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer._color", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "bar", "(", "self", ",", "entry_type", ":", "str", ",", "x", ":", "str", ",", "labels", ":", "list", "=", "None", ",", "diff", ":", "bool", "=", "False", ",", "x_idx", ":", "int", "=", "-", "1", ")", ":", "\n", "        ", "\"\"\" Plot a bar chart. The result of x should be list or dictionary. \"\"\"", "\n", "\n", "query", "=", "self", ".", "_decode", "(", "x", ")", "\n", "\n", "data_points", "=", "[", "]", "\n", "\n", "for", "idx", ",", "(", "log", ",", "name", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "logs", ",", "self", ".", "log_names", ")", ")", ":", "\n", "            ", "log", "=", "log", "[", "entry_type", "]", "\n", "\n", "candidates", "=", "[", "]", "\n", "\n", "for", "entry", "in", "log", ":", "\n", "                ", "test", "=", "self", ".", "_follow", "(", "entry", ",", "query", ")", "\n", "\n", "if", "type", "(", "test", ")", "==", "dict", ":", "\n", "                    ", "candidates", ".", "append", "(", "test", ")", "\n", "", "elif", "type", "(", "test", ")", "==", "list", ":", "\n", "                    ", "candidates", ".", "append", "(", "{", "idx", ":", "v", "for", "idx", ",", "v", "in", "enumerate", "(", "test", ")", "}", ")", "\n", "\n", "", "", "if", "len", "(", "candidates", ")", ">", "0", ":", "\n", "                ", "data_points", ".", "append", "(", "(", "name", ",", "candidates", "[", "x_idx", "]", ")", ")", "\n", "\n", "", "", "if", "len", "(", "data_points", ")", "==", "0", ":", "\n", "            ", "print", "(", "'Warning: Nothing to show in bar chart!'", ")", "\n", "return", "\n", "\n", "", "names", "=", "[", "x", "[", "0", "]", "for", "x", "in", "data_points", "]", "\n", "data_points", "=", "[", "x", "[", "1", "]", "for", "x", "in", "data_points", "]", "\n", "\n", "# Construct the labels for the data", "\n", "if", "labels", "is", "not", "None", ":", "\n", "            ", "data_labels", "=", "labels", "\n", "", "else", ":", "\n", "            ", "data_labels", "=", "set", "(", ")", "\n", "for", "datum", "in", "data_points", ":", "\n", "                ", "for", "k", "in", "datum", ":", "\n", "                    ", "data_labels", ".", "add", "(", "k", ")", "\n", "\n", "", "", "data_labels", "=", "list", "(", "data_labels", ")", "\n", "data_labels", ".", "sort", "(", ")", "\n", "\n", "", "data_values", "=", "[", "[", "(", "datum", "[", "k", "]", "if", "k", "in", "datum", "else", "None", ")", "for", "k", "in", "data_labels", "]", "for", "datum", "in", "data_points", "]", "\n", "\n", "if", "diff", ":", "\n", "            ", "for", "idx", "in", "reversed", "(", "range", "(", "len", "(", "data_values", ")", ")", ")", ":", "\n", "                ", "for", "jdx", "in", "range", "(", "len", "(", "data_labels", ")", ")", ":", "\n", "                    ", "if", "data_values", "[", "0", "]", "[", "jdx", "]", "is", "None", "or", "data_values", "[", "idx", "]", "[", "jdx", "]", "is", "None", ":", "\n", "                        ", "data_values", "[", "idx", "]", "[", "jdx", "]", "=", "None", "\n", "", "else", ":", "\n", "                        ", "data_values", "[", "idx", "]", "[", "jdx", "]", "-=", "data_values", "[", "0", "]", "[", "jdx", "]", "\n", "\n", "", "", "", "", "series_labels", "=", "names", "\n", "\n", "# Plot the graph now", "\n", "num_bars", "=", "len", "(", "series_labels", ")", "\n", "bar_width", "=", "1", "/", "(", "num_bars", "+", "1", ")", "\n", "\n", "# Set position of bar on X axis", "\n", "positions", "=", "[", "np", ".", "arange", "(", "len", "(", "data_labels", ")", ")", "]", "\n", "for", "_", "in", "range", "(", "1", ",", "num_bars", ")", ":", "\n", "            ", "positions", ".", "append", "(", "[", "x", "+", "bar_width", "for", "x", "in", "positions", "[", "-", "1", "]", "]", ")", "\n", "\n", "# Make the plot", "\n", "", "for", "idx", ",", "(", "series", ",", "data", ",", "pos", ")", "in", "enumerate", "(", "zip", "(", "series_labels", ",", "data_values", ",", "positions", ")", ")", ":", "\n", "            ", "plt", ".", "bar", "(", "pos", ",", "data", ",", "color", "=", "self", ".", "_color", "(", "idx", ")", ",", "width", "=", "bar_width", ",", "edgecolor", "=", "'white'", ",", "label", "=", "series", ")", "\n", "\n", "# Add xticks on the middle of the group bars", "\n", "", "plt", ".", "title", "(", "x", ".", "replace", "(", "'x.'", ",", "entry_type", "+", "'.'", ")", "+", "(", "' diff'", "if", "diff", "else", "''", ")", ")", "\n", "plt", ".", "xticks", "(", "[", "r", "+", "bar_width", "for", "r", "in", "range", "(", "len", "(", "data_labels", ")", ")", "]", ",", "data_labels", ")", "\n", "\n", "# Create legend & Show graphic", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.elapsed_time": [[445, 461], ["logger.LogVisualizer.query", "logger.LogVisualizer.query", "diff", "zip", "str().split", "str", "datetime.timedelta"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.query", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.query", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["", "def", "elapsed_time", "(", "self", ",", "cond1", ":", "str", "=", "''", ",", "cond2", ":", "str", "=", "''", ",", "legible", ":", "bool", "=", "True", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Returns the elapsed time between two entries based on the given conditionals.\n        If a query isn't specified, the first / last entry will be used. The first query\n        uses the first value and the second query uses the last value in the results.\n        Setting legible to true returns human-readable results, while false returns seconds.\n        \"\"\"", "\n", "q1", "=", "'x.time; '", "+", "cond1", "\n", "q2", "=", "'x.time; '", "+", "cond2", "\n", "\n", "x1", "=", "self", ".", "query", "(", "q1", ",", "x_idx", "=", "0", ")", "\n", "x2", "=", "self", ".", "query", "(", "q2", ",", "x_idx", "=", "-", "1", ")", "\n", "\n", "diff", "=", "(", "lambda", "x", ":", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "x", ")", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", "if", "legible", "else", "lambda", "x", ":", "x", "\n", "\n", "return", "[", "diff", "(", "b", "-", "a", ")", "for", "a", ",", "b", "in", "zip", "(", "x1", ",", "x2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.__init__": [[12, 15], ["functions.MovingAverage.reset"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.reset"], ["def", "__init__", "(", "self", ",", "max_window_size", "=", "1000", ")", ":", "\n", "        ", "self", ".", "max_window_size", "=", "max_window_size", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.add": [[16, 27], ["functions.MovingAverage.window.append", "math.isfinite", "print", "len", "functions.MovingAverage.window.popleft"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print"], ["", "def", "add", "(", "self", ",", "elem", ")", ":", "\n", "        ", "\"\"\" Adds an element to the window, removing the earliest element if necessary. \"\"\"", "\n", "if", "not", "math", ".", "isfinite", "(", "elem", ")", ":", "\n", "            ", "print", "(", "'Warning: Moving average ignored a value of %f'", "%", "elem", ")", "\n", "return", "\n", "\n", "", "self", ".", "window", ".", "append", "(", "elem", ")", "\n", "self", ".", "sum", "+=", "elem", "\n", "\n", "if", "len", "(", "self", ".", "window", ")", ">", "self", ".", "max_window_size", ":", "\n", "            ", "self", ".", "sum", "-=", "self", ".", "window", ".", "popleft", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append": [[28, 31], ["functions.MovingAverage.add"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add"], ["", "", "def", "append", "(", "self", ",", "elem", ")", ":", "\n", "        ", "\"\"\" Same as add just more pythonic. \"\"\"", "\n", "self", ".", "add", "(", "elem", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.reset": [[32, 36], ["collections.deque"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\" Resets the MovingAverage to its initial state. \"\"\"", "\n", "self", ".", "window", "=", "deque", "(", ")", "\n", "self", ".", "sum", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg": [[37, 40], ["max", "len"], "methods", ["None"], ["", "def", "get_avg", "(", "self", ")", ":", "\n", "        ", "\"\"\" Returns the average of the elements in the window. \"\"\"", "\n", "return", "self", ".", "sum", "/", "max", "(", "len", "(", "self", ".", "window", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.__str__": [[41, 43], ["str", "functions.MovingAverage.get_avg"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "get_avg", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.__repr__": [[44, 46], ["repr", "functions.MovingAverage.get_avg"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "get_avg", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.__init__": [[51, 58], ["functions.ProgressBar._update_str"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar._update_str"], ["def", "__init__", "(", "self", ",", "length", ",", "max_val", ")", ":", "\n", "        ", "self", ".", "max_val", "=", "max_val", "\n", "self", ".", "length", "=", "length", "\n", "self", ".", "cur_val", "=", "0", "\n", "\n", "self", ".", "cur_num_bars", "=", "-", "1", "\n", "self", ".", "_update_str", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.set_val": [[59, 68], ["functions.ProgressBar._update_str"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar._update_str"], ["", "def", "set_val", "(", "self", ",", "new_val", ")", ":", "\n", "        ", "self", ".", "cur_val", "=", "new_val", "\n", "\n", "if", "self", ".", "cur_val", ">", "self", ".", "max_val", ":", "\n", "            ", "self", ".", "cur_val", "=", "self", ".", "max_val", "\n", "", "if", "self", ".", "cur_val", "<", "0", ":", "\n", "            ", "self", ".", "cur_val", "=", "0", "\n", "\n", "", "self", ".", "_update_str", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.is_finished": [[69, 71], ["None"], "methods", ["None"], ["", "def", "is_finished", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "cur_val", "==", "self", ".", "max_val", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar._update_str": [[72, 79], ["int"], "methods", ["None"], ["", "def", "_update_str", "(", "self", ")", ":", "\n", "        ", "num_bars", "=", "int", "(", "self", ".", "length", "*", "(", "self", ".", "cur_val", "/", "self", ".", "max_val", ")", ")", "\n", "\n", "if", "num_bars", "!=", "self", ".", "cur_num_bars", ":", "\n", "            ", "self", ".", "cur_num_bars", "=", "num_bars", "\n", "# self.string = '\u2588' * num_bars + '\u2591' * (self.length - num_bars)", "\n", "self", ".", "string", "=", "'1'", "*", "num_bars", "+", "'0'", "*", "(", "self", ".", "length", "-", "num_bars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.__repr__": [[80, 82], ["None"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.__str__": [[83, 85], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.__init__": [[103, 107], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model_name", ":", "str", ",", "epoch", ":", "int", ",", "iteration", ":", "int", ")", ":", "\n", "        ", "self", ".", "model_name", "=", "model_name", "\n", "self", ".", "epoch", "=", "epoch", "\n", "self", ".", "iteration", "=", "iteration", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.get_path": [[108, 111], ["os.path.join", "str", "str"], "methods", ["None"], ["", "def", "get_path", "(", "self", ",", "root", ":", "str", "=", "''", ")", ":", "\n", "        ", "file_name", "=", "self", ".", "model_name", "+", "'_'", "+", "str", "(", "self", ".", "epoch", ")", "+", "'_'", "+", "str", "(", "self", ".", "iteration", ")", "+", "'.pth'", "\n", "return", "os", ".", "path", ".", "join", "(", "root", ",", "file_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.from_str": [[112, 129], ["os.path.basename", "os.path.basename.endswith", "os.path.basename.split", "os.path.basename.endswith", "functions.SavePath", "int", "int"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["", "@", "staticmethod", "\n", "def", "from_str", "(", "path", ":", "str", ")", ":", "\n", "        ", "file_name", "=", "os", ".", "path", ".", "basename", "(", "path", ")", "\n", "\n", "if", "file_name", ".", "endswith", "(", "'.pth'", ")", ":", "\n", "            ", "file_name", "=", "file_name", "[", ":", "-", "4", "]", "\n", "\n", "", "params", "=", "file_name", ".", "split", "(", "'_'", ")", "\n", "\n", "if", "file_name", ".", "endswith", "(", "'interrupt'", ")", ":", "\n", "            ", "params", "=", "params", "[", ":", "-", "1", "]", "\n", "\n", "", "model_name", "=", "'_'", ".", "join", "(", "params", "[", ":", "-", "2", "]", ")", "\n", "epoch", "=", "params", "[", "-", "2", "]", "\n", "iteration", "=", "params", "[", "-", "1", "]", "\n", "\n", "return", "SavePath", "(", "model_name", ",", "int", "(", "epoch", ")", ",", "int", "(", "iteration", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.remove_interrupt": [[130, 134], ["pathlib.Path().glob", "p.unlink", "pathlib.Path"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "remove_interrupt", "(", "save_folder", ")", ":", "\n", "        ", "for", "p", "in", "Path", "(", "save_folder", ")", ".", "glob", "(", "'*_interrupt.pth'", ")", ":", "\n", "            ", "p", ".", "unlink", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.get_interrupt": [[135, 140], ["pathlib.Path().glob", "str", "pathlib.Path"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "get_interrupt", "(", "save_folder", ")", ":", "\n", "        ", "for", "p", "in", "Path", "(", "save_folder", ")", ".", "glob", "(", "'*_interrupt.pth'", ")", ":", "\n", "            ", "return", "str", "(", "p", ")", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.get_latest": [[141, 160], ["pathlib.Path().glob", "str", "pathlib.Path", "functions.SavePath.from_str"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.SavePath.from_str"], ["", "@", "staticmethod", "\n", "def", "get_latest", "(", "save_folder", ",", "config", ")", ":", "\n", "        ", "\"\"\" Note: config should be config.name. \"\"\"", "\n", "max_iter", "=", "-", "1", "\n", "max_name", "=", "None", "\n", "\n", "for", "p", "in", "Path", "(", "save_folder", ")", ".", "glob", "(", "config", "+", "'_*'", ")", ":", "\n", "            ", "path_name", "=", "str", "(", "p", ")", "\n", "\n", "try", ":", "\n", "                ", "save", "=", "SavePath", ".", "from_str", "(", "path_name", ")", "\n", "", "except", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "save", ".", "model_name", "==", "config", "and", "save", ".", "iteration", ">", "max_iter", ":", "\n", "                ", "max_iter", "=", "save", ".", "iteration", "\n", "max_name", "=", "path_name", "\n", "\n", "", "", "return", "max_name", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.init_console": [[87, 94], ["init"], "function", ["None"], ["", "", "def", "init_console", "(", ")", ":", "\n", "    ", "\"\"\"\n    Initialize the console to be able to use ANSI escape characters on Windows.\n    \"\"\"", "\n", "if", "os", ".", "name", "==", "'nt'", ":", "\n", "        ", "from", "colorama", "import", "init", "\n", "init", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Compose.__init__": [[49, 51], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transforms", ")", ":", "\n", "        ", "self", ".", "transforms", "=", "transforms", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Compose.__call__": [[52, 56], ["t"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "img", ",", "masks", ",", "boxes", ",", "labels", "=", "t", "(", "img", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "", "return", "img", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Lambda.__init__": [[61, 64], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lambd", ")", ":", "\n", "        ", "assert", "isinstance", "(", "lambd", ",", "types", ".", "LambdaType", ")", "\n", "self", ".", "lambd", "=", "lambd", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Lambda.__call__": [[65, 67], ["augmentations.Lambda.lambd"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "lambd", "(", "img", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.ConvertFromInts.__call__": [[70, 72], ["image.astype"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "image", ".", "astype", "(", "np", ".", "float32", ")", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.ToAbsoluteCoords.__call__": [[76, 84], ["None"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "height", ",", "width", ",", "channels", "=", "image", ".", "shape", "\n", "boxes", "[", ":", ",", "0", "]", "*=", "width", "\n", "boxes", "[", ":", ",", "2", "]", "*=", "width", "\n", "boxes", "[", ":", ",", "1", "]", "*=", "height", "\n", "boxes", "[", ":", ",", "3", "]", "*=", "height", "\n", "\n", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.ToPercentCoords.__call__": [[87, 95], ["None"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "height", ",", "width", ",", "channels", "=", "image", ".", "shape", "\n", "boxes", "[", ":", ",", "0", "]", "/=", "width", "\n", "boxes", "[", ":", ",", "2", "]", "/=", "width", "\n", "boxes", "[", ":", ",", "1", "]", "/=", "height", "\n", "boxes", "[", ":", ",", "3", "]", "/=", "height", "\n", "\n", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Pad.__init__": [[104, 109], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "width", ",", "height", ",", "mean", "=", "MEANS", ",", "pad_gt", "=", "True", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "height", "=", "height", "\n", "self", ".", "pad_gt", "=", "pad_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Pad.__call__": [[110, 127], ["numpy.zeros", "numpy.zeros"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "im_h", ",", "im_w", ",", "depth", "=", "image", ".", "shape", "\n", "\n", "expand_image", "=", "np", ".", "zeros", "(", "\n", "(", "self", ".", "height", ",", "self", ".", "width", ",", "depth", ")", ",", "\n", "dtype", "=", "image", ".", "dtype", ")", "\n", "expand_image", "[", ":", ",", ":", ",", ":", "]", "=", "self", ".", "mean", "\n", "expand_image", "[", ":", "im_h", ",", ":", "im_w", "]", "=", "image", "\n", "\n", "if", "self", ".", "pad_gt", ":", "\n", "            ", "expand_masks", "=", "np", ".", "zeros", "(", "\n", "(", "masks", ".", "shape", "[", "0", "]", ",", "self", ".", "height", ",", "self", ".", "width", ")", ",", "\n", "dtype", "=", "masks", ".", "dtype", ")", "\n", "expand_masks", "[", ":", ",", ":", "im_h", ",", ":", "im_w", "]", "=", "masks", "\n", "masks", "=", "expand_masks", "\n", "\n", "", "return", "expand_image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Resize.faster_rcnn_scale": [[138, 150], ["min", "max", "int", "int"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "faster_rcnn_scale", "(", "width", ",", "height", ",", "min_size", ",", "max_size", ")", ":", "\n", "        ", "min_scale", "=", "min_size", "/", "min", "(", "width", ",", "height", ")", "\n", "width", "*=", "min_scale", "\n", "height", "*=", "min_scale", "\n", "\n", "max_scale", "=", "max_size", "/", "max", "(", "width", ",", "height", ")", "\n", "if", "max_scale", "<", "1", ":", "# If a size is greater than max_size", "\n", "            ", "width", "*=", "max_scale", "\n", "height", "*=", "max_scale", "\n", "\n", "", "return", "int", "(", "width", ")", ",", "int", "(", "height", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Resize.__init__": [[151, 156], ["None"], "methods", ["None"], ["", "def", "__init__", "(", "self", ",", "resize_gt", "=", "True", ")", ":", "\n", "        ", "self", ".", "resize_gt", "=", "resize_gt", "\n", "self", ".", "min_size", "=", "cfg", ".", "min_size", "\n", "self", ".", "max_size", "=", "cfg", ".", "max_size", "\n", "self", ".", "preserve_aspect_ratio", "=", "cfg", ".", "preserve_aspect_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Resize.__call__": [[157, 183], ["cv2.resize", "augmentations.Resize.faster_rcnn_scale", "masks.transpose.transpose.transpose", "cv2.resize", "len", "numpy.expand_dims", "masks.transpose.transpose.transpose"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Resize.faster_rcnn_scale"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", "=", "None", ")", ":", "\n", "        ", "img_h", ",", "img_w", ",", "_", "=", "image", ".", "shape", "\n", "\n", "if", "self", ".", "preserve_aspect_ratio", ":", "\n", "            ", "width", ",", "height", "=", "Resize", ".", "faster_rcnn_scale", "(", "img_w", ",", "img_h", ",", "self", ".", "min_size", ",", "self", ".", "max_size", ")", "\n", "", "else", ":", "\n", "            ", "width", ",", "height", "=", "self", ".", "max_size", ",", "self", ".", "max_size", "\n", "\n", "", "image", "=", "cv2", ".", "resize", "(", "image", ",", "(", "width", ",", "height", ")", ")", "\n", "\n", "if", "self", ".", "resize_gt", ":", "\n", "# Act like each object is a color channel", "\n", "            ", "masks", "=", "masks", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "masks", "=", "cv2", ".", "resize", "(", "masks", ",", "(", "width", ",", "height", ")", ")", "\n", "\n", "# OpenCV resizes a (w,h,1) array to (s,s), so fix that", "\n", "if", "len", "(", "masks", ".", "shape", ")", "==", "2", ":", "\n", "                ", "masks", "=", "np", ".", "expand_dims", "(", "masks", ",", "0", ")", "\n", "", "else", ":", "\n", "                ", "masks", "=", "masks", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n", "# Scale bounding boxes (which are currently absolute coordinates)", "\n", "", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "*=", "(", "width", "/", "img_w", ")", "\n", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "*=", "(", "height", "/", "img_h", ")", "\n", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomSaturation.__init__": [[186, 191], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "lower", "=", "0.5", ",", "upper", "=", "1.5", ")", ":", "\n", "        ", "self", ".", "lower", "=", "lower", "\n", "self", ".", "upper", "=", "upper", "\n", "assert", "self", ".", "upper", ">=", "self", ".", "lower", ",", "\"contrast upper must be >= lower.\"", "\n", "assert", "self", ".", "lower", ">=", "0", ",", "\"contrast lower must be non-negative.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomSaturation.__call__": [[192, 197], ["numpy.random.randint", "numpy.random.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "image", "[", ":", ",", ":", ",", "1", "]", "*=", "random", ".", "uniform", "(", "self", ".", "lower", ",", "self", ".", "upper", ")", "\n", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomHue.__init__": [[200, 203], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "delta", "=", "18.0", ")", ":", "\n", "        ", "assert", "delta", ">=", "0.0", "and", "delta", "<=", "360.0", "\n", "self", ".", "delta", "=", "delta", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomHue.__call__": [[204, 210], ["numpy.random.randint", "numpy.random.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "image", "[", ":", ",", ":", ",", "0", "]", "+=", "random", ".", "uniform", "(", "-", "self", ".", "delta", ",", "self", ".", "delta", ")", "\n", "image", "[", ":", ",", ":", ",", "0", "]", "[", "image", "[", ":", ",", ":", ",", "0", "]", ">", "360.0", "]", "-=", "360.0", "\n", "image", "[", ":", ",", ":", ",", "0", "]", "[", "image", "[", ":", ",", ":", ",", "0", "]", "<", "0.0", "]", "+=", "360.0", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomLightingNoise.__init__": [[213, 217], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "perms", "=", "(", "(", "0", ",", "1", ",", "2", ")", ",", "(", "0", ",", "2", ",", "1", ")", ",", "\n", "(", "1", ",", "0", ",", "2", ")", ",", "(", "1", ",", "2", ",", "0", ")", ",", "\n", "(", "2", ",", "0", ",", "1", ")", ",", "(", "2", ",", "1", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomLightingNoise.__call__": [[218, 226], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "# Don't shuffle the channels please, why would you do this", "\n", "\n", "# if random.randint(2):", "\n", "#     swap = self.perms[random.randint(len(self.perms))]", "\n", "#     shuffle = SwapChannels(swap)  # shuffle channels", "\n", "#     image = shuffle(image)", "\n", "        ", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.ConvertColor.__init__": [[229, 232], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "current", "=", "'BGR'", ",", "transform", "=", "'HSV'", ")", ":", "\n", "        ", "self", ".", "transform", "=", "transform", "\n", "self", ".", "current", "=", "current", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.ConvertColor.__call__": [[233, 241], ["cv2.cvtColor", "cv2.cvtColor"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "current", "==", "'BGR'", "and", "self", ".", "transform", "==", "'HSV'", ":", "\n", "            ", "image", "=", "cv2", ".", "cvtColor", "(", "image", ",", "cv2", ".", "COLOR_BGR2HSV", ")", "\n", "", "elif", "self", ".", "current", "==", "'HSV'", "and", "self", ".", "transform", "==", "'BGR'", ":", "\n", "            ", "image", "=", "cv2", ".", "cvtColor", "(", "image", ",", "cv2", ".", "COLOR_HSV2BGR", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomContrast.__init__": [[244, 249], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "lower", "=", "0.5", ",", "upper", "=", "1.5", ")", ":", "\n", "        ", "self", ".", "lower", "=", "lower", "\n", "self", ".", "upper", "=", "upper", "\n", "assert", "self", ".", "upper", ">=", "self", ".", "lower", ",", "\"contrast upper must be >= lower.\"", "\n", "assert", "self", ".", "lower", ">=", "0", ",", "\"contrast lower must be non-negative.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomContrast.__call__": [[251, 256], ["numpy.random.randint", "numpy.random.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "lower", ",", "self", ".", "upper", ")", "\n", "image", "*=", "alpha", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomBrightness.__init__": [[259, 263], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "delta", "=", "32", ")", ":", "\n", "        ", "assert", "delta", ">=", "0.0", "\n", "assert", "delta", "<=", "255.0", "\n", "self", ".", "delta", "=", "delta", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomBrightness.__call__": [[264, 269], ["numpy.random.randint", "numpy.random.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "delta", "=", "random", ".", "uniform", "(", "-", "self", ".", "delta", ",", "self", ".", "delta", ")", "\n", "image", "+=", "delta", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.ToCV2Image.__call__": [[272, 274], ["tensor.cpu().numpy().astype().transpose", "tensor.cpu().numpy().astype", "tensor.cpu().numpy", "tensor.cpu"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "tensor", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.ToTensor.__call__": [[277, 279], ["torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "cvimage.astype"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "cvimage", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "cvimage", ".", "astype", "(", "np", ".", "float32", ")", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomSampleCrop.__init__": [[294, 305], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "sample_options", "=", "(", "\n", "# using entire original input image", "\n", "None", ",", "\n", "# sample a patch s.t. MIN jaccard w/ obj in .1,.3,.4,.7,.9", "\n", "(", "0.1", ",", "None", ")", ",", "\n", "(", "0.3", ",", "None", ")", ",", "\n", "(", "0.7", ",", "None", ")", ",", "\n", "(", "0.9", ",", "None", ")", ",", "\n", "# randomly sample a patch", "\n", "(", "None", ",", "None", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomSampleCrop.__call__": [[307, 408], ["numpy.random.choice", "range", "float", "float", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.array", "augmentations.jaccard_numpy", "numpy.zeros", "masks[].copy", "boxes[].copy", "numpy.maximum", "numpy.minimum", "numpy.sum", "int", "int", "int", "int", "jaccard_numpy.min", "jaccard_numpy.max", "mask.any", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.augment_bbox.jaccard_numpy", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "height", ",", "width", ",", "_", "=", "image", ".", "shape", "\n", "while", "True", ":", "\n", "# randomly choose a mode", "\n", "            ", "mode", "=", "random", ".", "choice", "(", "self", ".", "sample_options", ")", "\n", "if", "mode", "is", "None", ":", "\n", "                ", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n", "", "min_iou", ",", "max_iou", "=", "mode", "\n", "if", "min_iou", "is", "None", ":", "\n", "                ", "min_iou", "=", "float", "(", "'-inf'", ")", "\n", "", "if", "max_iou", "is", "None", ":", "\n", "                ", "max_iou", "=", "float", "(", "'inf'", ")", "\n", "\n", "# max trails (50)", "\n", "", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "                ", "current_image", "=", "image", "\n", "\n", "w", "=", "random", ".", "uniform", "(", "0.3", "*", "width", ",", "width", ")", "\n", "h", "=", "random", ".", "uniform", "(", "0.3", "*", "height", ",", "height", ")", "\n", "\n", "# aspect ratio constraint b/t .5 & 2", "\n", "if", "h", "/", "w", "<", "0.5", "or", "h", "/", "w", ">", "2", ":", "\n", "                    ", "continue", "\n", "\n", "", "left", "=", "random", ".", "uniform", "(", "width", "-", "w", ")", "\n", "top", "=", "random", ".", "uniform", "(", "height", "-", "h", ")", "\n", "\n", "# convert to integer rect x1,y1,x2,y2", "\n", "rect", "=", "np", ".", "array", "(", "[", "int", "(", "left", ")", ",", "int", "(", "top", ")", ",", "int", "(", "left", "+", "w", ")", ",", "int", "(", "top", "+", "h", ")", "]", ")", "\n", "\n", "# calculate IoU (jaccard overlap) b/t the cropped and gt boxes", "\n", "overlap", "=", "jaccard_numpy", "(", "boxes", ",", "rect", ")", "\n", "\n", "# This piece of code is bugged and does nothing:", "\n", "# https://github.com/amdegroot/ssd.pytorch/issues/68", "\n", "#", "\n", "# However, when I fixed it with overlap.max() < min_iou,", "\n", "# it cut the mAP in half (after 8k iterations). So it stays.", "\n", "#", "\n", "# is min and max overlap constraint satisfied? if not try again", "\n", "if", "overlap", ".", "min", "(", ")", "<", "min_iou", "and", "max_iou", "<", "overlap", ".", "max", "(", ")", ":", "\n", "                    ", "continue", "\n", "\n", "# cut the crop from the image", "\n", "", "current_image", "=", "current_image", "[", "rect", "[", "1", "]", ":", "rect", "[", "3", "]", ",", "rect", "[", "0", "]", ":", "rect", "[", "2", "]", ",", "\n", ":", "]", "\n", "\n", "# keep overlap with gt box IF center in sampled patch", "\n", "centers", "=", "(", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", ")", "/", "2.0", "\n", "\n", "# mask in all gt boxes that above and to the left of centers", "\n", "m1", "=", "(", "rect", "[", "0", "]", "<", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "1", "]", "<", "centers", "[", ":", ",", "1", "]", ")", "\n", "\n", "# mask in all gt boxes that under and to the right of centers", "\n", "m2", "=", "(", "rect", "[", "2", "]", ">", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "3", "]", ">", "centers", "[", ":", ",", "1", "]", ")", "\n", "\n", "# mask in that both m1 and m2 are true", "\n", "mask", "=", "m1", "*", "m2", "\n", "\n", "# [0 ... 0 for num_gt and then 1 ... 1 for num_crowds]", "\n", "num_crowds", "=", "labels", "[", "'num_crowds'", "]", "\n", "crowd_mask", "=", "np", ".", "zeros", "(", "mask", ".", "shape", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "if", "num_crowds", ">", "0", ":", "\n", "                    ", "crowd_mask", "[", "-", "num_crowds", ":", "]", "=", "1", "\n", "\n", "# have any valid boxes? try again if not", "\n", "# Also make sure you have at least one regular gt", "\n", "", "if", "not", "mask", ".", "any", "(", ")", "or", "np", ".", "sum", "(", "1", "-", "crowd_mask", "[", "mask", "]", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "\n", "# take only the matching gt masks", "\n", "", "current_masks", "=", "masks", "[", "mask", ",", ":", ",", ":", "]", ".", "copy", "(", ")", "\n", "\n", "# take only matching gt boxes", "\n", "current_boxes", "=", "boxes", "[", "mask", ",", ":", "]", ".", "copy", "(", ")", "\n", "\n", "# take only matching gt labels", "\n", "labels", "[", "'labels'", "]", "=", "labels", "[", "'labels'", "]", "[", "mask", "]", "\n", "current_labels", "=", "labels", "\n", "\n", "# We now might have fewer crowd annotations", "\n", "if", "num_crowds", ">", "0", ":", "\n", "                    ", "labels", "[", "'num_crowds'", "]", "=", "np", ".", "sum", "(", "crowd_mask", "[", "mask", "]", ")", "\n", "\n", "# should we use the box left and top corner or the crop's", "\n", "", "current_boxes", "[", ":", ",", ":", "2", "]", "=", "np", ".", "maximum", "(", "current_boxes", "[", ":", ",", ":", "2", "]", ",", "\n", "rect", "[", ":", "2", "]", ")", "\n", "# adjust to crop (by substracting crop's left,top)", "\n", "current_boxes", "[", ":", ",", ":", "2", "]", "-=", "rect", "[", ":", "2", "]", "\n", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "=", "np", ".", "minimum", "(", "current_boxes", "[", ":", ",", "2", ":", "]", ",", "\n", "rect", "[", "2", ":", "]", ")", "\n", "# adjust to crop (by substracting crop's left,top)", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "-=", "rect", "[", ":", "2", "]", "\n", "\n", "# crop the current masks to the same dimensions as the image", "\n", "current_masks", "=", "current_masks", "[", ":", ",", "rect", "[", "1", "]", ":", "rect", "[", "3", "]", ",", "rect", "[", "0", "]", ":", "rect", "[", "2", "]", "]", "\n", "\n", "return", "current_image", ",", "current_masks", ",", "current_boxes", ",", "current_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Expand.__init__": [[411, 413], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mean", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.Expand.__call__": [[414, 443], ["numpy.random.randint", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.zeros", "numpy.zeros", "boxes.copy.copy.copy", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n", "", "height", ",", "width", ",", "depth", "=", "image", ".", "shape", "\n", "ratio", "=", "random", ".", "uniform", "(", "1", ",", "4", ")", "\n", "left", "=", "random", ".", "uniform", "(", "0", ",", "width", "*", "ratio", "-", "width", ")", "\n", "top", "=", "random", ".", "uniform", "(", "0", ",", "height", "*", "ratio", "-", "height", ")", "\n", "\n", "expand_image", "=", "np", ".", "zeros", "(", "\n", "(", "int", "(", "height", "*", "ratio", ")", ",", "int", "(", "width", "*", "ratio", ")", ",", "depth", ")", ",", "\n", "dtype", "=", "image", ".", "dtype", ")", "\n", "expand_image", "[", ":", ",", ":", ",", ":", "]", "=", "self", ".", "mean", "\n", "expand_image", "[", "int", "(", "top", ")", ":", "int", "(", "top", "+", "height", ")", ",", "\n", "int", "(", "left", ")", ":", "int", "(", "left", "+", "width", ")", "]", "=", "image", "\n", "image", "=", "expand_image", "\n", "\n", "expand_masks", "=", "np", ".", "zeros", "(", "\n", "(", "masks", ".", "shape", "[", "0", "]", ",", "int", "(", "height", "*", "ratio", ")", ",", "int", "(", "width", "*", "ratio", ")", ")", ",", "\n", "dtype", "=", "masks", ".", "dtype", ")", "\n", "expand_masks", "[", ":", ",", "int", "(", "top", ")", ":", "int", "(", "top", "+", "height", ")", ",", "\n", "int", "(", "left", ")", ":", "int", "(", "left", "+", "width", ")", "]", "=", "masks", "\n", "masks", "=", "expand_masks", "\n", "\n", "boxes", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", ":", "2", "]", "+=", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ")", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ")", "\n", "\n", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomMirror.__call__": [[446, 454], ["numpy.random.randint", "boxes.copy.copy.copy"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "_", ",", "width", ",", "_", "=", "image", ".", "shape", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "image", "=", "image", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "masks", "=", "masks", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "boxes", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", "=", "width", "-", "boxes", "[", ":", ",", "2", ":", ":", "-", "2", "]", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomFlip.__call__": [[457, 465], ["numpy.random.randint", "boxes.copy.copy.copy"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "height", ",", "_", ",", "_", "=", "image", ".", "shape", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "image", "=", "image", "[", ":", ":", "-", "1", ",", ":", "]", "\n", "masks", "=", "masks", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "boxes", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", "1", ":", ":", "2", "]", "=", "height", "-", "boxes", "[", ":", ",", "3", ":", ":", "-", "2", "]", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.RandomRot90.__call__": [[468, 478], ["numpy.random.randint", "numpy.rot90", "numpy.array", "numpy.array.copy", "range", "numpy.array", "numpy.rot90"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "old_height", ",", "old_width", ",", "_", "=", "image", ".", "shape", "\n", "k", "=", "random", ".", "randint", "(", "4", ")", "\n", "image", "=", "np", ".", "rot90", "(", "image", ",", "k", ")", "\n", "masks", "=", "np", ".", "array", "(", "[", "np", ".", "rot90", "(", "mask", ",", "k", ")", "for", "mask", "in", "masks", "]", ")", "\n", "boxes", "=", "boxes", ".", "copy", "(", ")", "\n", "for", "_", "in", "range", "(", "k", ")", ":", "\n", "            ", "boxes", "=", "np", ".", "array", "(", "[", "[", "box", "[", "1", "]", ",", "old_width", "-", "1", "-", "box", "[", "2", "]", ",", "box", "[", "3", "]", ",", "old_width", "-", "1", "-", "box", "[", "0", "]", "]", "for", "box", "in", "boxes", "]", ")", "\n", "old_width", ",", "old_height", "=", "old_height", ",", "old_width", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.SwapChannels.__init__": [[488, 490], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "swaps", ")", ":", "\n", "        ", "self", ".", "swaps", "=", "swaps", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.SwapChannels.__call__": [[491, 504], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image (Tensor): image tensor to be transformed\n        Return:\n            a tensor with channels swapped according to swap\n        \"\"\"", "\n", "# if torch.is_tensor(image):", "\n", "#     image = image.data.cpu().numpy()", "\n", "# else:", "\n", "#     image = np.array(image)", "\n", "image", "=", "image", "[", ":", ",", ":", ",", "self", ".", "swaps", "]", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.PhotometricDistort.__init__": [[507, 518], ["augmentations.RandomBrightness", "augmentations.RandomLightingNoise", "augmentations.RandomContrast", "augmentations.ConvertColor", "augmentations.RandomSaturation", "augmentations.RandomHue", "augmentations.ConvertColor", "augmentations.RandomContrast"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "pd", "=", "[", "\n", "RandomContrast", "(", ")", ",", "\n", "ConvertColor", "(", "transform", "=", "'HSV'", ")", ",", "\n", "RandomSaturation", "(", ")", ",", "\n", "RandomHue", "(", ")", ",", "\n", "ConvertColor", "(", "current", "=", "'HSV'", ",", "transform", "=", "'BGR'", ")", ",", "\n", "RandomContrast", "(", ")", "\n", "]", "\n", "self", ".", "rand_brightness", "=", "RandomBrightness", "(", ")", "\n", "self", ".", "rand_light_noise", "=", "RandomLightingNoise", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.PhotometricDistort.__call__": [[519, 528], ["image.copy", "augmentations.PhotometricDistort.rand_brightness", "numpy.random.randint", "Compose.", "augmentations.PhotometricDistort.rand_light_noise", "augmentations.Compose", "augmentations.Compose"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "im", "=", "image", ".", "copy", "(", ")", "\n", "im", ",", "masks", ",", "boxes", ",", "labels", "=", "self", ".", "rand_brightness", "(", "im", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "distort", "=", "Compose", "(", "self", ".", "pd", "[", ":", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "distort", "=", "Compose", "(", "self", ".", "pd", "[", "1", ":", "]", ")", "\n", "", "im", ",", "masks", ",", "boxes", ",", "labels", "=", "distort", "(", "im", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "return", "self", ".", "rand_light_noise", "(", "im", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.PrepareMasks.__init__": [[536, 539], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mask_size", ",", "use_gt_bboxes", ")", ":", "\n", "        ", "self", ".", "mask_size", "=", "mask_size", "\n", "self", ".", "use_gt_bboxes", "=", "use_gt_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.PrepareMasks.__call__": [[540, 567], ["numpy.zeros", "range", "len", "cv2.resize", "cv2.resize.reshape", "int", "int", "int", "int"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "not", "self", ".", "use_gt_bboxes", ":", "\n", "            ", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n", "", "height", ",", "width", ",", "_", "=", "image", ".", "shape", "\n", "\n", "new_masks", "=", "np", ".", "zeros", "(", "(", "masks", ".", "shape", "[", "0", "]", ",", "self", ".", "mask_size", "**", "2", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "masks", ")", ")", ":", "\n", "            ", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "boxes", "[", "i", ",", ":", "]", "\n", "x1", "*=", "width", "\n", "x2", "*=", "width", "\n", "y1", "*=", "height", "\n", "y2", "*=", "height", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "(", "int", "(", "x1", ")", ",", "int", "(", "y1", ")", ",", "int", "(", "x2", ")", ",", "int", "(", "y2", ")", ")", "\n", "\n", "# +1 So that if y1=10.6 and y2=10.9 we still have a bounding box", "\n", "cropped_mask", "=", "masks", "[", "i", ",", "y1", ":", "(", "y2", "+", "1", ")", ",", "x1", ":", "(", "x2", "+", "1", ")", "]", "\n", "scaled_mask", "=", "cv2", ".", "resize", "(", "cropped_mask", ",", "(", "self", ".", "mask_size", ",", "self", ".", "mask_size", ")", ")", "\n", "\n", "new_masks", "[", "i", ",", ":", "]", "=", "scaled_mask", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "\n", "# Binarize", "\n", "", "new_masks", "[", "new_masks", ">", "0.5", "]", "=", "1", "\n", "new_masks", "[", "new_masks", "<=", "0.5", "]", "=", "0", "\n", "\n", "return", "image", ",", "new_masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.BackboneTransform.__init__": [[576, 584], ["numpy.array", "numpy.array", "enumerate"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transform", ",", "mean", ",", "std", ",", "in_channel_order", ")", ":", "\n", "        ", "self", ".", "mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "transform", "=", "transform", "\n", "\n", "# Here I use \"Algorithms and Coding\" to convert string permutations to numbers", "\n", "self", ".", "channel_map", "=", "{", "c", ":", "idx", "for", "idx", ",", "c", "in", "enumerate", "(", "in_channel_order", ")", "}", "\n", "self", ".", "channel_permutation", "=", "[", "self", ".", "channel_map", "[", "c", "]", "for", "c", "in", "transform", ".", "channel_order", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.BackboneTransform.__call__": [[585, 599], ["img.astype.astype.astype", "img.astype.astype.astype"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "\n", "        ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "if", "self", ".", "transform", ".", "normalize", ":", "\n", "            ", "img", "=", "(", "img", "-", "self", ".", "mean", ")", "/", "self", ".", "std", "\n", "", "elif", "self", ".", "transform", ".", "subtract_means", ":", "\n", "            ", "img", "=", "(", "img", "-", "self", ".", "mean", ")", "\n", "", "elif", "self", ".", "transform", ".", "to_float", ":", "\n", "            ", "img", "=", "img", "/", "255", "\n", "\n", "", "img", "=", "img", "[", ":", ",", ":", ",", "self", ".", "channel_permutation", "]", "\n", "\n", "return", "img", ".", "astype", "(", "np", ".", "float32", ")", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.BaseTransform.__init__": [[606, 612], ["augmentations.Compose", "augmentations.ConvertFromInts", "augmentations.Resize", "augmentations.Pad", "augmentations.BackboneTransform"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mean", "=", "MEANS", ",", "std", "=", "STD", ")", ":", "\n", "        ", "self", ".", "augment", "=", "Compose", "(", "[", "\n", "ConvertFromInts", "(", ")", ",", "\n", "Resize", "(", "resize_gt", "=", "False", ")", ",", "\n", "Pad", "(", "cfg", ".", "max_size", ",", "cfg", ".", "max_size", ",", "mean", ",", "pad_gt", "=", "False", ")", ",", "\n", "BackboneTransform", "(", "cfg", ".", "backbone", ".", "transform", ",", "mean", ",", "std", ",", "'BGR'", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.BaseTransform.__call__": [[614, 616], ["augmentations.BaseTransform.augment"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "augment", "(", "img", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.FastBaseTransform.__init__": [[626, 632], ["super().__init__", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "mean", "=", "torch", ".", "Tensor", "(", "MEANS", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "[", "None", ",", ":", ",", "None", ",", "None", "]", "\n", "self", ".", "std", "=", "torch", ".", "Tensor", "(", "STD", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "[", "None", ",", ":", ",", "None", ",", "None", "]", "\n", "self", ".", "transform", "=", "cfg", ".", "backbone", ".", "transform", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.FastBaseTransform.forward": [[633, 658], ["augmentations.FastBaseTransform.mean.to", "augmentations.FastBaseTransform.std.to", "img[].contiguous.permute().contiguous", "torch.interpolate", "torch.interpolate", "img[].contiguous", "img[].contiguous.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img", ")", ":", "\n", "        ", "self", ".", "mean", "=", "self", ".", "mean", ".", "to", "(", "img", ".", "device", ")", "\n", "self", ".", "std", "=", "self", ".", "std", ".", "to", "(", "img", ".", "device", ")", "\n", "\n", "# img assumed to be a pytorch BGR image with channel order [n, h, w, c]", "\n", "if", "cfg", ".", "preserve_aspect_ratio", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "img", "=", "img", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "img", "=", "F", ".", "interpolate", "(", "img", ",", "(", "cfg", ".", "max_size", ",", "cfg", ".", "max_size", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "\n", "if", "self", ".", "transform", ".", "normalize", ":", "\n", "            ", "img", "=", "(", "img", "-", "self", ".", "mean", ")", "/", "self", ".", "std", "\n", "", "elif", "self", ".", "transform", ".", "subtract_means", ":", "\n", "            ", "img", "=", "(", "img", "-", "self", ".", "mean", ")", "\n", "", "elif", "self", ".", "transform", ".", "to_float", ":", "\n", "            ", "img", "=", "img", "/", "255", "\n", "\n", "", "if", "self", ".", "transform", ".", "channel_order", "!=", "'RGB'", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "img", "=", "img", "[", ":", ",", "(", "2", ",", "1", ",", "0", ")", ",", ":", ",", ":", "]", ".", "contiguous", "(", ")", "\n", "\n", "# Return value is in channel order [n, c, h, w] and RGB", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.SSDAugmentation.__init__": [[669, 684], ["augmentations.Compose", "augmentations.ConvertFromInts", "augmentations.ToAbsoluteCoords", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.Resize", "augmentations.Pad", "augmentations.ToPercentCoords", "augmentations.PrepareMasks", "augmentations.BackboneTransform", "augmentations.PhotometricDistort", "augmentations.Expand", "augmentations.RandomSampleCrop", "augmentations.RandomMirror", "augmentations.RandomFlip", "augmentations.RandomRot90"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.enable_if"], ["def", "__init__", "(", "self", ",", "mean", "=", "MEANS", ",", "std", "=", "STD", ")", ":", "\n", "        ", "self", ".", "augment", "=", "Compose", "(", "[", "\n", "ConvertFromInts", "(", ")", ",", "\n", "ToAbsoluteCoords", "(", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_photometric_distort", ",", "PhotometricDistort", "(", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_expand", ",", "Expand", "(", "mean", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_random_sample_crop", ",", "RandomSampleCrop", "(", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_random_mirror", ",", "RandomMirror", "(", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_random_flip", ",", "RandomFlip", "(", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_random_flip", ",", "RandomRot90", "(", ")", ")", ",", "\n", "Resize", "(", ")", ",", "\n", "Pad", "(", "cfg", ".", "max_size", ",", "cfg", ".", "max_size", ",", "mean", ")", ",", "\n", "ToPercentCoords", "(", ")", ",", "\n", "PrepareMasks", "(", "cfg", ".", "mask_size", ",", "cfg", ".", "use_gt_bboxes", ")", ",", "\n", "BackboneTransform", "(", "cfg", ".", "backbone", ".", "transform", ",", "mean", ",", "std", ",", "'BGR'", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.SSDAugmentation.__call__": [[686, 688], ["augmentations.SSDAugmentation.augment"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "return", "self", ".", "augment", "(", "img", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.intersect": [[11, 16], ["numpy.minimum", "numpy.maximum", "numpy.clip"], "function", ["None"], ["def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "max_xy", "=", "np", ".", "minimum", "(", "box_a", "[", ":", ",", "2", ":", "]", ",", "box_b", "[", "2", ":", "]", ")", "\n", "min_xy", "=", "np", ".", "maximum", "(", "box_a", "[", ":", ",", ":", "2", "]", ",", "box_b", "[", ":", "2", "]", ")", "\n", "inter", "=", "np", ".", "clip", "(", "(", "max_xy", "-", "min_xy", ")", ",", "a_min", "=", "0", ",", "a_max", "=", "np", ".", "inf", ")", "\n", "return", "inter", "[", ":", ",", "0", "]", "*", "inter", "[", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.jaccard_numpy": [[18, 36], ["augmentations.intersect"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.intersect"], ["", "def", "jaccard_numpy", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: Multiple bounding boxes, Shape: [num_boxes,4]\n        box_b: Single bounding box, Shape: [4]\n    Return:\n        jaccard overlap: Shape: [box_a.shape[0], box_a.shape[1]]\n    \"\"\"", "\n", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", "1", "]", ")", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", "2", "]", "-", "box_b", "[", "0", "]", ")", "*", "\n", "(", "box_b", "[", "3", "]", "-", "box_b", "[", "1", "]", ")", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "return", "inter", "/", "union", "# [A,B]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.do_nothing": [[659, 661], ["None"], "function", ["None"], ["", "", "def", "do_nothing", "(", "img", "=", "None", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "    ", "return", "img", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.augmentations.enable_if": [[663, 665], ["datasets.cfg.augment_photometric_distort", "datasets.cfg.augment_expand", "datasets.cfg.augment_random_sample_crop", "datasets.cfg.augment_random_mirror", "datasets.cfg.augment_random_flip", "datasets.cfg.augment_random_flip"], "function", ["None"], ["", "def", "enable_if", "(", "condition", ",", "obj", ")", ":", "\n", "    ", "return", "obj", "if", "condition", "else", "do_nothing", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.__init__": [[38, 115], ["custom.CustomDataset.load_annotations", "mmcv.is_list_of", "transforms.ImageTransform", "transforms.BboxTransform", "transforms.MaskTransform", "transforms.Numpy2Tensor", "custom.CustomDataset.load_proposals", "custom.CustomDataset._filter_imgs", "isinstance", "custom.CustomDataset._set_group_flag", "extra_aug.ExtraAugmentation"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.load_annotations", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.load_proposals", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset._filter_imgs", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset._set_group_flag"], ["def", "__init__", "(", "self", ",", "\n", "ann_file", ",", "\n", "img_prefix", ",", "\n", "img_scale", ",", "\n", "img_norm_cfg", ",", "\n", "size_divisor", "=", "None", ",", "\n", "proposal_file", "=", "None", ",", "\n", "num_max_proposals", "=", "1000", ",", "\n", "flip_ratio", "=", "0", ",", "\n", "with_mask", "=", "True", ",", "\n", "with_crowd", "=", "True", ",", "\n", "with_label", "=", "True", ",", "\n", "with_track", "=", "False", ",", "\n", "extra_aug", "=", "None", ",", "\n", "resize_keep_ratio", "=", "True", ",", "\n", "test_mode", "=", "False", ")", ":", "\n", "# prefix of images path", "\n", "        ", "self", ".", "img_prefix", "=", "img_prefix", "\n", "\n", "# load annotations (and proposals)", "\n", "self", ".", "img_infos", "=", "self", ".", "load_annotations", "(", "ann_file", ")", "\n", "if", "proposal_file", "is", "not", "None", ":", "\n", "            ", "self", ".", "proposals", "=", "self", ".", "load_proposals", "(", "proposal_file", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "proposals", "=", "None", "\n", "# filter images with no annotation during training", "\n", "", "if", "not", "test_mode", ":", "\n", "            ", "valid_inds", "=", "self", ".", "_filter_imgs", "(", ")", "\n", "self", ".", "img_infos", "=", "[", "self", ".", "img_infos", "[", "i", "]", "for", "i", "in", "valid_inds", "]", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "                ", "self", ".", "proposals", "=", "[", "self", ".", "proposals", "[", "i", "]", "for", "i", "in", "valid_inds", "]", "\n", "\n", "# (long_edge, short_edge) or [(long1, short1), (long2, short2), ...]", "\n", "", "", "self", ".", "img_scales", "=", "img_scale", "if", "isinstance", "(", "img_scale", ",", "\n", "list", ")", "else", "[", "img_scale", "]", "\n", "assert", "mmcv", ".", "is_list_of", "(", "self", ".", "img_scales", ",", "tuple", ")", "\n", "# normalization configs", "\n", "self", ".", "img_norm_cfg", "=", "img_norm_cfg", "\n", "\n", "# max proposals per image", "\n", "self", ".", "num_max_proposals", "=", "num_max_proposals", "\n", "# flip ratio", "\n", "self", ".", "flip_ratio", "=", "flip_ratio", "\n", "assert", "flip_ratio", ">=", "0", "and", "flip_ratio", "<=", "1", "\n", "# padding border to ensure the image size can be divided by", "\n", "# size_divisor (used for FPN)", "\n", "self", ".", "size_divisor", "=", "size_divisor", "\n", "\n", "# with mask or not (reserved field, takes no effect)", "\n", "self", ".", "with_mask", "=", "with_mask", "\n", "# some datasets provide bbox annotations as ignore/crowd/difficult,", "\n", "# if `with_crowd` is True, then these info is returned.", "\n", "self", ".", "with_crowd", "=", "with_crowd", "\n", "# with label is False for RPN", "\n", "self", ".", "with_label", "=", "with_label", "\n", "self", ".", "with_track", "=", "with_track", "\n", "# in test mode or not", "\n", "self", ".", "test_mode", "=", "test_mode", "\n", "\n", "# set group flag for the sampler", "\n", "if", "not", "self", ".", "test_mode", ":", "\n", "            ", "self", ".", "_set_group_flag", "(", ")", "\n", "# transforms", "\n", "", "self", ".", "img_transform", "=", "ImageTransform", "(", "\n", "size_divisor", "=", "self", ".", "size_divisor", ",", "**", "self", ".", "img_norm_cfg", ")", "\n", "self", ".", "bbox_transform", "=", "BboxTransform", "(", ")", "\n", "self", ".", "mask_transform", "=", "MaskTransform", "(", ")", "\n", "self", ".", "numpy2tensor", "=", "Numpy2Tensor", "(", ")", "\n", "\n", "# if use extra augmentation", "\n", "if", "extra_aug", "is", "not", "None", ":", "\n", "            ", "self", ".", "extra_aug", "=", "ExtraAugmentation", "(", "**", "extra_aug", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "extra_aug", "=", "None", "\n", "\n", "# image rescale if keep ratio", "\n", "", "self", ".", "resize_keep_ratio", "=", "resize_keep_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.__len__": [[116, 118], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "img_infos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.load_annotations": [[119, 121], ["mmcv.load"], "methods", ["None"], ["", "def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "return", "mmcv", ".", "load", "(", "ann_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.load_proposals": [[122, 124], ["mmcv.load"], "methods", ["None"], ["", "def", "load_proposals", "(", "self", ",", "proposal_file", ")", ":", "\n", "        ", "return", "mmcv", ".", "load", "(", "proposal_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.get_ann_info": [[125, 127], ["None"], "methods", ["None"], ["", "def", "get_ann_info", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "img_infos", "[", "idx", "]", "[", "'ann'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset._filter_imgs": [[128, 135], ["enumerate", "min", "valid_inds.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "_filter_imgs", "(", "self", ",", "min_size", "=", "32", ")", ":", "\n", "        ", "\"\"\"Filter images too small.\"\"\"", "\n", "valid_inds", "=", "[", "]", "\n", "for", "i", ",", "img_info", "in", "enumerate", "(", "self", ".", "img_infos", ")", ":", "\n", "            ", "if", "min", "(", "img_info", "[", "'width'", "]", ",", "img_info", "[", "'height'", "]", ")", ">=", "min_size", ":", "\n", "                ", "valid_inds", ".", "append", "(", "i", ")", "\n", "", "", "return", "valid_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset._set_group_flag": [[136, 147], ["numpy.zeros", "range", "len", "len"], "methods", ["None"], ["", "def", "_set_group_flag", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set flag according to image aspect ratio.\n\n        Images with aspect ratio greater than 1 will be set as group 1,\n        otherwise group 0.\n        \"\"\"", "\n", "self", ".", "flag", "=", "np", ".", "zeros", "(", "len", "(", "self", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "img_info", "=", "self", ".", "img_infos", "[", "i", "]", "\n", "if", "img_info", "[", "'width'", "]", "/", "img_info", "[", "'height'", "]", ">", "1", ":", "\n", "                ", "self", ".", "flag", "[", "i", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset._rand_another": [[148, 151], ["numpy.random.choice", "numpy.where"], "methods", ["None"], ["", "", "", "def", "_rand_another", "(", "self", ",", "idx", ")", ":", "\n", "        ", "pool", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "self", ".", "flag", "[", "idx", "]", ")", "[", "0", "]", "\n", "return", "np", ".", "random", ".", "choice", "(", "pool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.__getitem__": [[152, 161], ["custom.CustomDataset.prepare_test_img", "custom.CustomDataset.prepare_train_img", "custom.CustomDataset._rand_another"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.prepare_test_img", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.prepare_train_img", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset._rand_another"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "test_mode", ":", "\n", "            ", "return", "self", ".", "prepare_test_img", "(", "idx", ")", "\n", "", "while", "True", ":", "\n", "            ", "data", "=", "self", ".", "prepare_train_img", "(", "idx", ")", "\n", "if", "data", "is", "None", ":", "\n", "                ", "idx", "=", "self", ".", "_rand_another", "(", "idx", ")", "\n", "continue", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.prepare_train_img": [[162, 240], ["mmcv.imread", "custom.CustomDataset.get_ann_info", "utils.random_scale", "custom.CustomDataset.img_transform", "img.copy.copy.copy", "custom.CustomDataset.bbox_transform", "dict", "dict", "os.join", "len", "custom.CustomDataset.extra_aug", "custom.CustomDataset.bbox_transform", "custom.CustomDataset.bbox_transform", "custom.CustomDataset.mask_transform", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "len", "AssertionError", "numpy.random.rand", "numpy.hstack", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "utils.to_tensor", "utils.to_tensor", "utils.to_tensor", "utils.to_tensor", "utils.to_tensor"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.get_ann_info", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.random_scale", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor"], ["", "", "def", "prepare_train_img", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img_info", "=", "self", ".", "img_infos", "[", "idx", "]", "\n", "# load image", "\n", "img", "=", "mmcv", ".", "imread", "(", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "img_info", "[", "'filename'", "]", ")", ")", "\n", "# load proposals if necessary", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "proposals", "=", "self", ".", "proposals", "[", "idx", "]", "[", ":", "self", ".", "num_max_proposals", "]", "\n", "# TODO: Handle empty proposals properly. Currently images with", "\n", "# no proposals are just ignored, but they can be used for", "\n", "# training in concept.", "\n", "if", "len", "(", "proposals", ")", "==", "0", ":", "\n", "                ", "return", "None", "\n", "", "if", "not", "(", "proposals", ".", "shape", "[", "1", "]", "==", "4", "or", "proposals", ".", "shape", "[", "1", "]", "==", "5", ")", ":", "\n", "                ", "raise", "AssertionError", "(", "\n", "'proposals should have shapes (n, 4) or (n, 5), '", "\n", "'but found {}'", ".", "format", "(", "proposals", ".", "shape", ")", ")", "\n", "", "if", "proposals", ".", "shape", "[", "1", "]", "==", "5", ":", "\n", "                ", "scores", "=", "proposals", "[", ":", ",", "4", ",", "None", "]", "\n", "proposals", "=", "proposals", "[", ":", ",", ":", "4", "]", "\n", "", "else", ":", "\n", "                ", "scores", "=", "None", "\n", "\n", "", "", "ann", "=", "self", ".", "get_ann_info", "(", "idx", ")", "\n", "gt_bboxes", "=", "ann", "[", "'bboxes'", "]", "\n", "gt_labels", "=", "ann", "[", "'labels'", "]", "\n", "if", "self", ".", "with_crowd", ":", "\n", "            ", "gt_bboxes_ignore", "=", "ann", "[", "'bboxes_ignore'", "]", "\n", "\n", "# skip the image if there is no valid gt bbox", "\n", "", "if", "len", "(", "gt_bboxes", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "# extra augmentation", "\n", "", "if", "self", ".", "extra_aug", "is", "not", "None", ":", "\n", "            ", "img", ",", "gt_bboxes", ",", "gt_labels", "=", "self", ".", "extra_aug", "(", "img", ",", "gt_bboxes", ",", "\n", "gt_labels", ")", "\n", "\n", "# apply transforms", "\n", "", "flip", "=", "True", "if", "np", ".", "random", ".", "rand", "(", ")", "<", "self", ".", "flip_ratio", "else", "False", "\n", "img_scale", "=", "random_scale", "(", "self", ".", "img_scales", ")", "# sample a scale", "\n", "img", ",", "img_shape", ",", "pad_shape", ",", "scale_factor", "=", "self", ".", "img_transform", "(", "\n", "img", ",", "img_scale", ",", "flip", ",", "keep_ratio", "=", "self", ".", "resize_keep_ratio", ")", "\n", "img", "=", "img", ".", "copy", "(", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "proposals", "=", "self", ".", "bbox_transform", "(", "proposals", ",", "img_shape", ",", "scale_factor", ",", "\n", "flip", ")", "\n", "proposals", "=", "np", ".", "hstack", "(", "\n", "[", "proposals", ",", "scores", "]", ")", "if", "scores", "is", "not", "None", "else", "proposals", "\n", "", "gt_bboxes", "=", "self", ".", "bbox_transform", "(", "gt_bboxes", ",", "img_shape", ",", "scale_factor", ",", "\n", "flip", ")", "\n", "if", "self", ".", "with_crowd", ":", "\n", "            ", "gt_bboxes_ignore", "=", "self", ".", "bbox_transform", "(", "gt_bboxes_ignore", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ")", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "gt_masks", "=", "self", ".", "mask_transform", "(", "ann", "[", "'masks'", "]", ",", "pad_shape", ",", "\n", "scale_factor", ",", "flip", ")", "\n", "\n", "", "ori_shape", "=", "(", "img_info", "[", "'height'", "]", ",", "img_info", "[", "'width'", "]", ",", "3", ")", "\n", "img_meta", "=", "dict", "(", "\n", "ori_shape", "=", "ori_shape", ",", "\n", "img_shape", "=", "img_shape", ",", "\n", "pad_shape", "=", "pad_shape", ",", "\n", "scale_factor", "=", "scale_factor", ",", "\n", "flip", "=", "flip", ")", "\n", "\n", "data", "=", "dict", "(", "\n", "img", "=", "DC", "(", "to_tensor", "(", "img", ")", ",", "stack", "=", "True", ")", ",", "\n", "img_meta", "=", "DC", "(", "img_meta", ",", "cpu_only", "=", "True", ")", ",", "\n", "gt_bboxes", "=", "DC", "(", "to_tensor", "(", "gt_bboxes", ")", ")", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "data", "[", "'proposals'", "]", "=", "DC", "(", "to_tensor", "(", "proposals", ")", ")", "\n", "", "if", "self", ".", "with_label", ":", "\n", "            ", "data", "[", "'gt_labels'", "]", "=", "DC", "(", "to_tensor", "(", "gt_labels", ")", ")", "\n", "", "if", "self", ".", "with_crowd", ":", "\n", "            ", "data", "[", "'gt_bboxes_ignore'", "]", "=", "DC", "(", "to_tensor", "(", "gt_bboxes_ignore", ")", ")", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "data", "[", "'gt_masks'", "]", "=", "DC", "(", "gt_masks", ",", "cpu_only", "=", "True", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.prepare_test_img": [[241, 298], ["mmcv.imread", "dict", "os.join", "custom.CustomDataset.img_transform", "utils.to_tensor", "dict", "custom.CustomDataset.prepare_test_img.prepare_single"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor"], ["", "def", "prepare_test_img", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Prepare an image for testing (multi-scale and flipping)\"\"\"", "\n", "img_info", "=", "self", ".", "img_infos", "[", "idx", "]", "\n", "img", "=", "mmcv", ".", "imread", "(", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "img_info", "[", "'filename'", "]", ")", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "proposal", "=", "self", ".", "proposals", "[", "idx", "]", "[", ":", "self", ".", "num_max_proposals", "]", "\n", "if", "not", "(", "proposal", ".", "shape", "[", "1", "]", "==", "4", "or", "proposal", ".", "shape", "[", "1", "]", "==", "5", ")", ":", "\n", "                ", "raise", "AssertionError", "(", "\n", "'proposals should have shapes (n, 4) or (n, 5), '", "\n", "'but found {}'", ".", "format", "(", "proposal", ".", "shape", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "proposal", "=", "None", "\n", "\n", "", "def", "prepare_single", "(", "img", ",", "scale", ",", "flip", ",", "proposal", "=", "None", ")", ":", "\n", "            ", "_img", ",", "img_shape", ",", "pad_shape", ",", "scale_factor", "=", "self", ".", "img_transform", "(", "\n", "img", ",", "scale", ",", "flip", ",", "keep_ratio", "=", "self", ".", "resize_keep_ratio", ")", "\n", "_img", "=", "to_tensor", "(", "_img", ")", "\n", "_img_meta", "=", "dict", "(", "\n", "ori_shape", "=", "(", "img_info", "[", "'height'", "]", ",", "img_info", "[", "'width'", "]", ",", "3", ")", ",", "\n", "img_shape", "=", "img_shape", ",", "\n", "pad_shape", "=", "pad_shape", ",", "\n", "scale_factor", "=", "scale_factor", ",", "\n", "flip", "=", "flip", ")", "\n", "if", "proposal", "is", "not", "None", ":", "\n", "                ", "if", "proposal", ".", "shape", "[", "1", "]", "==", "5", ":", "\n", "                    ", "score", "=", "proposal", "[", ":", ",", "4", ",", "None", "]", "\n", "proposal", "=", "proposal", "[", ":", ",", ":", "4", "]", "\n", "", "else", ":", "\n", "                    ", "score", "=", "None", "\n", "", "_proposal", "=", "self", ".", "bbox_transform", "(", "proposal", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ")", "\n", "_proposal", "=", "np", ".", "hstack", "(", "\n", "[", "_proposal", ",", "score", "]", ")", "if", "score", "is", "not", "None", "else", "_proposal", "\n", "_proposal", "=", "to_tensor", "(", "_proposal", ")", "\n", "", "else", ":", "\n", "                ", "_proposal", "=", "None", "\n", "", "return", "_img", ",", "_img_meta", ",", "_proposal", "\n", "\n", "", "imgs", "=", "[", "]", "\n", "img_metas", "=", "[", "]", "\n", "proposals", "=", "[", "]", "\n", "for", "scale", "in", "self", ".", "img_scales", ":", "\n", "            ", "_img", ",", "_img_meta", ",", "_proposal", "=", "prepare_single", "(", "\n", "img", ",", "scale", ",", "False", ",", "proposal", ")", "\n", "imgs", ".", "append", "(", "_img", ")", "\n", "img_metas", ".", "append", "(", "DC", "(", "_img_meta", ",", "cpu_only", "=", "True", ")", ")", "\n", "proposals", ".", "append", "(", "_proposal", ")", "\n", "if", "self", ".", "flip_ratio", ">", "0", ":", "\n", "                ", "_img", ",", "_img_meta", ",", "_proposal", "=", "prepare_single", "(", "\n", "img", ",", "scale", ",", "True", ",", "proposal", ")", "\n", "imgs", ".", "append", "(", "_img", ")", "\n", "img_metas", ".", "append", "(", "DC", "(", "_img_meta", ",", "cpu_only", "=", "True", ")", ")", "\n", "proposals", ".", "append", "(", "_proposal", ")", "\n", "", "", "data", "=", "dict", "(", "img", "=", "imgs", ",", "img_meta", "=", "img_metas", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "data", "[", "'proposals'", "]", "=", "proposals", "\n", "", "return", "data", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.transforms.ImageTransform.__init__": [[18, 27], ["numpy.array", "numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "mean", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "std", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "to_rgb", "=", "True", ",", "\n", "size_divisor", "=", "None", ")", ":", "\n", "        ", "self", ".", "mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "to_rgb", "=", "to_rgb", "\n", "self", ".", "size_divisor", "=", "size_divisor", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.transforms.ImageTransform.__call__": [[28, 47], ["mmcv.imnormalize", "mmcv.impad_to_multiple.transpose", "mmcv.imrescale", "mmcv.imresize", "numpy.array", "mmcv.imflip", "mmcv.impad_to_multiple"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "scale", ",", "flip", "=", "False", ",", "keep_ratio", "=", "True", ")", ":", "\n", "        ", "if", "keep_ratio", ":", "\n", "            ", "img", ",", "scale_factor", "=", "mmcv", ".", "imrescale", "(", "img", ",", "scale", ",", "return_scale", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "img", ",", "w_scale", ",", "h_scale", "=", "mmcv", ".", "imresize", "(", "\n", "img", ",", "scale", ",", "return_scale", "=", "True", ")", "\n", "scale_factor", "=", "np", ".", "array", "(", "[", "w_scale", ",", "h_scale", ",", "w_scale", ",", "h_scale", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "", "img_shape", "=", "img", ".", "shape", "\n", "img", "=", "mmcv", ".", "imnormalize", "(", "img", ",", "self", ".", "mean", ",", "self", ".", "std", ",", "self", ".", "to_rgb", ")", "\n", "if", "flip", ":", "\n", "            ", "img", "=", "mmcv", ".", "imflip", "(", "img", ")", "\n", "", "if", "self", ".", "size_divisor", "is", "not", "None", ":", "\n", "            ", "img", "=", "mmcv", ".", "impad_to_multiple", "(", "img", ",", "self", ".", "size_divisor", ")", "\n", "pad_shape", "=", "img", ".", "shape", "\n", "", "else", ":", "\n", "            ", "pad_shape", "=", "img_shape", "\n", "", "img", "=", "img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "return", "img", ",", "img_shape", ",", "pad_shape", ",", "scale_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.transforms.BboxTransform.__init__": [[72, 74], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "max_num_gts", "=", "None", ")", ":", "\n", "        ", "self", ".", "max_num_gts", "=", "max_num_gts", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.transforms.BboxTransform.__call__": [[75, 90], ["transforms.bbox_flip", "numpy.clip", "numpy.clip", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.transforms.bbox_flip"], ["", "def", "__call__", "(", "self", ",", "bboxes", ",", "img_shape", ",", "pad_shape", ",", "scale_factor", ",", "flip", "=", "False", ")", ":", "\n", "        ", "gt_bboxes", "=", "bboxes", "*", "scale_factor", "\n", "if", "flip", ":", "\n", "            ", "gt_bboxes", "=", "bbox_flip", "(", "gt_bboxes", ",", "img_shape", ")", "\n", "# normalization [0, 1] [x1,y1,x2,y2]", "\n", "", "gt_bboxes", "[", ":", ",", "0", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "gt_bboxes", "[", ":", ",", "0", ":", ":", "2", "]", ",", "0", ",", "img_shape", "[", "1", "]", ")", "/", "pad_shape", "[", "1", "]", "\n", "gt_bboxes", "[", ":", ",", "1", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "gt_bboxes", "[", ":", ",", "1", ":", ":", "2", "]", ",", "0", ",", "img_shape", "[", "0", "]", ")", "/", "pad_shape", "[", "0", "]", "\n", "\n", "if", "self", ".", "max_num_gts", "is", "None", ":", "\n", "            ", "return", "gt_bboxes", "\n", "", "else", ":", "\n", "            ", "num_gts", "=", "gt_bboxes", ".", "shape", "[", "0", "]", "\n", "padded_bboxes", "=", "np", ".", "zeros", "(", "(", "self", ".", "max_num_gts", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "padded_bboxes", "[", ":", "num_gts", ",", ":", "]", "=", "gt_bboxes", "\n", "return", "padded_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.transforms.MaskTransform.__call__": [[100, 119], ["numpy.stack", "mmcv.impad", "mmcv.imrescale", "mmcv.imresize"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "masks", ",", "pad_shape", ",", "scale", ",", "flip", "=", "False", ",", "keep_ratio", "=", "True", ")", ":", "\n", "        ", "if", "keep_ratio", ":", "\n", "            ", "masks", "=", "[", "\n", "mmcv", ".", "imrescale", "(", "mask", ",", "scale", ",", "interpolation", "=", "'nearest'", ")", "\n", "for", "mask", "in", "masks", "\n", "]", "\n", "", "else", ":", "\n", "            ", "masks", "=", "[", "\n", "mmcv", ".", "imresize", "(", "mask", ",", "scale", ",", "interpolation", "=", "'nearest'", ")", "\n", "for", "mask", "in", "masks", "\n", "]", "\n", "\n", "", "if", "flip", ":", "\n", "            ", "masks", "=", "[", "mask", "[", ":", ",", ":", ":", "-", "1", "]", "for", "mask", "in", "masks", "]", "\n", "", "padded_masks", "=", "[", "\n", "mmcv", ".", "impad", "(", "mask", ",", "shape", "=", "pad_shape", "[", ":", "2", "]", ",", "pad_val", "=", "0", ")", "for", "mask", "in", "masks", "\n", "]", "\n", "padded_masks", "=", "np", ".", "stack", "(", "padded_masks", ",", "axis", "=", "0", ")", "\n", "return", "padded_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.transforms.Numpy2Tensor.__init__": [[123, 125], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.transforms.Numpy2Tensor.__call__": [[126, 131], ["len", "torch.from_numpy", "tuple", "torch.from_numpy", "numpy.array"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "if", "len", "(", "args", ")", "==", "1", ":", "\n", "            ", "return", "torch", ".", "from_numpy", "(", "args", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "tuple", "(", "[", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "array", ")", ")", "for", "array", "in", "args", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.transforms.bbox_flip": [[49, 62], ["bboxes.copy"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy"], ["", "", "def", "bbox_flip", "(", "bboxes", ",", "img_shape", ")", ":", "\n", "    ", "\"\"\"Flip bboxes horizontally.\n\n    Args:\n        bboxes(ndarray): shape (..., 4*k)\n        img_shape(tuple): (height, width)\n    \"\"\"", "\n", "assert", "bboxes", ".", "shape", "[", "-", "1", "]", "%", "4", "==", "0", "\n", "w", "=", "img_shape", "[", "1", "]", "\n", "flipped", "=", "bboxes", ".", "copy", "(", ")", "\n", "flipped", "[", "...", ",", "0", ":", ":", "4", "]", "=", "w", "-", "bboxes", "[", "...", ",", "2", ":", ":", "4", "]", "-", "1", "\n", "flipped", "[", "...", ",", "2", ":", ":", "4", "]", "=", "w", "-", "bboxes", "[", "...", ",", "0", ":", ":", "4", "]", "-", "1", "\n", "return", "flipped", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.__init__": [[77, 80], ["config_dict.items", "config.Config.__setattr__"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "config_dict", ")", ":", "\n", "        ", "for", "key", ",", "val", "in", "config_dict", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "__setattr__", "(", "key", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy": [[81, 92], ["config.Config", "new_config_dict.items", "vars", "object.__setattr__"], "methods", ["None"], ["", "", "def", "copy", "(", "self", ",", "new_config_dict", "=", "{", "}", ")", ":", "\n", "        ", "\"\"\"\n        Copies this config into a new config object, making\n        the changes given by new_config_dict.\n        \"\"\"", "\n", "ret", "=", "Config", "(", "vars", "(", "self", ")", ")", "\n", "\n", "for", "key", ",", "val", "in", "new_config_dict", ".", "items", "(", ")", ":", "\n", "            ", "ret", ".", "__setattr__", "(", "key", ",", "val", ")", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.replace": [[93, 103], ["isinstance", "vars.items", "vars", "config.Config.__setattr__"], "methods", ["None"], ["", "def", "replace", "(", "self", ",", "new_config_dict", ")", ":", "\n", "        ", "\"\"\"\n        Copies new_config_dict into this config object.\n        Note: new_config_dict can also be a config object.\n        \"\"\"", "\n", "if", "isinstance", "(", "new_config_dict", ",", "Config", ")", ":", "\n", "            ", "new_config_dict", "=", "vars", "(", "new_config_dict", ")", "\n", "\n", "", "for", "key", ",", "val", "in", "new_config_dict", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "__setattr__", "(", "key", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print": [[104, 107], ["vars().items", "config.Config.print"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print"], ["", "", "def", "print", "(", "self", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "vars", "(", "self", ")", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "k", ",", "' = '", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.set_cfg": [[978, 988], ["cfg.replace", "eval", "config_name.split"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.replace", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["def", "set_cfg", "(", "config_name", ":", "str", ")", ":", "\n", "    ", "\"\"\" Sets the active config. Works even if cfg is already imported! \"\"\"", "\n", "global", "cfg", "\n", "\n", "# Note this is not just an eval because I'm lazy, but also because it can", "\n", "# be used like ssd300_config.copy({'max_size': 400}) for extreme fine-tuning", "\n", "cfg", ".", "replace", "(", "eval", "(", "config_name", ")", ")", "\n", "\n", "if", "cfg", ".", "name", "is", "None", ":", "\n", "        ", "cfg", ".", "name", "=", "config_name", ".", "split", "(", "'_config'", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.set_dataset": [[990, 996], ["eval", "eval"], "function", ["None"], ["", "", "def", "set_dataset", "(", "dataset_name", ":", "str", ",", "type", ":", "str", ")", ":", "\n", "    ", "\"\"\" Sets the dataset of the current config. \"\"\"", "\n", "if", "type", "==", "'train'", ":", "\n", "        ", "cfg", ".", "train_dataset", "=", "eval", "(", "dataset_name", ")", "\n", "", "elif", "type", "==", "'eval'", ":", "\n", "        ", "cfg", ".", "valid_dataset", "=", "eval", "(", "dataset_name", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.bbox_overlaps.bbox_overlaps": [[4, 50], ["bboxes1.astype.astype", "bboxes2.astype.astype", "numpy.zeros", "range", "numpy.zeros", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum"], "function", ["None"], ["def", "bbox_overlaps", "(", "bboxes1", ",", "bboxes2", ",", "mode", "=", "'iou'", ")", ":", "\n", "    ", "\"\"\"Calculate the ious between each bbox of bboxes1 and bboxes2.\n\n    Args:\n        bboxes1(ndarray): shape (n, 4)\n        bboxes2(ndarray): shape (k, 4)\n        mode(str): iou (intersection over union) or iof (intersection\n            over foreground)\n\n    Returns:\n        ious(ndarray): shape (n, k)\n    \"\"\"", "\n", "\n", "assert", "mode", "in", "[", "'iou'", ",", "'iof'", "]", "\n", "\n", "bboxes1", "=", "bboxes1", ".", "astype", "(", "np", ".", "float32", ")", "\n", "bboxes2", "=", "bboxes2", ".", "astype", "(", "np", ".", "float32", ")", "\n", "rows", "=", "bboxes1", ".", "shape", "[", "0", "]", "\n", "cols", "=", "bboxes2", ".", "shape", "[", "0", "]", "\n", "ious", "=", "np", ".", "zeros", "(", "(", "rows", ",", "cols", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "rows", "*", "cols", "==", "0", ":", "\n", "        ", "return", "ious", "\n", "", "exchange", "=", "False", "\n", "if", "bboxes1", ".", "shape", "[", "0", "]", ">", "bboxes2", ".", "shape", "[", "0", "]", ":", "\n", "        ", "bboxes1", ",", "bboxes2", "=", "bboxes2", ",", "bboxes1", "\n", "ious", "=", "np", ".", "zeros", "(", "(", "cols", ",", "rows", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "exchange", "=", "True", "\n", "", "area1", "=", "(", "bboxes1", "[", ":", ",", "2", "]", "-", "bboxes1", "[", ":", ",", "0", "]", "+", "1", ")", "*", "(", "\n", "bboxes1", "[", ":", ",", "3", "]", "-", "bboxes1", "[", ":", ",", "1", "]", "+", "1", ")", "\n", "area2", "=", "(", "bboxes2", "[", ":", ",", "2", "]", "-", "bboxes2", "[", ":", ",", "0", "]", "+", "1", ")", "*", "(", "\n", "bboxes2", "[", ":", ",", "3", "]", "-", "bboxes2", "[", ":", ",", "1", "]", "+", "1", ")", "\n", "for", "i", "in", "range", "(", "bboxes1", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "x_start", "=", "np", ".", "maximum", "(", "bboxes1", "[", "i", ",", "0", "]", ",", "bboxes2", "[", ":", ",", "0", "]", ")", "\n", "y_start", "=", "np", ".", "maximum", "(", "bboxes1", "[", "i", ",", "1", "]", ",", "bboxes2", "[", ":", ",", "1", "]", ")", "\n", "x_end", "=", "np", ".", "minimum", "(", "bboxes1", "[", "i", ",", "2", "]", ",", "bboxes2", "[", ":", ",", "2", "]", ")", "\n", "y_end", "=", "np", ".", "minimum", "(", "bboxes1", "[", "i", ",", "3", "]", ",", "bboxes2", "[", ":", ",", "3", "]", ")", "\n", "overlap", "=", "np", ".", "maximum", "(", "x_end", "-", "x_start", "+", "1", ",", "0", ")", "*", "np", ".", "maximum", "(", "\n", "y_end", "-", "y_start", "+", "1", ",", "0", ")", "\n", "if", "mode", "==", "'iou'", ":", "\n", "            ", "union", "=", "area1", "[", "i", "]", "+", "area2", "-", "overlap", "\n", "", "else", ":", "\n", "            ", "union", "=", "area1", "[", "i", "]", "if", "not", "exchange", "else", "area2", "\n", "", "ious", "[", "i", ",", ":", "]", "=", "overlap", "/", "union", "\n", "", "if", "exchange", ":", "\n", "        ", "ious", "=", "ious", ".", "T", "\n", "", "return", "ious", "\n", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.extra_aug.PhotoMetricDistortion.__init__": [[10, 19], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "brightness_delta", "=", "32", ",", "\n", "contrast_range", "=", "(", "0.5", ",", "1.5", ")", ",", "\n", "saturation_range", "=", "(", "0.5", ",", "1.5", ")", ",", "\n", "hue_delta", "=", "18", ")", ":", "\n", "        ", "self", ".", "brightness_delta", "=", "brightness_delta", "\n", "self", ".", "contrast_lower", ",", "self", ".", "contrast_upper", "=", "contrast_range", "\n", "self", ".", "saturation_lower", ",", "self", ".", "saturation_upper", "=", "saturation_range", "\n", "self", ".", "hue_delta", "=", "hue_delta", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.extra_aug.PhotoMetricDistortion.__call__": [[20, 65], ["numpy.random.randint", "numpy.random.randint", "mmcv.bgr2hsv", "numpy.random.randint", "numpy.random.randint", "mmcv.hsv2bgr", "numpy.random.randint", "numpy.random.uniform", "numpy.random.randint", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.randint", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.permutation"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", ")", ":", "\n", "# random brightness", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "delta", "=", "random", ".", "uniform", "(", "-", "self", ".", "brightness_delta", ",", "\n", "self", ".", "brightness_delta", ")", "\n", "img", "+=", "delta", "\n", "\n", "# mode == 0 --> do random contrast first", "\n", "# mode == 1 --> do random contrast last", "\n", "", "mode", "=", "random", ".", "randint", "(", "2", ")", "\n", "if", "mode", "==", "1", ":", "\n", "            ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "                ", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "contrast_lower", ",", "\n", "self", ".", "contrast_upper", ")", "\n", "img", "*=", "alpha", "\n", "\n", "# convert color from BGR to HSV", "\n", "", "", "img", "=", "mmcv", ".", "bgr2hsv", "(", "img", ")", "\n", "\n", "# random saturation", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "img", "[", "...", ",", "1", "]", "*=", "random", ".", "uniform", "(", "self", ".", "saturation_lower", ",", "\n", "self", ".", "saturation_upper", ")", "\n", "\n", "# random hue", "\n", "", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "img", "[", "...", ",", "0", "]", "+=", "random", ".", "uniform", "(", "-", "self", ".", "hue_delta", ",", "self", ".", "hue_delta", ")", "\n", "img", "[", "...", ",", "0", "]", "[", "img", "[", "...", ",", "0", "]", ">", "360", "]", "-=", "360", "\n", "img", "[", "...", ",", "0", "]", "[", "img", "[", "...", ",", "0", "]", "<", "0", "]", "+=", "360", "\n", "\n", "# convert color from HSV to BGR", "\n", "", "img", "=", "mmcv", ".", "hsv2bgr", "(", "img", ")", "\n", "\n", "# random contrast", "\n", "if", "mode", "==", "0", ":", "\n", "            ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "                ", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "contrast_lower", ",", "\n", "self", ".", "contrast_upper", ")", "\n", "img", "*=", "alpha", "\n", "\n", "# randomly swap channels", "\n", "", "", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "img", "=", "img", "[", "...", ",", "random", ".", "permutation", "(", "3", ")", "]", "\n", "\n", "", "return", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.extra_aug.Expand.__init__": [[69, 75], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mean", "=", "(", "0", ",", "0", ",", "0", ")", ",", "to_rgb", "=", "True", ",", "ratio_range", "=", "(", "1", ",", "4", ")", ")", ":", "\n", "        ", "if", "to_rgb", ":", "\n", "            ", "self", ".", "mean", "=", "mean", "[", ":", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "mean", "=", "mean", "\n", "", "self", ".", "min_ratio", ",", "self", ".", "max_ratio", "=", "ratio_range", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.extra_aug.Expand.__call__": [[76, 96], ["numpy.random.randint", "numpy.random.uniform", "numpy.full().astype", "int", "int", "mmcv.imresize", "numpy.rint().astype", "range", "numpy.random.uniform", "numpy.random.uniform", "len", "numpy.full().astype", "expand_masks.append", "numpy.full", "numpy.rint", "mmcv.imresize", "numpy.full", "int", "int", "numpy.tile", "int", "int"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "__call__", "(", "self", ",", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "return", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", "\n", "\n", "", "h", ",", "w", ",", "c", "=", "img", ".", "shape", "\n", "ratio", "=", "random", ".", "uniform", "(", "self", ".", "min_ratio", ",", "self", ".", "max_ratio", ")", "\n", "expand_img", "=", "np", ".", "full", "(", "(", "int", "(", "h", "*", "ratio", ")", ",", "int", "(", "w", "*", "ratio", ")", ",", "c", ")", ",", "\n", "self", ".", "mean", ")", ".", "astype", "(", "img", ".", "dtype", ")", "\n", "left", "=", "int", "(", "random", ".", "uniform", "(", "0", ",", "w", "*", "ratio", "-", "w", ")", ")", "\n", "top", "=", "int", "(", "random", ".", "uniform", "(", "0", ",", "h", "*", "ratio", "-", "h", ")", ")", "\n", "expand_img", "[", "top", ":", "top", "+", "h", ",", "left", ":", "left", "+", "w", "]", "=", "img", "\n", "img", "=", "mmcv", ".", "imresize", "(", "expand_img", ",", "(", "w", ",", "h", ")", ",", "interpolation", "=", "'nearest'", ")", "\n", "boxes", "=", "np", ".", "rint", "(", "(", "boxes", "+", "np", ".", "tile", "(", "(", "left", ",", "top", ")", ",", "2", ")", ")", "/", "ratio", ")", ".", "astype", "(", "boxes", ".", "dtype", ")", "\n", "expand_masks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "masks", ")", ")", ":", "\n", "            ", "expand_mask_cur", "=", "np", ".", "full", "(", "(", "int", "(", "h", "*", "ratio", ")", ",", "int", "(", "w", "*", "ratio", ")", ")", ",", "0", ")", ".", "astype", "(", "masks", "[", "i", "]", ".", "dtype", ")", "\n", "expand_mask_cur", "[", "top", ":", "top", "+", "h", ",", "left", ":", "left", "+", "w", "]", "=", "masks", "[", "i", "]", "\n", "expand_masks", ".", "append", "(", "mmcv", ".", "imresize", "(", "expand_mask_cur", ",", "(", "w", ",", "h", ")", ",", "interpolation", "=", "'nearest'", ")", ")", "\n", "", "masks", "=", "expand_masks", "\n", "return", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.extra_aug.RandomCrop.__init__": [[100, 106], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "min_ious", "=", "(", "0.1", ",", "0.3", ",", "0.5", ",", "0.7", ",", "0.9", ")", ",", "\n", "min_crop_size", "=", "0.3", ")", ":", "\n", "# 1: return ori img", "\n", "        ", "self", ".", "sample_mode", "=", "(", "1", ",", "*", "min_ious", ",", "0", ")", "\n", "self", ".", "min_crop_size", "=", "min_crop_size", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.extra_aug.RandomCrop.__call__": [[107, 159], ["numpy.random.choice", "range", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.array", "datasets.bbox_overlaps.bbox_overlaps().reshape", "[].tolist", "numpy.zeros", "boxes[].clip", "boxes[].clip", "numpy.tile", "numpy.zeros", "range", "datasets.bbox_overlaps.bbox_overlaps().reshape.min", "mask.any", "numpy.array", "len", "masks_crop_list.append", "int", "int", "int", "int", "datasets.bbox_overlaps.bbox_overlaps", "numpy.array.reshape", "boxes.reshape", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.bbox_overlaps.bbox_overlaps"], ["", "def", "__call__", "(", "self", ",", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", ")", ":", "\n", "        ", "h", ",", "w", ",", "c", "=", "img", ".", "shape", "\n", "while", "True", ":", "\n", "            ", "mode", "=", "random", ".", "choice", "(", "self", ".", "sample_mode", ")", "\n", "if", "mode", "==", "1", ":", "\n", "                ", "return", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", "\n", "\n", "", "min_iou", "=", "mode", "\n", "for", "i", "in", "range", "(", "50", ")", ":", "\n", "                ", "new_w", "=", "random", ".", "uniform", "(", "self", ".", "min_crop_size", "*", "w", ",", "w", ")", "\n", "new_h", "=", "random", ".", "uniform", "(", "self", ".", "min_crop_size", "*", "h", ",", "h", ")", "\n", "\n", "# h / w in [0.5, 2]", "\n", "if", "new_h", "/", "new_w", "<", "0.5", "or", "new_h", "/", "new_w", ">", "2", ":", "\n", "                    ", "continue", "\n", "\n", "", "left", "=", "random", ".", "uniform", "(", "w", "-", "new_w", ")", "\n", "top", "=", "random", ".", "uniform", "(", "h", "-", "new_h", ")", "\n", "\n", "patch", "=", "np", ".", "array", "(", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ",", "int", "(", "left", "+", "new_w", ")", ",", "\n", "int", "(", "top", "+", "new_h", ")", ")", ")", "\n", "overlaps", "=", "bbox_overlaps", "(", "\n", "patch", ".", "reshape", "(", "-", "1", ",", "4", ")", ",", "boxes", ".", "reshape", "(", "-", "1", ",", "4", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "if", "overlaps", ".", "min", "(", ")", "<", "min_iou", ":", "\n", "                    ", "continue", "\n", "\n", "# center of boxes should inside the crop img", "\n", "", "center", "=", "(", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "mask", "=", "(", "center", "[", ":", ",", "0", "]", ">", "patch", "[", "0", "]", ")", "*", "(", "\n", "center", "[", ":", ",", "1", "]", ">", "patch", "[", "1", "]", ")", "*", "(", "center", "[", ":", ",", "0", "]", "<", "patch", "[", "2", "]", ")", "*", "(", "\n", "center", "[", ":", ",", "1", "]", "<", "patch", "[", "3", "]", ")", "\n", "if", "not", "mask", ".", "any", "(", ")", ":", "\n", "                    ", "continue", "\n", "", "boxes", "=", "boxes", "[", "mask", "]", "\n", "labels", "=", "labels", "[", "mask", "]", "\n", "masks", "=", "np", ".", "array", "(", "masks", ")", "[", "mask", "]", "\n", "ids", "=", "np", ".", "array", "(", "ids", ")", "[", "mask", "]", ".", "tolist", "(", ")", "\n", "\n", "# adjust boxes", "\n", "img_crop", "=", "np", ".", "zeros", "(", "img", ".", "shape", ")", "\n", "img_crop", "[", "patch", "[", "1", "]", ":", "patch", "[", "3", "]", ",", "patch", "[", "0", "]", ":", "patch", "[", "2", "]", "]", "=", "img", "[", "patch", "[", "1", "]", ":", "patch", "[", "3", "]", ",", "patch", "[", "0", "]", ":", "patch", "[", "2", "]", "]", "\n", "boxes", "[", ":", ",", "2", ":", "]", "=", "boxes", "[", ":", ",", "2", ":", "]", ".", "clip", "(", "max", "=", "patch", "[", "2", ":", "]", ")", "\n", "boxes", "[", ":", ",", ":", "2", "]", "=", "boxes", "[", ":", ",", ":", "2", "]", ".", "clip", "(", "min", "=", "patch", "[", ":", "2", "]", ")", "\n", "boxes", "-=", "np", ".", "tile", "(", "patch", "[", ":", "2", "]", ",", "2", ")", "\n", "\n", "# adjust masks", "\n", "masks_crop", "=", "np", ".", "zeros", "(", "masks", ".", "shape", ")", "\n", "masks_crop", "[", ":", ",", "patch", "[", "1", "]", ":", "patch", "[", "3", "]", ",", "patch", "[", "0", "]", ":", "patch", "[", "2", "]", "]", "=", "masks", "[", ":", ",", "patch", "[", "1", "]", ":", "patch", "[", "3", "]", ",", "patch", "[", "0", "]", ":", "patch", "[", "2", "]", "]", "\n", "masks_crop_list", "=", "[", "]", "\n", "for", "m", "in", "range", "(", "len", "(", "masks", ")", ")", ":", "\n", "                    ", "masks_crop_list", ".", "append", "(", "masks_crop", "[", "m", "]", ")", "\n", "", "return", "img_crop", ",", "boxes", ",", "labels", ",", "masks_crop_list", ",", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.extra_aug.ExtraAugmentation.__init__": [[163, 175], ["extra_aug.ExtraAugmentation.transforms.append", "extra_aug.ExtraAugmentation.transforms.append", "extra_aug.ExtraAugmentation.transforms.append", "extra_aug.PhotoMetricDistortion", "extra_aug.Expand", "extra_aug.RandomCrop"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["    ", "def", "__init__", "(", "self", ",", "\n", "photo_metric_distortion", "=", "None", ",", "\n", "expand", "=", "None", ",", "\n", "random_crop", "=", "None", ")", ":", "\n", "        ", "self", ".", "transforms", "=", "[", "]", "\n", "if", "photo_metric_distortion", "is", "not", "None", ":", "\n", "            ", "self", ".", "transforms", ".", "append", "(", "\n", "PhotoMetricDistortion", "(", "**", "photo_metric_distortion", ")", ")", "\n", "", "if", "expand", "is", "not", "None", ":", "\n", "            ", "self", ".", "transforms", ".", "append", "(", "Expand", "(", "**", "expand", ")", ")", "\n", "", "if", "random_crop", "is", "not", "None", ":", "\n", "            ", "self", ".", "transforms", ".", "append", "(", "RandomCrop", "(", "**", "random_crop", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.extra_aug.ExtraAugmentation.__call__": [[176, 181], ["img.astype.astype.astype", "transform"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", ")", ":", "\n", "        ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "for", "transform", "in", "self", ".", "transforms", ":", "\n", "            ", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", "=", "transform", "(", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", ")", "\n", "", "return", "img", ",", "boxes", ",", "labels", ",", "masks", ",", "ids", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.concat_dataset.ConcatDataset.__init__": [[15, 23], ["torch.utils.data.dataset.ConcatDataset.__init__", "hasattr", "range", "numpy.concatenate", "len", "flags.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["def", "__init__", "(", "self", ",", "datasets", ")", ":", "\n", "        ", "super", "(", "ConcatDataset", ",", "self", ")", ".", "__init__", "(", "datasets", ")", "\n", "self", ".", "CLASSES", "=", "datasets", "[", "0", "]", ".", "CLASSES", "\n", "if", "hasattr", "(", "datasets", "[", "0", "]", ",", "'flag'", ")", ":", "\n", "            ", "flags", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "datasets", ")", ")", ":", "\n", "                ", "flags", ".", "append", "(", "datasets", "[", "i", "]", ".", "flag", ")", "\n", "", "self", ".", "flag", "=", "np", ".", "concatenate", "(", "flags", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.__init__.detection_collate": [[21, 50], ["batch[].keys", "range", "len", "batch_out.keys", "isinstance", "batch_out[].append", "batch_out[].append"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], []], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.__init__": [[23, 109], ["ytvos.YTVOSDataset.load_annotations", "zip", "mmcv.is_list_of", "transforms.ImageTransform", "transforms.BboxTransform", "transforms.MaskTransform", "transforms.Numpy2Tensor", "range", "ytvos.YTVOSDataset.load_proposals", "isinstance", "ytvos.YTVOSDataset._set_group_flag", "extra_aug.ExtraAugmentation", "len", "img_ids.append", "enumerate", "len", "ytvos.YTVOSDataset.get_ann_info"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.load_annotations", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.custom.CustomDataset.load_proposals", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset._set_group_flag", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.get_ann_info"], ["def", "__init__", "(", "self", ",", "\n", "ann_file", ",", "\n", "img_prefix", ",", "\n", "img_scale", ",", "\n", "img_norm_cfg", ",", "\n", "size_divisor", "=", "None", ",", "\n", "proposal_file", "=", "None", ",", "\n", "num_max_proposals", "=", "1000", ",", "\n", "flip_ratio", "=", "0", ",", "\n", "with_mask", "=", "True", ",", "\n", "with_crowd", "=", "False", ",", "\n", "with_label", "=", "True", ",", "\n", "with_track", "=", "False", ",", "\n", "extra_aug", "=", "None", ",", "\n", "aug_ref_bbox_param", "=", "None", ",", "\n", "resize_keep_ratio", "=", "True", ",", "\n", "test_mode", "=", "False", ",", "\n", "clip_frames", "=", "1", ")", ":", "\n", "# prefix of images path", "\n", "        ", "self", ".", "img_prefix", "=", "img_prefix", "\n", "\n", "# load annotations (and proposals)", "\n", "self", ".", "vid_infos", "=", "self", ".", "load_annotations", "(", "ann_file", ")", "\n", "img_ids", "=", "[", "]", "\n", "for", "vid_id", ",", "vid_info", "in", "zip", "(", "self", ".", "vid_ids", ",", "self", ".", "vid_infos", ")", ":", "\n", "            ", "for", "frame_id", "in", "range", "(", "len", "(", "vid_info", "[", "'filenames'", "]", ")", ")", ":", "\n", "                ", "img_ids", ".", "append", "(", "(", "vid_id", ",", "frame_id", ")", ")", "\n", "", "", "self", ".", "img_ids", "=", "img_ids", "\n", "if", "proposal_file", "is", "not", "None", ":", "\n", "            ", "self", ".", "proposals", "=", "self", ".", "load_proposals", "(", "proposal_file", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "proposals", "=", "None", "\n", "# filter images with no annotation during training", "\n", "", "if", "not", "test_mode", ":", "\n", "            ", "valid_inds", "=", "[", "i", "for", "i", ",", "(", "v", ",", "f", ")", "in", "enumerate", "(", "self", ".", "img_ids", ")", "\n", "if", "len", "(", "self", ".", "get_ann_info", "(", "v", ",", "f", ")", "[", "'bboxes'", "]", ")", "]", "\n", "self", ".", "img_ids", "=", "[", "self", ".", "img_ids", "[", "i", "]", "for", "i", "in", "valid_inds", "]", "\n", "\n", "# (long_edge, short_edge) or [(long1, short1), (long2, short2), ...]", "\n", "", "self", ".", "img_scales", "=", "img_scale", "if", "isinstance", "(", "img_scale", ",", "\n", "list", ")", "else", "[", "img_scale", "]", "\n", "assert", "mmcv", ".", "is_list_of", "(", "self", ".", "img_scales", ",", "tuple", ")", "\n", "# normalization configs", "\n", "self", ".", "img_norm_cfg", "=", "img_norm_cfg", "\n", "self", ".", "clip_frames", "=", "clip_frames", "\n", "\n", "# max proposals per image", "\n", "self", ".", "num_max_proposals", "=", "num_max_proposals", "\n", "# flip ratio", "\n", "self", ".", "flip_ratio", "=", "flip_ratio", "\n", "assert", "flip_ratio", ">=", "0", "and", "flip_ratio", "<=", "1", "\n", "# padding border to ensure the image size can be divided by", "\n", "# size_divisor (used for FPN)", "\n", "self", ".", "size_divisor", "=", "size_divisor", "\n", "\n", "# with mask or not (reserved field, takes no effect)", "\n", "self", ".", "with_mask", "=", "with_mask", "\n", "# some datasets provide bbox annotations as ignore/crowd/difficult,", "\n", "# if `with_crowd` is True, then these info is returned.", "\n", "self", ".", "with_crowd", "=", "with_crowd", "\n", "# with label is False for RPN", "\n", "self", ".", "with_label", "=", "with_label", "\n", "self", ".", "with_track", "=", "with_track", "\n", "# params for augmenting bbox in the reference frame", "\n", "self", ".", "aug_ref_bbox_param", "=", "aug_ref_bbox_param", "\n", "# in test mode or not", "\n", "self", ".", "test_mode", "=", "test_mode", "\n", "\n", "# set group flag for the sampler", "\n", "if", "not", "self", ".", "test_mode", ":", "\n", "            ", "self", ".", "_set_group_flag", "(", ")", "\n", "# transforms", "\n", "", "self", ".", "img_transform", "=", "ImageTransform", "(", "\n", "size_divisor", "=", "self", ".", "size_divisor", ",", "**", "self", ".", "img_norm_cfg", ")", "\n", "self", ".", "bbox_transform", "=", "BboxTransform", "(", ")", "\n", "self", ".", "mask_transform", "=", "MaskTransform", "(", ")", "\n", "self", ".", "numpy2tensor", "=", "Numpy2Tensor", "(", ")", "\n", "\n", "# if use extra augmentation", "\n", "if", "extra_aug", "is", "not", "None", ":", "\n", "            ", "self", ".", "extra_aug", "=", "ExtraAugmentation", "(", "**", "extra_aug", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "extra_aug", "=", "None", "\n", "\n", "# image rescale if keep ratio", "\n", "", "self", ".", "resize_keep_ratio", "=", "resize_keep_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.__len__": [[110, 112], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "img_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.__getitem__": [[113, 118], ["ytvos.YTVOSDataset.prepare_train_img", "ytvos.YTVOSDataset.prepare_test_img"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.prepare_train_img", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.prepare_test_img"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "test_mode", ":", "\n", "            ", "return", "self", ".", "prepare_test_img", "(", "self", ".", "img_ids", "[", "idx", "]", ")", "\n", "", "data", "=", "self", ".", "prepare_train_img", "(", "self", ".", "img_ids", "[", "idx", "]", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.load_annotations": [[119, 133], ["cocoapi.PythonAPI.pycocotools.ytvos.YTVOS", "ytvos.YTVOSDataset.ytvos.getCatIds", "ytvos.YTVOSDataset.ytvos.getVidIds", "vid_infos.append", "enumerate", "ytvos.YTVOSDataset.ytvos.loadVids"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "self", ".", "ytvos", "=", "YTVOS", "(", "ann_file", ")", "\n", "self", ".", "cat_ids", "=", "self", ".", "ytvos", ".", "getCatIds", "(", ")", "\n", "self", ".", "cat2label", "=", "{", "\n", "cat_id", ":", "i", "+", "1", "\n", "for", "i", ",", "cat_id", "in", "enumerate", "(", "self", ".", "cat_ids", ")", "\n", "}", "\n", "self", ".", "vid_ids", "=", "self", ".", "ytvos", ".", "getVidIds", "(", ")", "\n", "vid_infos", "=", "[", "]", "\n", "for", "i", "in", "self", ".", "vid_ids", ":", "\n", "            ", "info", "=", "self", ".", "ytvos", ".", "loadVids", "(", "[", "i", "]", ")", "[", "0", "]", "\n", "info", "[", "'filenames'", "]", "=", "info", "[", "'file_names'", "]", "\n", "vid_infos", ".", "append", "(", "info", ")", "\n", "", "return", "vid_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.get_ann_info": [[134, 138], ["ytvos.YTVOSDataset.ytvos.getAnnIds", "ytvos.YTVOSDataset.ytvos.loadAnns", "ytvos.YTVOSDataset._parse_ann_info"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset._parse_ann_info"], ["", "def", "get_ann_info", "(", "self", ",", "vid_id", ",", "frame_id", ")", ":", "\n", "        ", "ann_ids", "=", "self", ".", "ytvos", ".", "getAnnIds", "(", "vidIds", "=", "[", "vid_id", "]", ")", "\n", "ann_info", "=", "self", ".", "ytvos", ".", "loadAnns", "(", "ann_ids", ")", "\n", "return", "self", ".", "_parse_ann_info", "(", "ann_info", ",", "frame_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset._set_group_flag": [[139, 152], ["numpy.zeros", "range", "len", "len", "ytvos.YTVOSDataset.vid_ids.index"], "methods", ["None"], ["", "def", "_set_group_flag", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set flag according to image aspect ratio.\n\n        Images with aspect ratio greater than 1 will be set as group 1,\n        otherwise group 0.\n        \"\"\"", "\n", "self", ".", "flag", "=", "np", ".", "zeros", "(", "len", "(", "self", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "vid", ",", "_", "=", "self", ".", "img_ids", "[", "i", "]", "\n", "vid_idx", "=", "self", ".", "vid_ids", ".", "index", "(", "vid", ")", "\n", "vid_info", "=", "self", ".", "vid_infos", "[", "vid_idx", "]", "\n", "if", "vid_info", "[", "'width'", "]", "/", "vid_info", "[", "'height'", "]", ">", "1", ":", "\n", "                ", "self", ".", "flag", "[", "i", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.bbox_aug": [[153, 176], ["numpy.clip", "numpy.clip", "numpy.hstack().astype", "numpy.hstack", "numpy.random.rand", "numpy.random.rand"], "methods", ["None"], ["", "", "", "def", "bbox_aug", "(", "self", ",", "bbox", ",", "img_size", ")", ":", "\n", "        ", "assert", "self", ".", "aug_ref_bbox_param", "is", "not", "None", "\n", "center_off", "=", "self", ".", "aug_ref_bbox_param", "[", "0", "]", "\n", "size_perturb", "=", "self", ".", "aug_ref_bbox_param", "[", "1", "]", "\n", "\n", "n_bb", "=", "bbox", ".", "shape", "[", "0", "]", "\n", "# bbox center offset", "\n", "center_offs", "=", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "n_bb", ",", "2", ")", "-", "1", ")", "*", "center_off", "\n", "# bbox resize ratios", "\n", "resize_ratios", "=", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "n_bb", ",", "2", ")", "-", "1", ")", "*", "size_perturb", "+", "1", "\n", "# bbox: x1, y1, x2, y2", "\n", "centers", "=", "(", "bbox", "[", ":", ",", ":", "2", "]", "+", "bbox", "[", ":", ",", "2", ":", "]", ")", "/", "2.", "\n", "sizes", "=", "bbox", "[", ":", ",", "2", ":", "]", "-", "bbox", "[", ":", ",", ":", "2", "]", "\n", "new_centers", "=", "centers", "+", "center_offs", "*", "sizes", "\n", "new_sizes", "=", "sizes", "*", "resize_ratios", "\n", "new_x1y1", "=", "new_centers", "-", "new_sizes", "/", "2.", "\n", "new_x2y2", "=", "new_centers", "+", "new_sizes", "/", "2.", "\n", "c_min", "=", "[", "0", ",", "0", "]", "\n", "c_max", "=", "[", "img_size", "[", "1", "]", ",", "img_size", "[", "0", "]", "]", "\n", "new_x1y1", "=", "np", ".", "clip", "(", "new_x1y1", ",", "c_min", ",", "c_max", ")", "\n", "new_x2y2", "=", "np", ".", "clip", "(", "new_x2y2", ",", "c_min", ",", "c_max", ")", "\n", "bbox", "=", "np", ".", "hstack", "(", "(", "new_x1y1", ",", "new_x2y2", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.sample_ref": [[177, 194], ["ytvos.YTVOSDataset.vid_ids.index", "range", "range", "len", "len", "random.sample", "valid_samples.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "sample_ref", "(", "self", ",", "idx", ")", ":", "\n", "# sample another frame in the same sequence as reference", "\n", "        ", "vid", ",", "frame_id", "=", "idx", "\n", "vid_idx", "=", "self", ".", "vid_ids", ".", "index", "(", "vid", ")", "\n", "vid_info", "=", "self", ".", "vid_infos", "[", "vid_idx", "]", "\n", "sample_range", "=", "range", "(", "len", "(", "vid_info", "[", "'filenames'", "]", ")", ")", "\n", "valid_samples", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "-", "2", "*", "self", ".", "clip_frames", ",", "2", "*", "self", ".", "clip_frames", "+", "1", ")", ":", "\n", "# check if the frame id is valid", "\n", "            ", "ref_idx", "=", "(", "vid", ",", "i", "+", "frame_id", ")", "\n", "if", "i", "!=", "0", "and", "ref_idx", "in", "self", ".", "img_ids", ":", "\n", "                ", "valid_samples", ".", "append", "(", "i", "+", "frame_id", ")", "\n", "", "", "if", "len", "(", "valid_samples", ")", "==", "0", ":", "\n", "            ", "ref_frames", "=", "[", "frame_id", "]", "\n", "", "else", ":", "\n", "            ", "ref_frames", "=", "random", ".", "sample", "(", "valid_samples", ",", "1", ")", "\n", "", "return", "ref_frames", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.prepare_train_img": [[195, 300], ["ytvos.YTVOSDataset.vid_ids.index", "os.basename", "clip_frame_ids.sort", "numpy.stack", "utils.random_scale", "range", "numpy.stack", "imgs.copy.copy.copy", "range", "dict", "dict", "ytvos.YTVOSDataset.sample_ref", "imgs.copy.copy.append", "ytvos.YTVOSDataset.get_ann_info", "bboxes.append", "labels.append", "ids.append", "range", "len", "ytvos.YTVOSDataset.img_transform", "temp_imgs.append", "ytvos.YTVOSDataset.bbox_transform", "len", "ytvos.YTVOSDataset.bbox_transform", "range", "range", "range", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.imread", "len", "AssertionError", "masks.append", "bboxes_ignore.append", "len", "ytvos.YTVOSDataset.extra_aug", "numpy.random.rand", "numpy.hstack", "len", "ytvos.YTVOSDataset.bbox_aug", "len", "ytvos.YTVOSDataset.bbox_transform", "len", "ytvos.YTVOSDataset.mask_transform", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "mmcv.parallel.DataContainer", "utils.to_tensor", "os.join", "utils.to_tensor", "utils.to_tensor", "utils.to_tensor", "utils.to_tensor", "utils.to_tensor", "utils.to_tensor", "range", "numpy.array", "range", "range", "range", "range", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.random_scale", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.sample_ref", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.get_ann_info", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.bbox_aug", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor"], ["", "def", "prepare_train_img", "(", "self", ",", "idx", ")", ":", "\n", "# prepare a pair of image in a sequence", "\n", "        ", "vid", ",", "frame_id", "=", "idx", "\n", "vid_idx", "=", "self", ".", "vid_ids", ".", "index", "(", "vid", ")", "\n", "vid_info", "=", "self", ".", "vid_infos", "[", "vid_idx", "]", "\n", "basename", "=", "osp", ".", "basename", "(", "vid_info", "[", "'filenames'", "]", "[", "frame_id", "]", ")", "\n", "clip_frame_ids", "=", "self", ".", "sample_ref", "(", "idx", ")", "+", "[", "frame_id", "]", "\n", "clip_frame_ids", ".", "sort", "(", ")", "\n", "imgs", "=", "[", "]", "\n", "for", "frame_id", "in", "clip_frame_ids", ":", "\n", "            ", "imgs", ".", "append", "(", "mmcv", ".", "imread", "(", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "vid_info", "[", "'filenames'", "]", "[", "frame_id", "]", ")", ")", ")", "\n", "", "imgs", "=", "np", ".", "stack", "(", "imgs", ",", "axis", "=", "0", ")", "\n", "# load proposals if necessary", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "proposals", "=", "self", ".", "proposals", "[", "idx", "]", "[", ":", "self", ".", "num_max_proposals", "]", "\n", "# TODO: Handle empty proposals properly. Currently images with", "\n", "# no proposals are just ignored, but they can be used for", "\n", "# training in concept.", "\n", "if", "len", "(", "proposals", ")", "==", "0", ":", "\n", "                ", "return", "None", "\n", "", "if", "not", "(", "proposals", ".", "shape", "[", "1", "]", "==", "4", "or", "proposals", ".", "shape", "[", "1", "]", "==", "5", ")", ":", "\n", "                ", "raise", "AssertionError", "(", "\n", "'proposals should have shapes (n, 4) or (n, 5), '", "\n", "'but found {}'", ".", "format", "(", "proposals", ".", "shape", ")", ")", "\n", "", "if", "proposals", ".", "shape", "[", "1", "]", "==", "5", ":", "\n", "                ", "scores", "=", "proposals", "[", ":", ",", "4", ",", "None", "]", "\n", "proposals", "=", "proposals", "[", ":", ",", ":", "4", "]", "\n", "", "else", ":", "\n", "                ", "scores", "=", "None", "\n", "\n", "# load annotation of ref_frames", "\n", "", "", "bboxes", ",", "labels", ",", "ids", ",", "masks", ",", "bboxes_ignore", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "frame_id", "in", "clip_frame_ids", ":", "\n", "            ", "ann", "=", "self", ".", "get_ann_info", "(", "vid", ",", "frame_id", ")", "\n", "bboxes", ".", "append", "(", "ann", "[", "'bboxes'", "]", ")", "\n", "labels", ".", "append", "(", "ann", "[", "'labels'", "]", ")", "\n", "# obj ids attribute does not exist in current annotation", "\n", "# need to add it", "\n", "ids", ".", "append", "(", "ann", "[", "'obj_ids'", "]", ")", "\n", "if", "self", ".", "with_mask", ":", "\n", "                ", "masks", ".", "append", "(", "ann", "[", "'masks'", "]", ")", "\n", "# compute matching of reference frame with current frame", "\n", "# 0 denote there is no matching", "\n", "# gt_pids = [ref_ids.index(i)+1 if i in ref_ids else 0 for i in gt_ids]", "\n", "", "if", "self", ".", "with_crowd", ":", "\n", "                ", "bboxes_ignore", ".", "append", "(", "ann", "[", "'bboxes_ignore'", "]", ")", "\n", "\n", "# extra augmentation", "\n", "", "", "if", "self", ".", "extra_aug", "is", "not", "None", "and", "self", ".", "with_mask", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", ":", "\n", "                ", "imgs", "[", "i", "]", ",", "bboxes", "[", "i", "]", ",", "labels", "[", "i", "]", ",", "masks", "[", "i", "]", ",", "ids", "[", "i", "]", "=", "self", ".", "extra_aug", "(", "imgs", "[", "i", "]", ",", "bboxes", "[", "i", "]", ",", "labels", "[", "i", "]", ",", "masks", "[", "i", "]", ",", "ids", "[", "i", "]", ")", "\n", "\n", "# apply transforms", "\n", "", "", "flip", "=", "True", "if", "np", ".", "random", ".", "rand", "(", ")", "<", "self", ".", "flip_ratio", "else", "False", "\n", "img_scale", "=", "random_scale", "(", "self", ".", "img_scales", ",", "mode", "=", "'range_keep_ratio'", ")", "# sample a scale", "\n", "temp_imgs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", ":", "\n", "            ", "img_cur", ",", "img_shape", ",", "pad_shape", ",", "scale_factor", "=", "self", ".", "img_transform", "(", "\n", "imgs", "[", "i", "]", ",", "img_scale", ",", "flip", ",", "keep_ratio", "=", "self", ".", "resize_keep_ratio", ")", "\n", "temp_imgs", ".", "append", "(", "img_cur", ")", "\n", "", "imgs", "=", "np", ".", "stack", "(", "temp_imgs", ",", "axis", "=", "0", ")", "\n", "imgs", "=", "imgs", ".", "copy", "(", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "proposals", "=", "self", ".", "bbox_transform", "(", "proposals", ",", "img_shape", ",", "scale_factor", ",", "flip", ")", "\n", "proposals", "=", "np", ".", "hstack", "(", "[", "proposals", ",", "scores", "]", ")", "if", "scores", "is", "not", "None", "else", "proposals", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", ":", "\n", "            ", "bboxes", "[", "i", "]", "=", "self", ".", "bbox_transform", "(", "bboxes", "[", "i", "]", ",", "img_shape", ",", "pad_shape", ",", "scale_factor", ",", "flip", ")", "\n", "", "if", "self", ".", "aug_ref_bbox_param", "is", "not", "None", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", ":", "\n", "                ", "bboxes", "[", "i", "]", "=", "self", ".", "bbox_aug", "(", "bboxes", "[", "i", "]", ",", "img_shape", ")", "\n", "", "", "if", "self", ".", "with_crowd", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", ":", "\n", "                ", "bboxes_ignore", "[", "i", "]", "=", "self", ".", "bbox_transform", "(", "bboxes_ignore", "[", "i", "]", ",", "img_shape", ",", "pad_shape", ",", "scale_factor", ",", "flip", ")", "\n", "", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", ":", "\n", "                ", "masks", "[", "i", "]", "=", "self", ".", "mask_transform", "(", "masks", "[", "i", "]", ",", "pad_shape", ",", "img_scale", ",", "flip", ",", "keep_ratio", "=", "self", ".", "resize_keep_ratio", ")", "\n", "\n", "", "", "ori_shape", "=", "(", "vid_info", "[", "'height'", "]", ",", "vid_info", "[", "'width'", "]", ",", "3", ")", "\n", "img_meta", "=", "dict", "(", "\n", "ori_shape", "=", "ori_shape", ",", "\n", "img_shape", "=", "img_shape", ",", "\n", "pad_shape", "=", "pad_shape", ",", "\n", "video_id", "=", "vid", ",", "\n", "frame_id", "=", "frame_id", ",", "\n", "is_first", "=", "(", "frame_id", "==", "0", ")", ",", "\n", "scale_factor", "=", "scale_factor", ",", "\n", "flip", "=", "flip", ")", "\n", "\n", "data", "=", "dict", "(", "\n", "img", "=", "DC", "(", "to_tensor", "(", "imgs", ")", ",", "stack", "=", "True", ")", ",", "\n", "img_meta", "=", "DC", "(", "img_meta", ",", "cpu_only", "=", "True", ")", ",", "\n", "bboxes", "=", "DC", "(", "[", "to_tensor", "(", "bboxes", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", "]", ")", ",", "\n", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "data", "[", "'proposals'", "]", "=", "DC", "(", "to_tensor", "(", "proposals", ")", ")", "\n", "", "if", "self", ".", "with_label", ":", "\n", "            ", "data", "[", "'labels'", "]", "=", "DC", "(", "[", "to_tensor", "(", "labels", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", "]", ")", "\n", "", "if", "self", ".", "with_track", ":", "\n", "            ", "data", "[", "'ids'", "]", "=", "DC", "(", "[", "to_tensor", "(", "np", ".", "array", "(", "ids", "[", "i", "]", ")", ")", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", "]", ")", "\n", "", "if", "self", ".", "with_crowd", ":", "\n", "            ", "data", "[", "'bboxes_ignore'", "]", "=", "DC", "(", "[", "to_tensor", "(", "bboxes_ignore", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", "]", ")", "\n", "", "if", "self", ".", "with_mask", ":", "\n", "            ", "data", "[", "'masks'", "]", "=", "DC", "(", "[", "to_tensor", "(", "masks", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "clip_frame_ids", ")", ")", "]", ",", "cpu_only", "=", "True", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.prepare_test_img": [[301, 354], ["ytvos.YTVOSDataset.vid_ids.index", "mmcv.imread", "dict", "os.join", "ytvos.YTVOSDataset.img_transform", "utils.to_tensor", "dict", "ytvos.YTVOSDataset.prepare_test_img.prepare_single"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor"], ["", "def", "prepare_test_img", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Prepare an image for testing (multi-scale and flipping)\"\"\"", "\n", "vid", ",", "frame_id", "=", "idx", "\n", "vid_idx", "=", "self", ".", "vid_ids", ".", "index", "(", "vid", ")", "\n", "vid_info", "=", "self", ".", "vid_infos", "[", "vid_idx", "]", "\n", "img", "=", "mmcv", ".", "imread", "(", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "vid_info", "[", "'filenames'", "]", "[", "frame_id", "]", ")", ")", "\n", "proposal", "=", "None", "\n", "\n", "def", "prepare_single", "(", "img", ",", "frame_id", ",", "scale", ",", "flip", ",", "proposal", "=", "None", ")", ":", "\n", "            ", "_img", ",", "img_shape", ",", "pad_shape", ",", "scale_factor", "=", "self", ".", "img_transform", "(", "\n", "img", ",", "scale", ",", "flip", ",", "keep_ratio", "=", "self", ".", "resize_keep_ratio", ")", "\n", "_img", "=", "to_tensor", "(", "_img", ")", "\n", "_img_meta", "=", "dict", "(", "\n", "ori_shape", "=", "(", "vid_info", "[", "'height'", "]", ",", "vid_info", "[", "'width'", "]", ",", "3", ")", ",", "\n", "img_shape", "=", "img_shape", ",", "\n", "pad_shape", "=", "pad_shape", ",", "\n", "is_first", "=", "(", "frame_id", "==", "0", ")", ",", "\n", "video_id", "=", "vid", ",", "\n", "frame_id", "=", "frame_id", ",", "\n", "scale_factor", "=", "scale_factor", ",", "\n", "flip", "=", "flip", ")", "\n", "if", "proposal", "is", "not", "None", ":", "\n", "                ", "if", "proposal", ".", "shape", "[", "1", "]", "==", "5", ":", "\n", "                    ", "score", "=", "proposal", "[", ":", ",", "4", ",", "None", "]", "\n", "proposal", "=", "proposal", "[", ":", ",", ":", "4", "]", "\n", "", "else", ":", "\n", "                    ", "score", "=", "None", "\n", "", "_proposal", "=", "self", ".", "bbox_transform", "(", "proposal", ",", "img_shape", ",", "\n", "scale_factor", ",", "flip", ")", "\n", "_proposal", "=", "np", ".", "hstack", "(", "\n", "[", "_proposal", ",", "score", "]", ")", "if", "score", "is", "not", "None", "else", "_proposal", "\n", "_proposal", "=", "to_tensor", "(", "_proposal", ")", "\n", "", "else", ":", "\n", "                ", "_proposal", "=", "None", "\n", "", "return", "_img", ",", "_img_meta", ",", "_proposal", "\n", "\n", "", "imgs", "=", "[", "]", "\n", "img_metas", "=", "[", "]", "\n", "proposals", "=", "[", "]", "\n", "for", "scale", "in", "self", ".", "img_scales", ":", "\n", "            ", "_img", ",", "_img_meta", ",", "_proposal", "=", "prepare_single", "(", "\n", "img", ",", "frame_id", ",", "scale", ",", "False", ",", "proposal", ")", "\n", "imgs", ".", "append", "(", "DC", "(", "_img", ")", ")", "\n", "img_metas", ".", "append", "(", "DC", "(", "_img_meta", ",", "cpu_only", "=", "True", ")", ")", "\n", "proposals", ".", "append", "(", "_proposal", ")", "\n", "# if self.flip_ratio > 0:", "\n", "#     _img, _img_meta, _proposal = prepare_single(", "\n", "#         img, frame_id, scale, True, proposal)", "\n", "#     imgs.append(DC(_img))", "\n", "#     img_metas.append(DC(_img_meta, cpu_only=True))", "\n", "#     proposals.append(_proposal)", "\n", "", "data", "=", "dict", "(", "img", "=", "imgs", ",", "img_meta", "=", "img_metas", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset.sample_ref_test": [[355, 375], ["ytvos.YTVOSDataset.vid_ids.index", "range", "len", "valid_samples.append", "len", "valid_samples.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "sample_ref_test", "(", "self", ",", "idx", ")", ":", "\n", "# sample another frame in the same sequence as reference", "\n", "        ", "vid", ",", "frame_id", "=", "idx", "\n", "vid_idx", "=", "self", ".", "vid_ids", ".", "index", "(", "vid", ")", "\n", "vid_info", "=", "self", ".", "vid_infos", "[", "vid_idx", "]", "\n", "sample_range", "=", "range", "(", "len", "(", "vid_info", "[", "'filenames'", "]", ")", ")", "\n", "valid_samples", "=", "[", "]", "\n", "if", "frame_id", "==", "0", ":", "\n", "            ", "for", "i", "in", "sample_range", ":", "\n", "                ", "if", "len", "(", "valid_samples", ")", ">=", "self", ".", "eval_clip_frames", ":", "\n", "                    ", "break", "\n", "# check if the frame id is valid", "\n", "", "ref_idx", "=", "(", "vid", ",", "i", "+", "frame_id", ")", "\n", "if", "ref_idx", "in", "self", ".", "img_ids", ":", "\n", "                    ", "valid_samples", ".", "append", "(", "i", "+", "frame_id", "+", "1", ")", "\n", "", "", "", "else", ":", "\n", "            ", "ref_idx", "=", "(", "vid", ",", "frame_id", "+", "self", ".", "eval_clip_frames", ")", "\n", "if", "ref_idx", "in", "self", ".", "img_ids", ":", "\n", "                ", "valid_samples", ".", "append", "(", "frame_id", "+", "self", ".", "eval_clip_frames", ")", "\n", "", "", "return", "valid_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.ytvos.YTVOSDataset._parse_ann_info": [[376, 449], ["enumerate", "dict", "numpy.array", "numpy.array", "numpy.zeros", "numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros.append", "numpy.zeros.append", "gt_ids.append", "numpy.array.append", "gt_masks.append", "gt_mask_polys.append", "gt_poly_lens.extend", "ytvos.YTVOSDataset.ytvos.annToMask", "len", "len"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "_parse_ann_info", "(", "self", ",", "ann_info", ",", "frame_id", ",", "with_mask", "=", "True", ")", ":", "\n", "        ", "\"\"\"Parse bbox and mask annotation.\n\n        Args:\n            ann_info (list[dict]): Annotation info of an image.\n            with_mask (bool): Whether to parse mask annotations.\n\n        Returns:\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\n                labels, masks, mask_polys, poly_lens.\n        \"\"\"", "\n", "gt_bboxes", "=", "[", "]", "\n", "gt_labels", "=", "[", "]", "\n", "gt_ids", "=", "[", "]", "\n", "gt_bboxes_ignore", "=", "[", "]", "\n", "# Two formats are provided.", "\n", "# 1. mask: a binary map of the same size of the image.", "\n", "# 2. polys: each mask consists of one or several polys, each poly is a", "\n", "# list of float.", "\n", "if", "with_mask", ":", "\n", "            ", "gt_masks", "=", "[", "]", "\n", "gt_mask_polys", "=", "[", "]", "\n", "gt_poly_lens", "=", "[", "]", "\n", "", "for", "i", ",", "ann", "in", "enumerate", "(", "ann_info", ")", ":", "\n", "# each ann is a list of masks", "\n", "# ann:", "\n", "# bbox: list of bboxes", "\n", "# segmentation: list of segmentation", "\n", "# category_id", "\n", "# area: list of area", "\n", "            ", "bbox", "=", "ann", "[", "'bboxes'", "]", "[", "frame_id", "]", "\n", "area", "=", "ann", "[", "'areas'", "]", "[", "frame_id", "]", "\n", "segm", "=", "ann", "[", "'segmentations'", "]", "[", "frame_id", "]", "\n", "if", "bbox", "is", "None", ":", "continue", "\n", "x1", ",", "y1", ",", "w", ",", "h", "=", "bbox", "\n", "if", "area", "<=", "0", "or", "w", "<", "1", "or", "h", "<", "1", ":", "\n", "                ", "continue", "\n", "", "bbox", "=", "[", "x1", ",", "y1", ",", "x1", "+", "w", "-", "1", ",", "y1", "+", "h", "-", "1", "]", "\n", "if", "ann", "[", "'iscrowd'", "]", ":", "\n", "                ", "gt_bboxes_ignore", ".", "append", "(", "bbox", ")", "\n", "", "else", ":", "\n", "                ", "gt_bboxes", ".", "append", "(", "bbox", ")", "\n", "gt_ids", ".", "append", "(", "ann", "[", "'id'", "]", ")", "\n", "gt_labels", ".", "append", "(", "self", ".", "cat2label", "[", "ann", "[", "'category_id'", "]", "]", ")", "\n", "", "if", "with_mask", ":", "\n", "                ", "gt_masks", ".", "append", "(", "self", ".", "ytvos", ".", "annToMask", "(", "ann", ",", "frame_id", ")", ")", "\n", "mask_polys", "=", "[", "\n", "p", "for", "p", "in", "segm", "if", "len", "(", "p", ")", ">=", "6", "\n", "]", "# valid polygons have >= 3 points (6 coordinates)", "\n", "poly_lens", "=", "[", "len", "(", "p", ")", "for", "p", "in", "mask_polys", "]", "\n", "gt_mask_polys", ".", "append", "(", "mask_polys", ")", "\n", "gt_poly_lens", ".", "extend", "(", "poly_lens", ")", "\n", "", "", "if", "gt_bboxes", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "array", "(", "gt_bboxes", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "gt_labels", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "", "if", "gt_bboxes_ignore", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "array", "(", "gt_bboxes_ignore", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "", "ann", "=", "dict", "(", "\n", "bboxes", "=", "gt_bboxes", ",", "labels", "=", "gt_labels", ",", "obj_ids", "=", "gt_ids", ",", "bboxes_ignore", "=", "gt_bboxes_ignore", ")", "\n", "\n", "if", "with_mask", ":", "\n", "            ", "ann", "[", "'masks'", "]", "=", "gt_masks", "\n", "# poly format is not used in the current implementation", "\n", "ann", "[", "'mask_polys'", "]", "=", "gt_mask_polys", "\n", "ann", "[", "'poly_lens'", "]", "=", "gt_poly_lens", "\n", "", "return", "ann", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.repeat_dataset.RepeatDataset.__init__": [[6, 14], ["hasattr", "len", "numpy.tile"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "times", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "times", "=", "times", "\n", "self", ".", "CLASSES", "=", "dataset", ".", "CLASSES", "\n", "if", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", ":", "\n", "            ", "self", ".", "flag", "=", "np", ".", "tile", "(", "self", ".", "dataset", ".", "flag", ",", "times", ")", "\n", "\n", "", "self", ".", "_ori_len", "=", "len", "(", "self", ".", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.repeat_dataset.RepeatDataset.__getitem__": [[15, 17], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "dataset", "[", "idx", "%", "self", ".", "_ori_len", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.repeat_dataset.RepeatDataset.__len__": [[18, 20], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "times", "*", "self", ".", "_ori_len", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.to_tensor": [[19, 37], ["isinstance", "isinstance", "torch.from_numpy", "torch.from_numpy", "isinstance", "torch.tensor", "torch.tensor", "isinstance", "mmcv.is_str", "torch.LongTensor", "torch.LongTensor", "isinstance", "torch.FloatTensor", "torch.FloatTensor", "TypeError", "type"], "function", ["None"], ["def", "to_tensor", "(", "data", ")", ":", "\n", "    ", "\"\"\"Convert objects of various python types to :obj:`torch.Tensor`.\n    Supported types are: :class:`numpy.ndarray`, :class:`torch.Tensor`,\n    :class:`Sequence`, :class:`int` and :class:`float`.\n    \"\"\"", "\n", "if", "isinstance", "(", "data", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "data", "\n", "", "elif", "isinstance", "(", "data", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "data", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "Sequence", ")", "and", "not", "mmcv", ".", "is_str", "(", "data", ")", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "data", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "int", ")", ":", "\n", "        ", "return", "torch", ".", "LongTensor", "(", "[", "data", "]", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "float", ")", ":", "\n", "        ", "return", "torch", ".", "FloatTensor", "(", "[", "data", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'type {} cannot be converted to tensor.'", ".", "format", "(", "\n", "type", "(", "data", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.random_scale": [[39, 74], ["len", "numpy.random.randint", "numpy.random.randint", "ValueError", "max", "min", "min", "min", "numpy.random.randint", "max", "max", "max", "min", "int", "int", "numpy.random.rand", "min", "min", "numpy.random.randint", "max", "min"], "function", ["None"], ["", "", "def", "random_scale", "(", "img_scales", ",", "mode", "=", "'range'", ")", ":", "\n", "    ", "\"\"\"Randomly select a scale from a list of scales or scale ranges.\n    Args:\n        img_scales (list[tuple]): Image scale or scale range.\n        mode (str): \"range\" or \"value\".\n    Returns:\n        tuple: Sampled image scale.\n    \"\"\"", "\n", "num_scales", "=", "len", "(", "img_scales", ")", "\n", "if", "num_scales", "==", "1", ":", "# fixed scale is specified", "\n", "        ", "img_scale", "=", "img_scales", "[", "0", "]", "\n", "", "elif", "num_scales", "==", "2", ":", "# randomly sample a scale", "\n", "        ", "if", "mode", "==", "'range'", ":", "\n", "            ", "img_scale_long", "=", "[", "max", "(", "s", ")", "for", "s", "in", "img_scales", "]", "\n", "img_scale_short", "=", "[", "min", "(", "s", ")", "for", "s", "in", "img_scales", "]", "\n", "long_edge", "=", "np", ".", "random", ".", "randint", "(", "\n", "min", "(", "img_scale_long", ")", ",", "\n", "max", "(", "img_scale_long", ")", "+", "1", ")", "\n", "short_edge", "=", "np", ".", "random", ".", "randint", "(", "\n", "min", "(", "img_scale_short", ")", ",", "\n", "max", "(", "img_scale_short", ")", "+", "1", ")", "\n", "img_scale", "=", "(", "long_edge", ",", "short_edge", ")", "\n", "", "elif", "mode", "==", "'range_keep_ratio'", ":", "\n", "            ", "img_scale_long", "=", "[", "max", "(", "s", ")", "for", "s", "in", "img_scales", "]", "\n", "img_scale_short", "=", "[", "min", "(", "s", ")", "for", "s", "in", "img_scales", "]", "\n", "scale", "=", "np", ".", "random", ".", "rand", "(", "1", ")", "*", "(", "max", "(", "img_scale_long", ")", "/", "min", "(", "img_scale_long", ")", "-", "1", ")", "+", "1", "\n", "img_scale", "=", "(", "int", "(", "min", "(", "img_scale_long", ")", "*", "scale", ")", ",", "int", "(", "min", "(", "img_scale_short", ")", "*", "scale", ")", ")", "\n", "", "elif", "mode", "==", "'value'", ":", "\n", "            ", "img_scale", "=", "img_scales", "[", "np", ".", "random", ".", "randint", "(", "num_scales", ")", "]", "\n", "", "", "else", ":", "\n", "        ", "if", "mode", "!=", "'value'", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "'Only \"value\" mode supports more than 2 image scales'", ")", "\n", "", "img_scale", "=", "img_scales", "[", "np", ".", "random", ".", "randint", "(", "num_scales", ")", "]", "\n", "", "return", "img_scale", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.show_ann": [[76, 81], ["matplotlib.imshow", "matplotlib.axis", "coco.showAnns", "matplotlib.show", "mmcv.bgr2rgb"], "function", ["None"], ["", "def", "show_ann", "(", "coco", ",", "img", ",", "ann_info", ")", ":", "\n", "    ", "plt", ".", "imshow", "(", "mmcv", ".", "bgr2rgb", "(", "img", ")", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "coco", ".", "showAnns", "(", "ann_info", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.get_dataset": [[83, 124], ["vars", "isinstance", "isinstance", "range", "repeat_dataset.RepeatDataset", "len", "vars.keys", "isinstance", "len", "len", "copy.deepcopy", "mmcv.runner.obj_from_dict", "dsets.append", "len", "concat_dataset.ConcatDataset", "utils.get_dataset"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.get_dataset"], ["", "def", "get_dataset", "(", "data_cfg", ")", ":", "\n", "    ", "data_cfg", "=", "vars", "(", "data_cfg", ")", "\n", "if", "data_cfg", "[", "'type'", "]", "==", "'RepeatDataset'", ":", "\n", "        ", "return", "RepeatDataset", "(", "\n", "get_dataset", "(", "data_cfg", "[", "'dataset'", "]", ")", ",", "data_cfg", "[", "'times'", "]", ")", "\n", "\n", "", "if", "isinstance", "(", "data_cfg", "[", "'ann_file'", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "ann_files", "=", "data_cfg", "[", "'ann_file'", "]", "\n", "num_dset", "=", "len", "(", "ann_files", ")", "\n", "", "else", ":", "\n", "        ", "ann_files", "=", "[", "data_cfg", "[", "'ann_file'", "]", "]", "\n", "num_dset", "=", "1", "\n", "\n", "", "if", "'proposal_file'", "in", "data_cfg", ".", "keys", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "data_cfg", "[", "'proposal_file'", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "proposal_files", "=", "data_cfg", "[", "'proposal_file'", "]", "\n", "", "else", ":", "\n", "            ", "proposal_files", "=", "[", "data_cfg", "[", "'proposal_file'", "]", "]", "\n", "", "", "else", ":", "\n", "        ", "proposal_files", "=", "[", "None", "]", "*", "num_dset", "\n", "", "assert", "len", "(", "proposal_files", ")", "==", "num_dset", "\n", "\n", "if", "isinstance", "(", "data_cfg", "[", "'img_prefix'", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "img_prefixes", "=", "data_cfg", "[", "'img_prefix'", "]", "\n", "", "else", ":", "\n", "        ", "img_prefixes", "=", "[", "data_cfg", "[", "'img_prefix'", "]", "]", "*", "num_dset", "\n", "", "assert", "len", "(", "img_prefixes", ")", "==", "num_dset", "\n", "\n", "dsets", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_dset", ")", ":", "\n", "        ", "data_info", "=", "copy", ".", "deepcopy", "(", "data_cfg", ")", "\n", "data_info", "[", "'ann_file'", "]", "=", "ann_files", "[", "i", "]", "\n", "data_info", "[", "'proposal_file'", "]", "=", "proposal_files", "[", "i", "]", "\n", "data_info", "[", "'img_prefix'", "]", "=", "img_prefixes", "[", "i", "]", "\n", "dset", "=", "obj_from_dict", "(", "data_info", ",", "datasets", ")", "\n", "dsets", ".", "append", "(", "dset", ")", "\n", "", "if", "len", "(", "dsets", ")", ">", "1", ":", "\n", "        ", "dset", "=", "ConcatDataset", "(", "dsets", ")", "\n", "", "else", ":", "\n", "        ", "dset", "=", "dsets", "[", "0", "]", "\n", "", "return", "dset", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.prepare_data": [[126, 192], ["torch.stack", "torch.stack", "torch.no_grad", "torch.no_grad", "images_list[].size", "zip", "data_batch.keys", "torch.stack", "torch.stack", "utils.gradinator", "utils.gradinator", "allocation.append", "range", "utils.gradinator", "range", "gradinator.cuda", "utils.gradinator", "utils.gradinator", "range", "len", "torch.stack().to", "torch.stack().to", "gradinator.cuda", "len", "sum", "utils.gradinator", "utils.gradinator", "utils.gradinator", "utils.gradinator", "len", "torch.stack", "torch.stack", "[].to", "range", "[].to", "range", "[].to", "range", "[].to", "range"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator"], ["", "def", "prepare_data", "(", "data_batch", ",", "devices", ":", "list", "=", "None", ",", "allocation", ":", "list", "=", "None", ",", "batch_size", "=", "None", ",", "is_cuda", "=", "False", ",", "\n", "train_mode", "=", "True", ")", ":", "\n", "    ", "if", "train_mode", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "batch_size", "is", "None", ":", "\n", "                ", "batch_size", "=", "1", "\n", "", "if", "devices", "is", "None", ":", "\n", "                ", "devices", "=", "[", "'cuda:0'", "]", "if", "is_cuda", "else", "[", "'cpu'", "]", "\n", "", "if", "allocation", "is", "None", ":", "\n", "                ", "allocation", "=", "[", "batch_size", "//", "len", "(", "devices", ")", "]", "*", "(", "len", "(", "devices", ")", "-", "1", ")", "\n", "allocation", ".", "append", "(", "batch_size", "-", "sum", "(", "allocation", ")", ")", "# The rest might need more/less", "\n", "\n", "", "images_list", "=", "data_batch", "[", "'img'", "]", "\n", "bboxes_list", "=", "data_batch", "[", "'bboxes'", "]", "\n", "labels_list", "=", "data_batch", "[", "'labels'", "]", "\n", "masks_list", "=", "data_batch", "[", "'masks'", "]", "\n", "ids_list", "=", "data_batch", "[", "'ids'", "]", "\n", "images_meta_list", "=", "data_batch", "[", "'img_meta'", "]", "\n", "n_clip", "=", "images_list", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "\n", "split_images", ",", "split_bboxes", ",", "split_labels", ",", "split_masks", ",", "split_ids", ",", "split_images_meta", "=", "[", "[", "None", "for", "alloc", "in", "allocation", "]", "for", "_", "in", "range", "(", "6", ")", "]", "\n", "for", "idx", ",", "device", ",", "alloc", "in", "zip", "(", "range", "(", "len", "(", "devices", ")", ")", ",", "devices", ",", "allocation", ")", ":", "\n", "                ", "split_images", "[", "idx", "]", "=", "gradinator", "(", "torch", ".", "stack", "(", "images_list", "[", "alloc", "*", "idx", ":", "alloc", "*", "(", "idx", "+", "1", ")", "]", ",", "dim", "=", "0", ")", ".", "to", "(", "device", ")", ")", "\n", "for", "cur_idx", "in", "range", "(", "alloc", ")", ":", "\n", "                    ", "bboxes_list", "[", "alloc", "*", "idx", "+", "cur_idx", "]", "=", "[", "gradinator", "(", "\n", "bboxes_list", "[", "alloc", "*", "idx", "+", "cur_idx", "]", "[", "i", "]", ".", "to", "(", "device", ")", ")", "for", "i", "in", "range", "(", "n_clip", ")", "]", "\n", "labels_list", "[", "alloc", "*", "idx", "+", "cur_idx", "]", "=", "[", "gradinator", "(", "\n", "labels_list", "[", "alloc", "*", "idx", "+", "cur_idx", "]", "[", "i", "]", ".", "to", "(", "device", ")", ")", "for", "i", "in", "range", "(", "n_clip", ")", "]", "\n", "masks_list", "[", "alloc", "*", "idx", "+", "cur_idx", "]", "=", "[", "gradinator", "(", "masks_list", "[", "alloc", "*", "idx", "+", "cur_idx", "]", "[", "i", "]", ".", "to", "(", "device", ")", ")", "\n", "for", "i", "in", "range", "(", "n_clip", ")", "]", "\n", "ids_list", "[", "alloc", "*", "idx", "+", "cur_idx", "]", "=", "[", "gradinator", "(", "ids_list", "[", "alloc", "*", "idx", "+", "cur_idx", "]", "[", "i", "]", ".", "to", "(", "device", ")", ")", "\n", "for", "i", "in", "range", "(", "n_clip", ")", "]", "\n", "\n", "", "split_bboxes", "[", "idx", "]", "=", "bboxes_list", "[", "alloc", "*", "idx", ":", "alloc", "*", "(", "idx", "+", "1", ")", "]", "\n", "split_labels", "[", "idx", "]", "=", "labels_list", "[", "alloc", "*", "idx", ":", "alloc", "*", "(", "idx", "+", "1", ")", "]", "\n", "split_masks", "[", "idx", "]", "=", "masks_list", "[", "alloc", "*", "idx", ":", "alloc", "*", "(", "idx", "+", "1", ")", "]", "\n", "split_ids", "[", "idx", "]", "=", "ids_list", "[", "alloc", "*", "idx", ":", "alloc", "*", "(", "idx", "+", "1", ")", "]", "\n", "split_images_meta", "[", "idx", "]", "=", "images_meta_list", "[", "alloc", "*", "idx", ":", "alloc", "*", "(", "idx", "+", "1", ")", "]", "\n", "\n", "", "return", "split_images", ",", "split_bboxes", ",", "split_labels", ",", "split_masks", ",", "split_ids", ",", "split_images_meta", "\n", "", "", "else", ":", "\n", "# [0] is downsample image [1, 3, 384, 640], [1] is original image [1, 3, 736, 1280]", "\n", "        ", "images", "=", "torch", ".", "stack", "(", "[", "img", "[", "0", "]", ".", "data", "for", "img", "in", "data_batch", "[", "'img'", "]", "]", ",", "dim", "=", "0", ")", "\n", "images_meta", "=", "[", "img_meta", "[", "0", "]", ".", "data", "for", "img_meta", "in", "data_batch", "[", "'img_meta'", "]", "]", "\n", "if", "'ref_imgs'", "in", "data_batch", ".", "keys", "(", ")", ":", "\n", "            ", "ref_images", "=", "torch", ".", "stack", "(", "[", "ref_img", "[", "0", "]", ".", "data", "for", "ref_img", "in", "data_batch", "[", "'ref_imgs'", "]", "]", ",", "dim", "=", "0", ")", "\n", "ref_images_meta", "=", "[", "ref_img_meta", "[", "0", "]", ".", "data", "for", "ref_img_meta", "in", "data_batch", "[", "'ref_img_metas'", "]", "]", "\n", "", "else", ":", "\n", "            ", "ref_images", "=", "None", "\n", "ref_images_meta", "=", "None", "\n", "\n", "", "if", "is_cuda", ":", "\n", "            ", "images", "=", "gradinator", "(", "images", ".", "cuda", "(", ")", ")", "\n", "images_meta", "=", "images_meta", "\n", "if", "ref_images", "is", "not", "None", ":", "\n", "                ", "ref_images", "=", "gradinator", "(", "ref_images", ".", "cuda", "(", ")", ")", "\n", "ref_images_meta", "=", "ref_images_meta", "\n", "", "", "else", ":", "\n", "            ", "images", "=", "gradinator", "(", "images", ")", "\n", "images_meta", "=", "images_meta", "\n", "if", "ref_images", "is", "not", "None", ":", "\n", "                ", "ref_images", "=", "gradinator", "(", "ref_images", ")", "\n", "ref_images_meta", "=", "ref_images_meta", "\n", "\n", "", "", "return", "images", ",", "images_meta", ",", "ref_images", ",", "ref_images_meta", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.gradinator": [[194, 197], ["None"], "function", ["None"], ["", "", "def", "gradinator", "(", "x", ")", ":", "\n", "    ", "x", ".", "requires_grad", "=", "False", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.utils.enforce_size": [[199, 236], ["torch.no_grad", "torch.no_grad", "F.pad.size", "int", "int", "torch.interpolate", "F.pad.squeeze_", "torch.interpolate", "F.pad.squeeze_", "torch.pad", "torch.pad", "F.pad.unsqueeze", "F.pad.unsqueeze"], "function", ["None"], ["", "def", "enforce_size", "(", "img", ",", "targets", ",", "masks", ",", "num_crowds", ",", "new_w", ",", "new_h", ")", ":", "\n", "    ", "\"\"\" Ensures that the image is the given size without distorting aspect ratio. \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "_", ",", "h", ",", "w", "=", "img", ".", "size", "(", ")", "\n", "\n", "if", "h", "==", "new_h", "and", "w", "==", "new_w", ":", "\n", "            ", "return", "img", ",", "targets", ",", "masks", ",", "num_crowds", "\n", "\n", "# Resize the image so that it fits within new_w, new_h", "\n", "", "w_prime", "=", "new_w", "\n", "h_prime", "=", "h", "*", "new_w", "/", "w", "\n", "\n", "if", "h_prime", ">", "new_h", ":", "\n", "            ", "w_prime", "*=", "new_h", "/", "h_prime", "\n", "h_prime", "=", "new_h", "\n", "\n", "", "w_prime", "=", "int", "(", "w_prime", ")", "\n", "h_prime", "=", "int", "(", "h_prime", ")", "\n", "\n", "# Do all the resizing", "\n", "img", "=", "F", ".", "interpolate", "(", "img", ".", "unsqueeze", "(", "0", ")", ",", "(", "h_prime", ",", "w_prime", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "img", ".", "squeeze_", "(", "0", ")", "\n", "\n", "# Act like each object is a color channel", "\n", "masks", "=", "F", ".", "interpolate", "(", "masks", ".", "unsqueeze", "(", "0", ")", ",", "(", "h_prime", ",", "w_prime", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "masks", ".", "squeeze_", "(", "0", ")", "\n", "\n", "# Scale bounding boxes (this will put them in the top left corner in the case of padding)", "\n", "targets", "[", ":", ",", "[", "0", ",", "2", "]", "]", "*=", "(", "w_prime", "/", "new_w", ")", "\n", "targets", "[", ":", ",", "[", "1", ",", "3", "]", "]", "*=", "(", "h_prime", "/", "new_h", ")", "\n", "\n", "# Finally, pad everything to be the new_w, new_h", "\n", "pad_dims", "=", "(", "0", ",", "new_w", "-", "w_prime", ",", "0", ",", "new_h", "-", "h_prime", ")", "\n", "img", "=", "F", ".", "pad", "(", "img", ",", "pad_dims", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "masks", "=", "F", ".", "pad", "(", "masks", ",", "pad_dims", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "\n", "return", "img", ",", "targets", ",", "masks", ",", "num_crowds", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.loader.sampler.GroupSampler.__init__": [[13, 27], ["hasattr", "numpy.bincount", "enumerate", "dataset.flag.astype", "numpy.ones().astype", "int", "numpy.ones", "numpy.ceil", "len"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "samples_per_gpu", "=", "1", ",", "shuffle", "=", "True", ")", ":", "\n", "# assert hasattr(dataset, 'flag')", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "samples_per_gpu", "=", "samples_per_gpu", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "if", "hasattr", "(", "dataset", ",", "'flag'", ")", ":", "\n", "            ", "self", ".", "flag", "=", "dataset", ".", "flag", ".", "astype", "(", "np", ".", "int64", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "flag", "=", "np", ".", "ones", "(", "len", "(", "dataset", ")", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "", "self", ".", "group_sizes", "=", "np", ".", "bincount", "(", "self", ".", "flag", ")", "\n", "self", ".", "num_samples", "=", "0", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "self", ".", "num_samples", "+=", "int", "(", "np", ".", "ceil", "(", "\n", "size", "/", "self", ".", "samples_per_gpu", ")", ")", "*", "self", ".", "samples_per_gpu", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.loader.sampler.GroupSampler.__iter__": [[28, 52], ["enumerate", "numpy.concatenate", "torch.from_numpy().long", "iter", "numpy.concatenate", "numpy.concatenate.append", "numpy.concatenate", "len", "numpy.where", "len", "len", "numpy.random.shuffle", "torch.from_numpy", "int", "numpy.random.permutation", "numpy.ceil", "range", "len"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "indices", "=", "[", "]", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "if", "size", "==", "0", ":", "\n", "                ", "continue", "\n", "", "indice", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "i", ")", "[", "0", "]", "\n", "assert", "len", "(", "indice", ")", "==", "size", "\n", "num_extra", "=", "int", "(", "np", ".", "ceil", "(", "size", "/", "self", ".", "samples_per_gpu", ")", "\n", ")", "*", "self", ".", "samples_per_gpu", "-", "len", "(", "indice", ")", "\n", "if", "self", ".", "shuffle", ":", "\n", "                ", "np", ".", "random", ".", "shuffle", "(", "indice", ")", "\n", "", "indice", "=", "np", ".", "concatenate", "(", "[", "indice", ",", "indice", "[", ":", "num_extra", "]", "]", ")", "\n", "indices", ".", "append", "(", "indice", ")", "\n", "", "indices", "=", "np", ".", "concatenate", "(", "indices", ")", "\n", "if", "self", ".", "shuffle", ":", "\n", "            ", "indices", "=", "[", "\n", "indices", "[", "i", "*", "self", ".", "samples_per_gpu", ":", "(", "i", "+", "1", ")", "*", "self", ".", "samples_per_gpu", "]", "\n", "for", "i", "in", "np", ".", "random", ".", "permutation", "(", "\n", "range", "(", "len", "(", "indices", ")", "//", "self", ".", "samples_per_gpu", ")", ")", "\n", "]", "\n", "indices", "=", "np", ".", "concatenate", "(", "indices", ")", "\n", "", "indices", "=", "torch", ".", "from_numpy", "(", "indices", ")", ".", "long", "(", ")", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.loader.sampler.GroupSampler.__len__": [[53, 55], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.loader.sampler.DistributedGroupSampler.__init__": [[72, 97], ["hasattr", "numpy.bincount", "enumerate", "torch.distributed.get_world_size", "torch.distributed.get_rank", "int", "math.ceil"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "dataset", ",", "\n", "samples_per_gpu", "=", "1", ",", "\n", "num_replicas", "=", "None", ",", "\n", "rank", "=", "None", ")", ":", "\n", "        ", "if", "num_replicas", "is", "None", ":", "\n", "            ", "num_replicas", "=", "get_world_size", "(", ")", "\n", "", "if", "rank", "is", "None", ":", "\n", "            ", "rank", "=", "get_rank", "(", ")", "\n", "", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "samples_per_gpu", "=", "samples_per_gpu", "\n", "self", ".", "num_replicas", "=", "num_replicas", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "epoch", "=", "0", "\n", "\n", "assert", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", "\n", "self", ".", "flag", "=", "self", ".", "dataset", ".", "flag", "\n", "self", ".", "group_sizes", "=", "np", ".", "bincount", "(", "self", ".", "flag", ")", "\n", "\n", "self", ".", "num_samples", "=", "0", "\n", "for", "i", ",", "j", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "self", ".", "num_samples", "+=", "int", "(", "\n", "math", ".", "ceil", "(", "self", ".", "group_sizes", "[", "i", "]", "*", "1.0", "/", "self", ".", "samples_per_gpu", "/", "\n", "self", ".", "num_replicas", ")", ")", "*", "self", ".", "samples_per_gpu", "\n", "", "self", ".", "total_size", "=", "self", ".", "num_samples", "*", "self", ".", "num_replicas", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.loader.sampler.DistributedGroupSampler.__iter__": [[98, 133], ["torch.Generator", "torch.Generator.manual_seed", "enumerate", "iter", "len", "len", "torch.randperm().tolist", "indice[].tolist", "list", "range", "numpy.where", "len", "len", "torch.randperm", "torch.randperm", "int", "int", "len", "torch.randperm().tolist", "math.ceil", "torch.randperm", "int"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "# deterministically shuffle based on epoch", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", ")", "\n", "\n", "indices", "=", "[", "]", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "if", "size", ">", "0", ":", "\n", "                ", "indice", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "i", ")", "[", "0", "]", "\n", "assert", "len", "(", "indice", ")", "==", "size", "\n", "a", "=", "torch", ".", "randperm", "(", "int", "(", "size", ")", ",", "generator", "=", "g", ")", ".", "tolist", "(", ")", "\n", "indice", "=", "indice", "[", "torch", ".", "randperm", "(", "int", "(", "size", ")", ",", "generator", "=", "g", ")", ".", "tolist", "(", ")", "]", ".", "tolist", "(", ")", "\n", "extra", "=", "int", "(", "\n", "math", ".", "ceil", "(", "\n", "size", "*", "1.0", "/", "self", ".", "samples_per_gpu", "/", "self", ".", "num_replicas", ")", "\n", ")", "*", "self", ".", "samples_per_gpu", "*", "self", ".", "num_replicas", "-", "len", "(", "indice", ")", "\n", "indice", "+=", "indice", "[", ":", "extra", "]", "\n", "indices", "+=", "indice", "\n", "\n", "", "", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "\n", "indices", "=", "[", "\n", "indices", "[", "j", "]", "for", "i", "in", "list", "(", "\n", "torch", ".", "randperm", "(", "\n", "len", "(", "indices", ")", "//", "self", ".", "samples_per_gpu", ",", "generator", "=", "g", ")", ")", "\n", "for", "j", "in", "range", "(", "i", "*", "self", ".", "samples_per_gpu", ",", "(", "i", "+", "1", ")", "*", "\n", "self", ".", "samples_per_gpu", ")", "\n", "]", "\n", "\n", "# subsample", "\n", "offset", "=", "self", ".", "num_samples", "*", "self", ".", "rank", "\n", "indices", "=", "indices", "[", "offset", ":", "offset", "+", "self", ".", "num_samples", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.loader.sampler.DistributedGroupSampler.__len__": [[134, 136], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.loader.sampler.DistributedGroupSampler.set_epoch": [[137, 139], ["None"], "methods", ["None"], ["", "def", "set_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "epoch", "=", "epoch", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.loader.build_loader.build_dataloader": [[15, 42], ["torch.utils.data.DataLoader", "mmcv.runner.get_dist_info", "sampler.DistributedGroupSampler", "kwargs.get", "sampler.GroupSampler"], "function", ["None"], ["def", "build_dataloader", "(", "dataset", ",", "\n", "batch_size", ",", "\n", "num_workers", ",", "\n", "dist", "=", "True", ",", "\n", "shuffle_sampler", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "if", "dist", ":", "\n", "        ", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "sampler", "=", "DistributedGroupSampler", "(", "dataset", ",", "batch_size", ",", "world_size", ",", "\n", "rank", ")", "\n", "\n", "", "else", ":", "\n", "        ", "if", "not", "kwargs", ".", "get", "(", "'shuffle'", ",", "True", ")", ":", "\n", "            ", "sampler", "=", "None", "\n", "", "else", ":", "\n", "            ", "sampler", "=", "GroupSampler", "(", "dataset", ",", "batch_size", ",", "shuffle", "=", "shuffle_sampler", ")", "\n", "\n", "", "", "data_loader", "=", "DataLoader", "(", "\n", "dataset", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "sampler", "=", "sampler", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "collate_fn", "=", "collate", ",", "\n", "pin_memory", "=", "False", ",", "\n", "**", "kwargs", ")", "\n", "\n", "return", "data_loader", "\n", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.track_utils.split_bbox": [[5, 27], ["len", "len", "range", "range", "range", "range", "range", "range", "len", "torch.cat", "split_bboxes[].append", "split_bboxes_idx[].append", "bbox[].unsqueeze"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["def", "split_bbox", "(", "bbox", ",", "idx_bbox_ori", ",", "nums_bbox_per_layer", ")", ":", "\n", "    ", "num_layers", "=", "len", "(", "nums_bbox_per_layer", ")", "\n", "num_bboxes", "=", "len", "(", "idx_bbox_ori", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "num_layers", ")", ":", "\n", "        ", "nums_bbox_per_layer", "[", "i", "]", "=", "nums_bbox_per_layer", "[", "i", "-", "1", "]", "+", "nums_bbox_per_layer", "[", "i", "]", "\n", "\n", "", "split_bboxes", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_layers", ")", "]", "\n", "split_bboxes_idx", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_layers", ")", "]", "\n", "for", "i", "in", "range", "(", "num_bboxes", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_layers", ")", ":", "\n", "            ", "if", "idx_bbox_ori", "[", "i", "]", "<", "nums_bbox_per_layer", "[", "j", "]", ":", "\n", "                ", "split_bboxes", "[", "j", "]", ".", "append", "(", "bbox", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", ")", "\n", "split_bboxes_idx", "[", "j", "]", ".", "append", "(", "i", ")", "\n", "break", "\n", "\n", "", "", "", "for", "j", "in", "range", "(", "num_layers", ")", ":", "\n", "        ", "if", "len", "(", "split_bboxes", "[", "j", "]", ")", ">", "0", ":", "\n", "            ", "split_bboxes", "[", "j", "]", "=", "torch", ".", "cat", "(", "split_bboxes", "[", "j", "]", ")", "\n", "", "if", "j", ">", "0", ":", "\n", "            ", "split_bboxes_idx", "[", "0", "]", "+=", "split_bboxes_idx", "[", "j", "]", "\n", "\n", "", "", "return", "split_bboxes", ",", "split_bboxes_idx", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.track_utils.mask_iou": [[29, 36], ["torch.sum", "torch.sum", "torch.sum"], "function", ["None"], ["", "def", "mask_iou", "(", "mask1", ",", "mask2", ")", ":", "\n", "    ", "intersection", "=", "torch", ".", "sum", "(", "mask1", "*", "mask2", ",", "dim", "=", "(", "0", ",", "1", ")", ")", "\n", "area1", "=", "torch", ".", "sum", "(", "mask1", ",", "dim", "=", "(", "0", ",", "1", ")", ")", "\n", "area2", "=", "torch", ".", "sum", "(", "mask2", ",", "dim", "=", "(", "0", ",", "1", ")", ")", "\n", "union", "=", "(", "area1", "+", "area2", ")", "-", "intersection", "\n", "ret", "=", "intersection", "/", "union", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.display_gt_annotations.display_gt_ann": [[13, 38], ["cocoapi.PythonAPI.pycocotools.ytvos.YTVOS", "enumerate", "cat_id.append", "bboxes.append", "segm.append", "display_gt_annotations.display_masks"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.display_gt_annotations.display_masks"], ["def", "display_gt_ann", "(", "anno_file", ",", "img_prefix", ",", "save_path", ",", "mask_alpha", "=", "0.45", ")", ":", "\n", "    ", "ytvosGt", "=", "YTVOS", "(", "anno_file", ")", "\n", "anns", "=", "ytvosGt", ".", "anns", "\n", "videos_info", "=", "ytvosGt", ".", "dataset", "[", "'videos'", "]", "\n", "video_id", "=", "anns", "[", "3394", "]", "[", "'video_id'", "]", "\n", "cat_id", ",", "bboxes", ",", "segm", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "n_vid", "=", "0", "\n", "for", "idx", ",", "ann_id", "in", "enumerate", "(", "anns", ")", ":", "\n", "        ", "video_id_cur", "=", "anns", "[", "ann_id", "]", "[", "'video_id'", "]", "\n", "cat_id_cur", "=", "anns", "[", "ann_id", "]", "[", "'category_id'", "]", "\n", "bboxes_cur", "=", "anns", "[", "ann_id", "]", "[", "'bboxes'", "]", "\n", "segm_cur", "=", "anns", "[", "ann_id", "]", "[", "'segmentations'", "]", "\n", "if", "video_id_cur", "==", "video_id", ":", "\n", "            ", "cat_id", ".", "append", "(", "cat_id_cur", ")", "\n", "bboxes", ".", "append", "(", "bboxes_cur", ")", "\n", "segm", ".", "append", "(", "segm_cur", ")", "\n", "", "else", ":", "\n", "            ", "vid_info", "=", "videos_info", "[", "n_vid", "]", "\n", "h", ",", "w", "=", "vid_info", "[", "'height'", "]", ",", "vid_info", "[", "'width'", "]", "\n", "display_masks", "(", "n_vid", ",", "h", ",", "w", ",", "bboxes", ",", "segm", ",", "cat_id", ",", "vid_info", ",", "img_prefix", ",", "save_path", ",", "mask_alpha", ")", "\n", "n_vid", "+=", "1", "\n", "video_id", "=", "video_id_cur", "\n", "cat_id", "=", "[", "cat_id_cur", "]", "\n", "bboxes", "=", "[", "bboxes_cur", "]", "\n", "segm", "=", "[", "segm_cur", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.display_gt_annotations.display_masks": [[40, 102], ["range", "len", "print", "mmcv.imread", "numpy.clip", "torch.Tensor().cuda", "torch.Tensor().cuda.cpu().numpy", "range", "matplotlib.imshow", "matplotlib.axis", "matplotlib.title", "matplotlib.savefig", "matplotlib.clf", "os.join", "len", "len", "numpy.clip().astype", "numpy.stack", "numpy.clip().astype", "range", "str", "torch.Tensor", "torch.Tensor().cuda.cpu", "pycocotools.frPyObjects", "masks.append", "np.stack.append", "numpy.stack", "len", "inv_alph_masks[].cumprod", "masks_color_cumul.sum", "len", "pycocotools.decode", "numpy.array().reshape", "numpy.clip", "numpy.repeat", "inv_alph_masks.prod", "numpy.clip", "display_gt_annotations.get_color", "cv2.rectangle", "cv2.rectangle", "cv2.putText", "str", "int", "int", "int", "int", "cv2.getTextSize", "max", "max", "numpy.array", "max", "max", "int", "int", "display_gt_annotations.get_color", "int", "int", "len"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.get_color", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.get_color"], ["", "", "", "def", "display_masks", "(", "n_vid", ",", "h", ",", "w", ",", "bboxes", ",", "segm", ",", "cat_id", ",", "vid_info", ",", "img_prefix", ",", "save_path", ",", "mask_alpha", "=", "0.45", ")", ":", "\n", "    ", "for", "frame_id", "in", "range", "(", "len", "(", "bboxes", "[", "0", "]", ")", ")", ":", "\n", "        ", "print", "(", "n_vid", ",", "frame_id", ")", "\n", "img_numpy", "=", "mmcv", ".", "imread", "(", "osp", ".", "join", "(", "img_prefix", ",", "vid_info", "[", "'file_names'", "]", "[", "frame_id", "]", ")", ")", "\n", "img_numpy", "=", "img_numpy", "[", ":", ",", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "/", "255.", "\n", "img_numpy", "=", "np", ".", "clip", "(", "img_numpy", ",", "0", ",", "1", ")", "\n", "img_gpu", "=", "torch", ".", "Tensor", "(", "img_numpy", ")", ".", "cuda", "(", ")", "\n", "img_numpy", "=", "img_gpu", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# plot masks", "\n", "masks", ",", "colors", "=", "[", "]", ",", "[", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "bboxes", ")", ")", ":", "\n", "            ", "if", "segm", "[", "j", "]", "[", "frame_id", "]", "is", "not", "None", ":", "\n", "# polygons to rle, rle to binary mask", "\n", "                ", "mask_rle", "=", "mask_util", ".", "frPyObjects", "(", "segm", "[", "j", "]", "[", "frame_id", "]", ",", "h", ",", "w", ")", "\n", "masks", ".", "append", "(", "mask_util", ".", "decode", "(", "mask_rle", ")", ")", "\n", "colors", ".", "append", "(", "np", ".", "array", "(", "get_color", "(", "j", ")", ")", ".", "reshape", "(", "[", "1", ",", "1", ",", "3", "]", ")", ")", "\n", "\n", "", "", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "            ", "img_numpy", "=", "np", ".", "clip", "(", "img_numpy", "*", "255", ",", "0", ",", "255", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "", "else", ":", "\n", "            ", "masks", "=", "np", ".", "stack", "(", "masks", ",", "axis", "=", "0", ")", "[", ":", ",", ":", ",", ":", ",", "None", "]", "\n", "colors", "=", "np", ".", "stack", "(", "colors", ",", "axis", "=", "0", ")", "\n", "masks_color", "=", "np", ".", "repeat", "(", "masks", ",", "3", ",", "axis", "=", "3", ")", "*", "colors", "*", "mask_alpha", "\n", "inv_alph_masks", "=", "masks", "*", "(", "-", "mask_alpha", ")", "+", "1", "\n", "\n", "masks_color_summand", "=", "masks_color", "[", "0", "]", "\n", "if", "len", "(", "colors", ")", ">", "1", ":", "\n", "                ", "inv_alph_cumul", "=", "inv_alph_masks", "[", ":", "(", "len", "(", "colors", ")", "-", "1", ")", "]", ".", "cumprod", "(", "0", ")", "\n", "masks_color_cumul", "=", "masks_color", "[", "1", ":", "]", "*", "inv_alph_cumul", "\n", "masks_color_summand", "+=", "masks_color_cumul", ".", "sum", "(", "0", ")", "\n", "", "img_numpy", "=", "img_numpy", "*", "inv_alph_masks", ".", "prod", "(", "axis", "=", "0", ")", "+", "masks_color_summand", "\n", "img_numpy", "=", "np", ".", "clip", "(", "img_numpy", "*", "255", ",", "0", ",", "255", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "# img_numpy = cv2.cvtColor(img_numpy, cv2.COLOR_RGB2BGR)", "\n", "# img_numpy = cv2.cvtColor(np.float32(img_numpy), cv2.COLOR_RGB2GRAY)", "\n", "\n", "# plot bboxes and text", "\n", "for", "j", "in", "range", "(", "len", "(", "bboxes", ")", ")", ":", "\n", "                ", "if", "bboxes", "[", "j", "]", "[", "frame_id", "]", "is", "not", "None", ":", "\n", "                    ", "color", "=", "get_color", "(", "j", ")", "\n", "x1", ",", "y1", ",", "w", ",", "h", "=", "bboxes", "[", "j", "]", "[", "frame_id", "]", "\n", "# x1, x2 = cx - w / 2, cx + w / 2", "\n", "x2", ",", "y2", "=", "x1", "+", "w", ",", "y1", "+", "h", "\n", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "int", "(", "y1", ")", ",", "int", "(", "x1", ")", ",", "int", "(", "y2", ")", ",", "int", "(", "x2", ")", "\n", "cv2", ".", "rectangle", "(", "img_numpy", ",", "(", "x1", ",", "y1", ")", ",", "(", "x2", ",", "y2", ")", ",", "color", ",", "1", ")", "\n", "\n", "_class", "=", "cfg", ".", "classes", "[", "cat_id", "[", "j", "]", "-", "1", "]", "\n", "text_str", "=", "'%s'", "%", "_class", "\n", "font_face", "=", "cv2", ".", "FONT_HERSHEY_DUPLEX", "\n", "font_scale", "=", "1", "\n", "font_thickness", "=", "1", "\n", "text_w", ",", "text_h", "=", "cv2", ".", "getTextSize", "(", "text_str", ",", "font_face", ",", "font_scale", ",", "font_thickness", ")", "[", "0", "]", "\n", "text_pt", "=", "(", "max", "(", "x1", ",", "50", ")", ",", "max", "(", "y1", "-", "3", ",", "50", ")", ")", "\n", "text_color", "=", "[", "255", ",", "255", ",", "255", "]", "\n", "cv2", ".", "rectangle", "(", "img_numpy", ",", "(", "max", "(", "int", "(", "x1", ")", ",", "5", ")", ",", "max", "(", "int", "(", "y1", ")", ",", "5", ")", ")", ",", "(", "int", "(", "x1", "+", "text_w", ")", ",", "int", "(", "y1", "-", "text_h", "-", "4", ")", ")", ",", "color", ",", "-", "1", ")", "\n", "cv2", ".", "putText", "(", "img_numpy", ",", "text_str", ",", "text_pt", ",", "font_face", ",", "font_scale", ",", "text_color", ",", "font_thickness", ",", "\n", "cv2", ".", "LINE_AA", ")", "\n", "", "", "", "plt", ".", "imshow", "(", "img_numpy", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "title", "(", "str", "(", "[", "n_vid", ",", "frame_id", "]", ")", ")", "\n", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "save_path", ",", "str", "(", "[", "n_vid", ",", "frame_id", "]", ")", ",", "'.png'", "]", ")", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.display_gt_annotations.get_color": [[106, 115], ["len"], "function", ["None"], ["", "", "def", "get_color", "(", "j", ",", "norm", "=", "True", ")", ":", "\n", "    ", "global", "color_cache", "\n", "color_idx", "=", "(", "j", "*", "5", ")", "%", "len", "(", "cfg", ".", "COLORS", ")", "\n", "\n", "color", "=", "cfg", ".", "COLORS", "[", "color_idx", "]", "\n", "if", "norm", ":", "\n", "        ", "color", "=", "[", "color", "[", "0", "]", "/", "255.", ",", "color", "[", "1", "]", "/", "255.", ",", "color", "[", "2", "]", "/", "255.", "]", "\n", "\n", "", "return", "color", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.train_output_utils.display_train_output": [[14, 97], ["train_output_utils.setup_eval", "images.size", "range", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "conf_data[].max", "box_utils.decode", "eval.prep_display", "gt_masks[].type", "gt_pids[].type", "eval.prep_display", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.arange", "torch.arange", "torch.arange", "eval.prep_display", "matplotlib.imshow", "matplotlib.title", "matplotlib.savefig", "matplotlib.show", "matplotlib.imshow", "matplotlib.title", "matplotlib.savefig", "matplotlib.show", "matplotlib.imshow", "matplotlib.title", "matplotlib.savefig", "matplotlib.show", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.softmax", "torch.softmax", "len", "gt_pids[].tolist", "gt_class_last.append", "gt_class_last.append", "len", "str", "str", "str", "str", "str", "str", "str", "str", "str", "gt_pids[].tolist().index", "gt_pids[].tolist"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.train_output_utils.setup_eval", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.prep_display", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.prep_display", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.prep_display", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["def", "display_train_output", "(", "images", ",", "predictions", ",", "conf_t", ",", "pids_t", ",", "gt_bboxes", ",", "gt_labels", ",", "gt_masks", ",", "ref_images", ",", "ref_bboxes", ",", "\n", "gt_pids", ",", "img_meta", ",", "epoch", ",", "iteration", ",", "path", "=", "None", ")", ":", "\n", "    ", "setup_eval", "(", ")", "\n", "loc_data", "=", "predictions", "[", "'loc'", "]", "\n", "conf_data", "=", "predictions", "[", "'conf'", "]", "\n", "mask_data", "=", "predictions", "[", "'mask'", "]", "\n", "priors", "=", "predictions", "[", "'priors'", "]", "\n", "priors", "=", "priors", "[", "0", ",", ":", ",", ":", "]", "\n", "match_score", "=", "predictions", "[", "'track'", "]", "\n", "ref_boxes_n", "=", "predictions", "[", "'ref_boxes_n'", "]", "\n", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", ":", "\n", "        ", "proto_data", "=", "predictions", "[", "'proto'", "]", "\n", "\n", "", "batch_size", ",", "_", ",", "h", ",", "w", "=", "images", ".", "size", "(", ")", "\n", "\n", "if", "cfg", ".", "use_sigmoid_focal_loss", ":", "\n", "# Note: even though conf[0] exists, this mode doesn't train it so don't use it", "\n", "        ", "conf_data", "=", "torch", ".", "sigmoid", "(", "conf_data", ")", "\n", "", "elif", "cfg", ".", "use_objectness_score", ":", "\n", "# See focal_loss_sigmoid in multibox_loss.py for details", "\n", "        ", "objectness", "=", "torch", ".", "sigmoid", "(", "conf_data", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "conf_data", "[", ":", ",", ":", ",", "1", ":", "]", "=", "objectness", "[", ":", ",", ":", ",", "None", "]", "*", "F", ".", "softmax", "(", "conf_data", "[", ":", ",", ":", ",", "1", ":", "]", ",", "-", "1", ")", "\n", "conf_data", "[", ":", ",", ":", ",", "0", "]", "=", "1", "-", "objectness", "\n", "", "else", ":", "\n", "        ", "conf_data", "=", "F", ".", "softmax", "(", "conf_data", ",", "-", "1", ")", "\n", "\n", "# visualization", "\n", "", "pos", "=", "conf_t", ">", "0", "\n", "for", "batch_idx", "in", "range", "(", "batch_size", ")", ":", "\n", "# detection results", "\n", "        ", "dets_out", "=", "{", "}", "\n", "idx_pos", "=", "pos", "[", "batch_idx", ",", ":", "]", "==", "1", "\n", "\n", "dets_out", "[", "'score'", "]", ",", "class_pred", "=", "conf_data", "[", "batch_idx", ",", "idx_pos", ",", "1", ":", "]", ".", "max", "(", "dim", "=", "1", ")", "\n", "dets_out", "[", "'class_pred'", "]", "=", "class_pred", "+", "1", "# classes begins from 1", "\n", "dets_out", "[", "'class'", "]", "=", "conf_t", "[", "batch_idx", ",", "idx_pos", "]", "\n", "dets_out", "[", "'pids'", "]", "=", "pids_t", "[", "batch_idx", ",", "idx_pos", "]", "\n", "dets_out", "[", "'box'", "]", "=", "decode", "(", "loc_data", "[", "batch_idx", ",", "idx_pos", ",", ":", "]", ",", "priors", "[", "idx_pos", "]", ")", "\n", "dets_out", "[", "'mask'", "]", "=", "mask_data", "[", "batch_idx", ",", "idx_pos", ",", ":", "]", "\n", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", ":", "\n", "            ", "dets_out", "[", "'proto'", "]", "=", "proto_data", "[", "batch_idx", "]", "\n", "\n", "", "img_numpy", "=", "eval_script", ".", "prep_display", "(", "dets_out", ",", "images", "[", "batch_idx", "]", ",", "h", ",", "w", ",", "img_meta", "[", "batch_idx", "]", ",", "display_mode", "=", "'train'", ")", "\n", "\n", "# gt results", "\n", "dets_out", "=", "{", "}", "\n", "dets_out", "[", "'class'", "]", "=", "gt_labels", "[", "batch_idx", "]", "\n", "dets_out", "[", "'box'", "]", "=", "gt_bboxes", "[", "batch_idx", "]", "\n", "dets_out", "[", "'segm'", "]", "=", "gt_masks", "[", "batch_idx", "]", ".", "type", "(", "torch", ".", "cuda", ".", "FloatTensor", ")", "\n", "dets_out", "[", "'pids'", "]", "=", "gt_pids", "[", "batch_idx", "]", ".", "type", "(", "torch", ".", "cuda", ".", "LongTensor", ")", "\n", "\n", "img_numpy_gt", "=", "eval_script", ".", "prep_display", "(", "dets_out", ",", "images", "[", "batch_idx", "]", ",", "h", ",", "w", ",", "img_meta", "[", "batch_idx", "]", ")", "\n", "\n", "# gt results of the last frame", "\n", "dets_out", "=", "{", "}", "\n", "gt_class_last", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "ref_bboxes", "[", "batch_idx", "]", ")", "+", "1", ")", ":", "\n", "            ", "if", "i", "in", "gt_pids", "[", "batch_idx", "]", ".", "tolist", "(", ")", ":", "\n", "                ", "gt_class_last", ".", "append", "(", "gt_labels", "[", "batch_idx", "]", "[", "gt_pids", "[", "batch_idx", "]", ".", "tolist", "(", ")", ".", "index", "(", "i", ")", "]", ")", "\n", "", "else", ":", "\n", "                ", "gt_class_last", ".", "append", "(", "-", "1", ")", "\n", "", "", "dets_out", "[", "'class'", "]", "=", "torch", ".", "tensor", "(", "gt_class_last", ")", "\n", "\n", "dets_out", "[", "'box'", "]", "=", "ref_bboxes", "[", "batch_idx", "]", "\n", "dets_out", "[", "'pids'", "]", "=", "torch", ".", "arange", "(", "1", ",", "len", "(", "ref_bboxes", "[", "batch_idx", "]", ")", "+", "1", ")", "\n", "\n", "img_numpy_gt_last", "=", "eval_script", ".", "prep_display", "(", "dets_out", ",", "ref_images", "[", "batch_idx", "]", ",", "h", ",", "w", ",", "img_meta", "[", "batch_idx", "]", ")", "\n", "\n", "# show results and save figs", "\n", "plt", ".", "imshow", "(", "img_numpy", ")", "\n", "plt", ".", "title", "(", "'train'", ")", "\n", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "path", ",", "'out/'", ",", "str", "(", "epoch", ")", ",", "'_'", ",", "str", "(", "iteration", ")", ",", "'_'", ",", "str", "(", "batch_idx", ")", ",", "'_train'", ",", "'.png'", "]", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "plt", ".", "imshow", "(", "img_numpy_gt", ")", "\n", "plt", ".", "title", "(", "'gt'", ")", "\n", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "path", ",", "'out/'", ",", "str", "(", "epoch", ")", ",", "'_'", ",", "str", "(", "iteration", ")", ",", "'_'", ",", "str", "(", "batch_idx", ")", ",", "'_gt'", ",", "'.png'", "]", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "plt", ".", "imshow", "(", "img_numpy_gt_last", ")", "\n", "plt", ".", "title", "(", "'gt_last'", ")", "\n", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "path", ",", "'out/'", ",", "str", "(", "epoch", ")", ",", "'_'", ",", "str", "(", "iteration", ")", ",", "'_'", ",", "str", "(", "batch_idx", ")", ",", "'_gt_last'", ",", "'.png'", "]", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.train_output_utils.setup_eval": [[99, 102], ["eval.parse_args"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.parse_args"], ["", "", "def", "setup_eval", "(", ")", ":", "\n", "    ", "eval_script", ".", "parse_args", "(", "[", "'--no_bar'", ",", "\n", "'--output_json'", ",", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.get_color": [[15, 30], ["len", "torch.Tensor().to().float", "torch.Tensor().to().float", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor", "torch.Tensor"], "function", ["None"], ["def", "get_color", "(", "j", ",", "color_type", ",", "on_gpu", "=", "None", ",", "undo_transform", "=", "True", ")", ":", "\n", "    ", "global", "color_cache", "\n", "color_idx", "=", "color_type", "[", "j", "]", "*", "5", "%", "len", "(", "cfg", ".", "COLORS", ")", "\n", "\n", "if", "on_gpu", "is", "not", "None", "and", "color_idx", "in", "color_cache", "[", "on_gpu", "]", ":", "\n", "        ", "return", "color_cache", "[", "on_gpu", "]", "[", "color_idx", "]", "\n", "", "else", ":", "\n", "        ", "color", "=", "cfg", ".", "COLORS", "[", "color_idx", "]", "\n", "if", "not", "undo_transform", ":", "\n", "# The image might come in as RGB or BRG, depending", "\n", "            ", "color", "=", "(", "color", "[", "2", "]", ",", "color", "[", "1", "]", ",", "color", "[", "0", "]", ")", "\n", "", "if", "on_gpu", "is", "not", "None", ":", "\n", "            ", "color", "=", "torch", ".", "Tensor", "(", "color", ")", ".", "to", "(", "on_gpu", ")", ".", "float", "(", ")", "/", "255.", "\n", "color_cache", "[", "on_gpu", "]", "[", "color_idx", "]", "=", "color", "\n", "", "return", "color", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.display_box_shift": [[32, 95], ["os.path.join", "range", "torch.Tensor().cuda.byte().cpu().numpy", "range", "cv2.imwrite", "str", "os.path.exists", "os.makedirs", "torch.Tensor().cuda.squeeze().permute().cpu().numpy", "torch.Tensor().cuda", "torch.Tensor().cuda", "box.size", "mask_shift.unsqueeze().repeat.unsqueeze().repeat", "range", "torch.stack().sum", "torch.stack().sum", "conf[].max", "box.size", "visualization.get_color", "cv2.rectangle", "cv2.rectangle", "str", "numpy.ones", "torch.Tensor().cuda.size", "numpy.clip", "box.size", "get_color().view", "torch.stack().sum.append", "torch.Tensor().cuda.byte().cpu", "cv2.putText", "torch.Tensor().cuda.squeeze().permute().cpu", "numpy.array", "torch.Tensor", "torch.Tensor", "mask_shift.unsqueeze().repeat.unsqueeze", "mask_shift.unsqueeze().repeat.sum", "torch.stack", "torch.stack", "numpy.array", "visualization.get_color", "torch.Tensor().cuda.byte", "torch.Tensor().cuda.squeeze().permute", "classes[].item", "torch.Tensor().cuda.squeeze"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.get_color", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.get_color"], ["", "", "def", "display_box_shift", "(", "box", ",", "box_shift", ",", "mask_shift", "=", "None", ",", "img_meta", "=", "None", ",", "img_gpu", "=", "None", ",", "conf", "=", "None", ",", "mask_alpha", "=", "0.45", ")", ":", "\n", "    ", "if", "img_meta", "is", "None", ":", "\n", "        ", "video_id", ",", "frame_id", "=", "0", ",", "0", "\n", "", "else", ":", "\n", "        ", "video_id", ",", "frame_id", "=", "img_meta", "[", "'video_id'", "]", ",", "img_meta", "[", "'frame_id'", "]", "\n", "\n", "", "save_dir", "=", "'weights/YTVIS2019/weights_r50_new/box_shift/'", "\n", "save_dir", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "str", "(", "video_id", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "save_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_dir", ")", "\n", "", "path", "=", "''", ".", "join", "(", "[", "save_dir", ",", "'/'", ",", "str", "(", "frame_id", ")", ",", "'.png'", "]", ")", "\n", "\n", "# Make empty black image", "\n", "if", "img_gpu", "is", "None", ":", "\n", "        ", "h", ",", "w", "=", "384", ",", "640", "\n", "image", "=", "np", ".", "ones", "(", "(", "h", ",", "w", ",", "3", ")", ",", "np", ".", "uint8", ")", "*", "255", "\n", "", "else", ":", "\n", "\n", "        ", "h", ",", "w", "=", "img_gpu", ".", "size", "(", ")", "[", "1", ":", "]", "\n", "img_numpy", "=", "img_gpu", ".", "squeeze", "(", "0", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "img_numpy", "=", "img_numpy", "[", ":", ",", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "# To BRG", "\n", "img_numpy", "=", "(", "img_numpy", "*", "np", ".", "array", "(", "STD", ")", "+", "np", ".", "array", "(", "MEANS", ")", ")", "/", "255.0", "\n", "# img_numpy = img_numpy[:, :, (2, 1, 0)]  # To RGB", "\n", "img_numpy", "=", "np", ".", "clip", "(", "img_numpy", ",", "0", ",", "1", ")", "*", "255", "\n", "img_gpu", "=", "torch", ".", "Tensor", "(", "img_numpy", ")", ".", "cuda", "(", ")", "\n", "\n", "# plot pred bbox", "\n", "", "color_type", "=", "range", "(", "box", ".", "size", "(", "0", ")", ")", "\n", "if", "mask_shift", "is", "not", "None", ":", "\n", "# Undo padding for masks", "\n", "# gt_masks_cur = gt_masks_cur[:, :img_h, :img_w].float()", "\n", "        ", "mask_shift", "=", "mask_shift", ".", "unsqueeze", "(", "-", "1", ")", ".", "repeat", "(", "1", ",", "1", ",", "1", ",", "3", ")", "\n", "# This is 1 everywhere except for 1-mask_alpha where the mask is", "\n", "inv_alph_masks", "=", "mask_shift", ".", "sum", "(", "0", ")", "*", "(", "-", "mask_alpha", ")", "+", "1", "\n", "mask_shift_color", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "box", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "color", "=", "get_color", "(", "i", ",", "color_type", ",", "on_gpu", "=", "img_gpu", ".", "device", ".", "index", ")", ".", "view", "(", "1", ",", "1", ",", "3", ")", "\n", "mask_shift_color", ".", "append", "(", "mask_shift", "[", "i", "]", "*", "color", "*", "mask_alpha", ")", "\n", "", "mask_shift_color", "=", "torch", ".", "stack", "(", "mask_shift_color", ",", "dim", "=", "0", ")", ".", "sum", "(", "0", ")", "\n", "img_gpu", "=", "(", "img_gpu", "*", "inv_alph_masks", "+", "mask_shift_color", ")", "\n", "\n", "", "image", "=", "img_gpu", ".", "byte", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "if", "conf", "is", "not", "None", ":", "\n", "        ", "scores", ",", "classes", "=", "conf", "[", ":", ",", "1", ":", "]", ".", "max", "(", "dim", "=", "1", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "box", ".", "size", "(", "0", ")", ")", ":", "\n", "        ", "color", "=", "get_color", "(", "i", ",", "color_type", ")", "\n", "cv2", ".", "rectangle", "(", "image", ",", "(", "box", "[", "i", ",", "0", "]", "*", "w", ",", "box", "[", "i", ",", "1", "]", "*", "h", ")", ",", "(", "box", "[", "i", ",", "2", "]", "*", "w", ",", "box", "[", "i", ",", "3", "]", "*", "h", ")", ",", "color", ",", "2", ")", "\n", "\n", "cv2", ".", "rectangle", "(", "image", ",", "(", "box_shift", "[", "i", ",", "0", "]", "*", "w", ",", "box_shift", "[", "i", ",", "1", "]", "*", "h", ")", ",", "\n", "(", "box_shift", "[", "i", ",", "2", "]", "*", "w", ",", "box_shift", "[", "i", ",", "3", "]", "*", "h", ")", ",", "color", ",", "4", ")", "\n", "\n", "if", "conf", "is", "not", "None", ":", "\n", "            ", "text_str", "=", "'%s: %.2f'", "%", "(", "classes", "[", "i", "]", ".", "item", "(", ")", "+", "1", ",", "scores", "[", "i", "]", ")", "\n", "\n", "font_face", "=", "cv2", ".", "FONT_HERSHEY_DUPLEX", "\n", "font_scale", "=", "0.5", "\n", "font_thickness", "=", "1", "\n", "text_pt", "=", "(", "box_shift", "[", "i", ",", "0", "]", "*", "w", ",", "box_shift", "[", "i", ",", "1", "]", "*", "h", "-", "3", ")", "\n", "text_color", "=", "[", "255", ",", "255", ",", "255", "]", "\n", "cv2", ".", "putText", "(", "image", ",", "text_str", ",", "text_pt", ",", "font_face", ",", "font_scale", ",", "text_color", ",", "font_thickness", ",", "cv2", ".", "LINE_AA", ")", "\n", "", "", "cv2", ".", "imwrite", "(", "path", ",", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.display_feature_align_dcn": [[97, 173], ["detection[].size", "cv2.rectangle", "cv2.rectangle", "range", "cv2.imwrite", "torch.Tensor().cuda.squeeze().permute().cpu().numpy", "numpy.clip", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.tensor", "torch.tensor", "torch.tensor().repeat().view", "torch.tensor().repeat().view", "len", "cv2.circle", "cv2.circle", "cv2.circle", "numpy.ones", "torch.tensor", "torch.tensor", "torch.tensor().repeat().view", "torch.tensor().repeat().view", "torch.tensor", "torch.tensor", "torch.tensor().repeat().view", "torch.tensor().repeat().view", "torch.Tensor().cuda.squeeze().permute().cpu", "numpy.array", "torch.Tensor", "torch.Tensor", "torch.tensor().repeat", "torch.tensor().repeat", "o[].view", "o[].view", "str", "str", "numpy.array", "torch.tensor().repeat", "torch.tensor().repeat", "torch.tensor().repeat", "torch.tensor().repeat", "torch.Tensor().cuda.squeeze().permute", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "loc.detach", "torch.Tensor().cuda.squeeze"], "function", ["None"], ["", "def", "display_feature_align_dcn", "(", "detection", ",", "offset", ",", "loc_data", ",", "img_gpu", "=", "None", ",", "img_meta", "=", "None", ",", "use_yolo_regressors", "=", "False", ")", ":", "\n", "    ", "h", ",", "w", "=", "384", ",", "640", "\n", "# Make empty black image", "\n", "if", "img_gpu", "is", "None", ":", "\n", "        ", "image", "=", "np", ".", "ones", "(", "(", "h", ",", "w", ",", "3", ")", ",", "np", ".", "uint8", ")", "*", "255", "\n", "", "else", ":", "\n", "        ", "img_numpy", "=", "img_gpu", ".", "squeeze", "(", "0", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "img_numpy", "=", "img_numpy", "[", ":", ",", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "# To BRG", "\n", "img_numpy", "=", "(", "img_numpy", "*", "np", ".", "array", "(", "STD", ")", "+", "np", ".", "array", "(", "MEANS", ")", ")", "/", "255.0", "\n", "# img_numpy = img_numpy[:, :, (2, 1, 0)]  # To RGB", "\n", "img_numpy", "=", "np", ".", "clip", "(", "img_numpy", ",", "0", ",", "1", ")", "\n", "img_gpu", "=", "torch", ".", "Tensor", "(", "img_numpy", ")", ".", "cuda", "(", ")", "\n", "image", "=", "(", "img_gpu", "*", "255", ")", ".", "byte", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "n_dets", "=", "detection", "[", "'box'", "]", ".", "size", "(", "0", ")", "\n", "n", "=", "0", "\n", "p", "=", "detection", "[", "'priors'", "]", "[", "n", "]", "\n", "decoded_loc", "=", "detection", "[", "'box'", "]", "[", "n", "]", "\n", "id", "=", "detection", "[", "'bbox_idx'", "]", "[", "n", "]", "\n", "loc", "=", "loc_data", "[", "0", ",", "id", ",", ":", "]", "\n", "pixel_id", "=", "id", "//", "3", "\n", "prior_id", "=", "id", "%", "3", "\n", "if", "prior_id", "==", "0", ":", "\n", "        ", "o", "=", "offset", "[", "0", ",", ":", "18", ",", "pixel_id", "]", "\n", "ks_h", ",", "ks_w", "=", "3", ",", "3", "\n", "grid_w", "=", "torch", ".", "tensor", "(", "[", "-", "1", ",", "0", ",", "1", "]", "*", "ks_h", ")", "\n", "grid_h", "=", "torch", ".", "tensor", "(", "[", "[", "-", "1", "]", ",", "[", "0", "]", ",", "[", "1", "]", "]", ")", ".", "repeat", "(", "1", ",", "ks_w", ")", ".", "view", "(", "-", "1", ")", "\n", "", "elif", "prior_id", "==", "1", ":", "\n", "        ", "o", "=", "offset", "[", "0", ",", "18", ":", "48", ",", "pixel_id", "]", "\n", "ks_h", ",", "ks_w", "=", "3", ",", "5", "\n", "grid_w", "=", "torch", ".", "tensor", "(", "[", "-", "2", ",", "-", "1", ",", "0", ",", "1", ",", "2", "]", "*", "ks_h", ")", "\n", "grid_h", "=", "torch", ".", "tensor", "(", "[", "[", "-", "1", "]", ",", "[", "0", "]", ",", "[", "1", "]", "]", ")", ".", "repeat", "(", "1", ",", "ks_w", ")", ".", "view", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "o", "=", "offset", "[", "0", ",", "48", ":", ",", "pixel_id", "]", "\n", "ks_h", ",", "ks_w", "=", "5", ",", "3", "\n", "grid_w", "=", "torch", ".", "tensor", "(", "[", "-", "1", ",", "0", ",", "1", "]", "*", "ks_h", ")", "\n", "grid_h", "=", "torch", ".", "tensor", "(", "[", "[", "-", "2", "]", ",", "[", "-", "1", "]", ",", "[", "0", "]", ",", "[", "1", "]", ",", "[", "2", "]", "]", ")", ".", "repeat", "(", "1", ",", "ks_w", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "# thransfer the rectange to 9 points", "\n", "", "cx1", ",", "cy1", ",", "w1", ",", "h1", "=", "p", "[", "0", "]", ",", "p", "[", "1", "]", ",", "p", "[", "2", "]", ",", "p", "[", "3", "]", "\n", "dw1", "=", "grid_w", "*", "w1", "/", "(", "ks_w", "-", "1", ")", "+", "cx1", "\n", "dh1", "=", "grid_h", "*", "h1", "/", "(", "ks_h", "-", "1", ")", "+", "cy1", "\n", "\n", "dwh", "=", "p", "[", "2", ":", "]", "*", "(", "(", "loc", ".", "detach", "(", ")", "[", "2", ":", "]", "*", "0.2", ")", ".", "exp", "(", ")", "-", "1", ")", "\n", "# regressed bounding boxes", "\n", "new_dh1", "=", "dh1", "+", "loc", "[", "1", "]", "*", "p", "[", "3", "]", "*", "0.1", "+", "dwh", "[", "1", "]", "/", "ks_h", "*", "grid_h", "\n", "new_dw1", "=", "dw1", "+", "loc", "[", "0", "]", "*", "p", "[", "2", "]", "*", "0.1", "+", "dwh", "[", "0", "]", "/", "ks_w", "*", "grid_w", "\n", "# points after the offsets of dcn", "\n", "new_dh2", "=", "dh1", "+", "o", "[", ":", ":", "2", "]", ".", "view", "(", "-", "1", ")", "*", "0.5", "*", "p", "[", "3", "]", "\n", "new_dw2", "=", "dw1", "+", "o", "[", "1", ":", ":", "2", "]", ".", "view", "(", "-", "1", ")", "*", "0.5", "*", "p", "[", "2", "]", "\n", "\n", "# Create a named colour", "\n", "blue", "=", "[", "255", ",", "0", ",", "0", "]", "# bgr", "\n", "purple", "=", "[", "128", ",", "0", ",", "128", "]", "\n", "red", "=", "[", "0", ",", "0", ",", "255", "]", "\n", "\n", "# plot pred bbox", "\n", "cv2", ".", "rectangle", "(", "image", ",", "(", "decoded_loc", "[", "0", "]", "*", "w", ",", "decoded_loc", "[", "1", "]", "*", "h", ")", ",", "(", "decoded_loc", "[", "2", "]", "*", "w", ",", "decoded_loc", "[", "3", "]", "*", "h", ")", ",", "\n", "blue", ",", "2", ",", "lineType", "=", "8", ")", "\n", "\n", "# plot priors", "\n", "pxy1", "=", "p", "[", ":", "2", "]", "-", "p", "[", "2", ":", "]", "/", "2", "\n", "pxy2", "=", "p", "[", ":", "2", "]", "+", "p", "[", "2", ":", "]", "/", "2", "\n", "cv2", ".", "rectangle", "(", "image", ",", "(", "pxy1", "[", "0", "]", "*", "w", ",", "pxy1", "[", "1", "]", "*", "h", ")", ",", "(", "pxy2", "[", "0", "]", "*", "w", ",", "pxy2", "[", "1", "]", "*", "h", ")", ",", "\n", "purple", ",", "2", ",", "lineType", "=", "8", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "dw1", ")", ")", ":", "\n", "        ", "cv2", ".", "circle", "(", "image", ",", "(", "new_dw2", "[", "i", "]", "*", "w", ",", "new_dh2", "[", "i", "]", "*", "h", ")", ",", "radius", "=", "0", ",", "color", "=", "blue", ",", "thickness", "=", "10", ")", "\n", "cv2", ".", "circle", "(", "image", ",", "(", "new_dw1", "[", "i", "]", "*", "w", ",", "new_dh1", "[", "i", "]", "*", "h", ")", ",", "radius", "=", "0", ",", "color", "=", "blue", ",", "thickness", "=", "6", ")", "\n", "cv2", ".", "circle", "(", "image", ",", "(", "dw1", "[", "i", "]", "*", "w", ",", "dh1", "[", "i", "]", "*", "h", ")", ",", "radius", "=", "0", ",", "color", "=", "purple", ",", "thickness", "=", "6", ")", "\n", "\n", "", "if", "img_meta", "is", "not", "None", ":", "\n", "        ", "path", "=", "''", ".", "join", "(", "[", "'results/results_1024_2/FCB/'", ",", "str", "(", "img_meta", "[", "0", "]", "[", "'video_id'", "]", ")", ",", "'_'", ",", "\n", "str", "(", "img_meta", "[", "0", "]", "[", "'frame_id'", "]", ")", ",", "'.png'", "]", ")", "\n", "", "else", ":", "\n", "        ", "path", "=", "'results/results_1024_2/FCB/0.png'", "\n", "", "cv2", ".", "imwrite", "(", "path", ",", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.display_correlation_map_patch": [[175, 206], ["os.path.join", "x_corr.size", "int", "range", "str", "os.path.exists", "os.makedirs", "math.sqrt", "x_corr_cur.view", "x_show.permute().contiguous().view.permute().contiguous().view", "x_show.permute().contiguous().view.detach().cpu().numpy", "[].detach().cpu().numpy", "matplotlib.imshow", "matplotlib.savefig", "matplotlib.axis", "matplotlib.pcolormesh", "matplotlib.savefig", "matplotlib.clf", "x_show.permute().contiguous().view.permute().contiguous", "x_show.permute().contiguous().view.detach().cpu", "str", "str", "[].detach().cpu", "str", "str", "x_show.permute().contiguous().view.permute", "x_show.permute().contiguous().view.detach", "[].detach", "x_corr_cur.max"], "function", ["None"], ["", "def", "display_correlation_map_patch", "(", "x_corr", ",", "img_meta", "=", "None", ")", ":", "\n", "    ", "if", "img_meta", "is", "not", "None", ":", "\n", "        ", "video_id", ",", "frame_id", "=", "img_meta", "[", "'video_id'", "]", ",", "img_meta", "[", "'frame_id'", "]", "\n", "", "else", ":", "\n", "        ", "video_id", ",", "frame_id", "=", "0", ",", "0", "\n", "\n", "", "save_dir", "=", "'weights/YTVIS2019/weights_r50_new/box_shift/'", "\n", "save_dir", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "str", "(", "video_id", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "save_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_dir", ")", "\n", "# x_corr = x_corr[0, :, :18, :]**2", "\n", "", "bs", ",", "ch", ",", "h", ",", "w", "=", "x_corr", ".", "size", "(", ")", "\n", "# x_corr = F.normalize(x_corr, dim=1)", "\n", "r", "=", "int", "(", "sqrt", "(", "ch", ")", ")", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "        ", "x_corr_cur", "=", "x_corr", "[", "i", "]", "\n", "x_show", "=", "x_corr_cur", ".", "view", "(", "r", ",", "r", ",", "h", ",", "w", ")", "\n", "\n", "x_show", "=", "x_show", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", ".", "view", "(", "h", "*", "r", ",", "r", "*", "w", ")", "\n", "x_numpy", "=", "x_show", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "path_max", "=", "''", ".", "join", "(", "[", "save_dir", ",", "'/'", ",", "str", "(", "frame_id", ")", ",", "'_'", ",", "str", "(", "i", ")", ",", "'_max_corr_patch.png'", "]", ")", "\n", "max_corr", "=", "x_corr_cur", ".", "max", "(", "dim", "=", "0", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "plt", ".", "imshow", "(", "max_corr", ")", "\n", "plt", ".", "savefig", "(", "path_max", ")", "\n", "\n", "path", "=", "''", ".", "join", "(", "[", "save_dir", ",", "'/'", ",", "str", "(", "frame_id", ")", ",", "'_'", ",", "str", "(", "i", ")", ",", "'_corr_patch.png'", "]", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "pcolormesh", "(", "x_numpy", ")", "\n", "plt", ".", "savefig", "(", "path", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.display_correlation_map": [[208, 226], ["x_corr.size", "int", "x_corr.view().permute().contiguous", "x_show.view.view", "x_show.view.cpu().numpy", "matplotlib.axis", "matplotlib.pcolormesh", "matplotlib.savefig", "matplotlib.clf", "math.sqrt", "x_corr.view().permute", "x_show.view.cpu", "str", "str", "str", "x_corr.view"], "function", ["None"], ["", "", "def", "display_correlation_map", "(", "x_corr", ",", "img_meta", "=", "None", ",", "idx", "=", "0", ")", ":", "\n", "    ", "x_corr", "=", "x_corr", "[", ":", ",", ":", "36", "]", "\n", "bs", ",", "ch", ",", "h", ",", "w", "=", "x_corr", ".", "size", "(", ")", "\n", "r", "=", "int", "(", "sqrt", "(", "ch", ")", ")", "\n", "x_show", "=", "x_corr", ".", "view", "(", "r", ",", "r", ",", "h", ",", "w", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "x_show", "=", "x_show", ".", "view", "(", "h", "*", "r", ",", "r", "*", "w", ")", "\n", "x_numpy", "=", "(", "x_show", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "if", "img_meta", "is", "not", "None", ":", "\n", "        ", "path", "=", "''", ".", "join", "(", "[", "'results/results_1024_2/fea_ref/'", ",", "str", "(", "img_meta", "[", "0", "]", "[", "'video_id'", "]", ")", ",", "'_'", ",", "\n", "str", "(", "img_meta", "[", "0", "]", "[", "'frame_id'", "]", ")", ",", "'_'", ",", "str", "(", "idx", ")", ",", "'.png'", "]", ")", "\n", "", "else", ":", "\n", "        ", "path", "=", "'results/results_1024_2/fea_ref/0.png'", "\n", "\n", "", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "pcolormesh", "(", "x_numpy", ")", "\n", "plt", ".", "savefig", "(", "path", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.display_embedding_map": [[228, 257], ["matching_map_all.squeeze.squeeze", "matching_map_all.squeeze.size", "matching_map_all.squeeze.view().max", "matching_map_all.squeeze.permute().contiguous", "x_show.view.view", "x_show[].cpu().numpy", "matplotlib.axis", "matplotlib.pcolormesh", "matplotlib.savefig", "matplotlib.clf", "matching_map.squeeze().cpu().numpy", "matplotlib.axis", "matplotlib.imshow", "matplotlib.savefig", "matplotlib.clf", "mmcv.imflip", "matching_map_all.squeeze.view", "matching_map_all.squeeze.permute", "x_show[].cpu", "matching_map.squeeze().cpu", "str", "str", "str", "str", "str", "str", "matching_map.squeeze"], "function", ["None"], ["", "def", "display_embedding_map", "(", "matching_map_all", ",", "idx", ",", "img_meta", "=", "None", ")", ":", "\n", "    ", "if", "img_meta", "is", "not", "None", ":", "\n", "        ", "path", "=", "''", ".", "join", "(", "[", "'results/results_1227_1/embedding_map/'", ",", "str", "(", "img_meta", "[", "'video_id'", "]", ")", ",", "'_'", ",", "\n", "str", "(", "img_meta", "[", "'frame_id'", "]", ")", ",", "'_'", ",", "str", "(", "idx", ")", ",", "'.png'", "]", ")", "\n", "path2", "=", "''", ".", "join", "(", "[", "'results/results_1227_1/embedding_map/'", ",", "str", "(", "img_meta", "[", "'video_id'", "]", ")", ",", "'_'", ",", "\n", "str", "(", "img_meta", "[", "'frame_id'", "]", ")", ",", "'_'", ",", "str", "(", "idx", ")", ",", "'_m.png'", "]", ")", "\n", "\n", "", "else", ":", "\n", "        ", "path", "=", "'results/results_1227_1/embedding_map/0.png'", "\n", "path2", "=", "'results/results_1227_1/embedding_map/0_m.png'", "\n", "\n", "", "matching_map_all", "=", "matching_map_all", ".", "squeeze", "(", "0", ")", "\n", "r", ",", "r", ",", "h", ",", "w", "=", "matching_map_all", ".", "size", "(", ")", "\n", "# matching_map_mean = matching_map_all.view(r**2, h, w).mean(0)  # / (r**2)", "\n", "matching_map", ",", "_", "=", "matching_map_all", ".", "view", "(", "r", "**", "2", ",", "h", ",", "w", ")", ".", "max", "(", "0", ")", "# / (r**2)", "\n", "x_show", "=", "matching_map_all", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "x_show", "=", "x_show", ".", "view", "(", "h", "*", "r", ",", "r", "*", "w", ")", "\n", "x_numpy", "=", "(", "x_show", "[", "h", "*", "2", ":", "h", "*", "10", ",", "w", "*", "2", ":", "w", "*", "10", "]", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "pcolormesh", "(", "mmcv", ".", "imflip", "(", "x_numpy", ",", "direction", "=", "'vertical'", ")", ")", "\n", "plt", ".", "savefig", "(", "path", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n", "matching_map_numpy", "=", "matching_map", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "imshow", "(", "matching_map_numpy", ")", "\n", "plt", ".", "savefig", "(", "path2", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.display_shifted_masks": [[259, 275], ["shifted_masks.gt().float.size", "range", "shifted_masks.gt().float.gt().float", "shifted_masks[].cpu().numpy", "matplotlib.axis", "matplotlib.pcolormesh", "matplotlib.savefig", "matplotlib.clf", "mmcv.imflip", "shifted_masks.gt().float.gt", "shifted_masks[].cpu", "str", "str", "str"], "function", ["None"], ["", "def", "display_shifted_masks", "(", "shifted_masks", ",", "img_meta", "=", "None", ")", ":", "\n", "    ", "n", ",", "h", ",", "w", "=", "shifted_masks", ".", "size", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "img_meta", "is", "not", "None", ":", "\n", "            ", "path", "=", "''", ".", "join", "(", "[", "'results/results_1227_1/embedding_map/'", ",", "str", "(", "img_meta", "[", "'video_id'", "]", ")", ",", "'_'", ",", "\n", "str", "(", "img_meta", "[", "'frame_id'", "]", ")", ",", "'_'", ",", "str", "(", "i", ")", ",", "'_shifted_masks.png'", "]", ")", "\n", "\n", "", "else", ":", "\n", "            ", "path", "=", "'results/results_1227_1/fea_ref/0_shifted_mask.png'", "\n", "", "shifted_masks", "=", "shifted_masks", ".", "gt", "(", "0.3", ")", ".", "float", "(", ")", "\n", "shifted_masks_numpy", "=", "shifted_masks", "[", "i", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "pcolormesh", "(", "mmcv", ".", "imflip", "(", "shifted_masks_numpy", "*", "10", ",", "direction", "=", "'vertical'", ")", ")", "\n", "plt", ".", "savefig", "(", "path", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.interpolate.InterpolateModule.__init__": [[11, 16], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwdargs", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "kwdargs", "=", "kwdargs", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.interpolate.InterpolateModule.forward": [[17, 19], ["torch.interpolate", "torch.interpolate"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\t\t", "return", "F", ".", "interpolate", "(", "x", ",", "*", "self", ".", "args", ",", "**", "self", ".", "kwdargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.point_form": [[11, 22], ["torch.cat", "torch.cat"], "function", ["None"], ["@", "torch", ".", "jit", ".", "script", "\n", "def", "point_form", "(", "boxes", ")", ":", "\n", "    ", "\"\"\" Convert prior_boxes to (xmin, ymin, xmax, ymax)\n    representation for comparison to point form ground truth data.\n    Args:\n        boxes: (tensor) center-size default boxes from priorbox layers.\n    Return:\n        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.\n    \"\"\"", "\n", "return", "torch", ".", "cat", "(", "(", "boxes", "[", ":", ",", ":", "2", "]", "-", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", ",", "# xmin, ymin", "\n", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", ")", ",", "1", ")", "# xmax, ymax", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.center_size": [[24, 35], ["torch.cat", "torch.cat"], "function", ["None"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "center_size", "(", "boxes", ")", ":", "\n", "    ", "\"\"\" Convert prior_boxes to (cx, cy, w, h)\n    representation for comparison to center-size form ground truth data.\n    Args:\n        boxes: (tensor) point_form boxes\n    Return:\n        boxes: (tensor) Converted cx, cy, w, h form of boxes.\n    \"\"\"", "\n", "return", "torch", ".", "cat", "(", "(", "(", "boxes", "[", ":", ",", "2", ":", "]", "+", "boxes", "[", ":", ",", ":", "2", "]", ")", "/", "2", ",", "# cx, cy", "\n", "boxes", "[", ":", ",", "2", ":", "]", "-", "boxes", "[", ":", ",", ":", "2", "]", ")", ",", "1", ")", "# w, h", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.intersect": [[36, 58], ["box_a.size", "box_a.size", "box_b.size", "torch.min", "torch.min", "torch.max", "torch.max", "torch.clamp", "torch.clamp", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze", "box_b[].unsqueeze", "box_a[].unsqueeze", "box_b[].unsqueeze"], "function", ["None"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\" We resize both tensors to [A,B,2] without new malloc:\n    [A,2] -> [A,1,2] -> [A,B,2]\n    [B,2] -> [1,B,2] -> [A,B,2]\n    Then we compute the area of intersect between box_a and box_b.\n    Args:\n      box_a: (tensor) bounding boxes, Shape: [n,A,4]. [x,y,x2,y2]\n      box_b: (tensor) bounding boxes, Shape: [n,B,4]. [x,y,x2,y2]\n    Return:\n      (tensor) intersection area, Shape: [n,A,B].\n    \"\"\"", "\n", "n", "=", "box_a", ".", "size", "(", "0", ")", "\n", "\n", "A", "=", "box_a", ".", "size", "(", "1", ")", "\n", "B", "=", "box_b", ".", "size", "(", "1", ")", "\n", "max_xy", "=", "torch", ".", "min", "(", "(", "box_a", "[", ":", ",", ":", ",", "2", ":", "]", ")", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "n", ",", "A", ",", "B", ",", "2", ")", ",", "\n", "(", "box_b", "[", ":", ",", ":", ",", "2", ":", "]", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "n", ",", "A", ",", "B", ",", "2", ")", ")", "\n", "min_xy", "=", "torch", ".", "max", "(", "box_a", "[", ":", ",", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "n", ",", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "n", ",", "A", ",", "B", ",", "2", ")", ")", "\n", "inter", "=", "torch", ".", "clamp", "(", "(", "max_xy", "-", "min_xy", ")", ",", "min", "=", "0", ")", "\n", "return", "inter", "[", ":", ",", ":", ",", ":", ",", "0", "]", "*", "inter", "[", ":", ",", ":", ",", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.jaccard": [[60, 89], ["box_utils.intersect", "box_a.dim", "out.squeeze"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.intersect"], ["", "def", "jaccard", "(", "box_a", ",", "box_b", ",", "iscrowd", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.  Here we operate on\n    ground truth boxes and default boxes. If iscrowd=True, put the crowd in box_b.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4] [x1,y1, x2, y2]\n        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4] [x1,y1,x2,y2]\n    Return:\n        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]\n    \"\"\"", "\n", "use_batch", "=", "True", "\n", "if", "box_a", ".", "dim", "(", ")", "==", "2", ":", "\n", "        ", "use_batch", "=", "False", "\n", "box_a", "=", "box_a", "[", "None", ",", "...", "]", "\n", "box_b", "=", "box_b", "[", "None", ",", "...", "]", "\n", "\n", "# box_a, box_b = torch.clamp(box_a, min=0, max=1), torch.clamp(box_b, min=0, max=1)", "\n", "\n", "", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "*", "(", "box_a", "[", ":", ",", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "2", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", ":", ",", ":", ",", "2", "]", "-", "box_b", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "*", "(", "box_b", "[", ":", ",", ":", ",", "3", "]", "-", "box_b", "[", ":", ",", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "\n", "out", "=", "inter", "/", "area_a", "if", "iscrowd", "else", "inter", "/", "union", "\n", "return", "out", "if", "use_batch", "else", "out", ".", "squeeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.change": [[91, 117], ["priors.size", "gt.size", "[].expand", "[].expand", "gt[].expand", "priors[].expand", "torch.sqrt", "torch.sqrt"], "function", ["None"], ["", "def", "change", "(", "gt", ",", "priors", ")", ":", "\n", "    ", "\"\"\"\n    Compute the d_change metric proposed in Box2Pix:\n    https://lmb.informatik.uni-freiburg.de/Publications/2018/UB18/paper-box2pix.pdf\n    \n    Input should be in point form (xmin, ymin, xmax, ymax).\n\n    Output is of shape [num_gt, num_priors]\n    Note this returns -change so it can be a drop in replacement for \n    \"\"\"", "\n", "num_priors", "=", "priors", ".", "size", "(", "0", ")", "\n", "num_gt", "=", "gt", ".", "size", "(", "0", ")", "\n", "\n", "gt_w", "=", "(", "gt", "[", ":", ",", "2", "]", "-", "gt", "[", ":", ",", "0", "]", ")", "[", ":", ",", "None", "]", ".", "expand", "(", "num_gt", ",", "num_priors", ")", "\n", "gt_h", "=", "(", "gt", "[", ":", ",", "3", "]", "-", "gt", "[", ":", ",", "1", "]", ")", "[", ":", ",", "None", "]", ".", "expand", "(", "num_gt", ",", "num_priors", ")", "\n", "\n", "gt_mat", "=", "gt", "[", ":", ",", "None", ",", ":", "]", ".", "expand", "(", "num_gt", ",", "num_priors", ",", "4", ")", "\n", "pr_mat", "=", "priors", "[", "None", ",", ":", ",", ":", "]", ".", "expand", "(", "num_gt", ",", "num_priors", ",", "4", ")", "\n", "\n", "diff", "=", "gt_mat", "-", "pr_mat", "\n", "diff", "[", ":", ",", ":", ",", "0", "]", "/=", "gt_w", "\n", "diff", "[", ":", ",", ":", ",", "2", "]", "/=", "gt_w", "\n", "diff", "[", ":", ",", ":", ",", "1", "]", "/=", "gt_h", "\n", "diff", "[", ":", ",", ":", ",", "3", "]", "/=", "gt_h", "\n", "\n", "return", "-", "torch", ".", "sqrt", "(", "(", "diff", "**", "2", ")", ".", "sum", "(", "dim", "=", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.match": [[119, 198], ["overlaps.max", "range", "box_utils.encode", "box_utils.decode", "box_utils.point_form", "box_utils.jaccard", "box_utils.change", "keep_cla.sum", "torch.cross_entropy", "F.cross_entropy.mean", "overlaps.size", "overlaps.max", "best_prior_overlap.max", "F.cross_entropy.exp"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.encode", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.point_form", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.change"], ["", "def", "match", "(", "pos_thresh", ",", "neg_thresh", ",", "bbox", ",", "labels", ",", "ids", ",", "priors", ",", "loc_data", ",", "conf_data", ",", "loc_t", ",", "conf_t", ",", "idx_t", ",", "ids_t", ",", "idx", ")", ":", "\n", "    ", "\"\"\"Match each prior box with the ground truth box of the highest jaccard\n    overlap, encode the bounding boxes, then return the matched indices\n    corresponding to both confidence and location preds.\n    Args:\n        pos_thresh: (float) IoU > pos_thresh ==> positive.\n        neg_thresh: (float) IoU < neg_thresh ==> negative.\n        bbox: (tensor) Ground truth boxes, Shape: [num_obj, 4].  [x1, y1, x2, y2]\n        labels: (tensor) All the class labels for the image, Shape: [num_obj].\n        ids: (tensor) the instance ids of each gt bbox\n        priors: (tensor) Prior boxes from priorbox layers, Shape: [n_priors,4]. [cx,cy,w,h]\n        loc_data: (tensor) The predicted bbox regression coordinates for this batch. [cx,cy,w,h]\n        conf_data: (tensor) The predicted classification confidence scores for this batch. [num_obj, num_classes]\n        loc_t: (tensor) Tensor to be filled w/ endcoded location targets.\n        conf_t: (tensor) Tensor to be filled w/ matched indices for conf preds. Note: -1 means neutral.\n        idx_t: (tensor) Tensor to be filled w/ the index of the matched gt box for each prior.\n        ids_t: (tensor) Tensor to be filled w/ the ids of the matched gt instance for each prior.\n        idx: (int) current batch index.\n    Return:\n        The matched indices corresponding to 1)location and 2)confidence preds.\n    \"\"\"", "\n", "# decoded_priors => [x1, y1, x2, y2]", "\n", "decoded_priors", "=", "decode", "(", "loc_data", ",", "priors", ",", "cfg", ".", "use_yolo_regressors", ")", "if", "cfg", ".", "use_prediction_matching", "else", "point_form", "(", "priors", ")", "\n", "\n", "# Size [num_objects, num_priors]", "\n", "overlaps", "=", "jaccard", "(", "bbox", ",", "decoded_priors", ")", "if", "not", "cfg", ".", "use_change_matching", "else", "change", "(", "bbox", ",", "decoded_priors", ")", "\n", "\n", "# Size [num_priors] best ground truth for each prior", "\n", "best_truth_overlap", ",", "best_truth_idx", "=", "overlaps", ".", "max", "(", "0", ")", "\n", "\n", "# delete the bboxes that inlcude more than two instance with a high BIoU", "\n", "multi_instance_in_box", "=", "(", "overlaps", ">", "pos_thresh", "-", "0.1", ")", ".", "sum", "(", "0", ")", ">", "1", "\n", "best_truth_overlap", "[", "multi_instance_in_box", "]", "=", "(", "pos_thresh", "+", "neg_thresh", ")", "/", "2", "\n", "\n", "# consider classification scores for choosing positive samples", "\n", "keep_cla", "=", "best_truth_overlap", ">", "pos_thresh", "\n", "if", "keep_cla", ".", "sum", "(", ")", ">", "0", ":", "\n", "        ", "cla_score", "=", "F", ".", "cross_entropy", "(", "conf_data", "[", "keep_cla", "]", ",", "labels", "[", "best_truth_idx", "[", "keep_cla", "]", "]", ",", "reduction", "=", "'none'", ")", "\n", "cla_score", "=", "2", "/", "(", "1", "+", "cla_score", ".", "exp", "(", ")", ")", "# value in [0, 1]", "\n", "best_truth_overlap", "[", "keep_cla", "]", "=", "best_truth_overlap", "[", "keep_cla", "]", "+", "cla_score", "\n", "cla_thresh", "=", "cla_score", ".", "mean", "(", ")", "\n", "pos_thresh", "=", "pos_thresh", "+", "cla_thresh", "\n", "neg_thresh", "=", "neg_thresh", "+", "cla_thresh", "\n", "\n", "# We want to ensure that each gt gets used at least once so that we don't", "\n", "# waste any training data. In order to do that, find the max overlap anchor", "\n", "# with each gt, and force that anchor to use that gt.", "\n", "", "for", "_", "in", "range", "(", "overlaps", ".", "size", "(", "0", ")", ")", ":", "\n", "# Find j, the gt with the highest overlap with a prior", "\n", "# In effect, this will loop through overlaps.size(0) in a \"smart\" order,", "\n", "# always choosing the highest overlap first.", "\n", "        ", "best_prior_overlap", ",", "best_prior_idx", "=", "overlaps", ".", "max", "(", "1", ")", "\n", "j", "=", "best_prior_overlap", ".", "max", "(", "0", ")", "[", "1", "]", "\n", "\n", "# Find i, the highest overlap anchor with this gt", "\n", "i", "=", "best_prior_idx", "[", "j", "]", "\n", "\n", "# Set all other overlaps with i to be -1 so that no other gt uses it", "\n", "overlaps", "[", ":", ",", "i", "]", "=", "-", "1", "\n", "# Set all other overlaps with j to be -1 so that this loop never uses j again", "\n", "overlaps", "[", "j", ",", ":", "]", "=", "-", "1", "\n", "\n", "# Overwrite i's score to be 2 so it doesn't get thresholded ever", "\n", "best_truth_overlap", "[", "i", "]", "=", "2", "\n", "# Set the gt to be used for i to be j, overwriting whatever was there", "\n", "best_truth_idx", "[", "i", "]", "=", "j", "\n", "\n", "", "matches", "=", "bbox", "[", "best_truth_idx", "]", "# Shape: [num_priors,4]  [x1, y1, x2, y2]", "\n", "conf", "=", "labels", "[", "best_truth_idx", "]", "# Shape: [num_priors]", "\n", "conf", "[", "best_truth_overlap", "<", "pos_thresh", "]", "=", "-", "1", "# label as neutral", "\n", "conf", "[", "best_truth_overlap", "<", "neg_thresh", "]", "=", "0", "# label as background", "\n", "id_cur", "=", "ids", "[", "best_truth_idx", "]", "\n", "id_cur", "[", "best_truth_overlap", "<", "pos_thresh", "]", "=", "0", "# Only remain positive boxes for tracking", "\n", "\n", "loc", "=", "encode", "(", "matches", ",", "priors", ",", "cfg", ".", "use_yolo_regressors", ")", "# [cx, cy, w, h]", "\n", "loc_t", "[", "idx", "]", "=", "loc", "# [num_priors,4] encoded offsets to learn", "\n", "conf_t", "[", "idx", "]", "=", "conf", "# [num_priors] top class label for each prior", "\n", "idx_t", "[", "idx", "]", "=", "best_truth_idx", "# [num_priors] indices for lookup", "\n", "ids_t", "[", "idx", "]", "=", "id_cur", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.encode": [[199, 236], ["box_utils.center_size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.log", "torch.log", "torch.log", "torch.log", "datasets.cfg.use_yolo_regressors"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.center_size", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "encode", "(", "matched", ",", "priors", ",", "use_yolo_regressors", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Encode bboxes matched with each prior into the format\n    produced by the network. See decode for more details on\n    this format. Note that encode(decode(x, p), p) = x.\n    \n    Args:\n        - matched: A tensor of bboxes in point form with shape [num_priors, 4] [x,y,x2,y2]\n        - priors:  The tensor of all priors with shape [num_priors, 4] [cx,cy,w,h]\n    Return: A tensor with encoded relative coordinates in the format\n            outputted by the network (see decode). Size: [num_priors, 4]\n    \"\"\"", "\n", "\n", "if", "use_yolo_regressors", ":", "\n", "# Exactly the reverse of what we did in decode", "\n", "# In fact encode(decode(x, p), p) should be x", "\n", "        ", "boxes", "=", "center_size", "(", "matched", ")", "\n", "\n", "loc", "=", "torch", ".", "cat", "(", "(", "\n", "boxes", "[", ":", ",", ":", "2", "]", "-", "priors", "[", ":", ",", ":", "2", "]", ",", "\n", "torch", ".", "log", "(", "boxes", "[", ":", ",", "2", ":", "]", "/", "priors", "[", ":", ",", "2", ":", "]", ")", "\n", ")", ",", "1", ")", "\n", "", "else", ":", "\n", "        ", "variances", "=", "[", "0.1", ",", "0.2", "]", "\n", "\n", "# dist b/t match center and prior's center", "\n", "g_cxcy", "=", "(", "matched", "[", ":", ",", ":", "2", "]", "+", "matched", "[", ":", ",", "2", ":", "]", ")", "/", "2", "-", "priors", "[", ":", ",", ":", "2", "]", "\n", "# encode variance", "\n", "g_cxcy", "/=", "(", "variances", "[", "0", "]", "*", "priors", "[", ":", ",", "2", ":", "]", ")", "\n", "# match wh / prior wh", "\n", "g_wh", "=", "(", "matched", "[", ":", ",", "2", ":", "]", "-", "matched", "[", ":", ",", ":", "2", "]", ")", "/", "priors", "[", ":", ",", "2", ":", "]", "\n", "g_wh", "=", "torch", ".", "log", "(", "g_wh", ")", "/", "variances", "[", "1", "]", "\n", "# return target for smooth_l1_loss", "\n", "loc", "=", "torch", ".", "cat", "(", "[", "g_cxcy", ",", "g_wh", "]", ",", "1", ")", "# [num_priors,4]", "\n", "\n", "", "return", "loc", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode": [[237, 284], ["torch.cat", "torch.cat", "box_utils.point_form", "torch.cat", "torch.cat", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "datasets.cfg.use_yolo_regressors"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.point_form"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "decode", "(", "loc", ",", "priors", ",", "use_yolo_regressors", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Decode predicted bbox coordinates using the same scheme\n    employed by Yolov2: https://arxiv.org/pdf/1612.08242.pdf\n\n        b_x = (sigmoid(pred_x) - .5) / conv_w + prior_x\n        b_y = (sigmoid(pred_y) - .5) / conv_h + prior_y\n        b_w = prior_w * exp(loc_w)\n        b_h = prior_h * exp(loc_h)\n    \n    Note that loc is inputed as [(s(x)-.5)/conv_w, (s(y)-.5)/conv_h, w, h]\n    while priors are inputed as [x, y, w, h] where each coordinate\n    is relative to size of the image (even sigmoid(x)). We do this\n    in the network by dividing by the 'cell size', which is just\n    the size of the convouts.\n    \n    Also note that prior_x and prior_y are center coordinates which\n    is why we have to subtract .5 from sigmoid(pred_x and pred_y).\n    \n    Args:\n        - loc:    The predicted bounding boxes of size [num_priors, 4]\n        - priors: The priorbox coords with size [num_priors, 4]\n    \n    Returns: A tensor of decoded relative coordinates in point form \n             form with size [num_priors, 4]\n    \"\"\"", "\n", "\n", "if", "use_yolo_regressors", ":", "\n", "# Decoded boxes in center-size notation", "\n", "        ", "boxes", "=", "torch", ".", "cat", "(", "(", "\n", "loc", "[", ":", ",", ":", "2", "]", "+", "priors", "[", ":", ",", ":", "2", "]", ",", "\n", "priors", "[", ":", ",", "2", ":", "]", "*", "torch", ".", "exp", "(", "loc", "[", ":", ",", "2", ":", "]", ")", "\n", ")", ",", "1", ")", "\n", "\n", "boxes", "=", "point_form", "(", "boxes", ")", "\n", "", "else", ":", "\n", "        ", "variances", "=", "[", "0.1", ",", "0.2", "]", "\n", "\n", "boxes", "=", "torch", ".", "cat", "(", "(", "\n", "priors", "[", ":", ",", ":", "2", "]", "+", "loc", "[", ":", ",", ":", "2", "]", "*", "variances", "[", "0", "]", "*", "priors", "[", ":", ",", "2", ":", "]", ",", "\n", "priors", "[", ":", ",", "2", ":", "]", "*", "torch", ".", "exp", "(", "loc", "[", ":", ",", "2", ":", "]", "*", "variances", "[", "1", "]", ")", ")", ",", "1", ")", "\n", "boxes", "[", ":", ",", ":", "2", "]", "-=", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "\n", "\n", "# [x1, y1, x2, y2]", "\n", "", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.log_sum_exp": [[286, 295], ["x.data.max", "torch.log", "torch.log", "torch.sum", "torch.sum", "torch.exp", "torch.exp"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log"], ["", "def", "log_sum_exp", "(", "x", ")", ":", "\n", "    ", "\"\"\"Utility function for computing log_sum_exp while determining\n    This will be used to determine unaveraged confidence loss across\n    all examples in a batch.\n    Args:\n        x (Variable(tensor)): conf_preds from conf layers\n    \"\"\"", "\n", "x_max", "=", "x", ".", "data", ".", "max", "(", ")", "\n", "return", "torch", ".", "log", "(", "torch", ".", "sum", "(", "torch", ".", "exp", "(", "x", "-", "x_max", ")", ",", "1", ")", ")", "+", "x_max", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates": [[297, 317], ["torch.min", "torch.min", "torch.max", "torch.max", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "_x1.long.long", "_x2.long.long"], "function", ["None"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "sanitize_coordinates", "(", "_x1", ",", "_x2", ",", "img_size", ":", "int", ",", "padding", ":", "int", "=", "0", ",", "cast", ":", "bool", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Sanitizes the input coordinates so that x1 < x2, x1 != x2, x1 >= 0, and x2 <= image_size.\n    Also converts from relative to absolute coordinates and casts the results to long tensors.\n\n    If cast is false, the result won't be cast to longs.\n    Warning: this does things in-place behind the scenes so copy if necessary.\n    \"\"\"", "\n", "_x1", "=", "_x1", "*", "img_size", "\n", "_x2", "=", "_x2", "*", "img_size", "\n", "if", "cast", ":", "\n", "        ", "_x1", "=", "_x1", ".", "long", "(", ")", "\n", "_x2", "=", "_x2", ".", "long", "(", ")", "\n", "", "x1", "=", "torch", ".", "min", "(", "_x1", ",", "_x2", ")", "\n", "x2", "=", "torch", ".", "max", "(", "_x1", ",", "_x2", ")", "\n", "x1", "=", "torch", ".", "clamp", "(", "x1", "-", "padding", ",", "min", "=", "0", ")", "\n", "x2", "=", "torch", ".", "clamp", "(", "x2", "+", "padding", ",", "max", "=", "img_size", ")", "\n", "\n", "return", "x1", ",", "x2", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates_hw": [[319, 338], ["box_utils.sanitize_coordinates", "box_utils.sanitize_coordinates", "torch.stack", "torch.stack", "box.dim", "torch.stack.squeeze"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "sanitize_coordinates_hw", "(", "box", ",", "h", ":", "int", ",", "w", ":", "int", ")", ":", "\n", "    ", "'''\n    :param box: [bs, n, 4], [x1, y1, x2, y2]\n    :param h: height of image\n    :param w:\n    :return:\n    '''", "\n", "\n", "use_batch", "=", "True", "\n", "if", "box", ".", "dim", "(", ")", "==", "2", ":", "\n", "        ", "use_batch", "=", "False", "\n", "box", "=", "box", "[", "None", ",", "...", "]", "\n", "\n", "", "x1", ",", "x2", "=", "sanitize_coordinates", "(", "box", "[", ":", ",", ":", ",", "0", "]", ",", "box", "[", ":", ",", ":", ",", "2", "]", ",", "w", ",", "cast", "=", "False", ")", "\n", "y1", ",", "y2", "=", "sanitize_coordinates", "(", "box", "[", ":", ",", ":", ",", "1", "]", ",", "box", "[", ":", ",", ":", ",", "3", "]", ",", "h", ",", "cast", "=", "False", ")", "\n", "box_wo_norm", "=", "torch", ".", "stack", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "box_wo_norm", "if", "use_batch", "else", "box_wo_norm", ".", "squeeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.crop": [[340, 365], ["masks.size", "box_utils.sanitize_coordinates", "box_utils.sanitize_coordinates", "torch.arange().view().expand", "torch.arange().view().expand", "torch.arange().view().expand", "torch.arange().view().expand", "x1.view", "x2.view", "y1.view", "y2.view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "crop", "(", "masks", ",", "boxes", ",", "padding", ":", "int", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    \"Crop\" predicted masks by zeroing out everything not in the predicted bbox.\n    Vectorized by Chong (thanks Chong).\n\n    Args:\n        - masks should be a size [h, w, n] tensor of masks\n        - boxes should be a size [n, 4] tensor of bbox coords in relative point form [x1,y1,x2,y2]\n    \"\"\"", "\n", "h", ",", "w", ",", "n", "=", "masks", ".", "size", "(", ")", "\n", "x1", ",", "x2", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "2", "]", ",", "w", ",", "padding", ",", "cast", "=", "False", ")", "\n", "y1", ",", "y2", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "1", "]", ",", "boxes", "[", ":", ",", "3", "]", ",", "h", ",", "padding", ",", "cast", "=", "False", ")", "\n", "\n", "rows", "=", "torch", ".", "arange", "(", "w", ",", "device", "=", "masks", ".", "device", ",", "dtype", "=", "x1", ".", "dtype", ")", ".", "view", "(", "1", ",", "-", "1", ",", "1", ")", ".", "expand", "(", "h", ",", "w", ",", "n", ")", "\n", "cols", "=", "torch", ".", "arange", "(", "h", ",", "device", "=", "masks", ".", "device", ",", "dtype", "=", "x1", ".", "dtype", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "h", ",", "w", ",", "n", ")", "\n", "\n", "masks_left", "=", "rows", ">=", "x1", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "\n", "masks_right", "=", "rows", "<", "x2", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "\n", "masks_up", "=", "cols", ">=", "y1", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "\n", "masks_down", "=", "cols", "<", "y2", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "\n", "\n", "crop_mask", "=", "(", "masks_left", "*", "masks_right", "*", "masks_up", "*", "masks_down", ")", ".", "float", "(", ")", "\n", "\n", "return", "crop_mask", ",", "masks", "*", "crop_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.crop_sipmask": [[367, 417], ["masks00.size", "box_utils.sanitize_coordinates", "box_utils.sanitize_coordinates", "torch.arange().view().expand", "torch.arange().view().expand", "torch.arange().view().expand", "torch.arange().view().expand", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "crop_mask.float().detach.float().detach", "crop_mask.float().detach.float().detach", "crop_mask.float().detach.float().detach", "crop_mask.float().detach.float().detach", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.clamp.view", "crop_mask.float().detach.float", "torch.clamp.view", "crop_mask.float().detach.float", "torch.clamp.view", "crop_mask.float().detach.float", "torch.clamp.view", "crop_mask.float().detach.float", "torch.clamp.view", "torch.clamp.view", "torch.clamp.view", "torch.clamp.view", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.clamp.view", "torch.clamp.view", "torch.clamp.view", "torch.clamp.view", "torch.clamp.view", "torch.clamp.view", "torch.clamp.view", "torch.clamp.view"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates"], ["", "def", "crop_sipmask", "(", "masks00", ",", "masks01", ",", "masks10", ",", "masks11", ",", "boxes", ",", "padding", ":", "int", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    \"Crop\" predicted masks by zeroing out everything not in the predicted bbox.\n    Vectorized by Chong (thanks Chong).\n    Args:\n        - masks should be a size [h, w, n] tensor of masks\n        - boxes should be a size [n, 4] tensor of bbox coords in relative point form\n    \"\"\"", "\n", "\n", "h", ",", "w", ",", "n", "=", "masks00", ".", "size", "(", ")", "\n", "x1", ",", "x2", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "2", "]", ",", "w", ",", "padding", ",", "cast", "=", "False", ")", "\n", "y1", ",", "y2", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "1", "]", ",", "boxes", "[", ":", ",", "3", "]", ",", "h", ",", "padding", ",", "cast", "=", "False", ")", "\n", "rows", "=", "torch", ".", "arange", "(", "w", ",", "device", "=", "masks00", ".", "device", ",", "dtype", "=", "boxes", ".", "dtype", ")", ".", "view", "(", "1", ",", "-", "1", ",", "1", ")", ".", "expand", "(", "h", ",", "w", ",", "n", ")", "\n", "cols", "=", "torch", ".", "arange", "(", "h", ",", "device", "=", "masks00", ".", "device", ",", "dtype", "=", "boxes", ".", "dtype", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "h", ",", "w", ",", "n", ")", "\n", "\n", "xc", "=", "(", "x1", "+", "x2", ")", "/", "2", "\n", "yc", "=", "(", "y1", "+", "y2", ")", "/", "2", "\n", "x1", "=", "torch", ".", "clamp", "(", "x1", ",", "min", "=", "0", ",", "max", "=", "w", "-", "1", ")", "\n", "y1", "=", "torch", ".", "clamp", "(", "y1", ",", "min", "=", "0", ",", "max", "=", "h", "-", "1", ")", "\n", "x2", "=", "torch", ".", "clamp", "(", "x2", ",", "min", "=", "0", ",", "max", "=", "w", "-", "1", ")", "\n", "y2", "=", "torch", ".", "clamp", "(", "y2", ",", "min", "=", "0", ",", "max", "=", "h", "-", "1", ")", "\n", "xc", "=", "torch", ".", "clamp", "(", "xc", ",", "min", "=", "0", ",", "max", "=", "w", "-", "1", ")", "\n", "yc", "=", "torch", ".", "clamp", "(", "yc", ",", "min", "=", "0", ",", "max", "=", "h", "-", "1", ")", "\n", "\n", "##x1,y1,xc,yc", "\n", "crop_mask", "=", "(", "rows", ">=", "x1", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "rows", "<", "xc", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "cols", ">=", "y1", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "\n", "cols", "<", "yc", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "\n", "crop_mask", "=", "crop_mask", ".", "float", "(", ")", ".", "detach", "(", ")", "\n", "\n", "masks00", "=", "masks00", "*", "crop_mask", "\n", "\n", "##xc,y1,x2,yc", "\n", "crop_mask", "=", "(", "rows", ">=", "xc", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "rows", "<", "x2", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "cols", ">=", "y1", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "\n", "cols", "<", "yc", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "\n", "crop_mask", "=", "crop_mask", ".", "float", "(", ")", ".", "detach", "(", ")", "\n", "masks01", "=", "masks01", "*", "crop_mask", "\n", "\n", "crop_mask", "=", "(", "rows", ">=", "x1", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "rows", "<", "xc", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "cols", ">=", "yc", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "\n", "cols", "<", "y2", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "\n", "crop_mask", "=", "crop_mask", ".", "float", "(", ")", ".", "detach", "(", ")", "\n", "masks10", "=", "masks10", "*", "crop_mask", "\n", "\n", "crop_mask", "=", "(", "rows", ">=", "xc", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "rows", "<", "x2", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "cols", ">=", "yc", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "&", "(", "\n", "cols", "<", "y2", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", ")", "\n", "crop_mask", "=", "crop_mask", ".", "float", "(", ")", ".", "detach", "(", ")", "\n", "masks11", "=", "masks11", "*", "crop_mask", "\n", "\n", "masks", "=", "masks00", "+", "masks01", "+", "masks10", "+", "masks11", "\n", "\n", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.index2d": [[419, 433], ["[].expand_as", "[].view", "idx.size", "idx.size", "torch.arange", "torch.arange", "src.view", "idx.size", "idx.view"], "function", ["None"], ["", "def", "index2d", "(", "src", ",", "idx", ")", ":", "\n", "    ", "\"\"\"\n    Indexes a tensor by a 2d index.\n\n    In effect, this does\n        out[i, j] = src[i, idx[i, j]]\n    \n    Both src and idx should have the same size.\n    \"\"\"", "\n", "\n", "offs", "=", "torch", ".", "arange", "(", "idx", ".", "size", "(", "0", ")", ",", "device", "=", "idx", ".", "device", ")", "[", ":", ",", "None", "]", ".", "expand_as", "(", "idx", ")", "\n", "idx", "=", "idx", "+", "offs", "*", "idx", ".", "size", "(", "1", ")", "\n", "\n", "return", "src", ".", "view", "(", "-", "1", ")", "[", "idx", ".", "view", "(", "-", "1", ")", "]", ".", "view", "(", "idx", ".", "size", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.mask_iou": [[435, 448], ["mask1.view.view", "mask2.view.view", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.zeros", "torch.zeros", "mask1.view.size", "mask2.view.size", "mask2.view.t", "keep.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum().unsqueeze.t"], "function", ["None"], ["", "def", "mask_iou", "(", "mask1", ",", "mask2", ")", ":", "\n", "# [n1, h, w], [n2, h, w]", "\n", "    ", "n1", ",", "n2", "=", "mask1", ".", "size", "(", "0", ")", ",", "mask2", ".", "size", "(", "0", ")", "\n", "mask1", "=", "mask1", ".", "view", "(", "n1", ",", "-", "1", ")", "\n", "mask2", "=", "mask2", ".", "view", "(", "n2", ",", "-", "1", ")", "\n", "intersection", "=", "mask1", "@", "mask2", ".", "t", "(", ")", "# [n1, n2]", "\n", "area1", "=", "torch", ".", "sum", "(", "mask1", ",", "dim", "=", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", "# [n1, 1]", "\n", "area2", "=", "torch", ".", "sum", "(", "mask2", ",", "dim", "=", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", "# [n2, 1]", "\n", "union", "=", "(", "area1", "+", "area2", ".", "t", "(", ")", ")", "-", "intersection", "\n", "mask_ious", "=", "intersection", "/", "union", "\n", "keep", "=", "union", "==", "0", "\n", "mask_ious", "[", "keep", "]", "=", "torch", ".", "zeros", "(", "1", ",", "keep", ".", "sum", "(", ")", ",", "device", "=", "mask1", ".", "device", ")", "\n", "return", "mask_ious", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.DIoU": [[450, 471], ["det_bbox.size", "prev_det_bbox.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "det_bbox_c.view().repeat.view().repeat", "prev_det_bbox_c.view().repeat.view().repeat", "det_bbox[].view().repeat", "prev_det_bbox[].view().repeat", "det_bbox[].view().repeat", "prev_det_bbox[].view().repeat", "det_bbox_c.view().repeat.view", "prev_det_bbox_c.view().repeat.view", "det_bbox[].view", "prev_det_bbox[].view", "det_bbox[].view", "prev_det_bbox[].view", "torch.cat.max", "torch.cat.min", "torch.cat.max", "torch.cat.min"], "function", ["None"], ["", "def", "DIoU", "(", "det_bbox", ",", "prev_det_bbox", ")", ":", "\n", "    ", "n_dets", "=", "det_bbox", ".", "size", "(", "0", ")", "\n", "n_prev", "=", "prev_det_bbox", ".", "size", "(", "0", ")", "\n", "# calculate the diagonal length of the smallest enclosing box", "\n", "x_label", "=", "torch", ".", "cat", "(", "[", "det_bbox", "[", ":", ",", ":", ":", "2", "]", ".", "view", "(", "-", "1", ",", "1", ",", "2", ")", ".", "repeat", "(", "1", ",", "n_prev", ",", "1", ")", ",", "\n", "prev_det_bbox", "[", ":", ",", ":", ":", "2", "]", ".", "view", "(", "1", ",", "-", "1", ",", "2", ")", ".", "repeat", "(", "n_dets", ",", "1", ",", "1", ")", "]", ",", "dim", "=", "2", ")", "# [n_pos, n_dets, 4]", "\n", "y_label", "=", "torch", ".", "cat", "(", "[", "det_bbox", "[", ":", ",", "1", ":", ":", "2", "]", ".", "view", "(", "-", "1", ",", "1", ",", "2", ")", ".", "repeat", "(", "1", ",", "n_prev", ",", "1", ")", ",", "\n", "prev_det_bbox", "[", ":", ",", "1", ":", ":", "2", "]", ".", "view", "(", "1", ",", "-", "1", ",", "2", ")", ".", "repeat", "(", "n_dets", ",", "1", ",", "1", ")", "]", ",", "dim", "=", "2", ")", "# [n_pos, n_dets, 4]", "\n", "c2", "=", "(", "x_label", ".", "max", "(", "dim", "=", "2", ")", "[", "0", "]", "-", "x_label", ".", "min", "(", "dim", "=", "2", ")", "[", "0", "]", ")", "**", "2", "+", "(", "\n", "y_label", ".", "max", "(", "dim", "=", "2", ")", "[", "0", "]", "-", "y_label", ".", "min", "(", "dim", "=", "2", ")", "[", "0", "]", ")", "**", "2", "# [n_pos, n_dets]", "\n", "\n", "# get the distance between centers of pred_bbox and gt_bbox", "\n", "det_bbox_c", "=", "det_bbox", "[", ":", ",", ":", "2", "]", "/", "2", "+", "det_bbox", "[", ":", ",", "2", ":", "]", "/", "2", "\n", "prev_det_bbox_c", "=", "prev_det_bbox", "[", ":", ",", ":", "2", "]", "/", "2", "+", "prev_det_bbox", "[", ":", ",", "2", ":", "]", "/", "2", "\n", "det_bbox_c", "=", "det_bbox_c", ".", "view", "(", "-", "1", ",", "1", ",", "2", ")", ".", "repeat", "(", "1", ",", "n_prev", ",", "1", ")", "# [n_pos, n_dets, 2]", "\n", "prev_det_bbox_c", "=", "prev_det_bbox_c", ".", "view", "(", "1", ",", "-", "1", ",", "2", ")", ".", "repeat", "(", "n_dets", ",", "1", ",", "1", ")", "# [n_pos, n_dets, 2]", "\n", "d2", "=", "(", "(", "det_bbox_c", "-", "prev_det_bbox_c", ")", "**", "2", ")", ".", "sum", "(", "dim", "=", "2", ")", "# [n_pos, n_dets]", "\n", "# print('bbox_iou:', bbox_ious)", "\n", "# print('new_iou:', d2/c2)", "\n", "\n", "return", "d2", "/", "c2", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.gaussian_kl_divergence": [[473, 488], ["torch.log", "torch.log", "torch.log", "torch.log"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log"], ["", "def", "gaussian_kl_divergence", "(", "bbox_gt", ",", "bbox_pred", ")", ":", "\n", "    ", "cwh_gt", "=", "bbox_gt", "[", ":", ",", "2", ":", "]", "-", "bbox_gt", "[", ":", ",", ":", "2", "]", "\n", "cwh_pred", "=", "bbox_pred", "[", ":", ",", "2", ":", "]", "-", "bbox_pred", "[", ":", ",", ":", "2", "]", "\n", "\n", "mu_gt", "=", "bbox_gt", "[", ":", ",", ":", "2", "]", "+", "0.5", "*", "cwh_gt", "\n", "mu_pred", "=", "bbox_pred", "[", ":", ",", ":", "2", "]", "+", "0.5", "*", "cwh_pred", "\n", "sigma_gt", "=", "cwh_gt", "/", "4.0", "\n", "sigma_pred", "=", "cwh_pred", "/", "4.0", "\n", "\n", "kl_div0", "=", "(", "sigma_pred", "/", "sigma_gt", ")", "**", "2", "+", "(", "mu_pred", "-", "mu_gt", ")", "**", "2", "/", "sigma_gt", "**", "2", "-", "1", "+", "2", "*", "torch", ".", "log", "(", "sigma_gt", "/", "sigma_pred", ")", "\n", "kl_div1", "=", "(", "sigma_gt", "/", "sigma_pred", ")", "**", "2", "+", "(", "mu_gt", "-", "mu_pred", ")", "**", "2", "/", "sigma_pred", "**", "2", "-", "1", "+", "2", "*", "torch", ".", "log", "(", "\n", "sigma_pred", "/", "sigma_gt", ")", "\n", "loss", "=", "0.25", "*", "(", "kl_div0", "+", "kl_div1", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_rel_coord": [[9, 41], ["det_bbox.size", "det_bbox.new", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.meshgrid", "torch.meshgrid", "range", "torch.cat", "torch.cat", "torch.round", "torch.round", "torch.round", "torch.round", "torch.exp", "torch.exp", "rel_coord.append", "y_grid.float().unsqueeze().repeat", "cy.view", "x_grid.float().unsqueeze().repeat", "cx.view", "torch.exp.unsqueeze", "y_grid.float().unsqueeze", "x_grid.float().unsqueeze", "y_grid.float", "x_grid.float"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["def", "generate_rel_coord", "(", "det_bbox", ",", "mask_h", ",", "mask_w", ",", "sigma_scale", "=", "2", ")", ":", "\n", "    ", "'''\n    :param det_box: the centers of pos bboxes ==> [cx, cy]\n    :param mask_h: height of pred_mask\n    :param mask_w: weight of pred_mask\n    :return: rel_coord ==> [num_pos, mask_h, mask_w, 2]\n    '''", "\n", "\n", "# generate relative coordinates", "\n", "num_pos", "=", "det_bbox", ".", "size", "(", "0", ")", "\n", "det_bbox_ori", "=", "det_bbox", ".", "new", "(", "num_pos", ",", "4", ")", "\n", "det_bbox_ori", "[", ":", ",", "0", ":", ":", "2", "]", "=", "det_bbox", "[", ":", ",", "0", ":", ":", "2", "]", "*", "mask_w", "\n", "det_bbox_ori", "[", ":", ",", "1", ":", ":", "2", "]", "=", "det_bbox", "[", ":", ",", "1", ":", ":", "2", "]", "*", "mask_h", "\n", "x_range", "=", "torch", ".", "arange", "(", "mask_w", ")", "\n", "y_range", "=", "torch", ".", "arange", "(", "mask_h", ")", "\n", "y_grid", ",", "x_grid", "=", "torch", ".", "meshgrid", "(", "y_range", ",", "x_range", ")", "\n", "det_bbox_c", "=", "(", "det_bbox_ori", "[", ":", ",", ":", "2", "]", "+", "det_bbox_ori", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "cx", ",", "cy", "=", "torch", ".", "round", "(", "det_bbox_c", "[", ":", ",", "0", "]", ")", ",", "torch", ".", "round", "(", "det_bbox_c", "[", ":", ",", "1", "]", ")", "\n", "y_rel_coord", "=", "(", "y_grid", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "num_pos", ",", "1", ",", "1", ")", "-", "cy", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "**", "2", "\n", "x_rel_coord", "=", "(", "x_grid", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "num_pos", ",", "1", ",", "1", ")", "-", "cx", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "**", "2", "\n", "\n", "# build 2D Normal distribution", "\n", "det_bbox_wh", "=", "det_bbox_ori", "[", ":", ",", "2", ":", "]", "-", "det_bbox_ori", "[", ":", ",", ":", "2", "]", "\n", "rel_coord", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_pos", ")", ":", "\n", "        ", "if", "det_bbox_wh", "[", "i", "]", "[", "0", "]", "*", "det_bbox_wh", "[", "i", "]", "[", "1", "]", "/", "mask_h", "/", "mask_w", "<", "0.1", ":", "\n", "            ", "sigma_scale", "=", "0.5", "*", "sigma_scale", "\n", "", "sigma_x", ",", "sigma_y", "=", "det_bbox_wh", "[", "i", "]", "/", "sigma_scale", "\n", "val", "=", "torch", ".", "exp", "(", "-", "0.5", "*", "(", "x_rel_coord", "[", "i", "]", "/", "(", "sigma_x", "**", "2", ")", "+", "y_rel_coord", "[", "i", "]", "/", "(", "sigma_y", "**", "2", ")", ")", ")", "\n", "rel_coord", ".", "append", "(", "val", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "rel_coord", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.mask_head": [[43, 88], ["proto_coeff[].reshape", "proto_coeff[].reshape", "torch.conv2d", "proto_coeff[].reshape", "proto_coeff[].reshape", "proto_coeff[].reshape", "torch.relu", "torch.conv2d", "torch.conv2d", "proto_coeff[].reshape", "proto_coeff[].reshape", "proto_coeff[].reshape", "proto_coeff[].reshape", "torch.relu", "torch.relu", "torch.conv2d", "torch.conv2d", "torch.conv2d"], "function", ["None"], ["", "def", "mask_head", "(", "protos", ",", "proto_coeff", ",", "num_mask_head", ",", "mask_dim", "=", "8", ",", "use_rela_coord", "=", "False", ",", "img_meta", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    :param protos: [1, n, h, w]\n    :param proto_coeff: reshape as weigths and bias\n    :return: [1, 1, h, w]\n    \"\"\"", "\n", "\n", "# reshape proto_coef as weights and bias of filters", "\n", "if", "use_rela_coord", ":", "\n", "        ", "ch", "=", "mask_dim", "+", "1", "\n", "", "else", ":", "\n", "        ", "ch", "=", "mask_dim", "\n", "", "ch2", "=", "mask_dim", "*", "ch", "\n", "\n", "if", "num_mask_head", "==", "1", ":", "\n", "        ", "weights1", "=", "proto_coeff", "[", ":", "8", "]", ".", "reshape", "(", "1", ",", "8", ",", "1", ",", "1", ")", "\n", "bias1", "=", "proto_coeff", "[", "-", "1", "]", ".", "reshape", "(", "1", ")", "\n", "# FCN network for mask prediction", "\n", "pred_masks", "=", "F", ".", "conv2d", "(", "protos", ",", "weights1", ",", "bias1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ",", "groups", "=", "1", ")", "\n", "\n", "", "elif", "num_mask_head", "==", "2", ":", "\n", "        ", "weights1", "=", "proto_coeff", "[", ":", "ch2", "]", ".", "reshape", "(", "mask_dim", ",", "ch", ",", "1", ",", "1", ")", "\n", "bias1", "=", "proto_coeff", "[", "ch2", ":", "ch2", "+", "mask_dim", "]", "\n", "weights2", "=", "proto_coeff", "[", "ch2", "+", "mask_dim", ":", "ch2", "+", "2", "*", "mask_dim", "]", ".", "reshape", "(", "1", ",", "mask_dim", ",", "1", ",", "1", ")", "\n", "bias2", "=", "proto_coeff", "[", "-", "1", "]", ".", "reshape", "(", "1", ")", "\n", "# FCN network for mask prediction", "\n", "protos1", "=", "F", ".", "relu", "(", "F", ".", "conv2d", "(", "protos", ",", "weights1", ",", "bias1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ",", "groups", "=", "1", ")", ")", "\n", "pred_masks", "=", "F", ".", "conv2d", "(", "protos1", ",", "weights2", ",", "bias2", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ",", "groups", "=", "1", ")", "\n", "\n", "# plot_protos(protos, pred_masks, img_meta, num=1)", "\n", "# plot_protos(protos1, pred_masks, img_meta, num=2)", "\n", "\n", "", "elif", "num_mask_head", "==", "3", ":", "\n", "        ", "weights1", "=", "proto_coeff", "[", ":", "ch2", "]", ".", "reshape", "(", "mask_dim", ",", "ch", ",", "1", ",", "1", ")", "\n", "bias1", "=", "proto_coeff", "[", "ch2", ":", "ch2", "+", "mask_dim", "]", "\n", "weights2", "=", "proto_coeff", "[", "ch2", "+", "mask_dim", ":", "ch2", "+", "mask_dim", "+", "mask_dim", "**", "2", "]", ".", "reshape", "(", "mask_dim", ",", "mask_dim", ",", "1", ",", "1", ")", "\n", "bias2", "=", "proto_coeff", "[", "ch2", "+", "mask_dim", "+", "mask_dim", "**", "2", ":", "ch2", "+", "mask_dim", "*", "2", "+", "mask_dim", "**", "2", "]", "\n", "weights3", "=", "proto_coeff", "[", "ch2", "+", "mask_dim", "*", "2", "+", "mask_dim", "**", "2", ":", "ch2", "+", "mask_dim", "*", "3", "+", "mask_dim", "**", "2", "]", ".", "reshape", "(", "1", ",", "mask_dim", ",", "1", ",", "1", ")", "\n", "bias3", "=", "proto_coeff", "[", "-", "1", "]", ".", "reshape", "(", "1", ")", "\n", "# FCN network for mask prediction", "\n", "protos1", "=", "F", ".", "relu", "(", "F", ".", "conv2d", "(", "protos", ",", "weights1", ",", "bias1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ",", "groups", "=", "1", ")", ")", "\n", "protos2", "=", "F", ".", "relu", "(", "F", ".", "conv2d", "(", "protos1", ",", "weights2", ",", "bias2", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ",", "groups", "=", "1", ")", ")", "\n", "pred_masks", "=", "F", ".", "conv2d", "(", "protos2", ",", "weights3", ",", "bias3", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ",", "groups", "=", "1", ")", "\n", "\n", "", "return", "pred_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.plot_protos": [[90, 109], ["torch.cat.squeeze", "int", "range", "torch.cat", "torch.cat", "matplotlib.imshow", "matplotlib.title", "matplotlib.savefig", "torch.cat.size", "torch.cat", "torch.cat", "proto_data_list.append", "torch.cat.max", "torch.cat.cpu().detach().numpy", "torch.cat.size", "torch.cat", "torch.cat", "protos.squeeze.size", "torch.cat", "torch.cat", "protos[].unsqueeze", "torch.cat.cpu().detach", "str", "str", "range", "torch.cat.cpu"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "plot_protos", "(", "protos", ",", "pred_masks", ",", "img_meta", ",", "num", ")", ":", "\n", "    ", "if", "protos", ".", "size", "(", "1", ")", "==", "9", ":", "\n", "        ", "protos", "=", "torch", ".", "cat", "(", "[", "protos", ",", "protos", "[", ":", ",", "-", "1", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "1", ")", "]", ",", "dim", "=", "1", ")", "\n", "", "elif", "protos", ".", "size", "(", "1", ")", "==", "8", ":", "\n", "        ", "protos", "=", "torch", ".", "cat", "(", "[", "protos", ",", "pred_masks", ",", "pred_masks", "]", ",", "dim", "=", "1", ")", "\n", "", "proto_data", "=", "protos", ".", "squeeze", "(", "0", ")", "\n", "num_per_row", "=", "int", "(", "proto_data", ".", "size", "(", "0", ")", "/", "2", ")", "\n", "proto_data_list", "=", "[", "]", "\n", "for", "r", "in", "range", "(", "2", ")", ":", "\n", "        ", "proto_data_list", ".", "append", "(", "\n", "torch", ".", "cat", "(", "[", "proto_data", "[", "i", ",", ":", ",", ":", "]", "*", "5", "for", "i", "in", "range", "(", "num_per_row", "*", "r", ",", "num_per_row", "*", "(", "r", "+", "1", ")", ")", "]", ",", "dim", "=", "-", "1", ")", ")", "\n", "\n", "", "img", "=", "torch", ".", "cat", "(", "proto_data_list", ",", "dim", "=", "0", ")", "\n", "img", "=", "img", "/", "img", ".", "max", "(", ")", "\n", "plt", ".", "imshow", "(", "img", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "plt", ".", "title", "(", "[", "img_meta", "[", "'video_id'", "]", ",", "img_meta", "[", "'frame_id'", "]", ",", "'protos'", "]", ")", "\n", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "'results/results_0306/out_protos/'", ",", "\n", "str", "(", "(", "img_meta", "[", "'video_id'", "]", ",", "img_meta", "[", "'frame_id'", "]", ")", ")", ",", "\n", "str", "(", "num", ")", ",", "'.png'", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask": [[111, 129], ["datasets.cfg.mask_proto_coeff_activation", "cfg.mask_proto_mask_activation.permute().contiguous", "datasets.cfg.mask_proto_mask_activation", "datasets.cfg.mask_proto_mask_activation", "datasets.cfg.mask_proto_mask_activation", "datasets.cfg.mask_proto_mask_activation", "box_utils.crop_sipmask", "datasets.cfg.mask_proto_mask_activation", "cfg.mask_proto_coeff_activation.t", "box_utils.crop", "cfg.mask_proto_mask_activation.permute", "mask_coeff[].t", "mask_coeff[].t", "mask_coeff[].t", "mask_coeff[].t", "cfg.mask_proto_mask_activation.squeeze"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.crop_sipmask", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.crop"], ["", "def", "generate_mask", "(", "proto_data", ",", "mask_coeff", ",", "bbox", "=", "None", ",", "use_sipmask", "=", "False", ")", ":", "\n", "    ", "mask_coeff", "=", "cfg", ".", "mask_proto_coeff_activation", "(", "mask_coeff", ")", "\n", "# get masks", "\n", "if", "use_sipmask", ":", "\n", "        ", "pred_masks00", "=", "cfg", ".", "mask_proto_mask_activation", "(", "proto_data", "@", "mask_coeff", "[", ":", ",", ":", "32", "]", ".", "t", "(", ")", ")", "\n", "pred_masks01", "=", "cfg", ".", "mask_proto_mask_activation", "(", "proto_data", "@", "mask_coeff", "[", ":", ",", "32", ":", "64", "]", ".", "t", "(", ")", ")", "\n", "pred_masks10", "=", "cfg", ".", "mask_proto_mask_activation", "(", "proto_data", "@", "mask_coeff", "[", ":", ",", "64", ":", "96", "]", ".", "t", "(", ")", ")", "\n", "pred_masks11", "=", "cfg", ".", "mask_proto_mask_activation", "(", "proto_data", "@", "mask_coeff", "[", ":", ",", "96", ":", "128", "]", ".", "t", "(", ")", ")", "\n", "pred_masks", "=", "crop_sipmask", "(", "pred_masks00", ",", "pred_masks01", ",", "pred_masks10", ",", "pred_masks11", ",", "bbox", ")", "\n", "", "else", ":", "\n", "        ", "pred_masks", "=", "proto_data", "@", "mask_coeff", ".", "t", "(", ")", "\n", "pred_masks", "=", "cfg", ".", "mask_proto_mask_activation", "(", "pred_masks", ")", "\n", "if", "bbox", "is", "not", "None", ":", "\n", "            ", "_", ",", "pred_masks", "=", "crop", "(", "pred_masks", ".", "squeeze", "(", "0", ")", ",", "bbox", ")", "# [mask_h, mask_w, n]", "\n", "\n", "", "", "det_masks", "=", "pred_masks", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "contiguous", "(", ")", "# [n_masks, h, w]", "\n", "\n", "return", "det_masks", "\n", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.postprocess_ytbvis": [[16, 134], ["detection.items", "F.interpolate().squeeze.gt_", "box_utils.sanitize_coordinates", "box_utils.sanitize_coordinates", "box_utils.center_size.long", "v.clone", "dets[].nelement", "torch.Tensor", "torch.Tensor", "torch.Tensor", "box_utils.center_size", "dets[].size", "torch.Tensor", "torch.Tensor", "torch.Tensor", "output_utils.display_lincomb", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "range", "dets[].nelement", "F.interpolate().squeeze.size", "pycocotools.encode", "masks_output_json.append", "int", "int", "torch.interpolate", "torch.interpolate", "numpy.array", "F.interpolate().squeeze.unsqueeze", "F.interpolate().squeeze.unsqueeze", "masks[].cpu", "F.interpolate().squeeze.size", "F.interpolate().squeeze.size"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.center_size", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.display_lincomb", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.encode", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["def", "postprocess_ytbvis", "(", "det_output", ",", "img_meta", ",", "interpolation_mode", "=", "'bilinear'", ",", "\n", "display_mask", "=", "False", ",", "visualize_lincomb", "=", "False", ",", "crop_masks", "=", "True", ",", "score_threshold", "=", "0", ",", "\n", "img_ids", "=", "None", ",", "mask_det_file", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Postprocesses the output of Yolact on testing mode into a format that makes sense,\n    accounting for all the possible configuration settings.\n\n    Args:\n        - det_output: The lost of dicts that Detect outputs.\n        - w: The real with of the image.\n        - h: The real height of the image.\n        - batch_idx: If you have multiple images for this batch, the image's index in the batch.\n        - interpolation_mode: Can be 'nearest' | 'area' | 'bilinear' (see torch.nn.functional.interpolate)\n\n    Returns 4 torch Tensors (in the following order):\n        - classes [num_det]: The class idx for each detection.\n        - scores  [num_det]: The confidence score for each detection.\n        - boxes   [num_det, 4]: The bounding box for each detection in absolute point form.\n        - masks   [num_det, h, w]: Full image masks for each detection.\n    \"\"\"", "\n", "\n", "net", "=", "det_output", "[", "'net'", "]", "\n", "detection", "=", "det_output", "[", "'detection'", "]", "\n", "dets", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "detection", ".", "items", "(", ")", ":", "\n", "        ", "dets", "[", "k", "]", "=", "v", ".", "clone", "(", ")", "\n", "\n", "", "ori_h", ",", "ori_w", "=", "img_meta", "[", "'ori_shape'", "]", "[", ":", "2", "]", "\n", "img_h", ",", "img_w", "=", "img_meta", "[", "'img_shape'", "]", "[", ":", "2", "]", "\n", "pad_h", ",", "pad_w", "=", "img_meta", "[", "'pad_shape'", "]", "[", ":", "2", "]", "\n", "s_w", ",", "s_h", "=", "(", "img_w", "/", "pad_w", ",", "img_h", "/", "pad_h", ")", "\n", "\n", "if", "dets", "[", "'box'", "]", ".", "nelement", "(", ")", "==", "0", ":", "\n", "        ", "dets", "[", "'segm'", "]", "=", "torch", ".", "Tensor", "(", ")", "\n", "return", "dets", "\n", "\n", "# double check", "\n", "", "if", "score_threshold", ">", "0", ":", "\n", "        ", "keep", "=", "dets", "[", "'score'", "]", ">", "score_threshold", "\n", "\n", "for", "k", "in", "dets", ":", "\n", "            ", "if", "k", "not", "in", "{", "'proto'", ",", "'bbox_idx'", ",", "'priors'", ",", "'embed_vectors'", ",", "'box_shift'", "}", "and", "dets", "[", "k", "]", "is", "not", "None", ":", "\n", "                ", "dets", "[", "k", "]", "=", "dets", "[", "k", "]", "[", "keep", "]", "\n", "\n", "# Undo the padding introduced with preserve_aspect_ratio", "\n", "", "", "", "if", "cfg", ".", "preserve_aspect_ratio", "and", "dets", "[", "'score'", "]", ".", "nelement", "(", ")", "!=", "0", ":", "\n", "# Get rid of any detections whose centers are outside the image", "\n", "        ", "boxes", "=", "dets", "[", "'box'", "]", "\n", "boxes", "=", "center_size", "(", "boxes", ")", "\n", "not_outside", "=", "(", "(", "boxes", "[", ":", ",", "0", "]", ">", "s_w", ")", "+", "(", "boxes", "[", ":", ",", "1", "]", ">", "s_h", ")", ")", "<", "1", "# not (a or b)", "\n", "for", "k", "in", "dets", ":", "\n", "            ", "if", "k", "not", "in", "{", "'proto'", ",", "'bbox_idx'", ",", "'priors'", ",", "'embed_vectors'", ",", "'box_shift'", "}", "and", "dets", "[", "k", "]", "is", "not", "None", ":", "\n", "                ", "dets", "[", "k", "]", "=", "dets", "[", "k", "]", "[", "not_outside", "]", "\n", "\n", "", "", "", "if", "dets", "[", "'score'", "]", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "        ", "dets", "[", "'segm'", "]", "=", "torch", ".", "Tensor", "(", ")", "\n", "return", "dets", "\n", "\n", "# Actually extract everything from dets now", "\n", "", "boxes", "=", "dets", "[", "'box'", "]", "\n", "masks_coeff", "=", "dets", "[", "'mask_coeff'", "]", "\n", "masks", "=", "dets", "[", "'mask'", "]", "\n", "proto_data", "=", "dets", "[", "'proto'", "]", "\n", "# normlized_coeff = F.normalize(masks_coeff, dim=1)", "\n", "# sim = torch.mm(normlized_coeff, normlized_coeff.t())", "\n", "\n", "if", "visualize_lincomb", ":", "\n", "        ", "display_lincomb", "(", "proto_data", ",", "masks_coeff", ",", "img_ids", ",", "mask_det_file", ")", "\n", "\n", "# Undo padding for masks", "\n", "", "masks", "=", "masks", "[", ":", ",", ":", "int", "(", "s_h", "*", "masks", ".", "size", "(", "1", ")", ")", ",", ":", "int", "(", "s_w", "*", "masks", ".", "size", "(", "2", ")", ")", "]", "\n", "# Scale masks up to the full image", "\n", "if", "cfg", ".", "preserve_aspect_ratio", ":", "\n", "        ", "masks", "=", "F", ".", "interpolate", "(", "masks", ".", "unsqueeze", "(", "0", ")", ",", "(", "ori_h", ",", "ori_w", ")", ",", "mode", "=", "interpolation_mode", ",", "\n", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "", "else", ":", "\n", "        ", "masks", "=", "F", ".", "interpolate", "(", "masks", ".", "unsqueeze", "(", "0", ")", ",", "(", "img_h", ",", "img_w", ")", ",", "mode", "=", "interpolation_mode", ",", "\n", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "# Binarize the masks", "\n", "", "masks", ".", "gt_", "(", "0.5", ")", "\n", "\n", "if", "display_mask", ":", "\n", "        ", "dets", "[", "'segm'", "]", "=", "masks", "\n", "", "else", ":", "\n", "# segm annotation: png2rle", "\n", "        ", "masks_output_json", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "masks", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "cur_mask", "=", "mask_util", ".", "encode", "(", "np", ".", "array", "(", "masks", "[", "i", "]", ".", "cpu", "(", ")", ",", "order", "=", "'F'", ",", "dtype", "=", "'uint8'", ")", ")", "\n", "# masks[i, :, :] = torch.from_numpy(mask_util.decode(cur_mask)).cuda()", "\n", "masks_output_json", ".", "append", "(", "cur_mask", ")", "\n", "", "dets", "[", "'segm'", "]", "=", "masks_output_json", "\n", "\n", "# Undo padding for bboxes", "\n", "", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", "=", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", "/", "s_w", "\n", "boxes", "[", ":", ",", "1", ":", ":", "2", "]", "=", "boxes", "[", ":", ",", "1", ":", ":", "2", "]", "/", "s_h", "\n", "# priors = dets['priors']  # [cx, cy, w, h]", "\n", "# priors[:, :2] = priors[:, :2] - priors[:, 2:]/2", "\n", "# priors[:, 2:] = priors[:, :2] + priors[:, 2:]", "\n", "# priors[:, 0::2] = priors[:, 0::2] / s_w", "\n", "# priors[:, 1::2] = priors[:, 1::2] / s_h", "\n", "\n", "if", "cfg", ".", "preserve_aspect_ratio", ":", "\n", "        ", "out_w", "=", "ori_w", "\n", "out_h", "=", "ori_h", "\n", "", "else", ":", "\n", "        ", "out_w", "=", "img_w", "\n", "out_h", "=", "img_h", "\n", "\n", "", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "2", "]", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "2", "]", ",", "out_w", ",", "cast", "=", "False", ")", "\n", "boxes", "[", ":", ",", "1", "]", ",", "boxes", "[", ":", ",", "3", "]", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "1", "]", ",", "boxes", "[", ":", ",", "3", "]", ",", "out_h", ",", "cast", "=", "False", ")", "\n", "# priors[:, 0], priors[:, 2] = sanitize_coordinates(priors[:, 0], priors[:, 2], out_w, cast=False)", "\n", "# priors[:, 1], priors[:, 3] = sanitize_coordinates(priors[:, 1], priors[:, 3], out_h, cast=False)", "\n", "\n", "boxes", "=", "boxes", ".", "long", "(", ")", "\n", "dets", "[", "'box'", "]", "=", "boxes", "\n", "# dets['priors'] = priors.long()", "\n", "\n", "return", "dets", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.undo_image_transformation": [[136, 166], ["F.interpolate().squeeze.permute().cpu().numpy", "numpy.clip", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "F.interpolate().squeeze.permute().cpu", "int", "int", "torch.interpolate", "torch.interpolate", "numpy.array", "F.interpolate().squeeze.unsqueeze", "F.interpolate().squeeze.unsqueeze", "F.interpolate().squeeze.permute", "numpy.array", "F.interpolate().squeeze.size", "F.interpolate().squeeze.size", "numpy.array"], "function", ["None"], ["", "def", "undo_image_transformation", "(", "img", ",", "img_meta", ",", "pad_h", ",", "pad_w", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "    ", "\"\"\"\n    Takes a transformed image tensor and returns a numpy ndarray that is untransformed.\n    Arguments w and h are the original height and width of the image.\n    \"\"\"", "\n", "ori_h", ",", "ori_w", "=", "img_meta", "[", "'ori_shape'", "]", "[", "0", ":", "2", "]", "\n", "img_h", ",", "img_w", "=", "img_meta", "[", "'img_shape'", "]", "[", "0", ":", "2", "]", "\n", "s_w", ",", "s_h", "=", "(", "img_w", "/", "pad_w", ",", "img_h", "/", "pad_h", ")", "\n", "\n", "# Undo padding", "\n", "img", "=", "img", "[", ":", ",", ":", "int", "(", "s_h", "*", "img", ".", "size", "(", "1", ")", ")", ",", ":", "int", "(", "s_w", "*", "img", ".", "size", "(", "2", ")", ")", "]", "\n", "if", "cfg", ".", "preserve_aspect_ratio", ":", "\n", "        ", "img", "=", "F", ".", "interpolate", "(", "img", ".", "unsqueeze", "(", "0", ")", ",", "(", "ori_h", ",", "ori_w", ")", ",", "mode", "=", "interpolation_mode", ",", "\n", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "", "else", ":", "\n", "        ", "img", "=", "F", ".", "interpolate", "(", "img", ".", "unsqueeze", "(", "0", ")", ",", "(", "img_h", ",", "img_w", ")", ",", "mode", "=", "interpolation_mode", ",", "\n", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "", "img_numpy", "=", "img", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "img_numpy", "=", "img_numpy", "[", ":", ",", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "# To BRG", "\n", "\n", "if", "cfg", ".", "backbone", ".", "transform", ".", "normalize", ":", "\n", "        ", "img_numpy", "=", "(", "img_numpy", "*", "np", ".", "array", "(", "STD", ")", "+", "np", ".", "array", "(", "MEANS", ")", ")", "/", "255.0", "\n", "", "elif", "cfg", ".", "backbone", ".", "transform", ".", "subtract_means", ":", "\n", "        ", "img_numpy", "=", "(", "img_numpy", "/", "255.0", "+", "np", ".", "array", "(", "MEANS", ")", "/", "255.0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "", "img_numpy", "=", "img_numpy", "[", ":", ",", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "# To RGB", "\n", "img_numpy", "=", "np", ".", "clip", "(", "img_numpy", ",", "0", ",", "1", ")", "\n", "\n", "return", "img_numpy", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.display_lincomb": [[168, 222], ["proto_data.squeeze.squeeze", "torch.matmul", "torch.matmul", "torch.matmul", "datasets.cfg.mask_proto_mask_activation", "range", "range", "masks.t", "masks[].cpu().numpy", "numpy.argsort", "proto_data.squeeze.size", "numpy.zeros", "numpy.zeros", "torch.sum().cpu().numpy", "torch.sum().cpu().numpy", "torch.sum().cpu().numpy", "range", "plt.imshow", "plt.axis", "cfg.mask_proto_mask_activation.size", "plt.imshow", "range", "plt.title", "plt.savefig", "out_masks[].cpu().numpy", "plt.title", "plt.savefig", "masks[].cpu", "numpy.abs", "torch.sum().cpu", "torch.sum().cpu", "torch.sum().cpu", "str", "str", "out_masks[].cpu", "torch.sum", "torch.sum", "torch.sum", "proto_data[].cpu().numpy", "proto_data[].cpu().numpy", "str", "str", "str", "numpy.exp", "proto_data[].cpu", "proto_data[].cpu", "torch.max", "torch.max", "torch.max"], "function", ["None"], ["", "def", "display_lincomb", "(", "proto_data", ",", "masks", ",", "img_ids", "=", "None", ",", "mask_det_file", "=", "None", ")", ":", "\n", "    ", "proto_data", "=", "proto_data", ".", "squeeze", "(", ")", "\n", "out_masks", "=", "torch", ".", "matmul", "(", "proto_data", ",", "masks", ".", "t", "(", ")", ")", "\n", "out_masks", "=", "cfg", ".", "mask_proto_mask_activation", "(", "out_masks", ")", "\n", "\n", "for", "kdx", "in", "range", "(", "1", ")", ":", "\n", "        ", "jdx", "=", "kdx", "+", "0", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "coeffs", "=", "masks", "[", "jdx", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "idx", "=", "np", ".", "argsort", "(", "-", "np", ".", "abs", "(", "coeffs", ")", ")", "\n", "# plt.bar(list(range(idx.shape[0])), coeffs[idx])", "\n", "# plt.show()", "\n", "\n", "coeffs_sort", "=", "coeffs", "[", "idx", "]", "\n", "arr_h", ",", "arr_w", "=", "(", "8", ",", "4", ")", "\n", "proto_h", ",", "proto_w", ",", "_", "=", "proto_data", ".", "size", "(", ")", "\n", "arr_img", "=", "np", ".", "zeros", "(", "[", "proto_h", "*", "arr_h", ",", "proto_w", "*", "arr_w", "]", ")", "\n", "arr_run", "=", "np", ".", "zeros", "(", "[", "proto_h", "*", "arr_h", ",", "proto_w", "*", "arr_w", "]", ")", "\n", "test", "=", "torch", ".", "sum", "(", "proto_data", ",", "-", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "y", "in", "range", "(", "arr_h", ")", ":", "\n", "            ", "for", "x", "in", "range", "(", "arr_w", ")", ":", "\n", "                ", "i", "=", "arr_w", "*", "y", "+", "x", "\n", "\n", "if", "i", "==", "0", ":", "\n", "                    ", "running_total", "=", "proto_data", "[", ":", ",", ":", ",", "idx", "[", "i", "]", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "coeffs_sort", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "running_total", "+=", "proto_data", "[", ":", ",", ":", ",", "idx", "[", "i", "]", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "coeffs_sort", "[", "i", "]", "\n", "\n", "", "running_total_nonlin", "=", "running_total", "\n", "if", "cfg", ".", "mask_proto_mask_activation", "==", "activation_func", ".", "sigmoid", ":", "\n", "                    ", "running_total_nonlin", "=", "(", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "running_total_nonlin", ")", ")", ")", "\n", "\n", "", "arr_img", "[", "y", "*", "proto_h", ":", "(", "y", "+", "1", ")", "*", "proto_h", ",", "x", "*", "proto_w", ":", "(", "x", "+", "1", ")", "*", "proto_w", "]", "=", "(", "proto_data", "[", ":", ",", ":", ",", "\n", "idx", "[", "i", "]", "]", "/", "torch", ".", "max", "(", "\n", "proto_data", "[", ":", ",", ":", ",", "idx", "[", "i", "]", "]", ")", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "coeffs_sort", "[", "i", "]", "\n", "arr_run", "[", "y", "*", "proto_h", ":", "(", "y", "+", "1", ")", "*", "proto_h", ",", "x", "*", "proto_w", ":", "(", "x", "+", "1", ")", "*", "proto_w", "]", "=", "(", "\n", "running_total_nonlin", ">", "0.5", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "", "", "plt", ".", "imshow", "(", "arr_img", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "if", "img_ids", "is", "not", "None", ":", "\n", "            ", "plt", ".", "title", "(", "str", "(", "img_ids", ")", ")", "\n", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "mask_det_file", "[", ":", "-", "12", "]", ",", "'out_proto/'", ",", "str", "(", "img_ids", ")", ",", "'protos.png'", "]", ")", ")", "\n", "# plt.show()", "\n", "# plt.imshow(arr_run)", "\n", "# plt.show()", "\n", "# plt.imshow(test)", "\n", "# plt.show()", "\n", "\n", "", "", "for", "jdx", "in", "range", "(", "out_masks", ".", "size", "(", "2", ")", ")", ":", "\n", "        ", "plt", ".", "imshow", "(", "out_masks", "[", ":", ",", ":", ",", "jdx", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "img_ids", "is", "not", "None", ":", "\n", "            ", "plt", ".", "title", "(", "str", "(", "img_ids", ")", ")", "\n", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "mask_det_file", "[", ":", "-", "12", "]", ",", "'out_proto/'", ",", "str", "(", "img_ids", ")", ",", "str", "(", "jdx", ")", ",", "'mask.png'", "]", ")", ")", "\n", "# plt.show()", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.output_utils.display_fpn_outs": [[225, 245], ["range", "outs[].size", "range", "len", "cur_out.size", "numpy.zeros", "range", "plt.imshow", "plt.show", "range", "plt.title", "plt.savefig", "cur_out[].cpu().numpy", "str", "cur_out[].cpu", "str", "str", "str"], "function", ["None"], ["", "", "", "def", "display_fpn_outs", "(", "outs", ",", "img_ids", "=", "None", ",", "mask_det_file", "=", "None", ")", ":", "\n", "\n", "    ", "for", "batch_idx", "in", "range", "(", "outs", "[", "0", "]", ".", "size", "(", "0", ")", ")", ":", "\n", "        ", "for", "idx", "in", "range", "(", "len", "(", "outs", ")", ")", ":", "\n", "            ", "cur_out", "=", "outs", "[", "idx", "]", "[", "batch_idx", "]", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "arr_h", ",", "arr_w", "=", "(", "4", ",", "4", ")", "\n", "_", ",", "h", ",", "w", "=", "cur_out", ".", "size", "(", ")", "\n", "arr_img", "=", "np", ".", "zeros", "(", "[", "h", "*", "arr_h", ",", "w", "*", "arr_w", "]", ")", "\n", "\n", "for", "y", "in", "range", "(", "arr_h", ")", ":", "\n", "                ", "for", "x", "in", "range", "(", "arr_w", ")", ":", "\n", "                    ", "i", "=", "arr_w", "*", "y", "+", "x", "\n", "arr_img", "[", "y", "*", "h", ":", "(", "y", "+", "1", ")", "*", "h", ",", "x", "*", "w", ":", "(", "x", "+", "1", ")", "*", "w", "]", "=", "cur_out", "[", "i", ",", ":", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "", "plt", ".", "imshow", "(", "arr_img", ")", "\n", "if", "img_ids", "is", "not", "None", ":", "\n", "                ", "plt", ".", "title", "(", "str", "(", "img_ids", ")", ")", "\n", "plt", ".", "savefig", "(", "''", ".", "join", "(", "[", "mask_det_file", ",", "str", "(", "img_ids", ")", ",", "'outs'", ",", "str", "(", "batch_idx", ")", ",", "str", "(", "idx", ")", ",", "'.png'", "]", ")", ")", "\n", "", "plt", ".", "show", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.bbox2result_with_id": [[15, 51], ["preds[].cpu().numpy", "preds[].cpu().numpy", "preds[].cpu().numpy", "preds[].cpu().numpy", "zip", "zip", "preds[].cpu", "preds[].cpu", "preds[].cpu", "preds[].cpu"], "function", ["None"], ["def", "bbox2result_with_id", "(", "preds", ",", "img_meta", ",", "classes", ")", ":", "\n", "    ", "\"\"\"Convert detection results to a list of numpy arrays.\n\n    Args:\n        bboxes (Tensor): shape (n, 5)\n        labels (Tensor): shape (n, )\n        classes (int): class category, including background class\n\n    Returns:\n        list(ndarray): bbox results of each class\n    \"\"\"", "\n", "video_id", ",", "frame_id", "=", "img_meta", "[", "'video_id'", "]", ",", "img_meta", "[", "'frame_id'", "]", "\n", "results", "=", "{", "'video_id'", ":", "video_id", ",", "'frame_id'", ":", "frame_id", "}", "\n", "if", "preds", "[", "'box'", "]", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "results", "\n", "", "else", ":", "\n", "        ", "bboxes", "=", "preds", "[", "'box'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "preds", "[", "'class'", "]", "is", "not", "None", ":", "\n", "            ", "labels", "=", "preds", "[", "'class'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# labels_all = preds['class_all'].cpu().numpy()", "\n", "", "else", ":", "\n", "            ", "labels", "=", "None", "\n", "", "scores", "=", "preds", "[", "'score'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "segms", "=", "preds", "[", "'segm'", "]", "\n", "obj_ids", "=", "preds", "[", "'box_ids'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "labels", "is", "not", "None", ":", "\n", "            ", "for", "bbox", ",", "label", ",", "score", ",", "segm", ",", "obj_id", "in", "zip", "(", "bboxes", ",", "labels", ",", "scores", ",", "segms", ",", "obj_ids", ")", ":", "\n", "                ", "if", "obj_id", ">=", "0", ":", "\n", "                    ", "results", "[", "obj_id", "]", "=", "{", "'bbox'", ":", "bbox", ",", "'label'", ":", "label", ",", "'score'", ":", "score", ",", "'segm'", ":", "segm", ",", "\n", "'category'", ":", "classes", "[", "label", "-", "1", "]", "}", "\n", "", "", "", "else", ":", "\n", "            ", "for", "bbox", ",", "score", ",", "segm", ",", "obj_id", "in", "zip", "(", "bboxes", ",", "scores", ",", "segms", ",", "obj_ids", ")", ":", "\n", "                ", "if", "obj_id", ">=", "0", ":", "\n", "                    ", "results", "[", "obj_id", "]", "=", "{", "'bbox'", ":", "bbox", ",", "'score'", ":", "score", ",", "'segm'", ":", "segm", "}", "\n", "\n", "", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.results2json_videoseg": [[53, 107], ["len", "range", "mmcv.dump", "print", "os.path.exists", "os.makedirs", "vid_objs.items", "[].append", "[].append", "segm[].decode", "dict", "numpy.array().mean().item", "numpy.bincount().argmax().item", "range", "json_results.append", "numpy.array().mean", "numpy.bincount().argmax", "vid_seg.append", "vid_seg.append", "numpy.array", "numpy.bincount", "numpy.array"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "", "def", "results2json_videoseg", "(", "results", ",", "out_file", ")", ":", "\n", "    ", "json_results", "=", "[", "]", "\n", "vid_objs", "=", "{", "}", "\n", "size", "=", "len", "(", "results", ")", "\n", "\n", "for", "idx", "in", "range", "(", "size", ")", ":", "\n", "# assume results is ordered", "\n", "\n", "        ", "vid_id", ",", "frame_id", "=", "results", "[", "idx", "]", "[", "'video_id'", "]", ",", "results", "[", "idx", "]", "[", "'frame_id'", "]", "\n", "if", "idx", "==", "size", "-", "1", ":", "\n", "            ", "is_last", "=", "True", "\n", "", "else", ":", "\n", "            ", "vid_id_next", ",", "frame_id_next", "=", "results", "[", "idx", "+", "1", "]", "[", "'video_id'", "]", ",", "results", "[", "idx", "+", "1", "]", "[", "'frame_id'", "]", "\n", "is_last", "=", "vid_id_next", "!=", "vid_id", "\n", "\n", "", "det", "=", "results", "[", "idx", "]", "\n", "for", "obj_id", "in", "det", ":", "\n", "            ", "if", "obj_id", "not", "in", "{", "'video_id'", ",", "'frame_id'", "}", ":", "\n", "                ", "bbox", "=", "det", "[", "obj_id", "]", "[", "'bbox'", "]", "\n", "score", "=", "det", "[", "obj_id", "]", "[", "'score'", "]", "\n", "segm", "=", "det", "[", "obj_id", "]", "[", "'segm'", "]", "\n", "label", "=", "det", "[", "obj_id", "]", "[", "'label'", "]", "\n", "# label_all = det[obj_id]['label_all']", "\n", "if", "obj_id", "not", "in", "vid_objs", ":", "\n", "                    ", "vid_objs", "[", "obj_id", "]", "=", "{", "'scores'", ":", "[", "]", ",", "'cats'", ":", "[", "]", ",", "'segms'", ":", "{", "}", "}", "\n", "", "vid_objs", "[", "obj_id", "]", "[", "'scores'", "]", ".", "append", "(", "score", ")", "\n", "vid_objs", "[", "obj_id", "]", "[", "'cats'", "]", ".", "append", "(", "label", ")", "\n", "segm", "[", "'counts'", "]", "=", "segm", "[", "'counts'", "]", ".", "decode", "(", ")", "\n", "vid_objs", "[", "obj_id", "]", "[", "'segms'", "]", "[", "frame_id", "]", "=", "segm", "\n", "", "", "if", "is_last", ":", "\n", "# store results of  the current video", "\n", "            ", "for", "obj_id", ",", "obj", "in", "vid_objs", ".", "items", "(", ")", ":", "\n", "                ", "data", "=", "dict", "(", ")", "\n", "\n", "data", "[", "'video_id'", "]", "=", "vid_id", "\n", "data", "[", "'score'", "]", "=", "np", ".", "array", "(", "obj", "[", "'scores'", "]", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "# majority voting for sequence category", "\n", "# data['category_id'] = np.stack(obj['cats'], axis=0).sum(0).argmax().item()+1", "\n", "data", "[", "'category_id'", "]", "=", "np", ".", "bincount", "(", "np", ".", "array", "(", "obj", "[", "'cats'", "]", ")", ")", ".", "argmax", "(", ")", ".", "item", "(", ")", "\n", "vid_seg", "=", "[", "]", "\n", "for", "fid", "in", "range", "(", "frame_id", "+", "1", ")", ":", "\n", "                    ", "if", "fid", "in", "obj", "[", "'segms'", "]", ":", "\n", "                        ", "vid_seg", ".", "append", "(", "obj", "[", "'segms'", "]", "[", "fid", "]", ")", "\n", "", "else", ":", "\n", "                        ", "vid_seg", ".", "append", "(", "None", ")", "\n", "", "", "data", "[", "'segmentations'", "]", "=", "vid_seg", "\n", "json_results", ".", "append", "(", "data", ")", "\n", "\n", "", "vid_objs", "=", "{", "}", "\n", "", "", "if", "not", "os", ".", "path", ".", "exists", "(", "out_file", "[", ":", "-", "13", "]", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_file", "[", ":", "-", "13", "]", ")", "\n", "\n", "", "mmcv", ".", "dump", "(", "json_results", ",", "out_file", ")", "\n", "print", "(", "'Done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.calc_metrics": [[109, 120], ["cocoapi.PythonAPI.pycocotools.ytvos.YTVOS", "cocoapi.PythonAPI.pycocotools.ytvos.YTVOS.loadRes", "cocoapi.PythonAPI.pycocotools.ytvoseval.YTVOSeval", "cocoapi.PythonAPI.pycocotools.ytvoseval.YTVOSeval.evaluate", "cocoapi.PythonAPI.pycocotools.ytvoseval.YTVOSeval.accumulate", "cocoapi.PythonAPI.pycocotools.ytvoseval.YTVOSeval.summarize", "print"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.evaluate", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print"], ["", "def", "calc_metrics", "(", "anno_file", ",", "dt_file", ",", "output_file", "=", "None", ")", ":", "\n", "    ", "ytvosGt", "=", "YTVOS", "(", "anno_file", ")", "\n", "ytvosDt", "=", "ytvosGt", ".", "loadRes", "(", "dt_file", ")", "\n", "\n", "E", "=", "YTVOSeval", "(", "ytvosGt", ",", "ytvosDt", ",", "iouType", "=", "'segm'", ",", "output_file", "=", "output_file", ")", "\n", "E", ".", "evaluate", "(", ")", "\n", "E", ".", "accumulate", "(", ")", "\n", "E", ".", "summarize", "(", ")", "\n", "print", "(", "'finish validation'", ")", "\n", "\n", "return", "E", ".", "stats", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.eval_utils.ytvos_eval": [[122, 144], ["mmcv.is_str", "isinstance", "result_file.endswith", "cocoapi.PythonAPI.pycocotools.ytvos.YTVOS.loadRes", "cocoapi.PythonAPI.pycocotools.ytvos.YTVOS.getVidIds", "cocoapi.PythonAPI.pycocotools.ytvos.YTVOS", "len", "print", "cocoapi.PythonAPI.pycocotools.ytvoseval.YTVOSeval", "cocoapi.PythonAPI.pycocotools.ytvoseval.YTVOSeval.evaluate", "cocoapi.PythonAPI.pycocotools.ytvoseval.YTVOSeval.accumulate", "cocoapi.PythonAPI.pycocotools.ytvoseval.YTVOSeval.summarize", "list"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.eval.evaluate"], ["", "def", "ytvos_eval", "(", "result_file", ",", "result_types", ",", "ytvos", ",", "max_dets", "=", "(", "100", ",", "300", ",", "1000", ")", ",", "save_path_valid_metrics", "=", "None", ")", ":", "\n", "    ", "if", "mmcv", ".", "is_str", "(", "ytvos", ")", ":", "\n", "        ", "ytvos", "=", "YTVOS", "(", "ytvos", ")", "\n", "", "assert", "isinstance", "(", "ytvos", ",", "YTVOS", ")", "\n", "\n", "if", "len", "(", "ytvos", ".", "anns", ")", "==", "0", ":", "\n", "        ", "print", "(", "\"Annotations does not exist\"", ")", "\n", "return", "\n", "", "assert", "result_file", ".", "endswith", "(", "'.json'", ")", "\n", "ytvos_dets", "=", "ytvos", ".", "loadRes", "(", "result_file", ")", "\n", "\n", "vid_ids", "=", "ytvos", ".", "getVidIds", "(", ")", "\n", "for", "res_type", "in", "result_types", ":", "\n", "        ", "iou_type", "=", "res_type", "\n", "ytvosEval", "=", "YTVOSeval", "(", "ytvos", ",", "ytvos_dets", ",", "iou_type", ",", "output_file", "=", "save_path_valid_metrics", ")", "\n", "ytvosEval", ".", "params", ".", "vidIds", "=", "vid_ids", "\n", "if", "res_type", "==", "'proposal'", ":", "\n", "            ", "ytvosEval", ".", "params", ".", "useCats", "=", "0", "\n", "ytvosEval", ".", "params", ".", "maxDets", "=", "list", "(", "max_dets", ")", "\n", "", "ytvosEval", ".", "evaluate", "(", ")", "\n", "ytvosEval", ".", "accumulate", "(", ")", "\n", "ytvosEval", ".", "summarize", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection_TF.Detect_TF.__init__": [[17, 29], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_classes", ",", "bkg_label", ",", "top_k", ",", "conf_thresh", ",", "nms_thresh", ")", ":", "\n", "        ", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "background_label", "=", "bkg_label", "\n", "self", ".", "top_k", "=", "top_k", "\n", "# Parameters used in nms.", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "if", "nms_thresh", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'nms_threshold must be non negative.'", ")", "\n", "", "self", ".", "conf_thresh", "=", "conf_thresh", "\n", "\n", "self", ".", "use_cross_class_nms", "=", "True", "\n", "self", ".", "use_fast_nms", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection_TF.Detect_TF.__call__": [[30, 55], ["utils.timer.env", "detection_TF.Detect_TF.detect", "results.append", "results.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.detect", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "__call__", "(", "self", ",", "net", ",", "candidates", ",", "is_output_candidate", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n             net: (tensor) Loc preds from loc layers\n                Shape: [batch, num_priors, 4]\n            candidate: (tensor) Shape: Conf preds from conf layers\n                Shape: [batch, num_priors, num_classes]\n        Returns:\n            output of shape (batch_size, top_k, 1 + 1 + 4 + mask_dim)\n            These outputs are in the order: class idx, confidence, bbox coords, and mask.\n\n            Note that the outputs are sorted only if cross_class_nms is False\n        \"\"\"", "\n", "\n", "with", "timer", ".", "env", "(", "'Detect'", ")", ":", "\n", "            ", "results", "=", "[", "]", "\n", "\n", "for", "candidate", "in", "candidates", ":", "\n", "                ", "result", "=", "self", ".", "detect", "(", "candidate", ",", "is_output_candidate", ")", "\n", "if", "is_output_candidate", ":", "\n", "                    ", "results", ".", "append", "(", "result", ")", "\n", "", "else", ":", "\n", "                    ", "results", ".", "append", "(", "{", "'detection'", ":", "result", ",", "'net'", ":", "net", "}", ")", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection_TF.Detect_TF.detect": [[56, 84], ["candidate[].t", "boxes.size", "candidate.items", "torch.Tensor", "torch.Tensor", "detection_TF.Detect_TF.cc_fast_nms", "detection_TF.Detect_TF.fast_nms"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.cc_fast_nms", "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.fast_nms"], ["", "", "def", "detect", "(", "self", ",", "candidate", ",", "is_output_candidate", "=", "False", ")", ":", "\n", "        ", "\"\"\" Perform nms for only the max scoring class that isn't background (class 0) \"\"\"", "\n", "\n", "scores", "=", "candidate", "[", "'conf'", "]", ".", "t", "(", ")", "[", "1", ":", "]", "# [n_class, n_dets]", "\n", "boxes", "=", "candidate", "[", "'box'", "]", "\n", "centerness_scores", "=", "candidate", "[", "'centerness'", "]", "\n", "mask_coeff", "=", "candidate", "[", "'mask_coeff'", "]", "\n", "track", "=", "candidate", "[", "'track'", "]", "\n", "proto_data", "=", "candidate", "[", "'proto'", "]", "\n", "\n", "if", "boxes", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "            ", "out_aft_nms", "=", "{", "'box'", ":", "boxes", ",", "'mask_coeff'", ":", "mask_coeff", ",", "'class'", ":", "torch", ".", "Tensor", "(", ")", ",", "'score'", ":", "torch", ".", "Tensor", "(", ")", "}", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "if", "self", ".", "use_cross_class_nms", ":", "\n", "                ", "out_aft_nms", "=", "self", ".", "cc_fast_nms", "(", "boxes", ",", "mask_coeff", ",", "proto_data", ",", "track", ",", "scores", ",", "\n", "centerness_scores", ",", "self", ".", "nms_thresh", ",", "self", ".", "top_k", ")", "\n", "", "else", ":", "\n", "                ", "out_aft_nms", "=", "self", ".", "fast_nms", "(", "boxes", ",", "mask_coeff", ",", "proto_data", ",", "track", ",", "scores", ",", "centerness_scores", ",", "\n", "self", ".", "nms_thresh", ",", "self", ".", "top_k", ")", "\n", "\n", "", "", "if", "is_output_candidate", ":", "\n", "            ", "for", "k", ",", "v", "in", "candidate", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", "in", "{", "'fpn_feat'", ",", "'proto'", ",", "'T2S_feat'", ",", "'sem_seg'", "}", ":", "\n", "                    ", "out_aft_nms", "[", "k", "]", "=", "v", "\n", "\n", "", "", "", "return", "out_aft_nms", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection_TF.Detect_TF.cc_fast_nms": [[85, 135], ["scores.max", "scores.sort", "len", "box_utils.jaccard", "torch.triu", "torch.max", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "mask_utils.generate_mask", "mask_utils.generate_mask.gt().float", "box_utils.mask_iou", "mask_utils.generate_mask.gt"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.mask_iou"], ["", "def", "cc_fast_nms", "(", "self", ",", "boxes", ",", "masks_coeff", ",", "proto_data", ",", "track", ",", "scores", ",", "centerness_scores", ",", "\n", "iou_threshold", ":", "float", "=", "0.5", ",", "top_k", ":", "int", "=", "200", ")", ":", "\n", "\n", "        ", "scores", ",", "classes", "=", "scores", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "if", "centerness_scores", "is", "not", "None", ":", "\n", "            ", "scores", "=", "scores", "*", "centerness_scores", "\n", "\n", "", "_", ",", "idx", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "idx", "=", "idx", "[", ":", "top_k", "]", "\n", "\n", "if", "len", "(", "idx", ")", "==", "0", ":", "\n", "            ", "out_after_NMS", "=", "{", "'box'", ":", "torch", ".", "Tensor", "(", ")", ",", "'mask_coeff'", ":", "torch", ".", "Tensor", "(", ")", ",", "'class'", ":", "torch", ".", "Tensor", "(", ")", ",", "\n", "'score'", ":", "torch", ".", "Tensor", "(", ")", "}", "\n", "\n", "", "else", ":", "\n", "# Compute the pairwise IoU between the boxes", "\n", "            ", "boxes_idx", "=", "boxes", "[", "idx", "]", "\n", "iou", "=", "jaccard", "(", "boxes_idx", ",", "boxes_idx", ")", "\n", "if", "cfg", ".", "nms_as_miou", ":", "\n", "                ", "det_masks_soft", "=", "generate_mask", "(", "proto_data", ",", "masks_coeff", ",", "boxes", ")", "\n", "det_masks", "=", "det_masks_soft", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "miou", "=", "mask_iou", "(", "det_masks", "[", "idx", "]", ",", "det_masks", "[", "idx", "]", ")", "\n", "iou", "=", "0.5", "*", "iou", "+", "0.5", "*", "miou", "\n", "\n", "# Zero out the lower triangle of the cosine similarity matrix and diagonal", "\n", "", "iou", "=", "torch", ".", "triu", "(", "iou", ",", "diagonal", "=", "1", ")", "\n", "\n", "# Now that everything in the diagonal and below is zeroed out, if we take the max", "\n", "# of the IoU matrix along the columns, each column will represent the maximum IoU", "\n", "# between this element and every element with a higher score than this element.", "\n", "iou_max", ",", "_", "=", "torch", ".", "max", "(", "iou", ",", "dim", "=", "0", ")", "\n", "\n", "# Now just filter out the ones greater than the threshold, i.e., only keep boxes that", "\n", "# don't have a higher scoring box that would supress it in normal NMS.", "\n", "idx_out", "=", "idx", "[", "iou_max", "<=", "iou_threshold", "]", "\n", "\n", "boxes", "=", "boxes", "[", "idx_out", "]", "\n", "masks_coeff", "=", "masks_coeff", "[", "idx_out", "]", "\n", "if", "track", "is", "not", "None", ":", "\n", "                ", "track", "=", "track", "[", "idx_out", "]", "\n", "", "if", "classes", "is", "not", "None", ":", "\n", "                ", "classes", "=", "classes", "[", "idx_out", "]", "+", "1", "\n", "", "scores", "=", "scores", "[", "idx_out", "]", "\n", "if", "centerness_scores", "is", "not", "None", ":", "\n", "                ", "centerness_scores", "=", "centerness_scores", "[", "idx_out", "]", "\n", "\n", "", "out_after_NMS", "=", "{", "'box'", ":", "boxes", ",", "'mask_coeff'", ":", "masks_coeff", ",", "'track'", ":", "track", ",", "'class'", ":", "classes", ",", "\n", "'score'", ":", "scores", ",", "'centerness'", ":", "centerness_scores", "}", "\n", "", "return", "out_after_NMS", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection_TF.Detect_TF.fast_nms": [[136, 205], ["conf.sort", "idx[].contiguous", "centerness_scores[].view.view", "len", "idx[].contiguous.size", "boxes[].view", "masks_coeff[].view", "box_utils.jaccard", "box_utils.jaccard.triu_", "box_utils.jaccard.max", "[].expand_as", "scores.sort", "centerness_scores[].view.t", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "track[].view", "centerness_scores[].view", "torch.arange", "idx[].contiguous.view", "idx[].contiguous.view", "idx[].contiguous.view", "idx[].contiguous.view"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard"], ["", "def", "fast_nms", "(", "self", ",", "boxes", ",", "masks_coeff", ",", "proto_data", ",", "track", ",", "conf", ",", "centerness_scores", ",", "\n", "iou_threshold", ":", "float", "=", "0.5", ",", "top_k", ":", "int", "=", "200", ",", "\n", "second_threshold", ":", "bool", "=", "True", ")", ":", "\n", "\n", "        ", "if", "centerness_scores", "is", "not", "None", ":", "\n", "            ", "centerness_scores", "=", "centerness_scores", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "conf", "=", "conf", "*", "centerness_scores", ".", "t", "(", ")", "\n", "\n", "", "scores", ",", "idx", "=", "conf", ".", "sort", "(", "1", ",", "descending", "=", "True", ")", "# [num_classes, num_dets]", "\n", "idx", "=", "idx", "[", ":", ",", ":", "top_k", "]", ".", "contiguous", "(", ")", "\n", "scores", "=", "scores", "[", ":", ",", ":", "top_k", "]", "\n", "\n", "if", "len", "(", "idx", ")", "==", "0", ":", "\n", "            ", "out_after_NMS", "=", "{", "'box'", ":", "torch", ".", "Tensor", "(", ")", ",", "'mask_coeff'", ":", "torch", ".", "Tensor", "(", ")", ",", "'class'", ":", "torch", ".", "Tensor", "(", ")", ",", "\n", "'score'", ":", "torch", ".", "Tensor", "(", ")", "}", "\n", "\n", "", "else", ":", "\n", "            ", "num_classes", ",", "num_dets", "=", "idx", ".", "size", "(", ")", "\n", "boxes", "=", "boxes", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "num_classes", ",", "num_dets", ",", "4", ")", "\n", "masks_coeff", "=", "masks_coeff", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "num_classes", ",", "num_dets", ",", "-", "1", ")", "\n", "if", "cfg", ".", "train_track", ":", "\n", "                ", "track", "=", "track", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "num_classes", ",", "num_dets", ",", "-", "1", ")", "\n", "", "if", "centerness_scores", "is", "not", "None", ":", "\n", "                ", "centerness_scores", "=", "centerness_scores", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "num_classes", ",", "num_dets", ",", "-", "1", ")", "\n", "\n", "", "iou", "=", "jaccard", "(", "boxes", ",", "boxes", ")", "# [num_classes, num_dets, num_dets]", "\n", "iou", ".", "triu_", "(", "diagonal", "=", "1", ")", "\n", "iou_max", ",", "_", "=", "iou", ".", "max", "(", "dim", "=", "1", ")", "# [num_classes, num_dets]", "\n", "\n", "# Now just filter out the ones higher than the threshold", "\n", "keep", "=", "(", "iou_max", "<=", "iou_threshold", ")", "# [num_classes, num_dets]", "\n", "\n", "# We should also only keep detections over the confidence threshold, but at the cost of", "\n", "# maxing out your detection count for every image, you can just not do that. Because we", "\n", "# have such a minimal amount of computation per detection (matrix mulitplication only),", "\n", "# this increase doesn't affect us much (+0.2 mAP for 34 -> 33 fps), so we leave it out.", "\n", "# However, when you implement this in your method, you should do this second threshold.", "\n", "if", "second_threshold", ":", "\n", "                ", "keep", "*=", "(", "scores", ">", "self", ".", "conf_thresh", ")", "\n", "\n", "# Assign each kept detection to its corresponding class", "\n", "", "classes", "=", "torch", ".", "arange", "(", "num_classes", ",", "device", "=", "boxes", ".", "device", ")", "[", ":", ",", "None", "]", ".", "expand_as", "(", "keep", ")", "\n", "classes", "=", "classes", "[", "keep", "]", "\n", "\n", "boxes", "=", "boxes", "[", "keep", "]", "\n", "masks_coeff", "=", "masks_coeff", "[", "keep", "]", "\n", "if", "cfg", ".", "train_track", ":", "\n", "                ", "track", "=", "track", "[", "keep", "]", "\n", "", "if", "centerness_scores", "is", "not", "None", ":", "\n", "                ", "centerness_scores", "=", "centerness_scores", "[", "keep", "]", "\n", "", "scores", "=", "scores", "[", "keep", "]", "\n", "\n", "# Only keep the top cfg.max_num_detections highest scores across all classes", "\n", "scores", ",", "idx", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "idx", "=", "idx", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "scores", "=", "scores", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "\n", "classes", "=", "classes", "[", "idx", "]", "+", "1", "\n", "boxes", "=", "boxes", "[", "idx", "]", "\n", "masks_coeff", "=", "masks_coeff", "[", "idx", "]", "\n", "if", "cfg", ".", "train_track", ":", "\n", "                ", "track", "=", "track", "[", "idx", "]", "\n", "", "if", "centerness_scores", "is", "not", "None", ":", "\n", "                ", "centerness_scores", "=", "centerness_scores", "[", "idx", "]", "\n", "\n", "", "out_after_NMS", "=", "{", "'box'", ":", "boxes", ",", "'mask_coeff'", ":", "masks_coeff", ",", "'track'", ":", "track", ",", "'class'", ":", "classes", ",", "\n", "'score'", ":", "scores", ",", "'centerness'", ":", "centerness_scores", "}", "\n", "\n", "", "return", "out_after_NMS", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.track_TF.Track_TF.__init__": [[24, 26], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "prev_candidate", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.track_TF.Track_TF.__call__": [[27, 49], ["utils.timer.env", "enumerate", "track_TF.Track_TF.track", "results.append"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.functions.track.Track.track", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "__call__", "(", "self", ",", "net", ",", "candidates", ",", "imgs_meta", ",", "imgs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n             loc_data: (tensor) Loc preds from loc layers\n                Shape: [batch, num_priors, 4]\n\n        Returns:\n            output of shape (batch_size, top_k, 1 + 1 + 4 + mask_dim)\n            These outputs are in the order: class idx, confidence, bbox coords, and mask.\n\n            Note that the outputs are sorted only if cross_class_nms is False\n        \"\"\"", "\n", "\n", "with", "timer", ".", "env", "(", "'Track'", ")", ":", "\n", "            ", "results", "=", "[", "]", "\n", "\n", "# only support batch_size = 1 for video test", "\n", "for", "batch_idx", ",", "candidate", "in", "enumerate", "(", "candidates", ")", ":", "\n", "                ", "result", "=", "self", ".", "track", "(", "net", ",", "candidate", ",", "imgs_meta", "[", "batch_idx", "]", ",", "img", "=", "imgs", "[", "batch_idx", "]", ")", "\n", "results", ".", "append", "(", "{", "'detection'", ":", "result", ",", "'net'", ":", "net", "}", ")", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.track_TF.Track_TF.track": [[50, 182], ["torch.arange", "torch.arange", "torch.arange", "torch.arange", "candidate[].nelement", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "TF_utils.CandidateShift", "TF_utils.CandidateShift.items", "det_bbox.size", "mask_utils.generate_mask", "mask_utils.generate_mask.gt().float", "track_TF.Track_TF.prev_candidate[].size", "track_TF.Track_TF.prev_candidate[].gt().sum", "track_TF.Track_TF.prev_candidate[].clone().detach", "keep.sum", "candidate[].nelement", "v.clone", "torch.normalize", "torch.normalize", "dict", "candidate.items", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "TF_utils.CandidateShift", "TF_utils.CandidateShift.items", "track_TF.Track_TF.prev_candidate[].size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "box_utils.jaccard", "track_TF.Track_TF.prev_candidate[].gt().float", "box_utils.mask_iou", "TF_utils.compute_comp_scores", "torch.max", "torch.max", "torch.max", "torch.max", "enumerate", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "mask_utils.generate_mask.gt", "v.clone", "track_TF.Track_TF.prev_candidate[].t", "det_score.view", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "track_TF.Track_TF.prev_candidate[].gt", "track_TF.Track_TF.prev_candidate[].clone", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "track_TF.Track_TF.prev_candidate[].gt", "track_TF.Track_TF.prev_candidate[].size", "track_TF.Track_TF.prev_candidate.items", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "det_labels.view", "track_TF.Track_TF.prev_candidate.items", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "int"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.functions.TF_utils.CandidateShift", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask", "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.TF_utils.CandidateShift", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.mask_iou", "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.TF_utils.compute_comp_scores"], ["", "def", "track", "(", "self", ",", "net", ",", "candidate", ",", "img_meta", ",", "img", "=", "None", ")", ":", "\n", "# only support batch_size = 1 for video test", "\n", "        ", "is_first", "=", "img_meta", "[", "'is_first'", "]", "\n", "if", "is_first", ":", "\n", "            ", "self", ".", "prev_candidate", "=", "None", "\n", "\n", "", "if", "candidate", "[", "'box'", "]", ".", "nelement", "(", ")", "==", "0", "and", "self", ".", "prev_candidate", "is", "None", ":", "\n", "            ", "return", "{", "'box'", ":", "torch", ".", "Tensor", "(", ")", ",", "'mask_coeff'", ":", "torch", ".", "Tensor", "(", ")", ",", "'class'", ":", "torch", ".", "Tensor", "(", ")", ",", "\n", "'score'", ":", "torch", ".", "Tensor", "(", ")", ",", "'box_ids'", ":", "torch", ".", "Tensor", "(", ")", "}", "\n", "\n", "", "else", ":", "\n", "            ", "if", "candidate", "[", "'box'", "]", ".", "nelement", "(", ")", "==", "0", "and", "self", ".", "prev_candidate", "is", "not", "None", ":", "\n", "                ", "prev_candidate_shift", "=", "CandidateShift", "(", "net", ",", "self", ".", "prev_candidate", ",", "candidate", ",", "\n", "img", "=", "img", ",", "img_meta", "=", "img_meta", ")", "\n", "for", "k", ",", "v", "in", "prev_candidate_shift", ".", "items", "(", ")", ":", "\n", "                    ", "self", ".", "prev_candidate", "[", "k", "]", "=", "v", ".", "clone", "(", ")", "\n", "", "self", ".", "prev_candidate", "[", "'tracked_mask'", "]", "=", "self", ".", "prev_candidate", "[", "'tracked_mask'", "]", "+", "1", "\n", "", "else", ":", "\n", "\n", "# get bbox and class after NMS", "\n", "                ", "det_bbox", "=", "candidate", "[", "'box'", "]", "\n", "det_score", "=", "candidate", "[", "'score'", "]", "\n", "det_labels", "=", "candidate", "[", "'class'", "]", "\n", "det_masks_coeff", "=", "candidate", "[", "'mask_coeff'", "]", "\n", "if", "cfg", ".", "train_track", ":", "\n", "                    ", "det_track_embed", "=", "candidate", "[", "'track'", "]", "\n", "", "else", ":", "\n", "                    ", "det_track_embed", "=", "F", ".", "normalize", "(", "det_masks_coeff", ",", "dim", "=", "1", ")", "\n", "\n", "", "n_dets", "=", "det_bbox", ".", "size", "(", "0", ")", "\n", "# get masks", "\n", "det_masks_soft", "=", "generate_mask", "(", "candidate", "[", "'proto'", "]", ",", "det_masks_coeff", ",", "det_bbox", ")", "\n", "candidate", "[", "'mask'", "]", "=", "det_masks_soft", "\n", "det_masks", "=", "det_masks_soft", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "\n", "# compared bboxes in current frame with bboxes in previous frame to achieve tracking", "\n", "if", "is_first", "or", "(", "not", "is_first", "and", "self", ".", "prev_candidate", "is", "None", ")", ":", "\n", "# save bbox and features for later matching", "\n", "                    ", "self", ".", "prev_candidate", "=", "dict", "(", ")", "\n", "for", "k", ",", "v", "in", "candidate", ".", "items", "(", ")", ":", "\n", "                        ", "self", ".", "prev_candidate", "[", "k", "]", "=", "v", "\n", "", "self", ".", "prev_candidate", "[", "'tracked_mask'", "]", "=", "torch", ".", "zeros", "(", "n_dets", ")", "\n", "\n", "", "else", ":", "\n", "\n", "                    ", "assert", "self", ".", "prev_candidate", "is", "not", "None", "\n", "prev_candidate_shift", "=", "CandidateShift", "(", "net", ",", "self", ".", "prev_candidate", ",", "candidate", ",", "\n", "img", "=", "img", ",", "img_meta", "=", "img_meta", ")", "\n", "for", "k", ",", "v", "in", "prev_candidate_shift", ".", "items", "(", ")", ":", "\n", "                        ", "self", ".", "prev_candidate", "[", "k", "]", "=", "v", ".", "clone", "(", ")", "\n", "", "self", ".", "prev_candidate", "[", "'tracked_mask'", "]", "=", "self", ".", "prev_candidate", "[", "'tracked_mask'", "]", "+", "1", "\n", "\n", "n_prev", "=", "self", ".", "prev_candidate", "[", "'box'", "]", ".", "size", "(", "0", ")", "\n", "# only support one image at a time", "\n", "cos_sim", "=", "det_track_embed", "@", "self", ".", "prev_candidate", "[", "'track'", "]", ".", "t", "(", ")", "\n", "cos_sim", "=", "torch", ".", "cat", "(", "[", "torch", ".", "zeros", "(", "n_dets", ",", "1", ")", ",", "cos_sim", "]", ",", "dim", "=", "1", ")", "\n", "cos_sim", "=", "(", "cos_sim", "+", "1", ")", "/", "2", "# [0, 1]", "\n", "\n", "bbox_ious", "=", "jaccard", "(", "det_bbox", ",", "self", ".", "prev_candidate", "[", "'box'", "]", ")", "\n", "prev_masks_shift", "=", "self", ".", "prev_candidate", "[", "'mask'", "]", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "\n", "mask_ious", "=", "mask_iou", "(", "det_masks", ",", "prev_masks_shift", ")", "# [n_dets, n_prev]", "\n", "# print(img_meta['video_id'], img_meta['frame_id'], cos_sim[:, 1:], mask_ious)", "\n", "\n", "# compute comprehensive score", "\n", "prev_det_labels", "=", "self", ".", "prev_candidate", "[", "'class'", "]", "\n", "label_delta", "=", "(", "prev_det_labels", "==", "det_labels", ".", "view", "(", "-", "1", ",", "1", ")", ")", ".", "float", "(", ")", "\n", "comp_scores", "=", "compute_comp_scores", "(", "cos_sim", ",", "\n", "det_score", ".", "view", "(", "-", "1", ",", "1", ")", ",", "\n", "bbox_ious", ",", "\n", "mask_ious", ",", "\n", "label_delta", ",", "\n", "add_bbox_dummy", "=", "True", ",", "\n", "bbox_dummy_iou", "=", "0.3", ",", "\n", "match_coeff", "=", "cfg", ".", "match_coeff", ")", "\n", "match_likelihood", ",", "match_ids", "=", "torch", ".", "max", "(", "comp_scores", ",", "dim", "=", "1", ")", "\n", "# translate match_ids to det_obj_ids, assign new id to new objects", "\n", "# update tracking features/bboxes of exisiting object,", "\n", "# add tracking features/bboxes of new object", "\n", "det_obj_ids", "=", "torch", ".", "ones", "(", "n_dets", ",", "dtype", "=", "torch", ".", "int32", ")", "*", "(", "-", "1", ")", "\n", "best_match_scores", "=", "torch", ".", "ones", "(", "n_prev", ")", "*", "(", "-", "1", ")", "\n", "best_match_idx", "=", "torch", ".", "ones", "(", "n_prev", ")", "*", "(", "-", "1", ")", "\n", "for", "idx", ",", "match_id", "in", "enumerate", "(", "match_ids", ")", ":", "\n", "                        ", "if", "match_id", "==", "0", ":", "\n", "                            ", "det_obj_ids", "[", "idx", "]", "=", "self", ".", "prev_candidate", "[", "'box'", "]", ".", "size", "(", "0", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "prev_candidate", ".", "items", "(", ")", ":", "\n", "                                ", "if", "k", "not", "in", "{", "'proto'", ",", "'T2S_feat'", ",", "'fpn_feat'", ",", "'tracked_mask'", "}", ":", "\n", "                                    ", "self", ".", "prev_candidate", "[", "k", "]", "=", "torch", ".", "cat", "(", "[", "v", ",", "candidate", "[", "k", "]", "[", "idx", "]", "[", "None", "]", "]", ",", "dim", "=", "0", ")", "\n", "", "", "self", ".", "prev_candidate", "[", "'tracked_mask'", "]", "=", "torch", ".", "cat", "(", "[", "self", ".", "prev_candidate", "[", "'tracked_mask'", "]", ",", "\n", "torch", ".", "zeros", "(", "1", ")", "]", ",", "dim", "=", "0", ")", "\n", "\n", "", "else", ":", "\n", "# multiple candidate might match with previous object, here we choose the one with", "\n", "# largest comprehensive score", "\n", "                            ", "obj_id", "=", "match_id", "-", "1", "\n", "match_score", "=", "det_score", "[", "idx", "]", "# match_likelihood[idx]", "\n", "if", "match_score", ">", "best_match_scores", "[", "obj_id", "]", ":", "\n", "                                ", "if", "best_match_idx", "[", "obj_id", "]", "!=", "-", "1", ":", "\n", "                                    ", "det_obj_ids", "[", "int", "(", "best_match_idx", "[", "obj_id", "]", ")", "]", "=", "-", "1", "\n", "", "det_obj_ids", "[", "idx", "]", "=", "obj_id", "\n", "best_match_scores", "[", "obj_id", "]", "=", "match_score", "\n", "best_match_idx", "[", "obj_id", "]", "=", "idx", "\n", "# udpate feature", "\n", "for", "k", ",", "v", "in", "self", ".", "prev_candidate", ".", "items", "(", ")", ":", "\n", "                                    ", "if", "k", "not", "in", "{", "'proto'", ",", "'T2S_feat'", ",", "'fpn_feat'", ",", "'tracked_mask'", "}", ":", "\n", "                                        ", "self", ".", "prev_candidate", "[", "k", "]", "[", "obj_id", "]", "=", "candidate", "[", "k", "]", "[", "idx", "]", "\n", "", "", "self", ".", "prev_candidate", "[", "'tracked_mask'", "]", "[", "obj_id", "]", "=", "0", "\n", "\n", "", "", "", "", "", "det_obj_ids", "=", "torch", ".", "arange", "(", "self", ".", "prev_candidate", "[", "'box'", "]", ".", "size", "(", "0", ")", ")", "\n", "# whether add some tracked masks", "\n", "cond1", "=", "self", ".", "prev_candidate", "[", "'tracked_mask'", "]", "<=", "10", "\n", "# whether tracked masks are greater than a small threshold, which removes some false positives", "\n", "cond2", "=", "self", ".", "prev_candidate", "[", "'mask'", "]", ".", "gt", "(", "0.5", ")", ".", "sum", "(", "[", "1", ",", "2", "]", ")", ">", "1", "\n", "# a declining weights (0.8) to remove some false positives that cased by consecutively track to segment", "\n", "cond3", "=", "self", ".", "prev_candidate", "[", "'score'", "]", ".", "clone", "(", ")", ".", "detach", "(", ")", ">", "cfg", ".", "eval_conf_thresh", "\n", "keep", "=", "cond1", "&", "cond2", "&", "cond3", "\n", "\n", "if", "keep", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "detection", "=", "{", "'box'", ":", "torch", ".", "Tensor", "(", ")", ",", "'mask_coeff'", ":", "torch", ".", "Tensor", "(", ")", ",", "'class'", ":", "torch", ".", "Tensor", "(", ")", ",", "\n", "'score'", ":", "torch", ".", "Tensor", "(", ")", ",", "'box_ids'", ":", "torch", ".", "Tensor", "(", ")", "}", "\n", "", "else", ":", "\n", "\n", "                ", "detection", "=", "{", "'box'", ":", "self", ".", "prev_candidate", "[", "'box'", "]", "[", "keep", "]", ",", "\n", "'mask_coeff'", ":", "self", ".", "prev_candidate", "[", "'mask_coeff'", "]", "[", "keep", "]", ",", "\n", "'track'", ":", "self", ".", "prev_candidate", "[", "'track'", "]", "[", "keep", "]", ",", "\n", "'class'", ":", "self", ".", "prev_candidate", "[", "'class'", "]", "[", "keep", "]", ",", "\n", "'score'", ":", "self", ".", "prev_candidate", "[", "'score'", "]", "[", "keep", "]", ",", "\n", "'centerness'", ":", "self", ".", "prev_candidate", "[", "'centerness'", "]", "[", "keep", "]", ",", "\n", "'proto'", ":", "candidate", "[", "'proto'", "]", ",", "'mask'", ":", "self", ".", "prev_candidate", "[", "'mask'", "]", "[", "keep", "]", ",", "\n", "'box_ids'", ":", "det_obj_ids", "[", "keep", "]", "}", "\n", "\n", "", "return", "detection", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.TF_utils.CandidateShift": [[12, 52], ["next_candidate.items", "layers.modules.correlate", "torch.relu", "ref_candidate[].clone", "layers.modules.bbox_feat_extractor", "net.TemporalNet", "layers.box_utils.decode", "layers.mask_utils.generate_mask", "layers.box_utils.decode.clone", "mask_coeff_ref_shift.clone", "layers.mask_utils.generate_mask.clone", "torch.cat", "torch.cat", "fpn_feat_ref.size", "layers.box_utils.center_size", "ref_candidate[].clone", "layers.visualization.display_box_shift", "ref_candidate[].clone", "v.clone"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.track_to_segment_head.correlate", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.track_to_segment_head.bbox_feat_extractor", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.center_size", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.visualization.display_box_shift"], ["def", "CandidateShift", "(", "net", ",", "ref_candidate", ",", "next_candidate", ",", "img", "=", "None", ",", "img_meta", "=", "None", ",", "display", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    The function try to shift the candidates of reference frame to that of target frame.\n    The most important step is to shift the bounding box of reference frame to that of target frame\n    :param net: network\n    :param next_candidate: features of the last layer to predict bounding box on target frame\n    :param ref_candidate: the candidate dictionary that includes 'box', 'conf', 'mask_coeff', 'track' items.\n    :return: candidates on the target frame\n     \"\"\"", "\n", "\n", "ref_candidate_shift", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "next_candidate", ".", "items", "(", ")", ":", "\n", "        ", "if", "k", "in", "{", "'proto'", ",", "'fpn_feat'", ",", "'T2S_feat'", "}", ":", "\n", "            ", "ref_candidate_shift", "[", "k", "]", "=", "v", ".", "clone", "(", ")", "\n", "\n", "# we only use the features in the P3 layer to perform correlation operation", "\n", "", "", "T2S_feat_ref", ",", "T2S_feat_next", "=", "ref_candidate", "[", "'T2S_feat'", "]", ",", "next_candidate", "[", "'T2S_feat'", "]", "\n", "fpn_feat_ref", ",", "fpn_feat_next", "=", "ref_candidate", "[", "'fpn_feat'", "]", ",", "next_candidate", "[", "'fpn_feat'", "]", "\n", "x_corr", "=", "correlate", "(", "fpn_feat_ref", ",", "fpn_feat_next", ",", "patch_size", "=", "cfg", ".", "correlation_patch_size", ")", "\n", "concatenated_features", "=", "F", ".", "relu", "(", "torch", ".", "cat", "(", "[", "x_corr", ",", "T2S_feat_ref", ",", "T2S_feat_next", "]", ",", "dim", "=", "1", ")", ")", "\n", "\n", "box_ref", "=", "ref_candidate", "[", "'box'", "]", ".", "clone", "(", ")", "\n", "feat_h", ",", "feat_w", "=", "fpn_feat_ref", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "bbox_feat_input", "=", "bbox_feat_extractor", "(", "concatenated_features", ",", "box_ref", ",", "feat_h", ",", "feat_w", ",", "7", ")", "\n", "loc_ref_shift", ",", "mask_coeff_shift", "=", "net", ".", "TemporalNet", "(", "bbox_feat_input", ")", "\n", "box_ref_shift", "=", "decode", "(", "loc_ref_shift", ",", "center_size", "(", "box_ref", ")", ")", "\n", "mask_coeff_ref_shift", "=", "ref_candidate", "[", "'mask_coeff'", "]", ".", "clone", "(", ")", "+", "mask_coeff_shift", "\n", "masks_ref_shift", "=", "generate_mask", "(", "next_candidate", "[", "'proto'", "]", ",", "mask_coeff_ref_shift", ",", "box_ref_shift", ")", "\n", "\n", "# display = 1", "\n", "if", "display", ":", "\n", "# display_correlation_map_patch(bbox_feat_input[:, :121], img_meta)", "\n", "        ", "display_box_shift", "(", "box_ref", ",", "box_ref_shift", ",", "mask_shift", "=", "masks_ref_shift", ",", "img_meta", "=", "img_meta", ",", "img_gpu", "=", "img", ")", "\n", "\n", "", "ref_candidate_shift", "[", "'box'", "]", "=", "box_ref_shift", ".", "clone", "(", ")", "\n", "ref_candidate_shift", "[", "'score'", "]", "=", "ref_candidate", "[", "'score'", "]", ".", "clone", "(", ")", "*", "0.95", "\n", "ref_candidate_shift", "[", "'mask_coeff'", "]", "=", "mask_coeff_ref_shift", ".", "clone", "(", ")", "\n", "ref_candidate_shift", "[", "'mask'", "]", "=", "masks_ref_shift", ".", "clone", "(", ")", "\n", "\n", "return", "ref_candidate_shift", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.TF_utils.generate_candidate": [[54, 83], ["predictions[].size", "predictions[].squeeze", "range", "candidate.append", "[].unsqueeze", "[].unsqueeze", "utils.timer.env", "layers.box_utils.decode", "conf_data.t().contiguous.t().contiguous", "torch.max", "torch.max", "conf_data[].t", "[].view", "conf_data.t().contiguous.t"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode"], ["", "def", "generate_candidate", "(", "predictions", ")", ":", "\n", "    ", "batch_Size", "=", "predictions", "[", "'loc'", "]", ".", "size", "(", "0", ")", "\n", "candidate", "=", "[", "]", "\n", "prior_data", "=", "predictions", "[", "'priors'", "]", ".", "squeeze", "(", "0", ")", "\n", "for", "i", "in", "range", "(", "batch_Size", ")", ":", "\n", "        ", "loc_data", "=", "predictions", "[", "'loc'", "]", "[", "i", "]", "\n", "conf_data", "=", "predictions", "[", "'conf'", "]", "[", "i", "]", "\n", "\n", "candidate_cur", "=", "{", "'T2S_feat'", ":", "predictions", "[", "'T2S_feat'", "]", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'fpn_feat'", ":", "predictions", "[", "'fpn_feat'", "]", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "}", "\n", "\n", "with", "timer", ".", "env", "(", "'Detect'", ")", ":", "\n", "            ", "decoded_boxes", "=", "decode", "(", "loc_data", ",", "prior_data", ")", "\n", "\n", "conf_data", "=", "conf_data", ".", "t", "(", ")", ".", "contiguous", "(", ")", "\n", "conf_scores", ",", "_", "=", "torch", ".", "max", "(", "conf_data", "[", "1", ":", ",", ":", "]", ",", "dim", "=", "0", ")", "\n", "\n", "keep", "=", "(", "conf_scores", ">", "cfg", ".", "eval_conf_thresh", ")", "\n", "candidate_cur", "[", "'proto'", "]", "=", "predictions", "[", "'proto'", "]", "[", "i", "]", "\n", "candidate_cur", "[", "'conf'", "]", "=", "conf_data", "[", ":", ",", "keep", "]", ".", "t", "(", ")", "\n", "candidate_cur", "[", "'box'", "]", "=", "decoded_boxes", "[", "keep", ",", ":", "]", "\n", "candidate_cur", "[", "'mask_coeff'", "]", "=", "predictions", "[", "'mask_coeff'", "]", "[", "i", "]", "[", "keep", ",", ":", "]", "\n", "candidate_cur", "[", "'track'", "]", "=", "predictions", "[", "'track'", "]", "[", "i", "]", "[", "keep", ",", ":", "]", "if", "cfg", ".", "train_track", "else", "None", "\n", "if", "cfg", ".", "train_centerness", ":", "\n", "                ", "candidate_cur", "[", "'centerness'", "]", "=", "predictions", "[", "'centerness'", "]", "[", "i", "]", "[", "keep", "]", ".", "view", "(", "-", "1", ")", "\n", "\n", "", "", "candidate", ".", "append", "(", "candidate_cur", ")", "\n", "\n", "", "return", "candidate", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.TF_utils.merge_candidates": [[85, 97], ["candidate.items", "v.clone", "ref_candidate[].nelement", "merged_candidate.items", "torch.cat", "torch.cat", "v.clone", "ref_candidate[].clone"], "function", ["None"], ["", "def", "merge_candidates", "(", "candidate", ",", "ref_candidate_clip_shift", ")", ":", "\n", "    ", "merged_candidate", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "candidate", ".", "items", "(", ")", ":", "\n", "        ", "merged_candidate", "[", "k", "]", "=", "v", ".", "clone", "(", ")", "\n", "\n", "", "for", "ref_candidate", "in", "ref_candidate_clip_shift", ":", "\n", "        ", "if", "ref_candidate", "[", "'box'", "]", ".", "nelement", "(", ")", ">", "0", ":", "\n", "            ", "for", "k", ",", "v", "in", "merged_candidate", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", "not", "in", "{", "'proto'", ",", "'T2S_feat'", ",", "'fpn_feat'", "}", ":", "\n", "                    ", "merged_candidate", "[", "k", "]", "=", "torch", ".", "cat", "(", "[", "v", ".", "clone", "(", ")", ",", "ref_candidate", "[", "k", "]", ".", "clone", "(", ")", "]", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "", "", "return", "merged_candidate", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.TF_utils.compute_comp_scores": [[99, 121], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.ones", "torch.ones", "torch.cat", "torch.cat", "torch.ones", "torch.ones", "torch.cat.size", "len", "torch.cat.size", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device"], "function", ["None"], ["", "def", "compute_comp_scores", "(", "match_ll", ",", "bbox_scores", ",", "bbox_ious", ",", "mask_ious", ",", "label_delta", ",", "add_bbox_dummy", "=", "False", ",", "bbox_dummy_iou", "=", "0", ",", "\n", "match_coeff", "=", "None", ")", ":", "\n", "# compute comprehensive matching score based on matchig likelihood,", "\n", "# bbox confidence, and ious", "\n", "    ", "if", "add_bbox_dummy", ":", "\n", "        ", "bbox_iou_dummy", "=", "torch", ".", "ones", "(", "bbox_ious", ".", "size", "(", "0", ")", ",", "1", ",", "\n", "device", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "*", "bbox_dummy_iou", "\n", "bbox_ious", "=", "torch", ".", "cat", "(", "(", "bbox_iou_dummy", ",", "bbox_ious", ")", ",", "dim", "=", "1", ")", "\n", "mask_ious", "=", "torch", ".", "cat", "(", "(", "bbox_iou_dummy", ",", "mask_ious", ")", ",", "dim", "=", "1", ")", "\n", "label_dummy", "=", "torch", ".", "ones", "(", "bbox_ious", ".", "size", "(", "0", ")", ",", "1", ",", "\n", "device", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "label_delta", "=", "torch", ".", "cat", "(", "(", "label_dummy", ",", "label_delta", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "if", "match_coeff", "is", "None", ":", "\n", "        ", "return", "match_ll", "\n", "", "else", ":", "\n", "# match coeff needs to be length of 4", "\n", "        ", "assert", "(", "len", "(", "match_coeff", ")", "==", "4", ")", "\n", "return", "match_ll", "+", "match_coeff", "[", "0", "]", "*", "bbox_scores", "+", "match_coeff", "[", "1", "]", "*", "mask_ious", "+", "match_coeff", "[", "2", "]", "*", "bbox_ious", "+", "match_coeff", "[", "3", "]", "*", "label_delta", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.__init__": [[25, 37], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_classes", ",", "bkg_label", ",", "top_k", ",", "conf_thresh", ",", "nms_thresh", ")", ":", "\n", "        ", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "background_label", "=", "bkg_label", "\n", "self", ".", "top_k", "=", "top_k", "\n", "# Parameters used in nms.", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "if", "nms_thresh", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'nms_threshold must be non negative.'", ")", "\n", "", "self", ".", "conf_thresh", "=", "conf_thresh", "\n", "\n", "self", ".", "use_cross_class_nms", "=", "True", "\n", "self", ".", "use_fast_nms", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.__call__": [[38, 97], ["predictions[].squeeze", "utils.timer.env", "loc_data.size", "predictions[].squeeze.size", "range", "conf_data.view().transpose().contiguous.view().transpose().contiguous.view().transpose().contiguous", "box_utils.decode", "detection.Detect.detect", "out.append", "conf_data.view().transpose().contiguous.view().transpose().contiguous.view().transpose", "len", "conf_data.view().transpose().contiguous.view().transpose().contiguous.view"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.detect", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "__call__", "(", "self", ",", "predictions", ",", "net", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n             loc_data: (tensor) Loc preds from loc layers\n                Shape: [batch, num_priors, 4]\n            conf_data: (tensor) Shape: Conf preds from conf layers\n                Shape: [batch, num_priors, num_classes]\n            mask_data: (tensor) Mask preds from mask layers\n                Shape: [batch, num_priors, mask_dim]\n            prior_data: (tensor) Prior boxes and variances from priorbox layers\n                Shape: [num_priors, 4]\n            proto_data: (tensor) If using mask_type.lincomb, the prototype masks\n                Shape: [batch, mask_h, mask_w, mask_dim]\n        \n        Returns:\n            output of shape (batch_size, top_k, 1 + 1 + 4 + mask_dim)\n            These outputs are in the order: class idx, confidence, bbox coords, and mask.\n\n            Note that the outputs are sorted only if cross_class_nms is False\n        \"\"\"", "\n", "\n", "if", "cfg", ".", "train_boxes", ":", "\n", "            ", "loc_data", "=", "predictions", "[", "'loc'", "]", "\n", "", "if", "cfg", ".", "train_centerness", ":", "\n", "            ", "centerness_data", "=", "predictions", "[", "'centerness'", "]", "\n", "", "else", ":", "\n", "            ", "centerness_data", "=", "None", "\n", "\n", "", "conf_data", "=", "predictions", "[", "'conf'", "]", "if", "cfg", ".", "train_class", "else", "None", "\n", "mask_data", "=", "predictions", "[", "'mask_coeff'", "]", "\n", "track_data", "=", "predictions", "[", "'track'", "]", "if", "cfg", ".", "train_track", "else", "None", "\n", "prior_data", "=", "predictions", "[", "'priors'", "]", ".", "squeeze", "(", "0", ")", "\n", "proto_data", "=", "predictions", "[", "'proto'", "]", "\n", "\n", "inst_data", "=", "predictions", "[", "'inst'", "]", "if", "'inst'", "in", "predictions", "else", "None", "\n", "\n", "out", "=", "[", "]", "\n", "\n", "with", "timer", ".", "env", "(", "'Detect'", ")", ":", "\n", "            ", "batch_size", "=", "loc_data", ".", "size", "(", "0", ")", "\n", "num_priors", "=", "prior_data", ".", "size", "(", "0", ")", "\n", "\n", "if", "cfg", ".", "train_class", ":", "\n", "                ", "conf_data", "=", "conf_data", ".", "view", "(", "batch_size", ",", "num_priors", ",", "-", "1", ")", ".", "transpose", "(", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "", "for", "batch_idx", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "decoded_boxes", "=", "decode", "(", "loc_data", "[", "batch_idx", "]", ",", "prior_data", ")", "\n", "\n", "result", "=", "self", ".", "detect", "(", "batch_idx", ",", "conf_data", ",", "decoded_boxes", ",", "centerness_data", ",", "\n", "mask_data", ",", "track_data", ",", "proto_data", ",", "inst_data", ")", "\n", "\n", "if", "result", "is", "not", "None", "and", "proto_data", "is", "not", "None", ":", "\n", "                    ", "result", "[", "'proto'", "]", "=", "proto_data", "[", "batch_idx", "]", "\n", "if", "len", "(", "result", "[", "'bbox_idx'", "]", ")", "!=", "0", ":", "\n", "                        ", "result", "[", "'priors'", "]", "=", "prior_data", "[", "result", "[", "'bbox_idx'", "]", "]", "\n", "\n", "", "", "out", ".", "append", "(", "{", "'detection'", ":", "result", ",", "'net'", ":", "net", "}", ")", "\n", "\n", "", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.detect": [[98, 138], ["torch.max", "torch.max", "torch.max", "torch.max", "centerness_data[].view", "boxes.size", "detection.Detect.traditional_nms", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "detection.Detect.cc_fast_nms", "detection.Detect.fast_nms"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.traditional_nms", "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.cc_fast_nms", "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.fast_nms"], ["", "def", "detect", "(", "self", ",", "batch_idx", ",", "conf_preds", ",", "decoded_boxes", ",", "centerness_data", ",", "\n", "mask_data", ",", "track_data", ",", "proto_data", ",", "inst_data", ")", ":", "\n", "        ", "\"\"\" Perform nms for only the max scoring class that isn't background (class 0) \"\"\"", "\n", "assert", "cfg", ".", "train_class", "or", "cfg", ".", "train_clip_class", ",", "'The training process should include train_class or train_clip_class.'", "\n", "if", "cfg", ".", "train_class", ":", "\n", "            ", "cur_scores", "=", "conf_preds", "[", "batch_idx", ",", "1", ":", ",", ":", "]", "\n", "conf_scores", ",", "_", "=", "torch", ".", "max", "(", "cur_scores", ",", "dim", "=", "0", ")", "\n", "\n", "", "keep", "=", "(", "conf_scores", ">", "self", ".", "conf_thresh", ")", "\n", "scores", "=", "cur_scores", "[", ":", ",", "keep", "]", "\n", "\n", "if", "cfg", ".", "train_centerness", ":", "\n", "            ", "centerness_scores", "=", "centerness_data", "[", "batch_idx", ",", "keep", "]", ".", "view", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "centerness_scores", "=", "None", "\n", "\n", "", "boxes", "=", "decoded_boxes", "[", "keep", ",", ":", "]", "\n", "masks_coeff", "=", "mask_data", "[", "batch_idx", ",", "keep", ",", ":", "]", "\n", "track", "=", "track_data", "[", "batch_idx", ",", "keep", ",", ":", "]", "if", "cfg", ".", "train_track", "else", "None", "\n", "proto_data", "=", "proto_data", "[", "batch_idx", "]", "\n", "\n", "if", "inst_data", "is", "not", "None", ":", "\n", "            ", "inst", "=", "inst_data", "[", "batch_idx", ",", "keep", ",", ":", "]", "\n", "\n", "", "if", "boxes", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "            ", "return", "{", "'box'", ":", "boxes", ",", "'mask_coeff'", ":", "masks_coeff", ",", "'class'", ":", "torch", ".", "Tensor", "(", ")", ",", "'score'", ":", "torch", ".", "Tensor", "(", ")", ",", "\n", "'bbox_idx'", ":", "torch", ".", "Tensor", "(", ")", "}", "\n", "\n", "", "if", "self", ".", "use_fast_nms", ":", "\n", "            ", "if", "self", ".", "use_cross_class_nms", ":", "\n", "                ", "out_after_nms", "=", "self", ".", "cc_fast_nms", "(", "boxes", ",", "masks_coeff", ",", "proto_data", ",", "\n", "track", ",", "scores", ",", "centerness_scores", ",", "\n", "self", ".", "nms_thresh", ",", "self", ".", "top_k", ")", "\n", "", "else", ":", "\n", "                ", "out_after_nms", "=", "self", ".", "fast_nms", "(", "boxes", ",", "masks_coeff", ",", "track", ",", "scores", ",", "self", ".", "nms_thresh", ",", "self", ".", "top_k", ")", "\n", "", "", "else", ":", "\n", "            ", "out_after_nms", "=", "self", ".", "traditional_nms", "(", "boxes", ",", "masks_coeff", ",", "track", ",", "scores", ",", "self", ".", "nms_thresh", ",", "self", ".", "conf_thresh", ")", "\n", "\n", "", "return", "out_after_nms", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.cc_fast_nms": [[139, 188], ["conf.max", "scores.sort", "box_utils.jaccard", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.max", "torch.max", "torch.max", "torch.max", "mask_utils.generate_mask", "mask_utils.generate_mask.gt().float", "box_utils.mask_iou", "mask_utils.generate_mask.gt"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.mask_iou"], ["", "def", "cc_fast_nms", "(", "self", ",", "boxes", ",", "masks_coeff", ",", "proto_data", ",", "track", ",", "conf", ",", "centerness_scores", ",", "\n", "iou_threshold", ":", "float", "=", "0.5", ",", "top_k", ":", "int", "=", "200", ")", ":", "\n", "# Collapse all the classes into 1", "\n", "        ", "scores", ",", "classes", "=", "conf", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "if", "centerness_scores", "is", "not", "None", ":", "\n", "            ", "scores", "=", "scores", "*", "centerness_scores", "\n", "\n", "", "_", ",", "idx", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "idx", "=", "idx", "[", ":", "top_k", "]", "\n", "\n", "# Compute the pairwise IoU between the boxes", "\n", "boxes_idx", "=", "boxes", "[", "idx", "]", "\n", "iou", "=", "jaccard", "(", "boxes_idx", ",", "boxes_idx", ")", "\n", "\n", "if", "cfg", ".", "nms_as_miou", ":", "\n", "            ", "det_masks_soft", "=", "generate_mask", "(", "proto_data", ",", "masks_coeff", "[", "idx", "]", ",", "boxes", "[", "idx", "]", ")", "\n", "det_masks", "=", "det_masks_soft", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "miou", "=", "mask_iou", "(", "det_masks", ",", "det_masks", ")", "\n", "iou", "=", "0.5", "*", "(", "iou", "+", "miou", ")", "\n", "\n", "# Zero out the lower triangle of the cosine similarity matrix and diagonal", "\n", "", "iou", "=", "torch", ".", "triu", "(", "iou", ",", "diagonal", "=", "1", ")", "\n", "\n", "# Now that everything in the diagonal and below is zeroed out, if we take the max", "\n", "# of the IoU matrix along the columns, each column will represent the maximum IoU", "\n", "# between this element and every element with a higher score than this element.", "\n", "iou_max", ",", "_", "=", "torch", ".", "max", "(", "iou", ",", "dim", "=", "0", ")", "\n", "\n", "# Now just filter out the ones greater than the threshold, i.e., only keep boxes that", "\n", "# don't have a higher scoring box that would supress it in normal NMS.", "\n", "idx_out", "=", "idx", "[", "iou_max", "<=", "iou_threshold", "]", "\n", "\n", "boxes", "=", "boxes", "[", "idx_out", "]", "\n", "masks_coeff", "=", "masks_coeff", "[", "idx_out", "]", "\n", "if", "track", "is", "not", "None", ":", "\n", "            ", "track", "=", "track", "[", "idx_out", "]", "\n", "", "if", "classes", "is", "not", "None", ":", "\n", "            ", "classes", "=", "classes", "[", "idx_out", "]", "+", "1", "\n", "", "scores", "=", "scores", "[", "idx_out", "]", "# conf.max(dim=0)[0][idx_out]  # scores[idx_out]", "\n", "if", "centerness_scores", "is", "not", "None", ":", "\n", "            ", "centerness_scores", "=", "centerness_scores", "[", "idx_out", "]", "\n", "\n", "", "out_after_NMS", "=", "{", "'box'", ":", "boxes", ",", "'mask_coeff'", ":", "masks_coeff", ",", "'track'", ":", "track", ",", "'class'", ":", "classes", ",", "\n", "'score'", ":", "scores", "}", "\n", "if", "centerness_scores", "is", "not", "None", ":", "\n", "            ", "out_after_NMS", "[", "'centerness'", "]", "=", "centerness_scores", "\n", "\n", "", "return", "out_after_NMS", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.coefficient_nms": [[189, 210], ["scores.sort", "torch.normalize", "torch.normalize", "cos_similarity.triu_", "torch.max", "torch.max", "torch.max", "torch.max", "torch.normalize.t", "idx_out.size"], "methods", ["None"], ["", "def", "coefficient_nms", "(", "self", ",", "coeffs", ",", "scores", ",", "cos_threshold", "=", "0.9", ",", "top_k", "=", "400", ")", ":", "\n", "        ", "_", ",", "idx", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "idx", "=", "idx", "[", ":", "top_k", "]", "\n", "coeffs_norm", "=", "F", ".", "normalize", "(", "coeffs", "[", "idx", "]", ",", "dim", "=", "1", ")", "\n", "\n", "# Compute the pairwise cosine similarity between the coefficients", "\n", "cos_similarity", "=", "coeffs_norm", "@", "coeffs_norm", ".", "t", "(", ")", "\n", "\n", "# Zero out the lower triangle of the cosine similarity matrix and diagonal", "\n", "cos_similarity", ".", "triu_", "(", "diagonal", "=", "1", ")", "\n", "\n", "# Now that everything in the diagonal and below is zeroed out, if we take the max", "\n", "# of the cos similarity matrix along the columns, each column will represent the", "\n", "# maximum cosine similarity between this element and every element with a higher", "\n", "# score than this element.", "\n", "cos_max", ",", "_", "=", "torch", ".", "max", "(", "cos_similarity", ",", "dim", "=", "0", ")", "\n", "\n", "# Now just filter out the ones higher than the threshold", "\n", "idx_out", "=", "idx", "[", "cos_max", "<=", "cos_threshold", "]", "\n", "\n", "return", "idx_out", ",", "idx_out", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.fast_nms": [[211, 264], ["scores.sort", "idx[].contiguous", "idx[].contiguous.size", "boxes[].view", "masks[].view", "box_utils.jaccard", "box_utils.jaccard.triu_", "box_utils.jaccard.max", "[].expand_as", "scores.sort", "track[].view", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "idx[].contiguous.view", "idx[].contiguous.view", "idx[].contiguous.view"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard"], ["", "def", "fast_nms", "(", "self", ",", "boxes", ",", "masks", ",", "track", ",", "scores", ",", "iou_threshold", ":", "float", "=", "0.5", ",", "top_k", ":", "int", "=", "200", ",", "second_threshold", ":", "bool", "=", "True", ")", ":", "\n", "        ", "scores", ",", "idx", "=", "scores", ".", "sort", "(", "1", ",", "descending", "=", "True", ")", "# [num_classes, num_dets]", "\n", "\n", "idx", "=", "idx", "[", ":", ",", ":", "top_k", "]", ".", "contiguous", "(", ")", "\n", "scores", "=", "scores", "[", ":", ",", ":", "top_k", "]", "\n", "\n", "num_classes", ",", "num_dets", "=", "idx", ".", "size", "(", ")", "\n", "\n", "boxes", "=", "boxes", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "num_classes", ",", "num_dets", ",", "4", ")", "\n", "masks", "=", "masks", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "num_classes", ",", "num_dets", ",", "-", "1", ")", "\n", "if", "cfg", ".", "train_track", ":", "\n", "            ", "track", "=", "track", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "num_classes", ",", "num_dets", ",", "-", "1", ")", "\n", "\n", "", "iou", "=", "jaccard", "(", "boxes", ",", "boxes", ")", "# [num_classes, num_dets, num_dets]", "\n", "iou", ".", "triu_", "(", "diagonal", "=", "1", ")", "\n", "iou_max", ",", "_", "=", "iou", ".", "max", "(", "dim", "=", "1", ")", "# [num_classes, num_dets]", "\n", "\n", "# Now just filter out the ones higher than the threshold", "\n", "keep", "=", "(", "iou_max", "<=", "iou_threshold", ")", "# [num_classes, num_dets]", "\n", "\n", "# We should also only keep detections over the confidence threshold, but at the cost of", "\n", "# maxing out your detection count for every image, you can just not do that. Because we", "\n", "# have such a minimal amount of computation per detection (matrix mulitplication only),", "\n", "# this increase doesn't affect us much (+0.2 mAP for 34 -> 33 fps), so we leave it out.", "\n", "# However, when you implement this in your method, you should do this second threshold.", "\n", "if", "second_threshold", ":", "\n", "            ", "keep", "*=", "(", "scores", ">", "self", ".", "conf_thresh", ")", "\n", "\n", "# Assign each kept detection to its corresponding class", "\n", "", "classes", "=", "torch", ".", "arange", "(", "num_classes", ",", "device", "=", "boxes", ".", "device", ")", "[", ":", ",", "None", "]", ".", "expand_as", "(", "keep", ")", "\n", "classes", "=", "classes", "[", "keep", "]", "\n", "\n", "boxes", "=", "boxes", "[", "keep", "]", "\n", "masks", "=", "masks", "[", "keep", "]", "\n", "if", "cfg", ".", "train_track", ":", "\n", "            ", "track", "=", "track", "[", "keep", "]", "\n", "", "scores", "=", "scores", "[", "keep", "]", "\n", "\n", "# Only keep the top cfg.max_num_detections highest scores across all classes", "\n", "scores", ",", "idx", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "idx", "=", "idx", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "scores", "=", "scores", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "\n", "classes", "=", "classes", "[", "idx", "]", "+", "1", "\n", "boxes", "=", "boxes", "[", "idx", "]", "\n", "masks", "=", "masks", "[", "idx", "]", "\n", "if", "cfg", ".", "train_track", ":", "\n", "            ", "track", "=", "track", "[", "idx", "]", "\n", "\n", "", "out_after_NMS", "=", "{", "'box'", ":", "boxes", ",", "'mask_coeff'", ":", "masks", ",", "'track'", ":", "track", ",", "'class'", ":", "classes", ",", "\n", "'score'", ":", "scores", "}", "\n", "\n", "return", "out_after_NMS", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.detection.Detect.traditional_nms": [[265, 313], ["torch.cat.size", "torch.cat.size", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.sort", "torch.cat.sort", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "utils.cython_nms.nms", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "idx_lst.append", "cls_lst.append", "scr_lst.append", "cls_scores.size", "cls_scores.size", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "traditional_nms", "(", "self", ",", "boxes", ",", "masks", ",", "track", ",", "scores", ",", "iou_threshold", "=", "0.5", ",", "conf_thresh", "=", "0.05", ")", ":", "\n", "        ", "num_classes", "=", "scores", ".", "size", "(", "0", ")", "\n", "\n", "idx_lst", "=", "[", "]", "\n", "cls_lst", "=", "[", "]", "\n", "scr_lst", "=", "[", "]", "\n", "\n", "# Multiplying by max_size is necessary because of how cnms computes its area and intersections", "\n", "boxes", "=", "boxes", "*", "cfg", ".", "max_size", "\n", "\n", "for", "_cls", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "cls_scores", "=", "scores", "[", "_cls", ",", ":", "]", "\n", "conf_mask", "=", "cls_scores", ">", "conf_thresh", "\n", "idx", "=", "torch", ".", "arange", "(", "cls_scores", ".", "size", "(", "0", ")", ",", "device", "=", "boxes", ".", "device", ")", "\n", "\n", "cls_scores", "=", "cls_scores", "[", "conf_mask", "]", "\n", "idx", "=", "idx", "[", "conf_mask", "]", "\n", "\n", "if", "cls_scores", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "preds", "=", "torch", ".", "cat", "(", "[", "boxes", "[", "conf_mask", "]", ",", "cls_scores", "[", ":", ",", "None", "]", "]", ",", "dim", "=", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "keep", "=", "cnms", "(", "preds", ",", "iou_threshold", ")", "\n", "keep", "=", "torch", ".", "Tensor", "(", "keep", ",", "device", "=", "boxes", ".", "device", ")", ".", "long", "(", ")", "\n", "\n", "idx_lst", ".", "append", "(", "idx", "[", "keep", "]", ")", "\n", "cls_lst", ".", "append", "(", "keep", "*", "0", "+", "_cls", ")", "\n", "scr_lst", ".", "append", "(", "cls_scores", "[", "keep", "]", ")", "\n", "\n", "", "idx", "=", "torch", ".", "cat", "(", "idx_lst", ",", "dim", "=", "0", ")", "\n", "classes", "=", "torch", ".", "cat", "(", "cls_lst", ",", "dim", "=", "0", ")", "\n", "scores", "=", "torch", ".", "cat", "(", "scr_lst", ",", "dim", "=", "0", ")", "\n", "\n", "scores", ",", "idx2", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "idx2", "=", "idx2", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "scores", "=", "scores", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "\n", "idx", "=", "idx", "[", "idx2", "]", "\n", "classes", "=", "classes", "[", "idx2", "]", "+", "1", "\n", "masks", "=", "masks", "[", "idx", "]", "\n", "track", "=", "track", "[", "idx", "]", "\n", "boxes", "=", "boxes", "[", "idx", "]", "/", "cfg", ".", "max_size", "\n", "\n", "out_after_NMS", "=", "{", "'box'", ":", "boxes", ",", "'mask_coeff'", ":", "masks", ",", "'track'", ":", "track", ",", "'class'", ":", "classes", ",", "\n", "'score'", ":", "scores", "}", "\n", "\n", "# Undo the multiplication above", "\n", "return", "out_after_NMS", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.track.Track.__init__": [[25, 33], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "prev_det_bbox", "=", "None", "\n", "self", ".", "prev_track_embed", "=", "None", "\n", "self", ".", "prev_det_labels", "=", "None", "\n", "self", ".", "prev_det_masks", "=", "None", "\n", "self", ".", "prev_det_masks_coeff", "=", "None", "\n", "self", ".", "prev_protos", "=", "None", "\n", "self", ".", "det_scores", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.track.Track.__call__": [[34, 55], ["utils.timer.env", "len", "range", "track.Track.track"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.functions.track.Track.track"], ["", "def", "__call__", "(", "self", ",", "pred_outs_after_NMS", ",", "img_meta", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n             loc_data: (tensor) Loc preds from loc layers\n                Shape: [batch, num_priors, 4]\n\n        Returns:\n            output of shape (batch_size, top_k, 1 + 1 + 4 + mask_dim)\n            These outputs are in the order: class idx, confidence, bbox coords, and mask.\n\n            Note that the outputs are sorted only if cross_class_nms is False\n        \"\"\"", "\n", "\n", "with", "timer", ".", "env", "(", "'Track'", ")", ":", "\n", "            ", "batch_size", "=", "len", "(", "pred_outs_after_NMS", ")", "\n", "\n", "for", "batch_idx", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "detection", "=", "pred_outs_after_NMS", "[", "batch_idx", "]", "[", "'detection'", "]", "\n", "pred_outs_after_NMS", "[", "batch_idx", "]", "[", "'detection'", "]", "=", "self", ".", "track", "(", "detection", ",", "img_meta", "[", "batch_idx", "]", ")", "\n", "\n", "", "", "return", "pred_outs_after_NMS", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.track.Track.track": [[56, 181], ["det_bbox.size", "mask_utils.generate_mask", "mask_utils.generate_mask.gt().float", "detection[].nelement", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.normalize", "torch.normalize", "proto_data.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "det_labels.view", "proto_data.unsqueeze().repeat", "track.Track.prev_det_bbox.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "box_utils.jaccard", "box_utils.mask_iou", "TF_utils.compute_comp_scores", "torch.max", "torch.max", "torch.max", "torch.max", "enumerate", "detection.items", "mask_utils.generate_mask.gt", "det_bbox.size", "track.Track.prev_track_embed.t", "det_score.view", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "proto_data.unsqueeze", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "track.Track.prev_det_masks.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "det_labels.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "int"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.mask_iou", "home.repos.pwc.inspect_result.MinghanLi_STMask.functions.TF_utils.compute_comp_scores"], ["", "def", "track", "(", "self", ",", "detection", ",", "img_meta", ")", ":", "\n", "\n", "# only support batch_size = 1 for video test", "\n", "        ", "is_first", "=", "img_meta", "[", "'is_first'", "]", "\n", "if", "is_first", ":", "\n", "            ", "self", ".", "prev_det_bbox", "=", "None", "\n", "self", ".", "prev_track_embed", "=", "None", "\n", "self", ".", "prev_det_labels", "=", "None", "\n", "self", ".", "prev_det_masks", "=", "None", "\n", "self", ".", "prev_det_masks_coeff", "=", "None", "\n", "self", ".", "prev_protos", "=", "None", "\n", "self", ".", "det_scores", "=", "None", "\n", "# self.prev_track = {}", "\n", "\n", "", "if", "detection", "[", "'class'", "]", ".", "nelement", "(", ")", "==", "0", ":", "\n", "            ", "detection", "[", "'box_ids'", "]", "=", "torch", ".", "tensor", "(", "[", "]", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "return", "detection", "\n", "\n", "# get bbox and class after NMS", "\n", "", "det_bbox", "=", "detection", "[", "'box'", "]", "\n", "det_labels", "=", "detection", "[", "'class'", "]", "# class", "\n", "det_score", "=", "detection", "[", "'score'", "]", "\n", "det_masks_coff", "=", "detection", "[", "'mask_coeff'", "]", "\n", "if", "cfg", ".", "train_track", ":", "\n", "            ", "det_track_embed", "=", "detection", "[", "'track'", "]", "\n", "", "else", ":", "\n", "            ", "det_track_embed", "=", "F", ".", "normalize", "(", "det_masks_coff", ",", "dim", "=", "1", ")", "\n", "", "proto_data", "=", "detection", "[", "'proto'", "]", "\n", "\n", "n_dets", "=", "det_bbox", ".", "size", "(", "0", ")", "\n", "mask_h", ",", "mask_w", "=", "proto_data", ".", "size", "(", ")", "[", ":", "2", "]", "\n", "\n", "# get masks", "\n", "det_masks_soft", "=", "generate_mask", "(", "proto_data", ",", "det_masks_coff", ",", "det_bbox", ")", "\n", "det_masks", "=", "det_masks_soft", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "detection", "[", "'mask'", "]", "=", "det_masks", "\n", "\n", "# compared bboxes in current frame with bboxes in previous frame to achieve tracking", "\n", "if", "is_first", "or", "(", "not", "is_first", "and", "self", ".", "prev_det_bbox", "is", "None", ")", ":", "\n", "            ", "det_obj_ids", "=", "torch", ".", "arange", "(", "det_bbox", ".", "size", "(", "0", ")", ")", "\n", "# save bbox and features for later matching", "\n", "self", ".", "prev_det_bbox", "=", "det_bbox", "\n", "self", ".", "prev_track_embed", "=", "det_track_embed", "\n", "self", ".", "prev_det_labels", "=", "det_labels", ".", "view", "(", "-", "1", ")", "\n", "self", ".", "prev_det_masks", "=", "det_masks", "\n", "self", ".", "prev_det_masks_coeff", "=", "det_masks_coff", "\n", "self", ".", "prev_protos", "=", "proto_data", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "n_dets", ",", "1", ",", "1", ",", "1", ")", "\n", "self", ".", "prev_scores", "=", "det_score", "\n", "# self.prev_track = {i: det_track_embed[i].view(1, -1) for i in range(det_bbox.size(0))}", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "assert", "self", ".", "prev_track_embed", "is", "not", "None", "\n", "n_prev", "=", "self", ".", "prev_det_bbox", ".", "size", "(", "0", ")", "\n", "# only support one image at a time", "\n", "cos_sim", "=", "det_track_embed", "@", "self", ".", "prev_track_embed", ".", "t", "(", ")", "# [n_dets, n_prev], val in [-1, 1]", "\n", "cos_sim", "=", "torch", ".", "cat", "(", "[", "torch", ".", "zeros", "(", "n_dets", ",", "1", ")", ",", "cos_sim", "]", ",", "dim", "=", "1", ")", "\n", "cos_sim", "=", "(", "cos_sim", "+", "1", ")", "/", "2", "# [0, 1]", "\n", "\n", "bbox_ious", "=", "jaccard", "(", "det_bbox", ",", "self", ".", "prev_det_bbox", ")", "\n", "mask_ious", "=", "mask_iou", "(", "det_masks", ",", "self", ".", "prev_det_masks", ")", "\n", "\n", "# compute comprehensive score", "\n", "label_delta", "=", "(", "self", ".", "prev_det_labels", "==", "det_labels", ".", "view", "(", "-", "1", ",", "1", ")", ")", ".", "float", "(", ")", "\n", "comp_scores", "=", "compute_comp_scores", "(", "cos_sim", ",", "\n", "det_score", ".", "view", "(", "-", "1", ",", "1", ")", ",", "\n", "bbox_ious", ",", "\n", "mask_ious", ",", "\n", "label_delta", ",", "\n", "add_bbox_dummy", "=", "True", ",", "\n", "bbox_dummy_iou", "=", "0.3", ",", "\n", "match_coeff", "=", "cfg", ".", "match_coeff", ")", "\n", "\n", "match_likelihood", ",", "match_ids", "=", "torch", ".", "max", "(", "comp_scores", ",", "dim", "=", "1", ")", "\n", "# translate match_ids to det_obj_ids, assign new id to new objects", "\n", "# update tracking features/bboxes of exisiting object,", "\n", "# add tracking features/bboxes of new object", "\n", "match_ids", "=", "match_ids", "\n", "det_obj_ids", "=", "torch", ".", "ones", "(", "n_dets", ",", "dtype", "=", "torch", ".", "int32", ")", "*", "(", "-", "1", ")", "\n", "best_match_scores", "=", "torch", ".", "ones", "(", "n_prev", ")", "*", "(", "-", "1", ")", "\n", "best_match_idx", "=", "torch", ".", "ones", "(", "n_prev", ")", "*", "(", "-", "1", ")", "\n", "for", "idx", ",", "match_id", "in", "enumerate", "(", "match_ids", ")", ":", "\n", "                ", "if", "match_id", "==", "0", ":", "\n", "                    ", "det_obj_ids", "[", "idx", "]", "=", "self", ".", "prev_det_masks", ".", "size", "(", "0", ")", "\n", "self", ".", "prev_track_embed", "=", "torch", ".", "cat", "(", "[", "self", ".", "prev_track_embed", ",", "det_track_embed", "[", "idx", "]", "[", "None", "]", "]", ",", "dim", "=", "0", ")", "\n", "self", ".", "prev_det_bbox", "=", "torch", ".", "cat", "(", "(", "self", ".", "prev_det_bbox", ",", "det_bbox", "[", "idx", "]", "[", "None", "]", ")", ",", "dim", "=", "0", ")", "\n", "if", "det_labels", "is", "not", "None", ":", "\n", "                        ", "self", ".", "prev_det_labels", "=", "torch", ".", "cat", "(", "(", "self", ".", "prev_det_labels", ",", "det_labels", "[", "idx", "]", "[", "None", "]", ")", ",", "dim", "=", "0", ")", "\n", "", "self", ".", "prev_det_masks", "=", "torch", ".", "cat", "(", "(", "self", ".", "prev_det_masks", ",", "det_masks", "[", "idx", "]", "[", "None", "]", ")", ",", "dim", "=", "0", ")", "\n", "self", ".", "prev_det_masks_coeff", "=", "torch", ".", "cat", "(", "(", "self", ".", "prev_det_masks_coeff", ",", "det_masks_coff", "[", "idx", "]", "[", "None", "]", ")", ",", "dim", "=", "0", ")", "\n", "self", ".", "prev_protos", "=", "torch", ".", "cat", "(", "(", "self", ".", "prev_protos", ",", "proto_data", "[", "None", "]", ")", ",", "dim", "=", "0", ")", "\n", "self", ".", "prev_scores", "=", "torch", ".", "cat", "(", "(", "self", ".", "prev_scores", ",", "det_score", "[", "idx", "]", "[", "None", "]", ")", ",", "dim", "=", "0", ")", "\n", "# self.prev_track[self.prev_det_masks.size(0)-1] = det_track_embed[idx].view(1, -1)", "\n", "\n", "", "else", ":", "\n", "# multiple candidate might match with previous object, here we choose the one with", "\n", "# largest comprehensive score", "\n", "                    ", "obj_id", "=", "match_id", "-", "1", "\n", "match_score", "=", "det_score", "[", "idx", "]", "# match_likelihood[idx]", "\n", "if", "match_score", ">", "best_match_scores", "[", "obj_id", "]", ":", "\n", "                        ", "if", "best_match_idx", "[", "obj_id", "]", "!=", "-", "1", ":", "\n", "                            ", "det_obj_ids", "[", "int", "(", "best_match_idx", "[", "obj_id", "]", ")", "]", "=", "-", "1", "\n", "", "det_obj_ids", "[", "idx", "]", "=", "obj_id", "\n", "best_match_scores", "[", "obj_id", "]", "=", "match_score", "\n", "best_match_idx", "[", "obj_id", "]", "=", "idx", "\n", "# udpate feature", "\n", "if", "(", "mask_ious", "[", "idx", "]", ">", "0.3", ")", ".", "sum", "(", ")", "<", "2", ":", "\n", "                            ", "if", "det_labels", "is", "not", "None", ":", "\n", "                                ", "self", ".", "prev_det_labels", "[", "obj_id", "]", "=", "det_labels", "[", "idx", "]", "\n", "", "self", ".", "prev_track_embed", "[", "obj_id", "]", "=", "det_track_embed", "[", "idx", "]", "\n", "self", ".", "prev_det_bbox", "[", "obj_id", "]", "=", "det_bbox", "[", "idx", "]", "\n", "self", ".", "prev_det_masks", "[", "obj_id", "]", "=", "det_masks", "[", "idx", "]", "\n", "self", ".", "prev_det_masks_coeff", "[", "obj_id", "]", "=", "det_masks_coff", "[", "idx", "]", "\n", "self", ".", "prev_protos", "[", "obj_id", "]", "=", "proto_data", "\n", "self", ".", "prev_scores", "[", "obj_id", "]", "=", "det_score", "[", "idx", "]", "\n", "# self.prev_track[int(obj_id)] = torch.cat([self.prev_track[int(obj_id)], det_track_embed[idx][None]], dim=0)", "\n", "\n", "", "", "", "", "", "detection", "[", "'box_ids'", "]", "=", "det_obj_ids", "\n", "if", "cfg", ".", "remove_false_inst", ":", "\n", "            ", "keep", "=", "det_obj_ids", ">=", "0", "\n", "for", "k", ",", "v", "in", "detection", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", "not", "in", "{", "'proto'", ",", "'bbox_idx'", ",", "'priors'", ",", "'loc_t'", "}", ":", "\n", "                    ", "detection", "[", "k", "]", "=", "detection", "[", "k", "]", "[", "keep", "]", "\n", "\n", "", "", "", "return", "detection", "", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head_FC.PredictionModule_FC.__init__": [[38, 128], ["torch.Module.__init__", "len", "range", "make_net.make_net.make_net", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "len", "prediction_head_FC.PredictionModule_FC.__init__.make_extra"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.make_net.make_net"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", "=", "1024", ",", "deform_groups", "=", "1", ",", "\n", "pred_aspect_ratios", "=", "None", ",", "pred_scales", "=", "None", ",", "parent", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_classes", "=", "cfg", ".", "num_classes", "\n", "self", ".", "mask_dim", "=", "cfg", ".", "mask_dim", "\n", "self", ".", "num_priors", "=", "len", "(", "pred_scales", ")", "\n", "self", ".", "deform_groups", "=", "deform_groups", "\n", "self", ".", "embed_dim", "=", "cfg", ".", "embed_dim", "\n", "self", ".", "pred_aspect_ratios", "=", "pred_aspect_ratios", "\n", "self", ".", "pred_scales", "=", "pred_scales", "\n", "self", ".", "parent", "=", "[", "parent", "]", "# Don't include this in the state dict", "\n", "self", ".", "num_heads", "=", "cfg", ".", "num_heads", "\n", "\n", "if", "cfg", ".", "use_sipmask", ":", "\n", "            ", "self", ".", "mask_dim", "=", "self", ".", "mask_dim", "*", "self", ".", "sipmask_head", "\n", "\n", "", "if", "parent", "is", "None", ":", "\n", "            ", "if", "cfg", ".", "extra_head_net", "is", "None", ":", "\n", "                ", "self", ".", "out_channels", "=", "in_channels", "\n", "", "else", ":", "\n", "                ", "self", ".", "upfeature", ",", "self", ".", "out_channels", "=", "make_net", "(", "in_channels", ",", "cfg", ".", "extra_head_net", ")", "\n", "\n", "# init single or multi kernel prediction modules", "\n", "", "self", ".", "bbox_layer", ",", "self", ".", "track_layer", ",", "self", ".", "mask_layer", "=", "nn", ".", "ModuleList", "(", "[", "]", ")", ",", "nn", ".", "ModuleList", "(", "[", "]", ")", ",", "nn", ".", "ModuleList", "(", "[", "]", ")", "\n", "\n", "if", "cfg", ".", "train_centerness", ":", "\n", "                ", "self", ".", "centerness_layer", "=", "nn", ".", "ModuleList", "(", "[", "]", ")", "\n", "\n", "", "if", "cfg", ".", "train_class", ":", "\n", "                ", "self", ".", "conf_layer", "=", "nn", ".", "ModuleList", "(", "[", "]", ")", "\n", "\n", "", "for", "k", "in", "range", "(", "len", "(", "cfg", ".", "head_layer_params", ")", ")", ":", "\n", "                ", "kernel_size", "=", "cfg", ".", "head_layer_params", "[", "k", "]", "[", "'kernel_size'", "]", "\n", "\n", "if", "cfg", ".", "train_centerness", ":", "\n", "# self.DIoU_layer.append(nn.Conv2d(self.out_channels, self.num_priors, **cfg.head_layer_params[k]))", "\n", "                    ", "self", ".", "centerness_layer", ".", "append", "(", "nn", ".", "Conv2d", "(", "self", ".", "out_channels", ",", "self", ".", "num_priors", ",", "**", "cfg", ".", "head_layer_params", "[", "k", "]", ")", ")", "\n", "\n", "", "if", "cfg", ".", "train_boxes", ":", "\n", "                    ", "self", ".", "bbox_layer", ".", "append", "(", "nn", ".", "Conv2d", "(", "self", ".", "out_channels", ",", "self", ".", "num_priors", "*", "4", ",", "**", "cfg", ".", "head_layer_params", "[", "k", "]", ")", ")", "\n", "\n", "", "if", "cfg", ".", "train_class", ":", "\n", "                    ", "if", "cfg", ".", "use_dcn_class", ":", "\n", "                        ", "self", ".", "conf_layer", ".", "append", "(", "FeatureAlign", "(", "self", ".", "out_channels", ",", "\n", "self", ".", "num_priors", "*", "self", ".", "num_classes", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "deformable_groups", "=", "self", ".", "deform_groups", ",", "\n", "use_pred_offset", "=", "cfg", ".", "use_pred_offset", ")", ")", "\n", "", "else", ":", "\n", "                        ", "self", ".", "conf_layer", ".", "append", "(", "nn", ".", "Conv2d", "(", "self", ".", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "num_classes", ",", "\n", "**", "cfg", ".", "head_layer_params", "[", "k", "]", ")", ")", "\n", "\n", "", "", "if", "cfg", ".", "train_track", ":", "\n", "                    ", "if", "cfg", ".", "use_dcn_track", ":", "\n", "                        ", "self", ".", "track_layer", ".", "append", "(", "FeatureAlign", "(", "self", ".", "out_channels", ",", "\n", "self", ".", "num_priors", "*", "self", ".", "embed_dim", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "deformable_groups", "=", "self", ".", "deform_groups", ",", "\n", "use_pred_offset", "=", "cfg", ".", "use_pred_offset", ")", ")", "\n", "", "else", ":", "\n", "                        ", "self", ".", "track_layer", ".", "append", "(", "nn", ".", "Conv2d", "(", "self", ".", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "embed_dim", ",", "\n", "**", "cfg", ".", "head_layer_params", "[", "k", "]", ")", ")", "\n", "", "", "if", "cfg", ".", "use_dcn_mask", ":", "\n", "                    ", "self", ".", "mask_layer", ".", "append", "(", "FeatureAlign", "(", "self", ".", "out_channels", ",", "\n", "self", ".", "num_priors", "*", "self", ".", "mask_dim", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "deformable_groups", "=", "self", ".", "deform_groups", ",", "\n", "use_pred_offset", "=", "cfg", ".", "use_pred_offset", ")", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "mask_layer", ".", "append", "(", "nn", ".", "Conv2d", "(", "self", ".", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "mask_dim", ",", "\n", "**", "cfg", ".", "head_layer_params", "[", "k", "]", ")", ")", "\n", "\n", "# What is this ugly lambda doing in the middle of all this clean prediction module code?", "\n", "", "", "def", "make_extra", "(", "num_layers", ",", "out_channels", ")", ":", "\n", "                ", "if", "num_layers", "==", "0", ":", "\n", "                    ", "return", "lambda", "x", ":", "x", "\n", "", "else", ":", "\n", "# Looks more complicated than it is. This just creates an array of num_layers alternating conv-relu", "\n", "                    ", "return", "nn", ".", "Sequential", "(", "*", "sum", "(", "[", "[", "\n", "nn", ".", "Conv2d", "(", "out_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "]", "for", "_", "in", "range", "(", "num_layers", ")", "]", ",", "[", "]", ")", ")", "\n", "\n", "", "", "if", "cfg", ".", "train_track", ":", "\n", "                ", "self", ".", "track_extra", "=", "make_extra", "(", "cfg", ".", "extra_layers", "[", "2", "]", ",", "self", ".", "out_channels", ")", "\n", "", "if", "cfg", ".", "train_class", ":", "\n", "                ", "self", ".", "conf_extra", "=", "make_extra", "(", "cfg", ".", "extra_layers", "[", "0", "]", ",", "self", ".", "out_channels", ")", "\n", "", "self", ".", "bbox_extra", ",", "self", ".", "mask_extra", "=", "[", "make_extra", "(", "x", ",", "self", ".", "out_channels", ")", "for", "x", "in", "cfg", ".", "extra_layers", "[", ":", "2", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head_FC.PredictionModule_FC.forward": [[129, 223], ["src.upfeature.size", "src.bbox_extra", "src.mask_extra", "range", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "prediction_head_FC.PredictionModule_FC.make_priors", "src.upfeature", "src.conf_extra", "src.track_extra", "len", "torch.cat().view.append", "torch.cat().view.append", "torch.cat().view.append", "torch.cat().view.append", "torch.cat().view.append", "torch.cat().view.append", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "src.upfeature.size", "src.upfeature.size", "src.upfeature.size", "torch.normalize", "torch.normalize", "torch.normalize", "torch.tanh.append", "torch.tanh.append", "torch.tanh.append", "bbox_cur.permute().contiguous", "torch.cat().view.append", "torch.cat().view.append", "torch.cat().view.append", "torch.cat().view.append", "torch.cat().view.append", "torch.cat().view.append", "mask_cur.permute().contiguous", "src.upfeature.size", "src.upfeature.size", "src.upfeature.size", "src.upfeature.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "centerness_cur.permute().contiguous", "conf_cur.permute().contiguous", "track_emb.permute().contiguous", "bbox_cur.detach", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "bbox_cur.permute", "bbox_cur.detach", "bbox_cur.detach", "mask_cur.permute", "centerness_cur.permute", "conf_cur.permute", "track_emb.permute"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.make_priors", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            - x: The convOut from a layer in the backbone network\n                 Size: [batch_size, in_channels, conv_h, conv_w])\n\n        Returns a tuple (bbox_coords, class_confs, mask_output, prior_boxes) with sizes\n            - bbox_coords: [batch_size, conv_h*conv_w*num_priors, 4]\n            - class_confs: [batch_size, conv_h*conv_w*num_priors, num_classes]\n            - mask_output: [batch_size, conv_h*conv_w*num_priors, mask_dim]\n            - prior_boxes: [conv_h*conv_w*num_priors, 4]\n        \"\"\"", "\n", "# In case we want to use another module's layers", "\n", "src", "=", "self", "if", "self", ".", "parent", "[", "0", "]", "is", "None", "else", "self", ".", "parent", "[", "0", "]", "\n", "\n", "batch_size", ",", "_", ",", "conv_h", ",", "conv_w", "=", "x", ".", "size", "(", ")", "\n", "\n", "if", "cfg", ".", "extra_head_net", "is", "not", "None", ":", "\n", "            ", "x", "=", "src", ".", "upfeature", "(", "x", ")", "\n", "\n", "", "if", "cfg", ".", "train_class", ":", "\n", "            ", "conf_x", "=", "src", ".", "conf_extra", "(", "x", ")", "\n", "", "bbox_x", "=", "src", ".", "bbox_extra", "(", "x", ")", "\n", "mask_x", "=", "src", ".", "mask_extra", "(", "x", ")", "\n", "if", "cfg", ".", "train_track", ":", "\n", "            ", "track_x", "=", "src", ".", "track_extra", "(", "x", ")", "\n", "\n", "", "conf", ",", "bbox", ",", "centerness_data", ",", "mask", ",", "track", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "k", "in", "range", "(", "len", "(", "cfg", ".", "head_layer_params", ")", ")", ":", "\n", "            ", "if", "cfg", ".", "train_centerness", ":", "\n", "                ", "centerness_cur", "=", "src", ".", "centerness_layer", "[", "k", "]", "(", "bbox_x", ")", "\n", "centerness_data", ".", "append", "(", "centerness_cur", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ")", "\n", "\n", "", "bbox_cur", "=", "src", ".", "bbox_layer", "[", "k", "]", "(", "bbox_x", ")", "\n", "bbox", ".", "append", "(", "bbox_cur", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ")", "\n", "\n", "if", "cfg", ".", "train_class", ":", "\n", "                ", "if", "cfg", ".", "use_dcn_class", ":", "\n", "                    ", "conf_cur", "=", "src", ".", "conf_layer", "[", "k", "]", "(", "conf_x", ",", "bbox_cur", ".", "detach", "(", ")", ")", "\n", "", "else", ":", "\n", "                    ", "conf_cur", "=", "src", ".", "conf_layer", "[", "k", "]", "(", "conf_x", ")", "\n", "", "conf", ".", "append", "(", "conf_cur", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ")", "\n", "\n", "", "if", "cfg", ".", "train_track", ":", "\n", "                ", "if", "cfg", ".", "use_dcn_track", ":", "\n", "                    ", "track_emb", "=", "src", ".", "track_layer", "[", "k", "]", "(", "track_x", ",", "bbox_cur", ".", "detach", "(", ")", ")", "\n", "", "else", ":", "\n", "                    ", "track_emb", "=", "src", ".", "track_layer", "[", "k", "]", "(", "track_x", ")", "\n", "", "track", ".", "append", "(", "track_emb", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ")", "\n", "\n", "", "if", "cfg", ".", "use_dcn_mask", ":", "\n", "                ", "mask_cur", "=", "src", ".", "mask_layer", "[", "k", "]", "(", "mask_x", ",", "bbox_cur", ".", "detach", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "mask_cur", "=", "src", ".", "mask_layer", "[", "k", "]", "(", "mask_x", ")", "\n", "", "mask", ".", "append", "(", "mask_cur", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ")", "\n", "\n", "# cat for all anchors", "\n", "", "if", "cfg", ".", "train_boxes", ":", "\n", "            ", "bbox", "=", "torch", ".", "cat", "(", "bbox", ",", "dim", "=", "-", "1", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "4", ")", "\n", "", "if", "cfg", ".", "train_centerness", ":", "\n", "            ", "centerness_data", "=", "torch", ".", "cat", "(", "centerness_data", ",", "dim", "=", "1", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "1", ")", "\n", "centerness_data", "=", "torch", ".", "tanh", "(", "centerness_data", ")", "\n", "", "if", "cfg", ".", "train_class", ":", "\n", "            ", "conf", "=", "torch", ".", "cat", "(", "conf", ",", "dim", "=", "-", "1", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "src", ".", "num_classes", ")", "\n", "", "if", "cfg", ".", "train_track", ":", "\n", "            ", "track", "=", "torch", ".", "cat", "(", "track", ",", "dim", "=", "-", "1", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "src", ".", "embed_dim", ")", "\n", "", "mask", "=", "torch", ".", "cat", "(", "mask", ",", "dim", "=", "-", "1", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "src", ".", "mask_dim", ")", "\n", "\n", "# See box_utils.decode for an explanation of this", "\n", "if", "cfg", ".", "use_yolo_regressors", ":", "\n", "            ", "bbox", "[", ":", ",", ":", ",", ":", "2", "]", "=", "torch", ".", "sigmoid", "(", "bbox", "[", ":", ",", ":", ",", ":", "2", "]", ")", "-", "0.5", "\n", "bbox", "[", ":", ",", ":", ",", "0", "]", "/=", "conv_w", "\n", "bbox", "[", ":", ",", ":", ",", "1", "]", "/=", "conv_h", "\n", "\n", "", "priors", "=", "self", ".", "make_priors", "(", "x", ".", "size", "(", "2", ")", ",", "x", ".", "size", "(", "3", ")", ",", "x", ".", "device", ")", "# [1, h*w*num_priors*num_ratios, 4]", "\n", "\n", "preds", "=", "{", "'mask_coeff'", ":", "mask", ",", "'priors'", ":", "priors", "}", "\n", "\n", "if", "cfg", ".", "train_boxes", ":", "\n", "            ", "preds", "[", "'loc'", "]", "=", "bbox", "\n", "\n", "", "if", "cfg", ".", "train_centerness", ":", "\n", "            ", "preds", "[", "'centerness'", "]", "=", "centerness_data", "\n", "\n", "", "if", "cfg", ".", "temporal_fusion_module", ":", "\n", "            ", "preds", "[", "'T2S_feat'", "]", "=", "x", "\n", "\n", "", "if", "cfg", ".", "train_class", ":", "\n", "            ", "preds", "[", "'conf'", "]", "=", "conf", "\n", "\n", "", "if", "cfg", ".", "train_track", ":", "\n", "            ", "preds", "[", "'track'", "]", "=", "F", ".", "normalize", "(", "track", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head_FC.PredictionModule_FC.make_priors": [[224, 248], ["utils.timer.env", "itertools.product", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "range", "range", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "make_priors", "(", "self", ",", "conv_h", ",", "conv_w", ",", "device", ")", ":", "\n", "        ", "\"\"\" Note that priors are [x,y,width,height] where (x,y) is the center of the box. \"\"\"", "\n", "with", "timer", ".", "env", "(", "'makepriors'", ")", ":", "\n", "            ", "prior_data", "=", "[", "]", "\n", "# Iteration order is important (it has to sync up with the convout)", "\n", "for", "j", ",", "i", "in", "product", "(", "range", "(", "conv_h", ")", ",", "range", "(", "conv_w", ")", ")", ":", "\n", "# +0.5 because priors are in center-size notation", "\n", "                ", "x", "=", "(", "i", "+", "0.5", ")", "/", "conv_w", "\n", "y", "=", "(", "j", "+", "0.5", ")", "/", "conv_h", "\n", "\n", "for", "ars", "in", "self", ".", "pred_aspect_ratios", ":", "\n", "                    ", "for", "ar", "in", "ars", ":", "\n", "                        ", "for", "scale", "in", "self", ".", "pred_scales", ":", "\n", "# [h, w]: [3, 3], [3, 5], [5, 3]", "\n", "                            ", "arh", ",", "arw", "=", "ar", "\n", "ratio", "=", "scale", "/", "self", ".", "pred_scales", "[", "0", "]", "\n", "w", "=", "ratio", "*", "arw", "/", "conv_w", "\n", "h", "=", "ratio", "*", "arh", "/", "conv_h", "\n", "prior_data", "+=", "[", "x", ",", "y", ",", "w", ",", "h", "]", "\n", "\n", "", "", "", "", "priors", "=", "torch", ".", "Tensor", "(", "prior_data", ",", "device", "=", "device", ")", ".", "view", "(", "1", ",", "-", "1", ",", "4", ")", ".", "detach", "(", ")", "\n", "priors", ".", "requires_grad", "=", "False", "\n", "\n", "", "return", "priors", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.__init__": [[38, 54], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__"], ["def", "__init__", "(", "self", ",", "num_classes", ",", "pos_threshold", ",", "neg_threshold", ",", "negpos_ratio", ")", ":", "\n", "        ", "super", "(", "MultiBoxLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "self", ".", "pos_threshold", "=", "pos_threshold", "\n", "self", ".", "neg_threshold", "=", "neg_threshold", "\n", "self", ".", "negpos_ratio", "=", "negpos_ratio", "\n", "\n", "# If you output a proto mask with this area, your l1 loss will be l1_alpha", "\n", "# Note that the area is relative (so 1 would be the entire image)", "\n", "self", ".", "l1_expected_area", "=", "20", "*", "20", "/", "70", "/", "70", "\n", "self", ".", "l1_alpha", "=", "0.1", "\n", "\n", "if", "cfg", ".", "use_class_balanced_conf", ":", "\n", "            ", "self", ".", "class_instances", "=", "None", "\n", "self", ".", "total_instances", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.forward": [[55, 120], ["sum", "sum", "sum", "sum", "multibox_loss.MultiBoxLoss.multibox_loss", "loc_data[].detach", "mask_data[].detach", "proto_data[].detach", "multibox_loss.MultiBoxLoss.track_to_segment_loss", "losses.update", "multibox_loss.MultiBoxLoss.track_loss", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isinf", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "print"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.multibox_loss", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.track_to_segment_loss", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.track_loss", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print"], ["", "", "def", "forward", "(", "self", ",", "net", ",", "predictions", ",", "gt_bboxes", ",", "gt_labels", ",", "gt_masks", ",", "gt_ids", ")", ":", "\n", "        ", "\"\"\"Multibox Loss\n        Args:\n            predictions (tuple): A tuple containing loc preds, conf preds,\n            mask preds, and prior boxes from SSD net.\n                loc shape: torch.size(batch_size,num_priors,4)\n                conf shape: torch.size(batch_size,num_priors,num_classes)\n                masks shape: torch.size(batch_size,num_priors,mask_dim)\n                priors shape: torch.size(num_priors,4)\n                proto* shape: torch.size(batch_size,mask_h,mask_w,mask_dim)\n\n            targets (list<tensor>): Ground truth boxes and labels for a batch,\n                shape: [batch_size][num_objs,5] (last idx is the label).\n\n            masks (list<tensor>): Ground truth masks for each object in each image,\n                shape: [batch_size][num_objs,im_height,im_width]\n\n            num_crowds (list<int>): Number of crowd annotations per batch. The crowd\n                annotations should be the last num_crowds elements of targets and masks.\n\n            * Only if mask_type == lincomb\n        \"\"\"", "\n", "gt_bboxes_fold", "=", "sum", "(", "gt_bboxes", ",", "[", "]", ")", "\n", "gt_labels_fold", "=", "sum", "(", "gt_labels", ",", "[", "]", ")", "\n", "gt_masks_fold", "=", "sum", "(", "gt_masks", ",", "[", "]", ")", "\n", "gt_ids_fold", "=", "sum", "(", "gt_ids", ",", "[", "]", ")", "\n", "\n", "loc_data", "=", "predictions", "[", "'loc'", "]", "\n", "centerness_data", "=", "predictions", "[", "'centerness'", "]", "if", "cfg", ".", "train_centerness", "else", "None", "\n", "score_data", "=", "predictions", "[", "'score'", "]", "if", "cfg", ".", "use_mask_scoring", "else", "None", "\n", "\n", "conf_data", "=", "predictions", "[", "'conf'", "]", "if", "cfg", ".", "train_class", "else", "None", "\n", "mask_data", "=", "predictions", "[", "'mask_coeff'", "]", "\n", "track_data", "=", "predictions", "[", "'track'", "]", "if", "cfg", ".", "train_track", "else", "None", "\n", "\n", "# This is necessary for training on multiple GPUs because", "\n", "# DataParallel will cat the priors from each GPU together", "\n", "priors", "=", "predictions", "[", "'priors'", "]", "\n", "proto_data", "=", "predictions", "[", "'proto'", "]", "\n", "segm_data", "=", "predictions", "[", "'segm'", "]", "if", "cfg", ".", "use_semantic_segmentation_loss", "else", "None", "\n", "\n", "losses", ",", "conf_t", ",", "ids_t", ",", "idx_t", ",", "pos_weights_per_img", "=", "self", ".", "multibox_loss", "(", "net", ",", "loc_data", ",", "conf_data", ",", "\n", "mask_data", ",", "centerness_data", ",", "score_data", ",", "\n", "proto_data", ",", "priors", ",", "segm_data", ",", "\n", "gt_bboxes_fold", ",", "gt_labels_fold", ",", "\n", "gt_masks_fold", ",", "gt_ids_fold", ")", "\n", "\n", "if", "cfg", ".", "temporal_fusion_module", ":", "\n", "            ", "loc_data_ref", "=", "loc_data", "[", ":", ":", "2", "]", ".", "detach", "(", ")", "\n", "ids_t_ref", "=", "ids_t", "[", ":", ":", "2", "]", "\n", "mask_coeff_ref", "=", "mask_data", "[", ":", ":", "2", "]", ".", "detach", "(", ")", "\n", "proto_data_next", "=", "proto_data", "[", "1", ":", ":", "2", "]", ".", "detach", "(", ")", "\n", "losses_shift", "=", "self", ".", "track_to_segment_loss", "(", "net", ",", "predictions", "[", "'T2S_concat_feat'", "]", ",", "\n", "loc_data_ref", ",", "ids_t_ref", ",", "mask_coeff_ref", ",", "proto_data_next", ",", "\n", "priors", "[", "0", "]", ",", "gt_bboxes", ",", "gt_ids", ",", "gt_masks", ")", "\n", "losses", ".", "update", "(", "losses_shift", ")", "\n", "\n", "", "if", "cfg", ".", "train_track", ":", "\n", "            ", "losses", "[", "'T'", "]", "=", "self", ".", "track_loss", "(", "pos_weights_per_img", ",", "track_data", ",", "conf_t", ",", "ids_t", ")", "\n", "\n", "", "for", "k", "in", "losses", ":", "\n", "            ", "if", "torch", ".", "isinf", "(", "losses", "[", "k", "]", ")", "or", "torch", ".", "isnan", "(", "losses", "[", "k", "]", ")", ":", "\n", "                ", "print", "(", "k", ")", "\n", "\n", "", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split": [[121, 124], ["torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "x1.squeeze", "x2.squeeze"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split"], ["", "def", "split", "(", "self", ",", "x", ")", ":", "\n", "        ", "x1", ",", "x2", "=", "torch", ".", "split", "(", "x", ",", "[", "1", ",", "1", "]", ",", "dim", "=", "-", "1", ")", "\n", "return", "x1", ".", "squeeze", "(", "-", "1", ")", ",", "x2", ".", "squeeze", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.multibox_loss": [[125, 226], ["loc_data.new", "loc_data.new", "loc_data.new().long", "loc_data.new().long", "loc_data.new().long", "range", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "pos.data.sum", "range", "torch.ones().split", "torch.ones().split", "torch.ones().split", "torch.ones().split", "torch.ones().split", "torch.ones().split", "torch.ones().split", "torch.ones().split", "torch.ones().split", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "loc_data.size", "box_utils.match", "num_pos_per_img.append", "loc_data[].view", "loc_t[].view", "priors[].view", "losses.update", "multibox_loss.MultiBoxLoss.mask_iou_loss", "multibox_loss.MultiBoxLoss.semantic_segmentation_loss", "loc_data.new", "loc_data.new", "loc_data.new", "pos[].sum().long", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "box_utils.decode", "multibox_loss.MultiBoxLoss.get_DIoU", "multibox_loss.MultiBoxLoss.lincomb_mask_loss", "losses.update", "multibox_loss.MultiBoxLoss.focal_conf_sigmoid_loss", "multibox_loss.MultiBoxLoss.ohem_conf_loss", "int", "IoU_cur.sum", "pos[].sum", "pos.data.sum.tolist", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.match", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.mask_iou_loss", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.semantic_segmentation_loss", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.get_DIoU", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.lincomb_mask_loss", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.focal_conf_sigmoid_loss", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.ohem_conf_loss"], ["", "def", "multibox_loss", "(", "self", ",", "net", ",", "loc_data", ",", "conf_data", ",", "mask_data", ",", "centerness_data", ",", "score_data", ",", "\n", "proto_data", ",", "priors", ",", "segm_data", ",", "gt_bboxes", ",", "gt_labels", ",", "gt_masks", ",", "gt_ids", ")", ":", "\n", "        ", "batch_size", ",", "num_priors", "=", "loc_data", ".", "size", "(", ")", "[", "0", ":", "2", "]", "\n", "\n", "# Match priors (default boxes) and ground truth boxes", "\n", "# These tensors will be created with the same device as loc_data", "\n", "loc_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ",", "4", ")", "\n", "gt_boxes_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ",", "4", ")", "\n", "conf_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ")", ".", "long", "(", ")", "\n", "idx_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ")", ".", "long", "(", ")", "\n", "ids_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ")", ".", "long", "(", ")", "# pids for tracking", "\n", "\n", "# assign positive samples", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "match", "(", "self", ".", "pos_threshold", ",", "self", ".", "neg_threshold", ",", "gt_bboxes", "[", "idx", "]", ",", "gt_labels", "[", "idx", "]", ",", "gt_ids", "[", "idx", "]", ",", "priors", "[", "idx", "]", ",", "\n", "loc_data", "[", "idx", "]", ",", "conf_data", "[", "idx", "]", ",", "loc_t", ",", "conf_t", ",", "idx_t", ",", "ids_t", ",", "idx", ")", "\n", "\n", "gt_boxes_t", "[", "idx", "]", "=", "gt_bboxes", "[", "idx", "]", "[", "idx_t", "[", "idx", "]", "]", "\n", "\n", "# wrap targets", "\n", "", "loc_t", "=", "Variable", "(", "loc_t", ",", "requires_grad", "=", "False", ")", "\n", "conf_t", "=", "Variable", "(", "conf_t", ",", "requires_grad", "=", "False", ")", "\n", "idx_t", "=", "Variable", "(", "idx_t", ",", "requires_grad", "=", "False", ")", "\n", "ids_t", "=", "Variable", "(", "ids_t", ",", "requires_grad", "=", "False", ")", "\n", "\n", "pos", "=", "conf_t", ">", "0", "\n", "total_num_pos", "=", "pos", ".", "data", ".", "sum", "(", ")", "\n", "num_pos_per_img", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "num_pos_per_img", ".", "append", "(", "pos", "[", "idx", "]", ".", "sum", "(", ")", ".", "long", "(", ")", ")", "\n", "\n", "", "losses", "=", "{", "}", "\n", "\n", "# design weights for all pos samples in per img", "\n", "IoU_split", "=", "torch", ".", "ones", "(", "int", "(", "total_num_pos", ".", "tolist", "(", ")", ")", ",", "device", "=", "loc_data", ".", "device", ")", ".", "split", "(", "num_pos_per_img", ")", "\n", "pos_weights_per_img", "=", "[", "IoU_cur", "/", "torch", ".", "clamp", "(", "IoU_cur", ".", "sum", "(", ")", ",", "min", "=", "1", ")", "for", "IoU_cur", "in", "IoU_split", "]", "\n", "pos_weights", "=", "torch", ".", "cat", "(", "pos_weights_per_img", ",", "dim", "=", "0", ")", "\n", "\n", "# Localization Loss (Smooth L1)", "\n", "if", "cfg", ".", "train_boxes", ":", "\n", "            ", "loc_p", "=", "loc_data", "[", "pos", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "loc_t", "=", "loc_t", "[", "pos", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "pos_priors", "=", "priors", "[", "pos", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "\n", "if", "cfg", ".", "use_boxiou_loss", ":", "\n", "                ", "decoded_loc_p", "=", "decode", "(", "loc_p", ",", "pos_priors", ",", "cfg", ".", "use_yolo_regressors", ")", "\n", "DIoU", "=", "self", ".", "get_DIoU", "(", "decoded_loc_p", ",", "gt_boxes_t", "[", "pos", "]", ")", "\n", "losses", "[", "'BIoU'", "]", "=", "(", "pos_weights", "*", "(", "1", "-", "DIoU", ")", ")", ".", "sum", "(", ")", "*", "cfg", ".", "bboxiou_alpha", "\n", "", "else", ":", "\n", "                ", "losses", "[", "'B'", "]", "=", "(", "pos_weights", ".", "view", "(", "-", "1", ",", "1", ")", "*", "F", ".", "smooth_l1_loss", "(", "loc_p", ",", "loc_t", ",", "\n", "reduction", "=", "'none'", ")", ")", ".", "sum", "(", ")", "*", "cfg", ".", "bbox_alpha", "\n", "\n", "# Mask Loss", "\n", "", "", "if", "cfg", ".", "train_masks", ":", "\n", "            ", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", ":", "\n", "                ", "ret", "=", "self", ".", "lincomb_mask_loss", "(", "pos_weights_per_img", ",", "pos", ",", "idx_t", ",", "ids_t", ",", "loc_data", ",", "mask_data", ",", "score_data", ",", "priors", ",", "\n", "proto_data", ",", "gt_masks", ",", "gt_boxes_t", ",", "gt_labels", ")", "\n", "if", "cfg", ".", "use_maskiou", ":", "\n", "                    ", "loss", ",", "maskiou_targets", "=", "ret", "\n", "", "else", ":", "\n", "                    ", "loss", "=", "ret", "\n", "", "losses", ".", "update", "(", "loss", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_loss", "is", "not", "None", ":", "\n", "                    ", "if", "cfg", ".", "mask_proto_loss", "==", "'l1'", ":", "\n", "                        ", "losses", "[", "'P'", "]", "=", "torch", ".", "mean", "(", "torch", ".", "abs", "(", "proto_data", ")", ")", "/", "self", ".", "l1_expected_area", "*", "self", ".", "l1_alpha", "\n", "", "elif", "cfg", ".", "mask_proto_loss", "==", "'disj'", ":", "\n", "                        ", "losses", "[", "'P'", "]", "=", "-", "torch", ".", "mean", "(", "torch", ".", "max", "(", "F", ".", "log_softmax", "(", "proto_data", ",", "dim", "=", "-", "1", ")", ",", "dim", "=", "-", "1", ")", "[", "0", "]", ")", "\n", "\n", "# Confidence loss", "\n", "", "", "", "", "if", "cfg", ".", "train_class", ":", "\n", "            ", "if", "cfg", ".", "use_sigmoid_focal_loss", ":", "\n", "                ", "loss_c", "=", "self", ".", "focal_conf_sigmoid_loss", "(", "conf_data", ",", "conf_t", ")", "\n", "", "else", ":", "\n", "                ", "loss_c", "=", "self", ".", "ohem_conf_loss", "(", "pos_weights", ",", "conf_data", ",", "conf_t", ",", "centerness_data", ",", "loc_data", ",", "priors", ",", "gt_boxes_t", ")", "\n", "", "losses", ".", "update", "(", "loss_c", ")", "\n", "\n", "# Mask IoU Loss", "\n", "", "if", "cfg", ".", "use_maskiou", "and", "maskiou_targets", "is", "not", "None", ":", "\n", "            ", "losses", "[", "'I'", "]", "=", "self", ".", "mask_iou_loss", "(", "net", ",", "maskiou_targets", ")", "\n", "\n", "# These losses also don't depend on anchors", "\n", "", "if", "cfg", ".", "use_semantic_segmentation_loss", ":", "\n", "            ", "losses", "[", "'S'", "]", "=", "self", ".", "semantic_segmentation_loss", "(", "segm_data", ",", "gt_masks", ",", "gt_labels", ")", "\n", "\n", "# Divide all losses by the number of positives.", "\n", "# Don't do it for loss[P] because that doesn't depend on the anchors.", "\n", "# loss[P] and loss [IC] have been divided the number of positives", "\n", "", "for", "k", "in", "losses", ":", "\n", "            ", "losses", "[", "k", "]", "/=", "batch_size", "\n", "# Loss Key:", "\n", "#  - B: Box Localization Loss", "\n", "#  - C: Class Confidence Loss", "\n", "#  - M: Mask Loss", "\n", "#  - T: Tracking Loss", "\n", "#  - T_acc: Tracking accuracy", "\n", "#  - P: Prototype Loss", "\n", "#  - D: Coefficient Diversity Loss", "\n", "#  - E: Class Existence Loss", "\n", "#  - S: Semantic Segmentation Loss", "\n", "", "return", "losses", ",", "conf_t", ",", "ids_t", ",", "idx_t", ",", "pos_weights_per_img", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.get_DIoU": [[227, 246], ["box_utils.jaccard().diag().view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "box_utils.jaccard().diag", "box_utils.jaccard", "torch.cat.max", "torch.cat.max", "torch.cat.max", "torch.cat.min", "torch.cat.min", "torch.cat.min", "torch.cat.max", "torch.cat.max", "torch.cat.max", "torch.cat.min", "torch.cat.min", "torch.cat.min"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard"], ["", "def", "get_DIoU", "(", "self", ",", "pos_pred_boxes", ",", "pos_gt_boxes", ")", ":", "\n", "# calculate bbox IoUs", "\n", "        ", "IoU", "=", "jaccard", "(", "pos_gt_boxes", ",", "pos_pred_boxes", ")", ".", "diag", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "# calculate the diagonal length of the smallest enclosing box", "\n", "x_label", "=", "torch", ".", "cat", "(", "[", "pos_pred_boxes", "[", ":", ",", ":", ":", "2", "]", ",", "pos_gt_boxes", "[", ":", ",", ":", ":", "2", "]", "]", ",", "dim", "=", "1", ")", "\n", "y_label", "=", "torch", ".", "cat", "(", "[", "pos_pred_boxes", "[", ":", ",", "1", ":", ":", "2", "]", ",", "pos_gt_boxes", "[", ":", ",", "1", ":", ":", "2", "]", "]", ",", "dim", "=", "1", ")", "\n", "c2", "=", "(", "x_label", ".", "max", "(", "dim", "=", "1", ")", "[", "0", "]", "-", "x_label", ".", "min", "(", "dim", "=", "1", ")", "[", "0", "]", ")", "**", "2", "+", "(", "y_label", ".", "max", "(", "dim", "=", "1", ")", "[", "0", "]", "-", "y_label", ".", "min", "(", "dim", "=", "1", ")", "[", "0", "]", ")", "**", "2", "\n", "c2", "=", "torch", ".", "clamp", "(", "c2", ",", "min", "=", "1e-10", ")", "\n", "\n", "# get the distance of centres between pred_bbox and gt_bbox", "\n", "pos_pred_boxes_c", "=", "pos_pred_boxes", "[", ":", ",", ":", "2", "]", "/", "2", "+", "pos_pred_boxes", "[", ":", ",", "2", ":", "]", "/", "2", "\n", "pos_gt_boxes_c", "=", "pos_gt_boxes", "[", ":", ",", ":", "2", "]", "/", "2", "+", "pos_gt_boxes", "[", ":", ",", "2", ":", "]", "/", "2", "\n", "d2", "=", "(", "(", "pos_pred_boxes_c", "-", "pos_gt_boxes_c", ")", "**", "2", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "# DIoU", "\n", "DIoU", "=", "IoU", "-", "d2", "/", "c2", "\n", "\n", "return", "DIoU", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.track_to_segment_loss": [[247, 327], ["loc_ref.size", "range", "concat_feat.size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "ids_t_ref[].clone", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "enumerate", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "pos.sum", "[].view().detach", "priors[].view", "box_utils.decode", "track_to_segment_head.bbox_feat_extractor", "net.TemporalNet", "torch.smooth_l1_loss().sum", "torch.smooth_l1_loss().sum", "torch.smooth_l1_loss().sum", "torch.smooth_l1_loss().sum.mean", "pos.sum", "concat_feat[].unsqueeze", "[].float", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "[].view", "[].view", "box_utils.encode", "box_utils.encode.repeat", "[].view", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "[].tolist().index", "mask_utils.generate_mask", "mask_utils.generate_mask", "[].float.size", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "box_utils.center_size", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "box_utils.center_size", "keep_inst.sum", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "[].tolist", "mask_utils.generate_mask.unsqueeze", "torch.smooth_l1_loss.sum", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.track_to_segment_head.bbox_feat_extractor", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.encode", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.center_size", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.center_size"], ["", "def", "track_to_segment_loss", "(", "self", ",", "net", ",", "concat_feat", ",", "loc_ref", ",", "ids_t_ref", ",", "mask_data_ref", ",", "proto_data_next", ",", "\n", "priors", ",", "gt_bboxes", ",", "gt_ids", ",", "gt_masks", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "        ", "feat_h", ",", "feat_w", "=", "concat_feat", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "loss_B_shift", ",", "loss_mask_shift", "=", "torch", ".", "zeros", "(", "1", ")", ",", "torch", ".", "zeros", "(", "1", ")", "\n", "bs", "=", "loc_ref", ".", "size", "(", "0", ")", "\n", "n_pos", "=", "0", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "ids_t_ref_cur", "=", "ids_t_ref", "[", "i", "]", ".", "clone", "(", ")", "\n", "# select instances that exists in both two frames", "\n", "gt_ids_ref", "=", "gt_ids", "[", "i", "]", "[", "0", "]", "\n", "gt_ids_next", "=", "gt_ids", "[", "i", "]", "[", "1", "]", "\n", "gt_bboxes_reg", "=", "torch", ".", "zeros_like", "(", "loc_ref", "[", "i", "]", ")", "\n", "for", "j", ",", "id", "in", "enumerate", "(", "gt_ids_ref", ")", ":", "\n", "                ", "if", "id", "in", "gt_ids_next", ":", "\n", "                    ", "keep_inst", "=", "ids_t_ref_cur", "==", "id", "\n", "# calculate tracking regression values between two frames of bounding boxes", "\n", "gt_bbox_ref", "=", "gt_bboxes", "[", "i", "]", "[", "0", "]", "[", "j", "]", ".", "view", "(", "1", ",", "4", ")", "\n", "gt_bbox_next", "=", "gt_bboxes", "[", "i", "]", "[", "1", "]", "[", "gt_ids_next", "==", "id", "]", ".", "view", "(", "1", ",", "4", ")", "\n", "gt_bboxes_reg_cur", "=", "encode", "(", "gt_bbox_next", ",", "center_size", "(", "gt_bbox_ref", ")", ")", "\n", "gt_bboxes_reg", "[", "keep_inst", "]", "=", "gt_bboxes_reg_cur", ".", "repeat", "(", "keep_inst", ".", "sum", "(", ")", ",", "1", ")", "\n", "", "else", ":", "\n", "                    ", "ids_t_ref_cur", "[", "ids_t_ref", "[", "i", "]", "==", "id", "]", "=", "0", "\n", "\n", "", "", "gt_bboxes_reg", "=", "Variable", "(", "gt_bboxes_reg", ",", "requires_grad", "=", "False", ")", "\n", "pos", "=", "ids_t_ref_cur", ">", "0", "\n", "\n", "if", "pos", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "n_pos", "+=", "pos", ".", "sum", "(", ")", "\n", "loc_p", "=", "loc_ref", "[", "i", "]", "[", "pos", "]", ".", "view", "(", "-", "1", ",", "4", ")", ".", "detach", "(", ")", "\n", "priors_p", "=", "priors", "[", "pos", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "bbox_p", "=", "decode", "(", "loc_p", ",", "priors_p", ",", "cfg", ".", "use_yolo_regressors", ")", "\n", "\n", "# extract features on the predicted bbox", "\n", "bbox_feats", "=", "bbox_feat_extractor", "(", "concat_feat", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", ",", "bbox_p", ",", "feat_h", ",", "feat_w", ",", "7", ")", "\n", "# display_correlation_map_patch(bbox_feats[:, :121])", "\n", "bbox_reg", ",", "shift_mask_coeff", "=", "net", ".", "TemporalNet", "(", "bbox_feats", ")", "\n", "pre_loss_B", "=", "F", ".", "smooth_l1_loss", "(", "bbox_reg", ",", "gt_bboxes_reg", "[", "pos", "]", ",", "reduction", "=", "'none'", ")", ".", "sum", "(", "1", ")", "\n", "loss_B_shift", "+=", "pre_loss_B", ".", "mean", "(", ")", "\n", "\n", "if", "cfg", ".", "maskshift_loss", ":", "\n", "# create mask_gt and bbox_gt in the reference frame", "\n", "                ", "cur_pos_ids_t", "=", "ids_t_ref_cur", "[", "pos", "]", "\n", "pos_idx_t", "=", "[", "gt_ids", "[", "i", "]", "[", "1", "]", ".", "tolist", "(", ")", ".", "index", "(", "id", ")", "for", "id", "in", "cur_pos_ids_t", "]", "\n", "bbox_t_next", "=", "gt_bboxes", "[", "i", "]", "[", "1", "]", "[", "pos_idx_t", "]", "\n", "mask_t_next", "=", "gt_masks", "[", "i", "]", "[", "1", "]", "[", "pos_idx_t", "]", ".", "float", "(", ")", "\n", "\n", "tar_mask_coeff", "=", "mask_data_ref", "[", "i", ",", "pos", "]", "+", "shift_mask_coeff", "\n", "\n", "if", "cfg", ".", "mask_proto_crop", ":", "\n", "                    ", "pred_masks_soft", "=", "generate_mask", "(", "proto_data_next", "[", "i", "]", ",", "tar_mask_coeff", ",", "bbox_t_next", ")", "# [n, h, w]", "\n", "", "else", ":", "\n", "                    ", "pred_masks_soft", "=", "generate_mask", "(", "proto_data_next", "[", "i", "]", ",", "tar_mask_coeff", ")", "\n", "\n", "", "mask_gt_h", ",", "mask_gt_w", "=", "mask_t_next", ".", "size", "(", ")", "[", "1", ":", "]", "\n", "upsampled_pred_masks", "=", "F", ".", "interpolate", "(", "pred_masks_soft", ".", "unsqueeze", "(", "0", ")", ",", "\n", "(", "mask_gt_h", ",", "mask_gt_w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_mask_activation", "==", "activation_func", ".", "sigmoid", ":", "\n", "                    ", "pre_loss", "=", "F", ".", "binary_cross_entropy", "(", "torch", ".", "clamp", "(", "upsampled_pred_masks", ",", "0", ",", "1", ")", ",", "mask_t_next", ",", "\n", "reduction", "=", "'none'", ")", "\n", "", "else", ":", "\n", "                    ", "pre_loss", "=", "F", ".", "smooth_l1_loss", "(", "upsampled_pred_masks", ",", "mask_t_next", ",", "reduction", "=", "'none'", ")", "\n", "\n", "", "if", "cfg", ".", "mask_proto_crop", ":", "\n", "                    ", "pos_get_csize", "=", "center_size", "(", "bbox_t_next", ")", "\n", "gt_box_width", "=", "pos_get_csize", "[", ":", ",", "2", "]", "*", "mask_gt_w", "\n", "gt_box_height", "=", "pos_get_csize", "[", ":", ",", "3", "]", "*", "mask_gt_h", "\n", "pre_loss", "=", "pre_loss", ".", "sum", "(", "dim", "=", "(", "1", ",", "2", ")", ")", "/", "gt_box_width", "/", "gt_box_height", "\n", "loss_mask_shift", "+=", "torch", ".", "mean", "(", "pre_loss", ")", "\n", "", "else", ":", "\n", "                    ", "loss_mask_shift", "+=", "torch", ".", "mean", "(", "pre_loss", ")", "/", "mask_gt_h", "/", "mask_gt_w", "\n", "\n", "", "", "", "losses", "=", "{", "'B_shift'", ":", "loss_B_shift", "/", "bs", "*", "cfg", ".", "boxshift_alpha", "}", "\n", "if", "cfg", ".", "maskshift_loss", ":", "\n", "            ", "losses", "[", "'M_shift'", "]", "=", "loss_mask_shift", "/", "bs", "*", "cfg", ".", "maskshift_alpha", "\n", "\n", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.track_loss": [[328, 352], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "loss_weights.triu_", "cos_sim.triu_", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "loss_m.triu_", "pos_track_data.t", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "loss_weights.sum", "pos_ids_t.view", "pos_ids_t.view", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp.log", "torch.clamp.log", "torch.clamp.log", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log"], ["", "def", "track_loss", "(", "self", ",", "pos_weights_per_img", ",", "track_data", ",", "conf_t", ",", "ids_t", "=", "None", ")", ":", "\n", "        ", "pos", "=", "conf_t", ">", "0", "# [2, n]", "\n", "\n", "pos_track_data", "=", "track_data", "[", "pos", "]", "\n", "pos_ids_t", "=", "ids_t", "[", "pos", "]", "\n", "cos_sim", "=", "pos_track_data", "@", "pos_track_data", ".", "t", "(", ")", "# [n_pos, n_ref_pos]", "\n", "inst_eq", "=", "(", "pos_ids_t", ".", "view", "(", "-", "1", ",", "1", ")", "==", "pos_ids_t", ".", "view", "(", "1", ",", "-", "1", ")", ")", ".", "float", "(", ")", "\n", "cur_weights", "=", "torch", ".", "cat", "(", "pos_weights_per_img", ")", "\n", "loss_weights", "=", "cur_weights", ".", "view", "(", "-", "1", ",", "1", ")", "@", "cur_weights", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "loss_weights", ".", "triu_", "(", "diagonal", "=", "1", ")", "\n", "\n", "# Rescale to be between 0 and 1", "\n", "cos_sim", "=", "(", "cos_sim", "+", "1", ")", "/", "2", "\n", "cos_sim", ".", "triu_", "(", "diagonal", "=", "1", ")", "\n", "\n", "# If they are the same instance, use cosine distance, else use consine similarity", "\n", "# loss += ((1 - cos_sim) * inst_eq + cos_sim * (1 - inst_eq)).sum() / (cos_sim.size(0) * cos_sim.size(1))", "\n", "# pos: -log(cos_sim), neg: -log(1-cos_sim)", "\n", "cos_sim_diff", "=", "torch", ".", "clamp", "(", "1", "-", "cos_sim", ",", "min", "=", "1e-10", ")", "\n", "loss_m", "=", "-", "1", "*", "(", "inst_eq", "*", "torch", ".", "clamp", "(", "cos_sim", ",", "min", "=", "1e-10", ")", ".", "log", "(", ")", "+", "(", "1", "-", "inst_eq", ")", "*", "cos_sim_diff", ".", "log", "(", ")", ")", "\n", "loss_m", ".", "triu_", "(", "diagonal", "=", "1", ")", "\n", "loss", "=", "(", "loss_m", "*", "loss_weights", ")", ".", "sum", "(", ")", "\n", "\n", "return", "loss", "*", "cfg", ".", "track_alpha", "/", "loss_weights", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.instance_conf_loss": [[353, 386], ["conf_data.size", "range", "multibox_loss.MultiBoxLoss.get_inst_conf", "multibox_loss.MultiBoxLoss.get_inst_conf", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "all_inst_pt.append", "all_inst_conf_t.append", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.unique.size", "torch.unique.size", "torch.unique.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.get_inst_conf", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.get_inst_conf", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "def", "instance_conf_loss", "(", "self", ",", "pos_weights_per_img", ",", "ref_pos_weights_per_img", ",", "conf_data", ",", "ref_conf_data", ",", "\n", "conf_t", ",", "ref_conf_t", ",", "ids_t", ",", "ref_ids_t", ")", ":", "\n", "        ", "batch_size", ",", "num_priors", ",", "n_classes", "=", "conf_data", ".", "size", "(", ")", "\n", "loss", "=", "0", "\n", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "# calculate the instance confident in a single frame: the mean of the bboxes with same instance id", "\n", "            ", "inst_pt", ",", "inst_conf_t", ",", "inst_id", "=", "self", ".", "get_inst_conf", "(", "pos_weights_per_img", "[", "idx", "]", ",", "conf_data", "[", "idx", "]", ",", "conf_t", "[", "idx", "]", ",", "ids_t", "[", "idx", "]", ")", "\n", "ref_inst_pt", ",", "ref_inst_conf_t", ",", "ref_inst_id", "=", "self", ".", "get_inst_conf", "(", "ref_pos_weights_per_img", "[", "idx", "]", ",", "ref_conf_data", "[", "idx", "]", ",", "\n", "ref_conf_t", "[", "idx", "]", ",", "ref_ids_t", "[", "idx", "]", ")", "\n", "\n", "# get the instance confident cross multi frames by mean them in different frames", "\n", "all_inst_id", "=", "torch", ".", "unique", "(", "torch", ".", "cat", "(", "[", "inst_id", ",", "ref_inst_id", "]", ")", ")", "\n", "all_inst_pt", ",", "all_inst_conf_t", "=", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "id", "in", "enumerate", "(", "all_inst_id", ")", ":", "\n", "                ", "used_idx", "=", "inst_id", "==", "id", "\n", "used_ref_idx", "=", "ref_inst_id", "==", "id", "\n", "if", "id", "in", "inst_id", "and", "id", "in", "ref_inst_id", ":", "\n", "                    ", "inst_pt_id", "=", "(", "inst_pt", "[", "used_idx", "]", "+", "ref_inst_pt", "[", "used_ref_idx", "]", ")", "/", "2.0", "\n", "inst_conf_t_id", "=", "inst_conf_t", "[", "used_idx", "]", "\n", "", "elif", "id", "in", "inst_id", ":", "\n", "                    ", "inst_pt_id", "=", "inst_pt", "[", "used_idx", "]", "\n", "inst_conf_t_id", "=", "inst_conf_t", "[", "used_idx", "]", "\n", "", "else", ":", "\n", "                    ", "inst_pt_id", "=", "ref_inst_pt", "[", "used_ref_idx", "]", "\n", "inst_conf_t_id", "=", "ref_inst_conf_t", "[", "used_ref_idx", "]", "\n", "", "all_inst_pt", ".", "append", "(", "inst_pt_id", ")", "\n", "all_inst_conf_t", ".", "append", "(", "inst_conf_t_id", ")", "\n", "\n", "# get the confident loss of instances in the a short subset (includes 2 frames here)", "\n", "", "loss", "+=", "F", ".", "cross_entropy", "(", "torch", ".", "cat", "(", "all_inst_pt", ",", "dim", "=", "0", ")", ",", "torch", ".", "cat", "(", "all_inst_conf_t", ")", ",", "reduction", "=", "'sum'", ")", "/", "all_inst_id", ".", "size", "(", "0", ")", "\n", "\n", "", "return", "loss", "/", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.get_inst_conf": [[387, 401], ["torch.softmax", "torch.softmax", "torch.softmax", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "[].view", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "pos_pt[].sum", "range", "range", "len", "len"], "methods", ["None"], ["", "def", "get_inst_conf", "(", "self", ",", "pos_weights", ",", "conf_data", ",", "conf_t", ",", "ids_t", ")", ":", "\n", "# put bboxes with same instances ids into a set, called instance confidence", "\n", "        ", "pos", "=", "(", "conf_t", ">", "0", ")", "\n", "pos_pt", "=", "F", ".", "softmax", "(", "conf_data", "[", "pos", "]", ",", "-", "1", ")", "# [n_pos, 41]", "\n", "pos_ids_t", "=", "ids_t", "[", "pos", "]", "\n", "pos_conf_t", "=", "conf_t", "[", "pos", "]", "\n", "\n", "# merge those bboxes with same instances into a subset", "\n", "# use the conf data's mean of all bboxes in the subset as the conf data of the instance in the subset", "\n", "inst_id", ",", "inv_id", "=", "torch", ".", "unique", "(", "pos_ids_t", ",", "sorted", "=", "True", ",", "return_inverse", "=", "True", ")", "\n", "inst_pt", "=", "[", "pos_pt", "[", "inv_id", "==", "i", "]", ".", "sum", "(", "dim", "=", "0", ")", "/", "(", "inv_id", "==", "i", ")", ".", "sum", "(", ")", "for", "i", "in", "range", "(", "len", "(", "inst_id", ")", ")", "]", "\n", "inst_conf_t", "=", "[", "pos_conf_t", "[", "inv_id", "==", "i", "]", "[", "0", "]", ".", "view", "(", "1", ")", "for", "i", "in", "range", "(", "len", "(", "inst_id", ")", ")", "]", "\n", "\n", "return", "torch", ".", "stack", "(", "inst_pt", ",", "dim", "=", "0", ")", ",", "torch", ".", "cat", "(", "inst_conf_t", ")", ",", "inst_id", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.select_neg_bboxes": [[402, 427], ["torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "loss_c.sort", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "conf_t.view.view.view", "torch.softmax.view", "torch.softmax", "torch.softmax", "torch.softmax", "conf_data[].max", "conf_t.view.view.size", "len", "len", "box_utils.log_sum_exp", "conf_t.view.view.get_device", "conf_t.view.view.size", "torch.softmax.size", "conf_t.view.view.size"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.log_sum_exp"], ["", "def", "select_neg_bboxes", "(", "self", ",", "conf_data", ",", "conf_t", ")", ":", "\n", "        ", "if", "len", "(", "conf_t", ".", "size", "(", ")", ")", "==", "2", "or", "len", "(", "conf_data", ".", "size", "(", ")", ")", "==", "3", ":", "\n", "            ", "conf_t", "=", "conf_t", ".", "view", "(", "-", "1", ")", "# [batch_size*num_priors]", "\n", "conf_data", "=", "conf_data", ".", "view", "(", "-", "1", ",", "self", ".", "num_classes", ")", "# [batch_size*num_priors, num_classes]", "\n", "\n", "# Compute max conf across batch for hard negative mining", "\n", "", "if", "cfg", ".", "ohem_use_most_confident", ":", "\n", "            ", "conf_data", "=", "F", ".", "softmax", "(", "conf_data", ",", "dim", "=", "1", ")", "\n", "loss_c", ",", "_", "=", "conf_data", "[", ":", ",", "1", ":", "]", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "loss_c", "=", "log_sum_exp", "(", "conf_data", ")", "-", "conf_data", "[", ":", ",", "0", "]", "\n", "\n", "# Hard Negative Mining", "\n", "", "num_pos", "=", "(", "conf_t", ">", "0", ")", ".", "sum", "(", ")", "\n", "num_neg", "=", "torch", ".", "clamp", "(", "self", ".", "negpos_ratio", "*", "num_pos", ",", "max", "=", "conf_t", ".", "size", "(", ")", "[", "0", "]", "-", "1", ")", "\n", "loss_c", "[", "conf_t", ">", "0", "]", "=", "0", "# filter out pos samples and neutrals", "\n", "loss_c", "[", "conf_t", "<", "0", "]", "=", "0", "# filter out pos samples and neutrals", "\n", "_", ",", "loss_idx", "=", "loss_c", ".", "sort", "(", "descending", "=", "True", ")", "\n", "neg", "=", "torch", ".", "zeros", "(", "conf_t", ".", "size", "(", ")", ",", "device", "=", "conf_t", ".", "get_device", "(", ")", ")", "\n", "neg", "[", "loss_idx", "[", ":", "num_neg", "]", "]", "=", "1", "\n", "# Just in case there aren't enough negatives, don't start using positives as negatives", "\n", "neg", "[", "conf_t", ">", "0", "]", "=", "0", "# filter out pos samplers and neutrals", "\n", "neg", "[", "conf_t", "<", "0", "]", "=", "0", "# filter out pos samplers and neutrals", "\n", "\n", "return", "neg", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.ohem_conf_loss": [[428, 458], ["conf_t.view.view.size", "conf_t.view.view.view", "conf_data.view.view.view", "multibox_loss.MultiBoxLoss.select_neg_bboxes", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "pos.gt.gt.gt", "box_utils.decode", "multibox_loss.MultiBoxLoss.get_DIoU", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "loc.view", "priors.view", "gt_boxes_t.view", "centerness_data.view"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.select_neg_bboxes", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.get_DIoU"], ["", "def", "ohem_conf_loss", "(", "self", ",", "pos_weights", ",", "conf_data", ",", "conf_t", ",", "centerness_data", ",", "loc", ",", "priors", ",", "gt_boxes_t", ")", ":", "\n", "        ", "\"\"\"\n        Focal loss but using sigmoid like the original paper.\n        Note: To make things mesh easier, the network still predicts 81 class confidences in this mode.\n              Because retinanet originally only predicts 80, we simply just don't use conf_data[..., 0]\n        \"\"\"", "\n", "batch_size", "=", "conf_t", ".", "size", "(", "0", ")", "\n", "conf_t", "=", "conf_t", ".", "view", "(", "-", "1", ")", "\n", "conf_data", "=", "conf_data", ".", "view", "(", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "\n", "pos", "=", "(", "conf_t", ">", "0", ")", ".", "float", "(", ")", "\n", "neg", "=", "self", ".", "select_neg_bboxes", "(", "conf_data", ",", "conf_t", ")", "\n", "keep", "=", "(", "pos", "+", "neg", ")", ".", "gt", "(", "0", ")", "\n", "use_conf_t", "=", "conf_t", "[", "keep", "]", "\n", "use_conf_data", "=", "conf_data", "[", "keep", "]", "\n", "num_neg", "=", "(", "neg", ">", "0", ")", ".", "sum", "(", ")", "\n", "neg_weights", "=", "torch", ".", "ones", "(", "num_neg", ",", "device", "=", "pos_weights", ".", "device", ")", "/", "num_neg", "*", "self", ".", "negpos_ratio", "*", "batch_size", "\n", "loss_weights", "=", "torch", ".", "cat", "(", "[", "pos_weights", ",", "neg_weights", "]", ")", "\n", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "use_conf_data", ",", "use_conf_t", ",", "reduction", "=", "'none'", ")", "\n", "losses", "=", "{", "'C'", ":", "cfg", ".", "conf_alpha", "*", "(", "loss_weights", "*", "loss", ")", ".", "sum", "(", ")", "/", "(", "self", ".", "negpos_ratio", "+", "1", ")", "}", "\n", "\n", "if", "centerness_data", "is", "not", "None", ":", "\n", "            ", "pos", "=", "pos", ".", "gt", "(", "0", ")", "\n", "decoded_loc", "=", "decode", "(", "loc", ".", "view", "(", "-", "1", ",", "4", ")", "[", "pos", "]", ",", "priors", ".", "view", "(", "-", "1", ",", "4", ")", "[", "pos", "]", ",", "cfg", ".", "use_yolo_regressors", ")", "\n", "DIoU", "=", "self", ".", "get_DIoU", "(", "decoded_loc", ",", "gt_boxes_t", ".", "view", "(", "-", "1", ",", "4", ")", "[", "pos", "]", ")", "\n", "loss_cn", "=", "F", ".", "smooth_l1_loss", "(", "centerness_data", ".", "view", "(", "-", "1", ")", "[", "pos", "]", ",", "DIoU", ",", "reduction", "=", "'none'", ")", "\n", "losses", "[", "'center'", "]", "=", "cfg", ".", "center_alpha", "*", "(", "pos_weights", "*", "loss_cn", ")", ".", "sum", "(", ")", "\n", "\n", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.focal_conf_loss": [[459, 478], ["conf_t.view.view.view", "conf_data.view.view.view", "multibox_loss.MultiBoxLoss.select_neg_bboxes", "conf_data[].view", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "conf_t[].view", "logpt.gather().view.gather().view.gather().view", "logpt.gather().view.gather().view.exp", "at[].view", "loss_c.sum", "logpt.gather().view.gather().view.gather", "pos.float", "multibox_loss.MultiBoxLoss.float", "conf_t[].view.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.select_neg_bboxes", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather"], ["", "def", "focal_conf_loss", "(", "self", ",", "conf_data", ",", "conf_t", ")", ":", "\n", "        ", "conf_t", "=", "conf_t", ".", "view", "(", "-", "1", ")", "\n", "conf_data", "=", "conf_data", ".", "view", "(", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "pos", "=", "(", "conf_t", ">", "0", ")", ".", "float", "(", ")", "\n", "neg", "=", "self", ".", "select_neg_bboxes", "(", "conf_data", ",", "conf_t", ")", "\n", "keep", "=", "(", "pos", "+", "neg", ")", ".", "gt", "(", "0", ")", "\n", "\n", "# Confidence Loss Including Positive and Negative Examples", "\n", "# adapted from focal loss to reduce the effect of class unbalance", "\n", "conf_p", "=", "conf_data", "[", "keep", "]", ".", "view", "(", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "logpt", "=", "F", ".", "log_softmax", "(", "conf_p", ",", "dim", "=", "-", "1", ")", "\n", "use_conf_t", "=", "conf_t", "[", "keep", "]", ".", "view", "(", "-", "1", ")", "\n", "logpt", "=", "logpt", ".", "gather", "(", "1", ",", "use_conf_t", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "pt", "=", "logpt", ".", "exp", "(", ")", "\n", "at", "=", "(", "1", "-", "cfg", ".", "focal_loss_alpha", ")", "*", "pos", ".", "float", "(", ")", "+", "cfg", ".", "focal_loss_alpha", "*", "neg", ".", "float", "(", ")", "\n", "at", "=", "at", "[", "keep", "]", ".", "view", "(", "-", "1", ")", "\n", "loss_c", "=", "-", "1", "*", "at", "*", "(", "1", "-", "pt", ")", "**", "cfg", ".", "focal_loss_gamma", "*", "logpt", "\n", "\n", "return", "cfg", ".", "conf_alpha", "*", "loss_c", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.focal_conf_sigmoid_loss": [[479, 512], ["conf_data.view.view.size", "conf_t.view.view.view", "conf_data.view.view.view", "torch.logsigmoid", "torch.logsigmoid", "torch.logsigmoid", "torch.logsigmoid.exp", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "loss.sum", "conf_t.view.view.get_device", "keep.sum", "loss.sum"], "methods", ["None"], ["", "def", "focal_conf_sigmoid_loss", "(", "self", ",", "conf_data", ",", "conf_t", ")", ":", "\n", "        ", "\"\"\"\n        Focal loss but using sigmoid like the original paper.\n        Note: To make things mesh easier, the network still predicts 81 class confidences in this mode.\n              Because retinanet originally only predicts 80, we simply just don't use conf_data[..., 0]\n        \"\"\"", "\n", "\n", "bs", ",", "_", ",", "num_classes", "=", "conf_data", ".", "size", "(", ")", "\n", "\n", "conf_t", "=", "conf_t", ".", "view", "(", "-", "1", ")", "# [batch_size*num_priors]", "\n", "conf_data", "=", "conf_data", ".", "view", "(", "-", "1", ",", "num_classes", ")", "# [batch_size*num_priors, num_classes]", "\n", "\n", "# Ignore neutral samples (class < 0)", "\n", "keep", "=", "(", "conf_t", ">=", "0", ")", ".", "float", "(", ")", "\n", "conf_t", "[", "conf_t", "<", "0", "]", "=", "0", "# can't mask with -1, so filter that out", "\n", "\n", "# Compute a one-hot embedding of conf_t", "\n", "# From https://github.com/kuangliu/pytorch-retinanet/blob/master/utils.py", "\n", "conf_one_t", "=", "torch", ".", "eye", "(", "num_classes", ",", "device", "=", "conf_t", ".", "get_device", "(", ")", ")", "[", "conf_t", "]", "\n", "conf_pm_t", "=", "conf_one_t", "*", "2", "-", "1", "# -1 if background, +1 if forground for specific class", "\n", "\n", "logpt", "=", "F", ".", "logsigmoid", "(", "conf_data", "*", "conf_pm_t", ")", "# note: 1 - sigmoid(x) = sigmoid(-x)", "\n", "pt", "=", "logpt", ".", "exp", "(", ")", "\n", "\n", "at", "=", "cfg", ".", "focal_loss_alpha", "*", "conf_one_t", "+", "(", "1", "-", "cfg", ".", "focal_loss_alpha", ")", "*", "(", "1", "-", "conf_one_t", ")", "\n", "at", "[", "...", ",", "0", "]", "=", "0", "# Set alpha for the background class to 0 because sigmoid focal loss doesn't use it", "\n", "\n", "loss", "=", "-", "at", "*", "(", "1", "-", "pt", ")", "**", "cfg", ".", "focal_loss_gamma", "*", "logpt", "\n", "loss", "=", "keep", "*", "loss", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "losses", "=", "{", "'C'", ":", "cfg", ".", "conf_alpha", "*", "loss", ".", "sum", "(", ")", "/", "keep", ".", "sum", "(", ")", "*", "bs", "}", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.coeff_sparse_loss": [[513, 518], ["torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["None"], ["", "def", "coeff_sparse_loss", "(", "self", ",", "coeffs", ")", ":", "\n", "        ", "\"\"\"\n        coeffs:  should be size [num_pos, num_coeffs]\n        \"\"\"", "\n", "torch", ".", "abs", "(", "coeffs", ")", ".", "sum", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.coeff_diversity_loss": [[519, 543], ["coeffs.size", "instance_t.view.view.view", "torch.normalize", "torch.normalize", "torch.normalize", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.normalize.t", "weights.view", "weights.view", "instance_t[].expand_as", "instance_t[].expand_as", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp().log", "torch.clamp.log", "torch.clamp.log", "torch.clamp.log", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log"], ["", "def", "coeff_diversity_loss", "(", "self", ",", "weights", ",", "coeffs", ",", "instance_t", ")", ":", "\n", "        ", "\"\"\"\n        coeffs     should be size [num_pos, num_coeffs]\n        instance_t should be size [num_pos] and be values from 0 to num_instances-1\n        \"\"\"", "\n", "num_pos", "=", "coeffs", ".", "size", "(", "0", ")", "\n", "instance_t", "=", "instance_t", ".", "view", "(", "-", "1", ")", "# juuuust to make sure", "\n", "\n", "coeffs_norm", "=", "F", ".", "normalize", "(", "coeffs", ",", "dim", "=", "1", ")", "\n", "cos_sim", "=", "torch", ".", "mm", "(", "coeffs_norm", ",", "coeffs_norm", ".", "t", "(", ")", ")", "\n", "\n", "inst_eq", "=", "(", "instance_t", "[", ":", ",", "None", "]", ".", "expand_as", "(", "cos_sim", ")", "==", "instance_t", "[", "None", ",", ":", "]", ".", "expand_as", "(", "cos_sim", ")", ")", ".", "float", "(", ")", "\n", "\n", "# Rescale to be between 0 and 1", "\n", "cos_sim", "=", "(", "cos_sim", "+", "1", ")", "/", "2", "\n", "\n", "# If they're the same instance, use cosine distance, else use cosine similarity", "\n", "cos_sim_diff", "=", "torch", ".", "clamp", "(", "1", "-", "cos_sim", ",", "min", "=", "1e-10", ")", "\n", "loss", "=", "-", "1", "*", "(", "torch", ".", "clamp", "(", "cos_sim", ",", "min", "=", "1e-10", ")", ".", "log", "(", ")", "*", "inst_eq", "+", "cos_sim_diff", ".", "log", "(", ")", "*", "(", "1", "-", "inst_eq", ")", ")", "\n", "weights", "=", "weights", ".", "view", "(", "-", "1", ",", "1", ")", "*", "weights", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "\n", "# Only divide by num_pos once because we're summing over a num_pos x num_pos tensor", "\n", "# and all the losses will be divided by num_pos at the end, so just one extra time.", "\n", "return", "cfg", ".", "mask_proto_coeff_diversity_alpha", "*", "(", "weights", "*", "loss", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.lincomb_mask_loss": [[544, 656], ["range", "mask_data.size", "box_utils.decode().detach", "box_utils.center_size", "box_utils.point_form", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "[].float", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "pos_idx_t.size", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "mask_utils.generate_mask", "mask_utils.generate_mask", "[].float.size", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "box_utils.center_size", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "upsampled_pred_masks.gt().float.gt().float.view().gt().float", "[].float.view", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "upsampled_pred_masks.gt().float.gt().float.unsqueeze", "upsampled_pred_masks.gt().float.gt().float.gt().float", "multibox_loss.MultiBoxLoss._mask_iou", "maskiou_net_input_list.append", "maskiou_t_list.append", "label_t_list.append", "len", "box_utils.decode", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "multibox_loss.MultiBoxLoss.coeff_diversity_loss", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "mask_utils.generate_mask.unsqueeze", "torch.smooth_l1_loss.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "upsampled_pred_masks.gt().float.gt().float.view().gt", "upsampled_pred_masks.gt().float.view().gt().float.sum", "[].float.view.sum", "upsampled_pred_masks.gt().float.gt().float.gt", "upsampled_pred_masks.gt().float.gt().float.view"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.center_size", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.point_form", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.mask_utils.generate_mask", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.center_size", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss._mask_iou", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.decode", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.coeff_diversity_loss"], ["", "def", "lincomb_mask_loss", "(", "self", ",", "pos_weights_per_img", ",", "pos", ",", "idx_t", ",", "ids_t", ",", "loc_data", ",", "mask_data", ",", "score_data", ",", "\n", "priors", ",", "proto_data", ",", "masks_gt", ",", "gt_box_t", ",", "labels_gt", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "        ", "process_gt_bboxes", "=", "cfg", ".", "mask_proto_normalize_emulate_roi_pooling", "or", "cfg", ".", "mask_proto_crop", "\n", "\n", "loss_m", ",", "loss_miou", "=", "0", ",", "0", "\n", "loss_d", "=", "0", "# Coefficient diversity loss", "\n", "proto_coef_clip", ",", "pos_ids_clip", ",", "weights_clip", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "maskiou_t_list", "=", "[", "]", "\n", "maskiou_net_input_list", "=", "[", "]", "\n", "label_t_list", "=", "[", "]", "\n", "\n", "for", "idx", "in", "range", "(", "mask_data", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "cur_pos", "=", "pos", "[", "idx", "]", "\n", "pos_idx_t", "=", "idx_t", "[", "idx", ",", "cur_pos", "]", "\n", "pos_ids_t", "=", "ids_t", "[", "idx", ",", "cur_pos", "]", "\n", "pos_pred_box", "=", "decode", "(", "loc_data", "[", "idx", ",", "cur_pos", "]", ",", "priors", "[", "idx", ",", "cur_pos", "]", ",", "cfg", ".", "use_yolo_regressors", ")", ".", "detach", "(", ")", "\n", "pos_pred_box", "=", "center_size", "(", "pos_pred_box", ")", "\n", "pos_pred_box", "[", ":", ",", "2", ":", "]", "*=", "1.2", "\n", "pos_pred_box", "=", "point_form", "(", "pos_pred_box", ")", "\n", "pos_pred_box", "=", "torch", ".", "clamp", "(", "pos_pred_box", ",", "min", "=", "1e-5", ",", "max", "=", "1", ")", "\n", "\n", "if", "process_gt_bboxes", ":", "\n", "# Note: this is in point-form", "\n", "                ", "if", "cfg", ".", "mask_proto_crop_with_pred_box", ":", "\n", "                    ", "pos_gt_box_t", "=", "pos_pred_box", "\n", "", "else", ":", "\n", "                    ", "pos_gt_box_t", "=", "gt_box_t", "[", "idx", ",", "cur_pos", "]", "\n", "\n", "", "", "if", "pos_idx_t", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "mask_t", "=", "masks_gt", "[", "idx", "]", "[", "pos_idx_t", "]", ".", "float", "(", ")", "# [n, h, w]", "\n", "label_t", "=", "labels_gt", "[", "idx", "]", "[", "pos_idx_t", "]", "\n", "\n", "proto_masks", "=", "proto_data", "[", "idx", "]", "# [mask_h, mask_w, 32]", "\n", "proto_coef", "=", "mask_data", "[", "idx", ",", "cur_pos", ",", ":", "]", "# [num_pos, 32]", "\n", "if", "cfg", ".", "use_mask_scoring", ":", "\n", "                ", "mask_scores", "=", "score_data", "[", "idx", ",", "cur_pos", ",", ":", "]", "\n", "", "if", "cfg", ".", "mask_proto_coeff_diversity_loss", ":", "\n", "                ", "proto_coef_clip", ".", "append", "(", "proto_coef", ")", "\n", "pos_ids_clip", ".", "append", "(", "pos_ids_t", ")", "\n", "weights_clip", ".", "append", "(", "pos_weights_per_img", "[", "idx", "]", ")", "\n", "if", "(", "idx", "+", "1", ")", "%", "2", "==", "0", ":", "\n", "                    ", "proto_coef_clip", "=", "torch", ".", "cat", "(", "proto_coef_clip", ",", "dim", "=", "0", ")", "\n", "pos_ids_clip", "=", "torch", ".", "cat", "(", "pos_ids_clip", ",", "dim", "=", "0", ")", "\n", "weights_clip", "=", "torch", ".", "cat", "(", "weights_clip", ",", "dim", "=", "0", ")", "\n", "loss_d", "+=", "self", ".", "coeff_diversity_loss", "(", "weights_clip", ",", "proto_coef_clip", ",", "pos_ids_clip", ")", "\n", "proto_coef_clip", ",", "pos_ids_clip", ",", "weights_clip", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "", "", "if", "cfg", ".", "mask_proto_crop", ":", "\n", "                ", "pred_masks_soft", "=", "generate_mask", "(", "proto_masks", ",", "proto_coef", ",", "pos_gt_box_t", ")", "# [n_pos, mask_h, mask_w]", "\n", "", "else", ":", "\n", "                ", "pred_masks_soft", "=", "generate_mask", "(", "proto_masks", ",", "proto_coef", ")", "\n", "", "mask_gt_h", ",", "mask_gt_w", "=", "mask_t", ".", "size", "(", ")", "[", "1", ":", "]", "\n", "upsampled_pred_masks", "=", "F", ".", "interpolate", "(", "pred_masks_soft", ".", "unsqueeze", "(", "0", ")", ",", "\n", "(", "mask_gt_h", ",", "mask_gt_w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_mask_activation", "==", "activation_func", ".", "sigmoid", ":", "\n", "                ", "pre_loss", "=", "F", ".", "binary_cross_entropy", "(", "torch", ".", "clamp", "(", "upsampled_pred_masks", ",", "0", ",", "1", ")", ",", "mask_t", ",", "reduction", "=", "'none'", ")", "\n", "", "else", ":", "\n", "                ", "pre_loss", "=", "F", ".", "smooth_l1_loss", "(", "upsampled_pred_masks", ",", "mask_t", ",", "reduction", "=", "'none'", ")", "\n", "\n", "", "if", "cfg", ".", "mask_proto_crop", ":", "\n", "                ", "pos_get_csize", "=", "center_size", "(", "pos_gt_box_t", ")", "\n", "gt_box_width", "=", "pos_get_csize", "[", ":", ",", "2", "]", "*", "mask_gt_w", "\n", "gt_box_width", "=", "torch", ".", "clamp", "(", "gt_box_width", ",", "min", "=", "1", ")", "\n", "gt_box_height", "=", "pos_get_csize", "[", ":", ",", "3", "]", "*", "mask_gt_h", "\n", "gt_box_height", "=", "torch", ".", "clamp", "(", "gt_box_height", ",", "min", "=", "1", ")", "\n", "pre_loss", "=", "pre_loss", ".", "sum", "(", "dim", "=", "(", "1", ",", "2", ")", ")", "/", "gt_box_width", "/", "gt_box_height", "\n", "loss_m", "+=", "torch", ".", "sum", "(", "pos_weights_per_img", "[", "idx", "]", "*", "pre_loss", ")", "\n", "", "else", ":", "\n", "                ", "loss_m", "+=", "torch", ".", "sum", "(", "pos_weights_per_img", "[", "idx", "]", "*", "pre_loss", ")", "/", "mask_gt_h", "/", "mask_gt_w", "\n", "\n", "", "if", "cfg", ".", "use_maskiou_loss", ":", "\n", "# calculate", "\n", "                ", "tmp_pred_masks", "=", "upsampled_pred_masks", ".", "view", "(", "-", "1", ",", "mask_gt_h", "*", "mask_gt_w", ")", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "tmp_mask_t", "=", "mask_t", ".", "view", "(", "-", "1", ",", "mask_gt_h", "*", "mask_gt_w", ")", "\n", "intersection", "=", "(", "tmp_pred_masks", "*", "tmp_mask_t", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "union", "=", "(", "tmp_pred_masks", ".", "sum", "(", "dim", "=", "-", "1", ")", "+", "tmp_mask_t", ".", "sum", "(", "dim", "=", "-", "1", ")", ")", "-", "intersection", "\n", "union", "=", "torch", ".", "clamp", "(", "union", ",", "min", "=", "1e-10", ")", "\n", "loss_miou", "+=", "(", "1", "-", "intersection", "/", "union", ")", ".", "sum", "(", ")", "# [n_pos]", "\n", "\n", "", "if", "cfg", ".", "use_maskiou", ":", "\n", "                ", "maskiou_net_input", "=", "upsampled_pred_masks", ".", "unsqueeze", "(", "1", ")", "# [n, 1, h, w]", "\n", "upsampled_pred_masks", "=", "upsampled_pred_masks", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "maskiou_t", "=", "self", ".", "_mask_iou", "(", "upsampled_pred_masks", ",", "mask_t", ")", "\n", "\n", "maskiou_net_input_list", ".", "append", "(", "maskiou_net_input", ")", "\n", "maskiou_t_list", ".", "append", "(", "maskiou_t", ")", "\n", "label_t_list", ".", "append", "(", "label_t", ")", "\n", "\n", "", "", "losses", "=", "{", "'M'", ":", "loss_m", "*", "cfg", ".", "mask_alpha", "}", "\n", "\n", "if", "cfg", ".", "use_maskiou_loss", ":", "\n", "            ", "losses", "[", "'MIoU'", "]", "=", "loss_miou", "*", "cfg", ".", "maskiou_alpha", "\n", "\n", "", "if", "cfg", ".", "mask_proto_coeff_diversity_loss", ":", "\n", "            ", "losses", "[", "'D'", "]", "=", "loss_d", "\n", "\n", "", "if", "cfg", ".", "use_maskiou", ":", "\n", "# discard_mask_area discarded every mask in the batch, so nothing to do here", "\n", "            ", "if", "len", "(", "maskiou_t_list", ")", "==", "0", ":", "\n", "                ", "return", "losses", ",", "None", "\n", "\n", "", "maskiou_t", "=", "torch", ".", "cat", "(", "maskiou_t_list", ")", "\n", "label_t", "=", "torch", ".", "cat", "(", "label_t_list", ")", "\n", "maskiou_net_input", "=", "torch", ".", "cat", "(", "maskiou_net_input_list", ")", "\n", "\n", "return", "losses", ",", "[", "maskiou_net_input", ",", "maskiou_t", ",", "label_t", "]", "\n", "\n", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss._mask_iou": [[657, 664], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "_mask_iou", "(", "self", ",", "mask1", ",", "mask2", ")", ":", "\n", "        ", "intersection", "=", "torch", ".", "sum", "(", "mask1", "*", "mask2", ",", "dim", "=", "(", "0", ",", "1", ")", ")", "\n", "area1", "=", "torch", ".", "sum", "(", "mask1", ",", "dim", "=", "(", "0", ",", "1", ")", ")", "\n", "area2", "=", "torch", ".", "sum", "(", "mask2", ",", "dim", "=", "(", "0", ",", "1", ")", ")", "\n", "union", "=", "(", "area1", "+", "area2", ")", "-", "intersection", "\n", "ret", "=", "intersection", "/", "union", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.mask_iou_loss": [[665, 676], ["net.maskiou_net", "torch.gather().view", "torch.gather().view", "torch.gather().view", "torch.gather().view", "torch.gather().view", "torch.gather().view", "torch.gather().view", "torch.gather().view", "torch.gather().view", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather", "home.repos.pwc.inspect_result.MinghanLi_STMask.None.train.CustomDataParallel.gather"], ["", "def", "mask_iou_loss", "(", "self", ",", "net", ",", "maskiou_targets", ")", ":", "\n", "        ", "maskiou_net_input", ",", "maskiou_t", ",", "label_t", "=", "maskiou_targets", "\n", "\n", "maskiou_p", "=", "net", ".", "maskiou_net", "(", "maskiou_net_input", ")", "\n", "\n", "label_t", "=", "label_t", "[", ":", ",", "None", "]", "\n", "maskiou_p", "=", "torch", ".", "gather", "(", "maskiou_p", ",", "dim", "=", "1", ",", "index", "=", "label_t", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "loss_i", "=", "F", ".", "smooth_l1_loss", "(", "maskiou_p", ",", "maskiou_t", ",", "reduction", "=", "'sum'", ")", "\n", "\n", "return", "loss_i", "*", "cfg", ".", "maskiou_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.semantic_segmentation_loss": [[677, 703], ["segment_data.size", "range", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "downsampled_masks.gt().float.gt().float.gt().float", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "mask_t[].size", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.interpolate", "torch.interpolate", "torch.interpolate", "downsampled_masks.gt().float.gt().float.gt", "mask_t[].float().unsqueeze", "mask_t[].float"], "methods", ["None"], ["", "def", "semantic_segmentation_loss", "(", "self", ",", "segment_data", ",", "mask_t", ",", "class_t", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "# Note num_classes here is without the background class so cfg.num_classes-1", "\n", "        ", "batch_size", ",", "num_classes", ",", "mask_h", ",", "mask_w", "=", "segment_data", ".", "size", "(", ")", "\n", "# mask_h, mask_w = 2*mask_h, 2*mask_w", "\n", "loss_s", "=", "0", "\n", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "cur_segment", "=", "segment_data", "[", "idx", "]", "\n", "cur_class_t", "=", "class_t", "[", "idx", "]", "-", "1", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "downsampled_masks", "=", "F", ".", "interpolate", "(", "mask_t", "[", "idx", "]", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", ",", "(", "mask_h", ",", "mask_w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "downsampled_masks", "=", "downsampled_masks", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "# cur_segment = F.interpolate(cur_segment.unsqueeze(0), (mask_h, mask_w),", "\n", "#                             mode=interpolation_mode, align_corners=False).squeeze(0)", "\n", "\n", "# Construct Semantic Segmentation", "\n", "segment_t", "=", "torch", ".", "zeros_like", "(", "cur_segment", ",", "requires_grad", "=", "False", ")", "\n", "for", "obj_idx", "in", "range", "(", "mask_t", "[", "idx", "]", ".", "size", "(", "0", ")", ")", ":", "\n", "                    ", "segment_t", "[", "cur_class_t", "[", "obj_idx", "]", "]", "=", "torch", ".", "max", "(", "segment_t", "[", "cur_class_t", "[", "obj_idx", "]", "]", ",", "\n", "downsampled_masks", "[", "obj_idx", "]", ")", "\n", "\n", "", "", "loss_s", "+=", "F", ".", "binary_cross_entropy_with_logits", "(", "cur_segment", ",", "segment_t", ",", "reduction", "=", "'sum'", ")", "\n", "\n", "", "return", "loss_s", "/", "mask_h", "/", "mask_w", "*", "cfg", ".", "semantic_segmentation_alpha", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.Featurealign.FeatureAlign.__init__": [[7, 36], ["torch.Module.__init__", "isinstance", "mmcv.ops.DeformConv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "(", "3", ",", "3", ")", ",", "\n", "deformable_groups", "=", "4", ",", "\n", "use_pred_offset", "=", "True", ")", ":", "\n", "        ", "super", "(", "FeatureAlign", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "kernel_size", ",", "int", ")", ":", "\n", "            ", "kernel_size", "=", "(", "kernel_size", ",", "kernel_size", ")", "\n", "", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "padding", "=", "(", "(", "kernel_size", "[", "0", "]", "-", "1", ")", "//", "2", ",", "(", "kernel_size", "[", "1", "]", "-", "1", ")", "//", "2", ")", "\n", "self", ".", "use_pred_offset", "=", "use_pred_offset", "\n", "\n", "if", "self", ".", "use_pred_offset", ":", "\n", "            ", "offset_channels", "=", "kernel_size", "[", "0", "]", "*", "kernel_size", "[", "1", "]", "*", "2", "\n", "self", ".", "conv_offset", "=", "nn", ".", "Conv2d", "(", "4", ",", "\n", "deformable_groups", "*", "offset_channels", ",", "\n", "1", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "", "self", ".", "conv_adaption", "=", "DeformConv2d", "(", "in_channels", ",", "\n", "in_channels", ",", "\n", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "deform_groups", "=", "deformable_groups", ")", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "\n", "kernel_size", "=", "self", ".", "kernel_size", ",", "padding", "=", "self", ".", "padding", ")", "\n", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "# self.norm = nn.BatchNorm2d(in_channels)", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.Featurealign.FeatureAlign.init_weights": [[38, 41], ["torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ",", "bias_value", "=", "0", ")", ":", "\n", "        ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "self", ".", "conv_offset", ".", "weight", ",", "std", "=", "0.0", ")", "\n", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "self", ".", "conv_adaption", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.Featurealign.FeatureAlign.forward": [[42, 75], ["Featurealign.FeatureAlign.relu", "Featurealign.FeatureAlign.conv", "Featurealign.FeatureAlign.conv_offset", "Featurealign.FeatureAlign.size", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "dh_R.view().repeat.view().repeat.view().repeat", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "dw_R.repeat.repeat.repeat", "torch.stack().permute().contiguous", "torch.stack().permute().contiguous", "torch.stack().permute().contiguous", "torch.stack().permute().contiguous", "offset.view.view.view", "Featurealign.FeatureAlign.conv_adaption", "shape.detach", "shape[].view", "dwh[].unsqueeze", "dh_R.view().repeat.view().repeat.view", "dwh[].unsqueeze", "dw_R.repeat.repeat.view", "Featurealign.FeatureAlign.size", "Featurealign.FeatureAlign.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "dh_R.view().repeat.view().repeat.view", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "shape[].view", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "shape", ")", ":", "\n", "        ", "if", "self", ".", "use_pred_offset", ":", "\n", "            ", "offset", "=", "self", ".", "conv_offset", "(", "shape", ".", "detach", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "ks_h", ",", "ks_w", "=", "self", ".", "kernel_size", "\n", "batch_size", "=", "x", ".", "size", "(", "0", ")", "\n", "\n", "variances", "=", "[", "0.1", ",", "0.2", "]", "\n", "# dx = 2*\\delta x , dy = 2*\\delta y", "\n", "dxy", "=", "shape", "[", ":", ",", ":", "2", "]", ".", "view", "(", "batch_size", ",", "2", ",", "-", "1", ")", "*", "variances", "[", "0", "]", "# [bs, 2, hw]", "\n", "dx", "=", "(", "dxy", "[", ":", ",", "0", "]", "*", "ks_w", ")", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "ks_h", "*", "ks_w", ",", "1", ")", "\n", "dy", "=", "(", "dxy", "[", ":", ",", "1", "]", "*", "ks_h", ")", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "ks_h", "*", "ks_w", ",", "1", ")", "\n", "\n", "# dw = exp(\\delta w) - 1", "\n", "dwh", "=", "(", "shape", "[", ":", ",", "2", ":", "]", ".", "view", "(", "batch_size", ",", "2", ",", "-", "1", ")", "*", "variances", "[", "1", "]", ")", ".", "exp", "(", ")", "-", "1", "\n", "\n", "# build offset for h", "\n", "dh_R", "=", "torch", ".", "arange", "(", "-", "ks_h", "//", "2", "+", "1", ",", "ks_h", "//", "2", "+", "1", ")", ".", "float", "(", ")", "\n", "dh_R", "=", "dh_R", ".", "view", "(", "-", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "ks_w", ")", "\n", "dh", "=", "dwh", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", "*", "dh_R", ".", "view", "(", "1", ",", "-", "1", ",", "1", ")", "\n", "# build offset for w", "\n", "dw_R", "=", "torch", ".", "arange", "(", "-", "ks_w", "//", "2", "+", "1", ",", "ks_w", "//", "2", "+", "1", ")", ".", "float", "(", ")", "\n", "dw_R", "=", "dw_R", ".", "repeat", "(", "ks_h", ")", "\n", "dw", "=", "dwh", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", "*", "dw_R", ".", "view", "(", "1", ",", "-", "1", ",", "1", ")", "\n", "\n", "# [dy1, dx1, dy2, dx2, ..., dyn, dxn]", "\n", "offset", "=", "torch", ".", "stack", "(", "[", "dy", "+", "dh", ",", "dx", "+", "dw", "]", ",", "dim", "=", "1", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "offset", "=", "offset", ".", "view", "(", "batch_size", ",", "-", "1", ",", "x", ".", "size", "(", "2", ")", ",", "x", ".", "size", "(", "3", ")", ")", "\n", "\n", "# x = self.conv_adaption(x, offset)", "\n", "", "x", "=", "self", ".", "relu", "(", "self", ".", "conv_adaption", "(", "x", ",", "offset", ")", ")", "\n", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.make_net.make_net": [[5, 58], ["sum", "isinstance", "torch.Sequential", "torch.ReLU", "make_net.make_net.make_layer"], "function", ["None"], ["def", "make_net", "(", "in_channels", ",", "conf", ",", "include_last_relu", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    A helper function to take a config setting and turn it into a network.\n    Used by protonet and extrahead. Returns (network, out_channels)\n    \"\"\"", "\n", "\n", "def", "make_layer", "(", "layer_cfg", ")", ":", "\n", "        ", "nonlocal", "in_channels", "\n", "\n", "# Possible patterns:", "\n", "# ( 256, 3, {}) -> conv", "\n", "# ( 256,-2, {}) -> deconv", "\n", "# (None,-2, {}) -> bilinear interpolate", "\n", "# ('cat',[],{}) -> concat the subnetworks in the list", "\n", "#", "\n", "# You know it would have probably been simpler just to adopt a 'c' 'd' 'u' naming scheme.", "\n", "# Whatever, it's too late now.", "\n", "if", "isinstance", "(", "layer_cfg", "[", "0", "]", ",", "str", ")", ":", "\n", "            ", "layer_name", "=", "layer_cfg", "[", "0", "]", "\n", "\n", "if", "layer_name", "==", "'cat'", ":", "\n", "                ", "nets", "=", "[", "make_net", "(", "in_channels", ",", "x", ")", "for", "x", "in", "layer_cfg", "[", "1", "]", "]", "\n", "layer", "=", "Concat", "(", "[", "net", "[", "0", "]", "for", "net", "in", "nets", "]", ",", "layer_cfg", "[", "2", "]", ")", "\n", "num_channels", "=", "sum", "(", "[", "net", "[", "1", "]", "for", "net", "in", "nets", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "num_channels", "=", "layer_cfg", "[", "0", "]", "\n", "kernel_size", "=", "layer_cfg", "[", "1", "]", "\n", "\n", "if", "kernel_size", ">", "0", ":", "\n", "                ", "layer", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "num_channels", ",", "kernel_size", ",", "**", "layer_cfg", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "                ", "if", "num_channels", "is", "None", ":", "\n", "                    ", "layer", "=", "InterpolateModule", "(", "scale_factor", "=", "-", "kernel_size", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ",", "\n", "**", "layer_cfg", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "                    ", "layer", "=", "nn", ".", "ConvTranspose2d", "(", "in_channels", ",", "num_channels", ",", "-", "kernel_size", ",", "**", "layer_cfg", "[", "2", "]", ")", "\n", "\n", "", "", "", "in_channels", "=", "num_channels", "if", "num_channels", "is", "not", "None", "else", "in_channels", "\n", "\n", "# Don't return a ReLU layer if we're doing an upsample. This probably doesn't affect anything", "\n", "# output-wise, but there's no need to go through a ReLU here.", "\n", "# Commented out for backwards compatibility with previous models", "\n", "# if num_channels is None:", "\n", "#     return [layer]", "\n", "# else:", "\n", "return", "[", "layer", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", "\n", "\n", "# Use sum to concat together all the component layer lists", "\n", "", "net", "=", "sum", "(", "[", "make_layer", "(", "x", ")", "for", "x", "in", "conf", "]", ",", "[", "]", ")", "\n", "if", "not", "include_last_relu", ":", "\n", "        ", "net", "=", "net", "[", ":", "-", "1", "]", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "(", "net", ")", ")", ",", "in_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.track_to_segment_head.TemporalNet.__init__": [[11, 24], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.AvgPool2d", "torch.AvgPool2d", "torch.AvgPool2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__"], ["    ", "def", "__init__", "(", "self", ",", "corr_channels", ",", "mask_proto_n", "=", "32", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "corr_channels", ",", "512", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "512", ",", "1024", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "pool", "=", "nn", ".", "AvgPool2d", "(", "(", "7", ",", "7", ")", ",", "stride", "=", "1", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "1024", ",", "4", ")", "\n", "if", "cfg", ".", "use_sipmask", ":", "\n", "            ", "self", ".", "fc_coeff", "=", "nn", ".", "Linear", "(", "1024", ",", "mask_proto_n", "*", "cfg", ".", "sipmask_head", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fc_coeff", "=", "nn", ".", "Linear", "(", "1024", ",", "mask_proto_n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.track_to_segment_head.TemporalNet.forward": [[25, 38], ["track_to_segment_head.TemporalNet.conv1", "track_to_segment_head.TemporalNet.relu", "track_to_segment_head.TemporalNet.conv2", "track_to_segment_head.TemporalNet.relu", "track_to_segment_head.TemporalNet.conv3", "track_to_segment_head.TemporalNet.relu", "track_to_segment_head.TemporalNet.pool", "x.view.view.view", "track_to_segment_head.TemporalNet.fc", "track_to_segment_head.TemporalNet.fc_coeff", "x.view.view.size"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "pool", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x_reg", "=", "self", ".", "fc", "(", "x", ")", "\n", "x_coeff", "=", "self", ".", "fc_coeff", "(", "x", ")", "\n", "\n", "return", "x_reg", ",", "x_coeff", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.track_to_segment_head.correlate": [[40, 63], ["spatial_correlation_sampler.spatial_correlation_sample", "spatial_correlation_sampler.spatial_correlation_sample.size", "torch.leaky_relu_", "spatial_correlation_sampler.spatial_correlation_sample.view", "x1.size"], "function", ["None"], ["", "", "def", "correlate", "(", "x1", ",", "x2", ",", "patch_size", "=", "11", ",", "dilation_patch", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    :param x1: features 1\n    :param x2: features 2\n    :param patch_size: the size of whole patch is used to calculate the correlation\n    :return:\n    \"\"\"", "\n", "\n", "# Output sizes oH and oW are no longer dependant of patch size, but only of kernel size and padding", "\n", "# patch_size is now the whole patch, and not only the radii.", "\n", "# stride1 is now stride and stride2 is dilation_patch, which behave like dilated convolutions", "\n", "# equivalent max_displacement is then dilation_patch * (patch_size - 1) / 2.", "\n", "# to get the right parameters for FlowNetC, you would have", "\n", "out_corr", "=", "spatial_correlation_sample", "(", "x1", ",", "\n", "x2", ",", "\n", "kernel_size", "=", "1", ",", "\n", "patch_size", "=", "patch_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation_patch", "=", "dilation_patch", ")", "\n", "b", ",", "ph", ",", "pw", ",", "h", ",", "w", "=", "out_corr", ".", "size", "(", ")", "\n", "out_corr", "=", "out_corr", ".", "view", "(", "b", ",", "ph", "*", "pw", ",", "h", ",", "w", ")", "/", "x1", ".", "size", "(", "1", ")", "\n", "return", "F", ".", "leaky_relu_", "(", "out_corr", ",", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.track_to_segment_head.bbox_feat_extractor": [[65, 89], ["layers.box_utils.sanitize_coordinates_hw", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "mmcv.ops.roi_align", "layers.box_utils.sanitize_coordinates_hw.size", "box_ind.cuda.cuda", "len", "feature_maps.unsqueeze.unsqueeze", "feature_maps.unsqueeze.size", "box_ind.cuda.unsqueeze"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.sanitize_coordinates_hw"], ["", "def", "bbox_feat_extractor", "(", "feature_maps", ",", "boxes_w_norm", ",", "h", ",", "w", ",", "pool_size", ")", ":", "\n", "    ", "\"\"\"\n        feature_maps: size:1*C*h*w\n        boxes: Mx5 float box with (x1, y1, x2, y2) **without normalization**\n    \"\"\"", "\n", "# Currently only supports batch_size 1", "\n", "boxes", "=", "sanitize_coordinates_hw", "(", "boxes_w_norm", ",", "h", ",", "w", ")", "\n", "# boxes = boxes_w_norm", "\n", "\n", "# Crop and Resize", "\n", "# Result: [num_boxes, pool_height, pool_width, channels]", "\n", "box_ind", "=", "torch", ".", "zeros", "(", "boxes", ".", "size", "(", "0", ")", ")", "# index of bbox in batch", "\n", "if", "boxes", ".", "is_cuda", ":", "\n", "        ", "box_ind", "=", "box_ind", ".", "cuda", "(", ")", "\n", "\n", "# CropAndResizeFunction needs batch dimension", "\n", "", "if", "len", "(", "feature_maps", ".", "size", "(", ")", ")", "==", "3", ":", "\n", "        ", "feature_maps", "=", "feature_maps", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# make crops:", "\n", "", "rois", "=", "torch", ".", "cat", "(", "[", "box_ind", ".", "unsqueeze", "(", "1", ")", ",", "boxes", "]", ",", "dim", "=", "1", ")", "\n", "pooled_features", "=", "roi_align", "(", "feature_maps", ",", "rois", ",", "pool_size", ")", "\n", "\n", "return", "pooled_features", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.FPN.FPN.__init__": [[40, 66], ["ScriptModuleWrapper.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "reversed", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "range"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "lat_layers", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "Conv2d", "(", "x", ",", "cfg", ".", "fpn", ".", "num_features", ",", "kernel_size", "=", "1", ")", "\n", "for", "x", "in", "reversed", "(", "in_channels", ")", "\n", "]", ")", "\n", "\n", "# This is here for backwards compatability", "\n", "padding", "=", "1", "if", "cfg", ".", "fpn", ".", "pad", "else", "0", "\n", "self", ".", "pred_layers", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "Conv2d", "(", "cfg", ".", "fpn", ".", "num_features", ",", "cfg", ".", "fpn", ".", "num_features", ",", "kernel_size", "=", "3", ",", "padding", "=", "padding", ")", "\n", "for", "_", "in", "in_channels", "\n", "]", ")", "\n", "\n", "if", "cfg", ".", "fpn", ".", "use_conv_downsample", ":", "\n", "            ", "self", ".", "downsample_layers", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "Conv2d", "(", "cfg", ".", "fpn", ".", "num_features", ",", "cfg", ".", "fpn", ".", "num_features", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "stride", "=", "2", ")", "\n", "for", "_", "in", "range", "(", "cfg", ".", "fpn", ".", "num_downsample", ")", "\n", "]", ")", "\n", "\n", "", "self", ".", "interpolation_mode", "=", "cfg", ".", "fpn", ".", "interpolation_mode", "\n", "self", ".", "num_downsample", "=", "cfg", ".", "fpn", ".", "num_downsample", "\n", "self", ".", "use_conv_downsample", "=", "cfg", ".", "fpn", ".", "use_conv_downsample", "\n", "self", ".", "relu_downsample_layers", "=", "cfg", ".", "fpn", ".", "relu_downsample_layers", "# yolact++", "\n", "self", ".", "relu_pred_layers", "=", "cfg", ".", "fpn", ".", "relu_pred_layers", "# yolact++", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.FPN.FPN.forward": [[67, 110], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "len", "len", "len", "out.append", "torch.relu", "torch.relu", "torch.relu", "range", "convouts[].size", "torch.interpolate", "torch.interpolate", "torch.interpolate", "lat_layer", "pred_layer", "out.append", "out.append", "len", "downsample_layer", "torch.functional.max_pool2d", "torch.functional.max_pool2d", "torch.functional.max_pool2d"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append"], ["", "@", "script_method_wrapper", "\n", "def", "forward", "(", "self", ",", "convouts", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            - convouts (list): A list of convouts for the corresponding layers in in_channels.\n        Returns:\n            - A list of FPN convouts in the same order as x with extra downsample layers if requested.\n        \"\"\"", "\n", "\n", "out", "=", "[", "]", "\n", "x", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "convouts", "[", "0", "]", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "convouts", ")", ")", ":", "\n", "            ", "out", ".", "append", "(", "x", ")", "\n", "\n", "# For backward compatability, the conv layers are stored in reverse but the input and output is", "\n", "# given in the correct order. Thus, use j=-i-1 for the input and output and i for the conv layers.", "\n", "", "j", "=", "len", "(", "convouts", ")", "\n", "for", "lat_layer", "in", "self", ".", "lat_layers", ":", "\n", "            ", "j", "-=", "1", "\n", "\n", "if", "j", "<", "len", "(", "convouts", ")", "-", "1", ":", "\n", "                ", "_", ",", "_", ",", "h", ",", "w", "=", "convouts", "[", "j", "]", ".", "size", "(", ")", "\n", "x", "=", "F", ".", "interpolate", "(", "x", ",", "size", "=", "(", "h", ",", "w", ")", ",", "mode", "=", "self", ".", "interpolation_mode", ",", "align_corners", "=", "False", ")", "\n", "\n", "", "x", "=", "x", "+", "lat_layer", "(", "convouts", "[", "j", "]", ")", "\n", "out", "[", "j", "]", "=", "x", "\n", "\n", "# This janky second loop is here because TorchScript.", "\n", "", "j", "=", "len", "(", "convouts", ")", "\n", "for", "pred_layer", "in", "self", ".", "pred_layers", ":", "\n", "            ", "j", "-=", "1", "\n", "out", "[", "j", "]", "=", "F", ".", "relu", "(", "pred_layer", "(", "out", "[", "j", "]", ")", ")", "\n", "\n", "# In the original paper, this takes care of P6", "\n", "", "if", "self", ".", "use_conv_downsample", ":", "\n", "            ", "for", "downsample_layer", "in", "self", ".", "downsample_layers", ":", "\n", "                ", "out", ".", "append", "(", "downsample_layer", "(", "out", "[", "-", "1", "]", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "idx", "in", "range", "(", "self", ".", "num_downsample", ")", ":", "\n", "# Note: this is an untested alternative to out.append(out[-1][:, :, ::2, ::2]). Thanks TorchScript.", "\n", "                ", "out", ".", "append", "(", "nn", ".", "functional", ".", "max_pool2d", "(", "out", "[", "-", "1", "]", ",", "1", ",", "stride", "=", "2", ")", ")", "\n", "\n", "", "", "return", "out", "", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.FastMaskIoUNet.FastMaskIoUNet.__init__": [[24, 29], ["ScriptModuleWrapper.__init__", "make_net.make_net.make_net"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.make_net.make_net"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "input_channels", "=", "1", "\n", "last_layer", "=", "[", "(", "cfg", ".", "num_classes", "-", "1", ",", "1", ",", "{", "}", ")", "]", "\n", "self", ".", "maskiou_net", ",", "_", "=", "make_net", "(", "input_channels", ",", "cfg", ".", "maskiou_net", "+", "last_layer", ",", "include_last_relu", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.FastMaskIoUNet.FastMaskIoUNet.forward": [[30, 35], ["FastMaskIoUNet.FastMaskIoUNet.maskiou_net", "torch.max_pool2d().squeeze().squeeze", "torch.max_pool2d().squeeze().squeeze", "torch.max_pool2d().squeeze().squeeze", "torch.max_pool2d().squeeze", "torch.max_pool2d().squeeze", "torch.max_pool2d().squeeze", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "FastMaskIoUNet.FastMaskIoUNet.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "maskiou_net", "(", "x", ")", "\n", "maskiou_p", "=", "F", ".", "max_pool2d", "(", "x", ",", "kernel_size", "=", "x", ".", "size", "(", ")", "[", "2", ":", "]", ")", ".", "squeeze", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "return", "maskiou_p", "", "", "", ""]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__": [[40, 121], ["torch.Module.__init__", "len", "len", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "make_net.make_net.make_net", "Featurealign.FeatureAlign", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "prediction_head.PredictionModule.__init__.make_extra"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.__init__", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.make_net.make_net"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", "=", "1024", ",", "\n", "pred_aspect_ratios", "=", "None", ",", "pred_scales", "=", "None", ",", "parent", "=", "None", ",", "deform_groups", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_classes", "=", "cfg", ".", "num_classes", "\n", "self", ".", "mask_dim", "=", "cfg", ".", "mask_dim", "\n", "self", ".", "num_priors", "=", "len", "(", "pred_aspect_ratios", "[", "0", "]", ")", "*", "len", "(", "pred_scales", ")", "\n", "self", ".", "embed_dim", "=", "cfg", ".", "embed_dim", "\n", "self", ".", "pred_aspect_ratios", "=", "pred_aspect_ratios", "\n", "self", ".", "pred_scales", "=", "pred_scales", "\n", "self", ".", "deform_groups", "=", "deform_groups", "\n", "self", ".", "parent", "=", "[", "parent", "]", "# Don't include this in the state dict", "\n", "self", ".", "num_heads", "=", "cfg", ".", "num_heads", "\n", "if", "cfg", ".", "use_sipmask", ":", "\n", "            ", "self", ".", "mask_dim", "=", "self", ".", "mask_dim", "*", "cfg", ".", "sipmask_head", "\n", "\n", "", "if", "cfg", ".", "mask_proto_prototypes_as_features", ":", "\n", "            ", "in_channels", "+=", "self", ".", "mask_dim", "\n", "\n", "", "if", "parent", "is", "None", ":", "\n", "            ", "if", "cfg", ".", "extra_head_net", "is", "None", ":", "\n", "                ", "self", ".", "out_channels", "=", "in_channels", "\n", "", "else", ":", "\n", "                ", "self", ".", "upfeature", ",", "self", ".", "out_channels", "=", "make_net", "(", "in_channels", ",", "cfg", ".", "extra_head_net", ")", "\n", "\n", "", "self", ".", "bbox_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "4", ",", "**", "cfg", ".", "head_layer_params", ")", "\n", "\n", "kernel_size", "=", "cfg", ".", "head_layer_params", "[", "'kernel_size'", "]", "\n", "if", "cfg", ".", "train_class", ":", "\n", "                ", "if", "cfg", ".", "use_cascade_pred", "and", "cfg", ".", "use_dcn_class", ":", "\n", "                    ", "self", ".", "conf_layer", "=", "FeatureAlign", "(", "self", ".", "out_channels", ",", "\n", "self", ".", "num_priors", "*", "self", ".", "num_classes", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "deformable_groups", "=", "self", ".", "deform_groups", ",", "\n", "use_pred_offset", "=", "cfg", ".", "use_pred_offset", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "conf_layer", "=", "nn", ".", "Conv2d", "(", "self", ".", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "num_classes", ",", "\n", "**", "cfg", ".", "head_layer_params", ")", "\n", "\n", "", "", "if", "cfg", ".", "train_track", ":", "\n", "                ", "if", "cfg", ".", "use_cascade_pred", "and", "cfg", ".", "use_dcn_track", ":", "\n", "                    ", "self", ".", "track_layer", "=", "FeatureAlign", "(", "self", ".", "out_channels", ",", "\n", "self", ".", "num_priors", "*", "self", ".", "embed_dim", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "deformable_groups", "=", "self", ".", "deform_groups", ",", "\n", "use_pred_offset", "=", "cfg", ".", "use_pred_offset", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "track_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "embed_dim", ",", "**", "cfg", ".", "head_layer_params", ")", "\n", "\n", "", "", "if", "cfg", ".", "use_cascade_pred", "and", "cfg", ".", "use_dcn_mask", ":", "\n", "                ", "self", ".", "mask_layer", "=", "FeatureAlign", "(", "self", ".", "out_channels", ",", "\n", "self", ".", "num_priors", "*", "self", ".", "mask_dim", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "deformable_groups", "=", "self", ".", "deform_groups", ",", "\n", "use_pred_offset", "=", "cfg", ".", "use_pred_offset", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "mask_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "mask_dim", ",", "**", "cfg", ".", "head_layer_params", ")", "\n", "\n", "", "if", "cfg", ".", "train_centerness", ":", "\n", "                ", "self", ".", "centerness_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", ",", "**", "cfg", ".", "head_layer_params", ")", "\n", "\n", "", "if", "cfg", ".", "use_instance_coeff", ":", "\n", "                ", "self", ".", "inst_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "cfg", ".", "num_instance_coeffs", ",", "\n", "**", "cfg", ".", "head_layer_params", ")", "\n", "\n", "# What is this ugly lambda doing in the middle of all this clean prediction module code?", "\n", "", "def", "make_extra", "(", "num_layers", ")", ":", "\n", "                ", "if", "num_layers", "==", "0", ":", "\n", "                    ", "return", "lambda", "x", ":", "x", "\n", "", "else", ":", "\n", "# Looks more complicated than it is. This just creates an array of num_layers alternating conv-relu", "\n", "                    ", "return", "nn", ".", "Sequential", "(", "*", "sum", "(", "[", "[", "\n", "nn", ".", "Conv2d", "(", "out_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "]", "for", "_", "in", "range", "(", "num_layers", ")", "]", ",", "[", "]", ")", ")", "\n", "\n", "", "", "self", ".", "bbox_extra", ",", "self", ".", "conf_extra", ",", "self", ".", "mask_extra", ",", "self", ".", "track_extra", "=", "[", "make_extra", "(", "x", ")", "for", "x", "in", "cfg", ".", "extra_layers", "]", "\n", "\n", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", "and", "cfg", ".", "mask_proto_coeff_gate", ":", "\n", "                ", "self", ".", "gate_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "mask_dim", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.forward": [[122, 213], ["src.upfeature.size", "src.bbox_extra", "src.conf_extra", "src.mask_extra", "src.track_extra", "src.bbox_layer", "bbox.permute().contiguous().view.permute().contiguous().view.permute().contiguous().view", "torch.pad.permute().contiguous().view", "prediction_head.PredictionModule.make_priors", "src.upfeature", "src.conv_offset", "src.upfeature.size", "src.conf_layer.permute().contiguous().view", "src.track_layer.permute().contiguous().view", "src.mask_layer", "src.mask_layer", "src.upfeature.size", "src.centerness_layer().permute().contiguous().view", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "src.score_layer().permute().contiguous().view", "src.inst_layer().permute().contiguous().view", "torch.pad", "torch.pad", "torch.pad", "torch.normalize", "torch.normalize", "torch.normalize", "bbox.permute().contiguous().view.permute().contiguous().view.detach", "bbox.permute().contiguous().view.permute().contiguous().view.permute().contiguous", "src.conf_layer", "src.conf_layer", "src.upfeature.size", "src.track_layer", "src.track_layer", "src.upfeature.size", "torch.pad.permute().contiguous", "src.upfeature.size", "src.upfeature.size", "src.upfeature.size", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "src.conf_layer.permute().contiguous", "src.track_layer.permute().contiguous", "src.centerness_layer().permute().contiguous", "src.score_layer().permute().contiguous", "src.inst_layer().permute().contiguous", "bbox.permute().contiguous().view.permute().contiguous().view.permute", "torch.pad.permute", "src.conf_layer.permute", "src.track_layer.permute", "src.centerness_layer().permute", "src.score_layer().permute", "src.inst_layer().permute", "src.centerness_layer", "src.score_layer", "src.inst_layer"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.make_priors", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            - x: The convOut from a layer in the backbone network\n                 Size: [batch_size, in_channels, conv_h, conv_w])\n        Returns a tuple (bbox_coords, class_confs, mask_output, prior_boxes) with sizes\n            - bbox_coords: [batch_size, conv_h*conv_w*num_priors, 4]\n            - class_confs: [batch_size, conv_h*conv_w*num_priors, num_classes]\n            - mask_output: [batch_size, conv_h*conv_w*num_priors, mask_dim]\n            - prior_boxes: [conv_h*conv_w*num_priors, 4]\n        \"\"\"", "\n", "# In case we want to use another module's layers", "\n", "src", "=", "self", "if", "self", ".", "parent", "[", "0", "]", "is", "None", "else", "self", ".", "parent", "[", "0", "]", "\n", "\n", "bs", ",", "_", ",", "conv_h", ",", "conv_w", "=", "x", ".", "size", "(", ")", "\n", "\n", "if", "cfg", ".", "extra_head_net", "is", "not", "None", ":", "\n", "            ", "x", "=", "src", ".", "upfeature", "(", "x", ")", "\n", "\n", "", "bbox_x", "=", "src", ".", "bbox_extra", "(", "x", ")", "\n", "conf_x", "=", "src", ".", "conf_extra", "(", "x", ")", "\n", "mask_x", "=", "src", ".", "mask_extra", "(", "x", ")", "\n", "track_x", "=", "src", ".", "track_extra", "(", "x", ")", "\n", "\n", "bbox", "=", "src", ".", "bbox_layer", "(", "bbox_x", ")", "\n", "if", "cfg", ".", "use_cascade_pred", ":", "\n", "            ", "offset", "=", "src", ".", "conv_offset", "(", "bbox", ".", "detach", "(", ")", ")", "\n", "# o1, o2, offset_mask = torch.chunk(offset_all, 3, dim=1)", "\n", "# offset = torch.cat((o1, o2), dim=1)", "\n", "# offset_mask = offset.new_ones(bs, int(offset.size(1)/2), conv_h, conv_w)", "\n", "", "bbox", "=", "bbox", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "4", ")", "\n", "\n", "if", "cfg", ".", "train_class", ":", "\n", "            ", "if", "cfg", ".", "use_cascade_pred", "and", "cfg", ".", "use_dcn_class", ":", "\n", "                ", "conf", "=", "src", ".", "conf_layer", "(", "conf_x", ",", "offset", ")", "\n", "", "else", ":", "\n", "                ", "conf", "=", "src", ".", "conf_layer", "(", "conf_x", ")", "\n", "", "conf", "=", "conf", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "\n", "", "if", "cfg", ".", "train_track", ":", "\n", "            ", "if", "cfg", ".", "use_cascade_pred", "and", "cfg", ".", "use_dcn_track", ":", "\n", "                ", "track", "=", "src", ".", "track_layer", "(", "track_x", ",", "offset", ")", "\n", "", "else", ":", "\n", "                ", "track", "=", "src", ".", "track_layer", "(", "track_x", ")", "\n", "", "track", "=", "track", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "self", ".", "embed_dim", ")", "\n", "\n", "", "if", "cfg", ".", "use_cascade_pred", "and", "cfg", ".", "use_dcn_mask", ":", "\n", "            ", "mask", "=", "src", ".", "mask_layer", "(", "mask_x", ",", "offset", ")", "\n", "", "else", ":", "\n", "            ", "mask", "=", "src", ".", "mask_layer", "(", "mask_x", ")", "\n", "", "mask", "=", "mask", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "self", ".", "mask_dim", ")", "\n", "\n", "if", "cfg", ".", "train_centerness", ":", "\n", "            ", "centerness", "=", "src", ".", "centerness_layer", "(", "bbox_x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "1", ")", "\n", "centerness", "=", "torch", ".", "tanh", "(", "centerness", ")", "\n", "\n", "", "if", "cfg", ".", "use_mask_scoring", ":", "\n", "            ", "score", "=", "src", ".", "score_layer", "(", "x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "1", ")", "\n", "\n", "", "if", "cfg", ".", "use_instance_coeff", ":", "\n", "            ", "inst", "=", "src", ".", "inst_layer", "(", "x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "cfg", ".", "num_instance_coeffs", ")", "\n", "\n", "# See box_utils.decode for an explanation of this", "\n", "", "if", "cfg", ".", "use_yolo_regressors", ":", "\n", "            ", "bbox", "[", ":", ",", ":", ",", ":", "2", "]", "=", "torch", ".", "sigmoid", "(", "bbox", "[", ":", ",", ":", ",", ":", "2", "]", ")", "-", "0.5", "\n", "bbox", "[", ":", ",", ":", ",", "0", "]", "/=", "conv_w", "\n", "bbox", "[", ":", ",", ":", ",", "1", "]", "/=", "conv_h", "\n", "\n", "", "if", "cfg", ".", "mask_proto_split_prototypes_by_head", "and", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", ":", "\n", "            ", "mask", "=", "F", ".", "pad", "(", "mask", ",", "(", "self", ".", "index", "*", "self", ".", "mask_dim", ",", "(", "self", ".", "num_heads", "-", "self", ".", "index", "-", "1", ")", "*", "self", ".", "mask_dim", ")", ",", "\n", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "\n", "", "priors", "=", "self", ".", "make_priors", "(", "conv_h", ",", "conv_w", ",", "x", ".", "device", ")", "\n", "preds", "=", "{", "'loc'", ":", "bbox", ",", "'conf'", ":", "conf", ",", "'mask_coeff'", ":", "mask", ",", "'priors'", ":", "priors", "}", "\n", "\n", "if", "cfg", ".", "train_centerness", ":", "\n", "            ", "preds", "[", "'centerness'", "]", "=", "centerness", "\n", "\n", "", "if", "cfg", ".", "train_track", ":", "\n", "            ", "preds", "[", "'track'", "]", "=", "F", ".", "normalize", "(", "track", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "if", "cfg", ".", "use_mask_scoring", ":", "\n", "            ", "preds", "[", "'score'", "]", "=", "score", "\n", "\n", "", "if", "cfg", ".", "use_instance_coeff", ":", "\n", "            ", "preds", "[", "'inst'", "]", "=", "inst", "\n", "\n", "", "if", "cfg", ".", "temporal_fusion_module", ":", "\n", "            ", "preds", "[", "'T2S_feat'", "]", "=", "x", "\n", "\n", "", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.prediction_head.PredictionModule.make_priors": [[214, 239], ["utils.timer.env", "itertools.product", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "torch.Tensor().view().detach", "range", "range", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "math.sqrt", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "make_priors", "(", "self", ",", "conv_h", ",", "conv_w", ",", "device", ")", ":", "\n", "        ", "\"\"\" Note that priors are [x,y,width,height] where (x,y) is the center of the box. \"\"\"", "\n", "with", "timer", ".", "env", "(", "'makepriors'", ")", ":", "\n", "            ", "prior_data", "=", "[", "]", "\n", "# Iteration order is important (it has to sync up with the convout)", "\n", "for", "j", ",", "i", "in", "product", "(", "range", "(", "conv_h", ")", ",", "range", "(", "conv_w", ")", ")", ":", "\n", "# +0.5 because priors are in center-size notation", "\n", "                ", "x", "=", "(", "i", "+", "0.5", ")", "/", "conv_w", "\n", "y", "=", "(", "j", "+", "0.5", ")", "/", "conv_h", "\n", "\n", "for", "ars", "in", "self", ".", "pred_aspect_ratios", ":", "\n", "                    ", "for", "scale", "in", "self", ".", "pred_scales", ":", "\n", "                        ", "for", "ar", "in", "ars", ":", "\n", "# [1, 1/2, 2]", "\n", "                            ", "ar", "=", "sqrt", "(", "ar", ")", "\n", "r", "=", "scale", "/", "self", ".", "pred_scales", "[", "0", "]", "*", "3", "\n", "w", "=", "r", "*", "ar", "/", "conv_w", "\n", "h", "=", "r", "/", "ar", "/", "conv_h", "\n", "\n", "prior_data", "+=", "[", "x", ",", "y", ",", "w", ",", "h", "]", "\n", "\n", "", "", "", "", "priors", "=", "torch", ".", "Tensor", "(", "prior_data", ",", "device", "=", "device", ")", ".", "view", "(", "1", ",", "-", "1", ",", "4", ")", ".", "detach", "(", ")", "\n", "priors", ".", "requires_grad", "=", "False", "\n", "\n", "", "return", "priors", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.render": [[27, 62], ["numpy.square", "numpy.square", "numpy.square", "numpy.clip", "fig.canvas.draw_idle", "numpy.tile", "numpy.tile", "numpy.sin", "numpy.sin", "numpy.sin", "numpy.exp", "numpy.exp", "numpy.exp", "matplotlib.imshow", "plt.imshow.set_data", "numpy.array().reshape", "numpy.array().reshape", "math.sin", "math.cos", "math.sin", "math.cos", "math.sin", "math.cos", "numpy.array", "numpy.array", "list", "list", "range", "range"], "function", ["None"], ["def", "render", "(", ")", ":", "\n", "\t", "if", "disable_render", ":", "\n", "\t\t", "return", "\n", "\n", "", "x", "=", "np", ".", "tile", "(", "np", ".", "array", "(", "list", "(", "range", "(", "grid_w", ")", ")", ",", "dtype", "=", "np", ".", "float", ")", ".", "reshape", "(", "1", ",", "grid_w", ")", ",", "[", "grid_h", ",", "1", "]", ")", "-", "grid_w", "*", "center_x", "\n", "y", "=", "np", ".", "tile", "(", "np", ".", "array", "(", "list", "(", "range", "(", "grid_h", ")", ")", ",", "dtype", "=", "np", ".", "float", ")", ".", "reshape", "(", "grid_h", ",", "1", ")", ",", "[", "1", ",", "grid_w", "]", ")", "-", "grid_h", "*", "center_y", "\n", "\n", "x", "/=", "scale", "\n", "y", "/=", "scale", "\n", "\n", "a1", "=", "angle", "+", "math", ".", "pi", "/", "3", "\n", "a2", "=", "-", "angle", "+", "math", ".", "pi", "/", "3", "\n", "a3", "=", "angle", "\n", "\n", "z1", "=", "x", "*", "math", ".", "sin", "(", "a1", ")", "+", "y", "*", "math", ".", "cos", "(", "a1", ")", "\n", "z2", "=", "x", "*", "math", ".", "sin", "(", "a2", ")", "-", "y", "*", "math", ".", "cos", "(", "a2", ")", "\n", "z3", "=", "x", "*", "math", ".", "sin", "(", "a3", ")", "+", "y", "*", "math", ".", "cos", "(", "a3", ")", "\n", "\n", "s1", "=", "np", ".", "square", "(", "np", ".", "sin", "(", "z1", ")", ")", "\n", "s2", "=", "np", ".", "square", "(", "np", ".", "sin", "(", "z2", ")", ")", "\n", "s3", "=", "np", ".", "square", "(", "np", ".", "sin", "(", "z3", ")", ")", "\n", "\n", "line_1", "=", "np", ".", "exp", "(", "s1", "*", "spacing", ")", "*", "s1", "\n", "line_2", "=", "np", ".", "exp", "(", "s2", "*", "spacing", ")", "*", "s2", "\n", "line_3", "=", "np", ".", "exp", "(", "s3", "*", "spacing", ")", "*", "s3", "\n", "\n", "global", "grid", "\n", "grid", "=", "np", ".", "clip", "(", "1", "-", "(", "line_1", "+", "line_2", "+", "line_3", ")", "/", "3", ",", "0", ",", "1", ")", "\n", "\n", "global", "im_handle", "\n", "if", "im_handle", "is", "None", ":", "\n", "\t\t", "im_handle", "=", "plt", ".", "imshow", "(", "grid", ")", "\n", "", "else", ":", "\n", "\t\t", "im_handle", ".", "set_data", "(", "grid", ")", "\n", "", "fig", ".", "canvas", ".", "draw_idle", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.update_scale": [[63, 68], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.render"], ["", "def", "update_scale", "(", "val", ")", ":", "\n", "\t", "global", "scale", "\n", "scale", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.update_angle": [[69, 74], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.render"], ["", "def", "update_angle", "(", "val", ")", ":", "\n", "\t", "global", "angle", "\n", "angle", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.update_centerx": [[75, 80], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.render"], ["", "def", "update_centerx", "(", "val", ")", ":", "\n", "\t", "global", "center_x", "\n", "center_x", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.update_centery": [[81, 86], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.render"], ["", "def", "update_centery", "(", "val", ")", ":", "\n", "\t", "global", "center_y", "\n", "center_y", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.update_spacing": [[87, 92], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.render"], ["", "def", "update_spacing", "(", "val", ")", ":", "\n", "\t", "global", "spacing", "\n", "spacing", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.randomize": [[93, 112], ["random.uniform", "random.uniform", "scale_slider.set_val", "angle_slider.set_val", "centx_slider.set_val", "centy_slider.set_val", "spaci_slider.set_val", "make_grid.render", "random.uniform", "random.uniform", "math.exp", "random.uniform"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.render"], ["", "def", "randomize", "(", "val", ")", ":", "\n", "\t", "global", "center_x", ",", "center_y", ",", "spacing", ",", "scale", ",", "angle", ",", "disable_render", "\n", "\n", "center_x", ",", "center_y", "=", "(", "random", ".", "uniform", "(", "0", ",", "1", ")", ",", "random", ".", "uniform", "(", "0", ",", "1", ")", ")", "\n", "spacing", "=", "random", ".", "uniform", "(", "-", "0.2", ",", "2", ")", "\n", "scale", "=", "4", "*", "math", ".", "exp", "(", "random", ".", "uniform", "(", "-", "1", ",", "1", ")", ")", "\n", "angle", "=", "random", ".", "uniform", "(", "-", "math", ".", "pi", ",", "math", ".", "pi", ")", "\n", "\n", "disable_render", "=", "True", "\n", "\n", "scale_slider", ".", "set_val", "(", "scale", ")", "\n", "angle_slider", ".", "set_val", "(", "angle", ")", "\n", "centx_slider", ".", "set_val", "(", "center_x", ")", "\n", "centy_slider", ".", "set_val", "(", "center_y", ")", "\n", "spaci_slider", ".", "set_val", "(", "spacing", ")", "\n", "\n", "disable_render", "=", "False", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add": [[113, 122], ["all_grids.append", "export_len_text.set_text", "fig.canvas.draw_idle", "make_grid.test_uniqueness", "numpy.stack", "str", "len"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.test_uniqueness"], ["", "def", "add", "(", "val", ")", ":", "\n", "\t", "all_grids", ".", "append", "(", "grid", ")", "\n", "\n", "global", "unique", "\n", "if", "not", "unique", ":", "\n", "\t\t", "unique", "=", "test_uniqueness", "(", "np", ".", "stack", "(", "all_grids", ")", ")", "\n", "\n", "", "export_len_text", ".", "set_text", "(", "'Num Grids: '", "+", "str", "(", "len", "(", "all_grids", ")", ")", ")", "\n", "fig", ".", "canvas", ".", "draw_idle", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add_randomize": [[123, 126], ["make_grid.add", "make_grid.randomize"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.add", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.randomize"], ["", "def", "add_randomize", "(", "val", ")", ":", "\n", "\t", "add", "(", "val", ")", "\n", "randomize", "(", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.export": [[127, 137], ["numpy.save", "print", "all_grids.clear", "export_len_text.set_text", "fig.canvas.draw_idle", "numpy.stack", "str", "len", "len"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print"], ["", "def", "export", "(", "val", ")", ":", "\n", "\t", "np", ".", "save", "(", "save_path", ",", "np", ".", "stack", "(", "all_grids", ")", ")", "\n", "print", "(", "'Saved %d grids to \"%s\"'", "%", "(", "len", "(", "all_grids", ")", ",", "save_path", ")", ")", "\n", "\n", "global", "unique", "\n", "unique", "=", "False", "\n", "all_grids", ".", "clear", "(", ")", "\n", "\n", "export_len_text", ".", "set_text", "(", "'Num Grids: '", "+", "str", "(", "len", "(", "all_grids", ")", ")", ")", "\n", "fig", ".", "canvas", ".", "draw_idle", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.make_grid.test_uniqueness": [[138, 158], ["grids.reshape.reshape", "range", "print", "range", "numpy.sum", "numpy.sum", "numpy.abs", "print", "numpy.tile().reshape", "numpy.tile"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print"], ["", "def", "test_uniqueness", "(", "grids", ")", ":", "\n", "# Grids shape [ngrids, h, w]", "\n", "\t", "grids", "=", "grids", ".", "reshape", "(", "(", "-", "1", ",", "grid_h", ",", "grid_w", ")", ")", "\n", "\n", "for", "y", "in", "range", "(", "grid_h", ")", ":", "\n", "\t\t", "for", "x", "in", "range", "(", "grid_h", ")", ":", "\n", "\t\t\t", "pixel_features", "=", "grids", "[", ":", ",", "y", ",", "x", "]", "\n", "\n", "# l1 distance for this pixel with every other", "\n", "l1_dist", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "grids", "-", "np", ".", "tile", "(", "pixel_features", ",", "grid_h", "*", "grid_w", ")", ".", "reshape", "(", "(", "-", "1", ",", "grid_h", ",", "grid_w", ")", ")", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# Equal if l1 distance is really small. Note that this will include this pixel", "\n", "num_equal", "=", "np", ".", "sum", "(", "(", "l1_dist", "<", "0.0001", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "\n", "if", "num_equal", ">", "1", ":", "\n", "\t\t\t\t", "print", "(", "'Pixel at (%d, %d) has %d other pixel%s with the same representation.'", "%", "(", "x", ",", "y", ",", "num_equal", "-", "1", ",", "''", "if", "num_equal", "==", "2", "else", "'s'", ")", ")", "\n", "return", "False", "\n", "\n", "", "", "", "print", "(", "'Each pixel has a distinct representation.'", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.augment_bbox.augment_boxes": [[18, 26], ["numpy.concatenate", "np.concatenate.append", "open", "pickle.dump", "augment_bbox.prep_box"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.augment_bbox.prep_box"], ["def", "augment_boxes", "(", "bboxes", ")", ":", "\n", "\t", "bboxes_rel", "=", "[", "]", "\n", "for", "box", "in", "bboxes", ":", "\n", "\t\t", "bboxes_rel", ".", "append", "(", "prep_box", "(", "box", ")", ")", "\n", "", "bboxes_rel", "=", "np", ".", "concatenate", "(", "bboxes_rel", ",", "axis", "=", "0", ")", "\n", "\n", "with", "open", "(", "dump_file", ",", "'wb'", ")", "as", "f", ":", "\n", "\t\t", "pickle", ".", "dump", "(", "bboxes_rel", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.augment_bbox.prep_box": [[27, 75], ["numpy.array", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "augment_bbox.random_sample_crop", "numpy.random.randint", "int", "int", "int", "int", "print"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.augment_bbox.random_sample_crop", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.print"], ["", "", "def", "prep_box", "(", "box_list", ")", ":", "\n", "\t", "global", "augment_idx", "\n", "boxes", "=", "np", ".", "array", "(", "[", "box_list", "[", "2", ":", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# Image width and height", "\n", "width", ",", "height", "=", "box_list", "[", ":", "2", "]", "\n", "\n", "# To point form", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "\n", "\n", "\n", "# Expand", "\n", "ratio", "=", "random", ".", "uniform", "(", "1", ",", "4", ")", "\n", "left", "=", "random", ".", "uniform", "(", "0", ",", "width", "*", "ratio", "-", "width", ")", "\n", "top", "=", "random", ".", "uniform", "(", "0", ",", "height", "*", "ratio", "-", "height", ")", "\n", "\n", "height", "*=", "ratio", "\n", "width", "*=", "ratio", "\n", "\n", "boxes", "[", ":", ",", ":", "2", "]", "+=", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ")", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ")", "\n", "\n", "\n", "# RandomSampleCrop", "\n", "height", ",", "width", ",", "boxes", "=", "random_sample_crop", "(", "height", ",", "width", ",", "boxes", ")", "\n", "\n", "\n", "# RandomMirror", "\n", "if", "random", ".", "randint", "(", "0", ",", "2", ")", ":", "\n", "\t\t", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", "=", "width", "-", "boxes", "[", ":", ",", "2", ":", ":", "-", "2", "]", "\n", "\n", "\n", "# Resize", "\n", "", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "*=", "(", "max_image_size", "/", "width", ")", "\n", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "*=", "(", "max_image_size", "/", "height", ")", "\n", "width", "=", "height", "=", "max_image_size", "\n", "\n", "\n", "# ToPercentCoords", "\n", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "/=", "width", "\n", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "/=", "height", "\n", "\n", "if", "augment_idx", "%", "50000", "==", "0", ":", "\n", "\t\t", "print", "(", "'Current idx: %d'", "%", "augment_idx", ")", "\n", "\n", "", "augment_idx", "+=", "1", "\n", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.augment_bbox.intersect": [[91, 96], ["numpy.minimum", "numpy.maximum", "numpy.clip"], "function", ["None"], ["def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "max_xy", "=", "np", ".", "minimum", "(", "box_a", "[", ":", ",", "2", ":", "]", ",", "box_b", "[", "2", ":", "]", ")", "\n", "min_xy", "=", "np", ".", "maximum", "(", "box_a", "[", ":", ",", ":", "2", "]", ",", "box_b", "[", ":", "2", "]", ")", "\n", "inter", "=", "np", ".", "clip", "(", "(", "max_xy", "-", "min_xy", ")", ",", "a_min", "=", "0", ",", "a_max", "=", "np", ".", "inf", ")", "\n", "return", "inter", "[", ":", ",", "0", "]", "*", "inter", "[", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.augment_bbox.jaccard_numpy": [[98, 116], ["augment_bbox.intersect"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.intersect"], ["", "def", "jaccard_numpy", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: Multiple bounding boxes, Shape: [num_boxes,4]\n        box_b: Single bounding box, Shape: [4]\n    Return:\n        jaccard overlap: Shape: [box_a.shape[0], box_a.shape[1]]\n    \"\"\"", "\n", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", "1", "]", ")", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", "2", "]", "-", "box_b", "[", "0", "]", ")", "*", "\n", "(", "box_b", "[", "3", "]", "-", "box_b", "[", "1", "]", ")", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "return", "inter", "/", "union", "# [A,B]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.augment_bbox.random_sample_crop": [[118, 164], ["numpy.random.choice", "range", "float", "float", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.array", "augment_bbox.jaccard_numpy", "boxes[].copy", "numpy.maximum", "numpy.minimum", "mask.any", "int", "int", "int", "int", "jaccard_numpy.min", "jaccard_numpy.max"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.augment_bbox.jaccard_numpy", "home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy"], ["", "def", "random_sample_crop", "(", "height", ",", "width", ",", "boxes", "=", "None", ")", ":", "\n", "\t", "global", "sample_options", "\n", "\n", "while", "True", ":", "\n", "# randomly choose a mode", "\n", "\t\t", "mode", "=", "random", ".", "choice", "(", "sample_options", ")", "\n", "if", "mode", "is", "None", ":", "\n", "\t\t\t", "return", "height", ",", "width", ",", "boxes", "\n", "\n", "", "min_iou", ",", "max_iou", "=", "mode", "\n", "if", "min_iou", "is", "None", ":", "\n", "\t\t\t", "min_iou", "=", "float", "(", "'-inf'", ")", "\n", "", "if", "max_iou", "is", "None", ":", "\n", "\t\t\t", "max_iou", "=", "float", "(", "'inf'", ")", "\n", "\n", "", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "\t\t\t", "w", "=", "random", ".", "uniform", "(", "0.3", "*", "width", ",", "width", ")", "\n", "h", "=", "random", ".", "uniform", "(", "0.3", "*", "height", ",", "height", ")", "\n", "\n", "if", "h", "/", "w", "<", "0.5", "or", "h", "/", "w", ">", "2", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "", "left", "=", "random", ".", "uniform", "(", "0", ",", "width", "-", "w", ")", "\n", "top", "=", "random", ".", "uniform", "(", "0", ",", "height", "-", "h", ")", "\n", "\n", "rect", "=", "np", ".", "array", "(", "[", "int", "(", "left", ")", ",", "int", "(", "top", ")", ",", "int", "(", "left", "+", "w", ")", ",", "int", "(", "top", "+", "h", ")", "]", ")", "\n", "overlap", "=", "jaccard_numpy", "(", "boxes", ",", "rect", ")", "\n", "if", "overlap", ".", "min", "(", ")", "<", "min_iou", "and", "max_iou", "<", "overlap", ".", "max", "(", ")", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "", "centers", "=", "(", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", ")", "/", "2.0", "\n", "\n", "m1", "=", "(", "rect", "[", "0", "]", "<", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "1", "]", "<", "centers", "[", ":", ",", "1", "]", ")", "\n", "m2", "=", "(", "rect", "[", "2", "]", ">", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "3", "]", ">", "centers", "[", ":", ",", "1", "]", ")", "\n", "mask", "=", "m1", "*", "m2", "\n", "\n", "if", "not", "mask", ".", "any", "(", ")", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "", "current_boxes", "=", "boxes", "[", "mask", ",", ":", "]", ".", "copy", "(", ")", "\n", "current_boxes", "[", ":", ",", ":", "2", "]", "=", "np", ".", "maximum", "(", "current_boxes", "[", ":", ",", ":", "2", "]", ",", "rect", "[", ":", "2", "]", ")", "\n", "current_boxes", "[", ":", ",", ":", "2", "]", "-=", "rect", "[", ":", "2", "]", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "=", "np", ".", "minimum", "(", "current_boxes", "[", ":", ",", "2", ":", "]", ",", "rect", "[", "2", ":", "]", ")", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "-=", "rect", "[", ":", "2", "]", "\n", "\n", "return", "h", ",", "w", ",", "current_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.plot_loss.smoother": [[35, 43], ["utils.functions.MovingAverage", "range", "len", "utils.functions.MovingAverage.append", "utils.functions.MovingAverage.get_avg"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.get_avg"], ["", "", "", "def", "smoother", "(", "y", ",", "interval", "=", "100", ")", ":", "\n", "\t", "avg", "=", "MovingAverage", "(", "interval", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "y", ")", ")", ":", "\n", "\t\t", "avg", ".", "append", "(", "y", "[", "i", "]", ")", "\n", "y", "[", "i", "]", "=", "avg", ".", "get_avg", "(", ")", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.plot_loss.plot_train": [[44, 62], ["matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.show", "plot_loss.smoother", "plot_loss.smoother", "plot_loss.smoother", "matplotlib.plot", "loss_names.append", "os.path.basename", "plot_loss.smoother"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.plot", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.plot", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.plot", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.plot", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.plot_loss.smoother"], ["", "def", "plot_train", "(", "data", ")", ":", "\n", "\t", "plt", ".", "title", "(", "os", ".", "path", ".", "basename", "(", "sys", ".", "argv", "[", "1", "]", ")", "+", "' Training Loss'", ")", "\n", "plt", ".", "xlabel", "(", "'Iteration'", ")", "\n", "plt", ".", "ylabel", "(", "'Loss'", ")", "\n", "\n", "loss_names", "=", "[", "'BBox Loss'", ",", "'Conf Loss'", ",", "'Mask Loss'", "]", "\n", "\n", "x", "=", "[", "x", "[", "'iteration'", "]", "for", "x", "in", "data", "]", "\n", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'b'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'c'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'m'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "\n", "if", "data", "[", "0", "]", "[", "'s'", "]", "is", "not", "None", ":", "\n", "\t\t", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'s'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "loss_names", ".", "append", "(", "'Segmentation Loss'", ")", "\n", "\n", "", "plt", ".", "legend", "(", "loss_names", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.plot_loss.plot_val": [[63, 74], ["matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.show", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.plot", "home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.LogVisualizer.plot"], ["", "def", "plot_val", "(", "data", ")", ":", "\n", "\t", "plt", ".", "title", "(", "os", ".", "path", ".", "basename", "(", "sys", ".", "argv", "[", "1", "]", ")", "+", "' Validation mAP'", ")", "\n", "plt", ".", "xlabel", "(", "'Epoch'", ")", "\n", "plt", ".", "ylabel", "(", "'mAP'", ")", "\n", "\n", "x", "=", "[", "x", "[", "1", "]", "[", "'epoch'", "]", "for", "x", "in", "data", "if", "x", "[", "0", "]", "[", "'type'", "]", "==", "'box'", "]", "\n", "plt", ".", "plot", "(", "x", ",", "[", "x", "[", "0", "]", "[", "'all'", "]", "for", "x", "in", "data", "if", "x", "[", "0", "]", "[", "'type'", "]", "==", "'box'", "]", ")", "\n", "plt", ".", "plot", "(", "x", ",", "[", "x", "[", "0", "]", "[", "'all'", "]", "for", "x", "in", "data", "if", "x", "[", "0", "]", "[", "'type'", "]", "==", "'mask'", "]", ")", "\n", "\n", "plt", ".", "legend", "(", "[", "'BBox mAP'", ",", "'Mask mAP'", "]", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.intersect": [[24, 43], ["box_a.size", "box_b.size", "torch.min", "torch.max", "torch.clamp", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze", "box_b[].unsqueeze", "box_a[].unsqueeze", "box_b[].unsqueeze"], "function", ["None"], ["def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\" We resize both tensors to [A,B,2] without new malloc:\n    [A,2] -> [A,1,2] -> [A,B,2]\n    [B,2] -> [1,B,2] -> [A,B,2]\n    Then we compute the area of intersect between box_a and box_b.\n    Args:\n      box_a: (tensor) bounding boxes, Shape: [A,4].\n      box_b: (tensor) bounding boxes, Shape: [B,4].\n    Return:\n      (tensor) intersection area, Shape: [A,B].\n    \"\"\"", "\n", "A", "=", "box_a", ".", "size", "(", "0", ")", "\n", "B", "=", "box_b", ".", "size", "(", "0", ")", "\n", "max_xy", "=", "torch", ".", "min", "(", "box_a", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "min_xy", "=", "torch", ".", "max", "(", "box_a", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "inter", "=", "torch", ".", "clamp", "(", "(", "max_xy", "-", "min_xy", ")", ",", "min", "=", "0", ")", "\n", "return", "inter", "[", ":", ",", ":", ",", "0", "]", "*", "inter", "[", ":", ",", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.jaccard": [[45, 68], ["optimize_bboxes.intersect"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.intersect"], ["", "def", "jaccard", "(", "box_a", ",", "box_b", ",", "iscrowd", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.  Here we operate on\n    ground truth boxes and default boxes. If iscrowd=True, put the crowd in box_b.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]\n        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]\n    Return:\n        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]\n    \"\"\"", "\n", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", ":", ",", "2", "]", "-", "box_b", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_b", "[", ":", ",", "3", "]", "-", "box_b", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "0", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "\n", "if", "iscrowd", ":", "\n", "        ", "return", "inter", "/", "area_a", "\n", "", "else", ":", "\n", "        ", "return", "inter", "/", "union", "# [A,B]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.to_relative": [[70, 72], ["numpy.concatenate"], "function", ["None"], ["", "", "def", "to_relative", "(", "bboxes", ")", ":", "\n", "    ", "return", "np", ".", "concatenate", "(", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "/", "bboxes", "[", ":", ",", ":", "2", "]", ",", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "+", "bboxes", "[", ":", ",", "4", ":", "]", ")", "/", "bboxes", "[", ":", ",", ":", "2", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.make_priors": [[74, 92], ["itertools.product", "torch.Tensor().view().cuda", "range", "range", "zip", "torch.Tensor().view", "torch.Tensor"], "function", ["None"], ["", "def", "make_priors", "(", "conv_size", ",", "scales", ",", "aspect_ratios", ")", ":", "\n", "    ", "prior_data", "=", "[", "]", "\n", "conv_h", "=", "conv_size", "[", "0", "]", "\n", "conv_w", "=", "conv_size", "[", "1", "]", "\n", "\n", "# Iteration order is important (it has to sync up with the convout)", "\n", "for", "j", ",", "i", "in", "product", "(", "range", "(", "conv_h", ")", ",", "range", "(", "conv_w", ")", ")", ":", "\n", "        ", "x", "=", "(", "i", "+", "0.5", ")", "/", "conv_w", "\n", "y", "=", "(", "j", "+", "0.5", ")", "/", "conv_h", "\n", "\n", "for", "scale", ",", "ars", "in", "zip", "(", "scales", ",", "aspect_ratios", ")", ":", "\n", "            ", "for", "ar", "in", "ars", ":", "\n", "                ", "w", "=", "scale", "*", "ar", "/", "conv_w", "\n", "h", "=", "scale", "/", "ar", "/", "conv_h", "\n", "\n", "# Point form", "\n", "prior_data", "+=", "[", "x", "-", "w", "/", "2", ",", "y", "-", "h", "/", "2", ",", "x", "+", "w", "/", "2", ",", "y", "+", "h", "/", "2", "]", "\n", "", "", "", "return", "torch", ".", "Tensor", "(", "prior_data", ")", ".", "view", "(", "-", "1", ",", "4", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.compute_hits": [[104, 109], ["optimize_bboxes.jaccard", "torch.max"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard"], ["def", "compute_hits", "(", "bboxes", ",", "anchors", ",", "iou_threshold", "=", "0.5", ")", ":", "\n", "    ", "ious", "=", "jaccard", "(", "bboxes", ",", "anchors", ")", "\n", "perGTAnchorMax", ",", "_", "=", "torch", ".", "max", "(", "ious", ",", "dim", "=", "1", ")", "\n", "\n", "return", "(", "perGTAnchorMax", ">", "iou_threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.compute_recall": [[110, 113], ["torch.sum", "hits.size"], "function", ["None"], ["", "def", "compute_recall", "(", "hits", ",", "base_hits", ")", ":", "\n", "    ", "hits", "=", "(", "hits", "|", "base_hits", ")", ".", "float", "(", ")", "\n", "return", "torch", ".", "sum", "(", "hits", ")", "/", "hits", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.step": [[115, 122], ["x_func", "optimize_bboxes.make_priors", "float", "compute_recall().cpu", "optimize_bboxes.compute_recall", "optimize_bboxes.compute_hits"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.make_priors", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.compute_recall", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.compute_hits"], ["", "def", "step", "(", "x", ",", "x_func", ",", "bboxes", ",", "base_hits", ",", "optim_idx", ")", ":", "\n", "# This should set the scale and aspect ratio", "\n", "    ", "x_func", "(", "x", ",", "scales", "[", "optim_idx", "]", ",", "aspect_ratios", "[", "optim_idx", "]", ")", "\n", "\n", "anchors", "=", "make_priors", "(", "conv_sizes", "[", "optim_idx", "]", ",", "scales", "[", "optim_idx", "]", ",", "aspect_ratios", "[", "optim_idx", "]", ")", "\n", "\n", "return", "-", "float", "(", "compute_recall", "(", "compute_hits", "(", "bboxes", ",", "anchors", ")", ",", "base_hits", ")", ".", "cpu", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.optimize": [[124, 155], ["min", "optimize_bboxes.compute_hits", "scipy.optimize.minimize", "full_bboxes.size", "optimize_bboxes.make_priors", "torch.cat", "full_bboxes.size", "range", "range", "range", "len", "len", "max", "len", "range", "sum", "len"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.compute_hits", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.make_priors"], ["", "def", "optimize", "(", "full_bboxes", ",", "optim_idx", ",", "batch_size", "=", "5000", ")", ":", "\n", "    ", "global", "batch_idx", ",", "scales", ",", "aspect_ratios", ",", "conv_sizes", "\n", "\n", "start", "=", "batch_idx", "*", "batch_size", "\n", "end", "=", "min", "(", "(", "batch_idx", "+", "1", ")", "*", "batch_size", ",", "full_bboxes", ".", "size", "(", "0", ")", ")", "\n", "\n", "if", "batch_idx", ">", "(", "full_bboxes", ".", "size", "(", "0", ")", "//", "batch_size", ")", ":", "\n", "        ", "batch_idx", "=", "0", "\n", "\n", "", "bboxes", "=", "full_bboxes", "[", "start", ":", "end", ",", ":", "]", "\n", "\n", "anchor_base", "=", "[", "\n", "make_priors", "(", "conv_sizes", "[", "idx", "]", ",", "scales", "[", "idx", "]", ",", "aspect_ratios", "[", "idx", "]", ")", "\n", "for", "idx", "in", "range", "(", "len", "(", "conv_sizes", ")", ")", "if", "idx", "!=", "optim_idx", "]", "\n", "base_hits", "=", "compute_hits", "(", "bboxes", ",", "torch", ".", "cat", "(", "anchor_base", ",", "dim", "=", "0", ")", ")", "\n", "\n", "\n", "def", "set_x", "(", "x", ",", "scales", ",", "aspect_ratios", ")", ":", "\n", "        ", "if", "optimize_scales", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "scales", ")", ")", ":", "\n", "                ", "scales", "[", "i", "]", "=", "max", "(", "x", "[", "i", "]", ",", "0", ")", "\n", "", "", "else", ":", "\n", "            ", "k", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "aspect_ratios", ")", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "len", "(", "aspect_ratios", "[", "i", "]", ")", ")", ":", "\n", "                    ", "aspect_ratios", "[", "i", "]", "[", "j", "]", "=", "x", "[", "k", "]", "\n", "k", "+=", "1", "\n", "\n", "\n", "", "", "", "", "res", "=", "minimize", "(", "step", ",", "x0", "=", "scales", "[", "optim_idx", "]", "if", "optimize_scales", "else", "sum", "(", "aspect_ratios", "[", "optim_idx", "]", ",", "[", "]", ")", ",", "method", "=", "'Powell'", ",", "\n", "args", "=", "(", "set_x", ",", "bboxes", ",", "base_hits", ",", "optim_idx", ")", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.pretty_str": [[157, 164], ["isinstance", "isinstance", "optimize_bboxes.pretty_str", "list", "optimize_bboxes.pretty_str"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.pretty_str", "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.optimize_bboxes.pretty_str"], ["", "def", "pretty_str", "(", "x", ":", "list", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "        ", "return", "'['", "+", "', '", ".", "join", "(", "[", "pretty_str", "(", "y", ")", "for", "y", "in", "x", "]", ")", "+", "']'", "\n", "", "elif", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "pretty_str", "(", "list", "(", "x", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "'%.2f'", "%", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.cluster_bbox_sizes.to_relative": [[21, 23], ["None"], "function", ["None"], ["def", "to_relative", "(", "bboxes", ")", ":", "\n", "\t", "return", "bboxes", "[", ":", ",", "2", ":", "4", "]", "/", "bboxes", "[", ":", ",", ":", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.cluster_bbox_sizes.process": [[24, 26], ["cluster_bbox_sizes.to_relative"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.to_relative"], ["", "def", "process", "(", "bboxes", ")", ":", "\n", "\t", "return", "to_relative", "(", "bboxes", ")", "*", "max_size", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.intersect": [[24, 43], ["box_a.size", "box_b.size", "torch.min", "torch.max", "torch.clamp", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze", "box_b[].unsqueeze", "box_a[].unsqueeze", "box_b[].unsqueeze"], "function", ["None"], ["def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\" We resize both tensors to [A,B,2] without new malloc:\n    [A,2] -> [A,1,2] -> [A,B,2]\n    [B,2] -> [1,B,2] -> [A,B,2]\n    Then we compute the area of intersect between box_a and box_b.\n    Args:\n      box_a: (tensor) bounding boxes, Shape: [A,4].\n      box_b: (tensor) bounding boxes, Shape: [B,4].\n    Return:\n      (tensor) intersection area, Shape: [A,B].\n    \"\"\"", "\n", "A", "=", "box_a", ".", "size", "(", "0", ")", "\n", "B", "=", "box_b", ".", "size", "(", "0", ")", "\n", "max_xy", "=", "torch", ".", "min", "(", "box_a", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "min_xy", "=", "torch", ".", "max", "(", "box_a", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "inter", "=", "torch", ".", "clamp", "(", "(", "max_xy", "-", "min_xy", ")", ",", "min", "=", "0", ")", "\n", "return", "inter", "[", ":", ",", ":", ",", "0", "]", "*", "inter", "[", ":", ",", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.jaccard": [[45, 68], ["bbox_recall.intersect"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.intersect"], ["", "def", "jaccard", "(", "box_a", ",", "box_b", ",", "iscrowd", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.  Here we operate on\n    ground truth boxes and default boxes. If iscrowd=True, put the crowd in box_b.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]\n        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]\n    Return:\n        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]\n    \"\"\"", "\n", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", ":", ",", "2", "]", "-", "box_b", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_b", "[", ":", ",", "3", "]", "-", "box_b", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "0", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "\n", "if", "iscrowd", ":", "\n", "        ", "return", "inter", "/", "area_a", "\n", "", "else", ":", "\n", "        ", "return", "inter", "/", "union", "# [A,B]", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.to_relative": [[70, 72], ["numpy.concatenate"], "function", ["None"], ["", "", "def", "to_relative", "(", "bboxes", ")", ":", "\n", "    ", "return", "np", ".", "concatenate", "(", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "/", "bboxes", "[", ":", ",", ":", "2", "]", ",", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "+", "bboxes", "[", ":", ",", "4", ":", "]", ")", "/", "bboxes", "[", ":", ",", ":", "2", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.bbox_recall.make_priors": [[74, 93], ["itertools.product", "numpy.array().reshape", "range", "range", "zip", "numpy.array"], "function", ["None"], ["", "def", "make_priors", "(", "conv_size", ",", "scales", ",", "aspect_ratios", ")", ":", "\n", "    ", "prior_data", "=", "[", "]", "\n", "conv_h", "=", "conv_size", "[", "0", "]", "\n", "conv_w", "=", "conv_size", "[", "1", "]", "\n", "\n", "# Iteration order is important (it has to sync up with the convout)", "\n", "for", "j", ",", "i", "in", "product", "(", "range", "(", "conv_h", ")", ",", "range", "(", "conv_w", ")", ")", ":", "\n", "        ", "x", "=", "(", "i", "+", "0.5", ")", "/", "conv_w", "\n", "y", "=", "(", "j", "+", "0.5", ")", "/", "conv_h", "\n", "\n", "for", "scale", ",", "ars", "in", "zip", "(", "scales", ",", "aspect_ratios", ")", ":", "\n", "            ", "for", "ar", "in", "ars", ":", "\n", "                ", "w", "=", "scale", "*", "ar", "/", "conv_w", "\n", "h", "=", "scale", "/", "ar", "/", "conv_h", "\n", "\n", "# Point form", "\n", "prior_data", "+=", "[", "x", "-", "w", "/", "2", ",", "y", "-", "h", "/", "2", ",", "x", "+", "w", "/", "2", ",", "y", "+", "h", "/", "2", "]", "\n", "\n", "", "", "", "return", "np", ".", "array", "(", "prior_data", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.mask_iou": [[10, 21], ["torch.matmul", "torch.matmul", "torch.sum().view", "torch.sum().view", "torch.sum().view", "torch.sum().view", "mask2.t", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum().view.t"], "function", ["None"], ["def", "mask_iou", "(", "mask1", ",", "mask2", ")", ":", "\n", "    ", "\"\"\"\n    Inputs inputs are matricies of size _ x N. Output is size _1 x _2.\n    Note: if iscrowd is True, then mask2 should be the crowd.\n    \"\"\"", "\n", "intersection", "=", "torch", ".", "matmul", "(", "mask1", ",", "mask2", ".", "t", "(", ")", ")", "\n", "area1", "=", "torch", ".", "sum", "(", "mask1", ",", "dim", "=", "1", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "area2", "=", "torch", ".", "sum", "(", "mask2", ",", "dim", "=", "1", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "union", "=", "(", "area1", ".", "t", "(", ")", "+", "area2", ")", "-", "intersection", "\n", "\n", "return", "intersection", "/", "union", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.paint_mask": [[22, 39], ["img_numpy.copy.copy", "numpy.tile", "numpy.array().reshape", "numpy.tile", "np.tile.reshape", "numpy.array"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.datasets.config.Config.copy"], ["", "def", "paint_mask", "(", "img_numpy", ",", "mask", ",", "color", ")", ":", "\n", "\t", "h", ",", "w", ",", "_", "=", "img_numpy", ".", "shape", "\n", "img_numpy", "=", "img_numpy", ".", "copy", "(", ")", "\n", "\n", "mask", "=", "np", ".", "tile", "(", "mask", ".", "reshape", "(", "h", ",", "w", ",", "1", ")", ",", "(", "1", ",", "1", ",", "3", ")", ")", "\n", "color_np", "=", "np", ".", "array", "(", "color", "[", ":", "3", "]", ")", ".", "reshape", "(", "1", ",", "1", ",", "3", ")", "\n", "color_np", "=", "np", ".", "tile", "(", "color_np", ",", "(", "h", ",", "w", ",", "1", ")", ")", "\n", "mask_color", "=", "mask", "*", "color_np", "\n", "\n", "mask_alpha", "=", "0.3", "\n", "\n", "# Blend image and mask", "\n", "image_crop", "=", "img_numpy", "*", "mask", "\n", "img_numpy", "*=", "(", "1", "-", "mask", ")", "\n", "img_numpy", "+=", "image_crop", "*", "(", "1", "-", "mask_alpha", ")", "+", "mask_color", "*", "mask_alpha", "\n", "\n", "return", "img_numpy", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.logit": [[41, 43], ["numpy.log"], "function", ["home.repos.pwc.inspect_result.MinghanLi_STMask.utils.logger.Log.log"], ["", "def", "logit", "(", "x", ")", ":", "\n", "\t", "return", "np", ".", "log", "(", "x", "/", "(", "1", "-", "x", "+", "0.0001", ")", "+", "0.0001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.scripts.compute_masks.sigmoid": [[44, 46], ["numpy.exp"], "function", ["None"], ["", "def", "sigmoid", "(", "x", ")", ":", "\n", "\t", "return", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.do_GET": [[11, 20], ["server.Handler.send_str", "server.Handler.path.startswith", "server.Handler.translate_path().split", "server.Handler.send_file", "super().do_GET", "os.path.join", "server.Handler.translate_path", "pathlib.Path().glob", "int", "pathlib.Path"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.send_str", "home.repos.pwc.inspect_result.MinghanLi_STMask.modules.multibox_loss.MultiBoxLoss.split", "home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.send_file", "home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.do_GET"], ["\t", "def", "do_GET", "(", "self", ")", ":", "\n", "\t\t", "if", "self", ".", "path", "==", "'/detindex'", ":", "\n", "\t\t\t", "self", ".", "send_str", "(", "'\\n'", ".", "join", "(", "[", "p", ".", "name", "[", ":", "-", "5", "]", "for", "p", "in", "Path", "(", "'dets/'", ")", ".", "glob", "(", "'*.json'", ")", "]", ")", ")", "\n", "", "elif", "self", ".", "path", ".", "startswith", "(", "'/image'", ")", ":", "\n", "# Unsafe practices ahead!", "\n", "\t\t\t", "path", "=", "self", ".", "translate_path", "(", "self", ".", "path", ")", ".", "split", "(", "'image'", ")", "\n", "self", ".", "send_file", "(", "os", ".", "path", ".", "join", "(", "path", "[", "0", "]", ",", "IMAGE_PATH", ",", "IMAGE_FMT", "%", "int", "(", "path", "[", "1", "]", ")", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "super", "(", ")", ".", "do_GET", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.send_str": [[21, 29], ["server.Handler.send_response", "server.Handler.send_header", "server.Handler.send_header", "server.Handler.send_header", "server.Handler.end_headers", "server.Handler.wfile.write", "str", "server.Handler.date_time_string", "string.encode", "len"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.send_response", "home.repos.pwc.inspect_result.MinghanLi_STMask.layers.box_utils.encode"], ["", "", "def", "send_str", "(", "self", ",", "string", ")", ":", "\n", "\t\t", "self", ".", "send_response", "(", "HTTPStatus", ".", "OK", ")", "\n", "self", ".", "send_header", "(", "'Content-type'", ",", "'text/plain'", ")", "\n", "self", ".", "send_header", "(", "'Content-Length'", ",", "str", "(", "len", "(", "string", ")", ")", ")", "\n", "self", ".", "send_header", "(", "'Last-Modified'", ",", "self", ".", "date_time_string", "(", ")", ")", "\n", "self", ".", "end_headers", "(", ")", "\n", "\n", "self", ".", "wfile", ".", "write", "(", "string", ".", "encode", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.send_file": [[30, 48], ["open", "server.Handler.send_response", "server.Handler.send_header", "os.fstat", "server.Handler.send_header", "server.Handler.send_header", "server.Handler.end_headers", "server.Handler.copyfile", "open.close", "server.Handler.send_error", "server.Handler.guess_type", "open.fileno", "str", "server.Handler.date_time_string"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.send_response"], ["", "def", "send_file", "(", "self", ",", "path", ")", ":", "\n", "\t\t", "try", ":", "\n", "\t\t\t", "f", "=", "open", "(", "path", ",", "'rb'", ")", "\n", "", "except", "OSError", ":", "\n", "\t\t\t", "self", ".", "send_error", "(", "HTTPStatus", ".", "NOT_FOUND", ",", "\"File not found\"", ")", "\n", "return", "\n", "\n", "", "try", ":", "\n", "\t\t\t", "self", ".", "send_response", "(", "HTTPStatus", ".", "OK", ")", "\n", "self", ".", "send_header", "(", "\"Content-type\"", ",", "self", ".", "guess_type", "(", "path", ")", ")", "\n", "fs", "=", "os", ".", "fstat", "(", "f", ".", "fileno", "(", ")", ")", "\n", "self", ".", "send_header", "(", "\"Content-Length\"", ",", "str", "(", "fs", "[", "6", "]", ")", ")", "\n", "self", ".", "send_header", "(", "\"Last-Modified\"", ",", "self", ".", "date_time_string", "(", "fs", ".", "st_mtime", ")", ")", "\n", "self", ".", "end_headers", "(", ")", "\n", "\n", "self", ".", "copyfile", "(", "f", ",", "self", ".", "wfile", ")", "\n", "", "finally", ":", "\n", "\t\t\t", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.send_response": [[49, 51], ["super().send_response"], "methods", ["home.repos.pwc.inspect_result.MinghanLi_STMask.web.server.Handler.send_response"], ["", "", "def", "send_response", "(", "self", ",", "code", ",", "message", "=", "None", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "send_response", "(", "code", ",", "message", ")", "\n", "\n"]]}