{"home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.ioutils.get_edgelist": [[5, 45], ["numpy.array", "open", "line.replace().replace.replace().replace", "line.replace().replace.split", "edgelist.append", "line.replace().replace.replace", "line.replace().replace.split", "edgelist.append", "int", "int", "int", "int", "line.replace().replace.split", "edgelist.append", "int", "int", "line.replace().replace.split", "edgelist.append", "ValueError", "int", "int"], "function", ["None"], ["def", "get_edgelist", "(", "f_edgelist", ",", "delimiter", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    This function returns an edgelist list from a file.\n\n    Parameters\n    ----------\n    f_edgelist : ``str``\n        The path to the edgelist text file.\n\n    delimiter : ``str``\n        The delimiter that separate the edges.\n\n    Returns\n    -------\n    edgelist : :class:`numpy.ndarray`\n        The numpy list of tupled edges.\n    \"\"\"", "\n", "edgelist", "=", "[", "]", "\n", "with", "open", "(", "f_edgelist", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "for", "line", "in", "f", ":", "\n", "            ", "line", "=", "line", ".", "replace", "(", "'\\r'", ",", "''", ")", ".", "replace", "(", "'\\n'", ",", "''", ")", "# remove all line breaks!", "\n", "if", "delimiter", "is", "not", "None", ":", "\n", "                ", "edge", "=", "line", ".", "split", "(", "delimiter", ")", "\n", "edgelist", ".", "append", "(", "(", "int", "(", "edge", "[", "0", "]", ")", ",", "int", "(", "edge", "[", "1", "]", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "try", ":", "\n", "                    ", "edge", "=", "line", ".", "split", "(", "' '", ")", "\n", "edgelist", ".", "append", "(", "(", "int", "(", "edge", "[", "0", "]", ")", ",", "int", "(", "edge", "[", "1", "]", ")", ")", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "try", ":", "\n", "                        ", "edge", "=", "line", ".", "split", "(", "'\\t'", ")", "\n", "edgelist", ".", "append", "(", "(", "int", "(", "edge", "[", "0", "]", ")", ",", "int", "(", "edge", "[", "1", "]", ")", ")", ")", "\n", "", "except", "ValueError", ":", "\n", "                        ", "try", ":", "\n", "                            ", "edge", "=", "line", ".", "split", "(", "','", ")", "\n", "edgelist", ".", "append", "(", "(", "int", "(", "edge", "[", "0", "]", ")", ",", "int", "(", "edge", "[", "1", "]", ")", ")", ")", "\n", "", "except", "ValueError", ":", "\n", "                            ", "raise", "ValueError", "(", "\"Tried delimiters ' ', '\\t', and ',', but none work...\"", ")", "\n", "\n", "", "", "", "", "", "", "return", "np", ".", "array", "(", "edgelist", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.ioutils.get_types": [[47, 74], ["numpy.array", "open", "types.append", "int", "line.replace"], "function", ["None"], ["", "def", "get_types", "(", "f_types", ")", ":", "\n", "    ", "\"\"\"\n    This function returns an edgelist list from a file.\n\n    Parameters\n    ----------\n    f_edgelist : ``str``\n        The path to the types file\n\n    Returns\n    -------\n    edgelist : ``list``\n        The list of types of each node.\n\n    Examples\n    --------\n    >>> from biSBM.ioutils import get_types\n    >>> edgelist = get_types(f_types)\n    >>> print(edgelist)\n\n    \"\"\"", "\n", "types", "=", "[", "]", "\n", "with", "open", "(", "f_types", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "for", "line", "in", "f", ":", "\n", "            ", "types", ".", "append", "(", "int", "(", "line", ".", "replace", "(", "'\\n'", ",", "\"\"", ")", ")", ")", "\n", "\n", "", "", "return", "np", ".", "array", "(", "types", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.ioutils.save_mb_to_file": [[76, 93], ["len", "type", "open", "range", "f.write", "str"], "function", ["None"], ["", "def", "save_mb_to_file", "(", "path", ",", "mb", ")", ":", "\n", "    ", "\"\"\"Save the group membership list to a file path.\n\n    Parameters\n    ----------\n    path : ``str``, required\n        File path for the list to save to.\n\n    mb : ``list[int]``, required\n        Group membership list.\n\n    \"\"\"", "\n", "assert", "type", "(", "mb", ")", "is", "list", ",", "\"[ERROR] the type of the second input parameter should be a list\"", "\n", "num_nodes", "=", "len", "(", "mb", ")", "\n", "with", "open", "(", "path", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "for", "i", "in", "range", "(", "0", ",", "num_nodes", ")", ":", "\n", "            ", "f", ".", "write", "(", "str", "(", "mb", "[", "i", "]", ")", "+", "\"\\n\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.__init__": [[47, 145], ["dict", "list", "np.array", "len", "collections.OrderedDict", "collections.OrderedDict", "dict", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "optimalks.OptimalKs._get_tempfile_edgelist", "optimalks.OptimalKs._set_logging_level", "dict", "init_q_cache", "engine.set_steps", "engine.set_await_steps", "engine.set_cooling", "engine.set_cooling_param_1", "engine.set_epsilon", "int", "int", "np.random.randint", "np.random.randint", "tempfile.NamedTemporaryFile", "tempfile.NamedTemporaryFile", "int", "int"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._get_tempfile_edgelist", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._set_logging_level", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.init_q_cache", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_steps", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_await_steps", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_cooling", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_cooling_param_1", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_epsilon"], ["def", "__init__", "(", "self", ",", "\n", "engine", ",", "\n", "edgelist", ",", "\n", "types", ",", "\n", "verbose", "=", "False", ",", "\n", "default_args", "=", "True", ",", "\n", "random_init_k", "=", "False", ",", "\n", "bipartite_prior", "=", "True", ",", "\n", "tempdir", "=", "None", ")", ":", "\n", "\n", "        ", "self", ".", "engine_", "=", "engine", ".", "engine", "# TODO: check that engine is an object", "\n", "self", ".", "max_n_sweeps_", "=", "engine", ".", "MAX_NUM_SWEEPS", "\n", "self", ".", "is_par_", "=", "engine", ".", "PARALLELIZATION", "\n", "self", ".", "n_cores_", "=", "engine", ".", "NUM_CORES", "\n", "self", ".", "algm_name_", "=", "engine", ".", "ALGM_NAME", "\n", "self", ".", "_virgin_run", "=", "True", "\n", "\n", "self", ".", "bm_state", "=", "dict", "(", ")", "\n", "self", ".", "bm_state", "[", "\"types\"", "]", "=", "types", "# TODO: \"types\" is only used to compute na and nb. Can be made more generic.", "\n", "self", ".", "bm_state", "[", "\"n_a\"", "]", "=", "0", "\n", "self", ".", "bm_state", "[", "\"n_b\"", "]", "=", "0", "\n", "self", ".", "bm_state", "[", "\"n\"", "]", "=", "0", "\n", "self", ".", "bm_state", "[", "\"ref_dl\"", "]", "=", "0", "\n", "self", ".", "bm_state", "[", "\"e_rs\"", "]", "=", "None", "\n", "self", ".", "bm_state", "[", "\"mb\"", "]", "=", "list", "(", ")", "\n", "\n", "for", "_type", "in", "types", ":", "\n", "            ", "self", ".", "bm_state", "[", "\"n\"", "]", "+=", "1", "\n", "if", "_type", "in", "[", "\"1\"", ",", "1", "]", ":", "\n", "                ", "self", ".", "bm_state", "[", "\"n_a\"", "]", "+=", "1", "\n", "", "elif", "_type", "in", "[", "\"2\"", ",", "2", "]", ":", "\n", "                ", "self", ".", "bm_state", "[", "\"n_b\"", "]", "+=", "1", "\n", "\n", "", "", "self", ".", "edgelist", "=", "np", ".", "array", "(", "edgelist", ",", "dtype", "=", "np", ".", "uint64", ")", "\n", "self", ".", "bm_state", "[", "\"e\"", "]", "=", "len", "(", "self", ".", "edgelist", ")", "\n", "self", ".", "i_0s", "=", "[", "]", "\n", "if", "engine", ".", "ALGM_NAME", "==", "\"mcmc\"", "and", "default_args", ":", "\n", "            ", "engine", ".", "set_steps", "(", "self", ".", "bm_state", "[", "\"n\"", "]", "*", "1e5", ")", "\n", "engine", ".", "set_await_steps", "(", "self", ".", "bm_state", "[", "\"n\"", "]", "*", "2e3", ")", "\n", "engine", ".", "set_cooling", "(", "\"abrupt_cool\"", ")", "\n", "engine", ".", "set_cooling_param_1", "(", "self", ".", "bm_state", "[", "\"n\"", "]", "*", "1e3", ")", "\n", "engine", ".", "set_epsilon", "(", "1.", ")", "\n", "", "if", "default_args", ":", "\n", "            ", "self", ".", "bm_state", "[", "\"ka\"", "]", "=", "int", "(", "self", ".", "bm_state", "[", "\"e\"", "]", "**", "0.5", "/", "2", ")", "\n", "self", ".", "bm_state", "[", "\"kb\"", "]", "=", "int", "(", "self", ".", "bm_state", "[", "\"e\"", "]", "**", "0.5", "/", "2", ")", "\n", "self", ".", "i_0", "=", "1.", "\n", "self", ".", "adaptive_ratio", "=", "0.9", "# adaptive parameter to make the \"i_0\" smaller, if it's overshooting.", "\n", "self", ".", "_k_th_nb_to_search", "=", "2", "\n", "self", ".", "_nm", "=", "10", "\n", "self", ".", "_c", "=", "3.", "\n", "", "else", ":", "\n", "            ", "self", ".", "bm_state", "[", "\"ka\"", "]", "=", "self", ".", "bm_state", "[", "\"kb\"", "]", "=", "self", ".", "i_0", "=", "self", ".", "adaptive_ratio", "=", "self", ".", "_k_th_nb_to_search", "=", "self", ".", "_nm", "=", "None", "\n", "", "if", "random_init_k", ":", "\n", "            ", "self", ".", "bm_state", "[", "\"ka\"", "]", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "self", ".", "bm_state", "[", "\"ka\"", "]", "+", "1", ")", "\n", "self", ".", "bm_state", "[", "\"kb\"", "]", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "self", ".", "bm_state", "[", "\"kb\"", "]", "+", "1", ")", "\n", "\n", "# Description Length (dl), e_rs matrix, and partition (mb) are book-kept", "\n", "", "self", ".", "bookkeeping_dl", "=", "OrderedDict", "(", ")", "\n", "self", ".", "bookkeeping_e_rs", "=", "OrderedDict", "(", ")", "\n", "self", ".", "bookkeeping_mb", "=", "dict", "(", ")", "\n", "self", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "=", "OrderedDict", "(", ")", "\n", "self", ".", "bookkeeping_mb", "[", "\"merge\"", "]", "=", "OrderedDict", "(", ")", "\n", "self", ".", "bookkeeping_mb", "[", "\"order\"", "]", "=", "OrderedDict", "(", ")", "\n", "self", ".", "trace_k", "=", "[", "]", "# only for painter.paint_trace", "\n", "\n", "# for debug/temp variables", "\n", "self", ".", "tempdir", "=", "tempdir", "\n", "\n", "self", ".", "__del__no_call", "=", "True", "\n", "if", "self", ".", "is_par_", ":", "\n", "# To prevent \"TypeError: cannot serialize '_io.TextIOWrapper' object\" when using loky", "\n", "            ", "self", ".", "f_edgelist", "=", "tempfile", ".", "NamedTemporaryFile", "(", "mode", "=", "'w+b'", ",", "dir", "=", "tempdir", ",", "delete", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "f_edgelist", "=", "tempfile", ".", "NamedTemporaryFile", "(", "mode", "=", "'w+b'", ",", "dir", "=", "tempdir", ",", "delete", "=", "True", ")", "\n", "", "self", ".", "_f_edgelist_name", "=", "self", ".", "_get_tempfile_edgelist", "(", ")", "\n", "\n", "# logging", "\n", "if", "verbose", ":", "\n", "            ", "_logging_level", "=", "\"INFO\"", "\n", "", "else", ":", "\n", "            ", "_logging_level", "=", "\"WARNING\"", "\n", "", "self", ".", "_logger", "=", "logging", ".", "Logger", "\n", "self", ".", "_set_logging_level", "(", "_logging_level", ")", "\n", "self", ".", "_summary", "=", "dict", "(", ")", "\n", "self", ".", "_summary", "[", "\"algm_args\"", "]", "=", "{", "}", "\n", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"init_ka\"", "]", "=", "self", ".", "bm_state", "[", "\"ka\"", "]", "\n", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"init_kb\"", "]", "=", "self", ".", "bm_state", "[", "\"kb\"", "]", "\n", "self", ".", "_summary", "[", "\"na\"", "]", "=", "self", ".", "bm_state", "[", "\"n_a\"", "]", "\n", "self", ".", "_summary", "[", "\"nb\"", "]", "=", "self", ".", "bm_state", "[", "\"n_b\"", "]", "\n", "self", ".", "_summary", "[", "\"e\"", "]", "=", "self", ".", "bm_state", "[", "\"e\"", "]", "\n", "self", ".", "_summary", "[", "\"avg_k\"", "]", "=", "2", "*", "self", ".", "bm_state", "[", "\"e\"", "]", "/", "(", "self", ".", "bm_state", "[", "\"n_a\"", "]", "+", "self", ".", "bm_state", "[", "\"n_b\"", "]", ")", "\n", "\n", "# look-up tables", "\n", "self", ".", "__q_cache_max_e_r", "=", "self", ".", "bm_state", "[", "\"e\"", "]", "if", "self", ".", "bm_state", "[", "\"e\"", "]", "<=", "int", "(", "1e4", ")", "else", "int", "(", "1e4", ")", "\n", "self", ".", "__q_cache", "=", "init_q_cache", "(", "self", ".", "__q_cache_max_e_r", ")", "\n", "\n", "self", ".", "bipartite_prior_", "=", "bipartite_prior", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.minimize_bisbm_dl": [[146, 198], ["optimalks.OptimalKs._prerunning_checks", "optimalks.OptimalKs._compute_dl_and_update", "optimalks.OptimalKs._check_if_local_minimum", "optimalks.OptimalKs._natural_merge", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs.minimize_bisbm_dl", "abs", "optimalks.OptimalKs._merge_e_rs", "optimalks.OptimalKs._determine_i_0", "accept_mb_merge", "assemble_e_rs_from_mb", "optimalks.OptimalKs._update_bm_state", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs.summary", "optimalks.OptimalKs._logger.info"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._prerunning_checks", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._compute_dl_and_update", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._check_if_local_minimum", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._natural_merge", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.minimize_bisbm_dl", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._merge_e_rs", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._determine_i_0", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.accept_mb_merge", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_e_rs_from_mb", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._update_bm_state", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary"], ["", "def", "minimize_bisbm_dl", "(", "self", ",", "bipartite_prior", "=", "True", ")", ":", "\n", "        ", "\"\"\"Fit the bipartite stochastic block model, by minimizing its description length using an agglomerative\n        heuristic.\n\n        Parameters\n        ----------\n        bipartite_prior : ``bool`` (optional, default ``True``)\n\n        Returns\n        -------\n        OptimalKs.bookkeeping_dl : :py:class:`collections.OrderedDict`\n\n        References\n        ----------\n        .. [yen-bipartite-2019] Tzu-Chi Yen and Daniel B. Larremore, \"Blockmodeling a Bipartite Network with Bipartite Priors\", in preparation.\n\n        \"\"\"", "\n", "self", ".", "bipartite_prior_", "=", "bipartite_prior", "\n", "self", ".", "_prerunning_checks", "(", ")", "\n", "\n", "self", ".", "_compute_dl_and_update", "(", "1", ",", "1", ")", "\n", "if", "self", ".", "algm_name_", "==", "\"mcmc\"", "and", "self", ".", "_virgin_run", ":", "\n", "            ", "self", ".", "_natural_merge", "(", ")", "\n", "\n", "", "if", "self", ".", "_check_if_local_minimum", "(", "self", ".", "bm_state", "[", "\"ka\"", "]", ",", "self", ".", "bm_state", "[", "\"kb\"", "]", ")", ":", "\n", "            ", "self", ".", "trace_k", "+=", "[", "(", "\"mdl\"", ",", "self", ".", "bm_state", "[", "\"ka\"", "]", ",", "self", ".", "bm_state", "[", "\"kb\"", "]", ")", "]", "\n", "return", "self", ".", "bookkeeping_dl", "\n", "", "else", ":", "\n", "            ", "dS", "=", "0.", "\n", "while", "abs", "(", "dS", ")", "<", "self", ".", "i_0", "*", "self", ".", "bm_state", "[", "\"ref_dl\"", "]", ":", "\n", "                ", "ka", ",", "kb", "=", "self", ".", "bm_state", "[", "\"ka\"", "]", ",", "self", ".", "bm_state", "[", "\"kb\"", "]", "\n", "self", ".", "trace_k", "+=", "[", "(", "\"merge_or_rollback\"", ",", "ka", ",", "kb", ")", "]", "\n", "if", "ka", "*", "kb", "!=", "1", ":", "\n", "                    ", "ka_", ",", "kb_", ",", "dS", ",", "mlist", "=", "self", ".", "_merge_e_rs", "(", "ka", ",", "kb", ")", "\n", "if", "self", ".", "_determine_i_0", "(", "dS", ")", ":", "\n", "                        ", "ka__", ",", "kb__", ",", "_", "=", "self", ".", "summary", "(", "mode", "=", "\"simple\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "f\"Tried {(ka, kb)} ~~-> {(ka_, kb_)}, \"", "\n", "f\"but *DL{(ka_, kb_)} deviates too much from *DL{(ka__, kb__)}, \"", "\n", "f\"which is {dS}.\"", "\n", ")", "\n", "break", "\n", "", "mb_", "=", "accept_mb_merge", "(", "self", ".", "bm_state", "[", "\"mb\"", "]", ",", "mlist", ")", "\n", "e_rs", "=", "assemble_e_rs_from_mb", "(", "self", ".", "edgelist", ",", "mb_", ")", "\n", "self", ".", "_update_bm_state", "(", "ka_", ",", "kb_", ",", "e_rs", ",", "mb_", ",", "record_merge", "=", "True", ")", "\n", "self", ".", "_logger", ".", "info", "(", "f\"{(ka, kb)} ~~-> {(ka_, kb_)}\"", ")", "\n", "", "else", ":", "\n", "                    ", "break", "\n", "", "", "ka", ",", "kb", "=", "self", ".", "bm_state", "[", "\"ka\"", "]", ",", "self", ".", "bm_state", "[", "\"kb\"", "]", "\n", "self", ".", "trace_k", "+=", "[", "(", "\"escape_to\"", ",", "ka", ",", "kb", ")", "]", "\n", "self", ".", "_logger", ".", "info", "(", "f\"Escape the loop of agglomerative merges. Now {(ka, kb)} looks suspicious.\"", ")", "\n", "return", "self", ".", "minimize_bisbm_dl", "(", "bipartite_prior", "=", "self", ".", "bipartite_prior_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary": [[199, 219], ["optimalks.OptimalKs.summary_dl", "sorted"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary_dl"], ["", "", "def", "summary", "(", "self", ",", "mode", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a summary of the algorithmic outcome.\n\n        Returns\n        -------\n        OptimalKs._summary : ``dict``\n            A summary of the algorithmic outcome with minimal description length (in nats).\n\n        \"\"\"", "\n", "ka", ",", "kb", "=", "sorted", "(", "self", ".", "bookkeeping_dl", ",", "key", "=", "self", ".", "bookkeeping_dl", ".", "get", ")", "[", "0", "]", "\n", "self", ".", "_summary", "[", "\"mdl\"", "]", "=", "self", ".", "bookkeeping_dl", "[", "(", "ka", ",", "kb", ")", "]", "\n", "if", "mode", "==", "\"simple\"", ":", "\n", "            ", "return", "ka", ",", "kb", ",", "self", ".", "_summary", "[", "\"mdl\"", "]", "\n", "\n", "", "self", ".", "_summary", "[", "\"ka\"", "]", "=", "ka", "\n", "self", ".", "_summary", "[", "\"kb\"", "]", "=", "kb", "\n", "self", ".", "_summary", "[", "\"dl\"", "]", "=", "self", ".", "summary_dl", "(", "ka", ",", "kb", ")", "\n", "del", "self", ".", "_summary", "[", "\"dl\"", "]", "[", "\"dl\"", "]", "\n", "\n", "return", "self", ".", "_summary", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary_dl": [[220, 236], ["dict", "assemble_n_r_from_mb", "float", "float", "float", "float", "sum", "adjacency_entropy", "partition_entropy", "degree_entropy", "dict.values", "KeyError", "model_entropy"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_n_r_from_mb", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.adjacency_entropy", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.partition_entropy", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.degree_entropy", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.model_entropy"], ["", "def", "summary_dl", "(", "self", ",", "ka", ",", "kb", ")", ":", "\n", "        ", "_summary", "=", "dict", "(", ")", "\n", "na", ",", "nb", ",", "e", "=", "self", ".", "bm_state", "[", "\"n_a\"", "]", ",", "self", ".", "bm_state", "[", "\"n_b\"", "]", ",", "self", ".", "bm_state", "[", "\"e\"", "]", "\n", "try", ":", "\n", "            ", "mb", "=", "self", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "[", "(", "ka", ",", "kb", ")", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "raise", "KeyError", "(", "f\"Did you compute the partition at {(ka, kb)}?\"", ")", "\n", "", "nr", "=", "assemble_n_r_from_mb", "(", "mb", ")", "\n", "_summary", "[", "\"adjacency\"", "]", "=", "float", "(", "adjacency_entropy", "(", "self", ".", "edgelist", ",", "mb", ")", ")", "\n", "_summary", "[", "\"partition\"", "]", "=", "float", "(", "partition_entropy", "(", "ka", "=", "ka", ",", "kb", "=", "kb", ",", "na", "=", "na", ",", "nb", "=", "nb", ",", "nr", "=", "nr", ")", ")", "\n", "_summary", "[", "\"degree\"", "]", "=", "float", "(", "degree_entropy", "(", "self", ".", "edgelist", ",", "mb", ",", "__q_cache", "=", "self", ".", "__q_cache", ")", ")", "\n", "_summary", "[", "\"edges\"", "]", "=", "float", "(", "\n", "model_entropy", "(", "e", ",", "ka", "=", "ka", ",", "kb", "=", "kb", ",", "na", "=", "na", ",", "nb", "=", "nb", ",", "nr", "=", "nr", ",", "is_bipartite", "=", "self", ".", "bipartite_prior_", ")", "-", "\n", "_summary", "[", "\"partition\"", "]", ")", "\n", "_summary", "[", "\"dl\"", "]", "=", "sum", "(", "_summary", ".", "values", "(", ")", ")", "\n", "return", "_summary", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.compute_and_update": [[237, 254], ["optimalks.OptimalKs._compute_dl_and_update"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._compute_dl_and_update"], ["", "def", "compute_and_update", "(", "self", ",", "ka", ",", "kb", ",", "recompute", "=", "True", ")", ":", "\n", "        ", "\"\"\"Infer the partitions at a specific :math:`(K_a, K_b)` and then update the base class.\n\n        Parameters\n        ----------\n        ka : ``int``\n            Number of type-`a` communities that we want to partition.\n\n        kb : ``int``\n            Number of type-`b` communities that we want to partition.\n\n        recompute : ``bool`` (optional, default: ``True``)\n\n        \"\"\"", "\n", "if", "recompute", ":", "\n", "            ", "self", ".", "bookkeeping_dl", "[", "(", "ka", ",", "kb", ")", "]", "=", "0", "\n", "", "self", ".", "_compute_dl_and_update", "(", "ka", ",", "kb", ",", "recompute", "=", "recompute", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.compute_dl": [[255, 333], ["min", "np.array", "optimalks.OptimalKs._compute_desc_len", "np.sqrt", "optimalks.OptimalKs.engine_", "list", "range", "optimalks.OptimalKs._compute_desc_len", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs._logger.info", "loky_executor", "np.sqrt", "list", "optimalks.OptimalKs.compute_dl.run"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._compute_desc_len", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._compute_desc_len", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.loky_executor"], ["", "def", "compute_dl", "(", "self", ",", "ka", ",", "kb", ",", "recompute", "=", "False", ")", ":", "\n", "        ", "\"\"\"Execute the partitioning code by spawning child processes in the shell; saves its output afterwards.\n\n        Parameters\n        ----------\n        ka : ``int``\n            Number of type-`a` communities that we want to partition.\n\n        kb : ``int``\n            Number of type-`b` communities that we want to partition.\n\n        recompute : ``bool`` (optional, default: ``False``)\n            TODO.\n\n        Returns\n        -------\n        dl : ``float``\n            The description length of the partition found.\n\n        e_rs : :class:`numpy.ndarray`\n            the affinity matrix via the group membership vector found by the partitioning engine\n\n        mb : ``list[int]``\n            group membership vector calculated by the partitioning engine\n\n        \"\"\"", "\n", "# each time when you calculate/search at particular ka and kb", "\n", "# the hood records relevant information for research", "\n", "try", ":", "\n", "            ", "self", ".", "bookkeeping_dl", "[", "(", "ka", ",", "kb", ")", "]", "\n", "", "except", "KeyError", "as", "_", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "bookkeeping_dl", "[", "(", "ka", ",", "kb", ")", "]", ">", "0", ":", "\n", "                ", "_", "=", "ka", ",", "kb", "\n", "return", "self", ".", "bookkeeping_dl", "[", "_", "]", ",", "self", ".", "bookkeeping_e_rs", "[", "_", "]", ",", "self", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "[", "_", "]", "\n", "", "", "na", ",", "nb", ",", "e", "=", "self", ".", "bm_state", "[", "\"n_a\"", "]", ",", "self", ".", "bm_state", "[", "\"n_b\"", "]", ",", "self", ".", "bm_state", "[", "\"e\"", "]", "\n", "if", "ka", "==", "1", "and", "kb", "==", "1", ":", "\n", "            ", "mb", "=", "np", ".", "array", "(", "[", "0", "]", "*", "na", "+", "[", "1", "]", "*", "nb", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "res", "=", "self", ".", "_compute_desc_len", "(", "na", ",", "nb", ",", "e", ",", "ka", ",", "kb", ",", "mb", ")", "\n", "return", "res", "[", "0", "]", ",", "res", "[", "1", "]", ",", "res", "[", "2", "]", "\n", "\n", "", "if", "not", "recompute", ":", "\n", "            ", "ka_", "=", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"init_ka\"", "]", "\n", "kb_", "=", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"init_kb\"", "]", "\n", "na", "=", "self", ".", "_summary", "[", "\"na\"", "]", "\n", "nb", "=", "self", ".", "_summary", "[", "\"nb\"", "]", "\n", "dist", "=", "np", ".", "sqrt", "(", "(", "ka_", "-", "ka", ")", "**", "2", "+", "(", "kb_", "-", "kb", ")", "**", "2", ")", "\n", "if", "dist", "<=", "self", ".", "_k_th_nb_to_search", "*", "np", ".", "sqrt", "(", "2", ")", ":", "\n", "                ", "self", ".", "_logger", ".", "info", "(", "f\"({na}, {nb}) ~~-> ({ka}, {kb}); Use that partition to start MCMC@({ka}, {kb}).\"", ")", "\n", "_mb", "=", "None", "\n", "", "else", ":", "\n", "                ", "self", ".", "_logger", ".", "info", "(", "f\"({ka_}, {kb_}) ~~-> ({ka}, {kb}); Use that partition to start MCMC@({ka}, {kb}).\"", ")", "\n", "_mb", "=", "self", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "[", "(", "ka_", ",", "kb_", ")", "]", "\n", "", "", "else", ":", "\n", "            ", "_mb", "=", "None", "\n", "\n", "", "def", "run", "(", "a", ",", "b", ")", ":", "\n", "            ", "return", "self", ".", "engine_", "(", "self", ".", "_f_edgelist_name", ",", "na", ",", "nb", ",", "a", ",", "b", ",", "mb", "=", "_mb", ")", "\n", "\n", "# Calculate the biSBM inference several times,", "\n", "# choose the maximum likelihood (or minimum entropy) result.", "\n", "", "results", "=", "[", "]", "\n", "if", "self", ".", "is_par_", ":", "\n", "# automatically shutdown after idling for 600s", "\n", "            ", "self", ".", "__del__no_call", "=", "True", "\n", "results", "=", "list", "(", "loky_executor", "(", "self", ".", "n_cores_", ",", "600", ",", "lambda", "x", ":", "run", "(", "ka", ",", "kb", ")", ",", "list", "(", "range", "(", "self", ".", "max_n_sweeps_", ")", ")", ")", ")", "\n", "self", ".", "__del__no_call", "=", "False", "\n", "", "else", ":", "\n", "            ", "for", "_", "in", "range", "(", "self", ".", "max_n_sweeps_", ")", ":", "\n", "                ", "results", "+=", "[", "run", "(", "ka", ",", "kb", ")", "]", "\n", "\n", "", "", "result_", "=", "[", "self", ".", "_compute_desc_len", "(", "na", ",", "nb", ",", "e", ",", "ka", ",", "kb", ",", "r", ")", "for", "r", "in", "results", "]", "\n", "result", "=", "min", "(", "result_", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", "\n", "dl", "=", "result", "[", "0", "]", "\n", "e_rs", "=", "result", "[", "1", "]", "\n", "mb", "=", "result", "[", "2", "]", "\n", "return", "dl", ",", "e_rs", ",", "mb", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.natural_merge": [[334, 359], ["min", "optimalks.OptimalKs.engine_", "list", "range", "optimalks.OptimalKs._compute_desc_len", "loky_executor", "list", "optimalks.OptimalKs.compute_dl.run"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._compute_desc_len", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.loky_executor"], ["", "def", "natural_merge", "(", "self", ")", ":", "\n", "        ", "\"\"\"Phase 1 natural e_rs-block merge\"\"\"", "\n", "na", ",", "nb", ",", "e", "=", "self", ".", "bm_state", "[", "\"n_a\"", "]", ",", "self", ".", "bm_state", "[", "\"n_b\"", "]", ",", "self", ".", "bm_state", "[", "\"e\"", "]", "\n", "\n", "def", "run", "(", "_", ")", ":", "\n", "# Note: setting (ka, kb) = (1, 1) is redundant.", "\n", "            ", "return", "self", ".", "engine_", "(", "self", ".", "_f_edgelist_name", ",", "na", ",", "nb", ",", "1", ",", "1", ",", "mb", "=", "None", ",", "method", "=", "\"natural\"", ")", "\n", "\n", "", "results", "=", "[", "]", "\n", "if", "self", ".", "is_par_", ":", "\n", "# automatically shutdown after idling for 600s", "\n", "            ", "self", ".", "__del__no_call", "=", "True", "\n", "results", "=", "list", "(", "loky_executor", "(", "self", ".", "n_cores_", ",", "600", ",", "lambda", "x", ":", "run", "(", "0", ")", ",", "list", "(", "range", "(", "self", ".", "max_n_sweeps_", ")", ")", ")", ")", "\n", "self", ".", "__del__no_call", "=", "False", "\n", "", "else", ":", "\n", "            ", "for", "_", "in", "range", "(", "self", ".", "max_n_sweeps_", ")", ":", "\n", "                ", "results", "+=", "[", "run", "(", "0", ")", "]", "\n", "\n", "", "", "result_", "=", "[", "self", ".", "_compute_desc_len", "(", "na", ",", "nb", ",", "e", ",", "r", "[", "0", "]", ",", "r", "[", "1", "]", ",", "r", "[", "2", ":", "]", ")", "for", "r", "in", "results", "]", "\n", "result", "=", "min", "(", "result_", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", "\n", "dl", "=", "result", "[", "0", "]", "\n", "e_rs", "=", "result", "[", "1", "]", "\n", "mb", "=", "result", "[", "2", "]", "\n", "ka", ",", "kb", "=", "result", "[", "3", "]", "\n", "return", "dl", ",", "e_rs", ",", "mb", ",", "ka", ",", "kb", ",", "na", ",", "nb", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._natural_merge": [[360, 373], ["optimalks.OptimalKs.natural_merge", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs._set_bookkeeping_mb_search_order", "optimalks.OptimalKs._update_bm_state", "max", "max"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.natural_merge", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._set_bookkeeping_mb_search_order", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._update_bm_state"], ["", "def", "_natural_merge", "(", "self", ")", ":", "\n", "        ", "dl", ",", "e_rs", ",", "mb", ",", "ka", ",", "kb", ",", "na", ",", "nb", "=", "self", ".", "natural_merge", "(", ")", "\n", "assert", "max", "(", "mb", ")", "+", "1", "==", "ka", "+", "kb", ",", "\"[ERROR] inconsistency between mb. indexes and #blocks. {} != {}\"", ".", "format", "(", "\n", "max", "(", "mb", ")", "+", "1", ",", "ka", "+", "kb", ")", "\n", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"init_ka\"", "]", "=", "ka", "\n", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"init_kb\"", "]", "=", "kb", "\n", "self", ".", "_logger", ".", "info", "(", "f\"Natural agglomerative merge {(na, nb)} ~~-> {(ka, kb)}.\"", ")", "\n", "self", ".", "bookkeeping_dl", "[", "(", "ka", ",", "kb", ")", "]", "=", "dl", "\n", "self", ".", "bookkeeping_e_rs", "[", "(", "ka", ",", "kb", ")", "]", "=", "e_rs", "\n", "self", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "[", "(", "ka", ",", "kb", ")", "]", "=", "mb", "\n", "self", ".", "_set_bookkeeping_mb_search_order", "(", "ka", ",", "kb", ")", "\n", "self", ".", "_update_bm_state", "(", "ka", ",", "kb", ",", "e_rs", ",", "mb", ")", "\n", "self", ".", "_virgin_run", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._determine_i_0": [[374, 387], ["np.percentile", "np.percentile", "optimalks.OptimalKs._logger.info", "np.percentile"], "methods", ["None"], ["", "def", "_determine_i_0", "(", "self", ",", "dS", ")", ":", "\n", "        ", "if", "self", ".", "i_0", "<", "1", ":", "\n", "            ", "return", "False", "\n", "", "i_0", "=", "dS", "/", "self", ".", "bm_state", "[", "\"ref_dl\"", "]", "\n", "self", ".", "i_0s", "+=", "[", "i_0", "]", "\n", "iqr", "=", "np", ".", "percentile", "(", "self", ".", "i_0s", ",", "75", ")", "-", "np", ".", "percentile", "(", "self", ".", "i_0s", ",", "25", ")", "\n", "if", "i_0", ">", "self", ".", "_c", "*", "iqr", "+", "np", ".", "percentile", "(", "self", ".", "i_0s", ",", "75", ")", ">=", "1e-4", ":", "\n", "            ", "self", ".", "i_0", "=", "i_0", "\n", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"i_0\"", "]", "=", "i_0", "\n", "self", ".", "_logger", ".", "info", "(", "f\"Determining \\u0394 at {i_0}.\"", ")", "# \\u0394 = Delta = i_0", "\n", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._compute_desc_len": [[388, 394], ["assemble_e_rs_from_mb", "assemble_n_r_from_mb", "get_desc_len_from_data"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_e_rs_from_mb", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_n_r_from_mb", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.get_desc_len_from_data"], ["", "", "def", "_compute_desc_len", "(", "self", ",", "n_a", ",", "n_b", ",", "e", ",", "ka", ",", "kb", ",", "mb", ")", ":", "\n", "        ", "e_rs", "=", "assemble_e_rs_from_mb", "(", "self", ".", "edgelist", ",", "mb", ")", "\n", "nr", "=", "assemble_n_r_from_mb", "(", "mb", ")", "\n", "desc_len", "=", "get_desc_len_from_data", "(", "n_a", ",", "n_b", ",", "e", ",", "ka", ",", "kb", ",", "self", ".", "edgelist", ",", "mb", ",", "nr", "=", "nr", ",", "q_cache", "=", "self", ".", "__q_cache", ",", "\n", "is_bipartite", "=", "self", ".", "bipartite_prior_", ")", "\n", "return", "desc_len", ",", "e_rs", ",", "mb", ",", "(", "ka", ",", "kb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._merge_e_rs": [[395, 441], ["np.arange", "set", "virtual_moves_ds", "len", "np.max", "random.choices", "min", "max", "set.add", "str", "str"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.virtual_moves_ds"], ["", "def", "_merge_e_rs", "(", "self", ",", "ka", ",", "kb", ")", ":", "\n", "        ", "\"\"\"Apply multiple merges of the original affinity matrix, return the one that least alters the entropy\n\n        Parameters\n        ----------\n        ka : ``int``\n            Number of type-a communities in the affinity matrix\n        kb : ``int``\n            Number of type-b communities in the affinity matrix\n\n        Returns\n        -------\n        _ka : ``int``\n            New number of type-a communities in the affinity matrix\n\n        _kb : ``int``\n            New number of type-b communities in the affinity matrix\n\n        dS : ``list(int, int)``\n            Difference of the new entropy and the old one\n\n        _mlist : ``list(int, int)``\n            The two row-indexes of the original affinity matrix that were finally chosen (and merged)\n\n        \"\"\"", "\n", "m", "=", "np", ".", "arange", "(", "ka", "+", "kb", ")", "\n", "\n", "mlists", "=", "set", "(", ")", "\n", "while", "len", "(", "mlists", ")", "==", "0", ":", "\n", "            ", "for", "_m", "in", "m", ":", "\n", "                ", "pool", "=", "random", ".", "choices", "(", "m", ",", "k", "=", "self", ".", "_nm", ")", "\n", "_mlist", "=", "[", "[", "min", "(", "x", ",", "_m", ")", ",", "max", "(", "x", ",", "_m", ")", "]", "for", "x", "in", "pool", "]", "\n", "for", "_", "in", "_mlist", ":", "\n", "                    ", "cond", "=", "(", "_", "[", "0", "]", "!=", "_", "[", "1", "]", ")", "and", "not", "(", "_", "[", "1", "]", ">=", "ka", ">", "_", "[", "0", "]", ")", "and", "not", "(", "_", "[", "0", "]", "==", "0", "and", "ka", "==", "1", ")", "and", "not", "(", "\n", "_", "[", "0", "]", "==", "ka", "and", "kb", "==", "1", ")", "\n", "if", "cond", ":", "\n", "                        ", "mlists", ".", "add", "(", "str", "(", "_", "[", "0", "]", ")", "+", "\"+\"", "+", "str", "(", "_", "[", "1", "]", ")", ")", "\n", "\n", "", "", "", "", "dS", ",", "_mlist", "=", "virtual_moves_ds", "(", "self", ".", "bm_state", "[", "\"e_rs\"", "]", ",", "mlists", ",", "self", ".", "bm_state", "[", "\"ka\"", "]", ")", "\n", "if", "np", ".", "max", "(", "_mlist", ")", "<", "self", ".", "bm_state", "[", "\"ka\"", "]", ":", "\n", "            ", "ka", "=", "self", ".", "bm_state", "[", "\"ka\"", "]", "-", "1", "\n", "kb", "=", "self", ".", "bm_state", "[", "\"kb\"", "]", "\n", "", "else", ":", "\n", "            ", "ka", "=", "self", ".", "bm_state", "[", "\"ka\"", "]", "\n", "kb", "=", "self", ".", "bm_state", "[", "\"kb\"", "]", "-", "1", "\n", "", "return", "ka", ",", "kb", ",", "dS", ",", "_mlist", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._rollback": [[442, 448], ["optimalks.OptimalKs.summary", "optimalks.OptimalKs._update_bm_state"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._update_bm_state"], ["", "def", "_rollback", "(", "self", ")", ":", "\n", "        ", "ka", ",", "kb", ",", "dl", "=", "self", ".", "summary", "(", "mode", "=", "\"simple\"", ")", "\n", "e_rs", "=", "self", ".", "bookkeeping_e_rs", "[", "(", "ka", ",", "kb", ")", "]", "\n", "mb", "=", "self", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "[", "(", "ka", ",", "kb", ")", "]", "\n", "self", ".", "_update_bm_state", "(", "ka", ",", "kb", ",", "e_rs", ",", "mb", ")", "\n", "return", "ka", ",", "kb", ",", "e_rs", ",", "dl", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._update_bm_state": [[449, 456], ["optimalks.OptimalKs._set_bookkeeping_mb_search_order"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._set_bookkeeping_mb_search_order"], ["", "def", "_update_bm_state", "(", "self", ",", "ka", ",", "kb", ",", "e_rs", ",", "mb", ",", "record_merge", "=", "False", ")", ":", "\n", "        ", "self", ".", "bm_state", "[", "\"ka\"", "]", ",", "self", ".", "bm_state", "[", "\"kb\"", "]", "=", "ka", ",", "kb", "\n", "self", ".", "bm_state", "[", "\"e_rs\"", "]", "=", "e_rs", "\n", "self", ".", "bm_state", "[", "\"mb\"", "]", "=", "mb", "\n", "if", "record_merge", ":", "\n", "            ", "self", ".", "bookkeeping_mb", "[", "\"merge\"", "]", "[", "(", "ka", ",", "kb", ")", "]", "=", "mb", "\n", "self", ".", "_set_bookkeeping_mb_search_order", "(", "ka", ",", "kb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._compute_dl_and_update": [[457, 468], ["optimalks.OptimalKs.compute_dl", "optimalks.OptimalKs._set_bookkeeping_mb_search_order", "max", "max", "optimalks.OptimalKs.summary"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.compute_dl", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._set_bookkeeping_mb_search_order", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary"], ["", "", "def", "_compute_dl_and_update", "(", "self", ",", "ka", ",", "kb", ",", "recompute", "=", "False", ")", ":", "\n", "        ", "dl", ",", "e_rs", ",", "mb", "=", "self", ".", "compute_dl", "(", "ka", ",", "kb", ",", "recompute", "=", "recompute", ")", "\n", "assert", "max", "(", "mb", ")", "+", "1", "==", "ka", "+", "kb", ",", "\"[ERROR] inconsistency between mb. indexes and #blocks. {} != {}\"", ".", "format", "(", "\n", "max", "(", "mb", ")", "+", "1", ",", "ka", "+", "kb", ")", "\n", "self", ".", "bookkeeping_dl", "[", "(", "ka", ",", "kb", ")", "]", "=", "dl", "\n", "self", ".", "bookkeeping_e_rs", "[", "(", "ka", ",", "kb", ")", "]", "=", "e_rs", "\n", "self", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "[", "(", "ka", ",", "kb", ")", "]", "=", "mb", "\n", "self", ".", "_set_bookkeeping_mb_search_order", "(", "ka", ",", "kb", ")", "\n", "self", ".", "trace_k", "+=", "[", "(", "\"mcmc\"", ",", "ka", ",", "kb", ")", "]", "\n", "self", ".", "bm_state", "[", "\"ref_dl\"", "]", "=", "self", ".", "summary", "(", "mode", "=", "\"simple\"", ")", "[", "2", "]", "if", "self", ".", "bm_state", "[", "\"ref_dl\"", "]", "!=", "0", "else", "dl", "\n", "return", "dl", ",", "e_rs", ",", "mb", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._is_mdl_so_far": [[472, 475], ["any", "optimalks.OptimalKs.bookkeeping_dl.values"], "methods", ["None"], ["", "def", "_is_mdl_so_far", "(", "self", ",", "desc_len", ")", ":", "\n", "        ", "\"\"\"Check if `desc_len` is the minimal value so far.\"\"\"", "\n", "return", "not", "any", "(", "[", "i", "<", "desc_len", "for", "i", "in", "self", ".", "bookkeeping_dl", ".", "values", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._check_if_local_minimum": [[476, 510], ["optimalks.OptimalKs._logger.info", "optimalks.OptimalKs._compute_dl_and_update", "optimalks.OptimalKs._get_neighbor_points", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs._update_bm_state", "optimalks.OptimalKs._rollback", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs._compute_dl_and_update", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs.summary", "optimalks.OptimalKs._is_mdl_so_far", "optimalks.OptimalKs._rollback", "optimalks.OptimalKs._logger.info", "optimalks.OptimalKs.summary"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._compute_dl_and_update", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._get_neighbor_points", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._update_bm_state", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._rollback", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._compute_dl_and_update", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._is_mdl_so_far", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._rollback", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary"], ["", "def", "_check_if_local_minimum", "(", "self", ",", "ka", ",", "kb", ")", ":", "\n", "        ", "\"\"\"The `neighborhood search` as described in the paper.\"\"\"", "\n", "self", ".", "_logger", ".", "info", "(", "f\"Is {(ka, kb)} a local minimum? Let's check.\"", ")", "\n", "_dl", ",", "_e_rs", ",", "_mb", "=", "self", ".", "_compute_dl_and_update", "(", "ka", ",", "kb", ")", "\n", "null_dl", "=", "self", ".", "bookkeeping_dl", "[", "(", "1", ",", "1", ")", "]", "\n", "if", "_dl", ">", "null_dl", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"DL({}, {}) > DL(1, 1), which is {} compared to {}\"", ".", "format", "(", "ka", ",", "kb", ",", "_dl", ",", "null_dl", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "f\"~~~- Keep merging -~~~\"", ")", "\n", "self", ".", "_update_bm_state", "(", "ka", ",", "kb", ",", "_e_rs", ",", "_mb", ")", "\n", "return", "False", "\n", "\n", "", "if", "_dl", ">", "self", ".", "summary", "(", "mode", "=", "\"simple\"", ")", "[", "2", "]", ":", "\n", "            ", "ka", ",", "kb", ",", "_", ",", "_dl", "=", "self", ".", "_rollback", "(", ")", "\n", "self", ".", "i_0", "*=", "self", ".", "adaptive_ratio", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "f\"Overshooting! There's already a point with lower DL. Let's reduce \\u0394 by {self.adaptive_ratio}.\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "f\"Move to {(ka, kb)} and re-checking if it is a local minimum.\"", ")", "\n", "\n", "", "nb_points", "=", "self", ".", "_get_neighbor_points", "(", "ka", ",", "kb", ")", "\n", "\n", "for", "_ka", ",", "_kb", "in", "nb_points", ":", "\n", "            ", "self", ".", "_compute_dl_and_update", "(", "_ka", ",", "_kb", ")", "\n", "if", "not", "self", ".", "_is_mdl_so_far", "(", "_dl", ")", ":", "\n", "                ", "_", ",", "_", ",", "_", ",", "mdl", "=", "self", ".", "_rollback", "(", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "f\"Warning. DL{(_ka, _kb)} = {mdl} < DL{(ka, kb)}. We move to {(_ka, _kb)} but NOT reduce \\u0394.\"", ")", "\n", "break", "\n", "\n", "", "", "if", "_dl", "!=", "self", ".", "summary", "(", "mode", "=", "\"simple\"", ")", "[", "2", "]", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "f\"Bummer. {(ka, kb)} is NOT a local minimum.\"", ")", "\n", "return", "False", "\n", "", "else", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "f\"YES! {(ka, kb)} is a local minimum with DL = {_dl}. We are done.\"", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._get_neighbor_points": [[511, 523], ["sorted", "random.shuffle", "sorted.pop", "sorted.pop", "product", "range"], "methods", ["None"], ["", "", "def", "_get_neighbor_points", "(", "self", ",", "ka", ",", "kb", ")", ":", "\n", "        ", "k_th", "=", "self", ".", "_k_th_nb_to_search", "\n", "nb_points", "=", "[", "(", "x", "+", "ka", ",", "y", "+", "kb", ")", "for", "(", "x", ",", "y", ")", "in", "product", "(", "range", "(", "-", "k_th", ",", "k_th", "+", "1", ")", ",", "repeat", "=", "2", ")", "]", "\n", "# if any item has values less than 1, delete it. Also, exclude the suspected point (i.e., [ka, kb]).", "\n", "na", "=", "self", ".", "bm_state", "[", "\"n_a\"", "]", "\n", "nb", "=", "self", ".", "bm_state", "[", "\"n_b\"", "]", "\n", "nb_points", "=", "[", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "nb_points", "if", "na", ">=", "i", ">=", "1", "and", "nb", ">=", "j", ">=", "1", "and", "(", "i", ",", "j", ")", "!=", "(", "ka", ",", "kb", ")", "]", "\n", "_", "=", "sorted", "(", "nb_points", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", "-", "ka", "+", "x", "[", "1", "]", "-", "kb", ",", "reverse", "=", "True", ")", "\n", "nb_points", "=", "[", "_", ".", "pop", "(", "0", ")", ",", "_", ".", "pop", "(", "-", "1", ")", "]", "\n", "random", ".", "shuffle", "(", "_", ")", "\n", "nb_points", "+=", "_", "\n", "return", "nb_points", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._prerunning_checks": [[524, 539], ["AttributeError", "AttributeError", "AttributeError", "AttributeError"], "methods", ["None"], ["", "def", "_prerunning_checks", "(", "self", ")", ":", "\n", "        ", "assert", "self", ".", "bm_state", "[", "\"n_a\"", "]", ">", "0", ",", "\"[ERROR] Number of type-a nodes = 0, which is not allowed\"", "\n", "assert", "self", ".", "bm_state", "[", "\"n_b\"", "]", ">", "0", ",", "\"[ERROR] Number of type-b nodes = 0, which is not allowed\"", "\n", "assert", "self", ".", "bm_state", "[", "\"n\"", "]", "==", "self", ".", "bm_state", "[", "\"n_a\"", "]", "+", "self", ".", "bm_state", "[", "\"n_b\"", "]", ",", "\"[ERROR] num_nodes ({}) does not equal to num_nodes_a ({}) plus num_nodes_b ({})\"", ".", "format", "(", "\n", "self", ".", "bm_state", "[", "\"n\"", "]", ",", "self", ".", "bm_state", "[", "\"n_a\"", "]", ",", "self", ".", "bm_state", "[", "\"n_b\"", "]", "\n", ")", "\n", "if", "self", ".", "bm_state", "[", "\"ka\"", "]", "is", "None", "or", "self", ".", "bm_state", "[", "\"kb\"", "]", "is", "None", "or", "self", ".", "i_0", "is", "None", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Arguments missing! Please assign `init_ka`, `init_kb`, and `i_0`.\"", ")", "\n", "", "if", "self", ".", "adaptive_ratio", "is", "None", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Arguments missing! Please assign `adaptive_ratio`.\"", ")", "\n", "", "if", "self", ".", "_k_th_nb_to_search", "is", "None", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Arguments missing! Please assign `k_th_nb_to_search`.\"", ")", "\n", "", "if", "self", ".", "_nm", "is", "None", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Arguments missing! Please assign `size_rows_to_run`.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._set_bookkeeping_mb_search_order": [[540, 548], ["len", "len", "len"], "methods", ["None"], ["", "", "def", "_set_bookkeeping_mb_search_order", "(", "self", ",", "ka", ",", "kb", ")", ":", "\n", "        ", "order", "=", "len", "(", "self", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", ")", "+", "len", "(", "self", ".", "bookkeeping_mb", "[", "\"merge\"", "]", ")", "\n", "try", ":", "\n", "            ", "len", "(", "self", ".", "bookkeeping_mb", "[", "\"order\"", "]", "[", "(", "ka", ",", "kb", ")", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "self", ".", "bookkeeping_mb", "[", "\"order\"", "]", "[", "(", "ka", ",", "kb", ")", "]", "=", "[", "order", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "bookkeeping_mb", "[", "\"order\"", "]", "[", "(", "ka", ",", "kb", ")", "]", "+=", "[", "order", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.set_params": [[552, 585], ["int", "int", "float", "float"], "methods", ["None"], ["", "", "def", "set_params", "(", "self", ",", "init_ka", "=", "10", ",", "init_kb", "=", "10", ",", "i_0", "=", "0.005", ")", ":", "\n", "        ", "\"\"\"Set the parameters for the heuristic.\n\n        Parameters\n        ----------\n        init_ka : ``int`` (required, default: ``10``)\n\n        init_kb : ``int`` (required, default: ``10``)\n\n        i_0 : ``float`` (required, default: ``0.005``)\n\n        Notes\n        -----\n        TODO.\n\n        .. warning::\n\n           If :math:`i_0` is set too small, the heuristic will be slow and tends to get trapped in\n           a local minimum (in the description length landscape) where :math:`K_a` and :math:`K_b` are large.\n\n        \"\"\"", "\n", "# params for the heuristic", "\n", "self", ".", "bm_state", "[", "\"ka\"", "]", "=", "int", "(", "init_ka", ")", "\n", "self", ".", "bm_state", "[", "\"kb\"", "]", "=", "int", "(", "init_kb", ")", "\n", "self", ".", "i_0", "=", "float", "(", "i_0", ")", "\n", "assert", "0.", "<=", "self", ".", "i_0", "<", "1", ",", "\"[ERROR] Allowed range for i_0 is [0, 1).\"", "\n", "assert", "self", ".", "bm_state", "[", "\"ka\"", "]", "<=", "self", ".", "bm_state", "[", "\n", "\"n_a\"", "]", ",", "\"[ERROR] Number of type-a communities must be smaller than the # nodes in type-a.\"", "\n", "assert", "self", ".", "bm_state", "[", "\"kb\"", "]", "<=", "self", ".", "bm_state", "[", "\n", "\"n_b\"", "]", ",", "\"[ERROR] Number of type-b communities must be smaller than the # nodes in type-b.\"", "\n", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"init_ka\"", "]", "=", "self", ".", "bm_state", "[", "\"ka\"", "]", "\n", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"init_kb\"", "]", "=", "self", ".", "bm_state", "[", "\"kb\"", "]", "\n", "self", ".", "_summary", "[", "\"algm_args\"", "]", "[", "\"i_0\"", "]", "=", "float", "(", "i_0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.set_adaptive_ratio": [[586, 590], ["float"], "methods", ["None"], ["", "def", "set_adaptive_ratio", "(", "self", ",", "adaptive_ratio", "=", "0.95", ")", ":", "\n", "        ", "\"\"\"Set the adaptive ratio (``float`` between 0 to 1, defaults to ``0.95``).\"\"\"", "\n", "assert", "0.", "<", "adaptive_ratio", "<", "1", ",", "\"[ERROR] Allowed range for adaptive_ratio is (0, 1).\"", "\n", "self", ".", "adaptive_ratio", "=", "float", "(", "adaptive_ratio", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.set_k_th_neighbor_to_search": [[591, 593], ["int"], "methods", ["None"], ["", "def", "set_k_th_neighbor_to_search", "(", "self", ",", "k", ")", ":", "\n", "        ", "self", ".", "_k_th_nb_to_search", "=", "int", "(", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.set_c": [[594, 596], ["None"], "methods", ["None"], ["", "def", "set_c", "(", "self", ",", "c", ")", ":", "\n", "        ", "self", ".", "_c", "=", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.set_nm": [[597, 600], ["int"], "methods", ["None"], ["", "def", "set_nm", "(", "self", ",", "s", "=", "10", ")", ":", "\n", "        ", "\"\"\"Set the :math:`n_m` parameter (defaults to ``10``).\"\"\"", "\n", "self", ".", "_nm", "=", "int", "(", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.get_f_edgelist_name": [[601, 603], ["None"], "methods", ["None"], ["", "def", "get_f_edgelist_name", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_f_edgelist_name", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.get__q_cache": [[604, 606], ["None"], "methods", ["None"], ["", "def", "get__q_cache", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__q_cache", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._set_logging_level": [[607, 618], ["logging.basicConfig", "logging.getLogger", "level.upper", "level.upper"], "methods", ["None"], ["", "def", "_set_logging_level", "(", "self", ",", "level", ")", ":", "\n", "        ", "_level", "=", "0", "\n", "if", "level", ".", "upper", "(", ")", "==", "\"INFO\"", ":", "\n", "            ", "_level", "=", "logging", ".", "INFO", "\n", "", "elif", "level", ".", "upper", "(", ")", "==", "\"WARNING\"", ":", "\n", "            ", "_level", "=", "logging", ".", "WARNING", "\n", "", "logging", ".", "basicConfig", "(", "\n", "level", "=", "_level", ",", "\n", "format", "=", "\"%(asctime)s:%(levelname)s:%(message)s\"", "\n", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs._get_tempfile_edgelist": [[619, 637], ["optimalks.OptimalKs.f_edgelist.seek", "optimalks.OptimalKs.f_edgelist.flush", "tempfile.NamedTemporaryFile", "optimalks.OptimalKs.f_edgelist.write", "content.encode", "str", "str"], "methods", ["None"], ["", "def", "_get_tempfile_edgelist", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "self", ".", "f_edgelist", ".", "seek", "(", "0", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "if", "self", ".", "is_par_", ":", "\n", "                ", "delete", "=", "False", "\n", "", "else", ":", "\n", "                ", "delete", "=", "True", "\n", "", "self", ".", "f_edgelist", "=", "tempfile", ".", "NamedTemporaryFile", "(", "mode", "=", "'wb'", ",", "dir", "=", "self", ".", "tempdir", ",", "delete", "=", "delete", ")", "\n", "", "finally", ":", "\n", "            ", "for", "edge", "in", "self", ".", "edgelist", ":", "\n", "                ", "content", "=", "str", "(", "edge", "[", "0", "]", ")", "+", "\"\\t\"", "+", "str", "(", "edge", "[", "1", "]", ")", "+", "\"\\n\"", "\n", "self", ".", "f_edgelist", ".", "write", "(", "content", ".", "encode", "(", ")", ")", "\n", "", "self", ".", "f_edgelist", ".", "flush", "(", ")", "\n", "f_edgelist_name", "=", "self", ".", "f_edgelist", ".", "name", "\n", "", "if", "self", ".", "is_par_", ":", "\n", "            ", "del", "self", ".", "f_edgelist", "\n", "", "return", "f_edgelist_name", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.__del__": [[638, 643], ["os.remove"], "methods", ["None"], ["", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "__del__no_call", ":", "\n", "            ", "return", "\n", "", "if", "self", ".", "is_par_", ":", "\n", "            ", "os", ".", "remove", "(", "self", ".", "_f_edgelist_name", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.log_q": [[26, 50], ["int", "int", "int_part.log_q_approx"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.log_q_approx"], ["def", "log_q", "(", "n", ",", "k", ",", "__q_cache", ")", ":", "\n", "    ", "\"\"\"log_q\n\n    Parameters\n    ----------\n    n : ``int``\n\n    k : ``int``\n\n    __q_cache : :class:`numpy.ndarray`\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "n", "=", "int", "(", "n", ")", "\n", "k", "=", "int", "(", "k", ")", "\n", "if", "n", "<=", "0", "or", "k", "<", "1", ":", "\n", "        ", "return", "0", "\n", "", "if", "k", ">", "n", ":", "\n", "        ", "k", "=", "n", "\n", "", "if", "n", "<", "__q_cache", ".", "shape", "[", "0", "]", ":", "\n", "        ", "return", "__q_cache", "[", "n", "]", "[", "k", "]", "\n", "", "return", "log_q_approx", "(", "n", ",", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.get_v": [[52, 72], ["abs", "numpy.sqrt", "scipy.special.spence", "numpy.exp"], "function", ["None"], ["", "def", "get_v", "(", "u", ",", "epsilon", "=", "1e-8", ")", ":", "\n", "    ", "\"\"\"get_v\n\n    Parameters\n    ----------\n    u : ``int``\n\n    epsilon : ``float``\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "v", "=", "u", "\n", "delta", "=", "1", "\n", "while", "delta", ">", "epsilon", ":", "\n", "        ", "n_v", "=", "u", "*", "np", ".", "sqrt", "(", "spence", "(", "np", ".", "exp", "(", "-", "v", ")", ")", ")", "\n", "delta", "=", "abs", "(", "n_v", "-", "v", ")", "\n", "v", "=", "n_v", "\n", "", "return", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.log_q_approx_small": [[74, 87], ["int_part.lbinom", "scipy.special.loggamma"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.lbinom"], ["", "def", "log_q_approx_small", "(", "n", ",", "k", ")", ":", "\n", "    ", "\"\"\"log_q_approx_small\n\n    Parameters\n    ----------\n    n : ``int``\n    k : ``int``\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "return", "lbinom", "(", "n", "-", "1", ",", "k", "-", "1", ")", "-", "loggamma", "(", "k", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.log_q_approx": [[89, 108], ["int_part.get_v", "pow", "int_part.log_q_approx_small", "numpy.sqrt", "numpy.log", "numpy.log", "numpy.log1p", "numpy.log", "numpy.sqrt", "numpy.log", "numpy.exp", "numpy.log1p", "numpy.log", "numpy.exp"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.get_v", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.log_q_approx_small"], ["", "def", "log_q_approx", "(", "n", ",", "k", ")", ":", "\n", "    ", "\"\"\"log_q_approx\n\n    Parameters\n    ----------\n    n : ``int``\n    k : ``int``\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "if", "k", "<", "pow", "(", "n", ",", "1", "/", "4.", ")", ":", "\n", "        ", "return", "log_q_approx_small", "(", "n", ",", "k", ")", "\n", "", "u", "=", "k", "/", "np", ".", "sqrt", "(", "n", ")", "\n", "v", "=", "get_v", "(", "u", ")", "\n", "lf", "=", "np", ".", "log", "(", "v", ")", "-", "np", ".", "log1p", "(", "-", "np", ".", "exp", "(", "-", "v", ")", "*", "(", "1", "+", "u", "*", "u", "/", "2", ")", ")", "/", "2", "-", "np", ".", "log", "(", "2", ")", "*", "3", "/", "2.", "-", "np", ".", "log", "(", "u", ")", "-", "np", ".", "log", "(", "np", ".", "pi", ")", "\n", "g", "=", "2", "*", "v", "/", "u", "-", "u", "*", "np", ".", "log1p", "(", "-", "np", ".", "exp", "(", "-", "v", ")", ")", "\n", "return", "lf", "-", "np", ".", "log", "(", "n", ")", "+", "np", ".", "sqrt", "(", "n", ")", "*", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.init_q_cache": [[110, 129], ["numpy.array", "numpy.resize", "np.resize.fill", "int_part.__fill_cache"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.__fill_cache"], ["", "def", "init_q_cache", "(", "n_max", ",", "__q_cache", "=", "np", ".", "array", "(", "[", "]", ",", "ndmin", "=", "2", ")", ")", ":", "\n", "    ", "\"\"\"Initiate the look-up table for :math:`q(m, n)`.\n\n    Parameters\n    ----------\n    n_max : ``int``\n\n    __q_cache : :class:`numpy.ndarray` (required, default: ``np.array([], ndmin=2)``)\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "old_n", "=", "__q_cache", ".", "shape", "[", "0", "]", "\n", "if", "old_n", ">=", "n_max", ":", "\n", "        ", "return", "\n", "", "__q_cache", "=", "np", ".", "resize", "(", "__q_cache", ",", "[", "n_max", "+", "1", ",", "n_max", "+", "1", "]", ")", "\n", "__q_cache", ".", "fill", "(", "-", "np", ".", "inf", ")", "\n", "return", "__fill_cache", "(", "__q_cache", ",", "n_max", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.__fill_cache": [[131, 140], ["numba.njit", "range", "range", "int_part.log_sum", "int_part.log_sum"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.log_sum", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.log_sum"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "__fill_cache", "(", "cache", ",", "n_max", ")", ":", "\n", "    ", "for", "n", "in", "range", "(", "1", ",", "n_max", "+", "1", ")", ":", "\n", "        ", "cache", "[", "n", "]", "[", "1", "]", "=", "0", "\n", "for", "k", "in", "range", "(", "2", ",", "n", "+", "1", ")", ":", "\n", "            ", "cache", "[", "n", "]", "[", "k", "]", "=", "log_sum", "(", "cache", "[", "n", "]", "[", "k", "]", ",", "cache", "[", "n", "]", "[", "k", "-", "1", "]", ")", "\n", "if", "n", ">", "k", ":", "\n", "                ", "cache", "[", "n", "]", "[", "k", "]", "=", "log_sum", "(", "cache", "[", "n", "]", "[", "k", "]", ",", "cache", "[", "n", "-", "k", "]", "[", "k", "]", ")", "\n", "", "", "", "return", "cache", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.log_sum": [[142, 156], ["numba.njit", "numpy.maximum", "numpy.log1p", "numpy.exp", "numpy.abs"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "log_sum", "(", "a", ",", "b", ")", ":", "\n", "    ", "\"\"\"log_sum\n\n    Parameters\n    ----------\n    a : ``int``\n    b : ``int``\n\n    Returns\n    -------\n\n    \"\"\"", "\n", "return", "np", ".", "maximum", "(", "a", ",", "b", ")", "+", "np", ".", "log1p", "(", "np", ".", "exp", "(", "-", "np", ".", "abs", "(", "a", "-", "b", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.lbinom": [[158, 166], ["type", "numpy.array", "numpy.array", "scipy.special.gammaln", "scipy.special.gammaln", "scipy.special.gammaln", "numpy.array", "numpy.array", "numpy.array", "float", "float", "float"], "function", ["None"], ["", "def", "lbinom", "(", "n", ",", "k", ")", ":", "\n", "    ", "\"\"\"Return log of binom(n, k).\"\"\"", "\n", "if", "type", "(", "n", ")", "in", "[", "float", ",", "int", ",", "np", ".", "int64", ",", "np", ".", "float64", "]", ":", "\n", "        ", "n", "=", "np", ".", "array", "(", "[", "n", "]", ")", "\n", "k", "=", "np", ".", "array", "(", "[", "k", "]", ")", "\n", "", "return", "(", "gammaln", "(", "np", ".", "array", "(", "[", "float", "(", "x", ")", "for", "x", "in", "n", "+", "1", "]", ")", ")", "-", "\n", "gammaln", "(", "np", ".", "array", "(", "[", "float", "(", "x", ")", "for", "x", "in", "n", "-", "k", "+", "1", "]", ")", ")", "-", "\n", "gammaln", "(", "np", ".", "array", "(", "[", "float", "(", "x", ")", "for", "x", "in", "k", "+", "1", "]", ")", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.painter.paint_block_mat_from_e_rs": [[15, 53], ["matplotlib.figure", "matplotlib.gca", "range", "matplotlib.scatter", "matplotlib.ylabel", "matplotlib.xlabel", "matplotlib.xlim", "matplotlib.ylim", "plt.gca.axes.get_xaxis().set_visible", "plt.gca.axes.get_yaxis().set_visible", "len", "range", "matplotlib.savefig", "len", "x_index.append", "y_index.append", "size.append", "plt.gca.axes.get_xaxis", "plt.gca.axes.get_yaxis", "len", "len", "numpy.max"], "function", ["None"], ["def", "paint_block_mat_from_e_rs", "(", "e_rs", ",", "output", "=", "None", ",", "figsize", "=", "(", "3", ",", "3", ")", ",", "dpi", "=", "200", ",", "**", "kwargs", ")", ":", "\n", "    ", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "frame", "=", "plt", ".", "gca", "(", ")", "\n", "\n", "size", "=", "[", "]", "\n", "x_index", "=", "[", "]", "\n", "y_index", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "e_rs", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "e_rs", ")", ")", ":", "\n", "            ", "x_index", ".", "append", "(", "i", "+", "0.5", ")", "\n", "y_index", ".", "append", "(", "j", "+", "0.5", ")", "\n", "size", ".", "append", "(", "e_rs", "[", "i", "]", "[", "j", "]", ")", "\n", "\n", "", "", "plt", ".", "scatter", "(", "x_index", ",", "\n", "y_index", ",", "\n", "marker", "=", "'s'", ",", "\n", "color", "=", "'k'", ",", "\n", "alpha", "=", "0.8", ",", "\n", "facecolors", "=", "'k'", ",", "\n", "#             edgecolors='k',", "\n", "s", "=", "size", "/", "np", ".", "max", "(", "size", ")", "*", "100", ",", "\n", "label", "=", "''", ")", "\n", "\n", "plt", ".", "ylabel", "(", "''", ")", "\n", "plt", ".", "xlabel", "(", "''", ")", "\n", "\n", "# and a legend", "\n", "# plt.legend(loc='upper right')", "\n", "\n", "# set the figure boundaries", "\n", "plt", ".", "xlim", "(", "[", "0", "-", "0.2", ",", "len", "(", "e_rs", ")", "+", "0.2", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0", "-", "0.2", ",", "len", "(", "e_rs", ")", "+", "0.2", "]", ")", "\n", "\n", "frame", ".", "axes", ".", "get_xaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "frame", ".", "axes", ".", "get_yaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "\n", "if", "output", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "output", ",", "dpi", "=", "dpi", ",", "transparent", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.painter.paint_block_mat": [[55, 96], ["numpy.asanyarray", "utils.assemble_e_rs_from_mb", "matplotlib.figure", "matplotlib.gca", "range", "matplotlib.scatter", "matplotlib.ylabel", "matplotlib.xlabel", "matplotlib.xlim", "matplotlib.ylim", "plt.gca.axes.get_xaxis().set_visible", "plt.gca.axes.get_yaxis().set_visible", "len", "range", "matplotlib.savefig", "len", "x_index.append", "y_index.append", "size.append", "plt.gca.axes.get_xaxis", "plt.gca.axes.get_yaxis", "len", "len", "numpy.max"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_e_rs_from_mb"], ["", "", "def", "paint_block_mat", "(", "mb", ",", "edgelist", ",", "output", "=", "None", ",", "figsize", "=", "(", "3", ",", "3", ")", ",", "dpi", "=", "200", ",", "**", "kwargs", ")", ":", "\n", "    ", "mb", "=", "np", ".", "asanyarray", "(", "mb", ",", "dtype", "=", "int", ")", "\n", "e_rs", "=", "assemble_e_rs_from_mb", "(", "edgelist", ",", "mb", ")", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "frame", "=", "plt", ".", "gca", "(", ")", "\n", "\n", "size", "=", "[", "]", "\n", "x_index", "=", "[", "]", "\n", "y_index", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "e_rs", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "e_rs", ")", ")", ":", "\n", "            ", "x_index", ".", "append", "(", "i", "+", "0.5", ")", "\n", "y_index", ".", "append", "(", "j", "+", "0.5", ")", "\n", "size", ".", "append", "(", "e_rs", "[", "i", "]", "[", "j", "]", ")", "\n", "\n", "", "", "plt", ".", "scatter", "(", "x_index", ",", "\n", "y_index", ",", "\n", "marker", "=", "'s'", ",", "\n", "color", "=", "'k'", ",", "\n", "alpha", "=", "0.8", ",", "\n", "facecolors", "=", "'k'", ",", "\n", "#             edgecolors='k',", "\n", "s", "=", "size", "/", "np", ".", "max", "(", "size", ")", "*", "100", ",", "\n", "label", "=", "''", ")", "\n", "\n", "plt", ".", "ylabel", "(", "''", ")", "\n", "plt", ".", "xlabel", "(", "''", ")", "\n", "\n", "# and a legend", "\n", "# plt.legend(loc='upper right')", "\n", "\n", "# set the figure boundaries", "\n", "plt", ".", "xlim", "(", "[", "0", "-", "0.2", ",", "len", "(", "e_rs", ")", "+", "0.2", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0", "-", "0.2", ",", "len", "(", "e_rs", ")", "+", "0.2", "]", ")", "\n", "\n", "frame", ".", "axes", ".", "get_xaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "frame", ".", "axes", ".", "get_yaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "\n", "if", "output", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "output", ",", "dpi", "=", "dpi", ",", "transparent", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.painter.paint_sorted_adj_mat": [[98, 125], ["matplotlib.figure", "matplotlib.subplots", "numpy.argsort", "numpy.zeros", "scipy.csr_matrix", "matplotlib.spy", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.xticks", "matplotlib.yticks", "int", "int", "matplotlib.gca().invert_yaxis", "ax.tick_params", "ax.tick_params", "ax.xaxis.set_ticks_position", "ax.spines[].set_visible", "ax.spines[].set_visible", "matplotlib.savefig", "len", "len", "numpy.linspace", "len", "numpy.linspace", "len", "len", "len", "matplotlib.gca", "numpy.argwhere", "numpy.argwhere", "numpy.argwhere", "numpy.argwhere"], "function", ["None"], ["", "", "def", "paint_sorted_adj_mat", "(", "mb", ",", "edgelist", ",", "output", "=", "None", ",", "figsize", "=", "(", "10", ",", "10", ")", ",", "dpi", "=", "300", ",", "invert", "=", "True", ")", ":", "\n", "    ", "font", "=", "{", "'family'", ":", "'serif'", "}", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "10", ",", "10", ")", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "mb", "=", "np", ".", "argsort", "(", "mb", ")", "\n", "A", "=", "np", ".", "zeros", "(", "[", "len", "(", "mb", ")", ",", "len", "(", "mb", ")", "]", ")", "\n", "for", "edge", "in", "edgelist", ":", "\n", "        ", "e0", "=", "int", "(", "edge", "[", "0", "]", ")", "\n", "e1", "=", "int", "(", "edge", "[", "1", "]", ")", "\n", "A", "[", "np", ".", "argwhere", "(", "mb", "==", "e0", ")", "[", "0", "]", "[", "0", "]", "]", "[", "np", ".", "argwhere", "(", "mb", "==", "e1", ")", "[", "0", "]", "[", "0", "]", "]", "+=", "1", "\n", "A", "[", "np", ".", "argwhere", "(", "mb", "==", "e1", ")", "[", "0", "]", "[", "0", "]", "]", "[", "np", ".", "argwhere", "(", "mb", "==", "e0", ")", "[", "0", "]", "[", "0", "]", "]", "+=", "1", "\n", "", "M", "=", "sps", ".", "csr_matrix", "(", "A", ")", "\n", "plt", ".", "spy", "(", "M", ",", "markersize", "=", "0.01", ",", "marker", "=", "\",\"", ")", "\n", "plt", ".", "xlabel", "(", "f\"(Node index $i$) / {len(mb)}\"", ",", "fontdict", "=", "font", ")", "\n", "plt", ".", "ylabel", "(", "f\"(Node index $i$) / {len(mb)}\"", ",", "fontdict", "=", "font", ")", "\n", "\n", "plt", ".", "xticks", "(", "np", ".", "linspace", "(", "0", ",", "1", ",", "5", ")", "*", "len", "(", "mb", ")", ",", "(", "'0'", ",", "'0.25'", ",", "'0.5'", ",", "'0.75'", ",", "'1'", ")", ")", "\n", "plt", ".", "yticks", "(", "np", ".", "linspace", "(", "0", ",", "1", ",", "5", ")", "*", "len", "(", "mb", ")", ",", "(", "'0'", ",", "'0.25'", ",", "'0.5'", ",", "'0.75'", ",", "'1'", ")", ")", "\n", "if", "invert", ":", "\n", "        ", "plt", ".", "gca", "(", ")", ".", "invert_yaxis", "(", ")", "\n", "ax", ".", "tick_params", "(", "axis", "=", "\"y\"", ",", "direction", "=", "\"in\"", ")", "\n", "ax", ".", "tick_params", "(", "axis", "=", "\"x\"", ",", "direction", "=", "\"in\"", ")", "\n", "ax", ".", "xaxis", ".", "set_ticks_position", "(", "\"bottom\"", ")", "\n", "ax", ".", "spines", "[", "'right'", "]", ".", "set_visible", "(", "False", ")", "\n", "ax", ".", "spines", "[", "'top'", "]", ".", "set_visible", "(", "False", ")", "\n", "", "if", "output", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "output", ",", "dpi", "=", "dpi", ",", "transparent", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.painter.paint_trace": [[127, 179], ["oks.summary", "enumerate", "lines.pop", "LineCollection", "matplotlib.subplots", "ax.add_collection", "ax.autoscale", "ax.tick_params", "ax.scatter", "matplotlib.axvline", "matplotlib.axhline", "enumerate", "ax.margins", "ax.set_aspect", "matplotlib.xlabel", "matplotlib.ylabel", "numpy.array", "np.max.flatten", "numpy.max", "matplotlib.xticks", "matplotlib.yticks", "matplotlib.xlim", "matplotlib.ylim", "list", "matplotlib.scatter", "numpy.arange", "numpy.arange", "matplotlib.savefig", "oks.bookkeeping_dl.keys", "len"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary"], ["", "", "def", "paint_trace", "(", "oks", ",", "output", "=", "None", ",", "figsize", "=", "(", "4", ",", "4", ")", ",", "dpi", "=", "200", ")", ":", "\n", "    ", "from", "matplotlib", ".", "collections", "import", "LineCollection", "\n", "summary", "=", "oks", ".", "summary", "(", ")", "\n", "trace", "=", "[", "(", "i", "[", "1", "]", ",", "i", "[", "2", "]", ")", "for", "i", "in", "oks", ".", "trace_k", "]", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "ind", ",", "i", "in", "enumerate", "(", "trace", ")", ":", "\n", "        ", "if", "ind", "!=", "len", "(", "trace", ")", "-", "1", ":", "\n", "            ", "lines", "+=", "[", "(", "trace", "[", "ind", "]", ",", "trace", "[", "ind", "+", "1", "]", ")", "]", "\n", "\n", "", "", "lines", ".", "pop", "(", "0", ")", "# remove the first line segment to make it prettier", "\n", "\n", "lc", "=", "LineCollection", "(", "lines", ",", "linewidths", "=", "0.5", ",", "color", "=", "\"#0074D9\"", ",", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "figsize", ",", "dpi", "=", "300", ")", "\n", "ax", ".", "add_collection", "(", "lc", ")", "\n", "ax", ".", "autoscale", "(", ")", "\n", "\n", "ax", ".", "tick_params", "(", "direction", "=", "\"in\"", ")", "\n", "\n", "x", "=", "[", "i", "[", "0", "]", "for", "j", "in", "lines", "for", "i", "in", "j", "]", "\n", "y", "=", "[", "i", "[", "1", "]", "for", "j", "in", "lines", "for", "i", "in", "j", "]", "\n", "\n", "ax", ".", "scatter", "(", "x", ",", "y", ")", "\n", "\n", "# Locate the mdl point (Pink circle marks the optimal point (ka, kb))", "\n", "ka", "=", "summary", "[", "\"ka\"", "]", "\n", "kb", "=", "summary", "[", "\"kb\"", "]", "\n", "plt", ".", "axvline", "(", "ka", ",", "color", "=", "\"#DDDDDD\"", ",", "linewidth", "=", "0.5", ")", "\n", "plt", ".", "axhline", "(", "kb", ",", "color", "=", "\"#DDDDDD\"", ",", "linewidth", "=", "0.5", ")", "\n", "#     ax.scatter(ka, kb, marker=\"o\", c=\"pink\", s=200, alpha=0.5)", "\n", "\n", "# Black numbers indicate ordered points where graph partition takes place", "\n", "for", "idx", ",", "point", "in", "enumerate", "(", "list", "(", "oks", ".", "bookkeeping_dl", ".", "keys", "(", ")", ")", ")", ":", "\n", "        ", "plt", ".", "scatter", "(", "point", "[", "0", "]", ",", "point", "[", "1", "]", ",", "marker", "=", "'x'", ",", "c", "=", "\"#FF4136\"", ",", "edgecolors", "=", "\"none\"", ",", "s", "=", "20", ")", "\n", "\n", "", "ax", ".", "margins", "(", "0.01", ")", "\n", "\n", "ax", ".", "set_aspect", "(", "1", ")", "\n", "plt", ".", "xlabel", "(", "\"$K_a$\"", ")", "\n", "plt", ".", "ylabel", "(", "\"$K_b$\"", ")", "\n", "\n", "k", "=", "np", ".", "array", "(", "trace", ")", "\n", "k", ".", "flatten", "(", ")", "\n", "k", "=", "np", ".", "max", "(", "k", ")", "\n", "plt", ".", "xticks", "(", "np", ".", "arange", "(", "0", ",", "k", "+", "1", ",", "2", ")", ")", "\n", "plt", ".", "yticks", "(", "np", ".", "arange", "(", "0", ",", "k", "+", "1", ",", "2", ")", ")", "\n", "plt", ".", "xlim", "(", "[", "0", ",", "k", "+", "1", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0", ",", "k", "+", "1", "]", ")", "\n", "\n", "# plt.show()", "\n", "if", "output", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "output", ",", "dpi", "=", "dpi", ",", "transparent", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.painter.paint_dl_trace": [[181, 203], ["oks.get__q_cache", "matplotlib.subplots", "enumerate", "ax.autoscale", "ax.margins", "ax.tick_params", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.plot", "oks.summary", "oks.summary", "oks.summary", "oks.oks.bookkeeping_mb[].keys", "utils.assemble_n_r_from_mb", "matplotlib.savefig", "utils.get_desc_len_from_data"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.get__q_cache", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_n_r_from_mb", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.get_desc_len_from_data"], ["", "", "def", "paint_dl_trace", "(", "oks", ",", "output", "=", "None", ",", "figsize", "=", "(", "4", ",", "2", ")", ",", "dpi", "=", "200", ")", ":", "\n", "    ", "qc", "=", "oks", ".", "get__q_cache", "(", ")", "\n", "na", "=", "oks", ".", "summary", "(", ")", "[", "\"na\"", "]", "\n", "nb", "=", "oks", ".", "summary", "(", ")", "[", "\"nb\"", "]", "\n", "e", "=", "oks", ".", "summary", "(", ")", "[", "\"e\"", "]", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "figsize", ",", "dpi", "=", "300", ")", "\n", "desc_len_list", "=", "[", "]", "\n", "\n", "for", "idx", ",", "key", "in", "enumerate", "(", "oks", ".", "oks", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", ".", "keys", "(", ")", ")", ":", "\n", "        ", "mb", "=", "oks", ".", "oks", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "[", "key", "]", "[", "1", "]", "\n", "nr", "=", "assemble_n_r_from_mb", "(", "mb", ")", "\n", "desc_len_list", "+=", "[", "get_desc_len_from_data", "(", "na", ",", "nb", ",", "e", ",", "key", "[", "0", "]", ",", "key", "[", "1", "]", ",", "oks", ".", "edgelist", ",", "mb", ",", "nr", "=", "nr", ",", "q_cache", "=", "qc", ")", "]", "\n", "", "ax", ".", "autoscale", "(", ")", "\n", "ax", ".", "margins", "(", "0.1", ")", "\n", "ax", ".", "tick_params", "(", "direction", "=", "\"in\"", ")", "\n", "\n", "plt", ".", "xlabel", "(", "\"steps\"", ")", "\n", "plt", ".", "ylabel", "(", "\"DL\"", ")", "\n", "plt", ".", "plot", "(", "desc_len_list", ",", "'o-'", ")", "\n", "if", "output", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "output", ",", "dpi", "=", "dpi", ",", "transparent", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.painter.paint_similarity_trace": [[205, 225], ["clusim.clustering.Clustering", "matplotlib.subplots", "clusim.clustering.Clustering.from_membership_list", "oks.oks.bookkeeping_mb[].values", "ax.autoscale", "ax.margins", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.yticks", "ax.tick_params", "matplotlib.plot", "clusim.clustering.Clustering", "clusim.clustering.Clustering.from_membership_list", "numpy.linspace", "matplotlib.savefig", "clusim.element_sim"], "function", ["None"], ["", "", "def", "paint_similarity_trace", "(", "b", ",", "oks", ",", "output", "=", "None", ",", "figsize", "=", "(", "3", ",", "3", ")", ",", "dpi", "=", "200", ")", ":", "\n", "    ", "clu_base", "=", "Clustering", "(", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "figsize", ",", "dpi", "=", "300", ")", "\n", "e_sim_list", "=", "[", "]", "\n", "clu_base", ".", "from_membership_list", "(", "b", ")", "\n", "for", "g", "in", "oks", ".", "oks", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", ".", "values", "(", ")", ":", "\n", "        ", "clu", "=", "Clustering", "(", ")", "\n", "clu", ".", "from_membership_list", "(", "g", "[", "1", "]", ")", "\n", "e_sim_list", "+=", "[", "sim", ".", "element_sim", "(", "clu_base", ",", "clu", ")", "]", "\n", "\n", "", "ax", ".", "autoscale", "(", ")", "\n", "ax", ".", "margins", "(", "0.1", ")", "\n", "# ax.set_aspect(1)", "\n", "plt", ".", "xlabel", "(", "\"steps\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Element-centric similarity\"", ")", "\n", "plt", ".", "yticks", "(", "np", ".", "linspace", "(", "0", ",", "1", ",", "5", ")", ")", "\n", "ax", ".", "tick_params", "(", "direction", "=", "\"in\"", ")", "\n", "plt", ".", "plot", "(", "e_sim_list", ")", "\n", "if", "output", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "output", ",", "dpi", "=", "dpi", ",", "transparent", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.painter.paint_landscape": [[227, 267], ["numpy.zeros", "oks.bookkeeping_dl.keys", "matplotlib.subplots", "matplotlib.cm.terrain", "matplotlib.cm.terrain", "numpy.vstack", "matplotlib.colors.LinearSegmentedColormap.from_list", "numpy.geomspace", "matplotlib.colors.BoundaryNorm", "ax.imshow", "matplotlib.xlabel", "matplotlib.ylabel", "mpl_toolkits.axes_grid1.make_axes_locatable", "mpl_toolkits.axes_grid1.make_axes_locatable.append_axes", "fig.colorbar", "ax.tick_params", "ax.tick_params", "ax.xaxis.set_ticks_position", "ax.spines[].set_visible", "ax.spines[].set_visible", "ax.set_xticks", "ax.set_yticks", "ax.set_xticklabels", "ax.set_yticklabels", "numpy.linspace", "numpy.linspace", "min", "max", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "matplotlib.savefig", "np.zeros.flatten", "np.zeros.flatten"], "function", ["None"], ["", "", "def", "paint_landscape", "(", "oks", ",", "max_ka", ",", "max_kb", ",", "output", "=", "None", ",", "dpi", "=", "200", ",", ")", ":", "\n", "    ", "mat", "=", "np", ".", "zeros", "(", "[", "max_ka", ",", "max_kb", "]", ")", "\n", "for", "i", "in", "oks", ".", "bookkeeping_dl", ".", "keys", "(", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "mat", "[", "i", "[", "0", "]", "-", "1", ",", "i", "[", "1", "]", "-", "1", "]", "=", "oks", ".", "bookkeeping_dl", "[", "i", "]", "\n", "", "except", "IndexError", ":", "\n", "            ", "pass", "\n", "\n", "", "", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "6", ",", "6", ")", ")", "# setup the plot", "\n", "\n", "colors_undersea", "=", "plt", ".", "cm", ".", "terrain", "(", "np", ".", "linspace", "(", "0", ",", "0.95", ",", "256", ")", ")", "\n", "colors_land", "=", "plt", ".", "cm", ".", "terrain", "(", "np", ".", "linspace", "(", "0.95", ",", "1", ",", "256", ")", ")", "\n", "all_colors", "=", "np", ".", "vstack", "(", "(", "colors_undersea", ",", "colors_land", ")", ")", "\n", "cmap", "=", "mpl", ".", "colors", ".", "LinearSegmentedColormap", ".", "from_list", "(", "'terrain_map'", ",", "all_colors", ")", "\n", "\n", "# define the bins and normalize", "\n", "bounds", "=", "np", ".", "geomspace", "(", "min", "(", "mat", ".", "flatten", "(", ")", ")", ",", "max", "(", "mat", ".", "flatten", "(", ")", ")", ",", "256", ")", "\n", "norm", "=", "mpl", ".", "colors", ".", "BoundaryNorm", "(", "bounds", ",", "256", ")", "\n", "\n", "ims", "=", "ax", ".", "imshow", "(", "mat", ",", "norm", "=", "norm", ",", "cmap", "=", "cmap", ",", "origin", "=", "'lower'", ",", "extent", "=", "[", "1", ",", "max_ka", ",", "1", ",", "max_ka", "]", ",", "rasterized", "=", "True", ")", "\n", "plt", ".", "xlabel", "(", "\"$K_a$\"", ")", "\n", "plt", ".", "ylabel", "(", "\"$K_b$\"", ")", "\n", "\n", "# scaled colorbar that aligns with the frame", "\n", "divider", "=", "make_axes_locatable", "(", "ax", ")", "\n", "cax", "=", "divider", ".", "append_axes", "(", "\"right\"", ",", "size", "=", "\"5%\"", ",", "pad", "=", "0.05", ")", "\n", "fig", ".", "colorbar", "(", "ims", ",", "cax", "=", "cax", ",", "label", "=", "\"DL (unit: nat)\"", ",", "shrink", "=", "1", ")", "\n", "ax", ".", "tick_params", "(", "axis", "=", "\"y\"", ",", "direction", "=", "\"in\"", ")", "\n", "ax", ".", "tick_params", "(", "axis", "=", "\"x\"", ",", "direction", "=", "\"in\"", ")", "\n", "ax", ".", "xaxis", ".", "set_ticks_position", "(", "\"bottom\"", ")", "\n", "\n", "ax", ".", "spines", "[", "'right'", "]", ".", "set_visible", "(", "True", ")", "\n", "ax", ".", "spines", "[", "'top'", "]", ".", "set_visible", "(", "True", ")", "\n", "\n", "ax", ".", "set_xticks", "(", "np", ".", "arange", "(", "1.5", ",", "max_ka", "+", "1", ",", "4", ")", ")", "\n", "ax", ".", "set_yticks", "(", "np", ".", "arange", "(", "1.5", ",", "max_kb", "+", "1", ",", "4", ")", ")", "\n", "ax", ".", "set_xticklabels", "(", "np", ".", "arange", "(", "1", ",", "max_ka", "+", "1", ",", "4", ")", ")", "\n", "ax", ".", "set_yticklabels", "(", "np", ".", "arange", "(", "1", ",", "max_kb", "+", "1", ",", "4", ")", ")", "\n", "if", "output", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "output", ",", "dpi", "=", "dpi", ",", "transparent", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.painter.paint_mds": [[269, 300], ["len", "int", "numpy.zeros", "enumerate", "sklearn.manifold.MDS", "manifold.MDS.fit_transform", "painter.paint_mds._plot_embedding"], "function", ["None"], ["", "", "def", "paint_mds", "(", "oks", ",", "figsize", "=", "(", "20", ",", "20", ")", ")", ":", "\n", "    ", "l2", "=", "len", "(", "oks", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", ".", "keys", "(", ")", ")", "\n", "l", "=", "int", "(", "l2", "**", "0.5", ")", "\n", "X", "=", "np", ".", "zeros", "(", "[", "l2", ",", "l2", "]", ")", "\n", "for", "idx_1", ",", "pair_1", "in", "enumerate", "(", "combinations", "(", "range", "(", "1", ",", "l", "+", "1", ")", ",", "2", ")", ")", ":", "\n", "        ", "b", "=", "oks", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "[", "pair_1", "]", "\n", "clu_1", "=", "Clustering", "(", ")", "\n", "clu_1", ".", "from_membership_list", "(", "b", ")", "\n", "for", "idx_2", ",", "pair_2", "in", "enumerate", "(", "combinations", "(", "range", "(", "1", ",", "l", "+", "1", ")", ",", "2", ")", ")", ":", "\n", "            ", "b", "=", "oks", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", "[", "pair_2", "]", "\n", "clu_2", "=", "Clustering", "(", ")", "\n", "clu_2", ".", "from_membership_list", "(", "b", ")", "\n", "\n", "X", "[", "idx_1", "]", "[", "idx_2", "]", "=", "1", "-", "sim", ".", "element_sim", "(", "clu_1", ",", "clu_2", ")", "\n", "X", "[", "idx_2", "]", "[", "idx_1", "]", "=", "X", "[", "idx_1", "]", "[", "idx_2", "]", "\n", "\n", "", "", "def", "_plot_embedding", "(", "X", ",", "title", "=", "None", ")", ":", "\n", "        ", "x_min", ",", "x_max", "=", "np", ".", "min", "(", "X", ",", "0", ")", ",", "np", ".", "max", "(", "X", ",", "0", ")", "\n", "X", "=", "(", "X", "-", "x_min", ")", "/", "(", "x_max", "-", "x_min", ")", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "for", "ind", ",", "i", "in", "enumerate", "(", "range", "(", "X", ".", "shape", "[", "0", "]", ")", ")", ":", "\n", "            ", "plt", ".", "text", "(", "X", "[", "i", ",", "0", "]", ",", "X", "[", "i", ",", "1", "]", ",", "str", "(", "list", "(", "oks", ".", "bookkeeping_mb", "[", "\"mcmc\"", "]", ".", "keys", "(", ")", ")", "[", "ind", "]", ")", ",", "color", "=", "plt", ".", "cm", ".", "Set1", "(", "1", "/", "10.", ")", ",", "\n", "fontdict", "=", "{", "'weight'", ":", "'bold'", ",", "'size'", ":", "12", "}", ")", "\n", "", "plt", ".", "xticks", "(", "[", "]", ")", ",", "plt", ".", "yticks", "(", "[", "]", ")", "\n", "if", "title", "is", "not", "None", ":", "\n", "            ", "plt", ".", "title", "(", "title", ")", "\n", "\n", "", "", "clf", "=", "manifold", ".", "MDS", "(", "n_components", "=", "2", ",", "n_init", "=", "10", ",", "max_iter", "=", "10000", ",", "dissimilarity", "=", "\"precomputed\"", ")", "\n", "X_mds", "=", "clf", ".", "fit_transform", "(", "X", ")", "\n", "_plot_embedding", "(", "X_mds", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.db_factorial_ln": [[11, 17], ["int", "gammaln", "gammaln", "gammaln", "np.log", "np.log"], "function", ["None"], ["def", "db_factorial_ln", "(", "val", ")", ":", "\n", "    ", "m", "=", "int", "(", "val", ")", "\n", "if", "m", "&", "0x1", "==", "1", ":", "# m is odd", "\n", "        ", "return", "gammaln", "(", "m", "+", "1", ")", "-", "gammaln", "(", "(", "m", "-", "1", ")", "/", "2", "+", "1", ")", "-", "(", "(", "m", "-", "1", ")", "/", "2", ")", "*", "np", ".", "log", "(", "2", ")", "\n", "", "else", ":", "\n", "        ", "return", "gammaln", "(", "m", "/", "2", "+", "1", ")", "+", "(", "m", "/", "2", ")", "*", "np", ".", "log", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.partition_entropy": [[25, 93], ["type", "np.array", "np.array", "np.array", "np.array", "np.array", "np.array", "np.log1p", "type", "type", "np.log", "int_part.lbinom", "int_part.lbinom", "np.log", "gammaln", "gammaln().sum", "np.log", "int_part.lbinom", "int_part.lbinom", "np.log", "gammaln", "gammaln().sum", "gammaln", "gammaln", "gammaln"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.lbinom", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.lbinom", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.lbinom", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.lbinom"], ["", "", "def", "partition_entropy", "(", "ka", "=", "None", ",", "kb", "=", "None", ",", "k", "=", "None", ",", "na", "=", "None", ",", "nb", "=", "None", ",", "n", "=", "None", ",", "nr", "=", "None", ",", "allow_empty", "=", "False", ")", ":", "\n", "    ", "\"\"\"partition_entropy\n\n    Compute the partition entropy, P(b), for the current partition. It has several variations depending on the priors\n    used. In the crudest way (`compute_profile_likelihood_from_e_rsnr == None`), we formulate P(b) = P(b | B) * P(B).\n    Or, by a two-level Bayesian hierarchy,\n    we can do P(b) = P(b | n) * P(n | B) * P(B).\n\n    Parameters\n    ----------\n    ka : ``int``\n        Number of communities in type-*a*.\n\n    kb : ``int``\n        Number of communities in type-*b*.\n\n    k : ``int``\n        Number of communities in the graph.\n\n    na : ``int``\n        Number of vertices in type-*a*.\n\n    nb : ``int``\n        Number of vertices in type-*b*.\n\n    n : ``int``\n        Number of vertices in the graph.\n\n    nr : :class:`numpy.ndarray`\n        Vertex property array of the block graph which contains the block sizes.\n\n    allow_empty : ``bool`` (optional, default: ``False``)\n        If ``True``, partition description length computed will allow for empty groups.\n\n    Returns\n    -------\n    ent : ``float``\n        The description length (or entropy) in nat of the partition.\n\n    \"\"\"", "\n", "if", "type", "(", "n", ")", "is", "int", ":", "\n", "        ", "n", "=", "np", ".", "array", "(", "[", "n", "]", ")", "\n", "k", "=", "np", ".", "array", "(", "[", "k", "]", ")", "\n", "", "elif", "type", "(", "na", ")", "is", "int", "and", "type", "(", "nb", ")", "is", "int", ":", "\n", "        ", "na", "=", "np", ".", "array", "(", "[", "na", "]", ")", "\n", "ka", "=", "np", ".", "array", "(", "[", "ka", "]", ")", "\n", "nb", "=", "np", ".", "array", "(", "[", "nb", "]", ")", "\n", "kb", "=", "np", ".", "array", "(", "[", "kb", "]", ")", "\n", "\n", "", "if", "nr", "is", "None", ":", "\n", "        ", "ent", "=", "n", "*", "np", ".", "log", "(", "k", ")", "+", "np", ".", "log1p", "(", "-", "(", "1", "-", "1.", "/", "k", ")", "**", "n", ")", "# TODO: check this term", "\n", "", "else", ":", "\n", "        ", "if", "ka", "is", "None", "and", "kb", "is", "None", "and", "k", "is", "not", "None", ":", "\n", "            ", "if", "allow_empty", ":", "\n", "                ", "ent", "=", "lbinom", "(", "k", "+", "n", "-", "1", ",", "n", ")", "\n", "", "else", ":", "\n", "                ", "ent", "=", "lbinom", "(", "n", "-", "1", ",", "k", "-", "1", ")", "\n", "", "ent", "+=", "(", "gammaln", "(", "n", "+", "1", ")", "-", "gammaln", "(", "nr", "+", "1", ")", ".", "sum", "(", ")", ")", "+", "np", ".", "log", "(", "n", ")", "# TODO: check the last term (should be alright)", "\n", "", "elif", "ka", "is", "not", "None", "and", "kb", "is", "not", "None", "and", "k", "is", "None", ":", "\n", "            ", "if", "allow_empty", ":", "\n", "# TODO", "\n", "                ", "raise", "NotImplementedError", "\n", "", "else", ":", "\n", "                ", "ent", "=", "lbinom", "(", "na", "-", "1", ",", "ka", "-", "1", ")", "+", "lbinom", "(", "nb", "-", "1", ",", "kb", "-", "1", ")", "\n", "", "ent", "+=", "(", "gammaln", "(", "na", "+", "1", ")", "+", "gammaln", "(", "nb", "+", "1", ")", "-", "gammaln", "(", "nr", "+", "1", ")", ".", "sum", "(", ")", ")", "+", "np", ".", "log", "(", "na", ")", "+", "np", ".", "log", "(", "nb", ")", "\n", "", "else", ":", "\n", "            ", "raise", "AttributeError", "\n", "", "", "return", "ent", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.adjacency_entropy": [[95, 177], ["np.zeros", "scipy.sparse.lil_matrix", "np.sum", "enumerate", "utils.assemble_n_k_from_edgelist", "enumerate", "int", "int", "np.nditer", "int", "len", "len", "len", "scipy.sparse.lil_matrix.nonzero", "zip", "gammaln", "np.floor", "max", "max", "gammaln", "gammaln", "int", "int", "int", "int", "utils.db_factorial_ln", "np.log", "utils.db_factorial_ln", "gammaln"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_n_k_from_edgelist", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.db_factorial_ln", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.db_factorial_ln"], ["", "def", "adjacency_entropy", "(", "edgelist", ",", "mb", ",", "exact", "=", "True", ",", "multigraph", "=", "True", ")", ":", "\n", "    ", "\"\"\"adjacency_entropy\n\n    Calculate the entropy (a.k.a. negative log-likelihood) associated with the current block partition. It does not\n    include the model entropy.\n\n    Parameters\n    ----------\n    edgelist : :class:`numpy.ndarray`\n\n    mb : :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    exact : ``bool``\n\n    multigraph : ``bool``\n\n    Returns\n    -------\n    ent : ``float``\n        The description length (or entropy) in nat of the fitting.\n    \"\"\"", "\n", "ent", "=", "0.", "\n", "e_rs", "=", "np", ".", "zeros", "(", "(", "max", "(", "mb", ")", "+", "1", ",", "max", "(", "mb", ")", "+", "1", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "m_ij", "=", "lil_matrix", "(", "(", "len", "(", "mb", ")", ",", "len", "(", "mb", ")", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n", "for", "i", "in", "edgelist", ":", "\n", "# Please do check the index convention of the edgelist", "\n", "        ", "source_group", "=", "int", "(", "mb", "[", "int", "(", "i", "[", "0", "]", ")", "]", ")", "\n", "target_group", "=", "int", "(", "mb", "[", "int", "(", "i", "[", "1", "]", ")", "]", ")", "\n", "e_rs", "[", "source_group", "]", "[", "target_group", "]", "+=", "1", "\n", "e_rs", "[", "target_group", "]", "[", "source_group", "]", "+=", "1", "\n", "m_ij", "[", "int", "(", "i", "[", "0", "]", ")", ",", "int", "(", "i", "[", "1", "]", ")", "]", "+=", "1", "# we only update the upper triangular part of the adj-matrix", "\n", "", "italic_i", "=", "0.", "\n", "e_r", "=", "np", ".", "sum", "(", "e_rs", ",", "axis", "=", "1", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "sum_m_ii", "=", "0.", "\n", "sum_m_ij", "=", "0.", "\n", "sum_e_rs", "=", "0.", "\n", "sum_e_rr", "=", "0.", "\n", "sum_e_r", "=", "0.", "\n", "if", "exact", ":", "\n", "        ", "if", "multigraph", ":", "\n", "            ", "ind_i", ",", "ind_j", "=", "m_ij", ".", "nonzero", "(", ")", "\n", "for", "ind", "in", "zip", "(", "ind_i", ",", "ind_j", ")", ":", "\n", "                ", "val", "=", "m_ij", "[", "ind", "[", "0", "]", ",", "ind", "[", "1", "]", "]", "\n", "if", "val", ">", "1", ":", "\n", "                    ", "if", "ind", "[", "0", "]", "==", "ind", "[", "1", "]", ":", "\n", "                        ", "sum_m_ii", "+=", "db_factorial_ln", "(", "val", ")", "\n", "", "else", ":", "\n", "                        ", "sum_m_ij", "+=", "gammaln", "(", "val", "+", "1", ")", "\n", "", "", "", "", "for", "_e_r", "in", "e_r", ":", "\n", "            ", "sum_e_r", "+=", "gammaln", "(", "_e_r", "+", "1", ")", "\n", "\n", "", "", "for", "ind", ",", "e_val", "in", "enumerate", "(", "np", ".", "nditer", "(", "e_rs", ")", ")", ":", "\n", "        ", "ind_i", "=", "int", "(", "np", ".", "floor", "(", "ind", "/", "(", "e_rs", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "ind_j", "=", "ind", "%", "(", "e_rs", ".", "shape", "[", "0", "]", ")", "\n", "if", "exact", ":", "\n", "            ", "if", "ind_j", ">", "ind_i", ":", "\n", "                ", "sum_e_rs", "+=", "gammaln", "(", "e_val", "+", "1", ")", "\n", "", "elif", "ind_j", "==", "ind_i", ":", "\n", "                ", "sum_e_rr", "+=", "db_factorial_ln", "(", "e_val", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "e_val", "!=", "0.0", ":", "\n", "                ", "italic_i", "+=", "e_val", "*", "np", ".", "log", "(", "\n", "e_val", "/", "e_r", "[", "ind_i", "]", "/", "e_r", "[", "ind_j", "]", "\n", ")", "\n", "\n", "", "", "", "ent", "+=", "-", "italic_i", "/", "2", "\n", "n_k", "=", "assemble_n_k_from_edgelist", "(", "edgelist", ",", "mb", ")", "\n", "\n", "ent_deg", "=", "0", "\n", "for", "deg", ",", "k", "in", "enumerate", "(", "n_k", ")", ":", "\n", "        ", "if", "deg", "!=", "0", "and", "k", "!=", "0", ":", "\n", "            ", "ent_deg", "-=", "k", "*", "gammaln", "(", "deg", "+", "1", ")", "\n", "\n", "", "", "ent", "+=", "ent_deg", "\n", "if", "exact", ":", "\n", "        ", "return", "ent_deg", "-", "sum_e_rs", "-", "sum_e_rr", "+", "sum_e_r", "+", "sum_m_ii", "+", "sum_m_ij", "\n", "", "else", ":", "\n", "        ", "num_edges", "=", "len", "(", "edgelist", ")", "\n", "ent", "+=", "-", "num_edges", "\n", "return", "ent", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.model_entropy": [[179, 246], ["int_part.lbinom", "int_part.lbinom", "utils.partition_entropy"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.lbinom", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.lbinom", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.partition_entropy"], ["", "", "def", "model_entropy", "(", "e", ",", "ka", "=", "None", ",", "kb", "=", "None", ",", "na", "=", "None", ",", "nb", "=", "None", ",", "nr", "=", "None", ",", "allow_empty", "=", "False", ",", "is_bipartite", "=", "True", ")", ":", "\n", "    ", "\"\"\"model_entropy\n\n    Computes the amount of information necessary for the parameters of the (bipartite) blockmodel ensemble,\n    for ``ka`` type-`a` blocks, ``kb`` type-`b` blocks, ``na`` type-`a` vertices,\n    ``nb`` vertices, ``e`` edges, and either bipartite or general as a prior. This includes the entropy from\n    modeling the edge counts and the partition.\n\n    Note that if we know `a priori` that the network is bipartite, we can further compress the model.\n\n    Parameters\n    ----------\n    e : ``int``\n        Number of edges.\n\n    ka : ``int``\n        Number of communities in type-*a*.\n\n    kb : ``int``\n        Number of communities in type-*b*.\n\n    na : ``int``\n        Number of vertices in type-*a*.\n\n    nb : ``int``\n        Number of vertices in type-*b*.\n\n    nr : :class:`numpy.ndarray`\n        Vertex property array of the block graph which contains the block sizes.\n\n    allow_empty : ``bool`` (optional, default: ``False``)\n        If ``True``, partition description length computed will allow for empty groups.\n\n    is_bipartite : ``bool`` (optional, default: ``True``)\n        If ``False``, edge counts description length computed will assume a purely flat :math:`e_{rs}`.\n\n    Returns\n    -------\n    dl : ``float``\n        The description length (or entropy) in nat of the model.\n\n    References\n    ----------\n\n    .. [peixoto-parsimonious-2013] Tiago P. Peixoto, \"Parsimonious module\n       inference in large networks\", Phys. Rev. Lett. 110, 148701 (2013),\n       :doi:`10.1103/PhysRevLett.110.148701`, :arxiv:`1212.4794`.\n    .. [peixoto-nonparametric-2017] Tiago P. Peixoto, \"Nonparametric\n       Bayesian inference of the microcanonical stochastic block model\",\n       Phys. Rev. E 95 012317 (2017), :doi:`10.1103/PhysRevE.95.012317`,\n       :arxiv:`1610.02703`\n\n    \"\"\"", "\n", "if", "not", "is_bipartite", ":", "\n", "        ", "k", "=", "ka", "+", "kb", "\n", "x", "=", "(", "k", "*", "(", "k", "+", "1", ")", ")", "/", "2", "\n", "", "else", ":", "\n", "        ", "x", "=", "ka", "*", "kb", "\n", "\n", "", "if", "nr", "is", "False", ":", "\n", "        ", "dl", "=", "lbinom", "(", "x", "+", "e", "-", "1", ",", "e", ")", "\n", "", "else", ":", "\n", "        ", "dl", "=", "lbinom", "(", "x", "+", "e", "-", "1", ",", "e", ")", "+", "partition_entropy", "(", "ka", "=", "ka", ",", "kb", "=", "kb", ",", "na", "=", "na", ",", "nb", "=", "nb", ",", "nr", "=", "nr", ",", "allow_empty", "=", "allow_empty", ")", "\n", "# TO use the general prior for the partition entropy, replace the function with:", "\n", "# n = na + nb", "\n", "# partition_entropy(k=k, n=n, nr=nr, allow_empty=allow_empty)", "\n", "", "return", "dl", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.degree_entropy": [[248, 307], ["np.array", "int", "utils.assemble_n_r_from_mb", "np.zeros", "int", "int", "np.sum", "max", "int_part.lbinom", "enumerate", "utils.assemble_eta_rk_from_edgelist_and_mb", "enumerate", "len", "int_part.init_q_cache", "int_part.log_q", "int", "int", "gammaln", "gammaln"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_n_r_from_mb", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.lbinom", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_eta_rk_from_edgelist_and_mb", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.init_q_cache", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.int_part.log_q"], ["", "def", "degree_entropy", "(", "edgelist", ",", "mb", ",", "__q_cache", "=", "np", ".", "array", "(", "[", "]", ",", "ndmin", "=", "2", ")", ",", "degree_dl_kind", "=", "\"distributed\"", ",", "\n", "q_cache_max_e_r", "=", "int", "(", "1e4", ")", ")", ":", "\n", "    ", "\"\"\"degree_entropy\n\n    degree_entropy\n\n    Parameters\n    ----------\n    edgelist : ``iterable`` or :class:`numpy.ndarray`\n\n    mb : ``iterable`` or :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    __q_cache : :class:`numpy.ndarray` (required, default: ``np.array([], ndmin=2)``)\n\n    degree_dl_kind: ``str``\n\n        1. ``degree_dl_kind == \"uniform\"``\n\n        This corresponds to a non-informative prior, where the node\n        degrees are sampled from an uniform distribution.\n\n        2. ``degree_dl_kind == \"distributed\"``\n\n        This option should be preferred in most cases.\n\n    Returns\n    -------\n    ent : ``float``\n        The entropy.\n\n    \"\"\"", "\n", "ent", "=", "0", "\n", "n_r", "=", "assemble_n_r_from_mb", "(", "mb", ")", "\n", "\n", "e_r", "=", "np", ".", "zeros", "(", "max", "(", "mb", ")", "+", "1", ")", "\n", "for", "i", "in", "edgelist", ":", "\n", "# Please do check the index convention of the edgelist", "\n", "        ", "source_group", "=", "int", "(", "mb", "[", "int", "(", "i", "[", "0", "]", ")", "]", ")", "\n", "target_group", "=", "int", "(", "mb", "[", "int", "(", "i", "[", "1", "]", ")", "]", ")", "\n", "e_r", "[", "source_group", "]", "+=", "1", "\n", "e_r", "[", "target_group", "]", "+=", "1", "\n", "\n", "", "if", "degree_dl_kind", "==", "\"uniform\"", ":", "\n", "        ", "ent", "+=", "np", ".", "sum", "(", "lbinom", "(", "n_r", "+", "e_r", "-", "1", ",", "e_r", ")", ")", "\n", "", "elif", "degree_dl_kind", "==", "\"distributed\"", ":", "\n", "        ", "if", "len", "(", "__q_cache", ")", "==", "1", ":", "\n", "            ", "__q_cache", "=", "init_q_cache", "(", "q_cache_max_e_r", ",", "__q_cache", ")", "# the pre-computed lookup table affects precision!", "\n", "", "for", "ind", ",", "n_r_", "in", "enumerate", "(", "n_r", ")", ":", "\n", "            ", "ent", "+=", "log_q", "(", "e_r", "[", "ind", "]", ",", "n_r_", ",", "__q_cache", ")", "\n", "", "eta_rk", "=", "assemble_eta_rk_from_edgelist_and_mb", "(", "edgelist", ",", "mb", ")", "\n", "\n", "for", "mb_", ",", "eta_rk_", "in", "enumerate", "(", "eta_rk", ")", ":", "\n", "            ", "for", "eta", "in", "eta_rk_", ":", "\n", "                ", "ent", "-=", "+", "gammaln", "(", "eta", "+", "1", ")", "\n", "", "ent", "-=", "-", "gammaln", "(", "n_r", "[", "mb_", "]", "+", "1", ")", "\n", "", "", "elif", "degree_dl_kind", "==", "\"entropy\"", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "ent", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.virtual_moves_ds": [[309, 360], ["np.sum", "np.zeros", "np.int_", "np.sum", "np.sum", "np.sum", "gammaln", "np.max", "np.max", "np.max", "gammaln", "gammaln", "gammaln", "gammaln", "gammaln", "_.split", "_.split", "np.max", "np.max"], "function", ["None"], ["", "def", "virtual_moves_ds", "(", "ori_e_rs", ",", "mlists", ",", "ka", ")", ":", "\n", "    ", "\"\"\"virtual_moves_ds\n\n    virtual_moves_ds\n\n    Parameters\n    ----------\n    ori_e_rs : :class:`numpy.ndarray`\n\n    mlists : ``set``\n\n    ka : ``int``\n        Number of communities in type-*a*.\n\n    Returns\n    -------\n    dS : ``float``\n\n    _mlist : :class:`numpy.ndarray`\n\n    \"\"\"", "\n", "ori_e_r", "=", "np", ".", "sum", "(", "ori_e_rs", ",", "axis", "=", "1", ")", "\n", "size", "=", "ori_e_rs", ".", "shape", "[", "0", "]", "-", "1", "\n", "t", "=", "np", ".", "inf", "\n", "dS", "=", "0.", "\n", "_mlist", "=", "np", ".", "zeros", "(", "2", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n", "for", "_", "in", "mlists", ":", "\n", "        ", "mlist", "=", "np", ".", "int_", "(", "[", "_", ".", "split", "(", "\"+\"", ")", "[", "0", "]", ",", "_", ".", "split", "(", "\"+\"", ")", "[", "1", "]", "]", ")", "\n", "if", "(", "np", ".", "max", "(", "mlist", ")", ">=", "ka", ">", "np", ".", "max", "(", "mlist", ")", ")", "or", "(", "np", ".", "max", "(", "mlist", ")", "==", "0", "and", "ka", "==", "1", ")", "or", "(", "\n", "np", ".", "max", "(", "mlist", ")", "==", "ka", "and", "ori_e_rs", ".", "shape", "[", "0", "]", "==", "1", "+", "ka", ")", ":", "\n", "            ", "continue", "\n", "", "else", ":", "\n", "            ", "if", "np", ".", "max", "(", "mlist", ")", "<", "ka", ":", "# we are merging groups of type-a", "\n", "                ", "_1", ",", "_2", "=", "ori_e_rs", "[", "[", "mlist", "[", "0", "]", ",", "mlist", "[", "1", "]", "]", ",", "ka", "+", "1", ":", "size", "+", "1", "]", "\n", "", "else", ":", "\n", "                ", "_1", ",", "_2", "=", "ori_e_rs", "[", "[", "mlist", "[", "0", "]", ",", "mlist", "[", "1", "]", "]", ",", "0", ":", "ka", "]", "\n", "", "_ds", "=", "0", "\n", "_ds", "-=", "np", ".", "sum", "(", "gammaln", "(", "_1", "+", "_2", "+", "1", ")", ")", "\n", "_ds", "+=", "np", ".", "sum", "(", "gammaln", "(", "_1", "+", "1", ")", ")", "\n", "_ds", "+=", "np", ".", "sum", "(", "gammaln", "(", "_2", "+", "1", ")", ")", "\n", "\n", "_3", ",", "_4", "=", "ori_e_r", "[", "[", "mlist", "[", "0", "]", ",", "mlist", "[", "1", "]", "]", "]", "\n", "_ds", "+=", "gammaln", "(", "_3", "+", "_4", "+", "1", ")", "\n", "_ds", "-=", "gammaln", "(", "_3", "+", "1", ")", "+", "gammaln", "(", "_4", "+", "1", ")", "\n", "\n", "if", "0", "<=", "_ds", "<", "t", ":", "\n", "                ", "t", "=", "_ds", "\n", "dS", ",", "_mlist", "=", "_ds", ",", "mlist", "\n", "\n", "", "", "", "return", "dS", ",", "_mlist", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.gen_equal_partition": [[367, 387], ["np.arange", "list", "map", "np.array_split"], "function", ["None"], ["", "def", "gen_equal_partition", "(", "n", ",", "total", ")", ":", "\n", "    ", "\"\"\"gen_equal_partition\n\n    gen_equal_partition\n\n    Parameters\n    ----------\n    n : ``int``\n\n    total : ``int``\n\n    Returns\n    -------\n    n_blocks : ``list``\n\n    \"\"\"", "\n", "all_nodes", "=", "np", ".", "arange", "(", "total", ")", "\n", "n_blocks", "=", "list", "(", "map", "(", "len", ",", "np", ".", "array_split", "(", "all_nodes", ",", "n", ")", ")", ")", "\n", "\n", "return", "n_blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.gen_unequal_partition": [[389, 429], ["list", "int", "enumerate", "np.random.dirichlet", "np.all", "map", "range", "np.random.dirichlet", "sum", "max", "min"], "function", ["None"], ["", "def", "gen_unequal_partition", "(", "n", ",", "total", ",", "avg_deg", ",", "alpha", ")", ":", "\n", "    ", "\"\"\"gen_unequal_partition\n\n    Parameters\n    ----------\n    n : ``int``\n        Number of communities.\n\n    total : ``int``\n        Number of nodes.\n\n    avg_deg : ``float``\n        Average degree of the network.\n\n    alpha : ``float``\n        The parameter of the Dirichlet distribution (the smaller the unevener the distribution is).\n        We usually use alpha=1 to generate a case and\n        filter it out if the lowest size of a community is less than (2 * total / avg_deg) ** 0.5 (resolution limit).\n\n    Returns\n    -------\n    a : ``list``\n        The sizes of communities to sum to `total`.\n\n    _ : ``float``\n        The ratio of largest-sized community to the lowest-sized one.\n\n    \"\"\"", "\n", "cutoff", "=", "(", "2", "*", "total", "/", "avg_deg", ")", "**", "0.5", "\n", "d", "=", "np", ".", "random", ".", "dirichlet", "(", "[", "alpha", "]", "*", "n", ",", "1", ")", "[", "0", "]", "\n", "\n", "while", "not", "np", ".", "all", "(", "d", "*", "total", ">", "cutoff", ")", ":", "\n", "        ", "d", "=", "np", ".", "random", ".", "dirichlet", "(", "[", "alpha", "]", "*", "n", ",", "1", ")", "[", "0", "]", "\n", "\n", "", "a", "=", "list", "(", "map", "(", "int", ",", "d", "*", "total", ")", ")", "\n", "remain_a", "=", "int", "(", "total", "-", "sum", "(", "a", ")", ")", "\n", "for", "idx", ",", "_", "in", "enumerate", "(", "range", "(", "remain_a", ")", ")", ":", "\n", "        ", "a", "[", "idx", "]", "+=", "1", "\n", "\n", "", "return", "a", ",", "max", "(", "a", ")", "/", "min", "(", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.gen_e_rs": [[431, 467], ["np.zeros", "itertools.product", "np.linspace", "enumerate", "range", "range"], "function", ["None"], ["", "def", "gen_e_rs", "(", "b", ",", "n_edges", ",", "p", "=", "0", ")", ":", "\n", "    ", "\"\"\"gen_e_rs\n\n    Parameters\n    ----------\n    b : ``int``\n        Number of communities within each type. (suppose Ka = Kb)\n\n    n_edges : ``int``\n        Number of edges planted in the system.\n\n    p : ``float``\n        Edge propensity between groups; i.e., the ratio :math:`c_{out} / c_{in}`.\n\n    Returns\n    -------\n    e_rs : :class:`numpy.ndarray`\n        Edge counts matrix.\n\n    \"\"\"", "\n", "c", "=", "n_edges", "/", "(", "b", "+", "(", "b", "**", "2", "-", "b", ")", "*", "p", ")", "\n", "c_in", "=", "c", "\n", "c_out", "=", "c", "*", "p", "\n", "e_rs", "=", "np", ".", "zeros", "(", "(", "b", "*", "2", ",", "b", "*", "2", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n", "perm", "=", "product", "(", "range", "(", "0", ",", "b", ")", ",", "range", "(", "b", ",", "b", "*", "2", ")", ")", "\n", "idx_in", "=", "np", ".", "linspace", "(", "0", ",", "b", "**", "2", "-", "1", ",", "b", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "for", "idx", ",", "p", "in", "enumerate", "(", "perm", ")", ":", "\n", "        ", "i", "=", "p", "[", "0", "]", "\n", "j", "=", "p", "[", "1", "]", "\n", "if", "idx", "in", "idx_in", ":", "\n", "            ", "e_rs", "[", "i", "]", "[", "j", "]", "=", "c_in", "\n", "", "else", ":", "\n", "            ", "e_rs", "[", "i", "]", "[", "j", "]", "=", "c_out", "\n", "", "e_rs", "[", "j", "]", "[", "i", "]", "=", "e_rs", "[", "i", "]", "[", "j", "]", "\n", "", "return", "e_rs", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.gen_e_rs_harder": [[469, 519], ["range", "ValueError", "int", "np.int_", "np.zeros", "enumerate", "itertools.product", "enumerate", "heapq.heappush", "heapq.heappop", "range", "np.sum", "range", "range", "range", "np.random.dirichlet", "utils.compute_profile_likelihood_from_e_rs", "heapq.heappop"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.compute_profile_likelihood_from_e_rs"], ["", "def", "gen_e_rs_harder", "(", "ka", ",", "kb", ",", "n_edges", ",", "samples", "=", "1", ",", "top_k", "=", "1", ")", ":", "\n", "    ", "\"\"\"gen_e_rs_harder\n\n    Parameters\n    ----------\n    ka : ``int``\n        Number of communities within type-*a*.\n\n    kb : ``int``\n        Number of communities within type-*b*.\n\n    n_edges : ``int``\n        Number of edges planted in the system.\n\n    samples : ``int``\n        Number of random draws made on :math:`e_{rs}`.\n\n    top_k : ``int``\n        Number of samples selected. These are `top-k` samples with higher profile likelihood.\n\n    Returns\n    -------\n    e_rs : :class:`numpy.ndarray` or ``list[numpy.ndarray]`` (when ``top_k > 1``)\n        Edge counts matrix.\n\n    \"\"\"", "\n", "if", "top_k", "<=", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\"Argument `top_k` needs to be a positive integer.\"", ")", "\n", "", "e_rs_inst", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "int", "(", "samples", ")", ")", ":", "\n", "        ", "c", "=", "np", ".", "int_", "(", "np", ".", "random", ".", "dirichlet", "(", "[", "1", "]", "*", "ka", "*", "kb", ",", "1", ")", "[", "0", "]", "*", "n_edges", ")", "\n", "e_rs", "=", "np", ".", "zeros", "(", "(", "ka", "+", "kb", ",", "ka", "+", "kb", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "remain_c", "=", "n_edges", "-", "np", ".", "sum", "(", "c", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "for", "idx", ",", "_", "in", "enumerate", "(", "range", "(", "remain_c", ")", ")", ":", "\n", "            ", "c", "[", "idx", "]", "+=", "1", "\n", "", "perm", "=", "product", "(", "range", "(", "0", ",", "ka", ")", ",", "range", "(", "ka", ",", "ka", "+", "kb", ")", ")", "\n", "for", "idx", ",", "p", "in", "enumerate", "(", "perm", ")", ":", "\n", "            ", "i", "=", "p", "[", "0", "]", "\n", "j", "=", "p", "[", "1", "]", "\n", "e_rs", "[", "i", "]", "[", "j", "]", "=", "c", "[", "idx", "]", "\n", "e_rs", "[", "j", "]", "[", "i", "]", "=", "e_rs", "[", "i", "]", "[", "j", "]", "\n", "", "heapq", ".", "heappush", "(", "e_rs_inst", ",", "(", "-", "compute_profile_likelihood_from_e_rs", "(", "e_rs", ")", ",", "e_rs", ")", ")", "\n", "", "e_rs", "=", "heapq", ".", "heappop", "(", "e_rs_inst", ")", "[", "1", "]", "\n", "if", "samples", "==", "1", "or", "top_k", "==", "1", ":", "\n", "        ", "return", "e_rs", "\n", "", "else", ":", "\n", "        ", "e_rs", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "top_k", ")", ":", "\n", "            ", "e_rs", "+=", "[", "heapq", ".", "heappop", "(", "e_rs_inst", ")", "[", "1", "]", "]", "\n", "", "return", "e_rs", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.gen_e_rs_hard": [[521, 579], ["max", "min", "np.zeros", "itertools.product", "enumerate", "scipy.special.comb", "range", "range", "range", "int", "scipy.special.comb", "list", "itertools.combinations", "range"], "function", ["None"], ["", "", "def", "gen_e_rs_hard", "(", "ka", ",", "kb", ",", "n_edges", ",", "p", "=", "0", ")", ":", "\n", "    ", "\"\"\"gen_e_rs_hard\n\n    Parameters\n    ----------\n    ka : ``int``\n        Mumber of communities within type-*a*.\n\n    kb : ``int``\n        Number of communities within type-*b*.\n\n    n_edges : ``int``\n        Number of edges planted in the system.\n\n    p : ``float``\n        Edge propensity between groups; i.e., the ratio :math:`c_{out} / c_{in}`.\n\n    Returns\n    -------\n    e_rs : :class:`numpy.ndarray`\n        Edge counts matrix.\n\n    \"\"\"", "\n", "k_max", "=", "max", "(", "ka", ",", "kb", ")", "\n", "k_min", "=", "min", "(", "ka", ",", "kb", ")", "\n", "if", "k_max", ">", "2", "**", "k_min", "-", "1", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "else", ":", "\n", "        ", "blocks", "=", "0", "\n", "k_min_", "=", "1", "\n", "_cum_comb", "=", "0", "\n", "cum_comb", "=", "comb", "(", "k_min", ",", "1", ")", "\n", "nonzero_indices", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "k_max", "+", "1", ")", ":", "\n", "            ", "if", "i", ">", "cum_comb", ":", "\n", "                ", "k_min_", "+=", "1", "\n", "_cum_comb", "=", "int", "(", "cum_comb", ")", "\n", "cum_comb", "+=", "comb", "(", "k_min", ",", "k_min_", ")", "\n", "\n", "", "blocks", "+=", "k_min_", "\n", "for", "__i", "in", "list", "(", "combinations", "(", "range", "(", "k_min", ")", ",", "k_min_", ")", ")", "[", "i", "-", "_cum_comb", "-", "1", "]", ":", "\n", "                ", "nonzero_indices", "+=", "[", "(", "__i", ",", "i", "-", "1", "+", "k_min", ")", "]", "\n", "\n", "", "", "", "c", "=", "n_edges", "/", "(", "blocks", "+", "(", "ka", "*", "kb", "-", "blocks", ")", "*", "p", ")", "\n", "c_in", "=", "c", "\n", "c_out", "=", "c", "*", "p", "\n", "\n", "e_rs", "=", "np", ".", "zeros", "(", "(", "ka", "+", "kb", ",", "ka", "+", "kb", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "perm", "=", "product", "(", "range", "(", "0", ",", "ka", ")", ",", "range", "(", "ka", ",", "ka", "+", "kb", ")", ")", "\n", "for", "_", ",", "p", "in", "enumerate", "(", "perm", ")", ":", "\n", "        ", "i", "=", "p", "[", "0", "]", "\n", "j", "=", "p", "[", "1", "]", "\n", "if", "(", "i", ",", "j", ")", "in", "nonzero_indices", ":", "\n", "            ", "e_rs", "[", "i", "]", "[", "j", "]", "=", "c_in", "\n", "", "else", ":", "\n", "            ", "e_rs", "[", "i", "]", "[", "j", "]", "=", "c_out", "\n", "", "e_rs", "[", "j", "]", "[", "i", "]", "=", "e_rs", "[", "i", "]", "[", "j", "]", "\n", "", "return", "e_rs", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.gen_equal_bipartite_partition": [[581, 608], ["map", "enumerate", "np.array", "utils.gen_equal_partition", "utils.gen_equal_partition"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.gen_equal_partition", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.gen_equal_partition"], ["", "def", "gen_equal_bipartite_partition", "(", "na", ",", "nb", ",", "ka", ",", "kb", ")", ":", "\n", "    ", "\"\"\"gen_equal_bipartite_partition\n\n    Parameters\n    ----------\n    na : ``int``\n        Number of nodes in type-*a*.\n\n    nb : ``int``\n        Number of nodes in type-*b*.\n\n    ka : ``int``\n        Number of communities in type-*a*.\n\n    kb : ``int``\n        Number of communities in type-*b*.\n\n    Returns\n    -------\n    n : :class:`numpy.ndarray`\n\n    \"\"\"", "\n", "n_blocks", "=", "map", "(", "int", ",", "gen_equal_partition", "(", "ka", ",", "na", ")", "+", "gen_equal_partition", "(", "kb", ",", "nb", ")", ")", "\n", "n", "=", "[", "]", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "n_blocks", ")", ":", "\n", "        ", "n", "+=", "[", "idx", "]", "*", "i", "\n", "", "return", "np", ".", "array", "(", "n", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.gen_bicliques_edgelist": [[610, 646], ["numba.njit", "np.zeros", "int", "np.zeros", "range", "range", "int", "range", "int"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "gen_bicliques_edgelist", "(", "b", ",", "num_nodes", ")", ":", "\n", "    ", "\"\"\"Generate an array of edgelist and node-type mapping for a group of bi-cliques.\n\n    Parameters\n    ----------\n    b : ``int``\n       Number of bi-cliques.\n    num_nodes : ``int``\n       Number of nodes (size) for each bi-clique.\n\n    Returns\n    -------\n    el : :class:`numpy.ndarray`\n        The edgelist of a group of bi-cliques.\n\n    types : :class:`numpy.ndarray`\n        The types-array that maps each node id to a bipartite type (``0`` or ``1``).\n\n    \"\"\"", "\n", "total_num_nodes", "=", "b", "*", "num_nodes", "\n", "types", "=", "np", ".", "zeros", "(", "total_num_nodes", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "num_edges_each_clique", "=", "int", "(", "num_nodes", "**", "2", "/", "4", ")", "\n", "el", "=", "np", ".", "zeros", "(", "(", "num_edges_each_clique", "*", "b", ",", "2", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n", "idx", "=", "0", "\n", "base", "=", "0", "\n", "for", "_b", "in", "range", "(", "0", ",", "b", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "0", ",", "int", "(", "num_nodes", "/", "2", ")", ")", ":", "\n", "            ", "types", "[", "i", "+", "base", "]", "=", "1", "\n", "for", "j", "in", "range", "(", "int", "(", "num_nodes", "/", "2", ")", ",", "num_nodes", ")", ":", "\n", "                ", "types", "[", "j", "+", "base", "]", "=", "2", "\n", "el", "[", "idx", "]", "=", "[", "i", "+", "base", ",", "j", "+", "base", "]", "\n", "idx", "+=", "1", "\n", "", "", "base", "=", "(", "_b", "+", "1", ")", "*", "num_nodes", "\n", "", "return", "el", ",", "types", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_old2new_mapping": [[648, 685], ["dict", "np.zeros", "enumerate", "enumerate", "len", "dict.items"], "function", ["None"], ["", "def", "assemble_old2new_mapping", "(", "types", ")", ":", "\n", "    ", "\"\"\"Create a mapping that map the old node-id's to new ones, such that the types-array is sorted orderly.\n\n    Parameters\n    ----------\n    types : :class:`numpy.ndarray`\n\n    Returns\n    -------\n    old2new : ``dict``\n        Dictionary that maps the old node index to a new one.\n\n    new2old : ``dict``\n        Dictionary that maps the new node index to the old one; i.e., a reverse mapping of ``old2new``.\n\n    new_types : :class:`numpy.ndarray`\n        The new types-array, which is sorted orderly and directly applicable to :class:`det_k_bisbm.OptimalKs`.\n\n    \"\"\"", "\n", "old2new", "=", "dict", "(", ")", "\n", "new_types", "=", "np", ".", "zeros", "(", "len", "(", "types", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n", "new_id", "=", "0", "\n", "for", "_id", ",", "t", "in", "enumerate", "(", "types", ")", ":", "\n", "        ", "if", "t", "==", "1", ":", "\n", "            ", "old2new", "[", "_id", "]", "=", "new_id", "\n", "new_types", "[", "new_id", "]", "=", "1", "\n", "new_id", "+=", "1", "\n", "\n", "", "", "for", "_id", ",", "t", "in", "enumerate", "(", "types", ")", ":", "\n", "        ", "if", "t", "==", "2", ":", "\n", "            ", "old2new", "[", "_id", "]", "=", "new_id", "\n", "new_types", "[", "new_id", "]", "=", "2", "\n", "new_id", "+=", "1", "\n", "\n", "", "", "new2old", "=", "{", "value", ":", "key", "for", "key", ",", "value", "in", "old2new", ".", "items", "(", ")", "}", "\n", "return", "old2new", ",", "new2old", ",", "new_types", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_edgelist_old2new": [[692, 713], ["np.zeros", "enumerate", "len"], "function", ["None"], ["", "def", "assemble_edgelist_old2new", "(", "edgelist", ",", "old2new", ")", ":", "\n", "    ", "\"\"\"Assemble the new edgelist array via an old2new mapping.\n\n    Parameters\n    ----------\n    edgelist : :class:`numpy.ndarray`\n\n    old2new : ``dict``\n        Dictionary that maps the old node index to a new one.\n\n    Returns\n    -------\n    el : :class:`numpy.ndarray`\n      The new edgelist of a group of bi-cliques (directly pluggable to :class:`det_k_bisbm.OptimalKs`)\n\n    \"\"\"", "\n", "el", "=", "np", ".", "zeros", "(", "(", "len", "(", "edgelist", ")", ",", "2", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "for", "_id", ",", "_", "in", "enumerate", "(", "edgelist", ")", ":", "\n", "        ", "el", "[", "_id", "]", "[", "0", "]", "=", "old2new", "[", "_", "[", "0", "]", "]", "\n", "el", "[", "_id", "]", "[", "1", "]", "=", "old2new", "[", "_", "[", "1", "]", "]", "\n", "", "return", "el", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_mb_new2old": [[715, 737], ["numba.njit", "np.zeros", "enumerate", "len"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "assemble_mb_new2old", "(", "mb", ",", "new2old", ")", ":", "\n", "    ", "\"\"\"Assemble the partition that corresponds to the old space of node indices.\n\n    Parameters\n    ----------\n    mb : :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    new2old : ``dict``\n        Dictionary that maps the new node index to the old one; i.e., a reverse mapping of ``old2new``.\n\n    Returns\n    -------\n    old_mb : :class:`numpy.ndarray`\n      The partition that corresponds to the old space of node indices.\n\n    \"\"\"", "\n", "old_mb", "=", "np", ".", "zeros", "(", "len", "(", "mb", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "for", "_id", ",", "_", "in", "enumerate", "(", "mb", ")", ":", "\n", "        ", "old_mb", "[", "new2old", "[", "_id", "]", "]", "=", "_", "\n", "", "return", "old_mb", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_n_r_from_mb": [[739, 758], ["numba.njit", "np.zeros", "np.array", "np.max", "int"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "assemble_n_r_from_mb", "(", "mb", ")", ":", "\n", "    ", "\"\"\"Get :math:`n_r`, i.e., the number of nodes in each group, from the partition :math:`b`.\n\n    Parameters\n    ----------\n    mb : ``iterable`` or :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    Returns\n    -------\n    n_r : :class:`numpy.ndarray`\n\n    \"\"\"", "\n", "n_r", "=", "np", ".", "zeros", "(", "np", ".", "max", "(", "mb", ")", "+", "1", ")", "\n", "for", "block_id", "in", "mb", ":", "\n", "        ", "n_r", "[", "block_id", "]", "+=", "1", "\n", "", "n_r", "=", "np", ".", "array", "(", "[", "int", "(", "x", ")", "for", "x", "in", "n_r", "]", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "return", "n_r", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_n_k_from_edgelist": [[760, 788], ["numba.njit", "np.zeros", "range", "np.int_", "np.zeros", "len", "np.max", "len"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "assemble_n_k_from_edgelist", "(", "edgelist", ",", "mb", ")", ":", "\n", "    ", "\"\"\"Get :math:`n_k`, i.e., the number :math:`n_k` of nodes of degree :math:`k`.\n\n    Parameters\n    ----------\n    edgelist : :class:`numpy.ndarray`\n        List of edge tuples.\n\n    mb : :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    Returns\n    -------\n    n_k : :class:`numpy.ndarray`\n        Array of the number of nodes of degree :math:`k`.\n\n    \"\"\"", "\n", "k", "=", "np", ".", "zeros", "(", "len", "(", "mb", ")", "+", "1", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "for", "idx", "in", "range", "(", "len", "(", "edgelist", ")", ")", ":", "\n", "        ", "k", "[", "edgelist", "[", "idx", "]", "[", "0", "]", "]", "+=", "1", "\n", "k", "[", "edgelist", "[", "idx", "]", "[", "1", "]", "]", "+=", "1", "\n", "\n", "", "max_", "=", "np", ".", "int_", "(", "np", ".", "max", "(", "k", ")", ")", "\n", "n_k", "=", "np", ".", "zeros", "(", "max_", "+", "1", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "for", "k_", "in", "k", ":", "\n", "        ", "n_k", "[", "k_", "]", "+=", "1", "\n", "", "return", "n_k", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_e_rs_from_mb": [[790, 815], ["zip", "np.ones", "int", "scipy.sparse.coo_matrix", "scipy.sparse.coo_matrix.toarray", "len", "np.max"], "function", ["None"], ["", "def", "assemble_e_rs_from_mb", "(", "edgelist", ",", "mb", ")", ":", "\n", "    ", "\"\"\"Get :math:`e_{rs}`, i.e., the matrix of edge counts between blocks.\n\n    Parameters\n    ----------\n    edgelist : :class:`numpy.ndarray`\n        List of edge tuples.\n\n    mb : :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    Returns\n    -------\n    e_rs : :class:`numpy.ndarray`\n        Edge count matrix :math:`e_{rs}`.\n\n    \"\"\"", "\n", "sources", ",", "targets", "=", "zip", "(", "*", "edgelist", ")", "\n", "sources", "=", "[", "mb", "[", "node", "]", "for", "node", "in", "sources", "]", "\n", "targets", "=", "[", "mb", "[", "node", "]", "for", "node", "in", "targets", "]", "\n", "data", "=", "np", ".", "ones", "(", "len", "(", "sources", "+", "targets", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "shape", "=", "int", "(", "np", ".", "max", "(", "mb", ")", "+", "1", ")", "\n", "e_rs", "=", "coo_matrix", "(", "(", "data", ",", "(", "sources", "+", "targets", ",", "targets", "+", "sources", ")", ")", ",", "shape", "=", "(", "shape", ",", "shape", ")", ")", "\n", "\n", "return", "e_rs", ".", "toarray", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.assemble_eta_rk_from_edgelist_and_mb": [[817, 853], ["numba.njit", "np.int_", "np.zeros", "range", "np.empty", "range", "np.max", "np.zeros", "range", "np.max", "len", "len", "np.max", "enumerate", "len"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "assemble_eta_rk_from_edgelist_and_mb", "(", "edgelist", ",", "mb", ")", ":", "\n", "    ", "\"\"\"Get :math:`\\eta_{rk}`, or the number :math:`\\eta_{rk}` of nodes of degree :math:`k` that belong to group :math:`r`.\n\n    Parameters\n    ----------\n    edgelist : :class:`numpy.ndarray`\n\n    mb : :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    Returns\n    -------\n    eta_rk : :class:`numpy.ndarray`\n\n    \"\"\"", "\n", "mb_max_", "=", "np", ".", "int_", "(", "np", ".", "max", "(", "mb", ")", ")", "\n", "\n", "k", "=", "np", ".", "zeros", "(", "(", "mb_max_", "+", "1", ",", "len", "(", "mb", ")", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n", "for", "idx", "in", "range", "(", "len", "(", "edgelist", ")", ")", ":", "\n", "        ", "k", "[", "mb", "[", "edgelist", "[", "idx", "]", "[", "0", "]", "]", "]", "[", "edgelist", "[", "idx", "]", "[", "0", "]", "]", "+=", "1", "\n", "k", "[", "mb", "[", "edgelist", "[", "idx", "]", "[", "1", "]", "]", "]", "[", "edgelist", "[", "idx", "]", "[", "1", "]", "]", "+=", "1", "\n", "\n", "", "max_array", "=", "np", ".", "empty", "(", "k", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "for", "_k_idx", "in", "range", "(", "len", "(", "k", ")", ")", ":", "\n", "        ", "max_array", "[", "_k_idx", "]", "=", "np", ".", "max", "(", "k", "[", "_k_idx", "]", ")", "\n", "", "max_", "=", "np", ".", "max", "(", "max_array", ")", "\n", "\n", "eta_rk", "=", "np", ".", "zeros", "(", "(", "mb_max_", "+", "1", ",", "max_", "+", "1", ")", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "for", "mb_", "in", "range", "(", "mb_max_", "+", "1", ")", ":", "\n", "        ", "for", "node_idx", ",", "k_", "in", "enumerate", "(", "k", "[", "mb_", "]", ")", ":", "\n", "            ", "if", "mb", "[", "node_idx", "]", "==", "mb_", ":", "\n", "                ", "eta_rk", "[", "mb_", "]", "[", "k_", "]", "+=", "1", "\n", "\n", "", "", "", "return", "eta_rk", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.compute_profile_likelihood": [[855, 911], ["np.zeros", "np.sum", "enumerate", "int", "int", "np.sum.sum", "np.nditer", "int", "np.floor", "max", "max", "ImportError", "np.log", "int", "int"], "function", ["None"], ["", "def", "compute_profile_likelihood", "(", "edgelist", ",", "mb", ",", "ka", "=", "None", ",", "kb", "=", "None", ",", "k", "=", "None", ")", ":", "\n", "    ", "\"\"\"compute_profile_likelihood\n\n    Parameters\n    ----------\n    edgelist : :class:`numpy.ndarray`\n\n    mb : :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    ka : ``int``\n        Number of communities in type-*a*.\n\n    kb : ``int``\n        Number of communities in type-*b*.\n\n    k : ``int``\n        Total number of communities.\n\n    Returns\n    -------\n    italic_i : ``float``\n\n    \"\"\"", "\n", "# First, let's compute the m_e_rs from the edgelist and mb", "\n", "m_e_rs", "=", "np", ".", "zeros", "(", "(", "max", "(", "mb", ")", "+", "1", ",", "max", "(", "mb", ")", "+", "1", ")", ")", "\n", "for", "i", "in", "edgelist", ":", "\n", "# Please do check the index convention of the edgelist", "\n", "        ", "source_group", "=", "int", "(", "mb", "[", "int", "(", "i", "[", "0", "]", ")", "]", ")", "\n", "target_group", "=", "int", "(", "mb", "[", "int", "(", "i", "[", "1", "]", ")", "]", ")", "\n", "if", "ka", "is", "not", "None", "or", "kb", "is", "not", "None", ":", "\n", "            ", "if", "source_group", "==", "target_group", ":", "\n", "                ", "raise", "ImportError", "(", "\"This is not a bipartite network!\"", ")", "\n", "", "", "m_e_rs", "[", "source_group", "]", "[", "target_group", "]", "+=", "1", "\n", "m_e_rs", "[", "target_group", "]", "[", "source_group", "]", "+=", "1", "\n", "\n", "# then, we compute the profile likelihood from the m_e_rs", "\n", "", "italic_i", "=", "0.", "\n", "m_e_r", "=", "np", ".", "sum", "(", "m_e_rs", ",", "axis", "=", "1", ")", "\n", "num_edges", "=", "m_e_r", ".", "sum", "(", ")", "/", "2.", "\n", "for", "ind", ",", "e_val", "in", "enumerate", "(", "np", ".", "nditer", "(", "m_e_rs", ")", ")", ":", "\n", "        ", "ind_i", "=", "int", "(", "np", ".", "floor", "(", "ind", "/", "(", "m_e_rs", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "ind_j", "=", "ind", "%", "(", "m_e_rs", ".", "shape", "[", "0", "]", ")", "\n", "if", "e_val", "!=", "0.0", ":", "\n", "            ", "italic_i", "+=", "e_val", "/", "2.", "/", "num_edges", "*", "np", ".", "log", "(", "\n", "e_val", "/", "m_e_r", "[", "ind_i", "]", "/", "m_e_r", "[", "ind_j", "]", "*", "2", "*", "num_edges", "\n", ")", "\n", "", "", "if", "ka", "is", "not", "None", "or", "kb", "is", "not", "None", ":", "\n", "        ", "assert", "m_e_rs", ".", "shape", "[", "0", "]", "==", "ka", "+", "kb", ",", "\"[ERROR] m_e_rs dimension (={}) is not equal to ka (={}) + kb (={})!\"", ".", "format", "(", "\n", "m_e_rs", ".", "shape", "[", "0", "]", ",", "ka", ",", "kb", "\n", ")", "\n", "", "elif", "k", "is", "not", "None", ":", "\n", "        ", "assert", "m_e_rs", ".", "shape", "[", "0", "]", "==", "k", ",", "\"[ERROR] m_e_rs dimension (={}) is not equal to k (={})!\"", ".", "format", "(", "\n", "m_e_rs", ".", "shape", "[", "0", "]", ",", "k", "\n", ")", "\n", "", "return", "italic_i", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.compute_profile_likelihood_from_e_rs": [[913, 937], ["numba.njit", "np.sum", "enumerate", "np.sum.sum", "np.nditer", "np.int_", "np.floor", "np.log"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "compute_profile_likelihood_from_e_rs", "(", "e_rs", ")", ":", "\n", "    ", "\"\"\"compute_profile_likelihood_from_e_rs\n\n    Parameters\n    ----------\n    e_rs : :class:`numpy.ndarray`\n\n    Returns\n    -------\n    italic_i : ``float``\n\n    \"\"\"", "\n", "italic_i", "=", "0.", "\n", "e_r", "=", "np", ".", "sum", "(", "e_rs", ",", "axis", "=", "1", ")", "\n", "num_edges", "=", "e_r", ".", "sum", "(", ")", "/", "2.", "\n", "for", "ind", ",", "e_val", "in", "enumerate", "(", "np", ".", "nditer", "(", "e_rs", ")", ")", ":", "\n", "        ", "ind_i", "=", "np", ".", "int_", "(", "np", ".", "floor", "(", "ind", "/", "(", "e_rs", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "ind_j", "=", "ind", "%", "(", "e_rs", ".", "shape", "[", "0", "]", ")", "\n", "if", "e_val", "!=", "0.0", ":", "\n", "            ", "italic_i", "+=", "e_val", "/", "2.", "/", "num_edges", "*", "np", ".", "log", "(", "\n", "e_val", "/", "e_r", "[", "ind_i", "]", "/", "e_r", "[", "ind_j", "]", "*", "2", "*", "num_edges", "\n", ")", "\n", "", "", "return", "italic_i", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.get_desc_len_from_data": [[939, 1001], ["np.array", "desc_len.__float__", "utils.compute_profile_likelihood", "utils.adjacency_entropy", "utils.model_entropy", "utils.degree_entropy", "float", "np.log", "np.log", "np.log", "np.log", "np.log", "np.log", "np.log"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.compute_profile_likelihood", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.adjacency_entropy", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.model_entropy", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.degree_entropy"], ["", "def", "get_desc_len_from_data", "(", "na", ",", "nb", ",", "n_edges", ",", "ka", ",", "kb", ",", "edgelist", ",", "mb", ",", "diff", "=", "False", ",", "nr", "=", "None", ",", "allow_empty", "=", "False", ",", "\n", "degree_dl_kind", "=", "\"distributed\"", ",", "q_cache", "=", "np", ".", "array", "(", "[", "]", ",", "ndmin", "=", "2", ")", ",", "is_bipartite", "=", "True", ")", ":", "\n", "    ", "\"\"\"Description length difference to a randomized instance\n\n    Parameters\n    ----------\n    na : ``int``\n        Number of nodes in type-*a*.\n\n    nb : ``int``\n        Number of nodes in type-*b*.\n\n    n_edges : ``int``\n        Number of edges.\n\n    ka : ``int``\n        Number of communities in type-*a*.\n\n    kb : ``int``\n        Number of communities in type-*b*.\n\n    edgelist : :class:`numpy.ndarray`\n        Edgelist in Python list structure.\n\n    mb : :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    diff : ``bool``\n        When `diff == True`,\n        the returned description value will be the difference to that of a random bipartite network. Otherwise, it will\n        return the entropy (a.k.a. negative log-likelihood) associated with the current block partition.\n\n    allow_empty : ``bool``\n\n    nr : :class:`numpy.ndarray`\n\n    degree_dl_kind : str (optional, default: `\"distributed\"`)\n        1. `degree_dl_kind == \"uniform\"`\n        2. `degree_dl_kind == \"distributed\"` (default)\n        3. `degree_dl_kind == \"entropy\"`\n    is_bipartite: `bool` (default: `\"True\"`)\n\n    Returns\n    -------\n    desc_len_b : ``float``\n        Difference of the description length to the bipartite ER network, per edge.\n\n    \"\"\"", "\n", "desc_len", "=", "0.", "\n", "# finally, we compute the description length", "\n", "if", "diff", ":", "# todo: add more options to it; now, only uniform prior for P(e) is included.", "\n", "        ", "italic_i", "=", "compute_profile_likelihood", "(", "edgelist", ",", "mb", ",", "ka", "=", "ka", ",", "kb", "=", "kb", ")", "\n", "desc_len", "+=", "(", "na", "*", "np", ".", "log", "(", "ka", ")", "+", "nb", "*", "np", ".", "log", "(", "kb", ")", "-", "n_edges", "*", "(", "italic_i", "-", "np", ".", "log", "(", "2", ")", ")", ")", "/", "n_edges", "\n", "x", "=", "float", "(", "ka", "*", "kb", ")", "/", "n_edges", "\n", "desc_len", "+=", "(", "1", "+", "x", ")", "*", "np", ".", "log", "(", "1", "+", "x", ")", "-", "x", "*", "np", ".", "log", "(", "x", ")", "\n", "desc_len", "-=", "(", "1", "+", "1", "/", "n_edges", ")", "*", "np", ".", "log", "(", "1", "+", "1", "/", "n_edges", ")", "-", "(", "1", "/", "n_edges", ")", "*", "np", ".", "log", "(", "1", "/", "n_edges", ")", "\n", "", "else", ":", "\n", "        ", "desc_len", "+=", "adjacency_entropy", "(", "edgelist", ",", "mb", ")", "\n", "desc_len", "+=", "model_entropy", "(", "n_edges", ",", "ka", "=", "ka", ",", "kb", "=", "kb", ",", "na", "=", "na", ",", "nb", "=", "nb", ",", "nr", "=", "nr", ",", "allow_empty", "=", "allow_empty", ",", "\n", "is_bipartite", "=", "is_bipartite", ")", "\n", "desc_len", "+=", "degree_entropy", "(", "edgelist", ",", "mb", ",", "__q_cache", "=", "q_cache", ",", "degree_dl_kind", "=", "degree_dl_kind", ")", "\n", "", "return", "desc_len", ".", "__float__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.get_desc_len_from_data_uni": [[1003, 1037], ["utils.compute_profile_likelihood", "float", "np.log", "np.log", "np.log", "np.log", "np.log"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.compute_profile_likelihood"], ["", "def", "get_desc_len_from_data_uni", "(", "n", ",", "n_edges", ",", "k", ",", "edgelist", ",", "mb", ")", ":", "\n", "    ", "\"\"\"Description length difference to a randomized instance, via PRL 110, 148701 (2013).\n\n    Parameters\n    ----------\n    n : ``int``\n        Number of nodes.\n\n    n_edges : ``int``\n        Number of edges.\n\n    k : ``int``\n        Number of communities.\n\n    edgelist : :class:`numpy.ndarray`\n        A list of edges.\n\n    mb : :class:`numpy.ndarray`\n        Partition :math:`b` of nodes into blocks.\n\n    Returns\n    -------\n    desc_len_b : ``float``\n        Difference of the description length to the ER network, per edge.\n\n    \"\"\"", "\n", "italic_i", "=", "compute_profile_likelihood", "(", "edgelist", ",", "mb", ",", "k", "=", "k", ")", "\n", "\n", "# finally, we compute the description length", "\n", "desc_len_b", "=", "(", "n", "*", "np", ".", "log", "(", "k", ")", "-", "n_edges", "*", "italic_i", ")", "/", "n_edges", "\n", "x", "=", "float", "(", "k", "*", "(", "k", "+", "1", ")", ")", "/", "2.", "/", "n_edges", "\n", "desc_len_b", "+=", "(", "1", "+", "x", ")", "*", "np", ".", "log", "(", "1", "+", "x", ")", "-", "x", "*", "np", ".", "log", "(", "x", ")", "\n", "desc_len_b", "-=", "(", "1", "+", "1", "/", "n_edges", ")", "*", "np", ".", "log", "(", "1", "+", "1", "/", "n_edges", ")", "-", "(", "1", "/", "n_edges", ")", "*", "np", ".", "log", "(", "1", "/", "n_edges", ")", "\n", "return", "desc_len_b", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.accept_mb_merge": [[1039, 1069], ["numba.njit", "np.zeros", "mlist.sort", "enumerate"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ",", "fastmath", "=", "True", ")", "\n", "def", "accept_mb_merge", "(", "mb", ",", "mlist", ")", ":", "\n", "    ", "\"\"\"accept_mb_merge\n\n    Accept partition merge.\n\n    Parameters\n    ----------\n    mb : ``iterable`` or :class:`numpy.ndarray`\n        The partition to be merged.\n\n    mlist : ``iterable`` or :class:`numpy.ndarray`\n        The two block labels to be merged.\n\n    Returns\n    -------\n    _mb : :class:`numpy.ndarray`\n        The merged partition.\n\n    \"\"\"", "\n", "_mb", "=", "np", ".", "zeros", "(", "mb", ".", "size", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "mlist", ".", "sort", "(", ")", "\n", "for", "_node_id", ",", "_g", "in", "enumerate", "(", "mb", ")", ":", "\n", "        ", "if", "_g", "==", "mlist", "[", "1", "]", ":", "\n", "            ", "_mb", "[", "_node_id", "]", "=", "mlist", "[", "0", "]", "\n", "", "elif", "_g", "<", "mlist", "[", "1", "]", ":", "\n", "            ", "_mb", "[", "_node_id", "]", "=", "_g", "\n", "", "else", ":", "\n", "            ", "_mb", "[", "_node_id", "]", "=", "_g", "-", "1", "\n", "", "", "return", "_mb", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.loky_executor": [[1076, 1081], ["loky.get_reusable_executor", "loky.get_reusable_executor.map", "type", "str", "type", "int", "int"], "function", ["None"], ["", "def", "loky_executor", "(", "max_workers", ",", "timeout", ",", "func", ",", "feeds", ")", ":", "\n", "    ", "assert", "type", "(", "feeds", ")", "is", "list", ",", "\"[ERROR] feeds should be a Python list; here it is {}\"", ".", "format", "(", "str", "(", "type", "(", "feeds", ")", ")", ")", "\n", "loky_executor", "=", "get_reusable_executor", "(", "max_workers", "=", "int", "(", "max_workers", ")", ",", "timeout", "=", "int", "(", "timeout", ")", ")", "\n", "results", "=", "loky_executor", ".", "map", "(", "func", ",", "feeds", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.get_flat_entropies": [[1087, 1111], ["sum", "dict", "state.entropy", "len", "len", "set", "set", "state.entropy", "state.entropy", "state.entropy", "state.entropy", "state.entropy", "state.entropy", "state.entropy", "state.entropy", "state.b.a.tolist", "state.b.a.tolist"], "function", ["None"], ["", "def", "get_flat_entropies", "(", "state", ")", ":", "\n", "    ", "\"\"\"get_flat_entropies\n\n    Parameters\n    ----------\n    state : :class:`graph_tool.inference.blockmodel.BlockState`\n        The stochastic block model state of a given graph, as defined in Graph-tool.\n\n    Returns\n    -------\n    dl : ``dict``\n        The entropic report of the partition.\n\n    \"\"\"", "\n", "na", "=", "sum", "(", "state", ".", "pclabel", ".", "a", "==", "0", ")", "\n", "dl", "=", "dict", "(", ")", "\n", "dl", "[", "\"mdl\"", "]", "=", "state", ".", "entropy", "(", ")", "\n", "dl", "[", "\"ka\"", "]", "=", "len", "(", "set", "(", "state", ".", "b", ".", "a", ".", "tolist", "(", ")", "[", ":", "na", "]", ")", ")", "\n", "dl", "[", "\"kb\"", "]", "=", "len", "(", "set", "(", "state", ".", "b", ".", "a", ".", "tolist", "(", ")", "[", "na", ":", "]", ")", ")", "\n", "dl", "[", "\"adjacency\"", "]", "=", "state", ".", "entropy", "(", "adjacency", "=", "1", ")", "-", "state", ".", "entropy", "(", "adjacency", "=", "0", ")", "\n", "dl", "[", "\"partition\"", "]", "=", "state", ".", "entropy", "(", "partition_dl", "=", "1", ")", "-", "state", ".", "entropy", "(", "partition_dl", "=", "0", ")", "\n", "dl", "[", "\"degree\"", "]", "=", "state", ".", "entropy", "(", "degree_dl", "=", "1", ")", "-", "state", ".", "entropy", "(", "degree_dl", "=", "0", ")", "\n", "dl", "[", "\"edges\"", "]", "=", "state", ".", "entropy", "(", "edges_dl", "=", "1", ")", "-", "state", ".", "entropy", "(", "edges_dl", "=", "0", ")", "\n", "return", "dl", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.utils.get_nested_entropies": [[1113, 1157], ["sum", "dict", "state.entropy", "len", "len", "range", "sum", "set", "set", "state.levels[].entropy", "state.levels[].entropy", "state.levels[].entropy", "state.levels[].entropy", "state.levels[].entropy", "state.levels[].entropy", "state.levels[].entropy", "state.levels[].entropy", "len", "state.levels[].entropy", "state.levels[].entropy", "state.levels[].entropy", "map", "state.levels[].entropy", "state.levels[].b.a.tolist", "state.levels[].b.a.tolist", "len"], "function", ["None"], ["", "def", "get_nested_entropies", "(", "state", ")", ":", "\n", "    ", "\"\"\"get_nested_entropies\n\n    Parameters\n    ----------\n    state : :class:`graph_tool.inference.nested_blockmodel.NestedBlockState`\n\n    Returns\n    -------\n    dl : ``dict``\n\n    \"\"\"", "\n", "na", "=", "sum", "(", "state", ".", "levels", "[", "0", "]", ".", "pclabel", ".", "a", "==", "0", ")", "\n", "dl", "=", "dict", "(", ")", "\n", "dl", "[", "\"mdl\"", "]", "=", "state", ".", "entropy", "(", ")", "\n", "dl", "[", "\"ka\"", "]", "=", "len", "(", "set", "(", "state", ".", "levels", "[", "0", "]", ".", "b", ".", "a", ".", "tolist", "(", ")", "[", ":", "na", "]", ")", ")", "\n", "dl", "[", "\"kb\"", "]", "=", "len", "(", "set", "(", "state", ".", "levels", "[", "0", "]", ".", "b", ".", "a", ".", "tolist", "(", ")", "[", "na", ":", "]", ")", ")", "\n", "\n", "dl", "[", "\"partition\"", "]", "=", "state", ".", "levels", "[", "0", "]", ".", "entropy", "(", "partition_dl", "=", "1", ")", "-", "state", ".", "levels", "[", "0", "]", ".", "entropy", "(", "partition_dl", "=", "0", ")", "\n", "dl", "[", "\"edges\"", "]", "=", "state", ".", "levels", "[", "0", "]", ".", "entropy", "(", "edges_dl", "=", "1", ")", "-", "state", ".", "levels", "[", "0", "]", ".", "entropy", "(", "edges_dl", "=", "0", ")", "\n", "dl", "[", "\"degree\"", "]", "=", "state", ".", "levels", "[", "0", "]", ".", "entropy", "(", "degree_dl", "=", "1", ")", "-", "state", ".", "levels", "[", "0", "]", ".", "entropy", "(", "degree_dl", "=", "0", ")", "\n", "dl", "[", "\"adjacency\"", "]", "=", "state", ".", "levels", "[", "0", "]", ".", "entropy", "(", "adjacency", "=", "1", ")", "-", "state", ".", "levels", "[", "0", "]", ".", "entropy", "(", "adjacency", "=", "0", ")", "\n", "\n", "multigraph_dls", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "state", ".", "levels", ")", ")", ":", "\n", "        ", "adj", "=", "state", ".", "levels", "[", "i", "]", ".", "entropy", "(", "adjacency", "=", "1", ",", "multigraph", "=", "1", ",", "partition_dl", "=", "0", ",", "degree_dl", "=", "0", ",", "edges_dl", "=", "0", ",", "dense", "=", "1", ")", "\n", "partition", "=", "state", ".", "levels", "[", "i", "]", ".", "entropy", "(", "adjacency", "=", "0", ",", "multigraph", "=", "1", ",", "partition_dl", "=", "1", ",", "degree_dl", "=", "0", ",", "edges_dl", "=", "0", ",", "dense", "=", "1", ")", "\n", "\n", "if", "i", "!=", "len", "(", "state", ".", "levels", ")", "-", "1", ":", "\n", "            ", "edges", "=", "0.", "\n", "", "else", ":", "\n", "            ", "edges", "=", "state", ".", "levels", "[", "i", "]", ".", "entropy", "(", "adjacency", "=", "0", ",", "multigraph", "=", "1", ",", "partition_dl", "=", "0", ",", "degree_dl", "=", "0", ",", "edges_dl", "=", "1", ",", "dense", "=", "1", ")", "\n", "", "degree", "=", "state", ".", "levels", "[", "i", "]", ".", "entropy", "(", "adjacency", "=", "0", ",", "multigraph", "=", "1", ",", "partition_dl", "=", "0", ",", "degree_dl", "=", "1", ",", "edges_dl", "=", "0", ",", "dense", "=", "1", ")", "\n", "total", "=", "adj", "+", "partition", "+", "edges", "+", "degree", "\n", "multigraph_dls", "+=", "[", "{", "\n", "\"sum\"", ":", "total", ",", "\n", "\"adjacency\"", ":", "adj", ",", "\n", "\"partition\"", ":", "partition", ",", "\n", "\"edges\"", ":", "edges", ",", "\n", "\"degree\"", ":", "degree", "\n", "}", "]", "\n", "", "dl", "[", "\"intermediate_dls\"", "]", "=", "multigraph_dls", "\n", "dl", "[", "\"edge_dl_nested\"", "]", "=", "sum", "(", "map", "(", "lambda", "x", ":", "x", "[", "\"sum\"", "]", ",", "multigraph_dls", ")", ")", "\n", "return", "dl", "\n", "", ""]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.docs.extlinks_fancy.make_link_role": [[23, 45], ["docutils.utils.unescape", "sphinx.util.nodes.split_explicit_title", "zip", "base_url.format", "docutils.nodes.reference", "pnodes.append", "len", "pnodes.append", "len", "pnodes.append", "len", "pnodes.append", "docutils.nodes.Text", "prefix.format", "docutils.nodes.Text", "docutils.nodes.Text"], "function", ["None"], ["def", "make_link_role", "(", "base_urls", ",", "prefixes", ")", ":", "\n", "    ", "def", "role", "(", "typ", ",", "rawtext", ",", "text", ",", "lineno", ",", "inliner", ",", "options", "=", "{", "}", ",", "content", "=", "[", "]", ")", ":", "\n", "        ", "text", "=", "utils", ".", "unescape", "(", "text", ")", "\n", "has_explicit_title", ",", "title", ",", "part", "=", "split_explicit_title", "(", "text", ")", "\n", "pnodes", "=", "[", "]", "\n", "for", "base_url", ",", "prefix", "in", "zip", "(", "base_urls", ",", "prefixes", ")", ":", "\n", "            ", "full_url", "=", "base_url", ".", "format", "(", "part", ")", "\n", "if", "not", "has_explicit_title", ":", "\n", "                ", "if", "prefix", "is", "None", ":", "\n", "                    ", "title", "=", "full_url", "\n", "", "else", ":", "\n", "                    ", "title", "=", "prefix", ".", "format", "(", "part", ")", "\n", "", "", "ref", "=", "nodes", ".", "reference", "(", "title", ",", "title", ",", "internal", "=", "False", ",", "refuri", "=", "full_url", ")", "\n", "if", "len", "(", "pnodes", ")", "==", "1", ":", "\n", "                ", "pnodes", ".", "append", "(", "nodes", ".", "Text", "(", "\" [\"", ")", ")", "\n", "", "if", "len", "(", "pnodes", ")", ">", "2", ":", "\n", "                ", "pnodes", ".", "append", "(", "nodes", ".", "Text", "(", "\", \"", ")", ")", "\n", "", "pnodes", ".", "append", "(", "ref", ")", "\n", "", "if", "len", "(", "base_urls", ")", ">", "1", ":", "\n", "            ", "pnodes", ".", "append", "(", "nodes", ".", "Text", "(", "\"]\"", ")", ")", "\n", "", "return", "pnodes", ",", "[", "]", "\n", "", "return", "role", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.docs.extlinks_fancy.setup_link_roles": [[47, 50], ["six.iteritems", "app.add_role", "extlinks_fancy.make_link_role"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.docs.extlinks_fancy.make_link_role"], ["", "def", "setup_link_roles", "(", "app", ")", ":", "\n", "    ", "for", "name", ",", "(", "base_urls", ",", "prefixes", ")", "in", "iteritems", "(", "app", ".", "config", ".", "extlinks_fancy", ")", ":", "\n", "        ", "app", ".", "add_role", "(", "name", ",", "make_link_role", "(", "base_urls", ",", "prefixes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.docs.extlinks_fancy.setup": [[52, 56], ["app.add_config_value", "app.connect"], "function", ["None"], ["", "", "def", "setup", "(", "app", ")", ":", "\n", "    ", "app", ".", "add_config_value", "(", "'extlinks_fancy'", ",", "{", "}", ",", "'env'", ")", "\n", "app", ".", "connect", "(", "'builder-inited'", ",", "setup_link_roles", ")", "\n", "return", "{", "'version'", ":", "sphinx", ".", "__display_version__", ",", "'parallel_read_safe'", ":", "True", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.tests.test_kl.test_answer": [[21, 26], ["oks.minimize_bisbm_dl", "oks.summary", "oks.summary"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.minimize_bisbm_dl", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary"], ["def", "test_answer", "(", ")", ":", "\n", "    ", "oks", ".", "minimize_bisbm_dl", "(", ")", "\n", "ka", "=", "oks", ".", "summary", "(", ")", "[", "\"ka\"", "]", "\n", "kb", "=", "oks", ".", "summary", "(", ")", "[", "\"kb\"", "]", "\n", "assert", "(", "ka", ",", "kb", ")", "==", "(", "1", ",", "1", ")", "# there exists no community structure in the southernWomen dataset", "\n", "", ""]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.tests.test_mcmc.test_answer": [[18, 24], ["oks.minimize_bisbm_dl", "oks.summary", "oks.summary"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.minimize_bisbm_dl", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary"], ["def", "test_answer", "(", ")", ":", "\n", "    ", "oks", ".", "minimize_bisbm_dl", "(", ")", "\n", "ka", "=", "oks", ".", "summary", "(", ")", "[", "\"ka\"", "]", "\n", "kb", "=", "oks", ".", "summary", "(", ")", "[", "\"kb\"", "]", "\n", "# Note that we may not obtain (4, 6), as non-identifiable blocks may exist.", "\n", "assert", "(", "ka", ",", "kb", ")", "in", "[", "(", "4", ",", "6", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.tests.test_mcmc.test_summary_dl_at_1_1": [[26, 34], ["oks.compute_and_update", "oks.summary_dl"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.compute_and_update", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary_dl"], ["", "def", "test_summary_dl_at_1_1", "(", ")", ":", "\n", "    ", "oks", ".", "compute_and_update", "(", "1", ",", "1", ")", "\n", "dl", "=", "oks", ".", "summary_dl", "(", "1", ",", "1", ")", "\n", "assert", "dl", "[", "\"dl\"", "]", "==", "56078.5634561319", "\n", "assert", "dl", "[", "\"adjacency\"", "]", "==", "51884.81583464478", "\n", "assert", "dl", "[", "\"partition\"", "]", "==", "12.429216196844383", "\n", "assert", "dl", "[", "\"degree\"", "]", "==", "4181.318405290275", "\n", "assert", "dl", "[", "\"edges\"", "]", "==", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.tests.test_mcmc.test_summary_dl_at_500_500": [[36, 44], ["oks.compute_and_update", "oks.summary_dl", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.compute_and_update", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary_dl"], ["", "def", "test_summary_dl_at_500_500", "(", ")", ":", "\n", "    ", "oks", ".", "compute_and_update", "(", "500", ",", "500", ")", "\n", "dl", "=", "oks", ".", "summary_dl", "(", "500", ",", "500", ")", "\n", "assert", "dl", "[", "\"dl\"", "]", "==", "pytest", ".", "approx", "(", "62871.75555606898", ")", "\n", "assert", "dl", "[", "\"adjacency\"", "]", "==", "pytest", ".", "approx", "(", "0.", ",", "abs", "=", "1e-9", ")", "\n", "assert", "dl", "[", "\"partition\"", "]", "==", "pytest", ".", "approx", "(", "5235.090133117156", ")", "\n", "assert", "dl", "[", "\"degree\"", "]", "==", "pytest", ".", "approx", "(", "0.", ",", "abs", "=", "1e-9", ")", "\n", "assert", "dl", "[", "\"edges\"", "]", "==", "pytest", ".", "approx", "(", "57636.66542295214", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.tests.test_mcmc.test_issue_12": [[46, 53], ["biSBM.OptimalKs", "bm.OptimalKs.minimize_bisbm_dl", "bm.OptimalKs.summary", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.minimize_bisbm_dl", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.biSBM.optimalks.OptimalKs.summary"], ["", "def", "test_issue_12", "(", ")", ":", "\n", "    ", "edgelist", "=", "[", "[", "0", ",", "3", "]", ",", "[", "0", ",", "4", "]", ",", "[", "0", ",", "5", "]", ",", "[", "1", ",", "3", "]", ",", "[", "1", ",", "4", "]", ",", "[", "1", ",", "5", "]", ",", "[", "2", ",", "6", "]", ",", "[", "2", ",", "7", "]", ",", "[", "2", ",", "8", "]", "]", "\n", "types", "=", "[", "1", ",", "1", ",", "1", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", "]", "\n", "oks", "=", "bm", ".", "OptimalKs", "(", "mcmc", ",", "edgelist", ",", "types", ")", "\n", "oks", ".", "minimize_bisbm_dl", "(", ")", "\n", "dl", "=", "oks", ".", "summary", "(", ")", "\n", "assert", "dl", "[", "\"mdl\"", "]", "==", "pytest", ".", "approx", "(", "15.615238196841506", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.__init__": [[47, 78], ["int", "bool", "int", "str", "int", "int", "str", "os.path.isfile", "BaseException"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "f_engine", "=", "\"engines/bipartiteSBM-MCMC/bin/mcmc\"", ",", "\n", "n_sweeps", "=", "1", ",", "\n", "is_parallel", "=", "False", ",", "\n", "n_cores", "=", "1", ",", "\n", "algm_name", "=", "\"mcmc\"", ",", "\n", "mcmc_steps", "=", "1e5", ",", "\n", "mcmc_await_steps", "=", "2e3", ",", "\n", "mcmc_cooling", "=", "\"abrupt_cool\"", ",", "\n", "mcmc_cooling_param_1", "=", "1e3", ",", "\n", "mcmc_cooling_param_2", "=", "0.1", ",", "\n", "mcmc_epsilon", "=", "1.", ")", ":", "\n", "\n", "        ", "self", ".", "MAX_NUM_SWEEPS", "=", "int", "(", "n_sweeps", ")", "\n", "self", ".", "PARALLELIZATION", "=", "bool", "(", "is_parallel", ")", "\n", "self", ".", "NUM_CORES", "=", "int", "(", "n_cores", ")", "\n", "self", ".", "ALGM_NAME", "=", "str", "(", "algm_name", ")", "\n", "\n", "# for MCMC", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "f_engine", ")", ":", "\n", "            ", "raise", "BaseException", "(", "\"[ERROR] MCMC engine binary not found!\"", ")", "\n", "\n", "", "self", ".", "f_engine", "=", "f_engine", "\n", "self", ".", "mcmc_steps_", "=", "int", "(", "mcmc_steps", ")", "\n", "self", ".", "mcmc_await_steps_", "=", "int", "(", "mcmc_await_steps", ")", "\n", "self", ".", "mcmc_cooling_", "=", "str", "(", "mcmc_cooling", ")", "\n", "self", ".", "mcmc_cooling_param_1", "=", "mcmc_cooling_param_1", "\n", "self", ".", "mcmc_cooling_param_2", "=", "mcmc_cooling_param_2", "\n", "self", ".", "mcmc_epsilon_", "=", "mcmc_epsilon", "\n", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_steps": [[79, 81], ["int"], "methods", ["None"], ["", "def", "set_steps", "(", "self", ",", "steps", ")", ":", "\n", "        ", "self", ".", "mcmc_steps_", "=", "int", "(", "steps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_await_steps": [[82, 84], ["int"], "methods", ["None"], ["", "def", "set_await_steps", "(", "self", ",", "await_steps", ")", ":", "\n", "        ", "self", ".", "mcmc_await_steps_", "=", "int", "(", "await_steps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_cooling": [[85, 87], ["str"], "methods", ["None"], ["", "def", "set_cooling", "(", "self", ",", "cooling", ")", ":", "\n", "        ", "self", ".", "mcmc_cooling_", "=", "str", "(", "cooling", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_cooling_param_1": [[88, 90], ["None"], "methods", ["None"], ["", "def", "set_cooling_param_1", "(", "self", ",", "cooling_param_1", ")", ":", "\n", "        ", "self", ".", "mcmc_cooling_param_1", "=", "cooling_param_1", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_cooling_param_2": [[91, 93], ["None"], "methods", ["None"], ["", "def", "set_cooling_param_2", "(", "self", ",", "cooling_param_2", ")", ":", "\n", "        ", "self", ".", "mcmc_cooling_param_2", "=", "cooling_param_2", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.set_epsilon": [[94, 96], ["None"], "methods", ["None"], ["", "def", "set_epsilon", "(", "self", ",", "epsilon", ")", ":", "\n", "        ", "self", ".", "mcmc_epsilon_", "=", "epsilon", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.prepare_engine": [[97, 162], ["mcmc.MCMC._gen_init_n_blocks", "str", "str", "str", "str", "str", "str", "str", "str", "str", "map", "str"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC._gen_init_n_blocks"], ["", "def", "prepare_engine", "(", "self", ",", "f_edgelist", ",", "na", ",", "nb", ",", "ka", ",", "kb", ",", "mb", "=", "None", ",", "method", "=", "None", ")", ":", "\n", "        ", "\"\"\"Output shell commands for graph partitioning calculation.\n\n        Parameters\n        ----------\n        ka : ``int`` (required)\n            Number of communities for type-`a` nodes to partition.\n\n        kb : ``int`` (required)\n            Number of communities for type-`b` nodes to partition.\n\n        Returns\n        -------\n        action_str : ``str``\n            the command line string that enables execution of the code\n\n        \"\"\"", "\n", "params_", "=", "\"\"", "\n", "if", "self", ".", "mcmc_cooling_", "in", "[", "\"exponential\"", ",", "\"linear\"", ",", "\"logarithmic\"", "]", ":", "\n", "            ", "params_", "=", "str", "(", "self", ".", "mcmc_cooling_param_1", ")", "+", "\" \"", "+", "str", "(", "self", ".", "mcmc_cooling_param_2", ")", "\n", "", "elif", "self", ".", "mcmc_cooling_", "in", "[", "\"constant\"", ",", "\"abrupt_cool\"", "]", ":", "\n", "            ", "params_", "=", "str", "(", "self", ".", "mcmc_cooling_param_1", ")", "\n", "\n", "", "if", "mb", "is", "None", ":", "\n", "            ", "means_", "=", "\"-g\"", "\n", "", "else", ":", "\n", "            ", "means_", "=", "\"--mb\"", "+", "\" \"", "+", "\" \"", ".", "join", "(", "map", "(", "str", ",", "mb", ")", ")", "\n", "\n", "", "if", "method", "==", "\"natural\"", ":", "\n", "            ", "means_", "=", "\"-g -u\"", "\n", "\n", "# n_blocks_ = \" \".join(", "\n", "#     self._constrained_sum_sample_pos(ka, na)", "\n", "# ) + \" \" + \" \".join(", "\n", "#     self._constrained_sum_sample_pos(kb, nb)", "\n", "# )", "\n", "", "n_blocks_", "=", "self", ".", "_gen_init_n_blocks", "(", "na", ",", "nb", ",", "ka", ",", "kb", ")", "\n", "n_types_", "=", "str", "(", "na", ")", "+", "\" \"", "+", "str", "(", "nb", ")", "\n", "\n", "action_list", "=", "[", "\n", "self", ".", "f_engine", ",", "\n", "\"-e\"", ",", "\n", "f_edgelist", ",", "\n", "\"-n\"", ",", "\n", "n_blocks_", ",", "\n", "\"-t\"", ",", "\n", "str", "(", "self", ".", "mcmc_steps_", ")", ",", "\n", "\"-x\"", ",", "\n", "str", "(", "self", ".", "mcmc_await_steps_", ")", ",", "\n", "\"-c\"", ",", "\n", "self", ".", "mcmc_cooling_", ",", "\n", "\"-a\"", ",", "\n", "params_", ",", "\n", "\"-y\"", ",", "\n", "n_types_", ",", "\n", "\"-z\"", ",", "\n", "str", "(", "ka", ")", "+", "\" \"", "+", "str", "(", "kb", ")", ",", "\n", "\"-E\"", ",", "\n", "str", "(", "self", ".", "mcmc_epsilon_", ")", ",", "\n", "means_", "\n", "]", "\n", "\n", "action_str", "=", "' '", ".", "join", "(", "action_list", ")", "\n", "#print(action_str)", "\n", "return", "action_str", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.engine": [[163, 216], ["mcmc.MCMC.prepare_engine", "numpy.array", "subprocess.Popen", "subprocess.Popen.communicate", "subprocess.Popen.wait", "mcmc.MCMC.engine._run_engine"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL.prepare_engine"], ["", "def", "engine", "(", "self", ",", "f_edgelist", ",", "na", ",", "nb", ",", "ka", ",", "kb", ",", "mb", "=", "None", ",", "method", "=", "None", ")", ":", "# TODO: bug when assigned verbose=False", "\n", "        ", "\"\"\"Run the shell code.\n\n        Parameters\n        ----------\n        f_edgelist : ``str``\n\n        na : ``int``\n\n        nb : ``int``\n\n        ka : ``int``, required\n            Number of communities for type-*a* nodes to partition.\n\n        kb : ``int``, required\n            Number of communities for type-*b* nodes to partition.\n\n        mb : :class:`numpy.ndarray`\n\n        method :\n\n        Returns\n        -------\n        of_group : :class:`numpy.ndarray`\n\n        \"\"\"", "\n", "of_group", "=", "[", "]", "\n", "action_str", "=", "self", ".", "prepare_engine", "(", "f_edgelist", ",", "na", ",", "nb", ",", "ka", ",", "kb", ",", "mb", "=", "mb", ",", "method", "=", "method", ")", "\n", "\n", "num_sweeps_", "=", "1", "\n", "\n", "def", "_run_engine", "(", "_", ")", ":", "\n", "            ", "p", "=", "subprocess", ".", "Popen", "(", "\n", "action_str", ".", "split", "(", "' '", ")", ",", "\n", "bufsize", "=", "2048", ",", "\n", "stdout", "=", "subprocess", ".", "PIPE", "\n", ")", "\n", "out", ",", "err", "=", "p", ".", "communicate", "(", ")", "\n", "p", ".", "wait", "(", ")", "\n", "return", "out", ",", "err", ",", "p", "\n", "\n", "", "num_sweep_", "=", "0", "\n", "\n", "while", "num_sweep_", "<", "num_sweeps_", ":", "\n", "            ", "out", ",", "err", ",", "p", "=", "_run_engine", "(", "\"\"", ")", "\n", "if", "p", ".", "returncode", "==", "-", "11", ":", "# when Exception raises from the mcmc code", "\n", "                ", "raise", "RuntimeError", "(", "\"Exception from C++ program during inference! -- \"", "+", "action_str", ")", "\n", "", "elif", "p", ".", "returncode", "==", "0", ":", "\n", "                ", "num_sweep_", "+=", "1", "\n", "of_group", "=", "out", ".", "replace", "(", "b' \\n'", ",", "b''", ")", ".", "split", "(", "b' '", ")", "# Note the space before the line break", "\n", "of_group", "=", "list", "(", "map", "(", "int", ",", "of_group", ")", ")", "\n", "\n", "", "", "return", "np", ".", "array", "(", "of_group", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC._gen_init_n_blocks": [[217, 227], ["numpy.arange", "map", "numpy.arange", "map", "numpy.array_split", "numpy.array_split", "map", "map"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_gen_init_n_blocks", "(", "na", ",", "nb", ",", "ka", ",", "kb", ")", ":", "\n", "        ", "num_nodes_a", "=", "np", ".", "arange", "(", "na", ")", "\n", "n_blocks_a", "=", "map", "(", "len", ",", "np", ".", "array_split", "(", "num_nodes_a", ",", "ka", ")", ")", "\n", "num_nodes_b", "=", "np", ".", "arange", "(", "nb", ")", "\n", "n_blocks_b", "=", "map", "(", "len", ",", "np", ".", "array_split", "(", "num_nodes_b", ",", "kb", ")", ")", "\n", "\n", "n_blocks_", "=", "\" \"", ".", "join", "(", "map", "(", "str", ",", "n_blocks_a", ")", ")", "+", "\" \"", "+", "\" \"", ".", "join", "(", "map", "(", "str", ",", "n_blocks_b", ")", ")", "\n", "\n", "return", "n_blocks_", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC._constrained_sum_sample_pos": [[228, 248], ["int", "int", "map", "numpy.greater_equal().all", "enumerate", "abs", "sum", "int", "sum", "list", "list", "numpy.greater_equal", "map", "map", "numpy.zeros", "map", "len", "numpy.count_nonzero", "len", "len", "numpy.random.dirichlet().tolist", "numpy.random.dirichlet", "numpy.ones"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_constrained_sum_sample_pos", "(", "n", ",", "total", ")", ":", "\n", "# in this setting, there will be no empty groups generated by this function", "\n", "        ", "n", "=", "int", "(", "n", ")", "\n", "total", "=", "int", "(", "total", ")", "\n", "normalized_list", "=", "[", "int", "(", "total", ")", "+", "1", "]", "\n", "while", "sum", "(", "normalized_list", ")", ">", "total", "and", "np", ".", "greater_equal", "(", "normalized_list", ",", "np", ".", "zeros", "(", "n", ")", ")", ".", "all", "(", ")", ":", "\n", "            ", "indicator", "=", "True", "\n", "while", "indicator", ":", "\n", "                ", "normalized_list", "=", "list", "(", "map", "(", "round", ",", "map", "(", "lambda", "x", ":", "x", "*", "total", ",", "np", ".", "random", ".", "dirichlet", "(", "np", ".", "ones", "(", "n", ")", ",", "1", ")", ".", "tolist", "(", ")", "[", "0", "]", ")", ")", ")", "\n", "normalized_list", "=", "list", "(", "map", "(", "int", ",", "normalized_list", ")", ")", "\n", "indicator", "=", "len", "(", "normalized_list", ")", "-", "np", ".", "count_nonzero", "(", "normalized_list", ")", "!=", "0", "\n", "", "sum_", "=", "0", "\n", "for", "ind", ",", "q", "in", "enumerate", "(", "normalized_list", ")", ":", "\n", "                ", "if", "ind", "<", "len", "(", "normalized_list", ")", "-", "1", ":", "\n", "                    ", "sum_", "+=", "q", "\n", "# TODO: there is a bug here; sometimes it assigns -1 to the end of the array, but pass the while condition", "\n", "", "", "normalized_list", "[", "len", "(", "normalized_list", ")", "-", "1", "]", "=", "abs", "(", "total", "-", "sum_", ")", "\n", "", "assert", "sum", "(", "normalized_list", ")", "==", "total", ",", "\"ERROR: the constrainedSumSamplePos-sampled list does not sum to #edges.\"", "\n", "return", "map", "(", "str", ",", "normalized_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.mcmc.MCMC.gen_types": [[249, 253], ["int", "int"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "gen_types", "(", "na", ",", "nb", ")", ":", "\n", "        ", "types", "=", "[", "1", "]", "*", "int", "(", "na", ")", "+", "[", "2", "]", "*", "int", "(", "nb", ")", "\n", "return", "types", "\n", "", "", ""]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL.__init__": [[44, 82], ["int", "bool", "int", "bool", "str", "int", "int", "str", "bool", "NotImplementedError", "os.path.isfile", "BaseException"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "f_engine", "=", "\"engines/bipartiteSBM-KL/biSBM\"", ",", "\n", "n_sweeps", "=", "1", ",", "\n", "is_parallel", "=", "False", ",", "\n", "n_cores", "=", "1", ",", "\n", "algm_name", "=", "\"kl\"", ",", "\n", "kl_edgelist_delimiter", "=", "\"\\t\"", ",", "\n", "kl_steps", "=", "5", ",", "\n", "kl_itertimes", "=", "1", ",", "\n", "f_kl_output", "=", "\"engines/bipartiteSBM-KL/f_kl_output\"", ",", "\n", "kl_verbose", "=", "True", ",", "\n", "kl_is_parallel", "=", "False", ")", ":", "\n", "\n", "        ", "self", ".", "MAX_NUM_SWEEPS", "=", "int", "(", "n_sweeps", ")", "\n", "self", ".", "PARALLELIZATION", "=", "bool", "(", "is_parallel", ")", "\n", "self", ".", "NUM_CORES", "=", "int", "(", "n_cores", ")", "\n", "self", ".", "KL_PARALLELIZATION", "=", "bool", "(", "kl_is_parallel", ")", "\n", "self", ".", "ALGM_NAME", "=", "str", "(", "algm_name", ")", "\n", "\n", "# <kl_itertimes> is the number of KL sweeps (<kl_steps> per sweep) performed before returning the optimal result", "\n", "# during each engine run (Note that there are <n_sweeps> engines running in parallel via loky)", "\n", "self", ".", "MAX_KL_NUM_SWEEPS", "=", "int", "(", "kl_itertimes", ")", "\n", "\n", "if", "self", ".", "KL_PARALLELIZATION", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"[ERROR] KL calculation accross many cores is not supported.\"", ")", "\n", "\n", "# for KL", "\n", "", "if", "not", "os", ".", "path", ".", "isfile", "(", "f_engine", ")", ":", "\n", "            ", "raise", "BaseException", "(", "\"[ERROR] KL engine binary not found!\"", ")", "\n", "\n", "", "self", ".", "f_engine", "=", "f_engine", "\n", "self", ".", "kl_steps", "=", "int", "(", "kl_steps", ")", "\n", "\n", "self", ".", "f_kl_output", "=", "str", "(", "f_kl_output", ")", "\n", "self", ".", "kl_verbose", "=", "bool", "(", "kl_verbose", ")", "\n", "self", ".", "kl_edgelist_delimiter", "=", "kl_edgelist_delimiter", "\n", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL.prepare_engine": [[83, 138], ["hashlib.md5().hexdigest", "kl.KL._save_edgelist_as_1_indexed", "kl.KL._save_types", "os.mkdir", "str", "str", "str", "hashlib.md5().hexdigest", "os.mkdir", "hashlib.md5", "shutil.rmtree", "os.mkdir", "f_edgelist.encode", "hashlib.md5", "str().encode", "str", "random.random"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._save_edgelist_as_1_indexed", "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._save_types"], ["", "def", "prepare_engine", "(", "self", ",", "f_edgelist", ",", "na", ",", "nb", ",", "ka", ",", "kb", ",", "delimiter", "=", "None", ")", ":", "\n", "        ", "\"\"\"Output shell commands for graph partitioning calculation.\n\n        Parameters\n        ----------\n        ka : ``int`` (required)\n            Number of communities for type-`a` nodes to partition.\n\n        kb : ``int`` (required)\n            Number of communities for type-`b` nodes to partition.\n\n        Returns\n        -------\n        action_str : ``str``\n            The command line string that enables execution of the code.\n\n        \"\"\"", "\n", "if", "delimiter", "is", "None", ":", "\n", "            ", "delimiter", "=", "self", ".", "kl_edgelist_delimiter", "\n", "\n", "", "try", ":", "\n", "            ", "os", ".", "mkdir", "(", "self", ".", "f_kl_output", ")", "\n", "", "except", "OSError", ":", "\n", "            ", "pass", "\n", "", "finally", ":", "\n", "            ", "self", ".", "f_kl_output", "+=", "\"/\"", "+", "hashlib", ".", "md5", "(", "str", "(", "random", ".", "random", "(", ")", ")", ".", "encode", "(", ")", ")", ".", "hexdigest", "(", ")", "\n", "try", ":", "\n", "                ", "os", ".", "mkdir", "(", "self", ".", "f_kl_output", ")", "\n", "", "except", "OSError", ":", "\n", "# clear the working dir, and mkdir a new one", "\n", "                ", "shutil", ".", "rmtree", "(", "self", ".", "f_kl_output", ",", "ignore_errors", "=", "True", ")", "\n", "os", ".", "mkdir", "(", "self", ".", "f_kl_output", ")", "\n", "pass", "\n", "\n", "", "", "filename", "=", "hashlib", ".", "md5", "(", "f_edgelist", ".", "encode", "(", ")", ")", ".", "hexdigest", "(", ")", "\n", "f_edgelist_1_indexed", "=", "self", ".", "f_kl_output", "+", "\"/\"", "+", "filename", "+", "\"_1-indexed.edgelist\"", "\n", "self", ".", "_save_edgelist_as_1_indexed", "(", "f_edgelist", ",", "f_edgelist_1_indexed", ",", "delimiter", ")", "\n", "\n", "f_types", "=", "self", ".", "f_kl_output", "+", "\"/\"", "+", "filename", "+", "\".types\"", "\n", "self", ".", "types", "=", "self", ".", "_save_types", "(", "f_types", ",", "na", ",", "nb", ")", "\n", "\n", "action_list", "=", "[", "\n", "self", ".", "f_engine", ",", "\n", "f_edgelist_1_indexed", ",", "\n", "f_types", ",", "\n", "self", ".", "f_kl_output", ",", "\n", "str", "(", "ka", ")", ",", "\n", "str", "(", "kb", ")", ",", "\n", "'1'", ",", "# degree-corrected", "\n", "str", "(", "self", ".", "kl_steps", ")", "\n", "]", "\n", "\n", "action_str", "=", "' '", ".", "join", "(", "action_list", ")", "\n", "\n", "return", "action_str", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL.engine": [[139, 201], ["kl.KL.prepare_engine", "collections.OrderedDict", "open", "subprocess.Popen", "subprocess.Popen.communicate", "subprocess.Popen.wait", "shutil.rmtree", "numpy.array", "kl.KL.split", "kl.KL.engine.run"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL.prepare_engine"], ["", "def", "engine", "(", "self", ",", "f_edgelist", ",", "na", ",", "nb", ",", "ka", ",", "kb", ",", "mb", "=", "None", ")", ":", "# TODO: bug when assigned verbose=False", "\n", "        ", "\"\"\"Run the shell code.\n\n        Parameters\n        ----------\n        ka : ``int`` (required)\n            Number of communities for type-`a` nodes to partition.\n\n        kb : ``int`` (required)\n            Number of communities for type-`b` nodes to partition.\n\n        Returns\n        -------\n        of_group : ``list[int]``\n\n        \"\"\"", "\n", "action_str", "=", "self", ".", "prepare_engine", "(", "f_edgelist", ",", "na", ",", "nb", ",", "ka", ",", "kb", ")", "\n", "\n", "num_sweeps_", "=", "self", ".", "MAX_KL_NUM_SWEEPS", "\n", "verbose_", "=", "self", ".", "kl_verbose", "\n", "parallelization_", "=", "self", ".", "KL_PARALLELIZATION", "\n", "num_cores_", "=", "self", ".", "NUM_CORES", "\n", "\n", "if", "not", "verbose_", ":", "\n", "            ", "stdout", "=", "open", "(", "os", ".", "devnull", ",", "\"w\"", ")", "\n", "", "else", ":", "\n", "            ", "stdout", "=", "subprocess", ".", "PIPE", "\n", "\n", "", "def", "run", "(", "_", ")", ":", "\n", "            ", "p", "=", "subprocess", ".", "Popen", "(", "\n", "action_str", ".", "split", "(", "' '", ")", ",", "\n", "bufsize", "=", "2048", ",", "\n", "stdout", "=", "stdout", "\n", ")", "\n", "out", ",", "err", "=", "p", ".", "communicate", "(", ")", "\n", "p", ".", "wait", "(", ")", "\n", "return", "out", ",", "err", ",", "p", "\n", "\n", "", "kl_output", "=", "OrderedDict", "(", ")", "\n", "num_sweep_", "=", "0", "\n", "while", "num_sweep_", "<", "num_sweeps_", ":", "\n", "            ", "if", "not", "parallelization_", ":", "\n", "                ", "out", ",", "err", ",", "p", "=", "run", "(", "\"\"", ")", "\n", "if", "p", ".", "returncode", "==", "-", "11", ":", "# when Exception raises from the KL code", "\n", "                    ", "raise", "RuntimeError", "(", "\"[ERROR] Exception from C++ program during inference! -- \"", "+", "action_str", ")", "\n", "", "elif", "p", ".", "returncode", "==", "0", ":", "\n", "                    ", "num_sweep_", "+=", "1", "\n", "assert", "type", "(", "self", ".", "_get_score_by_index", "(", "num_sweep_", ")", ")", "==", "float", "\n", "kl_output", "[", "self", ".", "_get_score_by_index", "(", "num_sweep_", ")", "]", "=", "self", ".", "_get_of_group_by_index", "(", "num_sweep_", ")", "\n", "\n", "", "", "else", ":", "# spawn processes across cores, collect results, and return the best option", "\n", "# However, in optimalks.py main code, we may calculate each single point in parallel, which", "\n", "# might raise \"AssertionError: daemonic processes are not allowed to have children\"", "\n", "# TODO: For now, parallel calculation for KL is disabled. (Fix it?)", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "of_group", "=", "kl_output", "[", "max", "(", "kl_output", ")", "]", "\n", "\n", "try", ":", "\n", "            ", "shutil", ".", "rmtree", "(", "self", ".", "f_kl_output", ",", "ignore_errors", "=", "True", ")", "\n", "", "finally", ":", "\n", "            ", "return", "np", ".", "array", "(", "of_group", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL.gen_types": [[202, 206], ["int", "int"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "gen_types", "(", "na", ",", "nb", ")", ":", "\n", "        ", "types", "=", "[", "1", "]", "*", "int", "(", "na", ")", "+", "[", "2", "]", "*", "int", "(", "nb", ")", "\n", "return", "types", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._get_of_group_by_index": [[207, 214], ["kl.KL._open_biDCSBMcomms_file", "enumerate", "kl.KL.close", "of_group.append", "int", "line.split"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._open_biDCSBMcomms_file"], ["", "def", "_get_of_group_by_index", "(", "self", ",", "num_sweep_", ")", ":", "\n", "        ", "of_group", "=", "[", "]", "\n", "f", "=", "self", ".", "_open_biDCSBMcomms_file", "(", "num_sweep_", ")", "\n", "for", "ind", ",", "line", "in", "enumerate", "(", "f", ")", ":", "\n", "            ", "of_group", ".", "append", "(", "int", "(", "line", ".", "split", "(", "'\\n'", ")", "[", "0", "]", ")", ")", "\n", "", "f", ".", "close", "(", ")", "\n", "return", "of_group", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._get_score_by_index": [[215, 221], ["kl.KL._get_bisbm_score_file", "enumerate", "kl.KL.close", "float", "line.split"], "methods", ["home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._get_bisbm_score_file"], ["", "def", "_get_score_by_index", "(", "self", ",", "num_sweep_", ")", ":", "\n", "        ", "f", "=", "self", ".", "_get_bisbm_score_file", "(", "num_sweep_", ")", "\n", "for", "ind", ",", "line", "in", "enumerate", "(", "f", ")", ":", "\n", "            ", "score", "=", "float", "(", "line", ".", "split", "(", "'\\n'", ")", "[", "0", "]", ")", "\n", "", "f", ".", "close", "(", ")", "\n", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._get_bisbm_score_file": [[222, 228], ["open", "str", "int"], "methods", ["None"], ["", "def", "_get_bisbm_score_file", "(", "self", ",", "num_sweep_", ")", ":", "\n", "        ", "\"\"\":return: file handle\"\"\"", "\n", "f", "=", "open", "(", "\n", "self", ".", "f_kl_output", "+", "'/biDCSBMcomms'", "+", "str", "(", "int", "(", "num_sweep_", ")", ")", "+", "'.score'", ",", "'r'", "\n", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._open_biDCSBMcomms_file": [[229, 236], ["open", "str", "int"], "methods", ["None"], ["", "def", "_open_biDCSBMcomms_file", "(", "self", ",", "num_sweep_", ")", ":", "\n", "        ", "\"\"\":return: file handle\"\"\"", "\n", "f", "=", "open", "(", "\n", "self", ".", "f_kl_output", "+", "'/biDCSBMcomms'", "+", "\n", "str", "(", "int", "(", "num_sweep_", ")", ")", "+", "'.tsv'", ",", "'r'", "\n", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._save_edgelist_as_1_indexed": [[237, 265], ["open", "open", "line.replace().replace.replace().replace.replace().replace", "re.split", "g.write", "line.replace().replace.replace().replace.replace", "ValueError", "str", "str", "int", "int"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_save_edgelist_as_1_indexed", "(", "f_edgelist", ",", "f_target_edgelist", ",", "delimiter", "=", "\"\\t\"", ")", ":", "\n", "        ", "\"\"\"\n\n        Note that this function always saves with delimiter.\n\n        Parameters\n        ----------\n        f_edgelist : ``str``\n\n        f_target_edgelist : ``str``\n\n        delimiter : ``str``\n\n        Returns\n        -------\n\n        \"\"\"", "\n", "with", "open", "(", "f_target_edgelist", ",", "\"w\"", ")", "as", "g", ":", "\n", "            ", "with", "open", "(", "f_edgelist", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "for", "line", "in", "f", ":", "\n", "                    ", "line", "=", "line", ".", "replace", "(", "'\\r'", ",", "''", ")", ".", "replace", "(", "'\\n'", ",", "''", ")", "\n", "edge", "=", "re", ".", "split", "(", "delimiter", ",", "line", ")", "\n", "try", ":", "\n", "                        ", "g", ".", "write", "(", "str", "(", "int", "(", "edge", "[", "0", "]", ")", "+", "1", ")", "+", "\"\\t\"", "+", "str", "(", "int", "(", "edge", "[", "1", "]", ")", "+", "1", ")", "+", "\"\\n\"", ")", "\n", "", "except", "ValueError", "as", "e", ":", "\n", "                        ", "raise", "ValueError", "(", "\n", "\"[ERROR] Please check if the delimiter for the edgelist file is wrong -- {}\"", ".", "format", "(", "e", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.junipertcy_bipartiteSBM.engines.kl.KL._save_types": [[267, 276], ["open", "int", "int", "f.write", "str"], "methods", ["None"], ["", "", "", "", "", "@", "staticmethod", "\n", "def", "_save_types", "(", "f_types", ",", "na", ",", "nb", ")", ":", "\n", "        ", "assert", "na", ">", "0", ",", "\"[ERROR] Number of type-a nodes = 0, which is not allowed\"", "\n", "assert", "nb", ">", "0", ",", "\"[ERROR] Number of type-b nodes = 0, which is not allowed\"", "\n", "types", "=", "[", "1", "]", "*", "int", "(", "na", ")", "+", "[", "2", "]", "*", "int", "(", "nb", ")", "\n", "with", "open", "(", "f_types", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "types", ":", "\n", "                ", "f", ".", "write", "(", "str", "(", "line", ")", "+", "'\\n'", ")", "\n", "", "", "return", "types", "\n", "", "", ""]]}