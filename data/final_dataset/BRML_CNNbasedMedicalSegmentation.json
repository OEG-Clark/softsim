{"home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.load_mhas_as_dict": [[15, 43], ["brain_data_scripts.get_im"], "function", ["None"], ["def", "load_mhas_as_dict", "(", "path", ")", ":", "\n", "    ", "\"\"\"\n    Takes a path to a dictionary holding a series of subdirectories,\n    where each subdirectory corresponds to one of the MRI modalities\n    'Flair', 'T1', 'T1c' and 'T2'. The subdir corresponding to a mo-\n    dality must also contain the name of that modality in its name.\n    In other words, we assume the following kind of file hierarchy:\n    .\n    \u251c\u2500\u2500 VSD.Brain_3more.XX.O.OT.54517\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 License_CC_BY_NC_SA_3.0.txt\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 VSD.Brain_3more.XX.O.OT.54517.mha\n    \u251c\u2500\u2500 VSD.Brain.XX.O.MR_Flair.54512\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 License_CC_BY_NC_SA_3.0.txt\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 VSD.Brain.XX.O.MR_Flair.54512.mha\n    \u251c\u2500\u2500 VSD.Brain.XX.O.MR_T1.54513\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 License_CC_BY_NC_SA_3.0.txt\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 VSD.Brain.XX.O.MR_T1.54513.mha\n    \u251c\u2500\u2500 VSD.Brain.XX.O.MR_T1c.54514\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 License_CC_BY_NC_SA_3.0.txt\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 VSD.Brain.XX.O.MR_T1c.54514.mha\n    \u2514\u2500\u2500 VSD.Brain.XX.O.MR_T2.54515\n        \u251c\u2500\u2500 License_CC_BY_NC_SA_3.0.txt\n        \u2514\u2500\u2500 VSD.Brain.XX.O.MR_T2.54515.mha\n    \n    The method will return a tuple dictionary with the modalities\n    as keys and numpy ndarrays as values.\n    \"\"\"", "\n", "return", "bds", ".", "get_im", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.load_dict_as_inputable_ndarray": [[45, 66], ["brain_data_scripts.get_image_slice", "brain_data_scripts.get_im_as_ndarray", "numpy.transpose"], "function", ["None"], ["", "def", "load_dict_as_inputable_ndarray", "(", "im", ")", ":", "\n", "    ", "\"\"\"\"   \n    The method will take a dictionary like the one returned by\n    load_mhas_as_dict and return a tuple (image, slices)\n    where image is a 5D numpy array with dimensions\n    corresponding to: (1, depth, n_chans, height, width)\n    and slices will be used to insert the segmentation into \n    a volume of the same size as the original image.\n\n    We need this because the network is trained on images of size\n    (128, 160, 144) so during deployment we would ideally extract\n    a patch of this size from the original image, segment it and\n    re-insert the segmentation into its appropriate place.\n    \"\"\"", "\n", "im", ",", "slices", "=", "bds", ".", "get_image_slice", "(", "im", ")", "\n", "\n", "np_image", "=", "bds", ".", "get_im_as_ndarray", "(", "im", ",", "downsize", "=", "False", ")", "\n", "np_image", "=", "np", ".", "transpose", "(", "np_image", ",", "(", "1", ",", "0", ",", "2", ",", "3", ")", ")", "\n", "np_image", "=", "np_image", "[", "np", ".", "newaxis", "]", "\n", "\n", "return", "np_image", ",", "slices", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.build_net": [[67, 147], ["os.path.join", "os.path.join", "os.path.join", "os.listdir", "model_defs.get_model", "conv3d.model.SequentialModel", "h5py.File", "numpy.zeros", "h5py.File.close", "os.path.exists", "ash.BatchNormFuns", "f_name.endswith", "open", "cPickle.load", "conv3d.model.SequentialModel.set_batchnorm_params", "AssertionError", "f_name.startswith", "open", "json.load", "os.path.join"], "function", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.model_defs.get_model", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel.set_batchnorm_params"], ["", "def", "build_net", "(", "model_folder", ",", "model_code", ",", "n_classes", ",", "train_size", ",", "inpt_h", ",", "inpt_w", ",", "inpt_d", ",", "n_channels", ")", ":", "\n", "    ", "\"\"\"\n    Takes everything that defines a trained neural network \n    in our setting and returns a function predict that accepts\n    a numpy array as input and returns the segmentation corresponding\n    to it.\n    Parameters:\n        model_folder: path to a directory containing the training results\n                      of the network.\n        model_code:   id of the model. This will be used to find the neural\n                      net architecture in model_defs.py\n        n_classes:    number of labels in the segmentation problem\n        inpt_h:       height of input\n        inpt_w:       width of input\n        inpt_d:       depth of input\n        n_channels:   number of input channels\n    \"\"\"", "\n", "model_path", "=", "os", ".", "path", ".", "join", "(", "'models'", ",", "model_folder", ")", "\n", "\n", "param_file", "=", "os", ".", "path", ".", "join", "(", "model_path", ",", "'params.hdf5'", ")", "\n", "bn_par_file", "=", "os", ".", "path", ".", "join", "(", "model_path", ",", "'bn_pars.pkl'", ")", "\n", "\n", "log", "=", "None", "\n", "for", "f_name", "in", "os", ".", "listdir", "(", "model_path", ")", ":", "\n", "        ", "if", "f_name", ".", "endswith", "(", "'.json'", ")", "and", "not", "f_name", ".", "startswith", "(", "'dice'", ")", ":", "\n", "            ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "model_path", ",", "f_name", ")", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "log", "=", "json", ".", "load", "(", "f", ")", "\n", "", "break", "\n", "", "", "if", "'layers'", "not", "in", "log", ":", "\n", "        ", "log", "=", "None", "\n", "\n", "", "model_def", "=", "get_model", "(", "model_code", ")", "\n", "\n", "layer_vars", "=", "model_def", ".", "layer_vars", "if", "log", "is", "None", "else", "log", "[", "'layers'", "]", "\n", "batchnorm", "=", "model_def", ".", "batchnorm", "\n", "loss_id", "=", "model_def", ".", "loss_id", "\n", "out_transfer", "=", "model_def", ".", "out_transfer", "\n", "\n", "batch_size", "=", "1", "\n", "max_passes", "=", "1", "\n", "inpt_dims", "=", "(", "inpt_h", ",", "inpt_w", ",", "inpt_d", ")", "\n", "\n", "n_report", "=", "train_size", "/", "batch_size", "\n", "max_iter", "=", "n_report", "*", "max_passes", "\n", "\n", "optimizer", "=", "'adam'", "\n", "\n", "model", "=", "SequentialModel", "(", "\n", "image_height", "=", "inpt_dims", "[", "0", "]", ",", "image_width", "=", "inpt_dims", "[", "1", "]", ",", "\n", "image_depth", "=", "inpt_dims", "[", "2", "]", ",", "n_channels", "=", "n_channels", ",", "\n", "n_output", "=", "n_classes", ",", "layer_vars", "=", "layer_vars", ",", "\n", "out_transfer", "=", "out_transfer", ",", "loss_id", "=", "loss_id", ",", "\n", "optimizer", "=", "optimizer", ",", "batch_size", "=", "batch_size", ",", "\n", "max_iter", "=", "max_iter", ",", "using_bn", "=", "batchnorm", "\n", ")", "\n", "\n", "f_params", "=", "h5py", ".", "File", "(", "param_file", ",", "'r'", ")", "\n", "params", "=", "np", ".", "zeros", "(", "model", ".", "parameters", ".", "data", ".", "shape", ")", "\n", "params", "[", "...", "]", "=", "f_params", "[", "'best_pars'", "]", "\n", "f_params", ".", "close", "(", ")", "\n", "model", ".", "parameters", ".", "data", "[", "...", "]", "=", "params", "\n", "\n", "if", "batchnorm", "and", "os", ".", "path", ".", "exists", "(", "bn_par_file", ")", ":", "\n", "        ", "with", "open", "(", "bn_par_file", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "bn_pars", "=", "pickle", ".", "load", "(", "f", ")", "\n", "model", ".", "set_batchnorm_params", "(", "bn_pars", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "batchnorm", ":", "\n", "            ", "raise", "AssertionError", "(", "'Batch norm used but running metrics not available.'", ")", "\n", "\n", "", "", "if", "batchnorm", ":", "\n", "        ", "predict", "=", "ash", ".", "BatchNormFuns", "(", "\n", "model", "=", "model", ",", "\n", "fun", "=", "model", ".", "predict", ",", "\n", "phase", "=", "'infer'", "\n", ")", "\n", "", "else", ":", "\n", "        ", "predict", "=", "model", ".", "predict", "\n", "\n", "", "return", "predict", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.apply_network": [[148, 161], ["predict_fn", "numpy.reshape", "np.reshape.argmax", "isinstance", "predict_fn.as_numpy_array"], "function", ["None"], ["", "def", "apply_network", "(", "inpt", ",", "predict_fn", ",", "n_classes", "=", "5", ")", ":", "\n", "    ", "\"\"\"Applies the predict function returned by build_net to a numpy array.\"\"\"", "\n", "_", ",", "depth", ",", "_", ",", "height", ",", "width", "=", "inpt", ".", "shape", "\n", "\n", "model_output", "=", "predict_fn", "(", "inpt", ")", "\n", "model_output", "=", "model_output", ".", "as_numpy_array", "(", ")", "if", "isinstance", "(", "model_output", ",", "gnumpy", ".", "garray", ")", "else", "model_output", "\n", "fuzzy_seg", "=", "np", ".", "reshape", "(", "\n", "model_output", ",", "\n", "(", "height", ",", "width", ",", "depth", ",", "n_classes", ")", "\n", ")", "\n", "seg", "=", "fuzzy_seg", ".", "argmax", "(", "axis", "=", "3", ")", "\n", "\n", "return", "seg", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.segment_dict": [[162, 187], ["segment.load_dict_as_inputable_ndarray", "segment.build_net", "segment.apply_network", "numpy.zeros", "apply_network.transpose"], "function", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.load_dict_as_inputable_ndarray", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.build_net", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.apply_network"], ["", "def", "segment_dict", "(", "im_dict", ",", "model_folder", ",", "model_code", ",", "n_classes", "=", "5", ")", ":", "\n", "    ", "\"\"\"\n    Segments an image using a trained neural network.\n    Parameters:\n        im_dict: a dictionary where the keys are 'Flair', 'T1', 'T1c' and 'T2'\n                 and the values are numpy ndarrays.\n        model_folder: path to a directory containing the training results\n                      of the network.\n        model_code:   id of the model. This will be used to find the neural\n                      net architecture in model_defs.py\n    \"\"\"", "\n", "orig_shape", "=", "im_dict", "[", "'Flair'", "]", ".", "shape", "\n", "\n", "inpt", ",", "slices", "=", "load_dict_as_inputable_ndarray", "(", "im_dict", ")", "\n", "train_size", ",", "inpt_d", ",", "n_channels", ",", "inpt_h", ",", "inpt_w", "=", "inpt", ".", "shape", "\n", "\n", "predict_fn", "=", "build_net", "(", "model_folder", ",", "model_code", ",", "n_classes", ",", "train_size", ",", "inpt_h", ",", "inpt_w", ",", "inpt_d", ",", "n_channels", ")", "\n", "\n", "seg", "=", "apply_network", "(", "inpt", ",", "predict_fn", ",", "n_classes", ")", "\n", "\n", "segmentation", "=", "np", ".", "zeros", "(", "orig_shape", ")", "\n", "z_s", ",", "x_s", ",", "y_s", "=", "slices", "\n", "segmentation", "[", "z_s", ",", "x_s", ",", "y_s", "]", "=", "seg", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.segment": [[188, 203], ["segment.load_mhas_as_dict", "segment.segment_dict"], "function", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.load_mhas_as_dict", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.segment.segment_dict"], ["", "def", "segment", "(", "path", ",", "model_folder", ",", "model_code", ",", "n_classes", "=", "5", ")", ":", "\n", "    ", "\"\"\"\n    Segments an image using a trained neural network.\n    Parameters:\n        path: path of a directory containing .mha files in\n                its subdirectories. \n                This is specified in: load_mhas_as_dict\n        model_folder: path to a directory containing the training results\n                      of the network.\n        model_code:   id of the model. This will be used to find the neural\n                      net architecture in model_defs.py\n    \"\"\"", "\n", "im_dict", "=", "load_mhas_as_dict", "(", "path", ")", "\n", "\n", "return", "segment_dict", "(", "im_dict", ",", "model_folder", ",", "model_code", ",", "n_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.RandomSectionSelection.__init__": [[85, 104], ["ValueError"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "data_mode", ",", "followed_by", "=", "None", ")", ":", "\n", "        ", "if", "data_mode", "==", "'brain'", ":", "\n", "            ", "self", ".", "random_point_selection", "=", "random_brain_points", "\n", "self", ".", "section_shape", "=", "(", "80", ",", "72", ",", "64", ")", "\n", "", "elif", "data_mode", "==", "'hand'", ":", "\n", "            ", "self", ".", "random_point_selection", "=", "random_hand_points", "\n", "self", ".", "section_shape", "=", "(", "144", ",", "120", ",", "96", ")", "\n", "", "elif", "data_mode", "==", "'debug_hand'", ":", "\n", "            ", "self", ".", "random_point_selection", "=", "random_hand_points", "\n", "self", ".", "section_shape", "=", "(", "64", ",", "64", ",", "64", ")", "\n", "", "elif", "data_mode", "==", "'debug_brain'", ":", "\n", "            ", "self", ".", "random_point_selection", "=", "random_brain_points", "\n", "self", ".", "section_shape", "=", "(", "32", ",", "32", ",", "32", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Data modes are: hand, brain.'", ")", "\n", "", "self", ".", "data_mode", "=", "data_mode", "\n", "self", ".", "followed_by", "=", "followed_by", "\n", "\n", "self", ".", "__name__", "=", "'RandomSectionSelection'", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.RandomSectionSelection.__call__": [[105, 121], ["numpy.transpose", "numpy.reshape", "numpy.transpose", "transformations.extract_random_section", "numpy.transpose", "numpy.transpose", "numpy.reshape", "transformations.RandomSectionSelection.followed_by"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.extract_random_section"], ["", "def", "__call__", "(", "self", ",", "x", ",", "z", ")", ":", "\n", "        ", "n_classes", "=", "z", ".", "shape", "[", "-", "1", "]", "\n", "\n", "nx", "=", "np", ".", "transpose", "(", "x", ",", "(", "0", ",", "2", ",", "3", ",", "4", ",", "1", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "z", ",", "(", "1", ",", "x", ".", "shape", "[", "3", "]", ",", "x", ".", "shape", "[", "4", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "n_classes", ")", ")", "\n", "nz", "=", "np", ".", "transpose", "(", "nz", ",", "(", "0", ",", "4", ",", "1", ",", "2", ",", "3", ")", ")", "\n", "\n", "nx", ",", "nz", "=", "extract_random_section", "(", "nx", "[", "0", "]", ",", "nz", "[", "0", "]", ",", "self", ".", "random_point_selection", ",", "self", ".", "section_shape", ")", "\n", "nx", "=", "np", ".", "transpose", "(", "nx", "[", "np", ".", "newaxis", "]", ",", "(", "0", ",", "4", ",", "1", ",", "2", ",", "3", ")", ")", "\n", "nz", "=", "np", ".", "transpose", "(", "nz", "[", "np", ".", "newaxis", "]", ",", "(", "0", ",", "2", ",", "3", ",", "4", ",", "1", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "nz", ",", "(", "nz", ".", "shape", "[", "0", "]", ",", "nz", ".", "shape", "[", "1", "]", "*", "nz", ".", "shape", "[", "2", "]", "*", "nz", ".", "shape", "[", "3", "]", ",", "n_classes", ")", ")", "\n", "\n", "if", "self", ".", "followed_by", "is", "None", ":", "\n", "            ", "return", "(", "nx", ",", "nz", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "followed_by", "(", "nx", ",", "nz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.extract_section": [[4, 33], ["slice", "slice", "slice", "slice", "slice", "slice", "slice", "slice", "slice"], "function", ["None"], ["def", "extract_section", "(", "im", ",", "x", ",", "y", ",", "z", ",", "padding", ",", "section_shape", ")", ":", "\n", "    ", "x_sect", ",", "y_sect", ",", "z_sect", "=", "section_shape", "\n", "size_x", ",", "size_y", ",", "size_z", "=", "im", ".", "shape", "\n", "take_x", "=", "x_sect", "+", "padding", "\n", "take_y", "=", "y_sect", "+", "padding", "\n", "take_z", "=", "z_sect", "+", "padding", "\n", "\n", "if", "x", "-", "(", "take_x", "/", "2", ")", "<", "0", ":", "\n", "        ", "sl_x", "=", "slice", "(", "0", ",", "take_x", ")", "\n", "", "elif", "x", "+", "(", "take_x", "/", "2", ")", ">", "size_x", ":", "\n", "        ", "sl_x", "=", "slice", "(", "size_x", "-", "take_x", ",", "size_x", ")", "\n", "", "else", ":", "\n", "        ", "sl_x", "=", "slice", "(", "x", "-", "(", "take_x", "/", "2", ")", ",", "x", "+", "(", "take_x", "/", "2", ")", ")", "\n", "\n", "", "if", "y", "-", "(", "take_y", "/", "2", ")", "<", "0", ":", "\n", "        ", "sl_y", "=", "slice", "(", "0", ",", "take_y", ")", "\n", "", "elif", "y", "+", "(", "take_y", "/", "2", ")", ">", "size_y", ":", "\n", "        ", "sl_y", "=", "slice", "(", "size_y", "-", "take_y", ",", "size_y", ")", "\n", "", "else", ":", "\n", "        ", "sl_y", "=", "slice", "(", "y", "-", "(", "take_y", "/", "2", ")", ",", "y", "+", "(", "take_y", "/", "2", ")", ")", "\n", "\n", "", "if", "z", "-", "(", "take_z", "/", "2", ")", "<", "0", ":", "\n", "        ", "sl_z", "=", "slice", "(", "0", ",", "take_z", ")", "\n", "", "elif", "z", "+", "(", "take_z", "/", "2", ")", ">", "size_z", ":", "\n", "        ", "sl_z", "=", "slice", "(", "size_z", "-", "take_z", ",", "size_z", ")", "\n", "", "else", ":", "\n", "        ", "sl_z", "=", "slice", "(", "z", "-", "(", "take_z", "/", "2", ")", ",", "z", "+", "(", "take_z", "/", "2", ")", ")", "\n", "\n", "", "return", "im", "[", "sl_x", ",", "sl_y", ",", "sl_z", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.random_brain_points": [[34, 53], ["random.choice", "numpy.random.randint", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "len", "ValueError", "len", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "len", "regions.append"], "function", ["None"], ["", "def", "random_brain_points", "(", "gt", ")", ":", "\n", "    ", "whole", "=", "np", ".", "array", "(", "np", ".", "where", "(", "gt", "!=", "0", ")", ")", ".", "T", "\n", "core", "=", "np", ".", "array", "(", "np", ".", "where", "(", "(", "gt", "!=", "0", ")", "&", "(", "gt", "!=", "2", ")", ")", ")", ".", "T", "\n", "active", "=", "np", ".", "array", "(", "np", ".", "where", "(", "gt", "==", "4", ")", ")", ".", "T", "\n", "healthy", "=", "np", ".", "array", "(", "np", ".", "where", "(", "gt", "==", "0", ")", ")", ".", "T", "\n", "\n", "region_candidates", "=", "[", "whole", ",", "core", ",", "active", ",", "healthy", ",", "healthy", "]", "\n", "regions", "=", "[", "]", "\n", "for", "candidate", "in", "region_candidates", ":", "\n", "        ", "if", "len", "(", "candidate", ")", ">", "0", ":", "\n", "            ", "regions", ".", "append", "(", "candidate", ")", "\n", "\n", "", "", "if", "len", "(", "regions", ")", "==", "0", ":", "\n", "        ", "raise", "ValueError", "(", "'Ground truth does not make sense.'", ")", "\n", "\n", "", "reg", "=", "random", ".", "choice", "(", "regions", ")", "\n", "i", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "reg", ")", ")", "\n", "point", "=", "reg", "[", "i", "]", "\n", "return", "point", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.random_hand_points": [[54, 74], ["numpy.array", "numpy.random.randint", "numpy.array", "numpy.where", "int", "numpy.round", "numpy.mean"], "function", ["None"], ["", "def", "random_hand_points", "(", "gt", ")", ":", "\n", "    ", "bone", "=", "np", ".", "array", "(", "np", ".", "where", "(", "gt", ">", "0", ")", ")", ".", "T", "\n", "center", "=", "np", ".", "array", "(", "[", "int", "(", "i", ")", "for", "i", "in", "np", ".", "round", "(", "np", ".", "mean", "(", "bone", ",", "axis", "=", "0", ")", ")", "]", ")", "\n", "offset", "=", "np", ".", "random", ".", "randint", "(", "-", "25", ",", "25", ",", "size", "=", "(", "3", ",", ")", ")", "\n", "point", "=", "center", "+", "offset", "\n", "\n", "# region_candidates = [metacarpal, proximal, middle]", "\n", "# regions = []", "\n", "# for candidate in region_candidates:", "\n", "#     if len(candidate) > 0:", "\n", "#         regions.append(candidate)", "\n", "#", "\n", "# if len(regions) == 0:", "\n", "#     raise ValueError('Ground truth does not make sense.')", "\n", "#", "\n", "# reg = random.choice(regions)", "\n", "# i = np.random.randint(0, len(reg))", "\n", "# point = reg[i]", "\n", "\n", "return", "point", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.extract_random_section": [[75, 82], ["random_point_selection", "gt.argmax", "transformations.extract_section", "transformations.extract_section", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.extract_section", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.extract_section"], ["", "def", "extract_random_section", "(", "image", ",", "gt", ",", "random_point_selection", ",", "section_shape", ")", ":", "\n", "    ", "point", "=", "random_point_selection", "(", "gt", ".", "argmax", "(", "axis", "=", "0", ")", ")", "\n", "x", ",", "y", ",", "z", "=", "point", "\n", "sections", "=", "[", "extract_section", "(", "modality", ",", "x", ",", "y", ",", "z", ",", "padding", "=", "0", ",", "section_shape", "=", "section_shape", ")", "for", "modality", "in", "image", "]", "\n", "gt_sections", "=", "[", "extract_section", "(", "class_map", ",", "x", ",", "y", ",", "z", ",", "padding", "=", "0", ",", "section_shape", "=", "section_shape", ")", "for", "class_map", "in", "gt", "]", "\n", "\n", "return", "np", ".", "array", "(", "sections", ",", "dtype", "=", "'int16'", ")", ",", "np", ".", "array", "(", "gt_sections", ",", "dtype", "=", "'int8'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.random_flip": [[122, 140], ["random.choice", "numpy.reshape", "numpy.reshape"], "function", ["None"], ["", "", "", "def", "random_flip", "(", "x", ",", "z", ")", ":", "\n", "    ", "flip_axis", "=", "random", ".", "choice", "(", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "original_shape", "=", "z", ".", "shape", "\n", "nz", "=", "np", ".", "reshape", "(", "z", ",", "(", "1", ",", "x", ".", "shape", "[", "3", "]", ",", "x", ".", "shape", "[", "4", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "z", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "if", "flip_axis", "==", "0", ":", "\n", "# flip along the height", "\n", "        ", "nx", "=", "x", "[", ":", ",", ":", ",", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "nz", "=", "nz", "[", ":", ",", ":", ":", "-", "1", ",", ":", ",", ":", ",", ":", "]", "\n", "", "elif", "flip_axis", "==", "1", ":", "\n", "# flip along the width", "\n", "        ", "nx", "=", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "nz", "=", "nz", "[", ":", ",", ":", ",", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "# flip along the depth", "\n", "        ", "nx", "=", "x", "[", ":", ",", ":", ":", "-", "1", ",", ":", ",", ":", ",", ":", "]", "\n", "nz", "=", "nz", "[", ":", ",", ":", ",", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "nz", "=", "np", ".", "reshape", "(", "nz", ",", "original_shape", ")", "\n", "return", "(", "nx", ",", "nz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.percentile_filter": [[141, 162], ["numpy.random.randint", "numpy.transpose", "numpy.transpose", "numpy.reshape", "numpy.transpose", "numpy.array", "np.asarray.argmax", "numpy.reshape", "numpy.reshape", "numpy.asarray", "numpy.asarray", "transformations.percentile_filter", "one_hot", "transformations.percentile_filter"], "function", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.percentile_filter", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.percentile_filter"], ["", "def", "percentile_filter", "(", "x", ",", "z", ")", ":", "\n", "    ", "from", "scipy", ".", "ndimage", "import", "percentile_filter", "\n", "from", "breze", ".", "learn", ".", "data", "import", "one_hot", "\n", "percentile", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "10", ")", "\n", "\n", "nx", "=", "np", ".", "transpose", "(", "x", ",", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", ")", "\n", "nx", "[", "0", "]", "=", "[", "percentile_filter", "(", "modality", ",", "percentile", ",", "(", "2", ",", "2", ",", "2", ")", ")", "for", "modality", "in", "nx", "[", "0", "]", "]", "\n", "nx", "=", "np", ".", "transpose", "(", "nx", ",", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", ")", "\n", "\n", "n_classes", "=", "z", ".", "shape", "[", "-", "1", "]", "\n", "nz", "=", "np", ".", "reshape", "(", "z", ",", "(", "x", ".", "shape", "[", "3", "]", ",", "x", ".", "shape", "[", "4", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "n_classes", ")", ")", "\n", "nz", "=", "np", ".", "transpose", "(", "nz", ",", "(", "3", ",", "0", ",", "1", ",", "2", ")", ")", "\n", "nz", "=", "np", ".", "array", "(", "[", "percentile_filter", "(", "class_map", ",", "percentile", ",", "(", "2", ",", "2", ",", "2", ")", ")", "for", "class_map", "in", "nz", "]", ")", "\n", "nz", "=", "nz", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "nz", ",", "(", "-", "1", ",", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "one_hot", "(", "nz", ",", "n_classes", ")", ",", "z", ".", "shape", ")", "\n", "\n", "nx", "=", "np", ".", "asarray", "(", "nx", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "nz", "=", "np", ".", "asarray", "(", "nz", ",", "dtype", "=", "z", ".", "dtype", ")", "\n", "\n", "return", "(", "nx", ",", "nz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.swirl_": [[163, 166], ["swirl"], "function", ["None"], ["", "def", "swirl_", "(", "im", ",", "strength", ",", "radius", ")", ":", "\n", "    ", "from", "skimage", ".", "transform", "import", "swirl", "\n", "return", "[", "swirl", "(", "im_slice", ",", "rotation", "=", "0", ",", "strength", "=", "strength", ",", "radius", "=", "radius", ")", "for", "im_slice", "in", "im", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.swirl_transform": [[167, 194], ["numpy.random.uniform", "numpy.random.randint", "numpy.transpose", "numpy.reshape", "numpy.transpose", "numpy.transpose", "nz[].argmax", "numpy.transpose", "numpy.reshape", "numpy.reshape", "numpy.asarray", "numpy.asarray", "transformations.swirl_", "transformations.swirl_", "one_hot"], "function", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.swirl_", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.swirl_"], ["", "def", "swirl_transform", "(", "x", ",", "z", ")", ":", "\n", "    ", "\"\"\"\n    Adds a swirl effect to every depth slice.\n    Assuming a batch size of 1.\n    More specifically: x is (1, depth, channels, height, width) and z is (1, height*width*depth, classes)\n    \"\"\"", "\n", "from", "breze", ".", "learn", ".", "data", "import", "one_hot", "\n", "strength", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "2", ")", "\n", "radius", "=", "np", ".", "random", ".", "randint", "(", "90", ",", "140", ")", "\n", "z_original_shape", "=", "z", ".", "shape", "\n", "n_classes", "=", "z", ".", "shape", "[", "-", "1", "]", "\n", "\n", "nx", "=", "np", ".", "transpose", "(", "x", ",", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "z", ",", "(", "1", ",", "x", ".", "shape", "[", "3", "]", ",", "x", ".", "shape", "[", "4", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "n_classes", ")", ")", "\n", "nz", "=", "np", ".", "transpose", "(", "nz", ",", "(", "0", ",", "4", ",", "3", ",", "1", ",", "2", ")", ")", "\n", "nx", "[", "0", "]", "=", "[", "swirl_", "(", "modality", ",", "strength", ",", "radius", ")", "for", "modality", "in", "nx", "[", "0", "]", "]", "\n", "nx", "=", "np", ".", "transpose", "(", "nx", ",", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", ")", "\n", "nz", "[", "0", "]", "=", "[", "swirl_", "(", "class_map", ",", "strength", ",", "radius", ")", "for", "class_map", "in", "nz", "[", "0", "]", "]", "\n", "nz", "=", "nz", "[", "0", "]", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "nz", "=", "np", ".", "transpose", "(", "nz", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "nz", ",", "(", "-", "1", ",", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "one_hot", "(", "nz", ",", "n_classes", ")", ",", "z_original_shape", ")", "\n", "\n", "nx", "=", "np", ".", "asarray", "(", "nx", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "nz", "=", "np", ".", "asarray", "(", "nz", ",", "dtype", "=", "z", ".", "dtype", ")", "\n", "\n", "return", "(", "nx", ",", "nz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.minor_rotation": [[195, 222], ["float", "numpy.transpose", "numpy.reshape", "numpy.transpose", "numpy.transpose", "nz[].argmax", "numpy.reshape", "numpy.reshape", "numpy.asarray", "numpy.asarray", "numpy.random.uniform", "numpy.random.permutation", "rotate_scipy", "rotate_scipy", "one_hot"], "function", ["None"], ["", "def", "minor_rotation", "(", "x", ",", "z", ")", ":", "\n", "    ", "\"\"\"\n    Assuming a batch size of 1.\n    More specifically: x is (1, depth, channels, height, width) and z is (1, height*width*depth, classes)\n    \"\"\"", "\n", "from", "scipy", ".", "ndimage", ".", "interpolation", "import", "rotate", "as", "rotate_scipy", "\n", "from", "breze", ".", "learn", ".", "data", "import", "one_hot", "\n", "z_original_shape", "=", "z", ".", "shape", "\n", "n_classes", "=", "z", ".", "shape", "[", "-", "1", "]", "\n", "ang", "=", "float", "(", "np", ".", "random", ".", "uniform", "(", "-", "90", ",", "90", ")", ")", "\n", "axes", "=", "np", ".", "random", ".", "permutation", "(", "3", ")", "[", ":", "2", "]", "\n", "\n", "nx", "=", "np", ".", "transpose", "(", "x", ",", "(", "0", ",", "2", ",", "3", ",", "4", ",", "1", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "z", ",", "(", "1", ",", "x", ".", "shape", "[", "3", "]", ",", "x", ".", "shape", "[", "4", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "n_classes", ")", ")", "\n", "nz", "=", "np", ".", "transpose", "(", "nz", ",", "(", "0", ",", "4", ",", "1", ",", "2", ",", "3", ")", ")", "\n", "\n", "nx", "[", "0", "]", "=", "[", "rotate_scipy", "(", "modality", ",", "ang", ",", "axes", "=", "axes", ",", "order", "=", "3", ",", "reshape", "=", "False", ")", "for", "modality", "in", "nx", "[", "0", "]", "]", "\n", "nx", "=", "np", ".", "transpose", "(", "nx", ",", "(", "0", ",", "4", ",", "1", ",", "2", ",", "3", ")", ")", "\n", "nz", "[", "0", "]", "=", "[", "rotate_scipy", "(", "class_map", ",", "ang", ",", "axes", "=", "axes", ",", "order", "=", "3", ",", "reshape", "=", "False", ")", "for", "class_map", "in", "nz", "[", "0", "]", "]", "\n", "nz", "=", "nz", "[", "0", "]", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "nz", ",", "(", "-", "1", ",", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "one_hot", "(", "nz", ",", "n_classes", ")", ",", "z_original_shape", ")", "\n", "\n", "nx", "=", "np", ".", "asarray", "(", "nx", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "nz", "=", "np", ".", "asarray", "(", "nz", ",", "dtype", "=", "z", ".", "dtype", ")", "\n", "\n", "return", "(", "nx", ",", "nz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.full_rotation": [[223, 250], ["float", "numpy.transpose", "numpy.reshape", "numpy.transpose", "numpy.transpose", "nz[].argmax", "numpy.reshape", "numpy.reshape", "numpy.asarray", "numpy.asarray", "numpy.random.uniform", "numpy.random.permutation", "rotate_scipy", "rotate_scipy", "one_hot"], "function", ["None"], ["", "def", "full_rotation", "(", "x", ",", "z", ")", ":", "\n", "    ", "\"\"\"\n    Assuming a batch size of 1.\n    More specifically: x is (1, depth, channels, height, width) and z is (1, height*width*depth, classes)\n    \"\"\"", "\n", "from", "scipy", ".", "ndimage", ".", "interpolation", "import", "rotate", "as", "rotate_scipy", "\n", "from", "breze", ".", "learn", ".", "data", "import", "one_hot", "\n", "z_original_shape", "=", "z", ".", "shape", "\n", "n_classes", "=", "z", ".", "shape", "[", "-", "1", "]", "\n", "ang", "=", "float", "(", "np", ".", "random", ".", "uniform", "(", "0", ",", "360", ")", ")", "\n", "axes", "=", "np", ".", "random", ".", "permutation", "(", "3", ")", "[", ":", "2", "]", "\n", "\n", "nx", "=", "np", ".", "transpose", "(", "x", ",", "(", "0", ",", "2", ",", "3", ",", "4", ",", "1", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "z", ",", "(", "1", ",", "x", ".", "shape", "[", "3", "]", ",", "x", ".", "shape", "[", "4", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "n_classes", ")", ")", "\n", "nz", "=", "np", ".", "transpose", "(", "nz", ",", "(", "0", ",", "4", ",", "1", ",", "2", ",", "3", ")", ")", "\n", "\n", "nx", "[", "0", "]", "=", "[", "rotate_scipy", "(", "modality", ",", "ang", ",", "axes", "=", "axes", ",", "order", "=", "3", ",", "reshape", "=", "False", ")", "for", "modality", "in", "nx", "[", "0", "]", "]", "\n", "nx", "=", "np", ".", "transpose", "(", "nx", ",", "(", "0", ",", "4", ",", "1", ",", "2", ",", "3", ")", ")", "\n", "nz", "[", "0", "]", "=", "[", "rotate_scipy", "(", "class_map", ",", "ang", ",", "axes", "=", "axes", ",", "order", "=", "3", ",", "reshape", "=", "False", ")", "for", "class_map", "in", "nz", "[", "0", "]", "]", "\n", "nz", "=", "nz", "[", "0", "]", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "nz", ",", "(", "-", "1", ",", ")", ")", "\n", "nz", "=", "np", ".", "reshape", "(", "one_hot", "(", "nz", ",", "n_classes", ")", ",", "z_original_shape", ")", "\n", "\n", "nx", "=", "np", ".", "asarray", "(", "nx", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "nz", "=", "np", ".", "asarray", "(", "nz", ",", "dtype", "=", "z", ".", "dtype", ")", "\n", "\n", "return", "(", "nx", ",", "nz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.identity": [[251, 253], ["None"], "function", ["None"], ["", "def", "identity", "(", "x", ",", "z", ")", ":", "\n", "    ", "return", "(", "x", ",", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.nil": [[254, 259], ["numpy.zeros", "numpy.zeros"], "function", ["None"], ["", "def", "nil", "(", "x", ",", "z", ")", ":", "\n", "    ", "nx", "=", "np", ".", "zeros", "(", "x", ".", "shape", ")", "\n", "nz", "=", "np", ".", "zeros", "(", "z", ".", "shape", ")", "\n", "\n", "return", "(", "nx", ",", "nz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.random_transformation": [[260, 281], ["random.choice", "transform_fun", "random.choice", "second_transform_fun"], "function", ["None"], ["", "def", "random_transformation", "(", "x", ",", "z", ")", ":", "\n", "    ", "import", "random", "\n", "transformations", "=", "[", "'identity'", ",", "'random_flip'", ",", "'percentile_filter'", ",", "'full_rotation'", "]", "\n", "transform_dict", "=", "{", "\n", "'identity'", ":", "identity", ",", "\n", "'random_flip'", ":", "random_flip", ",", "\n", "'percentile_filter'", ":", "percentile_filter", ",", "\n", "'full_rotation'", ":", "full_rotation", "\n", "}", "\n", "\n", "transform_key", "=", "random", ".", "choice", "(", "transformations", ")", "\n", "transform_fun", "=", "transform_dict", "[", "transform_key", "]", "\n", "\n", "nx", ",", "nz", "=", "transform_fun", "(", "x", ",", "z", ")", "\n", "\n", "second_transform_key", "=", "random", ".", "choice", "(", "transformations", ")", "\n", "if", "second_transform_key", "==", "transform_key", ":", "\n", "        ", "return", "(", "nx", ",", "nz", ")", "\n", "", "else", ":", "\n", "        ", "second_transform_fun", "=", "transform_dict", "[", "second_transform_key", "]", "\n", "return", "second_transform_fun", "(", "nx", ",", "nz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.random_geometric_transformation": [[282, 302], ["random.choice", "transform_fun", "random.choice", "second_transform_fun"], "function", ["None"], ["", "", "def", "random_geometric_transformation", "(", "x", ",", "z", ")", ":", "\n", "    ", "import", "random", "\n", "transformations", "=", "[", "'identity'", ",", "'random_flip'", ",", "'full_rotation'", "]", "\n", "transform_dict", "=", "{", "\n", "'identity'", ":", "identity", ",", "\n", "'random_flip'", ":", "random_flip", ",", "\n", "'full_rotation'", ":", "full_rotation", "\n", "}", "\n", "\n", "transform_key", "=", "random", ".", "choice", "(", "transformations", ")", "\n", "transform_fun", "=", "transform_dict", "[", "transform_key", "]", "\n", "\n", "nx", ",", "nz", "=", "transform_fun", "(", "x", ",", "z", ")", "\n", "\n", "second_transform_key", "=", "random", ".", "choice", "(", "transformations", ")", "\n", "if", "second_transform_key", "==", "transform_key", ":", "\n", "        ", "return", "(", "nx", ",", "nz", ")", "\n", "", "else", ":", "\n", "        ", "second_transform_fun", "=", "transform_dict", "[", "second_transform_key", "]", "\n", "return", "second_transform_fun", "(", "nx", ",", "nz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.transformations.random_soft_geometric_transformation": [[303, 318], ["random.choice", "transform_fun"], "function", ["None"], ["", "", "def", "random_soft_geometric_transformation", "(", "x", ",", "z", ")", ":", "\n", "    ", "import", "random", "\n", "transformations", "=", "[", "'identity'", ",", "'random_flip'", ",", "'full_rotation'", "]", "\n", "transform_dict", "=", "{", "\n", "'identity'", ":", "identity", ",", "\n", "'random_flip'", ":", "random_flip", ",", "\n", "'full_rotation'", ":", "full_rotation", "\n", "}", "\n", "\n", "transform_key", "=", "random", ".", "choice", "(", "transformations", ")", "\n", "transform_fun", "=", "transform_dict", "[", "transform_key", "]", "\n", "\n", "nx", ",", "nz", "=", "transform_fun", "(", "x", ",", "z", ")", "\n", "\n", "return", "(", "nx", ",", "nz", ")", "", "", ""]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.model_defs.ModelDef.__init__": [[21, 62], ["isinstance", "isinstance"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "alpha", ",", "layer_vars", ",", "\n", "batchnorm", ",", "out_transfer", ",", "\n", "loss_id", "=", "None", ",", "loss_layer_def", "=", "None", ",", "\n", "size_reduction", "=", "0", ",", "bn_version", "=", "'new'", ",", "\n", "regularize", "=", "False", ",", "l1", "=", "None", ",", "l2", "=", "None", ",", "\n", "perform_transform", "=", "None", ",", "trans_for_valid", "=", "None", ",", "\n", "optimizer", "=", "(", "'adam'", ",", "{", "}", ")", ",", "alternate_size", "=", "None", ",", "\n", "initializer", "=", "'standard'", ")", ":", "\n", "        ", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "layer_vars", "=", "layer_vars", "\n", "self", ".", "batchnorm", "=", "batchnorm", "\n", "self", ".", "loss_id", "=", "loss_id", "\n", "self", ".", "loss_layer_def", "=", "loss_layer_def", "\n", "self", ".", "out_transfer", "=", "out_transfer", "\n", "self", ".", "size_reduction", "=", "size_reduction", "\n", "self", ".", "regularize", "=", "regularize", "\n", "self", ".", "l1", "=", "l1", "\n", "self", ".", "l2", "=", "l2", "\n", "self", ".", "bn_version", "=", "bn_version", "\n", "self", ".", "perform_transform", "=", "perform_transform", "\n", "self", ".", "trans_for_valid", "=", "trans_for_valid", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "alternate_size", "=", "alternate_size", "\n", "self", ".", "initializer", "=", "initializer", "\n", "for", "lv", "in", "self", ".", "layer_vars", ":", "\n", "            ", "if", "lv", "[", "'type'", "]", "==", "'batch_norm'", ":", "\n", "                ", "lv", "[", "'alpha'", "]", "=", "self", ".", "alpha", "\n", "if", "self", ".", "bn_version", "is", "not", "None", ":", "\n", "                    ", "lv", "[", "'version'", "]", "=", "self", ".", "bn_version", "\n", "\n", "", "", "", "if", "loss_id", "is", "None", ":", "\n", "            ", "lf", "=", "self", ".", "loss_layer_def", "[", "'loss_fun'", "]", "\n", "if", "isinstance", "(", "lf", ",", "str", ")", ":", "\n", "                ", "self", ".", "loss_name", "=", "lf", "\n", "", "else", ":", "\n", "                ", "self", ".", "loss_name", "=", "lf", ".", "__name__", "\n", "", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "loss_id", ",", "str", ")", ":", "\n", "                ", "self", ".", "loss_name", "=", "self", ".", "loss_id", "\n", "", "else", ":", "\n", "                ", "self", ".", "loss_name", "=", "self", ".", "loss_id", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.None.model_defs.get_model": [[1043, 1045], ["None"], "function", ["None"], ["def", "get_model", "(", "model_code", ")", ":", "\n", "    ", "return", "ready_models", "[", "model_code", "]", "", "", ""]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.helper.view_test_images.gen_ims": [[5, 9], ["None"], "function", ["None"], ["def", "gen_ims", "(", "image_stack", ")", ":", "\n", "    ", "for", "image", "in", "image_stack", ":", "\n", "#image = np.transpose(image, (1, 0, 2, 3))", "\n", "        ", "yield", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel.__init__": [[29, 114], ["model.SequentialModel._init_exprs", "ValueError", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.Lenet3d._init_exprs"], ["def", "__init__", "(", "self", ",", "image_height", ",", "image_width", ",", "\n", "image_depth", ",", "n_channels", ",", "n_output", ",", "\n", "layer_vars", ",", "out_transfer", ",", "loss_id", "=", "None", ",", "\n", "loss_layer_def", "=", "None", ",", "optimizer", "=", "'adam'", ",", "\n", "batch_size", "=", "1", ",", "max_iter", "=", "1000", ",", "\n", "using_bn", "=", "False", ",", "regularize", "=", "False", ",", "\n", "l1", "=", "None", ",", "l2", "=", "None", ",", "perform_transform", "=", "None", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "        ", "'''\n        :param n_output: Number of classes\n        :param layer_vars: list of dictionaries. Each dictionary specifies\n                           the type of a layer and the values of parameters\n                           associated with that kind of layer.\n                           Possible layers: conv, pool, deconv\n                           conv params: fs(:=filter shape), nkerns(:=feature maps),\n                                        transfer(:=non-linearity used), bm(:=border-mode),\n                                        stride(:=convolution stride), imp(:=theano implementation),\n                                        bias(:=True to use biases, False to omit them)\n                           pool params: ps(:=pool shape), transfer(:=non-linearity used)\n                           deconv params: fs(:=filter shape), nkerns(:=feature maps),\n                                        transfer(:=non-linearity used), imp(:=theano implementation),\n                                        bias(:=True to use biases, False to omit them),\n                                        up(:=upsampling factor)\n                           shortcut params: shortcut computes src.output + dst.output\n                                            src(:=index of src_layer), dst(:= index of dst_layer),\n                                            proj(:=projection to be used if src and dst have different\n                                            numbers of feature maps, 'zero_pad' or 'project'),\n                                            transfer(:=non_linearity used), imp(:=theano implementation,\n                                            only relevant if src and dst have different numbers of\n                                            feature maps and proj=='project')\n                           non_linearity params: transfer(:=non-linearity used)\n                           see: basic.Conv3d, basic.MaxPool3d, basic.Deconv, basic.Shortcut,\n                                basic.NonLinearity\n\n        :param out_transfer: output non-linearity, has to be a callable\n        :param loss_id: loss function, has to be a callable or the name\n                        of a loss function included in breze.arch.component.loss\n        :param optimizer: name of an optimizer supported by climin\n        :param batch_size: size of an input batch\n        :param max_iter: maximum number of training iterations\n        '''", "\n", "self", ".", "image_height", "=", "image_height", "\n", "self", ".", "image_width", "=", "image_width", "\n", "self", ".", "image_depth", "=", "image_depth", "\n", "self", ".", "n_channels", "=", "n_channels", "\n", "self", ".", "n_output", "=", "n_output", "\n", "self", ".", "layer_vars", "=", "layer_vars", "\n", "self", ".", "out_transfer", "=", "out_transfer", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "using_bn", "=", "using_bn", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "regularize", "=", "regularize", "\n", "if", "self", ".", "regularize", ":", "\n", "            ", "if", "l1", "is", "None", "and", "l2", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "'Asked to use regularization but no input for l1 or l2.'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "l1", "=", "l1", "\n", "self", ".", "l2", "=", "l2", "\n", "\n", "", "", "if", "loss_layer_def", "is", "None", ":", "\n", "            ", "if", "loss_id", "is", "not", "None", ":", "\n", "                ", "self", ".", "loss_id", "=", "loss_id", "\n", "self", ".", "loss_layer_def", "=", "None", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Either loss id or loss layer definition has to be specified.'", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "loss_id", "is", "None", ":", "\n", "                ", "self", ".", "loss_layer_def", "=", "loss_layer_def", "\n", "self", ".", "loss_id", "=", "None", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'loss_id and loss_layer_def can not be used at the same time.'", ")", "\n", "", "", "self", ".", "perform_transform", "=", "perform_transform", "\n", "\n", "self", ".", "_init_exprs", "(", ")", "\n", "\n", "if", "self", ".", "using_bn", ":", "\n", "            ", "self", ".", "ext_phase", "=", "0", "\n", "self", ".", "phase_select", "=", "self", ".", "_phase_select", "\n", "self", ".", "reset_phase", "=", "self", ".", "_reset_phase", "\n", "", "else", ":", "\n", "            ", "self", ".", "ext_phase", "=", "None", "\n", "self", ".", "phase_select", "=", "None", "\n", "self", ".", "reset_phase", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel._make_loss_layer": [[115, 136], ["basic.SupervisedMultiLoss", "predictions.append", "layers[].get_output"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.get_output"], ["", "", "def", "_make_loss_layer", "(", "self", ",", "lv", ",", "target", ",", "declare", ",", "imp_weight", ")", ":", "\n", "        ", "mode", "=", "lv", "[", "'mode'", "]", "\n", "if", "mode", "==", "'weighted'", ":", "\n", "            ", "p_weights", "=", "lv", "[", "'weights'", "]", "\n", "", "else", ":", "\n", "            ", "p_weights", "=", "None", "\n", "", "loss_fun", "=", "lv", "[", "'loss_fun'", "]", "\n", "p_indices", "=", "lv", "[", "'predictions'", "]", "\n", "transfer", "=", "lv", "[", "'transfer'", "]", "if", "'transfer'", "in", "lv", "else", "self", ".", "out_transfer", "\n", "\n", "layers", "=", "self", ".", "conv_net", ".", "layers", "\n", "\n", "predictions", "=", "[", "]", "\n", "for", "p_i", "in", "p_indices", ":", "\n", "            ", "predictions", ".", "append", "(", "layers", "[", "p_i", "]", ".", "get_output", "(", ")", ")", "\n", "\n", "", "self", ".", "loss_layer", "=", "SupervisedMultiLoss", "(", "\n", "target", "=", "target", ",", "predictions", "=", "predictions", ",", "\n", "loss", "=", "loss_fun", ",", "mode", "=", "mode", ",", "\n", "p_weights", "=", "p_weights", ",", "imp_weight", "=", "imp_weight", ",", "\n", "transfer", "=", "transfer", ",", "declare", "=", "declare", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel._init_exprs": [[138, 184], ["model.tensor5", "theano.tensor3", "theano.tensor3", "breze.arch.util.ParameterSet", "cnn3d.SequentialModel", "breze.learn.base.SupervisedModel.__init__", "theano.matrix", "theano.matrix", "breze.arch.construct.simple.SupervisedLoss", "model.SequentialModel._make_loss_layer", "model.SequentialModel.exprs[].copy", "theano.sum", "theano.sum", "theano.sum", "theano.sum", "theano.abs_", "theano.abs_", "theano.sqr", "theano.sqr"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.tensor5", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel._make_loss_layer"], ["", "def", "_init_exprs", "(", "self", ")", ":", "\n", "        ", "inpt", "=", "tensor5", "(", "'inpt'", ")", "\n", "target", "=", "T", ".", "tensor3", "(", "'target'", ")", "\n", "\n", "parameters", "=", "ParameterSet", "(", ")", "\n", "\n", "self", ".", "conv_net", "=", "cnn3d", ".", "SequentialModel", "(", "\n", "inpt", "=", "inpt", ",", "image_height", "=", "self", ".", "image_height", ",", "\n", "image_width", "=", "self", ".", "image_width", ",", "image_depth", "=", "self", ".", "image_depth", ",", "\n", "n_channels", "=", "self", ".", "n_channels", ",", "out_transfer", "=", "self", ".", "out_transfer", ",", "\n", "layer_vars", "=", "self", ".", "layer_vars", ",", "using_bn", "=", "self", ".", "using_bn", ",", "\n", "declare", "=", "parameters", ".", "declare", "\n", ")", "\n", "\n", "output", "=", "self", ".", "conv_net", ".", "output", "\n", "\n", "if", "self", ".", "imp_weight", ":", "\n", "            ", "imp_weight", "=", "T", ".", "matrix", "(", "'imp_weight'", ")", "\n", "", "else", ":", "\n", "            ", "imp_weight", "=", "None", "\n", "\n", "", "if", "self", ".", "loss_id", "is", "not", "None", ":", "\n", "            ", "self", ".", "loss_layer", "=", "SupervisedLoss", "(", "\n", "target", ",", "output", ",", "loss", "=", "self", ".", "loss_id", ",", "\n", "imp_weight", "=", "imp_weight", ",", "declare", "=", "parameters", ".", "declare", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_make_loss_layer", "(", "\n", "lv", "=", "self", ".", "loss_layer_def", ",", "target", "=", "target", ",", "\n", "imp_weight", "=", "imp_weight", ",", "declare", "=", "parameters", ".", "declare", "\n", ")", "\n", "\n", "", "SupervisedModel", ".", "__init__", "(", "self", ",", "inpt", "=", "inpt", ",", "target", "=", "target", ",", "\n", "output", "=", "output", ",", "\n", "loss", "=", "self", ".", "loss_layer", ".", "total", ",", "\n", "parameters", "=", "parameters", ")", "\n", "\n", "self", ".", "exprs", "[", "'imp_weight'", "]", "=", "imp_weight", "\n", "if", "self", ".", "regularize", ":", "\n", "            ", "self", ".", "exprs", "[", "'true_loss'", "]", "=", "self", ".", "exprs", "[", "'loss'", "]", ".", "copy", "(", ")", "\n", "if", "self", ".", "l2", "is", "not", "None", ":", "\n", "                ", "l2_reg", "=", "T", ".", "sum", "(", "T", ".", "sqr", "(", "self", ".", "parameters", ".", "flat", ")", ")", "*", "self", ".", "l2", "/", "2", "\n", "self", ".", "exprs", "[", "'loss'", "]", "+=", "l2_reg", "\n", "", "if", "self", ".", "l1", "is", "not", "None", ":", "\n", "                ", "l1_reg", "=", "T", ".", "sum", "(", "T", ".", "abs_", "(", "self", ".", "parameters", ".", "flat", ")", ")", "*", "self", ".", "l1", "\n", "self", ".", "exprs", "[", "'loss'", "]", "+=", "l1_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel._phase_select": [[185, 196], ["model.SequentialModel.conv_net.layers[].set_phase", "ValueError"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.set_phase"], ["", "", "", "def", "_phase_select", "(", "self", ",", "phase_id", ")", ":", "\n", "        ", "if", "phase_id", "==", "'train'", ":", "\n", "            ", "phase", "=", "0", "\n", "", "elif", "phase_id", "==", "'valid'", "or", "phase_id", "==", "'infer'", ":", "\n", "            ", "phase", "=", "1", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Phases are: train, valid, infer'", ")", "\n", "\n", "", "self", ".", "ext_phase", "=", "phase", "\n", "for", "l_index", "in", "self", ".", "conv_net", ".", "bn_layers", ":", "\n", "            ", "self", ".", "conv_net", ".", "layers", "[", "l_index", "]", ".", "set_phase", "(", "phase", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel._reset_phase": [[197, 199], ["model.SequentialModel.phase_select"], "methods", ["None"], ["", "", "def", "_reset_phase", "(", "self", ")", ":", "\n", "        ", "self", ".", "phase_select", "(", "phase_id", "=", "'train'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel.get_batchnorm_params": [[200, 215], ["model.SequentialModel.conv_net.layers[].submit", "numpy.asarray", "numpy.asarray", "batchnorm_params.append", "isinstance", "mean.as_numpy_array.as_numpy_array.as_numpy_array", "std.as_numpy_array.as_numpy_array.as_numpy_array"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.submit"], ["", "def", "get_batchnorm_params", "(", "self", ")", ":", "\n", "        ", "batchnorm_params", "=", "[", "]", "\n", "for", "l_index", "in", "self", ".", "conv_net", ".", "bn_layers", ":", "\n", "            ", "mean", ",", "std", "=", "self", ".", "conv_net", ".", "layers", "[", "l_index", "]", ".", "submit", "(", ")", "\n", "if", "not", "isinstance", "(", "mean", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "mean", "=", "mean", ".", "as_numpy_array", "(", ")", "\n", "std", "=", "std", ".", "as_numpy_array", "(", ")", "\n", "\n", "", "mean", "=", "np", ".", "asarray", "(", "mean", ",", "dtype", "=", "'float32'", ")", "\n", "std", "=", "np", ".", "asarray", "(", "std", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "mean_and_std", "=", "(", "mean", ",", "std", ")", "\n", "batchnorm_params", ".", "append", "(", "mean_and_std", ")", "\n", "\n", "", "return", "batchnorm_params", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel.set_batchnorm_params": [[216, 224], ["model.SequentialModel.conv_net.layers[].running_mean.set_value", "model.SequentialModel.conv_net.layers[].running_std.set_value"], "methods", ["None"], ["", "def", "set_batchnorm_params", "(", "self", ",", "batchnorm_params", ")", ":", "\n", "        ", "index", "=", "0", "\n", "for", "l_index", "in", "self", ".", "conv_net", ".", "bn_layers", ":", "\n", "            ", "mean", ",", "std", "=", "batchnorm_params", "[", "index", "]", "\n", "\n", "self", ".", "conv_net", ".", "layers", "[", "l_index", "]", ".", "running_mean", ".", "set_value", "(", "mean", ")", "\n", "self", ".", "conv_net", ".", "layers", "[", "l_index", "]", ".", "running_std", ".", "set_value", "(", "std", ")", "\n", "index", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel.get_params": [[225, 239], ["enumerate", "hasattr", "hasattr"], "methods", ["None"], ["", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "layers", "=", "self", ".", "conv_net", ".", "layers", "\n", "params", "=", "self", ".", "parameters", "\n", "\n", "for", "i", ",", "l", "in", "enumerate", "(", "layers", ")", ":", "\n", "            ", "if", "hasattr", "(", "l", ",", "'weights'", ")", ":", "\n", "                ", "w", "=", "params", "[", "l", ".", "weights", "]", "\n", "", "else", ":", "\n", "                ", "w", "=", "None", "\n", "", "if", "hasattr", "(", "l", ",", "'bias'", ")", ":", "\n", "                ", "b", "=", "params", "[", "l", ".", "bias", "]", "\n", "", "else", ":", "\n", "                ", "b", "=", "None", "\n", "", "yield", "(", "w", ",", "b", ",", "i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.SequentialModel.initialize_xavier_weights": [[240, 252], ["hasattr", "layer.get_weights", "layer.get_fan_in", "hasattr", "numpy.random.normal", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv.get_weights", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv.get_fan_in"], ["", "", "def", "initialize_xavier_weights", "(", "self", ")", ":", "\n", "        ", "layers", "=", "self", ".", "conv_net", ".", "layers", "\n", "params", "=", "self", ".", "parameters", "\n", "\n", "for", "layer", "in", "layers", ":", "\n", "            ", "if", "hasattr", "(", "layer", ",", "'weights'", ")", ":", "\n", "                ", "w", "=", "layer", ".", "get_weights", "(", ")", "\n", "fan_in", "=", "layer", ".", "get_fan_in", "(", ")", "\n", "params", "[", "w", "]", "=", "np", ".", "random", ".", "normal", "(", "0.", ",", "1.", ",", "params", "[", "w", "]", ".", "shape", ")", "*", "np", ".", "sqrt", "(", "2.", "/", "fan_in", ")", "\n", "", "elif", "hasattr", "(", "layer", ",", "'a'", ")", ":", "\n", "                ", "a", "=", "layer", ".", "a", "\n", "params", "[", "a", "]", "=", "0.25", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.FCN.__init__": [[255, 298], ["model.FCN._init_exprs", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.Lenet3d._init_exprs"], ["    ", "def", "__init__", "(", "self", ",", "image_height", ",", "image_width", ",", "image_depth", ",", "\n", "n_channel", ",", "n_output", ",", "n_hiddens_conv", ",", "down_filter_shapes", ",", "\n", "hidden_transfers_conv", ",", "down_pools", ",", "n_hiddens_upconv", ",", "\n", "up_filter_shapes", ",", "hidden_transfers_upconv", ",", "up_pools", ",", "\n", "out_transfer", ",", "loss", ",", "optimizer", "=", "'adam'", ",", "\n", "bm_up", "=", "'same'", ",", "bm_down", "=", "'same'", ",", "\n", "batch_size", "=", "1", ",", "max_iter", "=", "1000", ",", "\n", "strides_d", "=", "(", "1", ",", "1", ",", "1", ")", ",", "up_factors", "=", "(", "2", ",", "2", ",", "2", ")", ",", "\n", "verbose", "=", "False", ",", "implementation", "=", "False", ")", ":", "\n", "        ", "assert", "len", "(", "hidden_transfers_conv", ")", "==", "len", "(", "n_hiddens_conv", ")", "\n", "assert", "len", "(", "down_filter_shapes", ")", "==", "len", "(", "n_hiddens_conv", ")", "\n", "assert", "len", "(", "down_pools", ")", "==", "len", "(", "n_hiddens_conv", ")", "\n", "\n", "assert", "len", "(", "hidden_transfers_upconv", ")", "==", "len", "(", "n_hiddens_upconv", ")", "\n", "assert", "len", "(", "up_filter_shapes", ")", "==", "len", "(", "n_hiddens_upconv", ")", "\n", "assert", "len", "(", "up_pools", ")", "==", "len", "(", "n_hiddens_upconv", ")", "\n", "\n", "self", ".", "image_height", "=", "image_height", "\n", "self", ".", "image_width", "=", "image_width", "\n", "self", ".", "image_depth", "=", "image_depth", "\n", "self", ".", "n_channel", "=", "n_channel", "\n", "self", ".", "n_output", "=", "n_output", "\n", "self", ".", "n_hiddens_conv", "=", "n_hiddens_conv", "\n", "self", ".", "down_filter_shapes", "=", "down_filter_shapes", "\n", "self", ".", "hidden_transfers_conv", "=", "hidden_transfers_conv", "\n", "self", ".", "down_pools", "=", "down_pools", "\n", "self", ".", "n_hiddens_upconv", "=", "n_hiddens_upconv", "\n", "self", ".", "up_filter_shapes", "=", "up_filter_shapes", "\n", "self", ".", "hidden_transfers_upconv", "=", "hidden_transfers_upconv", "\n", "self", ".", "up_pools", "=", "up_pools", "\n", "self", ".", "out_transfer", "=", "out_transfer", "\n", "self", ".", "loss_ident", "=", "loss", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "bm_down", "=", "bm_down", "\n", "self", ".", "bm_up", "=", "bm_up", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "implementation", "=", "implementation", "\n", "self", ".", "strides_d", "=", "strides_d", "\n", "self", ".", "up_factors", "=", "up_factors", "\n", "\n", "self", ".", "_init_exprs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.FCN._init_exprs": [[299, 351], ["model.tensor5", "theano.tensor3", "theano.tensor3", "breze.arch.util.ParameterSet", "cnn3d.FCN", "breze.arch.construct.simple.SupervisedLoss", "breze.learn.base.SupervisedModel.__init__", "theano.matrix", "theano.matrix", "model.FCN.loss_layer.sample_wise.mean"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.tensor5", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["", "def", "_init_exprs", "(", "self", ")", ":", "\n", "        ", "inpt", "=", "tensor5", "(", "'inpt'", ")", "\n", "#inpt.tag.test_value = np.zeros((", "\n", "#    2, self.image_depth, self.n_channel,", "\n", "#    self.image_height, self.image_width", "\n", "#))", "\n", "\n", "target", "=", "T", ".", "tensor3", "(", "'target'", ")", "\n", "#target.tag.test_value = np.zeros((", "\n", "#    2,self.image_depth*self.image_width*self.image_height, self.n_output", "\n", "#))", "\n", "\n", "parameters", "=", "ParameterSet", "(", ")", "\n", "\n", "self", ".", "conv_net", "=", "cnn3d", ".", "FCN", "(", "\n", "inpt", "=", "inpt", ",", "image_height", "=", "self", ".", "image_height", ",", "\n", "image_width", "=", "self", ".", "image_width", ",", "image_depth", "=", "self", ".", "image_depth", ",", "\n", "n_channel", "=", "self", ".", "n_channel", ",", "n_hiddens_conv", "=", "self", ".", "n_hiddens_conv", ",", "\n", "hidden_transfers_conv", "=", "self", ".", "hidden_transfers_conv", ",", "\n", "n_hiddens_upconv", "=", "self", ".", "n_hiddens_upconv", ",", "\n", "hidden_transfers_upconv", "=", "self", ".", "hidden_transfers_upconv", ",", "\n", "d_filter_shapes", "=", "self", ".", "down_filter_shapes", ",", "\n", "u_filter_shapes", "=", "self", ".", "up_filter_shapes", ",", "\n", "down_pools", "=", "self", ".", "down_pools", ",", "\n", "up_pools", "=", "self", ".", "up_pools", ",", "\n", "out_transfer", "=", "self", ".", "out_transfer", ",", "\n", "b_modes_down", "=", "self", ".", "bm_down", ",", "\n", "b_modes_up", "=", "self", ".", "bm_up", ",", "\n", "implementation", "=", "self", ".", "implementation", ",", "\n", "strides_down", "=", "self", ".", "strides_d", ",", "\n", "up_factors", "=", "self", ".", "up_factors", ",", "\n", "declare", "=", "parameters", ".", "declare", "\n", ")", "\n", "\n", "output", "=", "self", ".", "conv_net", ".", "output", "\n", "\n", "if", "self", ".", "imp_weight", ":", "\n", "            ", "imp_weight", "=", "T", ".", "matrix", "(", "'imp_weight'", ")", "\n", "", "else", ":", "\n", "            ", "imp_weight", "=", "None", "\n", "\n", "", "self", ".", "loss_layer", "=", "SupervisedLoss", "(", "\n", "target", ",", "output", ",", "loss", "=", "self", ".", "loss_ident", ",", "\n", "imp_weight", "=", "imp_weight", ",", "declare", "=", "parameters", ".", "declare", "\n", ")", "\n", "\n", "SupervisedModel", ".", "__init__", "(", "self", ",", "inpt", "=", "inpt", ",", "target", "=", "target", ",", "\n", "output", "=", "output", ",", "\n", "loss", "=", "self", ".", "loss_layer", ".", "sample_wise", ".", "mean", "(", ")", ",", "\n", "parameters", "=", "parameters", ")", "\n", "\n", "self", ".", "exprs", "[", "'imp_weight'", "]", "=", "imp_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.ConvNet3d.__init__": [[354, 407], ["model.ConvNet3d._init_exprs", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.Lenet3d._init_exprs"], ["    ", "def", "__init__", "(", "self", ",", "image_height", ",", "image_width", ",", "image_depth", ",", "\n", "n_channel", ",", "n_hiddens_conv", ",", "filter_shapes", ",", "pool_shapes", ",", "\n", "n_hiddens_full", ",", "n_output", ",", "hidden_transfers_conv", ",", "\n", "hidden_transfers_full", ",", "out_transfer", ",", "loss", ",", "optimizer", "=", "'adam'", ",", "\n", "batch_size", "=", "1", ",", "max_iter", "=", "1000", ",", "verbose", "=", "False", ",", "border_modes", "=", "'valid'", ",", "\n", "implementation", "=", "'dnn_conv3d'", ",", "\n", "dropout", "=", "False", ")", ":", "\n", "        ", "\"\"\"Flexible Convolutional neural network model\n\n        Some key things to know:\n        :param pool_shapes: list of 3-tuples or string-flags. e.g:\n                            [(2,2,2), 'no_pool', (2,2,2)]\n                            'no_pool' is to skip pooling whenever necessary.\n\n        Future work:\n        This model shouldn't actually have fully-connected layers. Rather, it should\n        turn fully-connected layers into convolutional layers as follows:\n        FC layer that takes (4*4*4)*10 inpt and outputs 1000 neurons will be turned\n        into a convolutional layer with 4*4*4 receptive fields outputting on 1000 feature\n        maps, thus producing a (1*1*1)*1000 output. If the output of the classification layer\n        has 3 neurons (3 classes), then after the conversion you'll get a (1*1*1)*3 output, which\n        will be reshaped to 3 neurons afterwards.\n        \"\"\"", "\n", "assert", "len", "(", "hidden_transfers_conv", ")", "==", "len", "(", "n_hiddens_conv", ")", "\n", "assert", "len", "(", "n_hiddens_conv", ")", "==", "len", "(", "filter_shapes", ")", "\n", "\n", "assert", "len", "(", "pool_shapes", ")", "==", "len", "(", "filter_shapes", ")", "\n", "assert", "len", "(", "hidden_transfers_full", ")", "==", "len", "(", "n_hiddens_full", ")", "\n", "\n", "self", ".", "image_height", "=", "image_height", "\n", "self", ".", "image_width", "=", "image_width", "\n", "self", ".", "image_depth", "=", "image_depth", "\n", "self", ".", "n_channel", "=", "n_channel", "\n", "self", ".", "n_hiddens_conv", "=", "n_hiddens_conv", "\n", "self", ".", "filter_shapes", "=", "filter_shapes", "\n", "self", ".", "pool_shapes", "=", "pool_shapes", "\n", "self", ".", "n_hiddens_full", "=", "n_hiddens_full", "\n", "self", ".", "n_output", "=", "n_output", "\n", "self", ".", "hidden_transfers_conv", "=", "hidden_transfers_conv", "\n", "self", ".", "hidden_transfers_full", "=", "hidden_transfers_full", "\n", "self", ".", "out_transfer", "=", "out_transfer", "\n", "self", ".", "loss_ident", "=", "loss", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "implementation", "=", "implementation", "\n", "\n", "self", ".", "dropout", "=", "dropout", "\n", "\n", "self", ".", "border_modes", "=", "border_modes", "\n", "\n", "self", ".", "_init_exprs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.ConvNet3d._init_exprs": [[408, 468], ["model.tensor5", "numpy.zeros", "theano.matrix", "theano.matrix", "numpy.zeros", "breze.arch.util.ParameterSet", "cnn3d.ConvNet3d", "breze.arch.construct.simple.SupervisedLoss", "breze.learn.base.SupervisedModel.__init__", "theano.matrix", "theano.matrix", "breze.arch.util.lookup", "len"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.tensor5", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["", "def", "_init_exprs", "(", "self", ")", ":", "\n", "        ", "inpt", "=", "tensor5", "(", "'inpt'", ")", "\n", "inpt", ".", "tag", ".", "test_value", "=", "np", ".", "zeros", "(", "(", "\n", "2", ",", "self", ".", "image_depth", ",", "self", ".", "n_channel", ",", "\n", "self", ".", "image_height", ",", "self", ".", "image_width", "\n", ")", ")", "\n", "\n", "target", "=", "T", ".", "matrix", "(", "'target'", ")", "\n", "target", ".", "tag", ".", "test_value", "=", "np", ".", "zeros", "(", "(", "\n", "2", ",", "self", ".", "n_output", "\n", ")", ")", "\n", "\n", "parameters", "=", "ParameterSet", "(", ")", "\n", "\n", "if", "self", ".", "dropout", ":", "\n", "            ", "self", ".", "p_dropout_inpt", "=", ".2", "\n", "self", ".", "p_dropout_hiddens", "=", "[", ".5", "]", "*", "len", "(", "self", ".", "n_hiddens_full", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "p_dropout_inpt", "=", "None", "\n", "self", ".", "p_dropout_hiddens", "=", "None", "\n", "\n", "", "self", ".", "conv_net", "=", "cnn3d", ".", "ConvNet3d", "(", "\n", "inpt", "=", "inpt", ",", "image_height", "=", "self", ".", "image_height", ",", "\n", "image_width", "=", "self", ".", "image_width", ",", "image_depth", "=", "self", ".", "image_depth", ",", "\n", "n_channel", "=", "self", ".", "n_channel", ",", "n_hiddens_conv", "=", "self", ".", "n_hiddens_conv", ",", "\n", "filter_shapes", "=", "self", ".", "filter_shapes", ",", "pool_shapes", "=", "self", ".", "pool_shapes", ",", "\n", "n_hiddens_full", "=", "self", ".", "n_hiddens_full", ",", "\n", "hidden_transfers_conv", "=", "self", ".", "hidden_transfers_conv", ",", "\n", "hidden_transfers_full", "=", "self", ".", "hidden_transfers_full", ",", "n_output", "=", "self", ".", "n_output", ",", "\n", "out_transfer", "=", "self", ".", "out_transfer", ",", "\n", "border_modes", "=", "self", ".", "border_modes", ",", "\n", "declare", "=", "parameters", ".", "declare", ",", "\n", "implementation", "=", "self", ".", "implementation", ",", "\n", "dropout", "=", "self", ".", "dropout", ",", "p_dropout_inpt", "=", "self", ".", "p_dropout_inpt", ",", "\n", "p_dropout_hiddens", "=", "self", ".", "p_dropout_hiddens", "\n", ")", "\n", "\n", "output", "=", "self", ".", "conv_net", ".", "output", "\n", "\n", "if", "self", ".", "imp_weight", ":", "\n", "            ", "imp_weight", "=", "T", ".", "matrix", "(", "'imp_weight'", ")", "\n", "", "else", ":", "\n", "            ", "imp_weight", "=", "None", "\n", "\n", "", "if", "not", "self", ".", "dropout", ":", "\n", "            ", "loss_id", "=", "self", ".", "loss_ident", "\n", "", "else", ":", "\n", "            ", "loss_id", "=", "lookup", "(", "self", ".", "loss_ident", ",", "vp_loss", ")", "\n", "\n", "", "self", ".", "loss_layer", "=", "SupervisedLoss", "(", "\n", "target", ",", "output", ",", "loss", "=", "loss_id", ",", "\n", "imp_weight", "=", "imp_weight", ",", "declare", "=", "parameters", ".", "declare", "\n", ")", "\n", "\n", "SupervisedModel", ".", "__init__", "(", "self", ",", "inpt", "=", "inpt", ",", "target", "=", "target", ",", "\n", "output", "=", "output", ",", "\n", "loss", "=", "self", ".", "loss_layer", ".", "total", ",", "\n", "parameters", "=", "parameters", ")", "\n", "\n", "self", ".", "exprs", "[", "'imp_weight'", "]", "=", "imp_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.Lenet3d.__init__": [[472, 505], ["model.Lenet3d._init_exprs", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.Lenet3d._init_exprs"], ["    ", "def", "__init__", "(", "self", ",", "image_height", ",", "image_width", ",", "image_depth", ",", "\n", "n_channel", ",", "n_hiddens_conv", ",", "filter_shapes", ",", "pool_shapes", ",", "\n", "n_hiddens_full", ",", "n_output", ",", "hidden_transfers_conv", ",", "\n", "hidden_transfers_full", ",", "out_transfer", ",", "loss", ",", "optimizer", "=", "'adam'", ",", "\n", "batch_size", "=", "1", ",", "max_iter", "=", "1000", ",", "verbose", "=", "False", ",", "implementation", "=", "'dnn_conv3d'", ",", "\n", "pool", "=", "True", ")", ":", "\n", "        ", "assert", "len", "(", "hidden_transfers_conv", ")", "==", "len", "(", "n_hiddens_conv", ")", "\n", "assert", "len", "(", "n_hiddens_conv", ")", "==", "len", "(", "filter_shapes", ")", "\n", "\n", "assert", "len", "(", "pool_shapes", ")", "==", "len", "(", "filter_shapes", ")", "\n", "assert", "len", "(", "hidden_transfers_full", ")", "==", "len", "(", "n_hiddens_full", ")", "\n", "\n", "self", ".", "image_height", "=", "image_height", "\n", "self", ".", "image_width", "=", "image_width", "\n", "self", ".", "image_depth", "=", "image_depth", "\n", "self", ".", "n_channel", "=", "n_channel", "\n", "self", ".", "n_hiddens_conv", "=", "n_hiddens_conv", "\n", "self", ".", "n_hiddens_full", "=", "n_hiddens_full", "\n", "self", ".", "filter_shapes", "=", "filter_shapes", "\n", "self", ".", "pool_shapes", "=", "pool_shapes", "\n", "self", ".", "n_output", "=", "n_output", "\n", "self", ".", "hidden_transfers_conv", "=", "hidden_transfers_conv", "\n", "self", ".", "hidden_transfers_full", "=", "hidden_transfers_full", "\n", "self", ".", "out_transfer", "=", "out_transfer", "\n", "self", ".", "loss_ident", "=", "loss", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "implementation", "=", "implementation", "\n", "self", ".", "pool", "=", "pool", "\n", "\n", "self", ".", "_init_exprs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.Lenet3d._init_exprs": [[506, 549], ["model.tensor5", "numpy.zeros", "theano.matrix", "theano.matrix", "numpy.zeros", "breze.arch.util.ParameterSet", "cnn3d.Lenet3d", "breze.arch.construct.simple.SupervisedLoss", "breze.learn.base.SupervisedModel.__init__", "theano.matrix", "theano.matrix"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.tensor5", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["", "def", "_init_exprs", "(", "self", ")", ":", "\n", "        ", "inpt", "=", "tensor5", "(", "'inpt'", ")", "\n", "inpt", ".", "tag", ".", "test_value", "=", "np", ".", "zeros", "(", "(", "\n", "2", ",", "self", ".", "image_depth", ",", "self", ".", "n_channel", ",", "\n", "self", ".", "image_height", ",", "self", ".", "image_width", "\n", ")", ")", "\n", "\n", "target", "=", "T", ".", "matrix", "(", "'target'", ")", "\n", "target", ".", "tag", ".", "test_value", "=", "np", ".", "zeros", "(", "(", "\n", "2", ",", "self", ".", "n_output", "\n", ")", ")", "\n", "\n", "parameters", "=", "ParameterSet", "(", ")", "\n", "\n", "self", ".", "lenet", "=", "cnn3d", ".", "Lenet3d", "(", "\n", "inpt", ",", "self", ".", "image_height", ",", "\n", "self", ".", "image_width", ",", "self", ".", "image_depth", ",", "\n", "self", ".", "n_channel", ",", "self", ".", "n_hiddens_conv", ",", "\n", "self", ".", "filter_shapes", ",", "self", ".", "pool_shapes", ",", "\n", "self", ".", "n_hiddens_full", ",", "self", ".", "hidden_transfers_conv", ",", "\n", "self", ".", "hidden_transfers_full", ",", "self", ".", "n_output", ",", "\n", "self", ".", "out_transfer", ",", "\n", "declare", "=", "parameters", ".", "declare", ",", "\n", "implementation", "=", "self", ".", "implementation", ",", "\n", "pool", "=", "self", ".", "pool", "\n", ")", "\n", "\n", "if", "self", ".", "imp_weight", ":", "\n", "            ", "imp_weight", "=", "T", ".", "matrix", "(", "'imp_weight'", ")", "\n", "", "else", ":", "\n", "            ", "imp_weight", "=", "None", "\n", "\n", "", "self", ".", "loss_layer", "=", "SupervisedLoss", "(", "\n", "target", ",", "self", ".", "lenet", ".", "output", ",", "loss", "=", "self", ".", "loss_ident", ",", "\n", "imp_weight", "=", "imp_weight", ",", "declare", "=", "parameters", ".", "declare", "\n", ")", "\n", "\n", "SupervisedModel", ".", "__init__", "(", "self", ",", "inpt", "=", "inpt", ",", "target", "=", "target", ",", "\n", "output", "=", "self", ".", "lenet", ".", "output", ",", "\n", "loss", "=", "self", ".", "loss_layer", ".", "total", ",", "\n", "parameters", "=", "parameters", ")", "\n", "\n", "self", ".", "exprs", "[", "'imp_weight'", "]", "=", "imp_weight", "\n", "", "", ""]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.model.tensor5": [[15, 24], ["theano.tensor.type.TensorType", "theano.tensor.type.TensorType."], "function", ["None"], ["def", "tensor5", "(", "name", "=", "None", ",", "dtype", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Returns a symbolic 5D tensor variable.\n    \"\"\"", "\n", "if", "dtype", "is", "None", ":", "\n", "        ", "dtype", "=", "theano", ".", "config", ".", "floatX", "\n", "\n", "", "type", "=", "TensorType", "(", "dtype", ",", "(", "(", "False", ",", ")", "*", "5", ")", ")", "\n", "return", "type", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Conv3d.__init__": [[57, 111], ["breze.arch.construct.base.Layer.__init__", "warnings.warn", "ValueError", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "inpt_width", ",", "\n", "inpt_depth", ",", "n_inpt", ",", "filter_height", ",", "\n", "filter_width", ",", "filter_depth", ",", "n_output", ",", "\n", "transfer", "=", "'identity'", ",", "n_samples", "=", "None", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ",", "border_mode", "=", "'valid'", ",", "\n", "implementation", "=", "'dnn_conv3d'", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "use_bias", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Create one layer of 3d convolution.\n        Notes: strides don't work the way they're supposed to with regular\n               convolution. First an un-strided convolution takes place\n               and then the result is downsized by discarding elements using\n               the strides. e.g.: Input size: 48*48*48 -> Conv 3*3*3 -> 46*46*46\n                                  -> Stride 2, discards every other voxel -> 23*23*23\n                                  Rule of thumb: new_dim = (old_dim - f + 1) / stride\n        \"\"\"", "\n", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "inpt_height", "=", "inpt_height", "\n", "self", ".", "inpt_width", "=", "inpt_width", "\n", "self", ".", "inpt_depth", "=", "inpt_depth", "\n", "self", ".", "n_inpt", "=", "n_inpt", "\n", "\n", "self", ".", "filter_height", "=", "filter_height", "\n", "self", ".", "filter_width", "=", "filter_width", "\n", "self", ".", "filter_depth", "=", "filter_depth", "\n", "\n", "self", ".", "n_output", "=", "n_output", "\n", "if", "transfer", "!=", "'identity'", ":", "\n", "            ", "warnings", ".", "warn", "(", "'Transfer functions can only be used in activation layers.'", ",", "DeprecationWarning", ")", "\n", "", "self", ".", "transfer", "=", "'identity'", "\n", "self", ".", "n_samples", "=", "n_samples", "\n", "\n", "self", ".", "output_height", "=", "(", "inpt_height", "-", "filter_height", "+", "1", ")", "/", "strides", "[", "0", "]", "\n", "self", ".", "output_width", "=", "(", "inpt_width", "-", "filter_width", "+", "1", ")", "/", "strides", "[", "1", "]", "\n", "self", ".", "output_depth", "=", "(", "inpt_depth", "-", "filter_depth", "+", "1", ")", "/", "strides", "[", "2", "]", "\n", "\n", "if", "border_mode", "==", "'same'", ":", "\n", "            ", "self", ".", "output_height", "=", "inpt_height", "/", "strides", "[", "0", "]", "\n", "self", ".", "output_width", "=", "inpt_width", "/", "strides", "[", "1", "]", "\n", "self", ".", "output_depth", "=", "inpt_depth", "/", "strides", "[", "2", "]", "\n", "\n", "", "if", "not", "self", ".", "output_height", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'inpt height smaller than filter height'", ")", "\n", "", "if", "not", "self", ".", "output_width", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'inpt width smaller than filter width'", ")", "\n", "", "if", "not", "self", ".", "output_depth", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'inpt depth smaller than filter depth'", ")", "\n", "\n", "", "self", ".", "border_mode", "=", "border_mode", "\n", "self", ".", "implementation", "=", "implementation", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "\n", "super", "(", "Conv3d", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Conv3d._forward": [[112, 177], ["basic.Conv3d.declare", "basic.Conv3d.declare", "theano.tensor.nnet.conv3d2d.conv3d", "theano.tensor.nnet.conv3d2d.conv3d", "theano.zeros", "theano.zeros", "theano.set_subtensor", "theano.set_subtensor", "theano.tensor.nnet.Conv3D.conv3D", "theano.tensor.nnet.Conv3D.conv3D", "basic.Conv3d.output_in.dimshuffle", "slice", "slice", "slice", "slice", "slice", "basic.Conv3d.bias.dimshuffle", "theano.zeros", "theano.zeros", "theano.sandbox.cuda.dnn.dnn_conv3d", "theano.sandbox.cuda.dnn.dnn_conv3d", "theano.sandbox.cuda.dnn.dnn_conv3d", "theano.sandbox.cuda.dnn.dnn_conv3d", "basic.Conv3d.output_in.dimshuffle", "NotImplementedError", "theano.set_subtensor.dimshuffle", "filters_flip.dimshuffle", "theano.set_subtensor.dimshuffle", "basic.Conv3d.weights.dimshuffle", "basic.Conv3d.bias.dimshuffle"], "methods", ["None"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "inpt", "=", "self", ".", "inpt", "\n", "\n", "self", ".", "weights", "=", "self", ".", "declare", "(", "\n", "(", "self", ".", "n_output", ",", "self", ".", "filter_depth", ",", "self", ".", "n_inpt", ",", "\n", "self", ".", "filter_height", ",", "self", ".", "filter_width", ")", "\n", ")", "\n", "self", ".", "bias", "=", "self", ".", "declare", "(", "(", "self", ".", "n_output", ",", ")", ")", "\n", "\n", "if", "self", ".", "border_mode", "==", "'same'", ":", "\n", "            ", "pad_dim1", "=", "self", ".", "filter_height", "-", "1", "\n", "pad_dim2", "=", "self", ".", "filter_width", "-", "1", "\n", "pad_dim3", "=", "self", ".", "filter_depth", "-", "1", "\n", "\n", "if", "pad_dim1", ">", "0", "or", "pad_dim2", ">", "0", "or", "pad_dim3", ">", "0", ":", "\n", "                ", "output_shape", "=", "(", "\n", "inpt", ".", "shape", "[", "0", "]", ",", "inpt", ".", "shape", "[", "1", "]", "+", "pad_dim3", ",", "\n", "inpt", ".", "shape", "[", "2", "]", ",", "inpt", ".", "shape", "[", "3", "]", "+", "pad_dim1", ",", "\n", "inpt", ".", "shape", "[", "4", "]", "+", "pad_dim2", "\n", ")", "\n", "big_zero", "=", "T", ".", "zeros", "(", "output_shape", ")", "\n", "indices", "=", "(", "\n", "slice", "(", "None", ")", ",", "\n", "slice", "(", "pad_dim3", "//", "2", ",", "inpt", ".", "shape", "[", "1", "]", "+", "pad_dim3", "//", "2", ")", ",", "\n", "slice", "(", "None", ")", ",", "\n", "slice", "(", "pad_dim1", "//", "2", ",", "inpt", ".", "shape", "[", "3", "]", "+", "pad_dim1", "//", "2", ")", ",", "\n", "slice", "(", "pad_dim2", "//", "2", ",", "inpt", ".", "shape", "[", "4", "]", "+", "pad_dim2", "//", "2", ")", "\n", ")", "\n", "\n", "inpt", "=", "T", ".", "set_subtensor", "(", "big_zero", "[", "indices", "]", ",", "inpt", ")", "\n", "\n", "#print '@basic.py implementation: ', self.implementation", "\n", "\n", "", "", "if", "self", ".", "implementation", "==", "'conv3d2d'", ":", "\n", "            ", "self", ".", "output_in", "=", "conv3d", "(", "\n", "signals", "=", "inpt", ",", "\n", "filters", "=", "self", ".", "weights", "\n", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "                ", "self", ".", "output_in", "=", "self", ".", "output_in", "+", "self", ".", "bias", ".", "dimshuffle", "(", "'x'", ",", "'x'", ",", "0", ",", "'x'", ",", "'x'", ")", "\n", "", "", "elif", "self", ".", "implementation", "==", "'conv3D'", ":", "\n", "            ", "filters_flip", "=", "self", ".", "weights", "[", ":", ",", ":", ":", "-", "1", ",", ":", ",", ":", ":", "-", "1", ",", ":", ":", "-", "1", "]", "\n", "bias", "=", "self", ".", "bias", "if", "self", ".", "use_bias", "else", "T", ".", "zeros", "(", "self", ".", "bias", ".", "shape", ")", "\n", "self", ".", "output_in", "=", "conv3D", "(", "\n", "V", "=", "inpt", ".", "dimshuffle", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ")", ",", "\n", "W", "=", "filters_flip", ".", "dimshuffle", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ")", ",", "\n", "b", "=", "bias", ",", "\n", "d", "=", "(", "1", ",", "1", ",", "1", ")", "\n", ")", "\n", "self", ".", "output_in", "=", "self", ".", "output_in", ".", "dimshuffle", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ")", "\n", "", "elif", "self", ".", "implementation", "==", "'dnn_conv3d'", ":", "\n", "            ", "self", ".", "output_in", "=", "theano", ".", "sandbox", ".", "cuda", ".", "dnn", ".", "dnn_conv3d", "(", "\n", "img", "=", "inpt", ".", "dimshuffle", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", ",", "\n", "kerns", "=", "self", ".", "weights", ".", "dimshuffle", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", "\n", ")", "\n", "self", ".", "output_in", "=", "self", ".", "output_in", ".", "dimshuffle", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "                ", "self", ".", "output_in", "=", "self", ".", "output_in", "+", "self", ".", "bias", ".", "dimshuffle", "(", "'x'", ",", "'x'", ",", "0", ",", "'x'", ",", "'x'", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'This class only supports conv3d2d, conv3D and dnn_conv3d'", ")", "\n", "\n", "", "self", ".", "output", "=", "self", ".", "output_in", "\n", "\n", "if", "self", ".", "strides", "!=", "(", "1", ",", "1", ",", "1", ")", ":", "\n", "            ", "self", ".", "output", "=", "self", ".", "output", "[", ":", ",", ":", ":", "self", ".", "strides", "[", "2", "]", ",", ":", ",", ":", ":", "self", ".", "strides", "[", "0", "]", ",", ":", ":", "self", ".", "strides", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Conv3d.get_output": [[178, 180], ["None"], "methods", ["None"], ["", "", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Conv3d.get_fan_in": [[181, 183], ["None"], "methods", ["None"], ["", "def", "get_fan_in", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n_inpt", "*", "self", ".", "filter_height", "*", "self", ".", "filter_width", "*", "self", ".", "filter_depth", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Conv3d.get_weights": [[184, 186], ["None"], "methods", ["None"], ["", "def", "get_weights", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.MaxPool3d.__init__": [[231, 264], ["divmod", "divmod", "divmod", "breze.arch.construct.base.Layer.__init__", "warnings.warn", "ValueError", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "inpt_width", ",", "inpt_depth", ",", "\n", "pool_height", ",", "pool_width", ",", "pool_depth", ",", "n_output", ",", "\n", "transfer", "=", "'identity'", ",", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        One layer of 3D max pooling.\n        \"\"\"", "\n", "\n", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "inpt_height", "=", "inpt_height", "\n", "self", ".", "inpt_width", "=", "inpt_width", "\n", "self", ".", "inpt_depth", "=", "inpt_depth", "\n", "\n", "self", ".", "pool_height", "=", "pool_height", "\n", "self", ".", "pool_width", "=", "pool_width", "\n", "self", ".", "pool_depth", "=", "pool_depth", "\n", "\n", "if", "transfer", "!=", "'identity'", ":", "\n", "            ", "warnings", ".", "warn", "(", "'Transfer functions can only be used in activation layers.'", ",", "DeprecationWarning", ")", "\n", "", "self", ".", "transfer", "=", "'identity'", "\n", "self", ".", "output_height", ",", "_", "=", "divmod", "(", "inpt_height", ",", "pool_height", ")", "\n", "self", ".", "output_width", ",", "_", "=", "divmod", "(", "inpt_width", ",", "pool_width", ")", "\n", "self", ".", "output_depth", ",", "_", "=", "divmod", "(", "inpt_depth", ",", "pool_depth", ")", "\n", "\n", "if", "not", "self", ".", "output_height", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'inpt height smaller than pool height'", ")", "\n", "", "if", "not", "self", ".", "output_width", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'inpt width smaller than pool width'", ")", "\n", "", "if", "not", "self", ".", "output_depth", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'inpt depth smaller than pool depth'", ")", "\n", "\n", "", "self", ".", "n_output", "=", "n_output", "\n", "\n", "super", "(", "MaxPool3d", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.MaxPool3d._forward": [[265, 273], ["basic.max_pool_3d"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.max_pool_3d"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "poolsize", "=", "(", "self", ".", "pool_depth", ",", "self", ".", "pool_height", ",", "self", ".", "pool_width", ")", "\n", "\n", "self", ".", "output", "=", "max_pool_3d", "(", "\n", "inpt", "=", "self", ".", "inpt", ",", "\n", "inpt_shape", "=", "self", ".", "inpt", ".", "shape", ",", "\n", "ds", "=", "poolsize", ",", "\n", "ignore_border", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.MaxPool3d.get_output": [[275, 277], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.NearestNeighborsUpsample3d.__init__": [[320, 356], ["breze.arch.construct.base.Layer.__init__", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "inpt_width", ",", "\n", "inpt_depth", ",", "up_factor", "=", "None", ",", "to_shape", "=", "None", ",", "\n", "transfer", "=", "'identity'", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        One layer of nearest neighbor upsampling.\n        :param inpt: input to be upsampled.\n                     Shape: (batch, channel, time, height, width)\n        :param to_shape: output shape (3-tuple or list of int).\n                         Shape: (height, width, depth)\n        \"\"\"", "\n", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "to_shape", "=", "to_shape", "\n", "self", ".", "inpt_height", "=", "inpt_height", "\n", "self", ".", "inpt_width", "=", "inpt_width", "\n", "self", ".", "inpt_depth", "=", "inpt_depth", "\n", "\n", "if", "up_factor", "is", "None", ":", "\n", "            ", "assert", "to_shape", "is", "not", "None", "\n", "self", ".", "output_height", "=", "to_shape", "[", "0", "]", "\n", "self", ".", "output_width", "=", "to_shape", "[", "1", "]", "\n", "self", ".", "output_depth", "=", "to_shape", "[", "2", "]", "\n", "", "else", ":", "\n", "            ", "assert", "to_shape", "is", "None", "\n", "self", ".", "output_height", "=", "inpt_height", "*", "up_factor", "[", "0", "]", "\n", "self", ".", "output_width", "=", "inpt_width", "*", "up_factor", "[", "1", "]", "\n", "self", ".", "output_depth", "=", "inpt_depth", "*", "up_factor", "[", "2", "]", "\n", "\n", "", "self", ".", "up_factor", "=", "up_factor", "\n", "self", ".", "to_shape", "=", "to_shape", "\n", "\n", "if", "transfer", "!=", "'identity'", ":", "\n", "            ", "warnings", ".", "warn", "(", "'Transfer functions can only be used in activation layers.'", ",", "DeprecationWarning", ")", "\n", "", "self", ".", "transfer", "=", "'identity'", "\n", "\n", "super", "(", "NearestNeighborsUpsample3d", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.NearestNeighborsUpsample3d._forward": [[357, 372], ["basic.upsample_3d", "basic.NearestNeighborsUpsample3d.output.dimshuffle", "basic.NearestNeighborsUpsample3d.inpt.dimshuffle", "basic.simple_upsample3d"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.upsample_3d", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.simple_upsample3d"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "to_shape", "is", "not", "None", ":", "\n", "            ", "self", ".", "output", "=", "upsample_3d", "(", "\n", "self", ".", "inpt", ".", "dimshuffle", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", ",", "\n", "self", ".", "to_shape", ",", "\n", "self", ".", "inpt_height", ",", "\n", "self", ".", "inpt_width", ",", "\n", "self", ".", "inpt_depth", "\n", ")", "\n", "self", ".", "output", "=", "self", ".", "output", ".", "dimshuffle", "(", "0", ",", "2", ",", "1", ",", "3", ",", "4", ")", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "up_factor", "==", "(", "1", ",", "1", ",", "1", ")", ":", "\n", "                ", "self", ".", "output", "=", "self", ".", "inpt", "\n", "", "else", ":", "\n", "                ", "self", ".", "output", "=", "simple_upsample3d", "(", "self", ".", "inpt", ",", "self", ".", "up_factor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.NearestNeighborsUpsample3d.get_output": [[373, 375], ["None"], "methods", ["None"], ["", "", "", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BilinearUpsample3d.__init__": [[377, 397], ["breze.arch.construct.base.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "inpt_width", ",", "\n", "inpt_depth", ",", "n_inpt", ",", "up_factor", "=", "2", ",", "declare", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "        ", "'''\n        Bilinear interpolation through a mild hack.\n        This function assumes inpt is: (1, depth, n_inpt, height, width)\n        '''", "\n", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "inpt_height", "=", "inpt_height", "\n", "self", ".", "inpt_width", "=", "inpt_width", "\n", "self", ".", "inpt_depth", "=", "inpt_depth", "\n", "self", ".", "n_inpt", "=", "n_inpt", "\n", "self", ".", "up_factor", "=", "up_factor", "\n", "\n", "self", ".", "output_height", "=", "up_factor", "*", "inpt_height", "\n", "self", ".", "output_width", "=", "up_factor", "*", "inpt_width", "\n", "self", ".", "output_depth", "=", "up_factor", "*", "inpt_depth", "\n", "self", ".", "n_output", "=", "n_inpt", "\n", "\n", "super", "(", "BilinearUpsample3d", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BilinearUpsample3d._bilinear_upsampling_1D": [[398, 431], ["theano.config.device.startswith", "theano.config.device.startswith", "theano.config.device.startswith", "theano.config.device.startswith", "inpt.reshape", "theano.concatenate", "theano.concatenate", "bilinear_kernel_1D", "conv2d_grad_wrt_inputs", "conv2d_grad_wrt_inputs.reshape", "AssertionError"], "methods", ["None"], ["", "def", "_bilinear_upsampling_1D", "(", "self", ",", "inpt", ",", "ratio", ",", "batch_size", "=", "None", ",", "num_input_channels", "=", "None", ")", ":", "\n", "        ", "'''\n        This implementation is a very minimally changed excerpt from:\n        https://github.com/Theano/theano/blob/ddfd7d239a1e656cee850cdbc548da63f349c37d/theano/tensor/nnet/abstract_conv.py#L455\n        '''", "\n", "if", "theano", ".", "config", ".", "device", ".", "startswith", "(", "'gpu'", ")", ":", "\n", "            ", "from", "theano", ".", "tensor", ".", "nnet", ".", "abstract_conv", "import", "bilinear_kernel_1D", ",", "conv2d_grad_wrt_inputs", "\n", "", "else", ":", "\n", "            ", "raise", "AssertionError", "(", "'Bilinear interpolation requires GPU and cuDNN.'", ")", "\n", "", "try", ":", "\n", "            ", "up_bs", "=", "batch_size", "*", "num_input_channels", "\n", "", "except", "TypeError", ":", "\n", "            ", "up_bs", "=", "None", "\n", "", "row", ",", "col", "=", "inpt", ".", "shape", "[", "2", ":", "]", "\n", "up_input", "=", "inpt", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "row", ",", "col", ")", ")", "\n", "\n", "concat_mat", "=", "T", ".", "concatenate", "(", "(", "up_input", "[", ":", ",", ":", ",", ":", "1", ",", ":", "]", ",", "up_input", ",", "\n", "up_input", "[", ":", ",", ":", ",", "-", "1", ":", ",", ":", "]", ")", ",", "axis", "=", "2", ")", "\n", "\n", "pad", "=", "2", "*", "ratio", "-", "(", "ratio", "-", "1", ")", "//", "2", "-", "1", "\n", "\n", "kern", "=", "bilinear_kernel_1D", "(", "ratio", "=", "ratio", ",", "normalize", "=", "True", ")", "\n", "upsampled_row", "=", "conv2d_grad_wrt_inputs", "(", "\n", "output_grad", "=", "concat_mat", ",", "\n", "filters", "=", "kern", "[", "np", ".", "newaxis", ",", "np", ".", "newaxis", ",", ":", ",", "np", ".", "newaxis", "]", ",", "\n", "input_shape", "=", "(", "up_bs", ",", "1", ",", "row", "*", "ratio", ",", "col", ")", ",", "\n", "filter_shape", "=", "(", "1", ",", "1", ",", "None", ",", "1", ")", ",", "\n", "border_mode", "=", "(", "pad", ",", "0", ")", ",", "\n", "subsample", "=", "(", "ratio", ",", "1", ")", ",", "\n", "filter_flip", "=", "True", "\n", ")", "\n", "\n", "return", "upsampled_row", ".", "reshape", "(", "(", "inpt", ".", "shape", "[", "0", "]", ",", "inpt", ".", "shape", "[", "1", "]", ",", "row", "*", "ratio", ",", "col", "*", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BilinearUpsample3d._forward": [[432, 445], ["theano.config.device.startswith", "theano.config.device.startswith", "theano.config.device.startswith", "theano.config.device.startswith", "theano.reshape", "theano.reshape", "bilinear_upsampling", "bilinear_upsampling.dimshuffle", "basic.BilinearUpsample3d._bilinear_upsampling_1D", "basic.BilinearUpsample3d.dimshuffle", "theano.shape_padaxis", "theano.shape_padaxis", "theano.unbroadcast", "theano.unbroadcast", "AssertionError"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BilinearUpsample3d._bilinear_upsampling_1D"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "if", "theano", ".", "config", ".", "device", ".", "startswith", "(", "'gpu'", ")", ":", "\n", "            ", "from", "theano", ".", "tensor", ".", "nnet", ".", "abstract_conv", "import", "bilinear_upsampling", "\n", "", "else", ":", "\n", "            ", "raise", "AssertionError", "(", "'Bilinear interpolation requires GPU and cuDNN.'", ")", "\n", "\n", "", "inpt", "=", "T", ".", "reshape", "(", "self", ".", "inpt", ",", "(", "self", ".", "inpt_depth", ",", "self", ".", "n_inpt", ",", "self", ".", "inpt_height", ",", "self", ".", "inpt_width", ")", ")", "\n", "pre_res", "=", "bilinear_upsampling", "(", "input", "=", "inpt", ",", "ratio", "=", "self", ".", "up_factor", ")", "\n", "shuffle_res", "=", "pre_res", ".", "dimshuffle", "(", "(", "2", ",", "3", ",", "0", ",", "1", ")", ")", "\n", "res", "=", "self", ".", "_bilinear_upsampling_1D", "(", "inpt", "=", "shuffle_res", ",", "ratio", "=", "self", ".", "up_factor", ")", "\n", "self", ".", "output", "=", "res", ".", "dimshuffle", "(", "(", "2", ",", "3", ",", "0", ",", "1", ")", ")", "\n", "self", ".", "output", "=", "T", ".", "shape_padaxis", "(", "self", ".", "output", ",", "axis", "=", "0", ")", "\n", "self", ".", "output", "=", "T", ".", "unbroadcast", "(", "self", ".", "output", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BilinearUpsample3d.get_output": [[446, 448], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv.__init__": [[455, 483], ["breze.arch.construct.base.Layer.__init__", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "inpt_width", ",", "\n", "inpt_depth", ",", "n_inpt", ",", "filter_height", ",", "\n", "filter_width", ",", "filter_depth", ",", "n_output", ",", "\n", "transfer", "=", "'identity'", ",", "n_samples", "=", "None", ",", "\n", "up_factor", "=", "(", "2", ",", "2", ",", "2", ")", ",", "implementation", "=", "'dnn_conv3d'", ",", "\n", "bias", "=", "False", ",", "mode", "=", "'repeat'", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "inpt_height", "=", "inpt_height", "\n", "self", ".", "inpt_width", "=", "inpt_width", "\n", "self", ".", "inpt_depth", "=", "inpt_depth", "\n", "self", ".", "n_inpt", "=", "n_inpt", "\n", "self", ".", "filter_height", "=", "filter_height", "\n", "self", ".", "filter_width", "=", "filter_width", "\n", "self", ".", "filter_depth", "=", "filter_depth", "\n", "self", ".", "n_output", "=", "n_output", "\n", "\n", "if", "transfer", "!=", "'identity'", ":", "\n", "            ", "warnings", ".", "warn", "(", "'Transfer functions can only be used in activation layers.'", ",", "DeprecationWarning", ")", "\n", "", "self", ".", "transfer_id", "=", "'identity'", "\n", "\n", "self", ".", "n_samples", "=", "n_samples", "\n", "self", ".", "up_factor", "=", "up_factor", "\n", "self", ".", "implementation", "=", "implementation", "\n", "self", ".", "bias", "=", "bias", "\n", "self", ".", "mode", "=", "mode", "\n", "\n", "super", "(", "Deconv", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv.sparse_upsample": [[484, 501], ["basic.stretch_axis", "basic.stretch_axis", "basic.stretch_axis"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.stretch_axis", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.stretch_axis", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.stretch_axis"], ["", "def", "sparse_upsample", "(", "self", ")", ":", "\n", "        ", "up_factor", "=", "self", ".", "up_factor", "\n", "inpt", "=", "self", ".", "inpt", "\n", "new_height", "=", "self", ".", "inpt_height", "*", "up_factor", "[", "0", "]", "\n", "new_width", "=", "self", ".", "inpt_width", "*", "up_factor", "[", "1", "]", "\n", "new_depth", "=", "self", ".", "inpt_depth", "*", "up_factor", "[", "2", "]", "\n", "\n", "current_shape", "=", "[", "1", ",", "self", ".", "inpt_depth", ",", "self", ".", "n_inpt", ",", "self", ".", "inpt_height", ",", "self", ".", "inpt_width", "]", "\n", "inpt_up_first", "=", "stretch_axis", "(", "inpt", ",", "axis", "=", "3", ",", "factor", "=", "up_factor", "[", "0", "]", ",", "original_shape", "=", "current_shape", ")", "\n", "\n", "current_shape", "=", "[", "1", ",", "self", ".", "inpt_depth", ",", "self", ".", "n_inpt", ",", "new_height", ",", "self", ".", "inpt_width", "]", "\n", "inpt_up_second", "=", "stretch_axis", "(", "inpt_up_first", ",", "axis", "=", "4", ",", "factor", "=", "up_factor", "[", "1", "]", ",", "original_shape", "=", "current_shape", ")", "\n", "\n", "current_shape", "=", "[", "1", ",", "self", ".", "inpt_depth", ",", "self", ".", "n_inpt", ",", "new_height", ",", "new_width", "]", "\n", "upsampled_inpt", "=", "stretch_axis", "(", "inpt_up_second", ",", "axis", "=", "1", ",", "factor", "=", "up_factor", "[", "2", "]", ",", "original_shape", "=", "current_shape", ")", "\n", "\n", "return", "upsampled_inpt", ",", "new_height", ",", "new_width", ",", "new_depth", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv._forward": [[502, 556], ["basic.Conv3d", "basic.NearestNeighborsUpsample3d", "basic.Deconv.sparse_upsample", "basic.BilinearUpsample3d", "ValueError"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv.sparse_upsample"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "up_factor", "!=", "(", "1", ",", "1", ",", "1", ")", "and", "self", ".", "mode", "==", "'repeat'", ":", "\n", "            ", "self", ".", "upsample_layer", "=", "NearestNeighborsUpsample3d", "(", "\n", "inpt", "=", "self", ".", "inpt", ",", "inpt_height", "=", "self", ".", "inpt_height", ",", "\n", "inpt_width", "=", "self", ".", "inpt_width", ",", "inpt_depth", "=", "self", ".", "inpt_depth", ",", "\n", "up_factor", "=", "self", ".", "up_factor", ",", "\n", "to_shape", "=", "None", ",", "\n", "transfer", "=", "'identity'", ",", "declare", "=", "self", ".", "declare", ",", "name", "=", "self", ".", "name", "\n", ")", "\n", "inpt", "=", "self", ".", "upsample_layer", ".", "output", "\n", "inpt_height", "=", "self", ".", "upsample_layer", ".", "output_height", "\n", "inpt_width", "=", "self", ".", "upsample_layer", ".", "output_width", "\n", "inpt_depth", "=", "self", ".", "upsample_layer", ".", "output_depth", "\n", "", "elif", "self", ".", "up_factor", "!=", "(", "1", ",", "1", ",", "1", ")", "and", "self", ".", "mode", "==", "'sparse'", ":", "\n", "            ", "inpt", ",", "inpt_height", ",", "inpt_width", ",", "inpt_depth", "=", "self", ".", "sparse_upsample", "(", ")", "\n", "", "elif", "self", ".", "up_factor", "!=", "(", "1", ",", "1", ",", "1", ")", "and", "self", ".", "mode", "==", "'bilinear'", ":", "\n", "            ", "assert", "(", "self", ".", "up_factor", "[", "0", "]", "==", "self", ".", "up_factor", "[", "1", "]", ")", "\n", "assert", "(", "self", ".", "up_factor", "[", "1", "]", "==", "self", ".", "up_factor", "[", "2", "]", ")", "\n", "self", ".", "upsample_layer", "=", "BilinearUpsample3d", "(", "\n", "inpt", "=", "self", ".", "inpt", ",", "inpt_height", "=", "self", ".", "inpt_height", ",", "\n", "inpt_width", "=", "self", ".", "inpt_width", ",", "inpt_depth", "=", "self", ".", "inpt_depth", ",", "\n", "n_inpt", "=", "self", ".", "n_inpt", ",", "up_factor", "=", "self", ".", "up_factor", "[", "0", "]", ",", "\n", "declare", "=", "self", ".", "declare", "\n", ")", "\n", "inpt", "=", "self", ".", "upsample_layer", ".", "output", "\n", "inpt_height", "=", "self", ".", "upsample_layer", ".", "output_height", "\n", "inpt_width", "=", "self", ".", "upsample_layer", ".", "output_width", "\n", "inpt_depth", "=", "self", ".", "upsample_layer", ".", "output_depth", "\n", "", "elif", "self", ".", "up_factor", "!=", "(", "1", ",", "1", ",", "1", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Deconv modes are: repeat, sparse, bilinear.'", ")", "\n", "", "else", ":", "\n", "            ", "inpt", "=", "self", ".", "inpt", "\n", "inpt_height", "=", "self", ".", "inpt_height", "\n", "inpt_width", "=", "self", ".", "inpt_width", "\n", "inpt_depth", "=", "self", ".", "inpt_depth", "\n", "\n", "", "self", ".", "conv_layer", "=", "Conv3d", "(", "\n", "inpt", "=", "inpt", ",", "\n", "inpt_height", "=", "inpt_height", ",", "\n", "inpt_width", "=", "inpt_width", ",", "\n", "inpt_depth", "=", "inpt_depth", ",", "\n", "n_inpt", "=", "self", ".", "n_inpt", ",", "filter_height", "=", "self", ".", "filter_height", ",", "\n", "filter_width", "=", "self", ".", "filter_width", ",", "filter_depth", "=", "self", ".", "filter_depth", ",", "\n", "n_output", "=", "self", ".", "n_output", ",", "transfer", "=", "self", ".", "transfer_id", ",", "\n", "n_samples", "=", "self", ".", "n_samples", ",", "border_mode", "=", "'same'", ",", "\n", "declare", "=", "self", ".", "declare", ",", "implementation", "=", "self", ".", "implementation", "\n", ")", "\n", "# added for Xavier init:", "\n", "self", ".", "weights", "=", "self", ".", "conv_layer", ".", "weights", "\n", "\n", "self", ".", "output", "=", "self", ".", "conv_layer", ".", "output", "\n", "self", ".", "output_height", "=", "self", ".", "conv_layer", ".", "output_height", "\n", "self", ".", "output_width", "=", "self", ".", "conv_layer", ".", "output_width", "\n", "self", ".", "output_depth", "=", "self", ".", "conv_layer", ".", "output_depth", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv.get_output": [[557, 559], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv.get_weights": [[560, 562], ["None"], "methods", ["None"], ["", "def", "get_weights", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv.get_fan_in": [[563, 565], ["basic.Deconv.conv_layer.get_fan_in"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Deconv.get_fan_in"], ["", "def", "get_fan_in", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "conv_layer", ".", "get_fan_in", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Shortcut.__init__": [[572, 605], ["numpy.maximum", "numpy.maximum", "numpy.maximum", "breze.arch.construct.base.Layer.__init__", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["def", "__init__", "(", "self", ",", "src_layer", ",", "dst_layer", ",", "\n", "transfer", "=", "'identity'", ",", "implementation", "=", "'dnn_conv3d'", ",", "\n", "projection", "=", "'zero_pad'", ",", "mode", "=", "'sum'", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "'''\n        :param src_layer: layer that produced the input to the\n                          stack of layers ending with dst_layer\n        :param dst_layer: layer that computes f(x) where x is the\n                          output of src_layer\n        :param transfer: non-linearity to be applied to the sum f(x) + x\n        :param implementation: theano implementation for 3d-convolution.\n                               only used if src_layer produces a different\n                               number of feature maps than dst_layer and\n                               projection is set to 'project'. 'zero_pad'\n                               simply adds extra feature maps with zero\n                               activations to match the shapes.\n        '''", "\n", "self", ".", "src_layer", "=", "src_layer", "\n", "self", ".", "dst_layer", "=", "dst_layer", "\n", "if", "transfer", "!=", "'identity'", ":", "\n", "            ", "warnings", ".", "warn", "(", "'Transfer functions can only be used in activation layers.'", ",", "DeprecationWarning", ")", "\n", "", "self", ".", "transfer", "=", "'identity'", "\n", "self", ".", "implementation", "=", "implementation", "\n", "self", ".", "projection", "=", "projection", "\n", "\n", "self", ".", "output_height", "=", "np", ".", "maximum", "(", "dst_layer", ".", "output_height", ",", "src_layer", ".", "output_height", ")", "\n", "self", ".", "output_width", "=", "np", ".", "maximum", "(", "dst_layer", ".", "output_width", ",", "src_layer", ".", "output_width", ")", "\n", "self", ".", "output_depth", "=", "np", ".", "maximum", "(", "dst_layer", ".", "output_depth", ",", "src_layer", ".", "output_depth", ")", "\n", "self", ".", "n_output", "=", "dst_layer", ".", "n_output", "\n", "\n", "self", ".", "mode", "=", "mode", "\n", "\n", "super", "(", "Shortcut", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Shortcut.pad_dim": [[606, 618], ["theano.zeros_like", "theano.zeros_like", "theano.set_subtensor", "theano.set_subtensor", "slice", "slice", "slice", "slice", "slice"], "methods", ["None"], ["", "def", "pad_dim", "(", "self", ",", "left", ",", "right", ",", "height_diff", ",", "width_diff", ",", "depth_diff", ")", ":", "\n", "        ", "zero_pad", "=", "T", ".", "zeros_like", "(", "right", ")", "\n", "indices", "=", "(", "\n", "slice", "(", "None", ")", ",", "\n", "slice", "(", "depth_diff", "/", "2", ",", "zero_pad", ".", "shape", "[", "1", "]", "-", "(", "depth_diff", "-", "depth_diff", "/", "2", ")", ")", ",", "\n", "slice", "(", "None", ")", ",", "\n", "slice", "(", "height_diff", "/", "2", ",", "zero_pad", ".", "shape", "[", "3", "]", "-", "(", "height_diff", "-", "height_diff", "/", "2", ")", ")", ",", "\n", "slice", "(", "width_diff", "/", "2", ",", "zero_pad", ".", "shape", "[", "4", "]", "-", "(", "width_diff", "-", "width_diff", "/", "2", ")", ")", "\n", ")", "\n", "\n", "padded_left", "=", "T", ".", "set_subtensor", "(", "zero_pad", "[", "indices", "]", ",", "left", ")", "\n", "return", "padded_left", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Shortcut._forward": [[619, 672], ["basic.Shortcut.pad_dim", "basic.Conv3d", "basic.Shortcut.pad_dim", "ValueError", "theano.zeros", "theano.zeros", "theano.set_subtensor", "theano.set_subtensor", "NotImplementedError", "slice", "slice", "slice", "slice", "slice"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Shortcut.pad_dim", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Shortcut.pad_dim"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "inpt_x", "=", "self", ".", "src_layer", ".", "output", "\n", "inpt_fx", "=", "self", ".", "dst_layer", ".", "output", "\n", "\n", "if", "self", ".", "src_layer", ".", "n_output", "!=", "self", ".", "dst_layer", ".", "n_output", ":", "\n", "            ", "if", "self", ".", "projection", "==", "'project'", ":", "\n", "                ", "proj", "=", "Conv3d", "(", "\n", "inpt", "=", "inpt_x", ",", "inpt_height", "=", "self", ".", "src_layer", ".", "output_height", ",", "\n", "inpt_width", "=", "self", ".", "src_layer", ".", "output_width", ",", "inpt_depth", "=", "self", ".", "src_layer", ".", "output_depth", ",", "\n", "n_inpt", "=", "self", ".", "src_layer", ".", "n_output", ",", "filter_height", "=", "1", ",", "\n", "filter_width", "=", "1", ",", "filter_depth", "=", "1", ",", "n_output", "=", "self", ".", "dst_layer", ".", "n_output", ",", "\n", "transfer", "=", "'identity'", ",", "n_samples", "=", "None", ",", "border_mode", "=", "'valid'", ",", "\n", "implementation", "=", "self", ".", "implementation", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ")", ",", "use_bias", "=", "False", ",", "\n", "declare", "=", "self", ".", "declare", "\n", ")", "\n", "inpt_x", "=", "proj", ".", "output", "\n", "", "elif", "self", ".", "projection", "==", "'zero_pad'", ":", "\n", "                ", "projected_shape", "=", "(", "\n", "inpt_x", ".", "shape", "[", "0", "]", ",", "inpt_x", ".", "shape", "[", "1", "]", ",", "inpt_fx", ".", "shape", "[", "2", "]", ",", "\n", "inpt_x", ".", "shape", "[", "3", "]", ",", "inpt_x", ".", "shape", "[", "4", "]", "\n", ")", "\n", "big_zero", "=", "T", ".", "zeros", "(", "projected_shape", ")", "\n", "indices", "=", "(", "\n", "slice", "(", "None", ")", ",", "\n", "slice", "(", "None", ")", ",", "\n", "slice", "(", "0", ",", "inpt_x", ".", "shape", "[", "2", "]", ")", ",", "\n", "slice", "(", "None", ")", ",", "\n", "slice", "(", "None", ")", "\n", ")", "\n", "inpt_x", "=", "T", ".", "set_subtensor", "(", "big_zero", "[", "indices", "]", ",", "inpt_x", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "'Supported projections: zero_pad, project'", ")", "\n", "\n", "", "", "if", "self", ".", "src_layer", ".", "output_height", "<", "self", ".", "dst_layer", ".", "output_height", ":", "\n", "            ", "height_diff", "=", "self", ".", "dst_layer", ".", "output_height", "-", "self", ".", "src_layer", ".", "output_height", "\n", "assert", "(", "self", ".", "dst_layer", ".", "output_width", ">", "self", ".", "src_layer", ".", "output_width", ")", "\n", "assert", "(", "self", ".", "dst_layer", ".", "output_depth", ">", "self", ".", "src_layer", ".", "output_depth", ")", "\n", "width_diff", "=", "self", ".", "dst_layer", ".", "output_width", "-", "self", ".", "src_layer", ".", "output_width", "\n", "depth_diff", "=", "self", ".", "dst_layer", ".", "output_depth", "-", "self", ".", "src_layer", ".", "output_depth", "\n", "inpt_x", "=", "self", ".", "pad_dim", "(", "left", "=", "inpt_x", ",", "right", "=", "inpt_fx", ",", "height_diff", "=", "height_diff", ",", "width_diff", "=", "width_diff", ",", "depth_diff", "=", "depth_diff", ")", "\n", "", "elif", "self", ".", "src_layer", ".", "output_height", ">", "self", ".", "dst_layer", ".", "output_height", ":", "\n", "            ", "height_diff", "=", "self", ".", "src_layer", ".", "output_height", "-", "self", ".", "dst_layer", ".", "output_height", "\n", "assert", "(", "self", ".", "src_layer", ".", "output_width", ">", "self", ".", "dst_layer", ".", "output_width", ")", "\n", "assert", "(", "self", ".", "src_layer", ".", "output_depth", ">", "self", ".", "dst_layer", ".", "output_depth", ")", "\n", "width_diff", "=", "self", ".", "src_layer", ".", "output_width", "-", "self", ".", "dst_layer", ".", "output_width", "\n", "depth_diff", "=", "self", ".", "src_layer", ".", "output_depth", "-", "self", ".", "dst_layer", ".", "output_depth", "\n", "inpt_fx", "=", "self", ".", "pad_dim", "(", "left", "=", "inpt_fx", ",", "right", "=", "inpt_x", ",", "height_diff", "=", "height_diff", ",", "width_diff", "=", "width_diff", ",", "depth_diff", "=", "depth_diff", ")", "\n", "\n", "", "self", ".", "output", "=", "inpt_x", "+", "inpt_fx", "\n", "if", "self", ".", "mode", "==", "'mean'", ":", "\n", "            ", "self", ".", "output", "/=", "2", "\n", "", "elif", "self", ".", "mode", "!=", "'sum'", ":", "\n", "            ", "raise", "ValueError", "(", "'Shortcut modes are: sum, mean'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Shortcut.get_output": [[673, 675], ["None"], "methods", ["None"], ["", "", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.NonLinearity.__init__": [[681, 694], ["breze.arch.construct.base.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "\n", "inpt_width", ",", "inpt_depth", ",", "\n", "n_inpt", ",", "transfer", ",", "prelu", "=", "False", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "output_height", "=", "inpt_height", "\n", "self", ".", "output_width", "=", "inpt_width", "\n", "self", ".", "output_depth", "=", "inpt_depth", "\n", "self", ".", "n_output", "=", "n_inpt", "\n", "self", ".", "transfer", "=", "transfer", "\n", "self", ".", "prelu", "=", "prelu", "\n", "\n", "super", "(", "NonLinearity", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.NonLinearity._forward": [[695, 707], ["basic.NonLinearity.declare", "basic.prelu", "basic.tensor_softmax", "breze.arch.util.lookup", "breze.arch.util.lookup."], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.prelu", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.tensor_softmax"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "prelu", ":", "\n", "            ", "if", "self", ".", "transfer", "==", "'t_softmax'", ":", "\n", "                ", "self", ".", "output", "=", "tensor_softmax", "(", "self", ".", "inpt", ",", "self", ".", "n_output", ")", "\n", "", "else", ":", "\n", "                ", "f", "=", "lookup", "(", "self", ".", "transfer", ",", "_transfer", ")", "\n", "self", ".", "output", "=", "f", "(", "self", ".", "inpt", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "a", "=", "self", ".", "declare", "(", "\n", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", "\n", ")", "\n", "self", ".", "output", "=", "prelu", "(", "self", ".", "inpt", ",", "self", ".", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.NonLinearity.get_output": [[708, 710], ["None"], "methods", ["None"], ["", "", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm.__init__": [[712, 735], ["breze.arch.construct.base.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "\n", "inpt_width", ",", "inpt_depth", ",", "\n", "n_inpt", ",", "alpha", "=", "0.5", ",", "training", "=", "1", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "'''\n        Batch normalization as described in: http://arxiv.org/pdf/1502.03167v3.pdf\n        It is assumed that the input has shape (1, depth, n_inpt, height, width) and\n        that the normalization is for every feature map.\n        :param alpha: Parameter used to compute running metrics(mean and std).\n                      The larger alpha is, the higher the influence of recent\n                      samples will be.\n        '''", "\n", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "output_height", "=", "inpt_height", "\n", "self", ".", "output_width", "=", "inpt_width", "\n", "self", ".", "output_depth", "=", "inpt_depth", "\n", "self", ".", "n_output", "=", "n_inpt", "\n", "\n", "self", ".", "_training", "=", "training", "\n", "self", ".", "eps", "=", "1e-5", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n", "super", "(", "BatchNorm", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm.training": [[736, 739], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "training", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_training", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm.set_training": [[740, 747], ["None"], "methods", ["None"], ["", "def", "set_training", "(", "self", ",", "bool_val", ")", ":", "\n", "# Convert True/False to 1/0 for Theano", "\n", "        ", "if", "bool_val", ":", "\n", "            ", "val", "=", "1", "\n", "", "else", ":", "\n", "            ", "val", "=", "0", "\n", "", "self", ".", "_training", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm._setup_running_metrics": [[748, 754], ["theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "numpy.zeros", "numpy.ones"], "methods", ["None"], ["", "def", "_setup_running_metrics", "(", "self", ",", "shape", ")", ":", "\n", "        ", "self", ".", "running_mean", "=", "theano", ".", "shared", "(", "\n", "np", ".", "zeros", "(", "shape", ",", "dtype", "=", "'float32'", ")", ",", "'running_mean'", "\n", ")", "\n", "self", ".", "running_std", "=", "theano", ".", "shared", "(", "\n", "np", ".", "ones", "(", "shape", ",", "dtype", "=", "'float32'", ")", ",", "'running_std'", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm._forward": [[756, 790], ["basic.BatchNorm.declare", "basic.BatchNorm.declare", "basic.BatchNorm.inpt.mean", "basic.BatchNorm.inpt.std", "basic.BatchNorm._setup_running_metrics", "theano.ifelse.ifelse", "theano.ifelse.ifelse", "theano.ifelse.ifelse", "theano.ifelse.ifelse", "theano.ifelse.ifelse", "theano.ifelse.ifelse", "theano.ifelse.ifelse", "theano.ifelse.ifelse", "use_mean.dimshuffle.dimshuffle.dimshuffle", "use_std.dimshuffle.dimshuffle.dimshuffle"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm._setup_running_metrics"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "eps", "=", "self", ".", "eps", "\n", "\n", "param_size", "=", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", "\n", "self", ".", "gamma", "=", "self", ".", "declare", "(", "param_size", ")", "\n", "self", ".", "beta", "=", "self", ".", "declare", "(", "param_size", ")", "\n", "\n", "mean", "=", "self", ".", "inpt", ".", "mean", "(", "axis", "=", "[", "0", ",", "1", ",", "3", ",", "4", "]", ",", "keepdims", "=", "False", ")", "\n", "std", "=", "self", ".", "inpt", ".", "std", "(", "axis", "=", "[", "0", ",", "1", ",", "3", ",", "4", "]", ",", "keepdims", "=", "False", ")", "\n", "\n", "self", ".", "_setup_running_metrics", "(", "self", ".", "n_output", ")", "\n", "self", ".", "running_mean", ".", "default_update", "=", "ifelse", "(", "\n", "self", ".", "training", ",", "\n", "(", "1.0", "-", "self", ".", "alpha", ")", "*", "self", ".", "running_mean", "+", "self", ".", "alpha", "*", "mean", ",", "\n", "self", ".", "running_mean", "\n", ")", "\n", "self", ".", "running_std", ".", "default_update", "=", "ifelse", "(", "\n", "self", ".", "training", ",", "\n", "(", "1.0", "-", "self", ".", "alpha", ")", "*", "self", ".", "running_std", "+", "self", ".", "alpha", "*", "std", ",", "\n", "self", ".", "running_std", "\n", ")", "\n", "\n", "# This will be optimized away, but ensures the running mean and the running std get updated.", "\n", "# Reference: https://gist.github.com/f0k/f1a6bd3c8585c400c190#file-batch_norm-py-L86", "\n", "mean", "+=", "0", "*", "self", ".", "running_mean", "\n", "std", "+=", "0", "*", "self", ".", "running_std", "\n", "\n", "use_mean", "=", "ifelse", "(", "self", ".", "training", ",", "mean", ",", "self", ".", "running_mean", ")", "\n", "use_std", "=", "ifelse", "(", "self", ".", "training", ",", "std", ",", "self", ".", "running_std", ")", "\n", "\n", "use_mean", "=", "use_mean", ".", "dimshuffle", "(", "'x'", ",", "'x'", ",", "0", ",", "'x'", ",", "'x'", ")", "\n", "use_std", "=", "use_std", ".", "dimshuffle", "(", "'x'", ",", "'x'", ",", "0", ",", "'x'", ",", "'x'", ")", "\n", "norm_inpt", "=", "(", "self", ".", "inpt", "-", "use_mean", ")", "/", "(", "use_std", "+", "eps", ")", "\n", "self", ".", "output", "=", "self", ".", "gamma", "*", "norm_inpt", "+", "self", ".", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm.set_phase": [[791, 799], ["basic.BatchNorm.set_training", "basic.BatchNorm.set_training", "ValueError"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm.set_training", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm.set_training"], ["", "def", "set_phase", "(", "self", ",", "new_phase", ")", ":", "\n", "# Phase 0: Training, Phase 1: Validation", "\n", "        ", "if", "new_phase", "==", "1", ":", "\n", "            ", "self", ".", "set_training", "(", "False", ")", "\n", "", "elif", "new_phase", "==", "0", ":", "\n", "            ", "self", ".", "set_training", "(", "True", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Expected 0 or 1, got %i'", "%", "new_phase", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm.get_output": [[800, 802], ["None"], "methods", ["None"], ["", "", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNorm.submit": [[803, 805], ["basic.BatchNorm.running_mean.get_value", "basic.BatchNorm.running_std.get_value"], "methods", ["None"], ["", "def", "submit", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "running_mean", ".", "get_value", "(", ")", ",", "self", ".", "running_std", ".", "get_value", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Concatenate.__init__": [[807, 832], ["breze.arch.construct.base.Layer.__init__", "ValueError", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "layer_left", ",", "layer_right", ",", "nkerns", "=", "None", ",", "\n", "mode", "=", "'plain'", ",", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "self", ".", "layer_left", "=", "layer_left", "\n", "self", ".", "layer_right", "=", "layer_right", "\n", "self", ".", "output_height", "=", "layer_left", ".", "output_height", "\n", "self", ".", "output_width", "=", "layer_left", ".", "output_width", "\n", "self", ".", "output_depth", "=", "layer_left", ".", "output_depth", "\n", "if", "mode", "==", "'plain'", ":", "\n", "            ", "self", ".", "n_output", "=", "layer_left", ".", "n_output", "+", "layer_right", ".", "n_output", "\n", "", "elif", "mode", "==", "'truncated'", ":", "\n", "            ", "if", "nkerns", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "'Have to specify number of features in truncated mode.'", ")", "\n", "", "if", "nkerns", ">", "layer_left", ".", "n_output", ":", "\n", "                ", "raise", "ValueError", "(", "'left does not have %i features.'", "%", "nkerns", ")", "\n", "", "self", ".", "n_output", "=", "nkerns", "+", "layer_right", ".", "n_output", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Concat modes are: plain, truncated'", ")", "\n", "", "self", ".", "mode", "=", "mode", "\n", "self", ".", "nkerns", "=", "nkerns", "\n", "\n", "assert", "layer_left", ".", "output_height", "==", "layer_right", ".", "output_height", "\n", "assert", "layer_left", ".", "output_width", "==", "layer_right", ".", "output_width", "\n", "assert", "layer_left", ".", "output_depth", "==", "layer_right", ".", "output_depth", "\n", "\n", "super", "(", "Concatenate", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Concatenate._forward": [[833, 842], ["basic.Concatenate.layer_left.get_output", "basic.Concatenate.layer_right.get_output", "theano.concatenate", "theano.concatenate"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.get_output", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.get_output"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "left", "=", "self", ".", "layer_left", ".", "get_output", "(", ")", "\n", "\n", "if", "self", ".", "mode", "==", "'truncated'", ":", "\n", "            ", "left", "=", "left", "[", ":", ",", ":", ",", ":", "self", ".", "nkerns", ",", ":", ",", ":", "]", "\n", "\n", "", "right", "=", "self", ".", "layer_right", ".", "get_output", "(", ")", "\n", "\n", "self", ".", "output", "=", "T", ".", "concatenate", "(", "(", "left", ",", "right", ")", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Concatenate.get_output": [[843, 845], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Input.__init__": [[847, 859], ["breze.arch.construct.base.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "\n", "inpt_width", ",", "inpt_depth", ",", "\n", "n_inpt", ",", "mode", "=", "'same'", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "output_height", "=", "inpt_height", "\n", "self", ".", "output_width", "=", "inpt_width", "\n", "self", ".", "output_depth", "=", "inpt_depth", "\n", "self", ".", "n_output", "=", "n_inpt", "\n", "self", ".", "mode", "=", "mode", "\n", "\n", "super", "(", "Input", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Input._forward": [[860, 870], ["numpy.array", "basic.Input.inpt.mean", "basic.Input.inpt.std", "ValueError"], "methods", ["None"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "mode", "==", "'same'", ":", "\n", "            ", "self", ".", "output", "=", "self", ".", "inpt", "\n", "", "elif", "self", ".", "mode", "==", "'norm'", ":", "\n", "            ", "eps", "=", "np", ".", "array", "(", "1e-6", ",", "dtype", "=", "'float32'", ")", "\n", "mean", "=", "self", ".", "inpt", ".", "mean", "(", "axis", "=", "[", "0", ",", "1", ",", "3", ",", "4", "]", ",", "keepdims", "=", "True", ")", "\n", "std", "=", "self", ".", "inpt", ".", "std", "(", "axis", "=", "[", "0", ",", "1", ",", "3", ",", "4", "]", ",", "keepdims", "=", "True", ")", "\n", "self", ".", "output", "=", "(", "self", ".", "inpt", "-", "mean", ")", "/", "(", "std", "+", "eps", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Modes are: same, norm'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Input.get_output": [[871, 873], ["None"], "methods", ["None"], ["", "", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Skip.__init__": [[875, 884], ["inpt_layer.get_output", "breze.arch.construct.base.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.get_output", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt_layer", ",", "declare", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "        ", "self", ".", "inpt", "=", "inpt_layer", ".", "get_output", "(", ")", "\n", "self", ".", "output_height", "=", "inpt_layer", ".", "output_height", "\n", "self", ".", "output_width", "=", "inpt_layer", ".", "output_width", "\n", "self", ".", "output_depth", "=", "inpt_layer", ".", "output_depth", "\n", "self", ".", "n_output", "=", "inpt_layer", ".", "n_output", "\n", "\n", "super", "(", "Skip", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Skip._forward": [[885, 887], ["None"], "methods", ["None"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "self", ".", "output", "=", "self", ".", "inpt", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Skip.get_output": [[888, 890], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Gate.__init__": [[892, 905], ["inpt_layer.get_output", "len", "breze.arch.construct.base.Layer.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.get_output", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt_layer", ",", "take", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "self", ".", "inpt", "=", "inpt_layer", ".", "get_output", "(", ")", "\n", "self", ".", "output_height", "=", "inpt_layer", ".", "output_height", "\n", "self", ".", "output_width", "=", "inpt_layer", ".", "output_width", "\n", "self", ".", "output_depth", "=", "inpt_layer", ".", "output_depth", "\n", "\n", "if", "not", "isinstance", "(", "take", ",", "list", ")", ":", "\n", "            ", "take", "=", "[", "take", "]", "\n", "", "self", ".", "n_output", "=", "len", "(", "take", ")", "\n", "self", ".", "take", "=", "take", "\n", "\n", "super", "(", "Gate", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Gate._forward": [[906, 908], ["None"], "methods", ["None"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "self", ".", "output", "=", "self", ".", "inpt", "[", ":", ",", ":", ",", "self", ".", "take", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.Gate.get_output": [[909, 911], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.FlexConcatenate.__init__": [[913, 930], ["breze.arch.construct.base.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "layer_left", ",", "layer_right", ",", "\n", "take_left", ",", "take_right", ",", "declare", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "        ", "self", ".", "layer_left", "=", "layer_left", "\n", "self", ".", "layer_right", "=", "layer_right", "\n", "self", ".", "output_height", "=", "layer_left", ".", "output_height", "\n", "self", ".", "output_width", "=", "layer_left", ".", "output_width", "\n", "self", ".", "output_depth", "=", "layer_left", ".", "output_depth", "\n", "self", ".", "n_output", "=", "take_left", "+", "take_right", "\n", "self", ".", "take_left", "=", "take_left", "\n", "self", ".", "take_right", "=", "take_right", "\n", "\n", "assert", "layer_left", ".", "output_height", "==", "layer_right", ".", "output_height", "\n", "assert", "layer_left", ".", "output_width", "==", "layer_right", ".", "output_width", "\n", "assert", "layer_left", ".", "output_depth", "==", "layer_right", ".", "output_depth", "\n", "\n", "super", "(", "FlexConcatenate", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.FlexConcatenate._forward": [[931, 958], ["basic.FlexConcatenate.layer_left.get_output", "basic.FlexConcatenate.layer_right.get_output", "theano.concatenate", "theano.concatenate", "basic.Conv3d", "basic.Conv3d"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.get_output", "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.get_output"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "left", "=", "self", ".", "layer_left", ".", "get_output", "(", ")", "\n", "right", "=", "self", ".", "layer_right", ".", "get_output", "(", ")", "\n", "\n", "if", "self", ".", "layer_left", ".", "n_output", ">", "self", ".", "take_left", ":", "\n", "            ", "proj_left", "=", "Conv3d", "(", "\n", "inpt", "=", "left", ",", "inpt_height", "=", "self", ".", "layer_left", ".", "output_height", ",", "\n", "inpt_width", "=", "self", ".", "layer_left", ".", "output_width", ",", "inpt_depth", "=", "self", ".", "layer_left", ".", "output_depth", ",", "\n", "n_inpt", "=", "self", ".", "layer_left", ".", "n_output", ",", "filter_height", "=", "1", ",", "\n", "filter_width", "=", "1", ",", "filter_depth", "=", "1", ",", "n_output", "=", "self", ".", "take_left", ",", "\n", "transfer", "=", "'identity'", ",", "n_samples", "=", "None", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "declare", "=", "self", ".", "declare", "\n", ")", "\n", "left", "=", "proj_left", ".", "output", "\n", "\n", "", "if", "self", ".", "layer_right", ".", "n_output", ">", "self", ".", "take_right", ":", "\n", "            ", "proj_right", "=", "Conv3d", "(", "\n", "inpt", "=", "right", ",", "inpt_height", "=", "self", ".", "layer_right", ".", "output_height", ",", "\n", "inpt_width", "=", "self", ".", "layer_right", ".", "output_width", ",", "inpt_depth", "=", "self", ".", "layer_right", ".", "output_depth", ",", "\n", "n_inpt", "=", "self", ".", "layer_right", ".", "n_output", ",", "filter_height", "=", "1", ",", "\n", "filter_width", "=", "1", ",", "filter_depth", "=", "1", ",", "n_output", "=", "self", ".", "take_right", ",", "\n", "transfer", "=", "'identity'", ",", "n_samples", "=", "None", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "declare", "=", "self", ".", "declare", "\n", ")", "\n", "right", "=", "proj_right", ".", "output", "\n", "\n", "", "self", ".", "output", "=", "T", ".", "concatenate", "(", "(", "left", ",", "right", ")", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.FlexConcatenate.get_output": [[959, 961], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.OldBN.__init__": [[963, 990], ["theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "breze.arch.construct.base.Layer.__init__", "numpy.zeros", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "\n", "inpt_width", ",", "inpt_depth", ",", "\n", "n_inpt", ",", "alpha", "=", "0.5", ",", "warn_phase", "=", "False", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "'''\n        Batch normalization as described in: http://arxiv.org/pdf/1502.03167v3.pdf\n        It is assumed that the input has shape (1, depth, n_inpt, height, width) and\n        that the normalization is for every feature map.\n        :param alpha: Parameter used to compute running metrics(mean and std).\n                      The larger alpha is, the higher the influence of recent\n                      samples will be.\n        '''", "\n", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "output_height", "=", "inpt_height", "\n", "self", ".", "output_width", "=", "inpt_width", "\n", "self", ".", "output_depth", "=", "inpt_depth", "\n", "self", ".", "n_output", "=", "n_inpt", "\n", "self", ".", "warn_phase", "=", "warn_phase", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "running_mean", "=", "theano", ".", "shared", "(", "\n", "value", "=", "np", ".", "zeros", "(", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", ")", "\n", "self", ".", "running_std", "=", "theano", ".", "shared", "(", "\n", "value", "=", "np", ".", "ones", "(", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", ")", "\n", "\n", "super", "(", "OldBN", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.OldBN._forward": [[991, 1002], ["basic.OldBN.declare", "basic.OldBN.declare", "basic.OldBN.inpt.mean", "basic.OldBN.inpt.std"], "methods", ["None"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "param_size", "=", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", "\n", "self", ".", "gamma", "=", "self", ".", "declare", "(", "param_size", ")", "\n", "self", ".", "beta", "=", "self", ".", "declare", "(", "param_size", ")", "\n", "eps", "=", "1e-6", "\n", "\n", "mean", "=", "self", ".", "inpt", ".", "mean", "(", "axis", "=", "[", "0", ",", "1", ",", "3", ",", "4", "]", ",", "keepdims", "=", "True", ")", "\n", "std", "=", "self", ".", "inpt", ".", "std", "(", "axis", "=", "[", "0", ",", "1", ",", "3", ",", "4", "]", ",", "keepdims", "=", "True", ")", "\n", "\n", "norm_inpt", "=", "(", "self", ".", "inpt", "-", "mean", ")", "/", "(", "std", "+", "eps", ")", "\n", "self", ".", "output", "=", "self", ".", "gamma", "*", "norm_inpt", "+", "self", ".", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.OldBN.set_phase": [[1003, 1006], ["warnings.warn"], "methods", ["None"], ["", "def", "set_phase", "(", "self", ",", "new_phase", ")", ":", "\n", "        ", "if", "self", ".", "warn_phase", ":", "\n", "            ", "warnings", ".", "warn", "(", "'OldBN does not have phases.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.OldBN.get_output": [[1007, 1009], ["None"], "methods", ["None"], ["", "", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.OldBN.submit": [[1010, 1012], ["basic.OldBN.running_mean.get_value", "basic.OldBN.running_std.get_value"], "methods", ["None"], ["", "def", "submit", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "running_mean", ".", "get_value", "(", ")", ",", "self", ".", "running_std", ".", "get_value", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.__init__": [[1014, 1047], ["theano.zeros", "theano.zeros", "theano.zeros", "theano.zeros", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "breze.arch.construct.base.Layer.__init__", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inpt", ",", "inpt_height", ",", "\n", "inpt_width", ",", "inpt_depth", ",", "\n", "n_inpt", ",", "alpha", "=", "0.1", ",", "\n", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "'''\n        Batch normalization as described in: http://arxiv.org/pdf/1502.03167v3.pdf\n        It is assumed that the input has shape (1, depth, n_inpt, height, width) and\n        that the normalization is for every feature map.\n        :param alpha: Parameter used to compute running metrics(mean and std).\n                      The larger alpha is, the higher the influence of recent\n                      samples will be.\n        '''", "\n", "self", ".", "inpt", "=", "inpt", "\n", "self", ".", "output_height", "=", "inpt_height", "\n", "self", ".", "output_width", "=", "inpt_width", "\n", "self", ".", "output_depth", "=", "inpt_depth", "\n", "self", ".", "n_output", "=", "n_inpt", "\n", "\n", "self", ".", "freeze_mean", "=", "T", ".", "zeros", "(", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", "self", ".", "freeze_std", "=", "T", ".", "zeros", "(", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "self", ".", "phase", "=", "theano", ".", "shared", "(", "\n", "value", "=", "np", ".", "array", "(", "0", ",", "dtype", "=", "'int8'", ")", "\n", ")", "\n", "self", ".", "alpha", "=", "theano", ".", "shared", "(", "\n", "value", "=", "np", ".", "array", "(", "1.", ",", "dtype", "=", "'float32'", ")", "\n", ")", "\n", "self", ".", "real_alpha", "=", "theano", ".", "shared", "(", "\n", "value", "=", "np", ".", "array", "(", "alpha", ",", "dtype", "=", "'float32'", ")", "\n", ")", "\n", "self", ".", "alpha", ".", "default_update", "=", "self", ".", "real_alpha", "\n", "\n", "super", "(", "BatchNormFaulty", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty._forward": [[1048, 1093], ["theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "basic.BatchNormFaulty.declare", "basic.BatchNormFaulty.declare", "numpy.array", "theano.mean", "theano.mean", "theano.mean", "theano.mean", "theano.sqrt", "theano.sqrt", "basic.BatchNormFaulty.phase.get_value", "theano.sqr", "theano.sqr", "numpy.zeros", "numpy.zeros"], "methods", ["None"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "self", ".", "running_mean", "=", "theano", ".", "shared", "(", "\n", "value", "=", "np", ".", "zeros", "(", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", ")", "\n", "self", ".", "running_std", "=", "theano", ".", "shared", "(", "\n", "value", "=", "np", ".", "zeros", "(", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", ",", "dtype", "=", "'float32'", ")", "\n", ")", "\n", "\n", "param_size", "=", "(", "1", ",", "1", ",", "self", ".", "n_output", ",", "1", ",", "1", ")", "\n", "self", ".", "gamma", "=", "self", ".", "declare", "(", "param_size", ")", "\n", "self", ".", "beta", "=", "self", ".", "declare", "(", "param_size", ")", "\n", "eps", "=", "np", ".", "array", "(", "1e-6", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "mean", "=", "T", ".", "mean", "(", "self", ".", "inpt", ",", "axis", "=", "[", "0", ",", "1", ",", "3", ",", "4", "]", ",", "keepdims", "=", "True", ",", "dtype", "=", "'float32'", ")", "\n", "std", "=", "T", ".", "mean", "(", "T", ".", "sqr", "(", "self", ".", "inpt", "-", "mean", ")", ",", "axis", "=", "[", "0", ",", "1", ",", "3", ",", "4", "]", ",", "keepdims", "=", "True", ",", "dtype", "=", "'float32'", ")", "\n", "std", "=", "T", ".", "sqrt", "(", "std", "+", "eps", ")", "\n", "\n", "self", ".", "running_mean", ".", "default_update", "=", "(", "\n", "(", "1.0", "-", "self", ".", "alpha", ")", "*", "self", ".", "running_mean", "+", "self", ".", "alpha", "*", "mean", "\n", ")", "\n", "self", ".", "running_std", ".", "default_update", "=", "(", "\n", "(", "1.0", "-", "self", ".", "alpha", ")", "*", "self", ".", "running_std", "+", "self", ".", "alpha", "*", "std", "\n", ")", "\n", "\n", "# This will be optimized away, but ensures the running mean and the running std get updated.", "\n", "# Reference: https://gist.github.com/f0k/f1a6bd3c8585c400c190#file-batch_norm-py-L86", "\n", "mean", "+=", "0", "*", "self", ".", "running_mean", "\n", "std", "+=", "0", "*", "self", ".", "running_std", "\n", "\n", "phase", "=", "self", ".", "phase", ".", "get_value", "(", ")", "\n", "# train", "\n", "if", "phase", "==", "0", ":", "\n", "            ", "use_mean", "=", "mean", "\n", "use_std", "=", "std", "\n", "# valid", "\n", "", "elif", "phase", "==", "1", ":", "\n", "            ", "use_mean", "=", "self", ".", "freeze_mean", "\n", "use_std", "=", "self", ".", "freeze_std", "\n", "# infer", "\n", "", "else", ":", "\n", "            ", "use_mean", "=", "self", ".", "freeze_mean", "\n", "use_std", "=", "self", ".", "freeze_std", "\n", "\n", "", "norm_inpt", "=", "(", "self", ".", "inpt", "-", "use_mean", ")", "/", "use_std", "\n", "self", ".", "output", "=", "self", ".", "gamma", "*", "norm_inpt", "+", "self", ".", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.set_phase": [[1094, 1105], ["basic.BatchNormFaulty.phase.set_value"], "methods", ["None"], ["", "def", "set_phase", "(", "self", ",", "new_phase", ")", ":", "\n", "# Completely ignore the phase", "\n", "# get the running metrics before validation/inference", "\n", "#if phase == 1 or phase == 2:", "\n", "#    self.freeze_mean.set_value(self.running_mean.get_value())", "\n", "#    self.freeze_std.set_value(self.running_std.get_value())", "\n", "# reset the running metrics to old values before continuing the training", "\n", "#else:", "\n", "#    self.running_mean.set_value(self.freeze_mean)", "\n", "#    self.running_std.set_value(self.freeze_std)", "\n", "        ", "self", ".", "phase", ".", "set_value", "(", "new_phase", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.get_output": [[1106, 1108], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.BatchNormFaulty.submit": [[1109, 1111], ["basic.BatchNormFaulty.running_mean.get_value", "basic.BatchNormFaulty.running_std.get_value"], "methods", ["None"], ["", "def", "submit", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "running_mean", ".", "get_value", "(", ")", ",", "self", ".", "running_std", ".", "get_value", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__": [[1113, 1140], ["breze.arch.construct.base.Layer.__init__", "ValueError", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "target", ",", "predictions", ",", "loss", ",", "transfer", ",", "\n", "comp_dim", "=", "1", ",", "imp_weight", "=", "None", ",", "p_weights", "=", "None", ",", "\n", "mode", "=", "'sum'", ",", "declare", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "'''\n        Compute a loss that is a compound of different losses.\n        :param target: labels correponding to data\n        :param predictions: list of symbolic tensors of the same shape as target\n        :param loss: loss function\n        '''", "\n", "self", ".", "target", "=", "target", "\n", "self", ".", "predictions", "=", "predictions", "\n", "self", ".", "loss_ident", "=", "loss", "\n", "self", ".", "imp_weight", "=", "imp_weight", "\n", "self", ".", "comp_dim", "=", "comp_dim", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "transfer", "=", "transfer", "\n", "\n", "if", "p_weights", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "mode", "!=", "'weighted'", ":", "\n", "                ", "raise", "ValueError", "(", "'Set weights for sum but mode is not weighted.'", ")", "\n", "", "", "else", ":", "\n", "            ", "p_weights", "=", "[", "1", "]", "*", "len", "(", "predictions", ")", "\n", "if", "self", ".", "mode", "not", "in", "[", "'sum'", ",", "'mean'", "]", ":", "\n", "                ", "raise", "ValueError", "(", "'No weight scheme is given but mode is not sum or mean.'", ")", "\n", "", "", "self", ".", "p_weights", "=", "p_weights", "\n", "\n", "super", "(", "SupervisedMultiLoss", ",", "self", ")", ".", "__init__", "(", "declare", "=", "declare", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.SupervisedMultiLoss._forward": [[1141, 1157], ["breze.arch.util.lookup", "theano.zeros", "theano.zeros", "zip", "breze.arch.util.lookup.", "coord_wise.sum", "sample_wise.mean", "len", "basic.SupervisedMultiLoss.transfer"], "methods", ["None"], ["", "def", "_forward", "(", "self", ")", ":", "\n", "        ", "f_loss", "=", "lookup", "(", "self", ".", "loss_ident", ",", "_loss", ")", "\n", "\n", "self", ".", "coord_wise_multi", "=", "[", "f_loss", "(", "self", ".", "target", ",", "self", ".", "transfer", "(", "pred", ")", ")", "for", "pred", "in", "self", ".", "predictions", "]", "\n", "if", "self", ".", "imp_weight", "is", "not", "None", ":", "\n", "            ", "self", ".", "coord_wise_multi", "=", "[", "coord_wise", "*", "self", ".", "imp_weight", "for", "coord_wise", "in", "self", ".", "coord_wise_multi", "]", "\n", "\n", "", "self", ".", "sample_wise_multi", "=", "[", "coord_wise", ".", "sum", "(", "self", ".", "comp_dim", ")", "for", "coord_wise", "in", "self", ".", "coord_wise_multi", "]", "\n", "self", ".", "total_multi", "=", "[", "sample_wise", ".", "mean", "(", ")", "for", "sample_wise", "in", "self", ".", "sample_wise_multi", "]", "\n", "\n", "self", ".", "total", "=", "T", ".", "zeros", "(", "self", ".", "total_multi", "[", "0", "]", ".", "shape", ")", "\n", "for", "tot", ",", "pw", "in", "zip", "(", "self", ".", "total_multi", ",", "self", ".", "p_weights", ")", ":", "\n", "            ", "self", ".", "total", "+=", "tot", "*", "pw", "\n", "\n", "", "if", "self", ".", "mode", "==", "'mean'", ":", "\n", "            ", "self", ".", "total", "/=", "len", "(", "self", ".", "predictions", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.prelu": [[13, 18], ["theano.maximum", "theano.minimum"], "function", ["None"], ["def", "prelu", "(", "inpt", ",", "a", ")", ":", "\n", "    ", "'''\n    Parametric rectified linear unit, see: https://arxiv.org/pdf/1502.01852.pdf\n    '''", "\n", "return", "T", ".", "maximum", "(", "inpt", ",", "0", ")", "+", "a", "*", "T", ".", "minimum", "(", "inpt", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.elu": [[19, 24], ["theano.exp"], "function", ["None"], ["", "def", "elu", "(", "inpt", ")", ":", "\n", "    ", "'''\n    Exponential linear unit, see: arxiv:1511.07289v5 [cs.LG]\n    '''", "\n", "return", "(", "inpt", ">", "0", ")", "*", "inpt", "+", "(", "inpt", "<=", "0", ")", "*", "(", "T", ".", "exp", "(", "inpt", ")", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.tensor_softmax": [[25, 33], ["inpt.dimshuffle", "theano.reshape", "breze.arch.util.lookup", "theano.reshape", "T.reshape.dimshuffle", "breze.arch.util.lookup."], "function", ["None"], ["", "def", "tensor_softmax", "(", "inpt", ",", "n_classes", "=", "2", ")", ":", "\n", "    ", "output", "=", "inpt", ".", "dimshuffle", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ")", "\n", "shuffled_shape", "=", "output", ".", "shape", "\n", "output", "=", "T", ".", "reshape", "(", "output", ",", "(", "-", "1", ",", "n_classes", ")", ")", "\n", "\n", "f", "=", "lookup", "(", "'softmax'", ",", "_transfer", ")", "\n", "output", "=", "T", ".", "reshape", "(", "f", "(", "output", ")", ",", "shuffled_shape", ")", "\n", "return", "output", ".", "dimshuffle", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.stretch_axis": [[34, 55], ["theano.zeros", "slice", "slice", "slice", "slice", "theano.set_subtensor", "theano.set_subtensor", "slice", "slice", "slice", "slice"], "function", ["None"], ["", "def", "stretch_axis", "(", "a", ",", "axis", ",", "factor", ",", "original_shape", ")", ":", "\n", "    ", "new_shape", "=", "[", "original_shape", "[", "0", "]", ",", "original_shape", "[", "1", "]", ",", "\n", "original_shape", "[", "2", "]", ",", "original_shape", "[", "3", "]", ",", "\n", "original_shape", "[", "4", "]", "]", "\n", "new_shape", "[", "axis", "]", "*=", "factor", "\n", "out_first", "=", "T", ".", "zeros", "(", "new_shape", ")", "\n", "\n", "indices_first", "=", "[", "slice", "(", "None", ")", ",", "]", "*", "5", "\n", "indices_first", "[", "axis", "]", "=", "slice", "(", "0", ",", "new_shape", "[", "axis", "]", ",", "factor", "*", "2", ")", "\n", "indices_second", "=", "[", "slice", "(", "None", ")", ",", "]", "*", "5", "\n", "indices_second", "[", "axis", "]", "=", "slice", "(", "factor", "*", "2", "-", "1", ",", "new_shape", "[", "axis", "]", ",", "factor", "*", "2", ")", "\n", "\n", "indices_take_first", "=", "[", "slice", "(", "None", ")", ",", "]", "*", "5", "\n", "indices_take_first", "[", "axis", "]", "=", "slice", "(", "0", ",", "original_shape", "[", "axis", "]", ",", "factor", ")", "\n", "indices_take_second", "=", "[", "slice", "(", "None", ")", ",", "]", "*", "5", "\n", "indices_take_second", "[", "axis", "]", "=", "slice", "(", "1", ",", "original_shape", "[", "axis", "]", ",", "factor", ")", "\n", "\n", "out_second", "=", "T", ".", "set_subtensor", "(", "out_first", "[", "indices_first", "]", ",", "a", "[", "indices_take_first", "]", ")", "\n", "out", "=", "T", ".", "set_subtensor", "(", "out_second", "[", "indices_second", "]", ",", "a", "[", "indices_take_second", "]", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.max_pool_3d": [[188, 228], ["theano.reshape", "theano.tensor.signal.pool.pool_2d", "theano.join", "theano.reshape", "T.reshape.dimshuffle", "theano.reshape", "theano.tensor.signal.pool.pool_2d", "theano.join", "theano.reshape", "T.reshape.dimshuffle"], "function", ["None"], ["", "", "def", "max_pool_3d", "(", "inpt", ",", "inpt_shape", ",", "ds", ",", "ignore_border", "=", "True", ")", ":", "\n", "# Downsize 'into the depth' by downsizing twice.", "\n", "    ", "inpt_shape_4d", "=", "(", "\n", "inpt_shape", "[", "0", "]", "*", "inpt_shape", "[", "1", "]", ",", "\n", "inpt_shape", "[", "2", "]", ",", "\n", "inpt_shape", "[", "3", "]", ",", "\n", "inpt_shape", "[", "4", "]", "\n", ")", "\n", "\n", "inpt_as_tensor4", "=", "T", ".", "reshape", "(", "inpt", ",", "inpt_shape_4d", ",", "ndim", "=", "4", ")", "\n", "\n", "# The first pooling only downsizes the height and the width.", "\n", "pool_out1", "=", "pool", ".", "pool_2d", "(", "inpt_as_tensor4", ",", "(", "ds", "[", "1", "]", ",", "ds", "[", "2", "]", ")", ",", "\n", "ignore_border", "=", "True", ")", "\n", "out_shape1", "=", "T", ".", "join", "(", "0", ",", "inpt_shape", "[", ":", "-", "2", "]", ",", "pool_out1", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "inpt_pooled_once", "=", "T", ".", "reshape", "(", "pool_out1", ",", "out_shape1", ",", "ndim", "=", "5", ")", "\n", "\n", "# Shuffle dimensions so the depth is the last dimension.", "\n", "inpt_shuffled", "=", "inpt_pooled_once", ".", "dimshuffle", "(", "0", ",", "4", ",", "2", ",", "3", ",", "1", ")", "\n", "\n", "shuffled_shape", "=", "inpt_shuffled", ".", "shape", "\n", "# Reshape input to be 4 dimensional.", "\n", "shuffle_shape_4d", "=", "(", "\n", "shuffled_shape", "[", "0", "]", "*", "shuffled_shape", "[", "1", "]", ",", "\n", "shuffled_shape", "[", "2", "]", ",", "\n", "shuffled_shape", "[", "3", "]", ",", "\n", "shuffled_shape", "[", "4", "]", "\n", ")", "\n", "\n", "inpt_shuffled_4d", "=", "T", ".", "reshape", "(", "inpt_shuffled", ",", "shuffle_shape_4d", ",", "ndim", "=", "4", ")", "\n", "\n", "pool_out2", "=", "pool", ".", "pool_2d", "(", "inpt_shuffled_4d", ",", "(", "1", ",", "ds", "[", "0", "]", ")", ",", "\n", "ignore_border", "=", "True", ")", "\n", "out_shape2", "=", "T", ".", "join", "(", "0", ",", "shuffled_shape", "[", ":", "-", "2", "]", ",", "pool_out2", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "inpt_pooled_twice", "=", "T", ".", "reshape", "(", "pool_out2", ",", "out_shape2", ",", "ndim", "=", "5", ")", "\n", "pool_output_fin", "=", "inpt_pooled_twice", ".", "dimshuffle", "(", "0", ",", "4", ",", "2", ",", "3", ",", "1", ")", "\n", "\n", "return", "pool_output_fin", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.upsample_3d": [[279, 310], ["numpy.array", "numpy.array", "theano.repeat", "theano.repeat", "theano.repeat", "numpy.ones", "theano.repeat", "numpy.ones", "theano.repeat", "numpy.ones", "theano.repeat"], "function", ["None"], ["", "", "def", "upsample_3d", "(", "inpt", ",", "to_shape", ",", "inpt_height", ",", "inpt_width", ",", "inpt_depth", ")", ":", "\n", "    ", "inpt_shape", "=", "np", ".", "array", "(", "[", "inpt_height", ",", "inpt_width", ",", "inpt_depth", "]", ")", "\n", "to_shape", "=", "np", ".", "array", "(", "to_shape", ")", "\n", "up_factors", "=", "to_shape", "/", "inpt_shape", "\n", "\n", "if", "to_shape", "[", "0", "]", ">=", "up_factors", "[", "0", "]", "*", "inpt_shape", "[", "0", "]", ":", "\n", "        ", "inpt", "=", "T", ".", "repeat", "(", "inpt", ",", "up_factors", "[", "0", "]", ",", "axis", "=", "3", ")", "\n", "inpt_shape", "[", "0", "]", "*=", "up_factors", "[", "0", "]", "\n", "", "if", "to_shape", "[", "1", "]", ">=", "up_factors", "[", "1", "]", "*", "inpt_shape", "[", "1", "]", ":", "\n", "        ", "inpt", "=", "T", ".", "repeat", "(", "inpt", ",", "up_factors", "[", "1", "]", ",", "axis", "=", "4", ")", "\n", "inpt_shape", "[", "1", "]", "*=", "up_factors", "[", "1", "]", "\n", "", "if", "to_shape", "[", "2", "]", ">=", "up_factors", "[", "2", "]", "*", "inpt_shape", "[", "2", "]", ":", "\n", "        ", "inpt", "=", "T", ".", "repeat", "(", "inpt", ",", "up_factors", "[", "2", "]", ",", "axis", "=", "2", ")", "\n", "inpt_shape", "[", "2", "]", "*=", "up_factors", "[", "2", "]", "\n", "\n", "", "while", "to_shape", "[", "0", "]", ">=", "inpt_shape", "[", "0", "]", ":", "\n", "        ", "reps", "=", "np", ".", "ones", "(", "inpt_shape", "[", "0", "]", ",", "dtype", "=", "'int16'", ")", "\n", "reps", "[", "-", "1", "]", "=", "2", "\n", "inpt", "=", "T", ".", "repeat", "(", "inpt", ",", "reps", ",", "axis", "=", "3", ")", "\n", "inpt_shape", "[", "0", "]", "+=", "1", "\n", "", "while", "to_shape", "[", "1", "]", ">=", "inpt_shape", "[", "1", "]", ":", "\n", "        ", "reps", "=", "np", ".", "ones", "(", "inpt_shape", "[", "1", "]", ",", "dtype", "=", "'int16'", ")", "\n", "reps", "[", "-", "1", "]", "=", "2", "\n", "inpt", "=", "T", ".", "repeat", "(", "inpt", ",", "reps", ",", "axis", "=", "4", ")", "\n", "inpt_shape", "[", "1", "]", "+=", "1", "\n", "", "while", "to_shape", "[", "2", "]", ">=", "inpt_shape", "[", "2", "]", ":", "\n", "        ", "reps", "=", "np", ".", "ones", "(", "inpt_shape", "[", "2", "]", ",", "dtype", "=", "'int16'", ")", "\n", "reps", "[", "-", "1", "]", "=", "2", "\n", "inpt", "=", "T", ".", "repeat", "(", "inpt", ",", "reps", ",", "axis", "=", "2", ")", "\n", "inpt_shape", "[", "2", "]", "+=", "1", "\n", "", "return", "inpt", "\n", "\n"]], "home.repos.pwc.inspect_result.BRML_CNNbasedMedicalSegmentation.conv3d.basic.simple_upsample3d": [[311, 318], ["theano.repeat", "theano.repeat", "theano.repeat"], "function", ["None"], ["", "def", "simple_upsample3d", "(", "inpt", ",", "up_factor", ")", ":", "\n", "    ", "inpt", "=", "T", ".", "repeat", "(", "inpt", ",", "up_factor", "[", "0", "]", ",", "axis", "=", "3", ")", "\n", "inpt", "=", "T", ".", "repeat", "(", "inpt", ",", "up_factor", "[", "1", "]", ",", "axis", "=", "4", ")", "\n", "inpt", "=", "T", ".", "repeat", "(", "inpt", ",", "up_factor", "[", "2", "]", ",", "axis", "=", "1", ")", "\n", "#rep = [1, up_factor[2], 1, up_factor[0], up_factor[1]]", "\n", "#inpt = T.tile(inpt, rep, ndim=5)", "\n", "return", "inpt", "\n", "\n"]]}