{"home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_coref.save_coref_results": [[21, 39], ["anaphor_position.split.split", "int", "[].append"], "function", ["None"], ["def", "save_coref_results", "(", "data", ",", "cid_to_wrong_predictions", ")", ":", "\n", "    ", "for", "d", "in", "data", ":", "\n", "        ", "if", "d", "[", "'conversationId'", "]", "in", "cid_to_wrong_predictions", ":", "\n", "            ", "wrong_predictions", "=", "cid_to_wrong_predictions", "[", "d", "[", "'conversationId'", "]", "]", "\n", "for", "anaphor_position", ",", "antecedent_positions", "in", "wrong_predictions", ":", "\n", "                ", "anaphor_position", "=", "anaphor_position", ".", "split", "(", ")", "\n", "anaphor_turn", ",", "anaphor_name", "=", "int", "(", "anaphor_position", "[", "0", "]", "[", "2", ":", "]", ")", ",", "anaphor_position", "[", "1", "]", "[", "2", ":", "]", "\n", "if", "'wrong_coref_prediction'", "in", "d", "[", "'turns'", "]", "[", "anaphor_turn", "]", ":", "\n", "                    ", "d", "[", "'turns'", "]", "[", "anaphor_turn", "]", "[", "'wrong_coref_prediction'", "]", ".", "append", "(", "{", "\n", "'reference_node'", ":", "anaphor_name", ",", "\n", "'prediction'", ":", "antecedent_positions", "\n", "}", ")", "\n", "", "else", ":", "\n", "                    ", "d", "[", "'turns'", "]", "[", "anaphor_turn", "]", "[", "'wrong_coref_prediction'", "]", "=", "[", "{", "\n", "'reference_node'", ":", "anaphor_name", ",", "\n", "'prediction'", ":", "antecedent_positions", "\n", "}", "]", "\n", "", "", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_coref.test": [[41, 107], ["print", "model.eval", "collections.defaultdict", "numpy.arange", "numpy.zeros", "isinstance", "batch_probs.append", "enumerate", "numpy.argmax", "print", "len", "torch.no_grad", "model", "label.size", "enumerate", "torch.equal", "torch.equal", "torch.numel", "torch.numel", "torch.nonzero", "tail_nids[].cpu().data.numpy().tolist", "head_nids[].item", "cid_to_wrong_predictions[].append", "torch.nonzero", "p.max", "tail_nids[].cpu().data.numpy", "p.max", "tail_nids[].cpu", "pred.bool"], "function", ["None"], ["", "def", "test", "(", "dl", ",", "best_beta", "=", "None", ",", "save_result", "=", "False", ")", ":", "\n", "    ", "print", "(", "'evaluating...'", ")", "\n", "model", ".", "eval", "(", ")", "\n", "tot_cnt", "=", "0", "\n", "cid_to_wrong_predictions", "=", "defaultdict", "(", "list", ")", "\n", "batch_probs", "=", "[", "]", "\n", "\n", "if", "not", "best_beta", ":", "\n", "        ", "thresholds", "=", "np", ".", "arange", "(", "0", ",", "1", ",", "0.01", ")", "\n", "correct_counts", "=", "np", ".", "zeros", "(", "len", "(", "thresholds", ")", ")", "\n", "", "else", ":", "\n", "        ", "assert", "isinstance", "(", "best_beta", ",", "float", ")", "\n", "correct_cnt", "=", "0", "\n", "\n", "", "for", "batch", "in", "dl", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "probs", "=", "model", "(", "batch", ",", "False", ")", "\n", "\n", "", "batch_probs", ".", "append", "(", "probs", ")", "\n", "\n", "start_idx", "=", "0", "\n", "\n", "for", "i", ",", "references", "in", "enumerate", "(", "batch", "[", "'reference_list'", "]", ")", ":", "\n", "            ", "nid_to_position", "=", "batch", "[", "'nid_to_position'", "]", "[", "i", "]", "\n", "cid", "=", "batch", "[", "'conversationId'", "]", "[", "i", "]", "\n", "\n", "for", "head_nids", ",", "tail_nids", ",", "label", "in", "references", ":", "\n", "                ", "num_labels", "=", "label", ".", "size", "(", "-", "1", ")", "\n", "p", "=", "probs", "[", "start_idx", ":", "start_idx", "+", "num_labels", "]", "\n", "tot_cnt", "+=", "1", "\n", "\n", "if", "not", "best_beta", ":", "\n", "                    ", "for", "beta_idx", ",", "beta", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "                        ", "pred", "=", "(", "p", ">", "beta", ")", ".", "float", "(", ")", "\n", "if", "torch", ".", "numel", "(", "(", "torch", ".", "nonzero", "(", "pred", ")", ")", ")", "==", "0", ":", "\n", "                            ", "pred", "=", "(", "p", "==", "p", ".", "max", "(", ")", ")", ".", "float", "(", ")", "\n", "", "if", "torch", ".", "equal", "(", "pred", ",", "label", ")", ":", "\n", "                            ", "correct_counts", "[", "beta_idx", "]", "+=", "1", "\n", "", "", "", "else", ":", "\n", "                    ", "pred", "=", "(", "p", ">", "best_beta", ")", ".", "float", "(", ")", "\n", "if", "torch", ".", "numel", "(", "(", "torch", ".", "nonzero", "(", "pred", ")", ")", ")", "==", "0", ":", "\n", "                        ", "pred", "=", "(", "p", "==", "p", ".", "max", "(", ")", ")", ".", "float", "(", ")", "\n", "", "if", "torch", ".", "equal", "(", "pred", ",", "label", ")", ":", "\n", "                        ", "correct_cnt", "+=", "1", "\n", "", "elif", "save_result", ":", "\n", "                        ", "predicted_nids", "=", "tail_nids", "[", "pred", ".", "bool", "(", ")", "]", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "anaphor_nid", "=", "head_nids", "[", "0", "]", ".", "item", "(", ")", "\n", "\n", "predicted_node_positions", "=", "[", "nid_to_position", "[", "nid", "]", "for", "nid", "in", "predicted_nids", "]", "\n", "anaphor_position", "=", "nid_to_position", "[", "anaphor_nid", "]", "\n", "\n", "cid_to_wrong_predictions", "[", "cid", "]", ".", "append", "(", "(", "anaphor_position", ",", "predicted_node_positions", ")", ")", "\n", "\n", "", "", "start_idx", "+=", "num_labels", "\n", "\n", "", "", "", "if", "not", "best_beta", ":", "\n", "        ", "best_beta_idx", "=", "np", ".", "argmax", "(", "correct_counts", ")", "\n", "best_beta", "=", "thresholds", "[", "best_beta_idx", "]", "\n", "print", "(", "f'best beta: {best_beta}'", ")", "\n", "acc", "=", "correct_counts", "[", "best_beta_idx", "]", "/", "tot_cnt", "\n", "", "else", ":", "\n", "        ", "acc", "=", "correct_cnt", "/", "tot_cnt", "\n", "\n", "", "if", "save_result", ":", "\n", "        ", "return", "acc", ",", "cid_to_wrong_predictions", "\n", "", "return", "acc", ",", "best_beta", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_coref.train": [[109, 143], ["torch.optim.Adam", "torch.nn.BCELoss", "range", "model.load_state_dict", "run_coref.test", "print", "print", "print", "print", "print", "model.parameters", "model.train", "tqdm.tqdm", "run_coref.test", "print", "print", "torch.load", "model", "torch.nn.BCELoss.", "torch.optim.Adam.zero_grad", "loss_fn.backward", "torch.optim.Adam.step", "tqdm.tqdm.set_description", "tqdm.tqdm.refresh", "torch.save", "json.dump", "print", "model.state_dict", "open", "loss_fn.item"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_parsing.test", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_parsing.train", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_parsing.test"], ["", "def", "train", "(", ")", ":", "\n", "    ", "optimizer", "=", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ")", "\n", "loss_fn", "=", "BCELoss", "(", ")", "\n", "\n", "best_dev_acc", "=", "0.", "\n", "best_beta", "=", "0.", "\n", "for", "epoch", "in", "range", "(", "args", ".", "epoch", ")", ":", "\n", "        ", "model", ".", "train", "(", ")", "\n", "bar", "=", "tqdm", "(", "train_dl", ")", "\n", "for", "batch", "in", "bar", ":", "\n", "            ", "probs", ",", "labels", "=", "model", "(", "batch", ",", "True", ")", "\n", "\n", "loss", "=", "loss_fn", "(", "probs", ",", "labels", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "bar", ".", "set_description", "(", "f'loss: {loss.item()}'", ")", "\n", "bar", ".", "refresh", "(", ")", "\n", "", "dev_acc", ",", "beta", "=", "test", "(", "dev_dl", ")", "\n", "print", "(", "f'Epoch {epoch}, Dev Acc : {dev_acc}'", ")", "\n", "if", "dev_acc", ">", "best_dev_acc", ":", "\n", "            ", "best_dev_acc", "=", "dev_acc", "\n", "best_beta", "=", "beta", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "ckpt_file", ")", "\n", "json", ".", "dump", "(", "best_beta", ",", "open", "(", "ckpt_file", "+", "'_best_beta.json'", ",", "'w'", ")", ")", "\n", "print", "(", "f'Model saved to {ckpt_file}'", ")", "\n", "", "print", "(", "f'So far, dev best Acc: {best_dev_acc}'", ")", "\n", "", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "ckpt_file", ")", ")", "\n", "test_acc", ",", "best_beta", "=", "test", "(", "test_dl", ",", "best_beta", ")", "\n", "print", "(", "'================================================'", ")", "\n", "print", "(", "f'Test set Acc: {test_acc}'", ")", "\n", "print", "(", "f'Dev set Acc: {best_dev_acc}'", ")", "\n", "print", "(", "f'Best threshold: {best_beta}'", ")", "\n", "print", "(", "'================================================'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.Relation.__init__": [[75, 79], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "value", ",", "head_node", ",", "tail_node", ")", ":", "\n", "        ", "self", ".", "value", "=", "value", "\n", "self", ".", "head_node", "=", "head_node", "\n", "self", ".", "tail_node", "=", "tail_node", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.Reference.__init__": [[82, 92], ["refer_value.split.split.split", "len", "int", "len", "int"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "refer_value", ")", ":", "\n", "        ", "refer_value", "=", "refer_value", ".", "split", "(", ")", "\n", "if", "len", "(", "refer_value", ")", "==", "2", ":", "\n", "            ", "turn", ",", "node", "=", "refer_value", "\n", "self", ".", "turn", "=", "int", "(", "turn", "[", "2", ":", "]", ")", "\n", "self", ".", "variable", "=", "node", "[", "2", ":", "]", "\n", "", "elif", "len", "(", "refer_value", ")", "==", "1", ":", "\n", "            ", "turn", "=", "refer_value", "[", "0", "]", "\n", "self", ".", "turn", "=", "int", "(", "turn", "[", "2", ":", "]", ")", "\n", "self", ".", "variable", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.Reference.__str__": [[93, 98], ["None"], "methods", ["None"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "variable", ":", "\n", "            ", "return", "f'T:{self.turn} N:{self.variable}'", "\n", "", "else", ":", "\n", "            ", "return", "f'T:{self.turn}'", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.Reference.__repr__": [[99, 101], ["str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.Node.__init__": [[104, 145], ["node.strip.strip.strip", "re.fullmatch", "re.match", "re.match", "node.strip.strip.split", "node.strip.strip.strip", "re.match.span", "re.match.span", "node.strip.strip.split", "re.match.span"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "node", ")", ":", "\n", "        ", "node", "=", "node", ".", "strip", "(", ")", "\n", "\n", "self", ".", "variable", "=", "None", "\n", "self", ".", "value", "=", "None", "\n", "self", ".", "entity_type", "=", "None", "\n", "\n", "self", ".", "is_reference_node", "=", "False", "\n", "self", ".", "referents", "=", "None", "\n", "self", ".", "is_refer_to_agent", "=", "False", "\n", "\n", "# 1. only a variable, e.g. v1", "\n", "if", "re", ".", "fullmatch", "(", "r'v[\\d]+'", ",", "node", ")", ":", "\n", "            ", "self", ".", "variable", "=", "node", "\n", "", "elif", "not", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "node", ")", ":", "\n", "# 2. constant, e.g. -", "\n", "            ", "self", ".", "value", "=", "node", "\n", "", "else", ":", "\n", "# 3. variable / lexical_value || entity_type, e.g. v1 / pizza", "\n", "            ", "m", "=", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "node", ")", "\n", "self", ".", "variable", "=", "node", "[", "m", ".", "span", "(", ")", "[", "0", "]", ":", "m", ".", "span", "(", ")", "[", "1", "]", "-", "3", "]", "\n", "node", "=", "node", "[", "m", ".", "span", "(", ")", "[", "1", "]", ":", "]", "\n", "\n", "if", "'reference'", "in", "node", ":", "\n", "                ", "self", ".", "is_reference_node", "=", "True", "\n", "if", "' || '", "in", "node", ":", "\n", "                    ", "self", ".", "value", "=", "node", ".", "split", "(", "' || '", ")", "[", "1", "]", "\n", "", "", "else", ":", "\n", "                ", "if", "' || '", "in", "node", ":", "\n", "                    ", "self", ".", "value", ",", "self", ".", "entity_type", "=", "node", ".", "split", "(", "' || '", ")", "\n", "assert", "self", ".", "entity_type", "in", "ff_entity_types", "\n", "", "else", ":", "\n", "                    ", "node", "=", "node", ".", "strip", "(", ")", "\n", "if", "node", "in", "ff_entity_types", ":", "\n", "                        ", "self", ".", "entity_type", "=", "node", "\n", "", "else", ":", "\n", "                        ", "self", ".", "value", "=", "node", "\n", "\n", "", "", "", "", "self", ".", "in_relation", "=", "None", "\n", "self", ".", "out_relations", "=", "None", "\n", "self", ".", "node_type", "=", "None", "# defined as incoming edge type, not including :opn", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.Node.__repr__": [[146, 164], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "node_value", "=", "None", "\n", "if", "self", ".", "variable", ":", "\n", "            ", "if", "self", ".", "is_reference_node", ":", "\n", "                ", "if", "not", "self", ".", "value", ":", "\n", "                    ", "node_value", "=", "f'{self.variable} / reference'", "\n", "", "else", ":", "\n", "                    ", "node_value", "=", "f'{self.variable} / reference || {self.value}'", "\n", "", "", "else", ":", "\n", "                ", "if", "self", ".", "value", "and", "self", ".", "entity_type", ":", "\n", "                    ", "node_value", "=", "f'{self.variable} / {self.value} || {self.entity_type}'", "\n", "", "elif", "self", ".", "value", ":", "\n", "                    ", "node_value", "=", "f'{self.variable} / {self.value}'", "\n", "", "elif", "self", ".", "entity_type", ":", "\n", "                    ", "node_value", "=", "f'{self.variable} / {self.entity_type}'", "\n", "", "", "", "else", ":", "\n", "            ", "node_value", "=", "self", ".", "value", "\n", "", "return", "node_value", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.__init__": [[167, 175], ["collections.defaultdict", "utils.DMR._read_dmr"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR._read_dmr"], ["    ", "def", "__init__", "(", "self", ",", "root", ")", ":", "\n", "        ", "self", ".", "max_var_num", "=", "0", "\n", "self", ".", "root", "=", "root", "\n", "self", ".", "ntype2nodes", "=", "defaultdict", "(", "list", ")", "\n", "self", ".", "refer_nodes", "=", "[", "]", "\n", "self", ".", "nodes", "=", "[", "]", "\n", "\n", "self", ".", "_read_dmr", "(", "self", ".", "root", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.from_dict": [[176, 204], ["cls", "isinstance", "utils.DMR.from_dict._bfs"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_dict", "(", "cls", ",", "dmr_dict", ")", ":", "\n", "        ", "def", "_bfs", "(", "dmr", ",", "is_node", "=", "True", ")", ":", "\n", "            ", "if", "isinstance", "(", "dmr", ",", "str", ")", ":", "\n", "                ", "assert", "is_node", ",", "print", "(", "dmr", ",", "dmr_dict", ")", "\n", "return", "[", "Node", "(", "dmr", ")", "]", "\n", "", "else", ":", "\n", "                ", "ret", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "dmr", ".", "items", "(", ")", ":", "\n", "                    ", "if", "is_node", ":", "\n", "                        ", "n", "=", "Node", "(", "k", ")", "\n", "out_relations", "=", "_bfs", "(", "v", ",", "not", "is_node", ")", "\n", "for", "r", "in", "out_relations", ":", "\n", "                            ", "r", ".", "head_node", "=", "n", "\n", "", "if", "out_relations", "and", "len", "(", "out_relations", ")", ">", "0", ":", "\n", "                            ", "n", ".", "out_relations", "=", "out_relations", "\n", "", "ret", ".", "append", "(", "n", ")", "\n", "", "else", ":", "\n", "                        ", "r", "=", "Relation", "(", "k", ",", "None", ",", "None", ")", "\n", "tail_node", "=", "_bfs", "(", "v", ",", "not", "is_node", ")", "[", "0", "]", "\n", "tail_node", ".", "in_relation", "=", "r", "\n", "r", ".", "tail_node", "=", "tail_node", "\n", "ret", ".", "append", "(", "r", ")", "\n", "", "", "return", "ret", "\n", "\n", "", "", "node", "=", "_bfs", "(", "dmr_dict", ",", "True", ")", "[", "0", "]", "\n", "dmr", "=", "cls", "(", "node", ")", "\n", "return", "dmr", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR._read_dmr": [[205, 241], ["utils.DMR.nodes.append", "max", "utils.DMR.ntype2nodes[].append", "int", "len", "utils.DMR.ntype2nodes[].append", "utils.DMR._read_dmr", "utils.DMR.refer_nodes.append", "any", "sorted", "node.referents.append", "len", "node.referents.append", "utils.Reference", "utils.Reference", "int"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR._read_dmr"], ["", "def", "_read_dmr", "(", "self", ",", "node", ")", ":", "\n", "        ", "if", "node", "is", "None", ":", "\n", "            ", "return", "\n", "", "self", ".", "nodes", ".", "append", "(", "node", ")", "\n", "if", "node", ".", "variable", ":", "\n", "            ", "c", "=", "node", ".", "variable", "[", "1", ":", "]", "\n", "self", ".", "max_var_num", "=", "max", "(", "self", ".", "max_var_num", ",", "int", "(", "c", ")", ")", "\n", "", "in_rel", "=", "node", ".", "in_relation", "\n", "if", "in_rel", "and", "len", "(", "in_rel", ".", "value", ")", ">", "3", "and", "in_rel", ".", "value", "[", ":", "3", "]", "==", "':op'", ":", "\n", "            ", "in_rel", "=", "in_rel", ".", "head_node", ".", "in_relation", "\n", "", "if", "in_rel", ":", "\n", "            ", "node", ".", "node_type", "=", "in_rel", ".", "value", "\n", "if", "node", ".", "value", "!=", "'and'", ":", "\n", "                ", "self", ".", "ntype2nodes", "[", "node", ".", "node_type", "]", ".", "append", "(", "node", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "ntype2nodes", "[", "'None'", "]", ".", "append", "(", "node", ")", "\n", "", "if", "node", ".", "out_relations", ":", "\n", "            ", "for", "r", "in", "node", ".", "out_relations", ":", "\n", "                ", "if", "r", ".", "value", "==", "':refer'", ":", "\n", "                    ", "node", ".", "is_reference_node", "=", "True", "\n", "node", ".", "referents", "=", "[", "]", "\n", "if", "r", ".", "tail_node", ".", "value", "==", "'and'", ":", "\n", "                        ", "r", ".", "tail_node", ".", "out_relations", "=", "sorted", "(", "r", ".", "tail_node", ".", "out_relations", ",", "key", "=", "lambda", "x", ":", "int", "(", "x", ".", "value", "[", "3", ":", "]", ")", ")", "\n", "for", "_r", "in", "r", ".", "tail_node", ".", "out_relations", ":", "\n", "                            ", "node", ".", "referents", ".", "append", "(", "Reference", "(", "_r", ".", "tail_node", ".", "value", ")", ")", "\n", "", "", "else", ":", "\n", "                        ", "node", ".", "referents", ".", "append", "(", "Reference", "(", "r", ".", "tail_node", ".", "value", ")", ")", "\n", "", "if", "any", "(", "refer", ".", "variable", "is", "None", "for", "refer", "in", "node", ".", "referents", ")", ":", "\n", "                        ", "node", ".", "is_refer_to_agent", "=", "True", "\n", "# else:", "\n", "#     self._read_dmr(r.tail_node)", "\n", "", "", "self", ".", "_read_dmr", "(", "r", ".", "tail_node", ")", "\n", "", "if", "node", ".", "is_reference_node", ":", "\n", "                ", "if", "not", "node", ".", "referents", "or", "len", "(", "node", ".", "referents", ")", "==", "0", ":", "\n", "                    ", "node", ".", "is_refer_to_agent", "=", "True", "\n", "", "self", ".", "refer_nodes", ".", "append", "(", "node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.to_dict": [[242, 271], ["utils.DMR.from_dict._bfs"], "methods", ["None"], ["", "", "", "def", "to_dict", "(", "self", ",", "for_parsing", "=", "False", ")", ":", "\n", "        ", "def", "_bfs", "(", "n", ")", ":", "\n", "            ", "node_value", "=", "None", "\n", "if", "n", ".", "variable", ":", "\n", "                ", "if", "n", ".", "is_reference_node", ":", "\n", "                    ", "if", "not", "n", ".", "value", "or", "(", "for_parsing", "and", "n", ".", "is_refer_to_agent", ")", ":", "\n", "                        ", "node_value", "=", "f'{n.variable} / reference'", "\n", "", "else", ":", "\n", "                        ", "node_value", "=", "f'{n.variable} / reference || {n.value}'", "\n", "", "", "else", ":", "\n", "                    ", "if", "n", ".", "value", "and", "n", ".", "entity_type", ":", "\n", "                        ", "node_value", "=", "f'{n.variable} / {n.value} || {n.entity_type}'", "\n", "", "elif", "n", ".", "value", ":", "\n", "                        ", "node_value", "=", "f'{n.variable} / {n.value}'", "\n", "", "elif", "n", ".", "entity_type", ":", "\n", "                        ", "node_value", "=", "f'{n.variable} / {n.entity_type}'", "\n", "", "", "", "else", ":", "\n", "                ", "node_value", "=", "n", ".", "value", "\n", "", "if", "n", ".", "out_relations", ":", "\n", "                ", "value_dict", "=", "dict", "(", ")", "\n", "for", "r", "in", "n", ".", "out_relations", ":", "\n", "                    ", "if", "r", ".", "value", "==", "':refer'", "and", "for_parsing", ":", "\n", "                        ", "continue", "\n", "", "value_dict", "[", "r", ".", "value", "]", "=", "_bfs", "(", "r", ".", "tail_node", ")", "\n", "", "return", "{", "node_value", ":", "value_dict", "}", "\n", "", "else", ":", "\n", "                ", "return", "node_value", "\n", "\n", "", "", "return", "_bfs", "(", "self", ".", "root", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.to_triples": [[272, 281], ["utils.DMR.from_dict._bfs"], "methods", ["None"], ["", "def", "to_triples", "(", "self", ")", ":", "\n", "        ", "def", "_bfs", "(", "n", ")", ":", "\n", "            ", "triples", "=", "[", "]", "\n", "if", "n", ".", "out_relations", "and", "len", "(", "n", ".", "out_relations", ")", ">", "0", ":", "\n", "                ", "for", "r", "in", "n", ".", "out_relations", ":", "\n", "                    ", "triples", ".", "append", "(", "(", "n", ",", "r", ".", "value", ",", "r", ".", "tail_node", ")", ")", "\n", "triples", "+=", "_bfs", "(", "r", ".", "tail_node", ")", "\n", "", "", "return", "triples", "\n", "", "return", "_bfs", "(", "self", ".", "root", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.__init__": [[284, 289], ["json.load", "dict", "utils.GloVeTokenizer.tok_to_id.items", "open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "vocab_file", ")", ":", "\n", "        ", "self", ".", "tok_to_id", "=", "json", ".", "load", "(", "open", "(", "vocab_file", ")", ")", "\n", "self", ".", "id_to_tok", "=", "dict", "(", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "tok_to_id", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "id_to_tok", "[", "v", "]", "=", "k", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.tokenize": [[290, 293], ["x.strip().split", "x.strip"], "methods", ["None"], ["", "", "def", "tokenize", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "        ", "ret", "=", "x", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.eos_token_id": [[294, 297], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "eos_token_id", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tok_to_id", "[", "'</s>'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.bos_token_id": [[298, 301], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bos_token_id", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tok_to_id", "[", "'<s>'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.pad_token_id": [[302, 305], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "pad_token_id", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tok_to_id", "[", "'<pad>'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.convert_tokens_to_ids": [[306, 314], ["isinstance", "isinstance", "utils.GloVeTokenizer.convert_tokens_to_ids"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.convert_tokens_to_ids"], ["", "def", "convert_tokens_to_ids", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "isinstance", "(", "x", ",", "str", ")", ":", "\n", "            ", "if", "x", "not", "in", "self", ".", "tok_to_id", ":", "\n", "                ", "x", "=", "'<unk>'", "\n", "", "return", "self", ".", "tok_to_id", "[", "x", "]", "\n", "", "elif", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "            ", "ret", "=", "[", "self", ".", "convert_tokens_to_ids", "(", "e", ")", "for", "e", "in", "x", "]", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.convert_ids_to_tokens": [[315, 321], ["isinstance", "isinstance", "utils.GloVeTokenizer.convert_ids_to_tokens"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.convert_ids_to_tokens"], ["", "", "def", "convert_ids_to_tokens", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "isinstance", "(", "x", ",", "int", ")", ":", "\n", "            ", "return", "self", ".", "id_to_tok", "[", "x", "]", "\n", "", "elif", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "            ", "ret", "=", "[", "self", ".", "convert_ids_to_tokens", "(", "e", ")", "for", "e", "in", "x", "]", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.encode_plus": [[322, 324], ["torch.tensor"], "methods", ["None"], ["", "", "def", "encode_plus", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "x", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.pad": [[325, 337], ["torch.nn.utils.rnn.pad_sequence", "torch.nn.utils.rnn.pad_sequence", "collections.namedtuple", "collections.namedtuple.", "e.size", "torch.ones"], "methods", ["None"], ["", "def", "pad", "(", "self", ",", "inputs", ",", "**", "kwargs", ")", ":", "\n", "        ", "lengths", "=", "[", "e", ".", "size", "(", "-", "1", ")", "for", "e", "in", "inputs", "]", "\n", "\n", "attention_mask", "=", "[", "torch", ".", "ones", "(", "e", ",", "dtype", "=", "torch", ".", "long", ")", "for", "e", "in", "lengths", "]", "\n", "attention_mask", "=", "pad_sequence", "(", "attention_mask", ",", "padding_value", "=", "0", ",", "batch_first", "=", "True", ")", "\n", "\n", "padded", "=", "pad_sequence", "(", "inputs", ",", "batch_first", "=", "True", ")", "\n", "\n", "Padding", "=", "namedtuple", "(", "'Padding'", ",", "[", "'input_ids'", ",", "'attention_mask'", "]", ")", "\n", "\n", "padding", "=", "Padding", "(", "padded", ",", "attention_mask", ")", "\n", "return", "padding", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.batch_decode": [[338, 345], ["x.cpu().data.numpy().tolist.cpu().data.numpy().tolist.cpu().data.numpy().tolist", "utils.GloVeTokenizer.convert_ids_to_tokens", "x.cpu().data.numpy().tolist.cpu().data.numpy().tolist.cpu().data.numpy", "x.cpu().data.numpy().tolist.cpu().data.numpy().tolist.cpu"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.convert_ids_to_tokens"], ["", "def", "batch_decode", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "        ", "special_ids", "=", "[", "self", ".", "pad_token_id", ",", "self", ".", "bos_token_id", ",", "self", ".", "eos_token_id", "]", "\n", "x", "=", "x", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "x", "=", "[", "[", "i", "for", "i", "in", "e", "if", "i", "not", "in", "special_ids", "]", "for", "e", "in", "x", "]", "\n", "x", "=", "[", "self", ".", "convert_ids_to_tokens", "(", "e", ")", "for", "e", "in", "x", "]", "\n", "x", "=", "[", "' '", ".", "join", "(", "e", ")", "for", "e", "in", "x", "]", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.__len__": [[346, 348], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "tok_to_id", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_parsing.test": [[19, 78], ["print", "model.eval", "tqdm.tqdm", "eval.dmr_smatch.score_dmr_pairs", "len", "batch[].to", "batch[].to", "tokenizer.batch_decode", "dmr_parsing.dmr_parser.parse_dmr_line_to_dict", "zip", "sorted", "os.path.join", "json.dump", "print", "torch.no_grad", "model.generate", "s.replace().replace().split", "data_to_save.append", "open", "batch[].to", "s.replace().replace", "s.replace"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr_smatch.score_dmr_pairs", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.batch_decode", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.dmr_parser.parse_dmr_line_to_dict", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.model.Seq2Seq.generate"], ["def", "test", "(", "dl", ",", "segment", "=", "'test'", ",", "save_file", "=", "False", ")", ":", "\n", "    ", "print", "(", "'evaluating...'", ")", "\n", "model", ".", "eval", "(", ")", "\n", "sources", "=", "[", "]", "\n", "predictions", "=", "[", "]", "\n", "targets", "=", "[", "]", "\n", "annotations", "=", "[", "]", "\n", "utterance_ids", "=", "[", "]", "\n", "for", "batch", "in", "tqdm", "(", "dl", ")", ":", "\n", "        ", "input_ids", "=", "batch", "[", "'input_ids'", "]", ".", "to", "(", "device", ")", "\n", "attention_mask", "=", "batch", "[", "'attention_mask'", "]", ".", "to", "(", "device", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "outputs", "=", "model", ".", "generate", "(", "\n", "input_ids", "=", "input_ids", ",", "\n", "attention_mask", "=", "attention_mask", ",", "\n", "logits_mask", "=", "batch", "[", "'logits_masks'", "]", ".", "to", "(", "device", ")", "\n", ")", "\n", "\n", "", "predictions", "+=", "tokenizer", ".", "batch_decode", "(", "outputs", ",", "skip_special_tokens", "=", "True", ",", "clean_up_tokenization_spaces", "=", "False", ")", "\n", "targets", "+=", "batch", "[", "'targets'", "]", "\n", "annotations", "+=", "batch", "[", "'annotations'", "]", "\n", "sources", "+=", "batch", "[", "'source'", "]", "\n", "utterance_ids", "+=", "batch", "[", "'utteranceId'", "]", "\n", "\n", "", "predictions", "=", "[", "' '", ".", "join", "(", "s", ".", "replace", "(", "'<<'", ",", "''", ")", ".", "replace", "(", "'>>'", ",", "''", ")", ".", "split", "(", ")", ")", "for", "s", "in", "predictions", "]", "\n", "predicted_dmrs", "=", "[", "parse_dmr_line_to_dict", "(", "s", ")", "for", "s", "in", "predictions", "]", "\n", "\n", "_", ",", "smatch_scores", "=", "score_dmr_pairs", "(", "[", "p", "[", "0", "]", "for", "p", "in", "predicted_dmrs", "]", ",", "annotations", ")", "\n", "em", "=", "0", "\n", "for", "_", ",", "_", ",", "f1", "in", "smatch_scores", ":", "\n", "        ", "if", "f1", "==", "1.0", ":", "\n", "            ", "em", "+=", "1", "\n", "", "", "em", "/=", "len", "(", "smatch_scores", ")", "\n", "\n", "if", "save_file", ":", "\n", "        ", "pkg", "=", "zip", "(", "smatch_scores", ",", "utterance_ids", ",", "sources", ",", "predictions", ",", "predicted_dmrs", ",", "annotations", ")", "\n", "pkg", "=", "sorted", "(", "pkg", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", "[", "-", "1", "]", ")", "\n", "\n", "data_to_save", "=", "[", "]", "\n", "for", "(", "p", ",", "r", ",", "f1", ")", ",", "ut_id", ",", "source", ",", "pred", ",", "(", "dmr", ",", "is_valid", ")", ",", "anno", "in", "pkg", ":", "\n", "            ", "d", "=", "{", "\n", "'utteranceId'", ":", "ut_id", ",", "\n", "'source'", ":", "source", ",", "\n", "'predicted_seq'", ":", "pred", ",", "\n", "'predicted_dmr'", ":", "dmr", ",", "\n", "'is_valid_graph'", ":", "is_valid", ",", "\n", "'annotation'", ":", "anno", ",", "\n", "'precision'", ":", "p", ",", "\n", "'recall'", ":", "r", ",", "\n", "'f1'", ":", "f1", "\n", "}", "\n", "data_to_save", ".", "append", "(", "d", ")", "\n", "\n", "", "filename", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "f'{segment}_{prediction_file}'", ")", "\n", "json", ".", "dump", "(", "data_to_save", ",", "open", "(", "filename", ",", "'w'", ")", ",", "indent", "=", "4", ")", "\n", "\n", "print", "(", "f'saved to {filename}'", ")", "\n", "\n", "", "return", "em", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_parsing.train": [[80, 124], ["torch.optim.Adam", "torch.nn.CrossEntropyLoss", "range", "model.load_state_dict", "run_parsing.test", "run_parsing.test", "print", "print", "print", "print", "model.parameters", "model.train", "tqdm.tqdm", "run_parsing.test", "print", "print", "torch.load", "batch[].to", "batch[].to().unsqueeze", "model.forward", "torch.nn.CrossEntropyLoss.", "torch.optim.Adam.zero_grad", "loss_fn.backward", "torch.optim.Adam.step", "tqdm.tqdm.set_description", "tqdm.tqdm.refresh", "torch.save", "print", "model.forward.reshape", "batch[].to.reshape", "model.state_dict", "batch[].to", "batch[].to", "batch[].to", "batch[].to", "loss_fn.item"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_parsing.test", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_parsing.test", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_parsing.train", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.run_parsing.test", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.model.MLPCorefModel.forward"], ["", "def", "train", "(", ")", ":", "\n", "    ", "optimizer", "=", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ")", "\n", "loss_fn", "=", "CrossEntropyLoss", "(", "ignore_index", "=", "tokenizer", ".", "pad_token_id", ")", "\n", "\n", "dev_best_em", "=", "0.", "\n", "step", "=", "0", "\n", "for", "epoch", "in", "range", "(", "args", ".", "epoch", ")", ":", "\n", "        ", "model", ".", "train", "(", ")", "\n", "bar", "=", "tqdm", "(", "train_dl", ")", "\n", "for", "batch", "in", "bar", ":", "\n", "            ", "step", "+=", "1", "\n", "labels", "=", "batch", "[", "'decoder_output_ids'", "]", ".", "to", "(", "device", ")", "\n", "logits_mask", "=", "batch", "[", "'logits_masks'", "]", ".", "to", "(", "device", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "logits", "=", "model", ".", "forward", "(", "\n", "input_ids", "=", "batch", "[", "'input_ids'", "]", ".", "to", "(", "device", ")", ",", "\n", "attention_mask", "=", "batch", "[", "'attention_mask'", "]", ".", "to", "(", "device", ")", ",", "\n", "decoder_input_ids", "=", "batch", "[", "'decoder_input_ids'", "]", ".", "to", "(", "device", ")", ",", "\n", "logits_mask", "=", "logits_mask", ",", "\n", ")", "\n", "\n", "loss", "=", "loss_fn", "(", "logits", ".", "reshape", "(", "-", "1", ",", "logits", ".", "shape", "[", "-", "1", "]", ")", ",", "labels", ".", "reshape", "(", "-", "1", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "bar", ".", "set_description", "(", "f'loss: {loss.item()}'", ")", "\n", "bar", ".", "refresh", "(", ")", "\n", "\n", "", "dev_em", "=", "test", "(", "dev_dl", ")", "\n", "print", "(", "f'Epoch {epoch}, Dev EM : {dev_em}'", ")", "\n", "if", "dev_em", ">", "dev_best_em", ":", "\n", "            ", "dev_best_em", "=", "dev_em", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "ckpt_file", ")", "\n", "print", "(", "f'Model saved to {ckpt_file}'", ")", "\n", "", "print", "(", "f'So far, dev best EM: {dev_best_em}'", ")", "\n", "\n", "", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "ckpt_file", ")", ")", "\n", "test_em", "=", "test", "(", "test_dl", ",", "'test'", ",", "save_file", "=", "True", ")", "\n", "dev_em", "=", "test", "(", "dev_dl", ",", "'dev'", ",", "save_file", "=", "True", ")", "\n", "print", "(", "'================================================'", ")", "\n", "print", "(", "f'Test set EM: {test_em}'", ")", "\n", "print", "(", "f'Dev set EM: {dev_em}'", ")", "\n", "print", "(", "'================================================'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.add_tokens": [[10, 21], ["range", "sorted", "tokenizer.add_tokens", "len", "sorted.append", "tokenizer.convert_tokens_to_ids", "len"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.add_tokens", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.convert_tokens_to_ids"], ["def", "add_tokens", "(", "tokenizer", ",", "tokens", ")", ":", "\n", "    ", "tokens_to_add", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "tokens", ")", ")", ":", "\n", "        ", "tokens_to_add", ".", "append", "(", "'<<'", "+", "tokens", "[", "i", "]", "+", "'>>'", ")", "\n", "", "for", "tok", "in", "tokens_to_add", ":", "\n", "        ", "assert", "tokenizer", ".", "convert_tokens_to_ids", "(", "[", "tok", "]", ")", "[", "0", "]", "==", "tokenizer", ".", "unk_token_id", "\n", "", "tokens_to_add", "=", "sorted", "(", "tokens_to_add", ",", "key", "=", "lambda", "x", ":", "len", "(", "x", ")", ",", "reverse", "=", "True", ")", "\n", "unique_no_split_tokens", "=", "tokenizer", ".", "unique_no_split_tokens", "\n", "tokenizer", ".", "unique_no_split_tokens", "=", "unique_no_split_tokens", "+", "tokens_to_add", "\n", "tokenizer", ".", "add_tokens", "(", "tokens_to_add", ")", "\n", "return", "tokenizer", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils._map_variable_to_value": [[23, 44], ["isinstance", "dmr.items", "re.match", "re.match", "re.fullmatch", "data_utils._map_variable_to_value", "data_utils._map_variable_to_value", "data_utils._map_variable_to_value", "re.match.span", "re.match.span", "re.match.span"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils._map_variable_to_value", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils._map_variable_to_value", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils._map_variable_to_value"], ["", "def", "_map_variable_to_value", "(", "dmr", ",", "var2val", ",", "is_node", "=", "True", ")", ":", "\n", "    ", "if", "isinstance", "(", "dmr", ",", "str", ")", ":", "\n", "        ", "if", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "dmr", ")", "and", "not", "re", ".", "fullmatch", "(", "r'v[\\d]+'", ",", "dmr", ")", ":", "\n", "            ", "m", "=", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "dmr", ")", "\n", "var", "=", "dmr", "[", "m", ".", "span", "(", ")", "[", "0", "]", ":", "m", ".", "span", "(", ")", "[", "1", "]", "-", "3", "]", "\n", "val", "=", "dmr", "[", "m", ".", "span", "(", ")", "[", "1", "]", ":", "]", "\n", "# if '#refer T:' in val:", "\n", "#     # If there are no referred nodes (only referred turn number), this is referred to the agent's turn,", "\n", "#     # For this case, remove the referred surface form", "\n", "#     if 'N:c' not in val:", "\n", "#         val = '#refer'", "\n", "#     else:", "\n", "#         val = re.split(r' T:', val)[0]", "\n", "var2val", "[", "var", "]", "=", "val", "\n", "", "", "else", ":", "\n", "        ", "for", "k", ",", "v", "in", "dmr", ".", "items", "(", ")", ":", "\n", "            ", "if", "is_node", ":", "\n", "                ", "_map_variable_to_value", "(", "k", ",", "var2val", ",", "True", ")", "\n", "_map_variable_to_value", "(", "v", ",", "var2val", ",", "False", ")", "\n", "", "else", ":", "\n", "                ", "_map_variable_to_value", "(", "v", ",", "var2val", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.linearize_dmr": [[46, 91], ["isinstance", "str_.strip", "dict", "data_utils._map_variable_to_value", "isinstance", "re.fullmatch", "sorted", "RuntimeError", "re.match", "value.keys", "re.fullmatch", "re.match", "re.match", "re.match", "data_utils.linearize_dmr", "data_utils.linearize_dmr", "re.match.span", "re.match.span", "re.match.span", "re.match.span"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils._map_variable_to_value", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.linearize_dmr", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.linearize_dmr"], ["", "", "", "", "def", "linearize_dmr", "(", "value", ",", "is_root", "=", "True", ",", "var2val", "=", "None", ")", ":", "\n", "    ", "if", "not", "var2val", ":", "\n", "        ", "var2val", "=", "dict", "(", ")", "\n", "_map_variable_to_value", "(", "value", ",", "var2val", ")", "\n", "\n", "", "str_", "=", "''", "\n", "if", "isinstance", "(", "value", ",", "str", ")", ":", "\n", "        ", "if", "is_root", ":", "\n", "            ", "str_", "=", "'( '", "+", "value", "+", "' )'", "\n", "", "else", ":", "\n", "            ", "if", "re", ".", "fullmatch", "(", "r'v[\\d]+'", ",", "value", ")", ":", "\n", "                ", "str_", "=", "var2val", "[", "value", "]", "\n", "", "elif", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "value", ")", ":", "\n", "                ", "m", "=", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "value", ")", "\n", "var", "=", "value", "[", "m", ".", "span", "(", ")", "[", "0", "]", ":", "m", ".", "span", "(", ")", "[", "1", "]", "-", "3", "]", "\n", "str_", "=", "var2val", "[", "var", "]", "\n", "", "elif", "'-'", "==", "value", ":", "\n", "                ", "str_", "=", "'#-'", "\n", "", "else", ":", "\n", "                ", "str_", "=", "value", "\n", "", "", "", "elif", "isinstance", "(", "value", ",", "dict", ")", ":", "\n", "        ", "keys", "=", "sorted", "(", "value", ".", "keys", "(", ")", ")", "\n", "# is_op = False", "\n", "# if ':op1' in keys:", "\n", "#     keys = sorted(keys, key=lambda k: int(k[3:]))", "\n", "#     is_op = True", "\n", "for", "key", "in", "keys", ":", "\n", "            ", "if", "re", ".", "fullmatch", "(", "r'v[\\d]+'", ",", "key", ")", ":", "\n", "                ", "_key", "=", "var2val", "[", "key", "]", "\n", "", "elif", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "key", ")", ":", "\n", "                ", "m", "=", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "key", ")", "\n", "var", "=", "key", "[", "m", ".", "span", "(", ")", "[", "0", "]", ":", "m", ".", "span", "(", ")", "[", "1", "]", "-", "3", "]", "\n", "_key", "=", "var2val", "[", "var", "]", "\n", "", "else", ":", "\n", "                ", "_key", "=", "key", "\n", "\n", "", "if", "_key", "==", "'and'", ":", "\n", "                ", "str_", "+=", "' ( #and'", "+", "' '", "+", "linearize_dmr", "(", "value", "[", "key", "]", ",", "False", ",", "var2val", ")", "+", "' )'", "\n", "# elif is_op:", "\n", "#     str_ += ' [ :op' + ' ' + linearize_dmr(value[key], False, var2val) + ' ]'", "\n", "", "else", ":", "\n", "                ", "str_", "+=", "' ( '", "+", "_key", "+", "' '", "+", "linearize_dmr", "(", "value", "[", "key", "]", ",", "False", ",", "var2val", ")", "+", "' )'", "\n", "", "", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", ")", "\n", "", "return", "str_", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.generate_examples": [[93, 160], ["enumerate", "data_utils.linearize_dmr", "target.split.split", "range", "re.sub", "re.sub", "set", "set.add", "set.add", "data_utils.tokenize", "tokenizer.encode_plus", "tokenizer.encode_plus", "tokenizer.encode_plus", "examples.append", "str", "utils.DMR.from_dict().to_dict", "len", "re.sub.split", "data_utils.tokenize", "data_utils.tokenize", "utils.DMR.from_dict", "utils.ff_schema_tokens"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.linearize_dmr", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.tokenize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.encode_plus", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.encode_plus", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.encode_plus", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.to_dict", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.tokenize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.tokenize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.from_dict"], ["", "def", "generate_examples", "(", "dialog", ",", "\n", "tokenizer", ",", "\n", "schema_tokens", ",", "\n", "context_size", "=", "0", ",", "\n", "add_role", "=", "False", ")", ":", "\n", "    ", "assert", "context_size", ">=", "0", "\n", "\n", "examples", "=", "[", "]", "\n", "turns", "=", "dialog", "[", "'turns'", "]", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "turns", ")", ":", "\n", "        ", "if", "'annotation'", "in", "t", ":", "\n", "            ", "if", "'eval_nlu'", "in", "t", "and", "not", "t", "[", "'eval_nlu'", "]", ":", "\n", "                ", "continue", "\n", "", "if", "'do_train'", "in", "t", "and", "not", "t", "[", "'do_train'", "]", ":", "\n", "                ", "continue", "\n", "", "anno", "=", "t", "[", "'annotation'", "]", "\n", "if", "\"reference\"", "in", "str", "(", "anno", ")", ":", "\n", "                ", "anno", "=", "DMR", ".", "from_dict", "(", "anno", ")", ".", "to_dict", "(", "for_parsing", "=", "True", ")", "\n", "", "target", "=", "linearize_dmr", "(", "anno", ")", "\n", "target", "=", "target", ".", "split", "(", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "target", ")", ")", ":", "\n", "                ", "if", "target", "[", "j", "]", "in", "schema_tokens", ":", "\n", "                    ", "target", "[", "j", "]", "=", "'<<'", "+", "target", "[", "j", "]", "+", "'>>'", "\n", "", "", "target", "=", "' '", ".", "join", "(", "target", ")", "\n", "\n", "start_turn", "=", "i", "-", "context_size", "\n", "if", "start_turn", "<", "0", ":", "\n", "                ", "start_turn", "=", "0", "\n", "", "context", "=", "turns", "[", "start_turn", ":", "i", "]", "\n", "source", "=", "''", "\n", "for", "_t", "in", "context", ":", "\n", "                ", "if", "add_role", ":", "\n", "                    ", "source", "+=", "f'{_t[\"authorRole\"]} : '", "+", "_t", "[", "'tokenized_content'", "]", "+", "' '", "\n", "", "else", ":", "\n", "                    ", "source", "+=", "_t", "[", "'tokenized_content'", "]", "+", "' '", "\n", "", "", "if", "add_role", "and", "context_size", ">", "0", ":", "\n", "                ", "source", "+=", "f'{t[\"authorRole\"]} : '", "+", "t", "[", "'tokenized_content'", "]", "\n", "", "else", ":", "\n", "                ", "source", "+=", "t", "[", "'tokenized_content'", "]", "\n", "", "source", "=", "' '", ".", "join", "(", "source", ".", "split", "(", ")", ")", "\n", "source", "=", "re", ".", "sub", "(", "r'http\\S+'", ",", "'<url>'", ",", "source", ")", "\n", "source", "=", "re", ".", "sub", "(", "r'www.\\S+'", ",", "'<url>'", ",", "source", ")", "\n", "\n", "good_words_ids", "=", "set", "(", "tokenize", "(", "tokenizer", ",", "t", "[", "'tokenized_content'", "]", ")", ")", "\n", "good_words_ids", ".", "add", "(", "tokenizer", ".", "eos_token_id", ")", "\n", "good_words_ids", ".", "add", "(", "tokenizer", ".", "bos_token_id", ")", "\n", "\n", "label", "=", "tokenize", "(", "tokenizer", ",", "target", ")", "\n", "\n", "decoder_input_ids", "=", "[", "tokenizer", ".", "bos_token_id", "]", "+", "label", "\n", "decoder_output_ids", "=", "label", "+", "[", "tokenizer", ".", "eos_token_id", "]", "\n", "\n", "encoded_input_ids", "=", "tokenizer", ".", "encode_plus", "(", "tokenize", "(", "tokenizer", ",", "source", ")", ",", "add_special_tokens", "=", "False", ")", "\n", "encoded_decoder_input_ids", "=", "tokenizer", ".", "encode_plus", "(", "decoder_input_ids", ",", "add_special_tokens", "=", "False", ")", "\n", "encoded_decoder_output_ids", "=", "tokenizer", ".", "encode_plus", "(", "decoder_output_ids", ",", "add_special_tokens", "=", "False", ")", "\n", "\n", "examples", ".", "append", "(", "{", "\n", "'source'", ":", "source", ",", "\n", "'encoded_input_ids'", ":", "encoded_input_ids", ",", "\n", "'target'", ":", "target", ",", "\n", "'annotation'", ":", "anno", ",", "\n", "'good_words_ids'", ":", "good_words_ids", ",", "\n", "'utteranceId'", ":", "t", "[", "'utteranceId'", "]", ",", "\n", "'encoded_decoder_input_ids'", ":", "encoded_decoder_input_ids", ",", "\n", "'encoded_decoder_output_ids'", ":", "encoded_decoder_output_ids", "\n", "}", ")", "\n", "", "", "return", "examples", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.tokenize": [[162, 170], ["isinstance", "tokenizer.convert_tokens_to_ids", "s.split.split", "tokenizer.tokenize"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.convert_tokens_to_ids", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.tokenize"], ["", "def", "tokenize", "(", "tokenizer", ",", "s", ")", ":", "\n", "    ", "ret", "=", "[", "]", "\n", "if", "isinstance", "(", "s", ",", "str", ")", ":", "\n", "        ", "s", "=", "s", ".", "split", "(", ")", "\n", "", "for", "tok", "in", "s", ":", "\n", "        ", "ret", "+=", "tokenizer", ".", "tokenize", "(", "tok", ",", "add_prefix_space", "=", "True", ")", "\n", "", "ret", "=", "tokenizer", ".", "convert_tokens_to_ids", "(", "ret", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.dataloader": [[172, 228], ["json.load", "print", "set", "torch.utils.data.DataLoader", "open", "data_utils.generate_examples", "set.add", "tokenizer.pad", "torch.tensor", "tokenizer.convert_tokens_to_ids", "good_words_id.union.union", "list", "numpy.zeros", "torch.tensor.append", "tokenizer.pad", "tokenizer.pad", "len", "len", "set", "list", "range", "len"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.data_utils.generate_examples", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.pad", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.convert_tokens_to_ids", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.pad", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.GloVeTokenizer.pad"], ["", "def", "dataloader", "(", "segment", ",", "\n", "batch_size", ",", "\n", "tokenizer", ",", "\n", "shuffle", "=", "False", ",", "\n", "context_size", "=", "0", ",", "\n", "add_role", "=", "False", ",", "\n", "num_workers", "=", "0", ")", ":", "\n", "    ", "dialogs", "=", "json", ".", "load", "(", "open", "(", "f'../dataset/dmr-fastfood/{segment}.json'", ")", ")", "\n", "\n", "examples", "=", "[", "]", "\n", "for", "d", "in", "dialogs", ":", "\n", "        ", "examples", "+=", "generate_examples", "(", "d", ",", "tokenizer", ",", "ff_schema_tokens", ",", "context_size", ",", "add_role", ")", "\n", "\n", "", "print", "(", "f'{segment} set contains {len(examples)} examples'", ")", "\n", "\n", "schema_token_ids", "=", "set", "(", ")", "\n", "for", "tok", "in", "ff_schema_tokens", ":", "\n", "        ", "schema_token_ids", ".", "add", "(", "tokenizer", ".", "convert_tokens_to_ids", "(", "'<<'", "+", "tok", "+", "'>>'", ")", ")", "\n", "\n", "", "def", "_collate_fn", "(", "batch", ")", ":", "\n", "        ", "logits_masks", "=", "[", "]", "\n", "for", "ex", "in", "batch", ":", "\n", "            ", "good_words_id", "=", "ex", "[", "'good_words_ids'", "]", "\n", "good_words_id", "=", "good_words_id", ".", "union", "(", "schema_token_ids", ")", "\n", "bad_words_id", "=", "list", "(", "set", "(", "range", "(", "len", "(", "tokenizer", ")", ")", ")", "-", "good_words_id", ")", "\n", "\n", "logits_mask", "=", "np", ".", "zeros", "(", "len", "(", "tokenizer", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "logits_mask", "[", "list", "(", "bad_words_id", ")", "]", "=", "True", "\n", "logits_masks", ".", "append", "(", "logits_mask", ")", "\n", "\n", "", "sources_", "=", "tokenizer", ".", "pad", "(", "[", "ex", "[", "'encoded_input_ids'", "]", "for", "ex", "in", "batch", "]", ",", "return_tensors", "=", "'pt'", ",", "padding", "=", "True", ")", "\n", "input_ids", ",", "attention_mask", "=", "sources_", ".", "input_ids", ",", "sources_", ".", "attention_mask", "\n", "\n", "decoder_input_ids", "=", "tokenizer", ".", "pad", "(", "[", "ex", "[", "'encoded_decoder_input_ids'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "return_tensors", "=", "'pt'", ",", "\n", "padding", "=", "True", ")", ".", "input_ids", "\n", "decoder_output_ids", "=", "tokenizer", ".", "pad", "(", "[", "ex", "[", "'encoded_decoder_output_ids'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "return_tensors", "=", "'pt'", ",", "\n", "padding", "=", "True", ")", ".", "input_ids", "\n", "\n", "logits_masks", "=", "torch", ".", "tensor", "(", "logits_masks", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "\n", "return", "{", "\n", "'source'", ":", "[", "ex", "[", "'source'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "'input_ids'", ":", "input_ids", ",", "\n", "'attention_mask'", ":", "attention_mask", ",", "\n", "'decoder_input_ids'", ":", "decoder_input_ids", ",", "\n", "'decoder_output_ids'", ":", "decoder_output_ids", ",", "\n", "'targets'", ":", "[", "ex", "[", "'target'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "'annotations'", ":", "[", "ex", "[", "'annotation'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "'logits_masks'", ":", "logits_masks", ",", "\n", "'utteranceId'", ":", "[", "ex", "[", "'utteranceId'", "]", "for", "ex", "in", "batch", "]", "\n", "}", "\n", "\n", "", "dl", "=", "DataLoader", "(", "examples", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "shuffle", ",", "collate_fn", "=", "_collate_fn", ",", "num_workers", "=", "num_workers", ")", "\n", "return", "dl", "", "", ""]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.dmr_parser.assign_var": [[4, 34], ["dmr_parser.assign_var._bfs"], "function", ["None"], ["def", "assign_var", "(", "g", ")", ":", "\n", "    ", "global", "var_idx", "\n", "var_idx", "=", "1", "\n", "\n", "def", "_bfs", "(", "g", ",", "is_node", "=", "True", ",", "node_incoming_edge", "=", "None", ")", ":", "\n", "        ", "global", "var_idx", "\n", "if", "isinstance", "(", "g", ",", "str", ")", ":", "\n", "            ", "if", "g", "==", "'#and'", ":", "\n", "                ", "g", "=", "f'v{var_idx} / and'", "\n", "var_idx", "+=", "1", "\n", "return", "g", "\n", "", "elif", "g", "==", "'#-'", ":", "\n", "                ", "return", "'-'", "\n", "", "else", ":", "\n", "                ", "g", "=", "f'v{var_idx} / {g}'", "\n", "var_idx", "+=", "1", "\n", "return", "g", "\n", "", "", "else", ":", "\n", "            ", "new_g", "=", "dict", "(", ")", "\n", "for", "k", ",", "v", "in", "g", ".", "items", "(", ")", ":", "\n", "                ", "if", "is_node", ":", "\n", "                    ", "new_k", "=", "_bfs", "(", "k", ",", "True", ",", "node_incoming_edge", ")", "\n", "new_v", "=", "_bfs", "(", "v", ",", "not", "is_node", ")", "\n", "", "else", ":", "\n", "                    ", "new_k", "=", "k", "\n", "new_v", "=", "_bfs", "(", "v", ",", "not", "is_node", ",", "k", ")", "\n", "", "new_g", "[", "new_k", "]", "=", "new_v", "\n", "", "return", "new_g", "\n", "", "", "g", "=", "_bfs", "(", "g", ")", "\n", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.dmr_parser._cleanup_dmr_string": [[36, 58], ["s[].split.index", "s[].split", "len", "len"], "function", ["None"], ["", "def", "_cleanup_dmr_string", "(", "s", ")", ":", "\n", "    ", "if", "'('", "not", "in", "s", ":", "\n", "        ", "return", "[", "]", "\n", "", "start_idx", "=", "s", ".", "index", "(", "'('", ")", "\n", "s", "=", "s", "[", "start_idx", ":", "]", ".", "split", "(", ")", "\n", "\n", "# add missing ']', or remove redundant ']'", "\n", "left_cnt", "=", "0", "\n", "i", "=", "0", "\n", "while", "i", "<", "len", "(", "s", ")", ":", "\n", "        ", "if", "s", "[", "i", "]", "==", "'('", ":", "\n", "            ", "left_cnt", "+=", "1", "\n", "", "elif", "s", "[", "i", "]", "==", "')'", ":", "\n", "            ", "left_cnt", "-=", "1", "\n", "", "if", "left_cnt", "==", "0", ":", "\n", "            ", "break", "\n", "", "i", "+=", "1", "\n", "", "if", "i", "<", "len", "(", "s", ")", ":", "\n", "        ", "s", "=", "s", "[", ":", "i", "+", "1", "]", "\n", "", "if", "left_cnt", ">", "0", ":", "\n", "        ", "s", "+=", "[", "')'", "]", "*", "left_cnt", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.dmr_parser._parse": [[60, 143], ["enumerate", "key_stack.append", "value_stack.append", "key_stack.pop", "len", "value_stack.pop", "len", "key_stack.append", "value_stack.append", "len", "len", "len", "value_stack[].append", "len", "value_stack.pop", "len", "value_stack[].append", "len", "dict", "value_stack.pop", "isinstance", "len", "len", "_v.items", "len", "value_stack[].append", "len"], "function", ["None"], ["", "def", "_parse", "(", "s", ")", ":", "\n", "# shift-reduce parsing", "\n", "    ", "start_state", "=", "0", "\n", "right_bracket_state", "=", "0", "\n", "left_bracket_state", "=", "1", "\n", "relation_state", "=", "2", "\n", "value_state", "=", "3", "\n", "\n", "state", "=", "start_state", "\n", "\n", "cur_key", "=", "''", "\n", "cur_value", "=", "''", "\n", "\n", "key_stack", "=", "[", "]", "\n", "value_stack", "=", "[", "]", "\n", "\n", "for", "i", ",", "tok", "in", "enumerate", "(", "s", ")", ":", "\n", "        ", "if", "tok", "==", "'('", ":", "\n", "            ", "if", "state", "==", "value_state", ":", "\n", "                ", "key_stack", ".", "append", "(", "cur_key", ")", "\n", "value_stack", ".", "append", "(", "[", "]", ")", "\n", "cur_key", "=", "''", "\n", "", "state", "=", "left_bracket_state", "\n", "", "elif", "tok", "==", "')'", ":", "\n", "            ", "if", "len", "(", "key_stack", ")", "==", "0", ":", "\n", "                ", "if", "len", "(", "cur_key", ")", ">", "0", ":", "\n", "                    ", "return", "cur_key", "\n", "", "if", "len", "(", "cur_value", ")", ">", "0", ":", "\n", "                    ", "return", "cur_value", "\n", "", "return", "None", "\n", "\n", "", "top_key", "=", "key_stack", ".", "pop", "(", ")", "\n", "if", "state", "==", "value_state", ":", "\n", "                ", "value_stack", ".", "pop", "(", ")", "\n", "if", "len", "(", "value_stack", ")", ">", "0", ":", "\n", "                    ", "value_stack", "[", "-", "1", "]", ".", "append", "(", "{", "top_key", ":", "cur_value", "}", ")", "\n", "", "else", ":", "\n", "                    ", "return", "{", "top_key", ":", "cur_value", "}", "\n", "", "", "else", ":", "\n", "                ", "if", "len", "(", "value_stack", "[", "-", "1", "]", ")", "==", "1", ":", "\n", "                    ", "v", "=", "value_stack", ".", "pop", "(", ")", "\n", "if", "len", "(", "value_stack", ")", ">", "0", ":", "\n", "                        ", "value_stack", "[", "-", "1", "]", ".", "append", "(", "{", "top_key", ":", "v", "[", "0", "]", "}", ")", "\n", "", "else", ":", "\n", "                        ", "return", "{", "top_key", ":", "v", "[", "0", "]", "}", "\n", "", "", "elif", "len", "(", "value_stack", "[", "-", "1", "]", ")", ">", "1", ":", "\n", "                    ", "merged_v", "=", "dict", "(", ")", "\n", "top_values", "=", "value_stack", ".", "pop", "(", ")", "\n", "for", "_v", "in", "top_values", ":", "\n", "                        ", "if", "isinstance", "(", "_v", ",", "dict", ")", ":", "\n", "                            ", "for", "k", ",", "v", "in", "_v", ".", "items", "(", ")", ":", "\n", "                                ", "merged_v", "[", "k", "]", "=", "v", "\n", "", "", "", "if", "len", "(", "merged_v", ")", ">", "0", ":", "\n", "                        ", "if", "len", "(", "value_stack", ")", ">", "0", ":", "\n", "                            ", "value_stack", "[", "-", "1", "]", ".", "append", "(", "{", "top_key", ":", "merged_v", "}", ")", "\n", "", "else", ":", "\n", "                            ", "return", "{", "top_key", ":", "merged_v", "}", "\n", "\n", "", "", "", "", "if", "len", "(", "key_stack", ")", "==", "0", ":", "\n", "                ", "return", "top_key", "\n", "\n", "", "state", "=", "right_bracket_state", "\n", "", "elif", "tok", "[", "0", "]", "==", "':'", "and", "tok", "in", "ff_schema_tokens", ":", "\n", "            ", "if", "state", "!=", "left_bracket_state", ":", "\n", "                ", "return", "None", "\n", "", "key_stack", ".", "append", "(", "tok", ")", "\n", "value_stack", ".", "append", "(", "[", "]", ")", "\n", "state", "=", "relation_state", "\n", "", "else", ":", "\n", "            ", "if", "state", "==", "left_bracket_state", ":", "\n", "                ", "cur_key", "=", "tok", "\n", "", "elif", "state", "==", "value_state", ":", "\n", "                ", "if", "len", "(", "cur_key", ")", ">", "0", ":", "\n", "                    ", "cur_key", "+=", "' '", "+", "tok", "\n", "", "elif", "len", "(", "cur_value", ")", ">", "0", ":", "\n", "                    ", "cur_value", "+=", "' '", "+", "tok", "\n", "", "", "elif", "state", "==", "relation_state", ":", "\n", "                ", "cur_value", "=", "tok", "\n", "", "else", ":", "\n", "                ", "return", "None", "\n", "", "state", "=", "value_state", "\n", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.dmr_parser.parse_dmr_line_to_dict": [[145, 157], ["dmr_parser._cleanup_dmr_string", "dmr_parser._parse", "isinstance", "dmr_parser.assign_var"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.dmr_parser._cleanup_dmr_string", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.dmr_parser._parse", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.dmr_parser.assign_var"], ["", "def", "parse_dmr_line_to_dict", "(", "dmr_line", ",", "default_value", "=", "'OutOfDomainIntent'", ")", ":", "\n", "    ", "dmr_line", "=", "_cleanup_dmr_string", "(", "dmr_line", ")", "\n", "dmr_wo_var", "=", "_parse", "(", "dmr_line", ")", "\n", "is_valid", "=", "True", "\n", "if", "not", "dmr_wo_var", ":", "\n", "        ", "dmr_wo_var", "=", "default_value", "\n", "is_valid", "=", "False", "\n", "", "if", "isinstance", "(", "dmr_wo_var", ",", "dict", ")", ":", "\n", "        ", "dmr", "=", "assign_var", "(", "dmr_wo_var", ")", "\n", "", "else", ":", "\n", "        ", "dmr", "=", "dmr_wo_var", "\n", "", "return", "dmr", ",", "is_valid", "", "", ""]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.model.Seq2Seq.__init__": [[13, 50], ["torch.nn.Module.__init__", "torch.nn.Embedding", "torch.nn.Parameter", "torch.nn.LSTM", "torch.nn.LSTM", "torch.nn.Linear", "model.Seq2Seq.args.model.startswith", "len", "torch.from_numpy", "len", "transformers.RobertaModel.from_pretrained", "transformers.RobertaModel.from_pretrained.resize_token_embeddings", "transformers.RobertaConfig", "transformers.RobertaForCausalLM", "transformers.RobertaForCausalLM.resize_token_embeddings", "transformers.EncoderDecoderModel", "model.Seq2Seq.args.model.startswith", "len", "len", "transformers.BartForConditionalGeneration.from_pretrained", "model.Seq2Seq.transformer.resize_token_embeddings", "len"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.__init__"], ["    ", "def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "super", "(", "Seq2Seq", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "args", "=", "args", "\n", "if", "self", ".", "args", ".", "model", "==", "'lstm'", ":", "\n", "            ", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "len", "(", "args", ".", "tokenizer", ")", ",", "300", ")", "\n", "self", ".", "embedding", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "from_numpy", "(", "args", ".", "glove_embed", ")", ")", "\n", "self", ".", "encoder", "=", "nn", ".", "LSTM", "(", "\n", "input_size", "=", "300", ",", "\n", "hidden_size", "=", "512", ",", "\n", "num_layers", "=", "2", ",", "\n", "bidirectional", "=", "True", ",", "\n", "batch_first", "=", "True", ",", "\n", "dropout", "=", "0.1", "\n", ")", "\n", "self", ".", "decoder", "=", "nn", ".", "LSTM", "(", "\n", "input_size", "=", "300", ",", "\n", "hidden_size", "=", "512", ",", "\n", "num_layers", "=", "2", ",", "\n", "bidirectional", "=", "False", ",", "\n", "batch_first", "=", "True", ",", "\n", "dropout", "=", "0.1", "\n", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "512", ",", "len", "(", "args", ".", "tokenizer", ")", ")", "\n", "", "elif", "self", ".", "args", ".", "model", ".", "startswith", "(", "'roberta'", ")", ":", "\n", "            ", "encoder", "=", "RobertaModel", ".", "from_pretrained", "(", "self", ".", "args", ".", "model", ")", "\n", "encoder", ".", "resize_token_embeddings", "(", "len", "(", "args", ".", "tokenizer", ")", ")", "\n", "decoder_config", "=", "RobertaConfig", "(", "hidden_size", "=", "encoder", ".", "config", ".", "hidden_size", ",", "\n", "num_hidden_layers", "=", "2", ",", "\n", "num_attention_heads", "=", "4", ",", "\n", "is_decoder", "=", "True", ",", "\n", "add_cross_attention", "=", "True", ")", "\n", "decoder", "=", "RobertaForCausalLM", "(", "config", "=", "decoder_config", ")", "\n", "decoder", ".", "resize_token_embeddings", "(", "len", "(", "args", ".", "tokenizer", ")", ")", "\n", "self", ".", "transformer", "=", "EncoderDecoderModel", "(", "encoder", "=", "encoder", ",", "decoder", "=", "decoder", ")", "\n", "", "elif", "self", ".", "args", ".", "model", ".", "startswith", "(", "'facebook/bart'", ")", ":", "\n", "            ", "self", ".", "transformer", "=", "BartForConditionalGeneration", ".", "from_pretrained", "(", "args", ".", "model", ")", "\n", "self", ".", "transformer", ".", "resize_token_embeddings", "(", "len", "(", "args", ".", "tokenizer", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.model.Seq2Seq.forward": [[51, 92], ["model.Seq2Seq.embedding().float", "range", "torch.nn.utils.rnn.pack_padded_sequence", "model.Seq2Seq.encoder", "model.Seq2Seq.embedding().float", "model.Seq2Seq.decoder", "model.Seq2Seq.linear", "model.Seq2Seq.masked_fill_", "attention_mask.size", "lengths.append", "model.Seq2Seq.args.model.startswith", "model.Seq2Seq.args.model.startswith", "model.Seq2Seq.transformer.get_encoder", "model.Seq2Seq.transformer.get_decoder", "model.Seq2Seq.", "model.Seq2Seq.args.model.startswith", "model.Seq2Seq.embedding", "attention_mask[].sum().item", "model.Seq2Seq.embedding", "model.Seq2Seq.", "model.Seq2Seq.args.model.startswith", "model.Seq2Seq.transformer.lm_head", "attention_mask[].sum"], "methods", ["None"], ["", "", "def", "forward", "(", "\n", "self", ",", "\n", "input_ids", "=", "None", ",", "\n", "attention_mask", "=", "None", ",", "\n", "decoder_input_ids", "=", "None", ",", "\n", "logits_mask", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "self", ".", "args", ".", "model", "==", "'lstm'", ":", "\n", "            ", "input_embeds", "=", "self", ".", "embedding", "(", "input_ids", ")", ".", "float", "(", ")", "\n", "lengths", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "attention_mask", ".", "size", "(", "0", ")", ")", ":", "\n", "                ", "lengths", ".", "append", "(", "attention_mask", "[", "i", "]", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "", "input_embeds", "=", "pack_padded_sequence", "(", "input_embeds", ",", "lengths", ",", "batch_first", "=", "True", ",", "enforce_sorted", "=", "False", ")", "\n", "_", ",", "hidden", "=", "self", ".", "encoder", "(", "input_embeds", ")", "\n", "\n", "h", ",", "c", "=", "hidden", "\n", "h", "=", "h", "[", "-", "2", ":", "]", "\n", "c", "=", "c", "[", "-", "2", ":", "]", "\n", "\n", "decoder_input_embeds", "=", "self", ".", "embedding", "(", "decoder_input_ids", ")", ".", "float", "(", ")", "\n", "outputs", ",", "_", "=", "self", ".", "decoder", "(", "decoder_input_embeds", ",", "(", "h", ",", "c", ")", ")", "\n", "logits", "=", "self", ".", "linear", "(", "outputs", ")", "\n", "\n", "", "elif", "self", ".", "args", ".", "model", ".", "startswith", "(", "'facebook/bart'", ")", "or", "self", ".", "args", ".", "model", ".", "startswith", "(", "'roberta'", ")", ":", "\n", "            ", "encoder", "=", "self", ".", "transformer", ".", "get_encoder", "(", ")", "\n", "decoder", "=", "self", ".", "transformer", ".", "get_decoder", "(", ")", "\n", "\n", "encoder_last_hidden_state", "=", "encoder", "(", "\n", "input_ids", "=", "input_ids", ",", "\n", "attention_mask", "=", "attention_mask", ")", ".", "last_hidden_state", "\n", "decoder_output", "=", "decoder", "(", "\n", "input_ids", "=", "decoder_input_ids", ",", "\n", "encoder_hidden_states", "=", "encoder_last_hidden_state", ",", "\n", "encoder_attention_mask", "=", "attention_mask", ")", "\n", "if", "self", ".", "args", ".", "model", ".", "startswith", "(", "'roberta'", ")", ":", "\n", "                ", "logits", "=", "decoder_output", ".", "logits", "\n", "", "elif", "self", ".", "args", ".", "model", ".", "startswith", "(", "'facebook/bart'", ")", ":", "\n", "                ", "logits", "=", "self", ".", "transformer", ".", "lm_head", "(", "decoder_output", ".", "last_hidden_state", ")", "\n", "", "", "if", "self", ".", "args", ".", "constrain_decoding", ":", "\n", "            ", "logits", ".", "masked_fill_", "(", "logits_mask", ",", "-", "1e24", ")", "\n", "", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.model.Seq2Seq.generate": [[93, 99], ["model.Seq2Seq.greedy_decode"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.model.Seq2Seq.greedy_decode"], ["", "def", "generate", "(", "self", ",", "\n", "input_ids", "=", "None", ",", "\n", "attention_mask", "=", "None", ",", "\n", "logits_mask", "=", "None", ")", ":", "\n", "        ", "outputs", "=", "self", ".", "greedy_decode", "(", "input_ids", ",", "attention_mask", ",", "logits_mask", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_parsing.model.Seq2Seq.greedy_decode": [[100, 178], ["model.Seq2Seq.embedding().float", "range", "torch.nn.utils.rnn.pack_padded_sequence", "model.Seq2Seq.encoder", "set", "set", "torch.cat.to", "range", "attention_mask.size", "lengths.append", "range", "torch.zeros", "model.Seq2Seq.embedding().float", "model.Seq2Seq.decoder", "model.Seq2Seq.linear", "model.Seq2Seq.argmax", "isinstance", "torch.cat", "model.Seq2Seq.args.model.startswith", "model.Seq2Seq.args.model.startswith", "model.Seq2Seq.transformer.get_encoder", "model.Seq2Seq.transformer.get_decoder", "torch.cat.to", "set", "set", "range", "model.Seq2Seq.embedding", "attention_mask[].sum().item", "input_ids.size", "model.Seq2Seq.masked_fill_", "len", "set.update", "model.Seq2Seq.", "torch.zeros", "range", "model.Seq2Seq.", "model.Seq2Seq.args.model.startswith", "model.Seq2Seq.argmax", "isinstance", "torch.cat", "input_ids.size", "model.Seq2Seq.embedding", "model.Seq2Seq.argmax.unsqueeze", "input_ids.size", "model.Seq2Seq.args.model.startswith", "model.Seq2Seq.masked_fill_", "len", "set.update", "attention_mask[].sum", "input_ids.size", "model.Seq2Seq.transformer.lm_head", "model.Seq2Seq.argmax.unsqueeze"], "methods", ["None"], ["", "def", "greedy_decode", "(", "self", ",", "input_ids", ",", "attention_mask", ",", "logits_mask", ")", ":", "\n", "        ", "if", "self", ".", "args", ".", "model", "==", "'lstm'", ":", "\n", "            ", "input_embeds", "=", "self", ".", "embedding", "(", "input_ids", ")", ".", "float", "(", ")", "\n", "lengths", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "attention_mask", ".", "size", "(", "0", ")", ")", ":", "\n", "                ", "lengths", ".", "append", "(", "attention_mask", "[", "i", "]", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "", "input_embeds", "=", "pack_padded_sequence", "(", "input_embeds", ",", "lengths", ",", "batch_first", "=", "True", ",", "enforce_sorted", "=", "False", ")", "\n", "_", ",", "hidden", "=", "self", ".", "encoder", "(", "input_embeds", ")", "\n", "\n", "h", ",", "c", "=", "hidden", "\n", "h", "=", "h", "[", "-", "2", ":", "]", "\n", "c", "=", "c", "[", "-", "2", ":", "]", "\n", "\n", "batch_ids", "=", "set", "(", "range", "(", "input_ids", ".", "size", "(", "0", ")", ")", ")", "\n", "stopped_batch_ids", "=", "set", "(", ")", "\n", "decoder_input_ids", "=", "torch", ".", "zeros", "(", "[", "input_ids", ".", "size", "(", "0", ")", ",", "1", "]", ",", "dtype", "=", "torch", ".", "long", ")", "+", "self", ".", "args", ".", "tokenizer", ".", "bos_token_id", "\n", "decoder_input_ids", "=", "decoder_input_ids", ".", "to", "(", "input_ids", ".", "device", ")", "\n", "max_decode_length", "=", "self", ".", "args", ".", "max_decode_length", "\n", "for", "i", "in", "range", "(", "max_decode_length", ")", ":", "\n", "                ", "_decoder_input_ids", "=", "decoder_input_ids", "[", ":", ",", "-", "1", ":", "]", "\n", "embed", "=", "self", ".", "embedding", "(", "_decoder_input_ids", ")", ".", "float", "(", ")", "\n", "out", ",", "hidden", "=", "self", ".", "decoder", "(", "embed", ",", "(", "h", ",", "c", ")", ")", "\n", "h", ",", "c", "=", "hidden", "\n", "next_token_logits", "=", "self", ".", "linear", "(", "out", "[", ":", ",", "-", "1", ",", ":", "]", ")", "\n", "if", "self", ".", "args", ".", "constrain_decoding", ":", "\n", "                    ", "next_token_logits", ".", "masked_fill_", "(", "logits_mask", ",", "-", "1e24", ")", "\n", "", "next_token_ids", "=", "next_token_logits", ".", "argmax", "(", "-", "1", ")", "\n", "stopped_batch", "=", "(", "\n", "next_token_ids", "==", "self", ".", "args", ".", "tokenizer", ".", "eos_token_id", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "isinstance", "(", "stopped_batch", ",", "int", ")", ":", "\n", "                    ", "stopped_batch", "=", "[", "stopped_batch", "]", "\n", "", "if", "len", "(", "stopped_batch", ")", ">", "0", ":", "\n", "                    ", "stopped_batch_ids", ".", "update", "(", "stopped_batch", ")", "\n", "if", "stopped_batch_ids", "==", "batch_ids", ":", "\n", "                        ", "break", "\n", "", "", "decoder_input_ids", "=", "torch", ".", "cat", "(", "[", "decoder_input_ids", ",", "next_token_ids", ".", "unsqueeze", "(", "-", "1", ")", "]", ",", "-", "1", ")", "\n", "", "return", "decoder_input_ids", "[", ":", ",", "1", ":", "]", "\n", "\n", "", "elif", "self", ".", "args", ".", "model", ".", "startswith", "(", "'facebook/bart'", ")", "or", "self", ".", "args", ".", "model", ".", "startswith", "(", "'roberta'", ")", ":", "\n", "            ", "encoder", "=", "self", ".", "transformer", ".", "get_encoder", "(", ")", "\n", "decoder", "=", "self", ".", "transformer", ".", "get_decoder", "(", ")", "\n", "\n", "encoder_hidden_states", "=", "encoder", "(", "\n", "input_ids", "=", "input_ids", ",", "\n", "attention_mask", "=", "attention_mask", ")", ".", "last_hidden_state", "\n", "decoder_input_ids", "=", "torch", ".", "zeros", "(", "[", "input_ids", ".", "size", "(", "0", ")", ",", "1", "]", ",", "dtype", "=", "torch", ".", "long", ")", "+", "self", ".", "args", ".", "tokenizer", ".", "bos_token_id", "\n", "decoder_input_ids", "=", "decoder_input_ids", ".", "to", "(", "input_ids", ".", "device", ")", "\n", "max_decode_length", "=", "self", ".", "args", ".", "max_decode_length", "\n", "\n", "batch_ids", "=", "set", "(", "range", "(", "input_ids", ".", "size", "(", "0", ")", ")", ")", "\n", "stopped_batch_ids", "=", "set", "(", ")", "\n", "past_key_values", "=", "None", "\n", "for", "i", "in", "range", "(", "max_decode_length", ")", ":", "\n", "                ", "_decoder_input_ids", "=", "decoder_input_ids", "[", ":", ",", "-", "1", ":", "]", "\n", "decoder_output", "=", "decoder", "(", "\n", "input_ids", "=", "_decoder_input_ids", ",", "\n", "encoder_hidden_states", "=", "encoder_hidden_states", ",", "\n", "encoder_attention_mask", "=", "attention_mask", ",", "\n", "past_key_values", "=", "past_key_values", ")", "\n", "if", "self", ".", "args", ".", "model", ".", "startswith", "(", "'roberta'", ")", ":", "\n", "                    ", "lm_logits", "=", "decoder_output", ".", "logits", "\n", "", "elif", "self", ".", "args", ".", "model", ".", "startswith", "(", "'facebook/bart'", ")", ":", "\n", "                    ", "lm_logits", "=", "self", ".", "transformer", ".", "lm_head", "(", "decoder_output", ".", "last_hidden_state", ")", "\n", "", "past_key_values", "=", "decoder_output", ".", "past_key_values", "\n", "next_token_logits", "=", "lm_logits", "[", ":", ",", "-", "1", ",", ":", "]", "\n", "\n", "if", "self", ".", "args", ".", "constrain_decoding", ":", "\n", "                    ", "next_token_logits", ".", "masked_fill_", "(", "logits_mask", ",", "-", "1e24", ")", "\n", "", "next_token_ids", "=", "next_token_logits", ".", "argmax", "(", "-", "1", ")", "\n", "stopped_batch", "=", "(", "next_token_ids", "==", "self", ".", "args", ".", "tokenizer", ".", "eos_token_id", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "isinstance", "(", "stopped_batch", ",", "int", ")", ":", "\n", "                    ", "stopped_batch", "=", "[", "stopped_batch", "]", "\n", "", "if", "len", "(", "stopped_batch", ")", ">", "0", ":", "\n", "                    ", "stopped_batch_ids", ".", "update", "(", "stopped_batch", ")", "\n", "if", "stopped_batch_ids", "==", "batch_ids", ":", "\n", "                        ", "break", "\n", "", "", "decoder_input_ids", "=", "torch", ".", "cat", "(", "[", "decoder_input_ids", ",", "next_token_ids", ".", "unsqueeze", "(", "-", "1", ")", "]", ",", "-", "1", ")", "\n", "", "return", "decoder_input_ids", "[", ":", ",", "1", ":", "]", "", "", "", "", ""]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.data_utils.get_edge_vocab": [[17, 33], ["sorted.append", "sorted.append", "sorted", "range", "dict", "enumerate", "len", "sorted.append", "sorted.append"], "function", ["None"], ["unique_no_split_tokens", "=", "tokenizer", ".", "unique_no_split_tokens", "\n", "tokenizer", ".", "unique_no_split_tokens", "=", "unique_no_split_tokens", "+", "tokens_to_add", "\n", "tokenizer", ".", "add_tokens", "(", "tokens_to_add", ")", "\n", "return", "tokenizer", "\n", "\n", "\n", "", "def", "_map_variable_to_value", "(", "dmr", ",", "var2val", ",", "is_node", "=", "True", ")", ":", "\n", "    ", "if", "isinstance", "(", "dmr", ",", "str", ")", ":", "\n", "        ", "if", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "dmr", ")", "and", "not", "re", ".", "fullmatch", "(", "r'v[\\d]+'", ",", "dmr", ")", ":", "\n", "            ", "m", "=", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "dmr", ")", "\n", "var", "=", "dmr", "[", "m", ".", "span", "(", ")", "[", "0", "]", ":", "m", ".", "span", "(", ")", "[", "1", "]", "-", "3", "]", "\n", "val", "=", "dmr", "[", "m", ".", "span", "(", ")", "[", "1", "]", ":", "]", "\n", "# if '#refer T:' in val:", "\n", "#     # If there are no referred nodes (only referred turn number), this is referred to the agent's turn,", "\n", "#     # For this case, remove the referred surface form", "\n", "#     if 'N:c' not in val:", "\n", "#         val = '#refer'", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.data_utils.get_examples": [[35, 191], ["dict", "collections.defaultdict", "dgl.graph", "enumerate", "isinstance", "utils.DMR.from_dict", "isinstance", "utils.DMR.from_dict", "DMR.from_dict.to_triples", "dgl.add_edges.number_of_nodes", "dgl.add_nodes", "enumerate", "turn_node_ids.append", "collections.defaultdict", "collections.defaultdict.items", "len", "node_features.append", "node_features.append", "reversed", "dgl.add_edges", "dgl.add_edges", "edges.append", "edges.append", "dgl.add_edges", "dgl.add_edges", "edges.append", "edges.append", "len", "dict", "dict.items", "examples.append", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "len", "dgl.add_edges.number_of_nodes", "dgl.add_nodes", "node_features.append", "dgl.add_edges", "edges.append", "dgl.add_edges", "edges.append", "dgl.add_edges", "edges.append", "dgl.add_edges", "edges.append", "dgl.add_edges.number_of_nodes", "dgl.add_nodes", "_ntype2ids[].append", "dgl.add_edges", "edges.append", "dgl.add_edges", "edges.append", "copy.deepcopy", "len", "len", "node_features.append", "node_features.append", "len", "set().issubset", "references.append", "len", "str", "antecedents.append", "set", "node_features.append", "node_features.append", "len", "set", "len", "node_features.append", "node_features.append"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.from_dict", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.from_dict", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.to_triples"], ["#         val = re.split(r' T:', val)[0]", "\n", "var2val", "[", "var", "]", "=", "val", "\n", "", "", "else", ":", "\n", "        ", "for", "k", ",", "v", "in", "dmr", ".", "items", "(", ")", ":", "\n", "            ", "if", "is_node", ":", "\n", "                ", "_map_variable_to_value", "(", "k", ",", "var2val", ",", "True", ")", "\n", "_map_variable_to_value", "(", "v", ",", "var2val", ",", "False", ")", "\n", "", "else", ":", "\n", "                ", "_map_variable_to_value", "(", "v", ",", "var2val", ",", "True", ")", "\n", "\n", "\n", "", "", "", "", "def", "linearize_dmr", "(", "value", ",", "is_root", "=", "True", ",", "var2val", "=", "None", ")", ":", "\n", "    ", "if", "not", "var2val", ":", "\n", "        ", "var2val", "=", "dict", "(", ")", "\n", "_map_variable_to_value", "(", "value", ",", "var2val", ")", "\n", "\n", "", "str_", "=", "''", "\n", "if", "isinstance", "(", "value", ",", "str", ")", ":", "\n", "        ", "if", "is_root", ":", "\n", "            ", "str_", "=", "'( '", "+", "value", "+", "' )'", "\n", "", "else", ":", "\n", "            ", "if", "re", ".", "fullmatch", "(", "r'v[\\d]+'", ",", "value", ")", ":", "\n", "                ", "str_", "=", "var2val", "[", "value", "]", "\n", "", "elif", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "value", ")", ":", "\n", "                ", "m", "=", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "value", ")", "\n", "var", "=", "value", "[", "m", ".", "span", "(", ")", "[", "0", "]", ":", "m", ".", "span", "(", ")", "[", "1", "]", "-", "3", "]", "\n", "str_", "=", "var2val", "[", "var", "]", "\n", "", "elif", "'-'", "==", "value", ":", "\n", "                ", "str_", "=", "'#-'", "\n", "", "else", ":", "\n", "                ", "str_", "=", "value", "\n", "", "", "", "elif", "isinstance", "(", "value", ",", "dict", ")", ":", "\n", "        ", "keys", "=", "sorted", "(", "value", ".", "keys", "(", ")", ")", "\n", "# is_op = False", "\n", "# if ':op1' in keys:", "\n", "#     keys = sorted(keys, key=lambda k: int(k[3:]))", "\n", "#     is_op = True", "\n", "for", "key", "in", "keys", ":", "\n", "            ", "if", "re", ".", "fullmatch", "(", "r'v[\\d]+'", ",", "key", ")", ":", "\n", "                ", "_key", "=", "var2val", "[", "key", "]", "\n", "", "elif", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "key", ")", ":", "\n", "                ", "m", "=", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "key", ")", "\n", "var", "=", "key", "[", "m", ".", "span", "(", ")", "[", "0", "]", ":", "m", ".", "span", "(", ")", "[", "1", "]", "-", "3", "]", "\n", "_key", "=", "var2val", "[", "var", "]", "\n", "", "else", ":", "\n", "                ", "_key", "=", "key", "\n", "\n", "", "if", "_key", "==", "'and'", ":", "\n", "                ", "str_", "+=", "' ( #and'", "+", "' '", "+", "linearize_dmr", "(", "value", "[", "key", "]", ",", "False", ",", "var2val", ")", "+", "' )'", "\n", "# elif is_op:", "\n", "#     str_ += ' [ :op' + ' ' + linearize_dmr(value[key], False, var2val) + ' ]'", "\n", "", "else", ":", "\n", "                ", "str_", "+=", "' ( '", "+", "_key", "+", "' '", "+", "linearize_dmr", "(", "value", "[", "key", "]", ",", "False", ",", "var2val", ")", "+", "' )'", "\n", "", "", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", ")", "\n", "", "return", "str_", ".", "strip", "(", ")", "\n", "\n", "\n", "", "def", "generate_examples", "(", "dialog", ",", "\n", "tokenizer", ",", "\n", "schema_tokens", ",", "\n", "context_size", "=", "0", ",", "\n", "add_role", "=", "False", ")", ":", "\n", "    ", "assert", "context_size", ">=", "0", "\n", "\n", "examples", "=", "[", "]", "\n", "turns", "=", "dialog", "[", "'turns'", "]", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "turns", ")", ":", "\n", "        ", "if", "'annotation'", "in", "t", ":", "\n", "            ", "if", "'eval_nlu'", "in", "t", "and", "not", "t", "[", "'eval_nlu'", "]", ":", "\n", "                ", "continue", "\n", "", "if", "'do_train'", "in", "t", "and", "not", "t", "[", "'do_train'", "]", ":", "\n", "                ", "continue", "\n", "", "anno", "=", "t", "[", "'annotation'", "]", "\n", "if", "\"reference\"", "in", "str", "(", "anno", ")", ":", "\n", "                ", "anno", "=", "DMR", ".", "from_dict", "(", "anno", ")", ".", "to_dict", "(", "for_parsing", "=", "True", ")", "\n", "", "target", "=", "linearize_dmr", "(", "anno", ")", "\n", "target", "=", "target", ".", "split", "(", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "target", ")", ")", ":", "\n", "                ", "if", "target", "[", "j", "]", "in", "schema_tokens", ":", "\n", "                    ", "target", "[", "j", "]", "=", "'<<'", "+", "target", "[", "j", "]", "+", "'>>'", "\n", "", "", "target", "=", "' '", ".", "join", "(", "target", ")", "\n", "\n", "start_turn", "=", "i", "-", "context_size", "\n", "if", "start_turn", "<", "0", ":", "\n", "                ", "start_turn", "=", "0", "\n", "", "context", "=", "turns", "[", "start_turn", ":", "i", "]", "\n", "source", "=", "''", "\n", "for", "_t", "in", "context", ":", "\n", "                ", "if", "add_role", ":", "\n", "                    ", "source", "+=", "f'{_t[\"authorRole\"]} : '", "+", "_t", "[", "'tokenized_content'", "]", "+", "' '", "\n", "", "else", ":", "\n", "                    ", "source", "+=", "_t", "[", "'tokenized_content'", "]", "+", "' '", "\n", "", "", "if", "add_role", "and", "context_size", ">", "0", ":", "\n", "                ", "source", "+=", "f'{t[\"authorRole\"]} : '", "+", "t", "[", "'tokenized_content'", "]", "\n", "", "else", ":", "\n", "                ", "source", "+=", "t", "[", "'tokenized_content'", "]", "\n", "", "source", "=", "' '", ".", "join", "(", "source", ".", "split", "(", ")", ")", "\n", "source", "=", "re", ".", "sub", "(", "r'http\\S+'", ",", "'<url>'", ",", "source", ")", "\n", "source", "=", "re", ".", "sub", "(", "r'www.\\S+'", ",", "'<url>'", ",", "source", ")", "\n", "\n", "good_words_ids", "=", "set", "(", "tokenize", "(", "tokenizer", ",", "t", "[", "'tokenized_content'", "]", ")", ")", "\n", "good_words_ids", ".", "add", "(", "tokenizer", ".", "eos_token_id", ")", "\n", "good_words_ids", ".", "add", "(", "tokenizer", ".", "bos_token_id", ")", "\n", "\n", "label", "=", "tokenize", "(", "tokenizer", ",", "target", ")", "\n", "\n", "decoder_input_ids", "=", "[", "tokenizer", ".", "bos_token_id", "]", "+", "label", "\n", "decoder_output_ids", "=", "label", "+", "[", "tokenizer", ".", "eos_token_id", "]", "\n", "\n", "encoded_input_ids", "=", "tokenizer", ".", "encode_plus", "(", "tokenize", "(", "tokenizer", ",", "source", ")", ",", "add_special_tokens", "=", "False", ")", "\n", "encoded_decoder_input_ids", "=", "tokenizer", ".", "encode_plus", "(", "decoder_input_ids", ",", "add_special_tokens", "=", "False", ")", "\n", "encoded_decoder_output_ids", "=", "tokenizer", ".", "encode_plus", "(", "decoder_output_ids", ",", "add_special_tokens", "=", "False", ")", "\n", "\n", "examples", ".", "append", "(", "{", "\n", "'source'", ":", "source", ",", "\n", "'encoded_input_ids'", ":", "encoded_input_ids", ",", "\n", "'target'", ":", "target", ",", "\n", "'annotation'", ":", "anno", ",", "\n", "'good_words_ids'", ":", "good_words_ids", ",", "\n", "'utteranceId'", ":", "t", "[", "'utteranceId'", "]", ",", "\n", "'encoded_decoder_input_ids'", ":", "encoded_decoder_input_ids", ",", "\n", "'encoded_decoder_output_ids'", ":", "encoded_decoder_output_ids", "\n", "}", ")", "\n", "", "", "return", "examples", "\n", "\n", "\n", "", "def", "tokenize", "(", "tokenizer", ",", "s", ")", ":", "\n", "    ", "ret", "=", "[", "]", "\n", "if", "isinstance", "(", "s", ",", "str", ")", ":", "\n", "        ", "s", "=", "s", ".", "split", "(", ")", "\n", "", "for", "tok", "in", "s", ":", "\n", "        ", "ret", "+=", "tokenizer", ".", "tokenize", "(", "tok", ",", "add_prefix_space", "=", "True", ")", "\n", "", "ret", "=", "tokenizer", ".", "convert_tokens_to_ids", "(", "ret", ")", "\n", "return", "ret", "\n", "\n", "\n", "", "def", "dataloader", "(", "segment", ",", "\n", "batch_size", ",", "\n", "tokenizer", ",", "\n", "shuffle", "=", "False", ",", "\n", "context_size", "=", "0", ",", "\n", "add_role", "=", "False", ",", "\n", "num_workers", "=", "0", ")", ":", "\n", "    ", "dialogs", "=", "json", ".", "load", "(", "open", "(", "f'../dataset/dmr-fastfood/{segment}.json'", ")", ")", "\n", "\n", "examples", "=", "[", "]", "\n", "for", "d", "in", "dialogs", ":", "\n", "        ", "examples", "+=", "generate_examples", "(", "d", ",", "tokenizer", ",", "ff_schema_tokens", ",", "context_size", ",", "add_role", ")", "\n", "\n", "", "print", "(", "f'{segment} set contains {len(examples)} examples'", ")", "\n", "\n", "schema_token_ids", "=", "set", "(", ")", "\n", "for", "tok", "in", "ff_schema_tokens", ":", "\n", "        ", "schema_token_ids", ".", "add", "(", "tokenizer", ".", "convert_tokens_to_ids", "(", "'<<'", "+", "tok", "+", "'>>'", ")", ")", "\n", "\n", "", "def", "_collate_fn", "(", "batch", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.data_utils.dataloader": [[193, 273], ["json.load", "data_utils.get_examples", "print", "data_utils.get_edge_vocab", "pickle.load", "torch.utils.data.DataLoader", "open", "open", "dgl.batch", "torch.cat", "torch.cat", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "g.to.to", "dgl_graphs.append", "enumerate", "torch.tensor", "node_feat_tensors.append", "torch.tensor", "edge_type_tensors.append", "reference_list.append", "len", "feat.split.strip", "torch.tensor", "torch.tensor", "torch.tensor", "references.append", "node_feats_vec.append", "int", "numpy.array", "node_feats_vec.append", "feat.split.split", "len", "node_feats_vec.append", "len", "numpy.array", "tok.lower.lower", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.data_utils.get_examples", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.data_utils.get_edge_vocab"], ["for", "ex", "in", "batch", ":", "\n", "            ", "good_words_id", "=", "ex", "[", "'good_words_ids'", "]", "\n", "good_words_id", "=", "good_words_id", ".", "union", "(", "schema_token_ids", ")", "\n", "bad_words_id", "=", "list", "(", "set", "(", "range", "(", "len", "(", "tokenizer", ")", ")", ")", "-", "good_words_id", ")", "\n", "\n", "logits_mask", "=", "np", ".", "zeros", "(", "len", "(", "tokenizer", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "logits_mask", "[", "list", "(", "bad_words_id", ")", "]", "=", "True", "\n", "logits_masks", ".", "append", "(", "logits_mask", ")", "\n", "\n", "", "sources_", "=", "tokenizer", ".", "pad", "(", "[", "ex", "[", "'encoded_input_ids'", "]", "for", "ex", "in", "batch", "]", ",", "return_tensors", "=", "'pt'", ",", "padding", "=", "True", ")", "\n", "input_ids", ",", "attention_mask", "=", "sources_", ".", "input_ids", ",", "sources_", ".", "attention_mask", "\n", "\n", "decoder_input_ids", "=", "tokenizer", ".", "pad", "(", "[", "ex", "[", "'encoded_decoder_input_ids'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "return_tensors", "=", "'pt'", ",", "\n", "padding", "=", "True", ")", ".", "input_ids", "\n", "decoder_output_ids", "=", "tokenizer", ".", "pad", "(", "[", "ex", "[", "'encoded_decoder_output_ids'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "return_tensors", "=", "'pt'", ",", "\n", "padding", "=", "True", ")", ".", "input_ids", "\n", "\n", "logits_masks", "=", "torch", ".", "tensor", "(", "logits_masks", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "\n", "return", "{", "\n", "'source'", ":", "[", "ex", "[", "'source'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "'input_ids'", ":", "input_ids", ",", "\n", "'attention_mask'", ":", "attention_mask", ",", "\n", "'decoder_input_ids'", ":", "decoder_input_ids", ",", "\n", "'decoder_output_ids'", ":", "decoder_output_ids", ",", "\n", "'targets'", ":", "[", "ex", "[", "'target'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "'annotations'", ":", "[", "ex", "[", "'annotation'", "]", "for", "ex", "in", "batch", "]", ",", "\n", "'logits_masks'", ":", "logits_masks", ",", "\n", "'utteranceId'", ":", "[", "ex", "[", "'utteranceId'", "]", "for", "ex", "in", "batch", "]", "\n", "}", "\n", "\n", "", "dl", "=", "DataLoader", "(", "examples", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "shuffle", ",", "collate_fn", "=", "_collate_fn", ",", "num_workers", "=", "num_workers", ")", "\n", "return", "dl", "", "", ""]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.data_utils.build_coref_vocab": [[275, 313], ["dict", "dict.items", "dict", "pickle.dump", "json.load", "open", "f.readlines", "open", "open", "words.append", "l.replace().strip().split.replace().strip().split", "numpy.random.randn().tolist", "isinstance", "utils.DMR.from_dict", "DMR.from_dict.ntype2nodes.items", "l.replace().strip().split.replace().strip", "len", "float", "numpy.random.randn", "n.node_value.strip().split", "l.replace().strip().split.replace", "n.node_value.strip", "dict.get", "tok.lower", "tok.lower"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.src.utils.DMR.from_dict"], []], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.model.GNNCorefModel.__init__": [[9, 27], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "range", "torch.nn.Sequential", "dgl.nn.RelGraphConv", "model.GNNCorefModel.layers.append", "torch.nn.Linear", "torch.nn.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.__init__"], ["from", "torch", ".", "nn", ".", "utils", ".", "rnn", "import", "pack_padded_sequence", "\n", "\n", "\n", "class", "Seq2Seq", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "super", "(", "Seq2Seq", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "args", "=", "args", "\n", "if", "self", ".", "args", ".", "model", "==", "'lstm'", ":", "\n", "            ", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "len", "(", "args", ".", "tokenizer", ")", ",", "300", ")", "\n", "self", ".", "embedding", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "from_numpy", "(", "args", ".", "glove_embed", ")", ")", "\n", "self", ".", "encoder", "=", "nn", ".", "LSTM", "(", "\n", "input_size", "=", "300", ",", "\n", "hidden_size", "=", "512", ",", "\n", "num_layers", "=", "2", ",", "\n", "bidirectional", "=", "True", ",", "\n", "batch_first", "=", "True", ",", "\n", "dropout", "=", "0.1", "\n", ")", "\n", "self", ".", "decoder", "=", "nn", ".", "LSTM", "(", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.model.GNNCorefModel.forward": [[29, 67], ["dgl.unbatch", "zip", "torch.cat", "torch.cat", "torch.cat", "model.GNNCorefModel.prediction_layer().squeeze", "conv", "torch.cat", "feats.index_select", "feats.index_select", "head_feat_list.append", "tail_feat_list.append", "model.GNNCorefModel.prediction_layer", "label_list.append"], "methods", ["None"], ["hidden_size", "=", "512", ",", "\n", "num_layers", "=", "2", ",", "\n", "bidirectional", "=", "False", ",", "\n", "batch_first", "=", "True", ",", "\n", "dropout", "=", "0.1", "\n", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "512", ",", "len", "(", "args", ".", "tokenizer", ")", ")", "\n", "", "elif", "self", ".", "args", ".", "model", ".", "startswith", "(", "'roberta'", ")", ":", "\n", "            ", "encoder", "=", "RobertaModel", ".", "from_pretrained", "(", "self", ".", "args", ".", "model", ")", "\n", "encoder", ".", "resize_token_embeddings", "(", "len", "(", "args", ".", "tokenizer", ")", ")", "\n", "decoder_config", "=", "RobertaConfig", "(", "hidden_size", "=", "encoder", ".", "config", ".", "hidden_size", ",", "\n", "num_hidden_layers", "=", "2", ",", "\n", "num_attention_heads", "=", "4", ",", "\n", "is_decoder", "=", "True", ",", "\n", "add_cross_attention", "=", "True", ")", "\n", "decoder", "=", "RobertaForCausalLM", "(", "config", "=", "decoder_config", ")", "\n", "decoder", ".", "resize_token_embeddings", "(", "len", "(", "args", ".", "tokenizer", ")", ")", "\n", "self", ".", "transformer", "=", "EncoderDecoderModel", "(", "encoder", "=", "encoder", ",", "decoder", "=", "decoder", ")", "\n", "", "elif", "self", ".", "args", ".", "model", ".", "startswith", "(", "'facebook/bart'", ")", ":", "\n", "            ", "self", ".", "transformer", "=", "BartForConditionalGeneration", ".", "from_pretrained", "(", "args", ".", "model", ")", "\n", "self", ".", "transformer", ".", "resize_token_embeddings", "(", "len", "(", "args", ".", "tokenizer", ")", ")", "\n", "\n", "", "", "def", "forward", "(", "\n", "self", ",", "\n", "input_ids", "=", "None", ",", "\n", "attention_mask", "=", "None", ",", "\n", "decoder_input_ids", "=", "None", ",", "\n", "logits_mask", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "self", ".", "args", ".", "model", "==", "'lstm'", ":", "\n", "            ", "input_embeds", "=", "self", ".", "embedding", "(", "input_ids", ")", ".", "float", "(", ")", "\n", "lengths", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "attention_mask", ".", "size", "(", "0", ")", ")", ":", "\n", "                ", "lengths", ".", "append", "(", "attention_mask", "[", "i", "]", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "", "input_embeds", "=", "pack_padded_sequence", "(", "input_embeds", ",", "lengths", ",", "batch_first", "=", "True", ",", "enforce_sorted", "=", "False", ")", "\n", "_", ",", "hidden", "=", "self", ".", "encoder", "(", "input_embeds", ")", "\n", "\n", "h", ",", "c", "=", "hidden", "\n", "h", "=", "h", "[", "-", "2", ":", "]", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.model.MLPCorefModel.__init__": [[70, 79], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.LeakyReLU", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.__init__"], ["decoder_input_embeds", "=", "self", ".", "embedding", "(", "decoder_input_ids", ")", ".", "float", "(", ")", "\n", "outputs", ",", "_", "=", "self", ".", "decoder", "(", "decoder_input_embeds", ",", "(", "h", ",", "c", ")", ")", "\n", "logits", "=", "self", ".", "linear", "(", "outputs", ")", "\n", "\n", "", "elif", "self", ".", "args", ".", "model", ".", "startswith", "(", "'facebook/bart'", ")", "or", "self", ".", "args", ".", "model", ".", "startswith", "(", "'roberta'", ")", ":", "\n", "            ", "encoder", "=", "self", ".", "transformer", ".", "get_encoder", "(", ")", "\n", "decoder", "=", "self", ".", "transformer", ".", "get_decoder", "(", ")", "\n", "\n", "encoder_last_hidden_state", "=", "encoder", "(", "\n", "input_ids", "=", "input_ids", ",", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.dmr_coref.model.MLPCorefModel.forward": [[81, 85], ["model.MLPCorefModel.mlp().squeeze", "model.MLPCorefModel.mlp"], "methods", ["None"], ["decoder_output", "=", "decoder", "(", "\n", "input_ids", "=", "decoder_input_ids", ",", "\n", "encoder_hidden_states", "=", "encoder_last_hidden_state", ",", "\n", "encoder_attention_mask", "=", "attention_mask", ")", "\n", "if", "self", ".", "args", ".", "model", ".", "startswith", "(", "'roberta'", ")", ":", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr_smatch.get_dmr_match": [[18, 81], ["DMR.read_dmr_data.rename_node", "DMR.read_dmr_data.rename_node", "DMR.read_dmr_data.get_triples", "DMR.read_dmr_data.get_triples", "smatch.get_best_match", "dmr.DMR.read_dmr_data", "dmr.DMR.read_dmr_data", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "len", "len", "dmr.DMR.read_dmr_data", "dmr.DMR.read_dmr_data", "len", "len", "len", "len", "len", "len", "smatch.print_alignment", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.rename_node", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.rename_node", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.get_triples", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.get_triples", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.get_best_match", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr.DMR.read_dmr_data", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr.DMR.read_dmr_data", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr.DMR.read_dmr_data", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr.DMR.read_dmr_data", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.print_alignment"], ["def", "get_dmr_match", "(", "dmr_data1", ",", "dmr_data2", ",", "sent_num", "=", "1", ",", "justinstance", "=", "False", ",", "justattribute", "=", "False", ",", "justrelation", "=", "False", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "dmr1", "=", "DMR", ".", "read_dmr_data", "(", "dmr_data1", ")", "\n", "", "except", ":", "\n", "        ", "dmr1", "=", "DMR", ".", "read_dmr_data", "(", "'OutOfDomainIntent'", ")", "\n", "", "try", ":", "\n", "        ", "dmr2", "=", "DMR", ".", "read_dmr_data", "(", "dmr_data2", ")", "\n", "", "except", ":", "\n", "        ", "dmr2", "=", "DMR", ".", "read_dmr_data", "(", "'OutOfDomainIntent'", ")", "\n", "", "prefix1", "=", "\"a\"", "\n", "prefix2", "=", "\"b\"", "\n", "# Rename node to \"a1\", \"a2\", .etc", "\n", "dmr1", ".", "rename_node", "(", "prefix1", ")", "\n", "# Renaming node to \"b1\", \"b2\", .etc", "\n", "dmr2", ".", "rename_node", "(", "prefix2", ")", "\n", "(", "instance1", ",", "attributes1", ",", "relation1", ")", "=", "dmr1", ".", "get_triples", "(", ")", "\n", "(", "instance2", ",", "attributes2", ",", "relation2", ")", "=", "dmr2", ".", "get_triples", "(", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"DMR pair\"", ",", "sent_num", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"============================================\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"DMR 1 (one-line):\"", ",", "dmr_data1", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"DMR 2 (one-line):\"", ",", "dmr_data2", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Instance triples of DMR 1:\"", ",", "len", "(", "instance1", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "instance1", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Attribute triples of DMR 1:\"", ",", "len", "(", "attributes1", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "attributes1", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Relation triples of DMR 1:\"", ",", "len", "(", "relation1", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "relation1", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Instance triples of DMR 2:\"", ",", "len", "(", "instance2", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "instance2", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Attribute triples of DMR 2:\"", ",", "len", "(", "attributes2", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "attributes2", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Relation triples of DMR 2:\"", ",", "len", "(", "relation2", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "relation2", ",", "file", "=", "DEBUG_LOG", ")", "\n", "# optionally turn off some of the node comparison", "\n", "", "doinstance", "=", "doattribute", "=", "dorelation", "=", "True", "\n", "if", "justinstance", ":", "\n", "        ", "doattribute", "=", "dorelation", "=", "False", "\n", "", "if", "justattribute", ":", "\n", "        ", "doinstance", "=", "dorelation", "=", "False", "\n", "", "if", "justrelation", ":", "\n", "        ", "doinstance", "=", "doattribute", "=", "False", "\n", "", "(", "best_mapping", ",", "best_match_num", ")", "=", "get_best_match", "(", "instance1", ",", "attributes1", ",", "relation1", ",", "\n", "instance2", ",", "attributes2", ",", "relation2", ",", "\n", "prefix1", ",", "prefix2", ",", "doinstance", "=", "doinstance", ",", "\n", "doattribute", "=", "doattribute", ",", "dorelation", "=", "dorelation", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"best match number\"", ",", "best_match_num", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"best node mapping\"", ",", "best_mapping", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Best node mapping alignment:\"", ",", "print_alignment", "(", "best_mapping", ",", "instance1", ",", "instance2", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "if", "justinstance", ":", "\n", "        ", "test_triple_num", "=", "len", "(", "instance1", ")", "\n", "gold_triple_num", "=", "len", "(", "instance2", ")", "\n", "", "elif", "justattribute", ":", "\n", "        ", "test_triple_num", "=", "len", "(", "attributes1", ")", "\n", "gold_triple_num", "=", "len", "(", "attributes2", ")", "\n", "", "elif", "justrelation", ":", "\n", "        ", "test_triple_num", "=", "len", "(", "relation1", ")", "\n", "gold_triple_num", "=", "len", "(", "relation2", ")", "\n", "", "else", ":", "\n", "        ", "test_triple_num", "=", "len", "(", "instance1", ")", "+", "len", "(", "attributes1", ")", "+", "len", "(", "relation1", ")", "\n", "gold_triple_num", "=", "len", "(", "instance2", ")", "+", "len", "(", "attributes2", ")", "+", "len", "(", "relation2", ")", "\n", "", "return", "best_match_num", ",", "test_triple_num", ",", "gold_triple_num", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr_smatch.score_dmr_pairs": [[83, 117], ["enumerate", "smatch.compute_f", "zip", "dmr_smatch.get_dmr_match", "smatch.match_triple_dict.clear", "smatch_scores.append", "print", "print", "print", "smatch.compute_f"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_f", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr_smatch.get_dmr_match", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_f"], ["", "def", "score_dmr_pairs", "(", "dmr_data_list1", ",", "dmr_data_list2", ",", "justinstance", "=", "False", ",", "justattribute", "=", "False", ",", "justrelation", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Score one pair of DMR lines at a time from each file handle\n    :param f1: file handle (or any iterable of strings) to read AMR 1 lines from\n    :param f2: file handle (or any iterable of strings) to read AMR 2 lines from\n    :param justinstance: just pay attention to matching instances\n    :param justattribute: just pay attention to matching attributes\n    :param justrelation: just pay attention to matching relations\n    :return: generator of cur_amr1, cur_amr2 pairs: one-line DMR strings\n    \"\"\"", "\n", "# matching triple number, triple number in test file, triple number in gold file", "\n", "total_match_num", "=", "total_test_num", "=", "total_gold_num", "=", "0", "\n", "\n", "smatch_scores", "=", "[", "]", "\n", "# Read amr pairs from two files", "\n", "for", "sent_num", ",", "(", "dmr_data1", ",", "dmr_data2", ")", "in", "enumerate", "(", "zip", "(", "dmr_data_list1", ",", "dmr_data_list2", ")", ",", "start", "=", "1", ")", ":", "\n", "        ", "best_match_num", ",", "test_triple_num", ",", "gold_triple_num", "=", "get_dmr_match", "(", "dmr_data1", ",", "dmr_data2", ",", "\n", "sent_num", "=", "sent_num", ",", "# sentence number", "\n", "justinstance", "=", "justinstance", ",", "\n", "justattribute", "=", "justattribute", ",", "\n", "justrelation", "=", "justrelation", ")", "\n", "total_match_num", "+=", "best_match_num", "\n", "total_test_num", "+=", "test_triple_num", "\n", "total_gold_num", "+=", "gold_triple_num", "\n", "# clear the matching triple dictionary for the next DMR pair", "\n", "match_triple_dict", ".", "clear", "(", ")", "\n", "\n", "smatch_scores", ".", "append", "(", "compute_f", "(", "best_match_num", ",", "test_triple_num", ",", "gold_triple_num", ")", ")", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Total match number, total triple number in DMR 1, and total triple number in DMR 2:\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "total_match_num", ",", "total_test_num", ",", "total_gold_num", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"---------------------------------------------------------------------------------\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "doc_smatch", "=", "compute_f", "(", "total_match_num", ",", "total_test_num", ",", "total_gold_num", ")", "\n", "return", "doc_smatch", ",", "smatch_scores", "", "", ""]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.get_best_match": [[44, 113], ["smatch.compute_pool", "range", "print", "print", "print", "print", "len", "smatch.compute_match", "print", "smatch.smart_init_mapping", "smatch.random_init_mapping", "print", "print", "smatch.get_best_gain", "len", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_pool", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_match", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.smart_init_mapping", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.random_init_mapping", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.get_best_gain"], ["def", "get_best_match", "(", "instance1", ",", "attribute1", ",", "relation1", ",", "\n", "instance2", ",", "attribute2", ",", "relation2", ",", "\n", "prefix1", ",", "prefix2", ",", "doinstance", "=", "True", ",", "doattribute", "=", "True", ",", "dorelation", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Get the highest triple match number between two sets of triples via hill-climbing.\n    Arguments:\n        instance1: instance triples of AMR 1 (\"instance\", node name, node value)\n        attribute1: attribute triples of AMR 1 (attribute name, node name, attribute value)\n        relation1: relation triples of AMR 1 (relation name, node 1 name, node 2 name)\n        instance2: instance triples of AMR 2 (\"instance\", node name, node value)\n        attribute2: attribute triples of AMR 2 (attribute name, node name, attribute value)\n        relation2: relation triples of AMR 2 (relation name, node 1 name, node 2 name)\n        prefix1: prefix label for AMR 1\n        prefix2: prefix label for AMR 2\n    Returns:\n        best_match: the node mapping that results in the highest triple matching number\n        best_match_num: the highest triple matching number\n\n    \"\"\"", "\n", "# Compute candidate pool - all possible node match candidates.", "\n", "# In the hill-climbing, we only consider candidate in this pool to save computing time.", "\n", "# weight_dict is a dictionary that maps a pair of node", "\n", "(", "candidate_mappings", ",", "weight_dict", ")", "=", "compute_pool", "(", "instance1", ",", "attribute1", ",", "relation1", ",", "\n", "instance2", ",", "attribute2", ",", "relation2", ",", "\n", "prefix1", ",", "prefix2", ",", "doinstance", "=", "doinstance", ",", "doattribute", "=", "doattribute", ",", "\n", "dorelation", "=", "dorelation", ")", "\n", "if", "veryVerbose", ":", "\n", "        ", "print", "(", "\"Candidate mappings:\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "candidate_mappings", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Weight dictionary\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "weight_dict", ",", "file", "=", "DEBUG_LOG", ")", "\n", "\n", "", "best_match_num", "=", "0", "\n", "# initialize best match mapping", "\n", "# the ith entry is the node index in AMR 2 which maps to the ith node in AMR 1", "\n", "best_mapping", "=", "[", "-", "1", "]", "*", "len", "(", "instance1", ")", "\n", "for", "i", "in", "range", "(", "iteration_num", ")", ":", "\n", "        ", "if", "veryVerbose", ":", "\n", "            ", "print", "(", "\"Iteration\"", ",", "i", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "if", "i", "==", "0", ":", "\n", "# smart initialization used for the first round", "\n", "            ", "cur_mapping", "=", "smart_init_mapping", "(", "candidate_mappings", ",", "instance1", ",", "instance2", ")", "\n", "", "else", ":", "\n", "# random initialization for the other round", "\n", "            ", "cur_mapping", "=", "random_init_mapping", "(", "candidate_mappings", ")", "\n", "# compute current triple match number", "\n", "", "match_num", "=", "compute_match", "(", "cur_mapping", ",", "weight_dict", ")", "\n", "if", "veryVerbose", ":", "\n", "            ", "print", "(", "\"Node mapping at start\"", ",", "cur_mapping", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Triple match number at start:\"", ",", "match_num", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "while", "True", ":", "\n", "# get best gain", "\n", "            ", "(", "gain", ",", "new_mapping", ")", "=", "get_best_gain", "(", "cur_mapping", ",", "candidate_mappings", ",", "weight_dict", ",", "\n", "len", "(", "instance2", ")", ",", "match_num", ")", "\n", "if", "veryVerbose", ":", "\n", "                ", "print", "(", "\"Gain after the hill-climbing\"", ",", "gain", ",", "file", "=", "DEBUG_LOG", ")", "\n", "# hill-climbing until there will be no gain for new node mapping", "\n", "", "if", "gain", "<=", "0", ":", "\n", "                ", "break", "\n", "# otherwise update match_num and mapping", "\n", "", "match_num", "+=", "gain", "\n", "cur_mapping", "=", "new_mapping", "[", ":", "]", "\n", "if", "veryVerbose", ":", "\n", "                ", "print", "(", "\"Update triple match number to:\"", ",", "match_num", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Current mapping:\"", ",", "cur_mapping", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "", "if", "match_num", ">", "best_match_num", ":", "\n", "            ", "best_mapping", "=", "cur_mapping", "[", ":", "]", "\n", "best_match_num", "=", "match_num", "\n", "", "", "return", "best_mapping", ",", "best_match_num", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize": [[115, 120], ["item.lower().rstrip", "item.lower"], "function", ["None"], ["", "def", "normalize", "(", "item", ")", ":", "\n", "    ", "\"\"\"\n    lowercase and remove quote signifiers from items that are about to be compared\n    \"\"\"", "\n", "return", "item", ".", "lower", "(", ")", ".", "rstrip", "(", "'_'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_pool": [[122, 230], ["candidate_mapping.append", "set", "int", "int", "candidate_mapping[].add", "int", "int", "candidate_mapping[].add", "smatch.normalize", "smatch.normalize", "int", "int", "int", "int", "candidate_mapping[].add", "candidate_mapping[].add", "smatch.normalize", "smatch.normalize", "smatch.normalize", "smatch.normalize", "smatch.normalize", "smatch.normalize", "smatch.normalize", "smatch.normalize", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.normalize"], ["", "def", "compute_pool", "(", "instance1", ",", "attribute1", ",", "relation1", ",", "\n", "instance2", ",", "attribute2", ",", "relation2", ",", "\n", "prefix1", ",", "prefix2", ",", "doinstance", "=", "True", ",", "doattribute", "=", "True", ",", "dorelation", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    compute all possible node mapping candidates and their weights (the triple matching number gain resulting from\n    mapping one node in AMR 1 to another node in AMR2)\n\n    Arguments:\n        instance1: instance triples of AMR 1\n        attribute1: attribute triples of AMR 1 (attribute name, node name, attribute value)\n        relation1: relation triples of AMR 1 (relation name, node 1 name, node 2 name)\n        instance2: instance triples of AMR 2\n        attribute2: attribute triples of AMR 2 (attribute name, node name, attribute value)\n        relation2: relation triples of AMR 2 (relation name, node 1 name, node 2 name\n        prefix1: prefix label for AMR 1\n        prefix2: prefix label for AMR 2\n    Returns:\n      candidate_mapping: a list of candidate nodes.\n                       The ith element contains the node indices (in AMR 2) the ith node (in AMR 1) can map to.\n                       (resulting in non-zero triple match)\n      weight_dict: a dictionary which contains the matching triple number for every pair of node mapping. The key\n                   is a node pair. The value is another dictionary. key {-1} is triple match resulting from this node\n                   pair alone (instance triples and attribute triples), and other keys are node pairs that can result\n                   in relation triple match together with the first node pair.\n\n\n    \"\"\"", "\n", "candidate_mapping", "=", "[", "]", "\n", "weight_dict", "=", "{", "}", "\n", "for", "instance1_item", "in", "instance1", ":", "\n", "# each candidate mapping is a set of node indices", "\n", "        ", "candidate_mapping", ".", "append", "(", "set", "(", ")", ")", "\n", "if", "doinstance", ":", "\n", "            ", "for", "instance2_item", "in", "instance2", ":", "\n", "# if both triples are instance triples and have the same value", "\n", "                ", "if", "normalize", "(", "instance1_item", "[", "0", "]", ")", "==", "normalize", "(", "instance2_item", "[", "0", "]", ")", "and", "normalize", "(", "instance1_item", "[", "2", "]", ")", "==", "normalize", "(", "instance2_item", "[", "2", "]", ")", ":", "\n", "# get node index by stripping the prefix", "\n", "                    ", "node1_index", "=", "int", "(", "instance1_item", "[", "1", "]", "[", "len", "(", "prefix1", ")", ":", "]", ")", "\n", "node2_index", "=", "int", "(", "instance2_item", "[", "1", "]", "[", "len", "(", "prefix2", ")", ":", "]", ")", "\n", "candidate_mapping", "[", "node1_index", "]", ".", "add", "(", "node2_index", ")", "\n", "node_pair", "=", "(", "node1_index", ",", "node2_index", ")", "\n", "# use -1 as key in weight_dict for instance triples and attribute triples", "\n", "if", "node_pair", "in", "weight_dict", ":", "\n", "                        ", "weight_dict", "[", "node_pair", "]", "[", "-", "1", "]", "+=", "1", "\n", "", "else", ":", "\n", "                        ", "weight_dict", "[", "node_pair", "]", "=", "{", "}", "\n", "weight_dict", "[", "node_pair", "]", "[", "-", "1", "]", "=", "1", "\n", "", "", "", "", "", "if", "doattribute", ":", "\n", "        ", "for", "attribute1_item", "in", "attribute1", ":", "\n", "            ", "for", "attribute2_item", "in", "attribute2", ":", "\n", "# if both attribute relation triple have the same relation name and value", "\n", "                ", "if", "normalize", "(", "attribute1_item", "[", "0", "]", ")", "==", "normalize", "(", "attribute2_item", "[", "0", "]", ")", "and", "normalize", "(", "attribute1_item", "[", "2", "]", ")", "==", "normalize", "(", "attribute2_item", "[", "2", "]", ")", ":", "\n", "                    ", "node1_index", "=", "int", "(", "attribute1_item", "[", "1", "]", "[", "len", "(", "prefix1", ")", ":", "]", ")", "\n", "node2_index", "=", "int", "(", "attribute2_item", "[", "1", "]", "[", "len", "(", "prefix2", ")", ":", "]", ")", "\n", "candidate_mapping", "[", "node1_index", "]", ".", "add", "(", "node2_index", ")", "\n", "node_pair", "=", "(", "node1_index", ",", "node2_index", ")", "\n", "# use -1 as key in weight_dict for instance triples and attribute triples", "\n", "if", "node_pair", "in", "weight_dict", ":", "\n", "                        ", "weight_dict", "[", "node_pair", "]", "[", "-", "1", "]", "+=", "1", "\n", "", "else", ":", "\n", "                        ", "weight_dict", "[", "node_pair", "]", "=", "{", "}", "\n", "weight_dict", "[", "node_pair", "]", "[", "-", "1", "]", "=", "1", "\n", "", "", "", "", "", "if", "dorelation", ":", "\n", "        ", "for", "relation1_item", "in", "relation1", ":", "\n", "            ", "for", "relation2_item", "in", "relation2", ":", "\n", "# if both relation share the same name", "\n", "                ", "if", "normalize", "(", "relation1_item", "[", "0", "]", ")", "==", "normalize", "(", "relation2_item", "[", "0", "]", ")", ":", "\n", "                    ", "node1_index_amr1", "=", "int", "(", "relation1_item", "[", "1", "]", "[", "len", "(", "prefix1", ")", ":", "]", ")", "\n", "node1_index_amr2", "=", "int", "(", "relation2_item", "[", "1", "]", "[", "len", "(", "prefix2", ")", ":", "]", ")", "\n", "node2_index_amr1", "=", "int", "(", "relation1_item", "[", "2", "]", "[", "len", "(", "prefix1", ")", ":", "]", ")", "\n", "node2_index_amr2", "=", "int", "(", "relation2_item", "[", "2", "]", "[", "len", "(", "prefix2", ")", ":", "]", ")", "\n", "# add mapping between two nodes", "\n", "candidate_mapping", "[", "node1_index_amr1", "]", ".", "add", "(", "node1_index_amr2", ")", "\n", "candidate_mapping", "[", "node2_index_amr1", "]", ".", "add", "(", "node2_index_amr2", ")", "\n", "node_pair1", "=", "(", "node1_index_amr1", ",", "node1_index_amr2", ")", "\n", "node_pair2", "=", "(", "node2_index_amr1", ",", "node2_index_amr2", ")", "\n", "if", "node_pair2", "!=", "node_pair1", ":", "\n", "# update weight_dict weight. Note that we need to update both entries for future search", "\n", "# i.e weight_dict[node_pair1][node_pair2]", "\n", "#     weight_dict[node_pair2][node_pair1]", "\n", "                        ", "if", "node1_index_amr1", ">", "node2_index_amr1", ":", "\n", "# swap node_pair1 and node_pair2", "\n", "                            ", "node_pair1", "=", "(", "node2_index_amr1", ",", "node2_index_amr2", ")", "\n", "node_pair2", "=", "(", "node1_index_amr1", ",", "node1_index_amr2", ")", "\n", "", "if", "node_pair1", "in", "weight_dict", ":", "\n", "                            ", "if", "node_pair2", "in", "weight_dict", "[", "node_pair1", "]", ":", "\n", "                                ", "weight_dict", "[", "node_pair1", "]", "[", "node_pair2", "]", "+=", "1", "\n", "", "else", ":", "\n", "                                ", "weight_dict", "[", "node_pair1", "]", "[", "node_pair2", "]", "=", "1", "\n", "", "", "else", ":", "\n", "                            ", "weight_dict", "[", "node_pair1", "]", "=", "{", "-", "1", ":", "0", ",", "node_pair2", ":", "1", "}", "\n", "", "if", "node_pair2", "in", "weight_dict", ":", "\n", "                            ", "if", "node_pair1", "in", "weight_dict", "[", "node_pair2", "]", ":", "\n", "                                ", "weight_dict", "[", "node_pair2", "]", "[", "node_pair1", "]", "+=", "1", "\n", "", "else", ":", "\n", "                                ", "weight_dict", "[", "node_pair2", "]", "[", "node_pair1", "]", "=", "1", "\n", "", "", "else", ":", "\n", "                            ", "weight_dict", "[", "node_pair2", "]", "=", "{", "-", "1", ":", "0", ",", "node_pair1", ":", "1", "}", "\n", "", "", "else", ":", "\n", "# two node pairs are the same. So we only update weight_dict once.", "\n", "# this generally should not happen.", "\n", "                        ", "if", "node_pair1", "in", "weight_dict", ":", "\n", "                            ", "weight_dict", "[", "node_pair1", "]", "[", "-", "1", "]", "+=", "1", "\n", "", "else", ":", "\n", "                            ", "weight_dict", "[", "node_pair1", "]", "=", "{", "-", "1", ":", "1", "}", "\n", "", "", "", "", "", "", "return", "candidate_mapping", ",", "weight_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.smart_init_mapping": [[232, 281], ["random.seed", "enumerate", "list", "result.append", "len", "no_word_match.append", "result.append", "random.randint", "list.pop", "result.append", "len"], "function", ["None"], ["", "def", "smart_init_mapping", "(", "candidate_mapping", ",", "instance1", ",", "instance2", ")", ":", "\n", "    ", "\"\"\"\n    Initialize mapping based on the concept mapping (smart initialization)\n    Arguments:\n        candidate_mapping: candidate node match list\n        instance1: instance triples of AMR 1\n        instance2: instance triples of AMR 2\n    Returns:\n        initialized node mapping between two AMRs\n\n    \"\"\"", "\n", "random", ".", "seed", "(", ")", "\n", "matched_dict", "=", "{", "}", "\n", "result", "=", "[", "]", "\n", "# list to store node indices that have no concept match", "\n", "no_word_match", "=", "[", "]", "\n", "for", "i", ",", "candidates", "in", "enumerate", "(", "candidate_mapping", ")", ":", "\n", "        ", "if", "not", "candidates", ":", "\n", "# no possible mapping", "\n", "            ", "result", ".", "append", "(", "-", "1", ")", "\n", "continue", "\n", "# node value in instance triples of AMR 1", "\n", "", "value1", "=", "instance1", "[", "i", "]", "[", "2", "]", "\n", "for", "node_index", "in", "candidates", ":", "\n", "            ", "value2", "=", "instance2", "[", "node_index", "]", "[", "2", "]", "\n", "# find the first instance triple match in the candidates", "\n", "# instance triple match is having the same concept value", "\n", "if", "value1", "==", "value2", ":", "\n", "                ", "if", "node_index", "not", "in", "matched_dict", ":", "\n", "                    ", "result", ".", "append", "(", "node_index", ")", "\n", "matched_dict", "[", "node_index", "]", "=", "1", "\n", "break", "\n", "", "", "", "if", "len", "(", "result", ")", "==", "i", ":", "\n", "            ", "no_word_match", ".", "append", "(", "i", ")", "\n", "result", ".", "append", "(", "-", "1", ")", "\n", "# if no concept match, generate a random mapping", "\n", "", "", "for", "i", "in", "no_word_match", ":", "\n", "        ", "candidates", "=", "list", "(", "candidate_mapping", "[", "i", "]", ")", "\n", "while", "candidates", ":", "\n", "# get a random node index from candidates", "\n", "            ", "rid", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "candidates", ")", "-", "1", ")", "\n", "candidate", "=", "candidates", "[", "rid", "]", "\n", "if", "candidate", "in", "matched_dict", ":", "\n", "                ", "candidates", ".", "pop", "(", "rid", ")", "\n", "", "else", ":", "\n", "                ", "matched_dict", "[", "candidate", "]", "=", "1", "\n", "result", "[", "i", "]", "=", "candidate", "\n", "break", "\n", "", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.random_init_mapping": [[283, 318], ["random.seed", "list", "result.append", "random.randint", "result.append", "list.pop", "result.append", "len"], "function", ["None"], ["", "def", "random_init_mapping", "(", "candidate_mapping", ")", ":", "\n", "    ", "\"\"\"\n    Generate a random node mapping.\n    Args:\n        candidate_mapping: candidate_mapping: candidate node match list\n    Returns:\n        randomly-generated node mapping between two AMRs\n\n    \"\"\"", "\n", "# if needed, a fixed seed could be passed here to generate same random (to help debugging)", "\n", "random", ".", "seed", "(", ")", "\n", "matched_dict", "=", "{", "}", "\n", "result", "=", "[", "]", "\n", "for", "c", "in", "candidate_mapping", ":", "\n", "        ", "candidates", "=", "list", "(", "c", ")", "\n", "if", "not", "candidates", ":", "\n", "# -1 indicates no possible mapping", "\n", "            ", "result", ".", "append", "(", "-", "1", ")", "\n", "continue", "\n", "", "found", "=", "False", "\n", "while", "candidates", ":", "\n", "# randomly generate an index in [0, length of candidates)", "\n", "            ", "rid", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "candidates", ")", "-", "1", ")", "\n", "candidate", "=", "candidates", "[", "rid", "]", "\n", "# check if it has already been matched", "\n", "if", "candidate", "in", "matched_dict", ":", "\n", "                ", "candidates", ".", "pop", "(", "rid", ")", "\n", "", "else", ":", "\n", "                ", "matched_dict", "[", "candidate", "]", "=", "1", "\n", "result", ".", "append", "(", "candidate", ")", "\n", "found", "=", "True", "\n", "break", "\n", "", "", "if", "not", "found", ":", "\n", "            ", "result", ".", "append", "(", "-", "1", ")", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_match": [[320, 370], ["enumerate", "print", "print", "tuple", "print", "print", "print", "tuple", "tuple", "print", "tuple", "print"], "function", ["None"], ["", "def", "compute_match", "(", "mapping", ",", "weight_dict", ")", ":", "\n", "    ", "\"\"\"\n    Given a node mapping, compute match number based on weight_dict.\n    Args:\n    mappings: a list of node index in AMR 2. The ith element (value j) means node i in AMR 1 maps to node j in AMR 2.\n    Returns:\n    matching triple number\n    Complexity: O(m*n) , m is the node number of AMR 1, n is the node number of AMR 2\n\n    \"\"\"", "\n", "# If this mapping has been investigated before, retrieve the value instead of re-computing.", "\n", "if", "veryVerbose", ":", "\n", "        ", "print", "(", "\"Computing match for mapping\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "mapping", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "if", "tuple", "(", "mapping", ")", "in", "match_triple_dict", ":", "\n", "        ", "if", "veryVerbose", ":", "\n", "            ", "print", "(", "\"saved value\"", ",", "match_triple_dict", "[", "tuple", "(", "mapping", ")", "]", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "return", "match_triple_dict", "[", "tuple", "(", "mapping", ")", "]", "\n", "", "match_num", "=", "0", "\n", "# i is node index in AMR 1, m is node index in AMR 2", "\n", "for", "i", ",", "m", "in", "enumerate", "(", "mapping", ")", ":", "\n", "        ", "if", "m", "==", "-", "1", ":", "\n", "# no node maps to this node", "\n", "            ", "continue", "\n", "# node i in AMR 1 maps to node m in AMR 2", "\n", "", "current_node_pair", "=", "(", "i", ",", "m", ")", "\n", "if", "current_node_pair", "not", "in", "weight_dict", ":", "\n", "            ", "continue", "\n", "", "if", "veryVerbose", ":", "\n", "            ", "print", "(", "\"node_pair\"", ",", "current_node_pair", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "for", "key", "in", "weight_dict", "[", "current_node_pair", "]", ":", "\n", "            ", "if", "key", "==", "-", "1", ":", "\n", "# matching triple resulting from instance/attribute triples", "\n", "                ", "match_num", "+=", "weight_dict", "[", "current_node_pair", "]", "[", "key", "]", "\n", "if", "veryVerbose", ":", "\n", "                    ", "print", "(", "\"instance/attribute match\"", ",", "weight_dict", "[", "current_node_pair", "]", "[", "key", "]", ",", "file", "=", "DEBUG_LOG", ")", "\n", "# only consider node index larger than i to avoid duplicates", "\n", "# as we store both weight_dict[node_pair1][node_pair2] and", "\n", "#     weight_dict[node_pair2][node_pair1] for a relation", "\n", "", "", "elif", "key", "[", "0", "]", "<", "i", ":", "\n", "                ", "continue", "\n", "", "elif", "mapping", "[", "key", "[", "0", "]", "]", "==", "key", "[", "1", "]", ":", "\n", "                ", "match_num", "+=", "weight_dict", "[", "current_node_pair", "]", "[", "key", "]", "\n", "if", "veryVerbose", ":", "\n", "                    ", "print", "(", "\"relation match with\"", ",", "key", ",", "weight_dict", "[", "current_node_pair", "]", "[", "key", "]", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "", "", "", "if", "veryVerbose", ":", "\n", "        ", "print", "(", "\"match computing complete, result:\"", ",", "match_num", ",", "file", "=", "DEBUG_LOG", ")", "\n", "# update match_triple_dict", "\n", "", "match_triple_dict", "[", "tuple", "(", "mapping", ")", "]", "=", "match_num", "\n", "return", "match_num", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.move_gain": [[372, 416], ["tuple", "tuple", "tuple"], "function", ["None"], ["", "def", "move_gain", "(", "mapping", ",", "node_id", ",", "old_id", ",", "new_id", ",", "weight_dict", ",", "match_num", ")", ":", "\n", "    ", "\"\"\"\n    Compute the triple match number gain from the move operation\n    Arguments:\n        mapping: current node mapping\n        node_id: remapped node in AMR 1\n        old_id: original node id in AMR 2 to which node_id is mapped\n        new_id: new node in to which node_id is mapped\n        weight_dict: weight dictionary\n        match_num: the original triple matching number\n    Returns:\n        the triple match gain number (might be negative)\n\n    \"\"\"", "\n", "# new node mapping after moving", "\n", "new_mapping", "=", "(", "node_id", ",", "new_id", ")", "\n", "# node mapping before moving", "\n", "old_mapping", "=", "(", "node_id", ",", "old_id", ")", "\n", "# new nodes mapping list (all node pairs)", "\n", "new_mapping_list", "=", "mapping", "[", ":", "]", "\n", "new_mapping_list", "[", "node_id", "]", "=", "new_id", "\n", "# if this mapping is already been investigated, use saved one to avoid duplicate computing", "\n", "if", "tuple", "(", "new_mapping_list", ")", "in", "match_triple_dict", ":", "\n", "        ", "return", "match_triple_dict", "[", "tuple", "(", "new_mapping_list", ")", "]", "-", "match_num", "\n", "", "gain", "=", "0", "\n", "# add the triple match incurred by new_mapping to gain", "\n", "if", "new_mapping", "in", "weight_dict", ":", "\n", "        ", "for", "key", "in", "weight_dict", "[", "new_mapping", "]", ":", "\n", "            ", "if", "key", "==", "-", "1", ":", "\n", "# instance/attribute triple match", "\n", "                ", "gain", "+=", "weight_dict", "[", "new_mapping", "]", "[", "-", "1", "]", "\n", "", "elif", "new_mapping_list", "[", "key", "[", "0", "]", "]", "==", "key", "[", "1", "]", ":", "\n", "# relation gain incurred by new_mapping and another node pair in new_mapping_list", "\n", "                ", "gain", "+=", "weight_dict", "[", "new_mapping", "]", "[", "key", "]", "\n", "# deduct the triple match incurred by old_mapping from gain", "\n", "", "", "", "if", "old_mapping", "in", "weight_dict", ":", "\n", "        ", "for", "k", "in", "weight_dict", "[", "old_mapping", "]", ":", "\n", "            ", "if", "k", "==", "-", "1", ":", "\n", "                ", "gain", "-=", "weight_dict", "[", "old_mapping", "]", "[", "-", "1", "]", "\n", "", "elif", "mapping", "[", "k", "[", "0", "]", "]", "==", "k", "[", "1", "]", ":", "\n", "                ", "gain", "-=", "weight_dict", "[", "old_mapping", "]", "[", "k", "]", "\n", "# update match number dictionary", "\n", "", "", "", "match_triple_dict", "[", "tuple", "(", "new_mapping_list", ")", "]", "=", "match_num", "+", "gain", "\n", "return", "gain", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.swap_gain": [[418, 482], ["tuple", "tuple", "tuple"], "function", ["None"], ["", "def", "swap_gain", "(", "mapping", ",", "node_id1", ",", "mapping_id1", ",", "node_id2", ",", "mapping_id2", ",", "weight_dict", ",", "match_num", ")", ":", "\n", "    ", "\"\"\"\n    Compute the triple match number gain from the swapping\n    Arguments:\n    mapping: current node mapping list\n    node_id1: node 1 index in AMR 1\n    mapping_id1: the node index in AMR 2 node 1 maps to (in the current mapping)\n    node_id2: node 2 index in AMR 1\n    mapping_id2: the node index in AMR 2 node 2 maps to (in the current mapping)\n    weight_dict: weight dictionary\n    match_num: the original matching triple number\n    Returns:\n    the gain number (might be negative)\n\n    \"\"\"", "\n", "new_mapping_list", "=", "mapping", "[", ":", "]", "\n", "# Before swapping, node_id1 maps to mapping_id1, and node_id2 maps to mapping_id2", "\n", "# After swapping, node_id1 maps to mapping_id2 and node_id2 maps to mapping_id1", "\n", "new_mapping_list", "[", "node_id1", "]", "=", "mapping_id2", "\n", "new_mapping_list", "[", "node_id2", "]", "=", "mapping_id1", "\n", "if", "tuple", "(", "new_mapping_list", ")", "in", "match_triple_dict", ":", "\n", "        ", "return", "match_triple_dict", "[", "tuple", "(", "new_mapping_list", ")", "]", "-", "match_num", "\n", "", "gain", "=", "0", "\n", "new_mapping1", "=", "(", "node_id1", ",", "mapping_id2", ")", "\n", "new_mapping2", "=", "(", "node_id2", ",", "mapping_id1", ")", "\n", "old_mapping1", "=", "(", "node_id1", ",", "mapping_id1", ")", "\n", "old_mapping2", "=", "(", "node_id2", ",", "mapping_id2", ")", "\n", "if", "node_id1", ">", "node_id2", ":", "\n", "        ", "new_mapping2", "=", "(", "node_id1", ",", "mapping_id2", ")", "\n", "new_mapping1", "=", "(", "node_id2", ",", "mapping_id1", ")", "\n", "old_mapping1", "=", "(", "node_id2", ",", "mapping_id2", ")", "\n", "old_mapping2", "=", "(", "node_id1", ",", "mapping_id1", ")", "\n", "", "if", "new_mapping1", "in", "weight_dict", ":", "\n", "        ", "for", "key", "in", "weight_dict", "[", "new_mapping1", "]", ":", "\n", "            ", "if", "key", "==", "-", "1", ":", "\n", "                ", "gain", "+=", "weight_dict", "[", "new_mapping1", "]", "[", "-", "1", "]", "\n", "", "elif", "new_mapping_list", "[", "key", "[", "0", "]", "]", "==", "key", "[", "1", "]", ":", "\n", "                ", "gain", "+=", "weight_dict", "[", "new_mapping1", "]", "[", "key", "]", "\n", "", "", "", "if", "new_mapping2", "in", "weight_dict", ":", "\n", "        ", "for", "key", "in", "weight_dict", "[", "new_mapping2", "]", ":", "\n", "            ", "if", "key", "==", "-", "1", ":", "\n", "                ", "gain", "+=", "weight_dict", "[", "new_mapping2", "]", "[", "-", "1", "]", "\n", "# to avoid duplicate", "\n", "", "elif", "key", "[", "0", "]", "==", "node_id1", ":", "\n", "                ", "continue", "\n", "", "elif", "new_mapping_list", "[", "key", "[", "0", "]", "]", "==", "key", "[", "1", "]", ":", "\n", "                ", "gain", "+=", "weight_dict", "[", "new_mapping2", "]", "[", "key", "]", "\n", "", "", "", "if", "old_mapping1", "in", "weight_dict", ":", "\n", "        ", "for", "key", "in", "weight_dict", "[", "old_mapping1", "]", ":", "\n", "            ", "if", "key", "==", "-", "1", ":", "\n", "                ", "gain", "-=", "weight_dict", "[", "old_mapping1", "]", "[", "-", "1", "]", "\n", "", "elif", "mapping", "[", "key", "[", "0", "]", "]", "==", "key", "[", "1", "]", ":", "\n", "                ", "gain", "-=", "weight_dict", "[", "old_mapping1", "]", "[", "key", "]", "\n", "", "", "", "if", "old_mapping2", "in", "weight_dict", ":", "\n", "        ", "for", "key", "in", "weight_dict", "[", "old_mapping2", "]", ":", "\n", "            ", "if", "key", "==", "-", "1", ":", "\n", "                ", "gain", "-=", "weight_dict", "[", "old_mapping2", "]", "[", "-", "1", "]", "\n", "# to avoid duplicate", "\n", "", "elif", "key", "[", "0", "]", "==", "node_id1", ":", "\n", "                ", "continue", "\n", "", "elif", "mapping", "[", "key", "[", "0", "]", "]", "==", "key", "[", "1", "]", ":", "\n", "                ", "gain", "-=", "weight_dict", "[", "old_mapping2", "]", "[", "key", "]", "\n", "", "", "", "match_triple_dict", "[", "tuple", "(", "new_mapping_list", ")", "]", "=", "match_num", "+", "gain", "\n", "return", "gain", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.get_best_gain": [[484, 583], ["set", "enumerate", "enumerate", "range", "range", "print", "print", "set.remove", "len", "smatch.swap_gain", "print", "smatch.move_gain", "print", "print", "print", "print", "print", "print", "smatch.compute_match", "print", "print", "print", "print", "smatch.compute_match", "print", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.swap_gain", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.move_gain", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_match", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_match"], ["", "def", "get_best_gain", "(", "mapping", ",", "candidate_mappings", ",", "weight_dict", ",", "instance_len", ",", "cur_match_num", ")", ":", "\n", "    ", "\"\"\"\n    Hill-climbing method to return the best gain swap/move can get\n    Arguments:\n    mapping: current node mapping\n    candidate_mappings: the candidates mapping list\n    weight_dict: the weight dictionary\n    instance_len: the number of the nodes in AMR 2\n    cur_match_num: current triple match number\n    Returns:\n    the best gain we can get via swap/move operation\n\n    \"\"\"", "\n", "largest_gain", "=", "0", "\n", "# True: using swap; False: using move", "\n", "use_swap", "=", "True", "\n", "# the node to be moved/swapped", "\n", "node1", "=", "None", "\n", "# store the other node affected. In swap, this other node is the node swapping with node1. In move, this other", "\n", "# node is the node node1 will move to.", "\n", "node2", "=", "None", "\n", "# unmatched nodes in AMR 2", "\n", "unmatched", "=", "set", "(", "range", "(", "instance_len", ")", ")", "\n", "# exclude nodes in current mapping", "\n", "# get unmatched nodes", "\n", "for", "nid", "in", "mapping", ":", "\n", "        ", "if", "nid", "in", "unmatched", ":", "\n", "            ", "unmatched", ".", "remove", "(", "nid", ")", "\n", "", "", "for", "i", ",", "nid", "in", "enumerate", "(", "mapping", ")", ":", "\n", "# current node i in AMR 1 maps to node nid in AMR 2", "\n", "        ", "for", "nm", "in", "unmatched", ":", "\n", "            ", "if", "nm", "in", "candidate_mappings", "[", "i", "]", ":", "\n", "# remap i to another unmatched node (move)", "\n", "# (i, m) -> (i, nm)", "\n", "                ", "if", "veryVerbose", ":", "\n", "                    ", "print", "(", "\"Remap node\"", ",", "i", ",", "\"from \"", ",", "nid", ",", "\"to\"", ",", "nm", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "mv_gain", "=", "move_gain", "(", "mapping", ",", "i", ",", "nid", ",", "nm", ",", "weight_dict", ",", "cur_match_num", ")", "\n", "if", "veryVerbose", ":", "\n", "                    ", "print", "(", "\"Move gain:\"", ",", "mv_gain", ",", "file", "=", "DEBUG_LOG", ")", "\n", "new_mapping", "=", "mapping", "[", ":", "]", "\n", "new_mapping", "[", "i", "]", "=", "nm", "\n", "new_match_num", "=", "compute_match", "(", "new_mapping", ",", "weight_dict", ")", "\n", "if", "new_match_num", "!=", "cur_match_num", "+", "mv_gain", ":", "\n", "                        ", "print", "(", "mapping", ",", "new_mapping", ",", "file", "=", "ERROR_LOG", ")", "\n", "print", "(", "\"Inconsistency in computing: move gain\"", ",", "cur_match_num", ",", "mv_gain", ",", "new_match_num", ",", "\n", "file", "=", "ERROR_LOG", ")", "\n", "", "", "if", "mv_gain", ">", "largest_gain", ":", "\n", "                    ", "largest_gain", "=", "mv_gain", "\n", "node1", "=", "i", "\n", "node2", "=", "nm", "\n", "use_swap", "=", "False", "\n", "# compute swap gain", "\n", "", "", "", "", "for", "i", ",", "m", "in", "enumerate", "(", "mapping", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "mapping", ")", ")", ":", "\n", "            ", "m2", "=", "mapping", "[", "j", "]", "\n", "# swap operation (i, m) (j, m2) -> (i, m2) (j, m)", "\n", "# j starts from i+1, to avoid duplicate swap", "\n", "if", "veryVerbose", ":", "\n", "                ", "print", "(", "\"Swap node\"", ",", "i", ",", "\"and\"", ",", "j", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Before swapping:\"", ",", "i", ",", "\"-\"", ",", "m", ",", "\",\"", ",", "j", ",", "\"-\"", ",", "m2", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "mapping", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"After swapping:\"", ",", "i", ",", "\"-\"", ",", "m2", ",", "\",\"", ",", "j", ",", "\"-\"", ",", "m", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "sw_gain", "=", "swap_gain", "(", "mapping", ",", "i", ",", "m", ",", "j", ",", "m2", ",", "weight_dict", ",", "cur_match_num", ")", "\n", "if", "veryVerbose", ":", "\n", "                ", "print", "(", "\"Swap gain:\"", ",", "sw_gain", ",", "file", "=", "DEBUG_LOG", ")", "\n", "new_mapping", "=", "mapping", "[", ":", "]", "\n", "new_mapping", "[", "i", "]", "=", "m2", "\n", "new_mapping", "[", "j", "]", "=", "m", "\n", "print", "(", "new_mapping", ",", "file", "=", "DEBUG_LOG", ")", "\n", "new_match_num", "=", "compute_match", "(", "new_mapping", ",", "weight_dict", ")", "\n", "if", "new_match_num", "!=", "cur_match_num", "+", "sw_gain", ":", "\n", "                    ", "print", "(", "mapping", ",", "new_mapping", ",", "file", "=", "ERROR_LOG", ")", "\n", "print", "(", "\"Inconsistency in computing: swap gain\"", ",", "cur_match_num", ",", "sw_gain", ",", "new_match_num", ",", "\n", "file", "=", "ERROR_LOG", ")", "\n", "", "", "if", "sw_gain", ">", "largest_gain", ":", "\n", "                ", "largest_gain", "=", "sw_gain", "\n", "node1", "=", "i", "\n", "node2", "=", "j", "\n", "use_swap", "=", "True", "\n", "# generate a new mapping based on swap/move", "\n", "", "", "", "cur_mapping", "=", "mapping", "[", ":", "]", "\n", "if", "node1", "is", "not", "None", ":", "\n", "        ", "if", "use_swap", ":", "\n", "            ", "if", "veryVerbose", ":", "\n", "                ", "print", "(", "\"Use swap gain\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "temp", "=", "cur_mapping", "[", "node1", "]", "\n", "cur_mapping", "[", "node1", "]", "=", "cur_mapping", "[", "node2", "]", "\n", "cur_mapping", "[", "node2", "]", "=", "temp", "\n", "", "else", ":", "\n", "            ", "if", "veryVerbose", ":", "\n", "                ", "print", "(", "\"Use move gain\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "cur_mapping", "[", "node1", "]", "=", "node2", "\n", "", "", "else", ":", "\n", "        ", "if", "veryVerbose", ":", "\n", "            ", "print", "(", "\"no move/swap gain found\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "", "if", "veryVerbose", ":", "\n", "        ", "print", "(", "\"Original mapping\"", ",", "mapping", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Current mapping\"", ",", "cur_mapping", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "return", "largest_gain", ",", "cur_mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.print_alignment": [[585, 604], ["zip", "result.append"], "function", ["None"], ["", "def", "print_alignment", "(", "mapping", ",", "instance1", ",", "instance2", ")", ":", "\n", "    ", "\"\"\"\n    print the alignment based on a node mapping\n    Args:\n        mapping: current node mapping list\n        instance1: nodes of AMR 1\n        instance2: nodes of AMR 2\n\n    \"\"\"", "\n", "result", "=", "[", "]", "\n", "for", "instance1_item", ",", "m", "in", "zip", "(", "instance1", ",", "mapping", ")", ":", "\n", "        ", "r", "=", "instance1_item", "[", "1", "]", "+", "\"(\"", "+", "instance1_item", "[", "2", "]", "+", "\")\"", "\n", "if", "m", "==", "-", "1", ":", "\n", "            ", "r", "+=", "\"-Null\"", "\n", "", "else", ":", "\n", "            ", "instance2_item", "=", "instance2", "[", "m", "]", "\n", "r", "+=", "\"-\"", "+", "instance2_item", "[", "1", "]", "+", "\"(\"", "+", "instance2_item", "[", "2", "]", "+", "\")\"", "\n", "", "result", ".", "append", "(", "r", ")", "\n", "", "return", "\" \"", ".", "join", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_f": [[606, 633], ["float", "float", "float", "float", "print", "print"], "function", ["None"], ["", "def", "compute_f", "(", "match_num", ",", "test_num", ",", "gold_num", ")", ":", "\n", "    ", "\"\"\"\n    Compute the f-score based on the matching triple number,\n                                 triple number of AMR set 1,\n                                 triple number of AMR set 2\n    Args:\n        match_num: matching triple number\n        test_num:  triple number of AMR 1 (test file)\n        gold_num:  triple number of AMR 2 (gold file)\n    Returns:\n        precision: match_num/test_num\n        recall: match_num/gold_num\n        f_score: 2*precision*recall/(precision+recall)\n    \"\"\"", "\n", "if", "test_num", "==", "0", "or", "gold_num", "==", "0", ":", "\n", "        ", "return", "0.00", ",", "0.00", ",", "0.00", "\n", "", "precision", "=", "float", "(", "match_num", ")", "/", "float", "(", "test_num", ")", "\n", "recall", "=", "float", "(", "match_num", ")", "/", "float", "(", "gold_num", ")", "\n", "if", "(", "precision", "+", "recall", ")", "!=", "0", ":", "\n", "        ", "f_score", "=", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", ")", "\n", "if", "veryVerbose", ":", "\n", "            ", "print", "(", "\"F-score:\"", ",", "f_score", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "return", "precision", ",", "recall", ",", "f_score", "\n", "", "else", ":", "\n", "        ", "if", "veryVerbose", ":", "\n", "            ", "print", "(", "\"F-score:\"", ",", "\"0.0\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "return", "precision", ",", "recall", ",", "0.00", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.generate_amr_lines": [[635, 657], ["amr.AMR.get_amr_line", "amr.AMR.get_amr_line", "print", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.get_amr_line", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.get_amr_line"], ["", "", "def", "generate_amr_lines", "(", "f1", ",", "f2", ")", ":", "\n", "    ", "\"\"\"\n    Read one AMR line at a time from each file handle\n    :param f1: file handle (or any iterable of strings) to read AMR 1 lines from\n    :param f2: file handle (or any iterable of strings) to read AMR 2 lines from\n    :return: generator of cur_amr1, cur_amr2 pairs: one-line AMR strings\n    \"\"\"", "\n", "while", "True", ":", "\n", "        ", "cur_amr1", "=", "amr", ".", "AMR", ".", "get_amr_line", "(", "f1", ")", "\n", "cur_amr2", "=", "amr", ".", "AMR", ".", "get_amr_line", "(", "f2", ")", "\n", "if", "not", "cur_amr1", "and", "not", "cur_amr2", ":", "\n", "            ", "pass", "\n", "", "elif", "not", "cur_amr1", ":", "\n", "            ", "print", "(", "\"Error: File 1 has less AMRs than file 2\"", ",", "file", "=", "ERROR_LOG", ")", "\n", "print", "(", "\"Ignoring remaining AMRs\"", ",", "file", "=", "ERROR_LOG", ")", "\n", "", "elif", "not", "cur_amr2", ":", "\n", "            ", "print", "(", "\"Error: File 2 has less AMRs than file 1\"", ",", "file", "=", "ERROR_LOG", ")", "\n", "print", "(", "\"Ignoring remaining AMRs\"", ",", "file", "=", "ERROR_LOG", ")", "\n", "", "else", ":", "\n", "            ", "yield", "cur_amr1", ",", "cur_amr2", "\n", "continue", "\n", "", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.get_amr_match": [[659, 723], ["amr1.rename_node", "amr2.rename_node", "amr1.get_triples", "amr2.get_triples", "smatch.get_best_match", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "len", "len", "amr_pair.append", "len", "len", "len", "len", "len", "len", "smatch.print_alignment", "len", "len", "amr.AMR.parse_AMR_line", "print", "print", "print", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.rename_node", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.rename_node", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.get_triples", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.get_triples", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.get_best_match", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.print_alignment", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.parse_AMR_line"], ["", "", "def", "get_amr_match", "(", "cur_amr1", ",", "cur_amr2", ",", "sent_num", "=", "1", ",", "justinstance", "=", "False", ",", "justattribute", "=", "False", ",", "justrelation", "=", "False", ")", ":", "\n", "    ", "amr_pair", "=", "[", "]", "\n", "for", "i", ",", "cur_amr", "in", "(", "1", ",", "cur_amr1", ")", ",", "(", "2", ",", "cur_amr2", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "amr_pair", ".", "append", "(", "amr", ".", "AMR", ".", "parse_AMR_line", "(", "cur_amr", ")", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "print", "(", "\"Error in parsing amr %d: %s\"", "%", "(", "i", ",", "cur_amr", ")", ",", "file", "=", "ERROR_LOG", ")", "\n", "print", "(", "\"Please check if the AMR is ill-formatted. Ignoring remaining AMRs\"", ",", "file", "=", "ERROR_LOG", ")", "\n", "print", "(", "\"Error message: %s\"", "%", "e", ",", "file", "=", "ERROR_LOG", ")", "\n", "", "", "amr1", ",", "amr2", "=", "amr_pair", "\n", "prefix1", "=", "\"a\"", "\n", "prefix2", "=", "\"b\"", "\n", "# Rename node to \"a1\", \"a2\", .etc", "\n", "amr1", ".", "rename_node", "(", "prefix1", ")", "\n", "# Renaming node to \"b1\", \"b2\", .etc", "\n", "amr2", ".", "rename_node", "(", "prefix2", ")", "\n", "(", "instance1", ",", "attributes1", ",", "relation1", ")", "=", "amr1", ".", "get_triples", "(", ")", "\n", "(", "instance2", ",", "attributes2", ",", "relation2", ")", "=", "amr2", ".", "get_triples", "(", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"AMR pair\"", ",", "sent_num", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"============================================\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"AMR 1 (one-line):\"", ",", "cur_amr1", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"AMR 2 (one-line):\"", ",", "cur_amr2", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Instance triples of AMR 1:\"", ",", "len", "(", "instance1", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "instance1", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Attribute triples of AMR 1:\"", ",", "len", "(", "attributes1", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "attributes1", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Relation triples of AMR 1:\"", ",", "len", "(", "relation1", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "relation1", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Instance triples of AMR 2:\"", ",", "len", "(", "instance2", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "instance2", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Attribute triples of AMR 2:\"", ",", "len", "(", "attributes2", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "attributes2", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Relation triples of AMR 2:\"", ",", "len", "(", "relation2", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "relation2", ",", "file", "=", "DEBUG_LOG", ")", "\n", "# optionally turn off some of the node comparison", "\n", "", "doinstance", "=", "doattribute", "=", "dorelation", "=", "True", "\n", "if", "justinstance", ":", "\n", "        ", "doattribute", "=", "dorelation", "=", "False", "\n", "", "if", "justattribute", ":", "\n", "        ", "doinstance", "=", "dorelation", "=", "False", "\n", "", "if", "justrelation", ":", "\n", "        ", "doinstance", "=", "doattribute", "=", "False", "\n", "", "(", "best_mapping", ",", "best_match_num", ")", "=", "get_best_match", "(", "instance1", ",", "attributes1", ",", "relation1", ",", "\n", "instance2", ",", "attributes2", ",", "relation2", ",", "\n", "prefix1", ",", "prefix2", ",", "doinstance", "=", "doinstance", ",", "\n", "doattribute", "=", "doattribute", ",", "dorelation", "=", "dorelation", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"best match number\"", ",", "best_match_num", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"best node mapping\"", ",", "best_mapping", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"Best node mapping alignment:\"", ",", "print_alignment", "(", "best_mapping", ",", "instance1", ",", "instance2", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "if", "justinstance", ":", "\n", "        ", "test_triple_num", "=", "len", "(", "instance1", ")", "\n", "gold_triple_num", "=", "len", "(", "instance2", ")", "\n", "", "elif", "justattribute", ":", "\n", "        ", "test_triple_num", "=", "len", "(", "attributes1", ")", "\n", "gold_triple_num", "=", "len", "(", "attributes2", ")", "\n", "", "elif", "justrelation", ":", "\n", "        ", "test_triple_num", "=", "len", "(", "relation1", ")", "\n", "gold_triple_num", "=", "len", "(", "relation2", ")", "\n", "", "else", ":", "\n", "        ", "test_triple_num", "=", "len", "(", "instance1", ")", "+", "len", "(", "attributes1", ")", "+", "len", "(", "relation1", ")", "\n", "gold_triple_num", "=", "len", "(", "instance2", ")", "+", "len", "(", "attributes2", ")", "+", "len", "(", "relation2", ")", "\n", "", "return", "best_match_num", ",", "test_triple_num", ",", "gold_triple_num", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.score_amr_pairs": [[725, 757], ["enumerate", "smatch.generate_amr_lines", "smatch.get_amr_match", "match_triple_dict.clear", "print", "print", "print", "smatch.compute_f", "smatch.compute_f"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.generate_amr_lines", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.get_amr_match", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_f", "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.compute_f"], ["", "def", "score_amr_pairs", "(", "f1", ",", "f2", ",", "justinstance", "=", "False", ",", "justattribute", "=", "False", ",", "justrelation", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Score one pair of AMR lines at a time from each file handle\n    :param f1: file handle (or any iterable of strings) to read AMR 1 lines from\n    :param f2: file handle (or any iterable of strings) to read AMR 2 lines from\n    :param justinstance: just pay attention to matching instances\n    :param justattribute: just pay attention to matching attributes\n    :param justrelation: just pay attention to matching relations\n    :return: generator of cur_amr1, cur_amr2 pairs: one-line AMR strings\n    \"\"\"", "\n", "# matching triple number, triple number in test file, triple number in gold file", "\n", "total_match_num", "=", "total_test_num", "=", "total_gold_num", "=", "0", "\n", "# Read amr pairs from two files", "\n", "for", "sent_num", ",", "(", "cur_amr1", ",", "cur_amr2", ")", "in", "enumerate", "(", "generate_amr_lines", "(", "f1", ",", "f2", ")", ",", "start", "=", "1", ")", ":", "\n", "        ", "best_match_num", ",", "test_triple_num", ",", "gold_triple_num", "=", "get_amr_match", "(", "cur_amr1", ",", "cur_amr2", ",", "\n", "sent_num", "=", "sent_num", ",", "# sentence number", "\n", "justinstance", "=", "justinstance", ",", "\n", "justattribute", "=", "justattribute", ",", "\n", "justrelation", "=", "justrelation", ")", "\n", "total_match_num", "+=", "best_match_num", "\n", "total_test_num", "+=", "test_triple_num", "\n", "total_gold_num", "+=", "gold_triple_num", "\n", "# clear the matching triple dictionary for the next AMR pair", "\n", "match_triple_dict", ".", "clear", "(", ")", "\n", "if", "not", "single_score", ":", "# if each AMR pair should have a score, compute and output it here", "\n", "            ", "yield", "compute_f", "(", "best_match_num", ",", "test_triple_num", ",", "gold_triple_num", ")", "\n", "", "", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Total match number, total triple number in AMR 1, and total triple number in AMR 2:\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "total_match_num", ",", "total_test_num", ",", "total_gold_num", ",", "file", "=", "DEBUG_LOG", ")", "\n", "print", "(", "\"---------------------------------------------------------------------------------\"", ",", "file", "=", "DEBUG_LOG", ")", "\n", "", "if", "single_score", ":", "# output document-level smatch score (a single f-score for all AMR pairs in two files)", "\n", "        ", "yield", "compute_f", "(", "total_match_num", ",", "total_test_num", ",", "total_gold_num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.main": [[759, 793], ["smatch.score_amr_pairs", "args.f[].close", "args.f[].close", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.smatch.score_amr_pairs"], ["", "", "def", "main", "(", "arguments", ")", ":", "\n", "    ", "\"\"\"\n    Main function of smatch score calculation\n    \"\"\"", "\n", "global", "verbose", "\n", "global", "veryVerbose", "\n", "global", "iteration_num", "\n", "global", "single_score", "\n", "global", "pr_flag", "\n", "global", "match_triple_dict", "\n", "# set the iteration number", "\n", "# total iteration number = restart number + 1", "\n", "iteration_num", "=", "arguments", ".", "r", "+", "1", "\n", "if", "arguments", ".", "ms", ":", "\n", "        ", "single_score", "=", "False", "\n", "", "if", "arguments", ".", "v", ":", "\n", "        ", "verbose", "=", "True", "\n", "", "if", "arguments", ".", "vv", ":", "\n", "        ", "veryVerbose", "=", "True", "\n", "", "if", "arguments", ".", "pr", ":", "\n", "        ", "pr_flag", "=", "True", "\n", "# significant digits to print out", "\n", "", "floatdisplay", "=", "\"%%.%df\"", "%", "arguments", ".", "significant", "\n", "for", "(", "precision", ",", "recall", ",", "best_f_score", ")", "in", "score_amr_pairs", "(", "args", ".", "f", "[", "0", "]", ",", "args", ".", "f", "[", "1", "]", ",", "\n", "justinstance", "=", "arguments", ".", "justinstance", ",", "\n", "justattribute", "=", "arguments", ".", "justattribute", ",", "\n", "justrelation", "=", "arguments", ".", "justrelation", ")", ":", "\n", "# print(\"Sentence\", sent_num)", "\n", "        ", "if", "pr_flag", ":", "\n", "            ", "print", "(", "\"Precision: \"", "+", "floatdisplay", "%", "precision", ")", "\n", "print", "(", "\"Recall: \"", "+", "floatdisplay", "%", "recall", ")", "\n", "", "print", "(", "\"F-score: \"", "+", "floatdisplay", "%", "best_f_score", ")", "\n", "", "args", ".", "f", "[", "0", "]", ".", "close", "(", ")", "\n", "args", ".", "f", "[", "1", "]", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr.Node.__init__": [[6, 25], ["node.strip.strip.strip", "re.fullmatch", "dmr.Node.node_value.strip().split", "dmr.Node.node_name.strip", "re.match", "re.match", "dmr.Node.node_value.strip", "re.match.span", "re.match.span", "re.match.span"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "node", ")", ":", "\n", "        ", "self", ".", "node_name", "=", "None", "\n", "self", ".", "node_value", "=", "None", "\n", "\n", "node", "=", "node", ".", "strip", "(", ")", "\n", "# 1. only a node name, e.g. v1", "\n", "if", "re", ".", "fullmatch", "(", "r'v[\\d]+'", ",", "node", ")", ":", "\n", "            ", "self", ".", "node_name", "=", "node", "\n", "", "elif", "not", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "node", ")", ":", "\n", "# 2. constant, e.g. -", "\n", "            ", "self", ".", "node_value", "=", "node", "\n", "", "else", ":", "\n", "# 3. node name / node value, e.g. c1 / pizza", "\n", "            ", "m", "=", "re", ".", "match", "(", "r'v[\\d]+ / '", ",", "node", ")", "\n", "self", ".", "node_name", "=", "node", "[", "m", ".", "span", "(", ")", "[", "0", "]", ":", "m", ".", "span", "(", ")", "[", "1", "]", "-", "3", "]", "\n", "self", ".", "node_value", "=", "node", "[", "m", ".", "span", "(", ")", "[", "1", "]", ":", "]", "\n", "", "self", ".", "node_value", "=", "' '", ".", "join", "(", "self", ".", "node_value", ".", "strip", "(", ")", ".", "split", "(", ")", ")", "\n", "if", "self", ".", "node_name", ":", "\n", "            ", "self", ".", "node_name", "=", "self", ".", "node_name", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr.Node.__str__": [[26, 28], ["None"], "methods", ["None"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "f'({self.node_name, self.node_value})'", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr.Node.__repr__": [[29, 31], ["dmr.Node.__str__"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.dmr.DMR.read_dmr_data": [[34, 99], ["dmr.DMR", "type", "node_name_list.append", "node_value_list.append", "relation_list.append", "attribute_list.append", "attribute_list.append", "dmr.Node", "node_name_list.append", "node_value_list.append", "dmr.DMR.read_dmr_data._dfs"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "read_dmr_data", "(", "dmr_data", ")", ":", "\n", "        ", "if", "not", "dmr_data", ":", "\n", "            ", "return", "None", "\n", "\n", "# create data structures to initialize a DMR", "\n", "", "node_name_list", "=", "[", "]", "\n", "node_value_list", "=", "[", "]", "\n", "relation_list", "=", "[", "]", "\n", "attribute_list", "=", "[", "]", "\n", "if", "type", "(", "dmr_data", ")", "==", "str", ":", "\n", "            ", "node_name_list", ".", "append", "(", "'v1'", ")", "\n", "node_value_list", ".", "append", "(", "dmr_data", ")", "\n", "relation_list", ".", "append", "(", "[", "]", ")", "\n", "attribute_list", ".", "append", "(", "[", "[", "'TOP'", ",", "'top'", "]", "]", ")", "\n", "attribute_list", ".", "append", "(", "[", "]", ")", "\n", "", "else", ":", "\n", "            ", "assert", "type", "(", "dmr_data", ")", "==", "dict", "\n", "assert", "len", "(", "dmr_data", ")", "==", "1", "\n", "\n", "def", "_dfs", "(", "data", ")", ":", "\n", "                ", "triples", "=", "[", "]", "\n", "for", "n", ",", "r", "in", "data", ".", "items", "(", ")", ":", "\n", "                    ", "head_node", "=", "Node", "(", "n", ")", "\n", "for", "_r", ",", "t", "in", "r", ".", "items", "(", ")", ":", "\n", "                        ", "if", "type", "(", "t", ")", "==", "str", ":", "\n", "                            ", "tail_node", "=", "Node", "(", "t", ")", "\n", "", "else", ":", "\n", "                            ", "assert", "type", "(", "t", ")", "==", "dict", "\n", "assert", "len", "(", "t", ")", "==", "1", ",", "dmr_data", "\n", "tail_node", "=", "Node", "(", "list", "(", "t", ".", "keys", "(", ")", ")", "[", "0", "]", ")", "\n", "triples", "+=", "_dfs", "(", "t", ")", "\n", "", "triples", ".", "append", "(", "(", "head_node", ",", "_r", ",", "tail_node", ")", ")", "\n", "", "", "return", "triples", "\n", "\n", "", "root_node", "=", "Node", "(", "list", "(", "dmr_data", ".", "keys", "(", ")", ")", "[", "0", "]", ")", "\n", "node_name_list", ".", "append", "(", "root_node", ".", "node_name", ")", "\n", "node_value_list", ".", "append", "(", "root_node", ".", "node_value", ")", "\n", "\n", "triples", "=", "_dfs", "(", "dmr_data", ")", "\n", "for", "h", ",", "r", ",", "t", "in", "triples", ":", "\n", "                ", "if", "h", ".", "node_name", "and", "h", ".", "node_value", "and", "h", ".", "node_name", "not", "in", "node_name_list", ":", "\n", "                    ", "node_name_list", ".", "append", "(", "h", ".", "node_name", ")", "\n", "node_value_list", ".", "append", "(", "h", ".", "node_value", ")", "\n", "", "if", "t", ".", "node_name", "and", "t", ".", "node_value", "and", "t", ".", "node_name", "not", "in", "node_name_list", ":", "\n", "                    ", "node_name_list", ".", "append", "(", "t", ".", "node_name", ")", "\n", "node_value_list", ".", "append", "(", "t", ".", "node_value", ")", "\n", "\n", "", "", "name2idx", "=", "dict", "(", "zip", "(", "node_name_list", ",", "range", "(", "len", "(", "node_name_list", ")", ")", ")", ")", "\n", "\n", "relation_list", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "node_name_list", ")", ")", "]", "\n", "attribute_list", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "node_name_list", ")", ")", "]", "\n", "\n", "attribute_list", "[", "0", "]", ".", "append", "(", "[", "'TOP'", ",", "'top'", "]", ")", "\n", "\n", "for", "h", ",", "r", ",", "t", "in", "triples", ":", "\n", "                ", "r", "=", "r", "[", "1", ":", "]", "\n", "assert", "h", ".", "node_name", ",", "(", "dmr_data", ",", "h", ")", "\n", "if", "t", ".", "node_name", ":", "\n", "                    ", "relation_list", "[", "name2idx", "[", "h", ".", "node_name", "]", "]", ".", "append", "(", "[", "r", ",", "t", ".", "node_name", "]", ")", "\n", "", "else", ":", "\n", "                    ", "assert", "t", ".", "node_value", "\n", "attribute_list", "[", "name2idx", "[", "h", ".", "node_name", "]", "]", ".", "append", "(", "[", "r", ",", "t", ".", "node_value", "]", ")", "\n", "\n", "", "", "", "return", "DMR", "(", "node_name_list", ",", "node_value_list", ",", "relation_list", ",", "attribute_list", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.__init__": [[38, 70], ["len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "node_list", "=", "None", ",", "node_value_list", "=", "None", ",", "relation_list", "=", "None", ",", "attribute_list", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        node_list: names of nodes in AMR graph, e.g. \"a11\", \"n\"\n        node_value_list: values of nodes in AMR graph, e.g. \"group\" for a node named \"g\"\n        relation_list: list of relations between two nodes\n        attribute_list: list of attributes (links between one node and one constant value)\n\n        \"\"\"", "\n", "# initialize AMR graph nodes using list of nodes name", "\n", "# root, by default, is the first in var_list", "\n", "\n", "if", "node_list", "is", "None", ":", "\n", "            ", "self", ".", "nodes", "=", "[", "]", "\n", "self", ".", "root", "=", "None", "\n", "", "else", ":", "\n", "            ", "self", ".", "nodes", "=", "node_list", "[", ":", "]", "\n", "if", "len", "(", "node_list", ")", "!=", "0", ":", "\n", "                ", "self", ".", "root", "=", "node_list", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "self", ".", "root", "=", "None", "\n", "", "", "if", "node_value_list", "is", "None", ":", "\n", "            ", "self", ".", "node_values", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "node_values", "=", "node_value_list", "[", ":", "]", "\n", "", "if", "relation_list", "is", "None", ":", "\n", "            ", "self", ".", "relations", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "relations", "=", "relation_list", "[", ":", "]", "\n", "", "if", "attribute_list", "is", "None", ":", "\n", "            ", "self", ".", "attributes", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "attributes", "=", "attribute_list", "[", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.rename_node": [[71, 87], ["range", "enumerate", "len", "enumerate", "str"], "methods", ["None"], ["", "", "def", "rename_node", "(", "self", ",", "prefix", ")", ":", "\n", "        ", "\"\"\"\n        Rename AMR graph nodes to prefix + node_index to avoid nodes with the same name in two different AMRs.\n\n        \"\"\"", "\n", "node_map_dict", "=", "{", "}", "\n", "# map each node to its new name (e.g. \"a1\")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "            ", "node_map_dict", "[", "self", ".", "nodes", "[", "i", "]", "]", "=", "prefix", "+", "str", "(", "i", ")", "\n", "# update node name", "\n", "", "for", "i", ",", "v", "in", "enumerate", "(", "self", ".", "nodes", ")", ":", "\n", "            ", "self", ".", "nodes", "[", "i", "]", "=", "node_map_dict", "[", "v", "]", "\n", "# update node name in relations", "\n", "", "for", "node_relations", "in", "self", ".", "relations", ":", "\n", "            ", "for", "i", ",", "l", "in", "enumerate", "(", "node_relations", ")", ":", "\n", "                ", "node_relations", "[", "i", "]", "[", "1", "]", "=", "node_map_dict", "[", "l", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.get_triples": [[88, 110], ["range", "len", "instance_triple.append", "relation_triple.append", "attribute_triple.append"], "methods", ["None"], ["", "", "", "def", "get_triples", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get the triples in three lists.\n        instance_triple: a triple representing an instance. E.g. instance(w, want-01)\n        attribute triple: relation of attributes, e.g. polarity(w, - )\n        and relation triple, e.g. arg0 (w, b)\n\n        \"\"\"", "\n", "instance_triple", "=", "[", "]", "\n", "relation_triple", "=", "[", "]", "\n", "attribute_triple", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "            ", "instance_triple", ".", "append", "(", "(", "\"instance\"", ",", "self", ".", "nodes", "[", "i", "]", ",", "self", ".", "node_values", "[", "i", "]", ")", ")", "\n", "# l[0] is relation name", "\n", "# l[1] is the other node this node has relation with", "\n", "for", "l", "in", "self", ".", "relations", "[", "i", "]", ":", "\n", "                ", "relation_triple", ".", "append", "(", "(", "l", "[", "0", "]", ",", "self", ".", "nodes", "[", "i", "]", ",", "l", "[", "1", "]", ")", ")", "\n", "# l[0] is the attribute name", "\n", "# l[1] is the attribute value", "\n", "", "for", "l", "in", "self", ".", "attributes", "[", "i", "]", ":", "\n", "                ", "attribute_triple", ".", "append", "(", "(", "l", "[", "0", "]", ",", "self", ".", "nodes", "[", "i", "]", ",", "l", "[", "1", "]", ")", ")", "\n", "", "", "return", "instance_triple", ",", "attribute_triple", ",", "relation_triple", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.get_triples2": [[112, 137], ["range", "len", "instance_triple.append", "relation_triple.append", "relation_triple.append"], "methods", ["None"], ["", "def", "get_triples2", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get the triples in two lists:\n        instance_triple: a triple representing an instance. E.g. instance(w, want-01)\n        relation_triple: a triple representing all relations. E.g arg0 (w, b) or E.g. polarity(w, - )\n        Note that we do not differentiate between attribute triple and relation triple. Both are considered as relation\n        triples.\n        All triples are represented by (triple_type, argument 1 of the triple, argument 2 of the triple)\n\n        \"\"\"", "\n", "instance_triple", "=", "[", "]", "\n", "relation_triple", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "# an instance triple is instance(node name, node value).", "\n", "# For example, instance(b, boy).", "\n", "            ", "instance_triple", ".", "append", "(", "(", "\"instance\"", ",", "self", ".", "nodes", "[", "i", "]", ",", "self", ".", "node_values", "[", "i", "]", ")", ")", "\n", "# l[0] is relation name", "\n", "# l[1] is the other node this node has relation with", "\n", "for", "l", "in", "self", ".", "relations", "[", "i", "]", ":", "\n", "                ", "relation_triple", ".", "append", "(", "(", "l", "[", "0", "]", ",", "self", ".", "nodes", "[", "i", "]", ",", "l", "[", "1", "]", ")", ")", "\n", "# l[0] is the attribute name", "\n", "# l[1] is the attribute value", "\n", "", "for", "l", "in", "self", ".", "attributes", "[", "i", "]", ":", "\n", "                ", "relation_triple", ".", "append", "(", "(", "l", "[", "0", "]", ",", "self", ".", "nodes", "[", "i", "]", ",", "l", "[", "1", "]", ")", ")", "\n", "", "", "return", "instance_triple", ",", "relation_triple", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.__str__": [[139, 154], ["range", "len", "lines.append", "lines.append", "lines.append", "lines.append", "lines.append", "str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Generate AMR string for better readability\n\n        \"\"\"", "\n", "lines", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "nodes", ")", ")", ":", "\n", "            ", "lines", ".", "append", "(", "\"Node \"", "+", "str", "(", "i", ")", "+", "\" \"", "+", "self", ".", "nodes", "[", "i", "]", ")", "\n", "lines", ".", "append", "(", "\"Value: \"", "+", "self", ".", "node_values", "[", "i", "]", ")", "\n", "lines", ".", "append", "(", "\"Relations:\"", ")", "\n", "for", "relation", "in", "self", ".", "relations", "[", "i", "]", ":", "\n", "                ", "lines", ".", "append", "(", "\"Node \"", "+", "relation", "[", "1", "]", "+", "\" via \"", "+", "relation", "[", "0", "]", ")", "\n", "", "for", "attribute", "in", "self", ".", "attributes", "[", "i", "]", ":", "\n", "                ", "lines", ".", "append", "(", "\"Attribute: \"", "+", "attribute", "[", "0", "]", "+", "\" value \"", "+", "attribute", "[", "1", "]", ")", "\n", "", "", "return", "\"\\n\"", ".", "join", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.__repr__": [[155, 157], ["amr.AMR.__str__"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.output_amr": [[158, 164], ["print", "amr.AMR.__str__"], "methods", ["home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.__str__"], ["", "def", "output_amr", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Output AMR string\n\n        \"\"\"", "\n", "print", "(", "self", ".", "__str__", "(", ")", ",", "file", "=", "DEBUG_LOG", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.get_amr_line": [[165, 191], ["line.strip.strip.strip", "line.strip.strip.strip().startswith", "cur_amr.append", "line.strip.strip.strip", "line.strip.strip.strip"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_amr_line", "(", "input_f", ")", ":", "\n", "        ", "\"\"\"\n        Read the file containing AMRs. AMRs are separated by a blank line.\n        Each call of get_amr_line() returns the next available AMR (in one-line form).\n        Note: this function does not verify if the AMR is valid\n\n        \"\"\"", "\n", "cur_amr", "=", "[", "]", "\n", "has_content", "=", "False", "\n", "for", "line", "in", "input_f", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "==", "\"\"", ":", "\n", "                ", "if", "not", "has_content", ":", "\n", "# empty lines before current AMR", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "# end of current AMR", "\n", "                    ", "break", "\n", "", "", "if", "line", ".", "strip", "(", ")", ".", "startswith", "(", "\"#\"", ")", ":", "\n", "# ignore the comment line (starting with \"#\") in the AMR file", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "has_content", "=", "True", "\n", "cur_amr", ".", "append", "(", "line", ".", "strip", "(", ")", ")", "\n", "", "", "return", "\"\"", ".", "join", "(", "cur_amr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amazon-research_dialogue-meaning-representation.eval.amr.AMR.parse_AMR_line": [[192, 427], ["set", "collections.defaultdict", "collections.defaultdict", "enumerate", "attribute_list[].append", "amr.AMR", "line.strip", "relation_list.append", "attribute_list.append", "r.endswith", "node_relation_dict[].append", "print", "node_value_list.append", "node_relation_dict[].append", "node_relation_dict[].append", "cur_charseq.append", "cur_charseq.append", "node_rel_list.append", "cur_charseq.append", "node_attr_list.append", "print", "cur_charseq.append", "node_rel_list.append", "node_attr_list.append", "temp_attr_value.split", "parts[].strip", "parts[].strip", "cur_charseq.append", "stack.append", "node_name_list.append", "print", "stack.pop", "cur_charseq.append", "len", "print", "len", "print", "amr.AMR.parse_AMR_line.update_triple"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "parse_AMR_line", "(", "line", ")", ":", "\n", "        ", "\"\"\"\n        Parse a AMR from line representation to an AMR object.\n        This parsing algorithm scans the line once and process each character, in a shift-reduce style.\n\n        \"\"\"", "\n", "# Current state. It denotes the last significant symbol encountered. 1 for (, 2 for :, 3 for /,", "\n", "# and 0 for start state or ')'", "\n", "# Last significant symbol is ( --- start processing node name", "\n", "# Last significant symbol is : --- start processing relation name", "\n", "# Last significant symbol is / --- start processing node value (concept name)", "\n", "# Last significant symbol is ) --- current node processing is complete", "\n", "# Note that if these symbols are inside parenthesis, they are not significant symbols.", "\n", "\n", "exceptions", "=", "set", "(", "[", "\"prep-on-behalf-of\"", ",", "\"prep-out-of\"", ",", "\"consist-of\"", "]", ")", "\n", "def", "update_triple", "(", "node_relation_dict", ",", "u", ",", "r", ",", "v", ")", ":", "\n", "# we detect a relation (r) between u and v, with direction u to v.", "\n", "# in most cases, if relation name ends with \"-of\", e.g.\"arg0-of\",", "\n", "# it is reverse of some relation. For example, if a is \"arg0-of\" b,", "\n", "# we can also say b is \"arg0\" a.", "\n", "# If the relation name ends with \"-of\", we store the reverse relation.", "\n", "# but note some exceptions like \"prep-on-behalf-of\" and \"prep-out-of\"", "\n", "# also note relation \"mod\" is the reverse of \"domain\"", "\n", "            ", "if", "r", ".", "endswith", "(", "\"-of\"", ")", "and", "not", "r", "in", "exceptions", ":", "\n", "                ", "node_relation_dict", "[", "v", "]", ".", "append", "(", "(", "r", "[", ":", "-", "3", "]", ",", "u", ")", ")", "\n", "", "elif", "r", "==", "\"mod\"", ":", "\n", "                ", "node_relation_dict", "[", "v", "]", ".", "append", "(", "(", "\"domain\"", ",", "u", ")", ")", "\n", "", "else", ":", "\n", "                ", "node_relation_dict", "[", "u", "]", ".", "append", "(", "(", "r", ",", "v", ")", ")", "\n", "\n", "", "", "state", "=", "0", "\n", "# node stack for parsing", "\n", "stack", "=", "[", "]", "\n", "# current not-yet-reduced character sequence", "\n", "cur_charseq", "=", "[", "]", "\n", "# key: node name value: node value", "\n", "node_dict", "=", "{", "}", "\n", "# node name list (order: occurrence of the node)", "\n", "node_name_list", "=", "[", "]", "\n", "# key: node name:  value: list of (relation name, the other node name)", "\n", "node_relation_dict1", "=", "defaultdict", "(", "list", ")", "\n", "# key: node name, value: list of (attribute name, const value) or (relation name, unseen node name)", "\n", "node_relation_dict2", "=", "defaultdict", "(", "list", ")", "\n", "# current relation name", "\n", "cur_relation_name", "=", "\"\"", "\n", "# having unmatched quote string", "\n", "in_quote", "=", "False", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "line", ".", "strip", "(", ")", ")", ":", "\n", "            ", "if", "c", "==", "\" \"", ":", "\n", "# allow space in relation name", "\n", "                ", "if", "state", "==", "2", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "", "continue", "\n", "", "if", "c", "==", "\"\\\"\"", ":", "\n", "# flip in_quote value when a quote symbol is encountered", "\n", "# insert placeholder if in_quote from last symbol", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "'_'", ")", "\n", "", "in_quote", "=", "not", "in_quote", "\n", "", "elif", "c", "==", "\"(\"", ":", "\n", "# not significant symbol if inside quote", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# get the attribute name", "\n", "# e.g :arg0 (x ...", "\n", "# at this point we get \"arg0\"", "\n", "", "if", "state", "==", "2", ":", "\n", "# in this state, current relation name should be empty", "\n", "                    ", "if", "cur_relation_name", "!=", "\"\"", ":", "\n", "                        ", "print", "(", "\"Format error when processing \"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "ERROR_LOG", ")", "\n", "return", "None", "\n", "# update current relation name for future use", "\n", "", "cur_relation_name", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", ".", "strip", "(", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "", "state", "=", "1", "\n", "", "elif", "c", "==", "\":\"", ":", "\n", "# not significant symbol if inside quote", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# Last significant symbol is \"/\". Now we encounter \":\"", "\n", "# Example:", "\n", "# :OR (o2 / *OR*", "\n", "#    :mod (o3 / official)", "\n", "#  gets node value \"*OR*\" at this point", "\n", "", "if", "state", "==", "3", ":", "\n", "                    ", "node_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "# clear current char sequence", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "# pop node name (\"o2\" in the above example)", "\n", "cur_node_name", "=", "stack", "[", "-", "1", "]", "\n", "# update node name/value map", "\n", "node_dict", "[", "cur_node_name", "]", "=", "node_value", "\n", "# Last significant symbol is \":\". Now we encounter \":\"", "\n", "# Example:", "\n", "# :op1 w :quant 30", "\n", "# or :day 14 :month 3", "\n", "# the problem is that we cannot decide if node value is attribute value (constant)", "\n", "# or node value (variable) at this moment", "\n", "", "elif", "state", "==", "2", ":", "\n", "                    ", "temp_attr_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "parts", "=", "temp_attr_value", ".", "split", "(", ")", "\n", "if", "len", "(", "parts", ")", "<", "2", ":", "\n", "                        ", "print", "(", "\"Error in processing; part len < 2\"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "ERROR_LOG", ")", "\n", "return", "None", "\n", "# For the above example, node name is \"op1\", and node value is \"w\"", "\n", "# Note that this node name might not be encountered before", "\n", "", "relation_name", "=", "parts", "[", "0", "]", ".", "strip", "(", ")", "\n", "relation_value", "=", "parts", "[", "1", "]", ".", "strip", "(", ")", "\n", "# We need to link upper level node to the current", "\n", "# top of stack is upper level node", "\n", "if", "len", "(", "stack", ")", "==", "0", ":", "\n", "                        ", "print", "(", "\"Error in processing\"", ",", "line", "[", ":", "i", "]", ",", "relation_name", ",", "relation_value", ",", "file", "=", "ERROR_LOG", ")", "\n", "return", "None", "\n", "# if we have not seen this node name before", "\n", "", "if", "relation_value", "not", "in", "node_dict", ":", "\n", "                        ", "update_triple", "(", "node_relation_dict2", ",", "stack", "[", "-", "1", "]", ",", "relation_name", ",", "relation_value", ")", "\n", "", "else", ":", "\n", "                        ", "update_triple", "(", "node_relation_dict1", ",", "stack", "[", "-", "1", "]", ",", "relation_name", ",", "relation_value", ")", "\n", "", "", "state", "=", "2", "\n", "", "elif", "c", "==", "\"/\"", ":", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# Last significant symbol is \"(\". Now we encounter \"/\"", "\n", "# Example:", "\n", "# (d / default-01", "\n", "# get \"d\" here", "\n", "", "if", "state", "==", "1", ":", "\n", "                    ", "node_name", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "# if this node name is already in node_dict, it is duplicate", "\n", "if", "node_name", "in", "node_dict", ":", "\n", "                        ", "print", "(", "\"Duplicate node name \"", ",", "node_name", ",", "\" in parsing AMR\"", ",", "file", "=", "ERROR_LOG", ")", "\n", "return", "None", "\n", "# push the node name to stack", "\n", "", "stack", ".", "append", "(", "node_name", ")", "\n", "# add it to node name list", "\n", "node_name_list", ".", "append", "(", "node_name", ")", "\n", "# if this node is part of the relation", "\n", "# Example:", "\n", "# :arg1 (n / nation)", "\n", "# cur_relation_name is arg1", "\n", "# node name is n", "\n", "# we have a relation arg1(upper level node, n)", "\n", "if", "cur_relation_name", "!=", "\"\"", ":", "\n", "                        ", "update_triple", "(", "node_relation_dict1", ",", "stack", "[", "-", "2", "]", ",", "cur_relation_name", ",", "node_name", ")", "\n", "cur_relation_name", "=", "\"\"", "\n", "", "", "else", ":", "\n", "# error if in other state", "\n", "                    ", "print", "(", "\"Error in parsing AMR\"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "ERROR_LOG", ")", "\n", "return", "None", "\n", "", "state", "=", "3", "\n", "", "elif", "c", "==", "\")\"", ":", "\n", "                ", "if", "in_quote", ":", "\n", "                    ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "continue", "\n", "# stack should be non-empty to find upper level node", "\n", "", "if", "len", "(", "stack", ")", "==", "0", ":", "\n", "                    ", "print", "(", "\"Unmatched parenthesis at position\"", ",", "i", ",", "\"in processing\"", ",", "line", "[", "0", ":", "i", "+", "1", "]", ",", "file", "=", "ERROR_LOG", ")", "\n", "return", "None", "\n", "# Last significant symbol is \":\". Now we encounter \")\"", "\n", "# Example:", "\n", "# :op2 \"Brown\") or :op2 w)", "\n", "# get \\\"Brown\\\" or w here", "\n", "", "if", "state", "==", "2", ":", "\n", "                    ", "temp_attr_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "parts", "=", "temp_attr_value", ".", "split", "(", ")", "\n", "if", "len", "(", "parts", ")", "<", "2", ":", "\n", "                        ", "print", "(", "\"Error processing\"", ",", "line", "[", ":", "i", "+", "1", "]", ",", "temp_attr_value", ",", "file", "=", "ERROR_LOG", ")", "\n", "return", "None", "\n", "", "relation_name", "=", "parts", "[", "0", "]", ".", "strip", "(", ")", "\n", "relation_value", "=", "parts", "[", "1", "]", ".", "strip", "(", ")", "\n", "# attribute value not seen before", "\n", "# Note that it might be a constant attribute value, or an unseen node", "\n", "# process this after we have seen all the node names", "\n", "if", "relation_value", "not", "in", "node_dict", ":", "\n", "                        ", "update_triple", "(", "node_relation_dict2", ",", "stack", "[", "-", "1", "]", ",", "relation_name", ",", "relation_value", ")", "\n", "", "else", ":", "\n", "                        ", "update_triple", "(", "node_relation_dict1", ",", "stack", "[", "-", "1", "]", ",", "relation_name", ",", "relation_value", ")", "\n", "# Last significant symbol is \"/\". Now we encounter \")\"", "\n", "# Example:", "\n", "# :arg1 (n / nation)", "\n", "# we get \"nation\" here", "\n", "", "", "elif", "state", "==", "3", ":", "\n", "                    ", "node_value", "=", "\"\"", ".", "join", "(", "cur_charseq", ")", "\n", "cur_charseq", "[", ":", "]", "=", "[", "]", "\n", "cur_node_name", "=", "stack", "[", "-", "1", "]", "\n", "# map node name to its value", "\n", "node_dict", "[", "cur_node_name", "]", "=", "node_value", "\n", "# pop from stack, as the current node has been processed", "\n", "", "stack", ".", "pop", "(", ")", "\n", "cur_relation_name", "=", "\"\"", "\n", "state", "=", "0", "\n", "", "else", ":", "\n", "# not significant symbols, so we just shift.", "\n", "                ", "cur_charseq", ".", "append", "(", "c", ")", "\n", "#create data structures to initialize an AMR", "\n", "", "", "node_value_list", "=", "[", "]", "\n", "relation_list", "=", "[", "]", "\n", "attribute_list", "=", "[", "]", "\n", "for", "v", "in", "node_name_list", ":", "\n", "            ", "if", "v", "not", "in", "node_dict", ":", "\n", "                ", "print", "(", "\"Error: Node name not found\"", ",", "v", ",", "file", "=", "ERROR_LOG", ")", "\n", "return", "None", "\n", "", "else", ":", "\n", "                ", "node_value_list", ".", "append", "(", "node_dict", "[", "v", "]", ")", "\n", "# build relation list and attribute list for this node", "\n", "", "node_rel_list", "=", "[", "]", "\n", "node_attr_list", "=", "[", "]", "\n", "if", "v", "in", "node_relation_dict1", ":", "\n", "                ", "for", "v1", "in", "node_relation_dict1", "[", "v", "]", ":", "\n", "                    ", "node_rel_list", ".", "append", "(", "[", "v1", "[", "0", "]", ",", "v1", "[", "1", "]", "]", ")", "\n", "", "", "if", "v", "in", "node_relation_dict2", ":", "\n", "                ", "for", "v2", "in", "node_relation_dict2", "[", "v", "]", ":", "\n", "# if value is in quote, it is a constant value", "\n", "# strip the quote and put it in attribute map", "\n", "                    ", "if", "v2", "[", "1", "]", "[", "0", "]", "==", "\"\\\"\"", "and", "v2", "[", "1", "]", "[", "-", "1", "]", "==", "\"\\\"\"", ":", "\n", "                        ", "node_attr_list", ".", "append", "(", "[", "[", "v2", "[", "0", "]", "]", ",", "v2", "[", "1", "]", "[", "1", ":", "-", "1", "]", "]", ")", "\n", "# if value is a node name", "\n", "", "elif", "v2", "[", "1", "]", "in", "node_dict", ":", "\n", "                        ", "node_rel_list", ".", "append", "(", "[", "v2", "[", "0", "]", ",", "v2", "[", "1", "]", "]", ")", "\n", "", "else", ":", "\n", "                        ", "node_attr_list", ".", "append", "(", "[", "v2", "[", "0", "]", ",", "v2", "[", "1", "]", "]", ")", "\n", "# each node has a relation list and attribute list", "\n", "", "", "", "relation_list", ".", "append", "(", "node_rel_list", ")", "\n", "attribute_list", ".", "append", "(", "node_attr_list", ")", "\n", "# add TOP as an attribute. The attribute value just needs to be constant", "\n", "", "attribute_list", "[", "0", "]", ".", "append", "(", "[", "\"TOP\"", ",", "'top'", "]", ")", "\n", "result_amr", "=", "AMR", "(", "node_name_list", ",", "node_value_list", ",", "relation_list", ",", "attribute_list", ")", "\n", "return", "result_amr", "\n", "\n"]]}