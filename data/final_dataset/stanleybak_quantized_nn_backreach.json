{"home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.__init__": [[71, 81], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ",", "parent", ")", ":", "\n", "        ", "assert", "parent", "is", "None", "or", "isinstance", "(", "parent", ",", "TimerData", ")", "\n", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "total_secs", "=", "0", "\n", "self", ".", "num_calls", "=", "0", "\n", "self", ".", "last_start_time", "=", "None", "\n", "\n", "self", ".", "parent", "=", "parent", "# parent TimerData, None for top-level timers", "\n", "self", ".", "children", "=", "[", "]", "# a list of child TimerData", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.get_child": [[82, 93], ["None"], "methods", ["None"], ["", "def", "get_child", "(", "self", ",", "name", ")", ":", "\n", "        ", "'get a child timer with the given name'", "\n", "\n", "rv", "=", "None", "\n", "\n", "for", "child", "in", "self", ".", "children", ":", "\n", "            ", "if", "child", ".", "name", "==", "name", ":", "\n", "                ", "rv", "=", "child", "\n", "break", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.get_children_recursive": [[94, 106], ["rv.append", "child.get_children_recursive"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.get_children_recursive"], ["", "def", "get_children_recursive", "(", "self", ",", "name", ")", ":", "\n", "        ", "'get all decendants with the given name (returns a list of TimerData)'", "\n", "\n", "rv", "=", "[", "]", "\n", "\n", "if", "name", "==", "self", ".", "name", ":", "\n", "            ", "rv", ".", "append", "(", "self", ")", "\n", "\n", "", "for", "child", "in", "self", ".", "children", ":", "\n", "            ", "rv", "+=", "child", ".", "get_children_recursive", "(", "name", ")", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.full_name": [[107, 114], ["timerutil.TimerData.parent.full_name"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.full_name"], ["", "def", "full_name", "(", "self", ")", ":", "\n", "        ", "'get the full name of the timer (including ancestors)'", "\n", "\n", "if", "self", ".", "parent", "is", "None", ":", "\n", "            ", "return", "self", ".", "name", "\n", "\n", "", "return", "\"{}.{}\"", ".", "format", "(", "self", ".", "parent", ".", "full_name", "(", ")", ",", "self", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.tic": [[115, 124], ["time.perf_counter", "RuntimeError"], "methods", ["None"], ["", "def", "tic", "(", "self", ")", ":", "\n", "        ", "'start the timer'", "\n", "\n", "#print \"Tic({})\".format(self.name)", "\n", "if", "self", ".", "last_start_time", "is", "not", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Timer started twice: {}\"", ".", "format", "(", "self", ".", "name", ")", ")", "\n", "\n", "", "self", ".", "num_calls", "+=", "1", "\n", "self", ".", "last_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.toc": [[125, 135], ["RuntimeError", "time.perf_counter"], "methods", ["None"], ["", "def", "toc", "(", "self", ")", ":", "\n", "        ", "'stop the timer'", "\n", "\n", "#print \"Toc({})\".format(self.name)", "\n", "\n", "if", "self", ".", "last_start_time", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Timer stopped without being started: {}\"", ".", "format", "(", "self", ".", "name", ")", ")", "\n", "\n", "", "self", ".", "total_secs", "+=", "time", ".", "perf_counter", "(", ")", "-", "self", ".", "last_start_time", "\n", "self", ".", "last_start_time", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.__init__": [[147, 149], ["RuntimeError"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "'Timers is a static class; should not be instantiated'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.reset": [[150, 156], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "reset", "(", ")", ":", "\n", "        ", "'reset all timers'", "\n", "\n", "Timers", ".", "top_level_timer", "=", "None", "\n", "Timers", ".", "stack", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.disable": [[157, 162], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "disable", "(", ")", ":", "\n", "        ", "'disables timing measurements'", "\n", "\n", "Timers", ".", "enabled", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.tic": [[163, 194], ["timerutil.TimerData.tic", "Timers.stack.append", "Timers.stack[].get_child", "timerutil.TimerData", "Timers.stack[].children.append"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.tic", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.get_child"], ["", "@", "staticmethod", "\n", "def", "tic", "(", "name", ")", ":", "\n", "        ", "'start a timer'", "\n", "\n", "if", "Timers", ".", "enabled", ":", "\n", "#print(f\"> tic({name})\")", "\n", "\n", "            ", "if", "not", "Timers", ".", "stack", ":", "\n", "                ", "top", "=", "Timers", ".", "top_level_timer", "\n", "\n", "if", "top", "is", "not", "None", "and", "top", ".", "name", "!=", "name", ":", "\n", "# overwrite old top level timer", "\n", "#print(\"Overwriting old top-level timer {} with new top-level timer {}\".format(top.name, name))", "\n", "                    ", "top", "=", "Timers", ".", "top_level_timer", "=", "None", "\n", "\n", "", "td", "=", "top", "\n", "", "else", ":", "\n", "                ", "td", "=", "Timers", ".", "stack", "[", "-", "1", "]", ".", "get_child", "(", "name", ")", "\n", "\n", "# create timer object if it doesn't exist", "\n", "", "if", "td", "is", "None", ":", "\n", "                ", "parent", "=", "None", "if", "not", "Timers", ".", "stack", "else", "Timers", ".", "stack", "[", "-", "1", "]", "\n", "td", "=", "TimerData", "(", "name", ",", "parent", ")", "\n", "\n", "if", "not", "Timers", ".", "stack", ":", "\n", "                    ", "Timers", ".", "top_level_timer", "=", "td", "\n", "", "else", ":", "\n", "                    ", "Timers", ".", "stack", "[", "-", "1", "]", ".", "children", ".", "append", "(", "td", ")", "\n", "\n", "", "", "td", ".", "tic", "(", ")", "\n", "Timers", ".", "stack", ".", "append", "(", "td", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc": [[195, 213], ["Timers.stack[].toc", "Timers.stack.pop", "RuntimeError", "Timers.stack[].full_name"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.full_name"], ["", "", "@", "staticmethod", "\n", "def", "toc", "(", "name", ")", ":", "\n", "        ", "'stop a timer'", "\n", "\n", "if", "Timers", ".", "enabled", ":", "\n", "#print(f\"< toc({name})\")", "\n", "\n", "            ", "if", "not", "Timers", ".", "stack", ":", "\n", "                ", "raise", "RuntimeError", "(", "f\"Timer '{name}' was stopped, but no timers were running\"", ")", "\n", "\n", "", "assert", "Timers", ".", "stack", "[", "-", "1", "]", ".", "name", "==", "name", ",", "\"Out of order toc(). Expected to first stop timer {}\"", ".", "format", "(", "\n", "Timers", ".", "stack", "[", "-", "1", "]", ".", "full_name", "(", ")", ")", "\n", "\n", "Timers", ".", "stack", "[", "-", "1", "]", ".", "toc", "(", ")", "\n", "Timers", ".", "stack", ".", "pop", "(", ")", "\n", "", "else", ":", "\n", "            ", "assert", "not", "Timers", ".", "stack", ",", "\"Timers.enabled was False but Timers.stack non-empty: \"", "+", "f\"{[t.name for t in Timers.stack]}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.print_stats": [[214, 228], ["timerutil.Timers.print_stats_recursive", "td.get_child.get_child.get_child"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.print_stats_recursive", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.TimerData.get_child"], ["", "", "@", "staticmethod", "\n", "def", "print_stats", "(", "name", "=", "None", ",", "short", "=", "False", ")", ":", "\n", "        ", "'print statistics about performance timers to stdout'", "\n", "\n", "td", "=", "Timers", ".", "top_level_timer", "\n", "\n", "if", "name", "is", "not", "None", "and", "td", ".", "name", "!=", "name", ":", "\n", "            ", "if", "Timers", ".", "stack", ":", "\n", "                ", "td", "=", "Timers", ".", "stack", "[", "-", "1", "]", "\n", "\n", "", "td", "=", "td", ".", "get_child", "(", "name", ")", "\n", "assert", "td", ",", "f\"no direct child with name {name}\"", "\n", "\n", "", "Timers", ".", "print_stats_recursive", "(", "td", ",", "0", ",", "None", ",", "short", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.print_stats_recursive": [[229, 325], ["timerutil.Timers.print_stats_recursive.print_func"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "print_stats_recursive", "(", "td", ",", "level", ",", "total_time", ",", "short", ")", ":", "\n", "        ", "'recursively print information about a timer'", "\n", "\n", "assert", "Timers", ".", "enabled", ",", "\"Timers were disabled\"", "\n", "\n", "low_threshold", "=", "5.0", "\n", "high_threshold", "=", "25.0", "\n", "\n", "if", "level", "==", "0", ":", "\n", "            ", "total_time", "=", "td", ".", "total_secs", "\n", "\n", "", "total_time", "=", "1e-9", "if", "total_time", "<", "1e-9", "else", "total_time", "# prevent division by zero", "\n", "\n", "percent_total", "=", "100", "*", "td", ".", "total_secs", "/", "total_time", "\n", "below_threshold", "=", "False", "\n", "\n", "if", "percent_total", "<", "low_threshold", ":", "\n", "            ", "below_threshold", "=", "True", "\n", "\n", "if", "short", ":", "\n", "                ", "print_func", "=", "lambda", "_", ":", "\"\"", "\n", "", "else", ":", "\n", "                ", "def", "print_func", "(", "text", ")", ":", "\n", "                    ", "'below threshold print function'", "\n", "\n", "return", "cprint", "(", "text", ",", "'white'", ",", "attrs", "=", "[", "'dark'", "]", ")", "\n", "", "", "", "elif", "percent_total", ">", "high_threshold", ":", "\n", "            ", "def", "print_func", "(", "text", ")", ":", "\n", "                ", "'above threshold print function'", "\n", "\n", "return", "cprint", "(", "text", ",", "'red'", ",", "attrs", "=", "[", "'bold'", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "short", ":", "\n", "                ", "below_threshold", "=", "True", "# short printing has a higher threshold", "\n", "print_func", "=", "lambda", "_", ":", "\"\"", "\n", "", "else", ":", "\n", "                ", "def", "print_func", "(", "text", ")", ":", "\n", "                    ", "'within threshold print function'", "\n", "\n", "return", "cprint", "(", "text", ",", "None", ")", "\n", "\n", "", "", "", "if", "td", ".", "last_start_time", "is", "not", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Timer was never stopped: {}\"", ".", "format", "(", "td", ".", "name", ")", ")", "\n", "\n", "", "if", "td", ".", "parent", "is", "None", "or", "td", ".", "parent", ".", "total_secs", "==", "0", ":", "\n", "            ", "percent", "=", "100", "\n", "percent_str", "=", "\"\"", "\n", "", "else", ":", "\n", "            ", "percent", "=", "100", "*", "td", ".", "total_secs", "/", "td", ".", "parent", ".", "total_secs", "\n", "percent_str", "=", "\" ({:.1f}%)\"", ".", "format", "(", "percent", ")", "\n", "\n", "", "print_func", "(", "\"{}{} Time ({} calls): {:.2f} sec{}\"", ".", "format", "(", "\" \"", "*", "level", "*", "2", ",", "td", ".", "name", ".", "capitalize", "(", ")", ",", "td", ".", "num_calls", ",", "td", ".", "total_secs", ",", "percent_str", ")", ")", "\n", "\n", "if", "not", "below_threshold", ":", "\n", "# print children", "\n", "            ", "total_children_secs", "=", "0", "\n", "\n", "for", "child", "in", "td", ".", "children", ":", "\n", "                ", "total_children_secs", "+=", "child", ".", "total_secs", "\n", "\n", "Timers", ".", "print_stats_recursive", "(", "child", ",", "level", "+", "1", ",", "total_time", ",", "short", ")", "\n", "\n", "", "if", "td", ".", "children", ":", "\n", "                ", "other", "=", "td", ".", "total_secs", "-", "total_children_secs", "\n", "other_percent", "=", "100", "*", "other", "/", "td", ".", "total_secs", "\n", "\n", "percent_other", "=", "100", "*", "other", "/", "total_time", "\n", "\n", "if", "percent_other", "<", "low_threshold", ":", "\n", "                    ", "if", "short", ":", "\n", "                        ", "other_print_func", "=", "lambda", "_", ":", "\"\"", "\n", "", "else", ":", "\n", "                        ", "def", "other_print_func", "(", "text", ")", ":", "\n", "                            ", "'below threshold print function'", "\n", "\n", "return", "cprint", "(", "text", ",", "'white'", ",", "attrs", "=", "[", "'dark'", "]", ")", "\n", "", "", "", "elif", "percent_other", ">", "high_threshold", ":", "\n", "                    ", "def", "other_print_func", "(", "text", ")", ":", "\n", "                        ", "'above threshold print function'", "\n", "\n", "return", "cprint", "(", "text", ",", "'red'", ",", "attrs", "=", "[", "'bold'", ",", "'underline'", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "if", "short", ":", "\n", "                        ", "other_print_func", "=", "lambda", "_", ":", "\"\"", "\n", "", "else", ":", "\n", "                        ", "def", "other_print_func", "(", "text", ")", ":", "\n", "                            ", "'within threshold print function'", "\n", "\n", "return", "cprint", "(", "text", ",", "None", ")", "\n", "\n", "", "", "", "percent_str", "=", "\" ({:.1f}%)\"", ".", "format", "(", "other_percent", ")", "\n", "\n", "other_print_func", "(", "\"{}Other ({}): {:.2f} sec{}\"", ".", "format", "(", "\" \"", "*", "(", "level", "+", "1", ")", "*", "2", ",", "td", ".", "name", ".", "capitalize", "(", ")", ",", "other", ",", "percent_str", ")", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.timed": [[18, 67], ["isinstance", "callable", "functools.wraps", "functools.wraps", "timerutil.Timers.tic", "timerutil.Timers.toc", "timerutil.Timers.tic", "timerutil.Timers.toc", "f", "f", "timerutil.Timers.toc", "timerutil.Timers.toc"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.tic", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.tic", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc"], ["def", "timed", "(", "name_or_f", "=", "None", ")", ":", "\n", "    ", "'decorator for automatic timing of entire functions'", "\n", "\n", "if", "isinstance", "(", "name_or_f", ",", "str", ")", ":", "\n", "# use provided name", "\n", "        ", "name", "=", "name_or_f", "\n", "\n", "def", "wrap", "(", "f", ")", ":", "\n", "            ", "'wrap a function with timers'", "\n", "\n", "@", "wraps", "(", "f", ")", "\n", "def", "wrapped_f", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "                ", "'wrapped function'", "\n", "\n", "Timers", ".", "tic", "(", "name", ")", "\n", "try", ":", "\n", "                    ", "rv", "=", "f", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "except", "Exception", ":", "\n", "                    ", "Timers", ".", "toc", "(", "name", ")", "\n", "raise", "\n", "\n", "", "Timers", ".", "toc", "(", "name", ")", "\n", "return", "rv", "\n", "\n", "", "return", "wrapped_f", "\n", "\n", "", "", "else", ":", "\n", "# use default name", "\n", "        ", "assert", "callable", "(", "name_or_f", ")", "\n", "\n", "f", "=", "name_or_f", "\n", "name", "=", "f", ".", "__name__", "\n", "\n", "@", "wraps", "(", "f", ")", "\n", "def", "wrap", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "'wrapped function'", "\n", "\n", "Timers", ".", "tic", "(", "name", ")", "\n", "try", ":", "\n", "                ", "rv", "=", "f", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "except", "Exception", ":", "\n", "                ", "Timers", ".", "toc", "(", "name", ")", "\n", "\n", "raise", "\n", "\n", "", "Timers", ".", "toc", "(", "name", ")", "\n", "return", "rv", "\n", "\n", "", "", "return", "wrap", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.plotting.Plotter.__init__": [[16, 27], ["matplotlib.subplots", "matplotlib.style.use", "ax.axis"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "equal", "=", "True", ")", ":", "\n", "\n", "        ", "self", ".", "fig", ",", "self", ".", "ax_list", "=", "plt", ".", "subplots", "(", "2", ",", "3", ",", "figsize", "=", "(", "12", ",", "8", ")", ")", "\n", "\n", "if", "equal", ":", "\n", "            ", "for", "ax_row", "in", "self", ".", "ax_list", ":", "\n", "                ", "for", "ax", "in", "ax_row", ":", "\n", "                    ", "ax", ".", "axis", "(", "'equal'", ")", "\n", "\n", "", "", "", "p", "=", "'resources/bak_matplotlib.mlpstyle'", "\n", "plt", ".", "style", ".", "use", "(", "[", "'bmh'", ",", "p", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.plotting.Plotter.plot_quantization": [[28, 51], ["ax.plot", "dxs.append", "dys.append", "plotting.Plotter.plot_star"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.plotting.Plotter.plot_star"], ["", "@", "timed", "\n", "def", "plot_quantization", "(", "self", ",", "q_list", ")", ":", "\n", "        ", "\"\"\"plot quantized states\"\"\"", "\n", "\n", "dxs", "=", "[", "]", "\n", "dys", "=", "[", "]", "\n", "#vxos = []", "\n", "#vyos = []", "\n", "#vxis = []", "\n", "\n", "for", "qstate", ",", "qstar", "in", "q_list", ":", "\n", "            ", "dx", ",", "dy", "=", "qstate", "[", ":", "2", "]", "\n", "\n", "dxs", ".", "append", "(", "dx", ")", "\n", "dys", ".", "append", "(", "dy", ")", "\n", "#vxis.append(vxi)", "\n", "\n", "# plot qstar", "\n", "self", ".", "plot_star", "(", "qstar", ",", "'r'", ")", "\n", "\n", "# dx/dy plot", "\n", "", "ax", "=", "self", ".", "ax_list", "[", "1", "]", "[", "0", "]", "\n", "ax", ".", "plot", "(", "dxs", ",", "dys", ",", "\"go\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.plotting.Plotter.plot_star": [[56, 128], ["range", "ax.set_xlabel", "ax.set_ylabel", "numpy.zeros", "numpy.zeros", "star.verts", "ax.plot", "ax.plot", "ax.set_xlabel", "ax.set_ylabel", "numpy.zeros", "numpy.zeros", "star.verts", "ax.plot", "ax.set_xlabel", "ax.set_ylabel", "star.verts", "ax.plot", "numpy.zeros", "star.verts", "ax.plot", "star.get_witness", "ax.set_xlabel", "ax.set_ylabel", "star.verts", "ax.plot", "ax.plot", "zip", "zip", "zip", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.verts", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.verts", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.verts", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.verts", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.get_witness", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.verts", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot"], ["", "@", "timed", "\n", "def", "plot_star", "(", "self", ",", "star", ",", "color", "=", "'k'", ",", "zorder", "=", "1", ")", ":", "\n", "        ", "\"\"\"add the current state to the plot\"\"\"", "\n", "\n", "labels", "=", "(", "\"X_own\"", ",", "\"Y_own\"", ",", "\"VX_own\"", ",", "\"VY_own\"", ",", "\"X_int\"", ",", "\"VX_int\"", ")", "\n", "index", "=", "0", "\n", "\n", "witness", "=", "star", ".", "get_witness", "(", ")", "[", "1", "]", "\n", "\n", "for", "index", "in", "range", "(", "3", ")", ":", "\n", "            ", "ax", "=", "self", ".", "ax_list", "[", "0", "]", "[", "index", "]", "\n", "\n", "ax", ".", "set_xlabel", "(", "labels", "[", "2", "*", "index", "]", ")", "\n", "ax", ".", "set_ylabel", "(", "labels", "[", "2", "*", "index", "+", "1", "]", ")", "\n", "\n", "verts", "=", "star", ".", "verts", "(", "2", "*", "index", ",", "2", "*", "index", "+", "1", ")", "\n", "ax", ".", "plot", "(", "*", "zip", "(", "*", "verts", ")", ",", "'-'", ",", "color", "=", "color", ",", "zorder", "=", "zorder", ")", "\n", "\n", "ax", ".", "plot", "(", "[", "witness", "[", "2", "*", "index", "]", "]", ",", "[", "witness", "[", "2", "*", "index", "+", "1", "]", "]", ",", "'o'", ",", "color", "=", "color", ",", "zorder", "=", "zorder", ")", "\n", "\n", "# plot 4: deltax / deltay", "\n", "# dx = x_int - x_own", "\n", "", "ax", "=", "self", ".", "ax_list", "[", "1", "]", "[", "0", "]", "\n", "\n", "ax", ".", "set_xlabel", "(", "\"dx (x_int - x_own)\"", ")", "\n", "ax", ".", "set_ylabel", "(", "\"dy (y_int - y_own)\"", ")", "\n", "\n", "xdim", "=", "np", ".", "zeros", "(", "Star", ".", "NUM_VARS", ")", "\n", "xdim", "[", "Star", ".", "X_INT", "]", "=", "1", "\n", "xdim", "[", "Star", ".", "X_OWN", "]", "=", "-", "1", "\n", "\n", "ydim", "=", "np", ".", "zeros", "(", "Star", ".", "NUM_VARS", ")", "\n", "#ydim[Star.Y_INT] = 1 # Y_int is always 0", "\n", "ydim", "[", "Star", ".", "Y_OWN", "]", "=", "-", "1", "\n", "\n", "verts", "=", "star", ".", "verts", "(", "xdim", ",", "ydim", ")", "\n", "ax", ".", "plot", "(", "*", "zip", "(", "*", "verts", ")", ",", "'-'", ",", "color", "=", "color", ",", "zorder", "=", "zorder", ")", "\n", "\n", "proj_witness_dx", "=", "xdim", "@", "witness", "\n", "proj_witness_dy", "=", "ydim", "@", "witness", "\n", "ax", ".", "plot", "(", "[", "proj_witness_dx", "]", ",", "[", "proj_witness_dy", "]", ",", "'o'", ",", "color", "=", "color", ",", "zorder", "=", "zorder", ")", "\n", "\n", "# plot 5: deltavx / deltavy", "\n", "# dvx = vx_int - vx_own", "\n", "ax", "=", "self", ".", "ax_list", "[", "1", "]", "[", "1", "]", "\n", "\n", "ax", ".", "set_xlabel", "(", "\"dvx (vx_int - vx_own)\"", ")", "\n", "ax", ".", "set_ylabel", "(", "\"dvy (vy_int - vy_own)\"", ")", "\n", "\n", "xdim", "=", "np", ".", "zeros", "(", "Star", ".", "NUM_VARS", ")", "\n", "xdim", "[", "Star", ".", "VX_INT", "]", "=", "1", "\n", "xdim", "[", "Star", ".", "VX_OWN", "]", "=", "-", "1", "\n", "\n", "ydim", "=", "np", ".", "zeros", "(", "Star", ".", "NUM_VARS", ")", "\n", "#ydim[Star.Y_INT] = 1 # Y_int is always 0", "\n", "ydim", "[", "Star", ".", "VY_OWN", "]", "=", "-", "1", "\n", "\n", "verts", "=", "star", ".", "verts", "(", "xdim", ",", "ydim", ")", "\n", "ax", ".", "plot", "(", "*", "zip", "(", "*", "verts", ")", ",", "'-'", ",", "color", "=", "color", ",", "zorder", "=", "zorder", ")", "\n", "\n", "# plot 6: x and y position of both int and ownship", "\n", "ax", "=", "self", ".", "ax_list", "[", "1", "]", "[", "2", "]", "\n", "\n", "ax", ".", "set_xlabel", "(", "\"X\"", ")", "\n", "ax", ".", "set_ylabel", "(", "\"Y\"", ")", "\n", "\n", "verts", "=", "star", ".", "verts", "(", "Star", ".", "X_OWN", ",", "Star", ".", "Y_OWN", ")", "\n", "ax", ".", "plot", "(", "*", "zip", "(", "*", "verts", ")", ",", "'-'", ",", "color", "=", "color", ",", "zorder", "=", "zorder", ")", "\n", "\n", "ydim", "=", "np", ".", "zeros", "(", "Star", ".", "NUM_VARS", ")", "\n", "verts", "=", "star", ".", "verts", "(", "Star", ".", "X_INT", ",", "ydim", ")", "\n", "ax", ".", "plot", "(", "*", "zip", "(", "*", "verts", ")", ",", "'b-o'", ",", "zorder", "=", "zorder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.plotting.get_airplane_img": [[129, 136], ["functools.lru_cache", "matplotlib.imread"], "function", ["None"], ["", "", "@", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "get_airplane_img", "(", ")", ":", "\n", "    ", "\"\"\"load airplane image form file\"\"\"", "\n", "\n", "img", "=", "plt", ".", "imread", "(", "'airplane.png'", ")", "\n", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.get_cmd": [[21, 92], ["functools.lru_cache", "isinstance", "numpy.sqrt", "isinstance", "math.atan2", "numpy.array", "networks.run_network", "int", "int", "print", "numpy.argmin"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.run_network"], ["@", "lru_cache", "(", "maxsize", "=", "int", "(", "1e6", ")", ")", "\n", "@", "timed", "\n", "def", "get_cmd", "(", "alpha_prev", ",", "tau_index", ",", "qdx", ",", "qdy", ",", "qtheta1", ",", "qv_own", ",", "qv_int", ",", "stdout", "=", "False", ")", "->", "int", ":", "\n", "    ", "\"\"\"get the command at the given quantized state\n\n    returns cmd\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "alpha_prev", ",", "int", ")", "and", "0", "<=", "alpha_prev", "<=", "4", ",", "f\"alpha_prev was {alpha_prev}\"", "\n", "assert", "isinstance", "(", "qdx", ",", "int", ")", "\n", "assert", "0", "<=", "tau_index", "<=", "8", ",", "f\"tau_index out of bounds: {tau_index}\"", "\n", "\n", "pos_quantum", "=", "Settings", ".", "pos_q", "\n", "vel_quantum", "=", "Settings", ".", "vel_q", "\n", "theta1_quantum", "=", "Settings", ".", "theta1_q", "\n", "\n", "# convert quantized state to floats", "\n", "dx", "=", "pos_quantum", "/", "2", "+", "pos_quantum", "*", "qdx", "\n", "dy", "=", "pos_quantum", "/", "2", "+", "pos_quantum", "*", "qdy", "\n", "theta1", "=", "theta1_quantum", "/", "2", "+", "theta1_quantum", "*", "qtheta1", "\n", "theta2", "=", "0", "\n", "\n", "if", "vel_quantum", "!=", "0", ":", "\n", "        ", "v_own", "=", "vel_quantum", "/", "2", "+", "qv_own", "*", "vel_quantum", "\n", "v_int", "=", "vel_quantum", "/", "2", "+", "qv_int", "*", "vel_quantum", "\n", "", "else", ":", "\n", "        ", "v_own", "=", "qv_own", "\n", "v_int", "=", "qv_int", "\n", "\n", "# dx is intruder - ownship", "\n", "\n", "# convert to network input", "\n", "", "rho", "=", "np", ".", "sqrt", "(", "dx", "*", "dx", "+", "dy", "*", "dy", ")", "\n", "\n", "if", "rho", ">", "60760", ":", "\n", "        ", "cmd", "=", "0", "\n", "", "else", ":", "\n", "        ", "theta", "=", "atan2", "(", "dy", ",", "dx", ")", "\n", "\n", "# compute thetas from velocities?", "\n", "#theta1 = atan2(vyo, vxo)", "\n", "#theta2 = atan2(vyi, vxi)", "\n", "psi", "=", "theta2", "-", "theta1", "\n", "#print(f\"dvy = {dvy}, dvx = {dvx}, psi = {psi}\")", "\n", "\n", "theta", "-=", "theta1", "# angle to intruder relative to ownship heading direction", "\n", "\n", "# get angles into range", "\n", "while", "theta", "<", "-", "np", ".", "pi", ":", "\n", "            ", "theta", "+=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "theta", ">", "np", ".", "pi", ":", "\n", "            ", "theta", "-=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "psi", "<", "-", "np", ".", "pi", ":", "\n", "            ", "psi", "+=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "psi", ">", "np", ".", "pi", ":", "\n", "            ", "psi", "-=", "2", "*", "np", ".", "pi", "\n", "\n", "", "qinput", "=", "(", "rho", ",", "theta", ",", "psi", ",", "v_own", ",", "v_int", ")", "\n", "\n", "if", "stdout", ":", "\n", "            ", "print", "(", "f\"qinput: {qinput}\"", ")", "\n", "\n", "", "i", "=", "np", ".", "array", "(", "qinput", ")", "\n", "\n", "out", "=", "run_network", "(", "alpha_prev", ",", "tau_index", ",", "i", ")", "\n", "cmd", "=", "int", "(", "np", ".", "argmin", "(", "out", ")", ")", "\n", "\n", "", "return", "cmd", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.get_cmd_continuous": [[93, 139], ["numpy.sqrt", "isinstance", "math.atan2", "numpy.array", "networks.run_network", "int", "numpy.argmin"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.run_network"], ["", "def", "get_cmd_continuous", "(", "alpha_prev", ",", "tau_index", ",", "dx", ",", "dy", ",", "theta1", ",", "v_own", ",", "v_int", ")", "->", "int", ":", "\n", "    ", "\"\"\"get the command at the given continuous state\n\n    returns cmd\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "alpha_prev", ",", "int", ")", "and", "0", "<=", "alpha_prev", "<=", "4", ",", "f\"alpha_prev was {alpha_prev}\"", "\n", "\n", "# convert quantized state to floats", "\n", "theta2", "=", "0", "\n", "\n", "# dx is intruder - ownship", "\n", "\n", "# convert to network input", "\n", "rho", "=", "np", ".", "sqrt", "(", "dx", "*", "dx", "+", "dy", "*", "dy", ")", "\n", "\n", "if", "rho", ">", "60760", ":", "\n", "        ", "cmd", "=", "0", "\n", "", "else", ":", "\n", "        ", "theta", "=", "atan2", "(", "dy", ",", "dx", ")", "\n", "\n", "psi", "=", "theta2", "-", "theta1", "\n", "\n", "theta", "-=", "theta1", "# angle to intruder relative to ownship heading direction", "\n", "\n", "# get angles into range", "\n", "while", "theta", "<", "-", "np", ".", "pi", ":", "\n", "            ", "theta", "+=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "theta", ">", "np", ".", "pi", ":", "\n", "            ", "theta", "-=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "psi", "<", "-", "np", ".", "pi", ":", "\n", "            ", "psi", "+=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "psi", ">", "np", ".", "pi", ":", "\n", "            ", "psi", "-=", "2", "*", "np", ".", "pi", "\n", "\n", "", "net_input", "=", "(", "rho", ",", "theta", ",", "psi", ",", "v_own", ",", "v_int", ")", "\n", "\n", "i", "=", "np", ".", "array", "(", "net_input", ")", "\n", "\n", "out", "=", "run_network", "(", "alpha_prev", ",", "tau_index", ",", "i", ")", "\n", "cmd", "=", "int", "(", "np", ".", "argmin", "(", "out", ")", ")", "\n", "\n", "", "return", "cmd", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.run_network": [[140, 168], ["networks.get_network", "networks.get_scaling", "range", "numpy.array", "get_network.run", "print"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.get_network", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.get_scaling"], ["", "@", "timed", "\n", "def", "run_network", "(", "alpha_prev", ",", "tau_index", ",", "x", ",", "stdout", "=", "False", ")", ":", "\n", "    ", "'run the network and return the output'", "\n", "\n", "# cached", "\n", "session", "=", "get_network", "(", "alpha_prev", ",", "tau_index", ")", "\n", "\n", "range_for_scaling", ",", "means_for_scaling", "=", "get_scaling", "(", ")", "\n", "\n", "tol", "=", "1e-2", "\n", "min_inputs", "=", "[", "0", ",", "-", "pi", ",", "-", "pi", ",", "100", ",", "0", "]", "\n", "max_inputs", "=", "[", "60760", ",", "pi", ",", "pi", ",", "1200", ",", "1200", "]", "\n", "\n", "# normalize input", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "        ", "assert", "min_inputs", "[", "i", "]", "-", "tol", "<=", "x", "[", "i", "]", "<=", "max_inputs", "[", "i", "]", "+", "tol", ",", "f\"network input input {i} out of bounds. got \"", "+", "f\"{x[i]}, valid range: {min_inputs[i], max_inputs[i]}\"", "\n", "\n", "x", "[", "i", "]", "=", "(", "x", "[", "i", "]", "-", "means_for_scaling", "[", "i", "]", ")", "/", "range_for_scaling", "[", "i", "]", "\n", "\n", "", "if", "stdout", ":", "\n", "        ", "print", "(", "f\"input (after scaling): {x}\"", ")", "\n", "\n", "", "in_array", "=", "np", ".", "array", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "in_array", ".", "shape", "=", "(", "1", ",", "1", ",", "1", ",", "5", ")", "\n", "outputs", "=", "session", ".", "run", "(", "None", ",", "{", "'input'", ":", "in_array", "}", ")", "\n", "\n", "return", "outputs", "[", "0", "]", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.get_scaling": [[169, 177], ["functools.lru_cache"], "function", ["None"], ["", "@", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "get_scaling", "(", ")", ":", "\n", "    ", "\"\"\"get scaling params\"\"\"", "\n", "\n", "means_for_scaling", "=", "(", "19791.091", ",", "0.0", ",", "0.0", ",", "650.0", ",", "600.0", ",", "7.5188840201005975", ")", "\n", "range_for_scaling", "=", "(", "60261.0", ",", "6.28318530718", ",", "6.28318530718", ",", "1100.0", ",", "1200.0", ")", "\n", "\n", "return", "range_for_scaling", ",", "means_for_scaling", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.get_network": [[178, 193], ["functools.lru_cache", "os.path.join", "onnxruntime.InferenceSession", "numpy.array", "ort.InferenceSession.run"], "function", ["None"], ["", "@", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "get_network", "(", "alpha_prev", ",", "tau_index", ")", ":", "\n", "    ", "'''load the one neural network as an ort session'''", "\n", "\n", "onnx_filename", "=", "f\"ACASXU_run2a_{alpha_prev + 1}_{tau_index + 1}_batch_2000.onnx\"", "\n", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "\"resources\"", ",", "onnx_filename", ")", "\n", "session", "=", "ort", ".", "InferenceSession", "(", "path", ")", "\n", "\n", "# warm up the network", "\n", "i", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "i", ".", "shape", "=", "(", "1", ",", "1", ",", "1", ",", "5", ")", "\n", "session", ".", "run", "(", "None", ",", "{", "'input'", ":", "i", "}", ")", "\n", "\n", "return", "session", "\n", "", ""]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._get_orthonormal_rank": [[11, 29], ["numpy.linalg.svd", "len", "len"], "function", ["None"], ["def", "_get_orthonormal_rank", "(", "vecs", ",", "tol", "=", "1e-7", ")", ":", "\n", "    ", "'''\n    given a list of vecs, return a new vector orthonormal to them and the rank of the matrix\n    '''", "\n", "\n", "_", ",", "s", ",", "v", "=", "np", ".", "linalg", ".", "svd", "(", "vecs", ")", "\n", "\n", "index", "=", "0", "\n", "\n", "while", "index", "<", "len", "(", "s", ")", "and", "s", "[", "index", "]", ">", "tol", ":", "\n", "        ", "index", "+=", "1", "\n", "\n", "", "if", "index", "==", "len", "(", "v", ")", ":", "\n", "        ", "rv_vec", "=", "None", "# the vectors span the space", "\n", "", "else", ":", "\n", "        ", "rv_vec", "=", "v", "[", "index", "]", "\n", "\n", "", "return", "rv_vec", ",", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._get_rank": [[30, 34], ["kamenev._get_orthonormal_rank"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._get_orthonormal_rank"], ["", "def", "_get_rank", "(", "vecs", ",", "tol", "=", "1e-7", ")", ":", "\n", "    ", "'''get the rank of the passed in matrix'''", "\n", "\n", "return", "_get_orthonormal_rank", "(", "vecs", ",", "tol", "=", "tol", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._find_two_points": [[35, 61], ["range", "numpy.array", "supp_point_func", "numpy.array", "supp_point_func", "len", "numpy.allclose", "len", "range", "range"], "function", ["None"], ["", "def", "_find_two_points", "(", "dims", ",", "supp_point_func", ")", ":", "\n", "    ", "'''find two points in the the convex set defined through supp_point_func (which may be degenerate)\n\n    if len(pts) == 1, the convex set is a degenerate set consisting of a single pt\n    '''", "\n", "\n", "pts", "=", "[", "]", "\n", "\n", "for", "d", "in", "range", "(", "dims", ")", ":", "\n", "        ", "vec", "=", "np", ".", "array", "(", "[", "-", "1", "if", "i", "==", "d", "else", "0", "for", "i", "in", "range", "(", "dims", ")", "]", ",", "dtype", "=", "float", ")", "\n", "\n", "# try min", "\n", "p1", "=", "supp_point_func", "(", "vec", ")", "\n", "assert", "len", "(", "p1", ")", "==", "dims", ",", "f\"support fuction returned {len(p1)}-dimensional point, expected {dims}-d\"", "\n", "\n", "pts", "=", "[", "p1", "]", "\n", "\n", "# try max", "\n", "vec", "=", "np", ".", "array", "(", "[", "1", "if", "i", "==", "d", "else", "0", "for", "i", "in", "range", "(", "dims", ")", "]", ",", "dtype", "=", "float", ")", "\n", "p2", "=", "supp_point_func", "(", "vec", ")", "\n", "\n", "if", "not", "np", ".", "allclose", "(", "p1", ",", "p2", ")", ":", "\n", "            ", "pts", "=", "[", "p1", ",", "p2", "]", "\n", "break", "\n", "\n", "", "", "return", "pts", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._find_init_simplex": [[62, 107], ["kamenev._find_two_points", "len", "range", "kamenev._get_orthonormal_rank", "supp_point_func", "vecs.append", "supp_point_func", "vecs.append", "vecs.append", "degenerate_dirs.append", "kamenev._get_rank", "_find_two_points.append", "spanning_dirs.append", "kamenev._get_rank", "_find_two_points.append", "spanning_dirs.append"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._find_two_points", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._get_orthonormal_rank", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._get_rank", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._get_rank"], ["", "def", "_find_init_simplex", "(", "dims", ",", "supp_point_func", ")", ":", "\n", "    ", "'''\n    find an n-dimensional initial simplex\n    '''", "\n", "\n", "# first, construct the initial simplex and determine a basis for the convex set (it may be degenerate)", "\n", "init_simplex", "=", "_find_two_points", "(", "dims", ",", "supp_point_func", ")", "\n", "\n", "if", "len", "(", "init_simplex", ")", "==", "2", ":", "# if len == 1, S may be a degenerate shape consisting of a single point", "\n", "        ", "init_vec", "=", "init_simplex", "[", "1", "]", "-", "init_simplex", "[", "0", "]", "\n", "\n", "spanning_dirs", "=", "[", "init_vec", "]", "\n", "degenerate_dirs", "=", "[", "]", "\n", "vecs", "=", "[", "init_vec", "]", "\n", "\n", "for", "_", "in", "range", "(", "dims", "-", "1", ")", ":", "\n", "            ", "new_dir", ",", "rank", "=", "_get_orthonormal_rank", "(", "vecs", ")", "\n", "\n", "# min/max in direction v, checking if it increases the rank of vecs", "\n", "pt", "=", "supp_point_func", "(", "new_dir", ")", "\n", "vecs", ".", "append", "(", "pt", "-", "init_simplex", "[", "0", "]", ")", "\n", "\n", "if", "_get_rank", "(", "vecs", ")", ">", "rank", ":", "\n", "                ", "init_simplex", ".", "append", "(", "pt", ")", "\n", "spanning_dirs", ".", "append", "(", "vecs", "[", "-", "1", "]", ")", "\n", "continue", "\n", "\n", "# rank did not increase with maximize, try minimize", "\n", "", "vecs", "=", "vecs", "[", "0", ":", "-", "1", "]", "# pop vec", "\n", "\n", "pt", "=", "supp_point_func", "(", "-", "1", "*", "new_dir", ")", "\n", "vecs", ".", "append", "(", "pt", "-", "init_simplex", "[", "0", "]", ")", "\n", "\n", "if", "_get_rank", "(", "vecs", ")", ">", "rank", ":", "\n", "                ", "init_simplex", ".", "append", "(", "pt", ")", "\n", "spanning_dirs", ".", "append", "(", "vecs", "[", "-", "1", "]", ")", "\n", "continue", "\n", "\n", "# rank still didn't increase, new_dir is orthogonal to shape S", "\n", "", "vecs", "=", "vecs", "[", "0", ":", "-", "1", "]", "# pop vec", "\n", "\n", "vecs", ".", "append", "(", "new_dir", ")", "# forces a new orthonormal direction during the next iteration", "\n", "degenerate_dirs", ".", "append", "(", "new_dir", ")", "\n", "\n", "", "", "return", "init_simplex", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev.get_verts": [[108, 139], ["kamenev._find_init_simplex", "kamenev._v_h_rep_given_init_simplex", "len", "scipy.spatial.ConvexHull", "rv.append", "max", "rv.append"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._find_init_simplex", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._v_h_rep_given_init_simplex"], ["", "def", "get_verts", "(", "dims", ",", "supp_point_func", ",", "epsilon", "=", "1e-7", ")", ":", "\n", "    ", "'''\n    get the n-dimensional vertices of the convex set defined through supp_point_func (which may be degenerate)\n    '''", "\n", "\n", "init_simplex", "=", "_find_init_simplex", "(", "dims", ",", "supp_point_func", ")", "\n", "\n", "if", "len", "(", "init_simplex", ")", "<", "3", ":", "\n", "        ", "return", "init_simplex", "# for 0-d and 1-d sets, the init_simplex corners are the only possible extreme points", "\n", "\n", "", "pts", ",", "_", "=", "_v_h_rep_given_init_simplex", "(", "init_simplex", ",", "supp_point_func", ",", "epsilon", "=", "epsilon", ")", "\n", "\n", "if", "dims", "==", "2", ":", "\n", "# make sure verts are in order (for 2-d plotting)", "\n", "        ", "rv", "=", "[", "]", "\n", "\n", "hull", "=", "ConvexHull", "(", "pts", ")", "\n", "\n", "#rv = hull.points", "\n", "max_y", "=", "-", "np", ".", "inf", "\n", "for", "v", "in", "hull", ".", "vertices", ":", "\n", "            ", "max_y", "=", "max", "(", "max_y", ",", "hull", ".", "points", "[", "v", ",", "1", "]", ")", "\n", "\n", "rv", ".", "append", "(", "hull", ".", "points", "[", "v", "]", ")", "\n", "\n", "", "rv", ".", "append", "(", "rv", "[", "0", "]", ")", "\n", "\n", "", "else", ":", "\n", "        ", "rv", "=", "pts", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev._v_h_rep_given_init_simplex": [[140, 194], ["len", "scipy.spatial.ConvexHull", "enumerate", "numpy.array", "supp_point_func", "max", "numpy.dot", "new_pts.append"], "function", ["None"], ["", "def", "_v_h_rep_given_init_simplex", "(", "init_simplex", ",", "supp_point_func", ",", "epsilon", "=", "1e-7", ")", ":", "\n", "    ", "'''get all the vertices and hyperplanes of (an epsilon approximation of) the set, defined through supp_point_func\n\n    This function is provided with an initial simplex which spans the space\n\n    this returns verts, equations, where equations is from the Convex Hull's (hull.equations)\n    '''", "\n", "\n", "new_pts", "=", "init_simplex", "\n", "\n", "verts", "=", "[", "]", "\n", "iteration", "=", "0", "\n", "max_error", "=", "None", "\n", "\n", "while", "new_pts", ":", "\n", "        ", "iteration", "+=", "1", "\n", "#print(f\"\\nIteration {iteration}. Verts: {len(verts)}, new_pts: {len(new_pts)}, max_error: {max_error}\")", "\n", "\n", "first_new_index", "=", "len", "(", "verts", ")", "\n", "verts", "+=", "new_pts", "\n", "new_pts", "=", "[", "]", "\n", "max_error", "=", "0", "\n", "\n", "hull", "=", "ConvexHull", "(", "verts", ")", "\n", "\n", "for", "i", ",", "simplex", "in", "enumerate", "(", "hull", ".", "simplices", ")", ":", "\n", "            ", "is_new", "=", "False", "\n", "\n", "for", "index", "in", "simplex", ":", "\n", "                ", "if", "index", ">=", "first_new_index", ":", "\n", "                    ", "is_new", "=", "True", "\n", "break", "\n", "\n", "", "", "if", "not", "is_new", ":", "\n", "                ", "continue", "# skip this simplex", "\n", "\n", "# get hyperplane for simplex", "\n", "", "normal", "=", "hull", ".", "equations", "[", "i", ",", ":", "-", "1", "]", "\n", "rhs", "=", "-", "1", "*", "hull", ".", "equations", "[", "i", ",", "-", "1", "]", "\n", "\n", "supporting_pt", "=", "supp_point_func", "(", "normal", ")", "\n", "\n", "error", "=", "np", ".", "dot", "(", "supporting_pt", ",", "normal", ")", "-", "rhs", "\n", "max_error", "=", "max", "(", "max_error", ",", "error", ")", "\n", "\n", "#assert error >= -1e-7, \"supporting point was inside facet?\"", "\n", "\n", "if", "error", ">=", "epsilon", ":", "\n", "# add the point... at this point points may be added twice... this doesn't seem to matter", "\n", "                ", "new_pts", ".", "append", "(", "supporting_pt", ")", "\n", "\n", "#points[hull.vertices]", "\n", "\n", "", "", "", "return", "np", ".", "array", "(", "verts", ",", "dtype", "=", "float", ")", ",", "hull", ".", "equations", "\n", "", ""]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.__init__": [[285, 313], ["numpy.array", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "init_vec", ",", "tau_init", ",", "tau_dot", ",", "save_states", "=", "False", ")", ":", "\n", "        ", "assert", "len", "(", "init_vec", ")", "==", "8", ",", "\"init vec should have length 8\"", "\n", "assert", "tau_dot", "in", "[", "0", ",", "-", "1", "]", "\n", "\n", "self", ".", "tau_dot", "=", "tau_dot", "\n", "self", ".", "tau_init", "=", "tau_init", "\n", "self", ".", "time", "=", "0", "\n", "\n", "self", ".", "state8", "=", "np", ".", "array", "(", "init_vec", ",", "dtype", "=", "float", ")", "# current state", "\n", "self", ".", "next_nn_update", "=", "0.0", "\n", "self", ".", "command", "=", "0", "# initial command", "\n", "\n", "# these are set when simulation() if save_states=True", "\n", "self", ".", "save_states", "=", "save_states", "\n", "self", ".", "vec_list", "=", "[", "]", "# state history", "\n", "self", ".", "commands", "=", "[", "]", "# commands history", "\n", "self", ".", "int_commands", "=", "[", "]", "# intruder command history", "\n", "\n", "self", ".", "qinputs", "=", "[", "]", "\n", "\n", "# used only if plotting", "\n", "self", ".", "artists_dict", "=", "{", "}", "# set when make_artists is called", "\n", "self", ".", "img", "=", "None", "# assigned if plotting", "\n", "\n", "# assigned by simulate()", "\n", "self", ".", "u_list", "=", "[", "]", "\n", "self", ".", "u_list_index", "=", "None", "\n", "self", ".", "min_dist", "=", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.artists_list": [[314, 318], ["list", "replay.State.artists_dict.values"], "methods", ["None"], ["", "def", "artists_list", "(", "self", ")", ":", "\n", "        ", "'return list of artists'", "\n", "\n", "return", "list", "(", "self", ".", "artists_dict", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.set_plane_visible": [[319, 326], ["replay.State.artists_dict[].set_visible", "replay.State.artists_dict[].set_visible", "replay.State.artists_dict[].set_visible", "replay.State.artists_dict[].set_visible"], "methods", ["None"], ["", "def", "set_plane_visible", "(", "self", ",", "vis", ")", ":", "\n", "        ", "'set ownship plane visibility status'", "\n", "\n", "self", ".", "artists_dict", "[", "'dot0'", "]", ".", "set_visible", "(", "not", "vis", ")", "\n", "self", ".", "artists_dict", "[", "'circle0'", "]", ".", "set_visible", "(", "False", ")", "# circle always False", "\n", "self", ".", "artists_dict", "[", "'lc0'", "]", ".", "set_visible", "(", "True", ")", "\n", "self", ".", "artists_dict", "[", "'plane0'", "]", ".", "set_visible", "(", "vis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.update_artists": [[327, 382], ["math.atan2", "math.atan2", "zip", "rv.append", "rv.append", "replay.State.update_lc_artists", "rv.append", "plane.get_visible", "dot.set_data", "cir.set_center", "list", "scipy.ndimage.rotate", "list", "plane.set_data", "matplotlib.transforms.Bbox.from_bounds", "matplotlib.transforms.TransformedBbox", "zip"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_lc_artists"], ["", "def", "update_artists", "(", "self", ",", "axes", ",", "plane_index", "=", "None", ")", ":", "\n", "        ", "'''update artists in self.artists_dict to be consistant with self.vec, returns a list of artists'''", "\n", "\n", "assert", "self", ".", "artists_dict", "\n", "rv", "=", "[", "]", "\n", "\n", "if", "plane_index", "is", "None", ":", "\n", "            ", "x1", ",", "y1", ",", "vx1", ",", "vy1", ",", "x2", ",", "y2", ",", "vx2", ",", "vy2", "=", "self", ".", "state8", "\n", "", "else", ":", "\n", "            ", "x1", ",", "y1", ",", "vx1", ",", "vy1", ",", "x2", ",", "y2", ",", "vx2", ",", "vy2", "=", "self", ".", "vec_list", "[", "plane_index", "]", "\n", "\n", "", "theta1", "=", "math", ".", "atan2", "(", "vy1", ",", "vx1", ")", "\n", "theta2", "=", "math", ".", "atan2", "(", "vy2", ",", "vx2", ")", "\n", "\n", "for", "i", ",", "x", ",", "y", ",", "theta", "in", "zip", "(", "[", "0", ",", "1", "]", ",", "[", "x1", ",", "x2", "]", ",", "[", "y1", ",", "y2", "]", ",", "[", "theta1", ",", "theta2", "]", ")", ":", "\n", "            ", "key", "=", "f'plane{i}'", "\n", "\n", "if", "key", "in", "self", ".", "artists_dict", ":", "\n", "                ", "plane", "=", "self", ".", "artists_dict", "[", "key", "]", "\n", "rv", ".", "append", "(", "plane", ")", "\n", "\n", "if", "plane", ".", "get_visible", "(", ")", ":", "\n", "                    ", "theta_deg", "=", "(", "theta", "-", "np", ".", "pi", "/", "2", ")", "/", "np", ".", "pi", "*", "180", "# original image is facing up, not right", "\n", "original_size", "=", "list", "(", "self", ".", "img", ".", "shape", ")", "\n", "img_rotated", "=", "ndimage", ".", "rotate", "(", "self", ".", "img", ",", "theta_deg", ",", "order", "=", "1", ")", "\n", "rotated_size", "=", "list", "(", "img_rotated", ".", "shape", ")", "\n", "ratios", "=", "[", "r", "/", "o", "for", "r", ",", "o", "in", "zip", "(", "rotated_size", ",", "original_size", ")", "]", "\n", "plane", ".", "set_data", "(", "img_rotated", ")", "\n", "\n", "size", "=", "State", ".", "plane_size", "\n", "width", "=", "size", "*", "ratios", "[", "0", "]", "\n", "height", "=", "size", "*", "ratios", "[", "1", "]", "\n", "box", "=", "Bbox", ".", "from_bounds", "(", "x", "-", "width", "/", "2", ",", "y", "-", "height", "/", "2", ",", "width", ",", "height", ")", "\n", "tbox", "=", "TransformedBbox", "(", "box", ",", "axes", ".", "transData", ")", "\n", "plane", ".", "bbox", "=", "tbox", "\n", "\n", "", "", "key", "=", "f'dot{i}'", "\n", "if", "key", "in", "self", ".", "artists_dict", ":", "\n", "                ", "dot", "=", "self", ".", "artists_dict", "[", "f'dot{i}'", "]", "\n", "cir", "=", "self", ".", "artists_dict", "[", "f'circle{i}'", "]", "\n", "rv", "+=", "[", "dot", ",", "cir", "]", "\n", "\n", "dot", ".", "set_data", "(", "[", "x", "]", ",", "[", "y", "]", ")", "\n", "cir", ".", "set_center", "(", "(", "x", ",", "y", ")", ")", "\n", "\n", "# line collection", "\n", "", "", "lc", "=", "self", ".", "artists_dict", "[", "'lc0'", "]", "\n", "rv", ".", "append", "(", "lc", ")", "\n", "\n", "int_lc", "=", "self", ".", "artists_dict", "[", "'int_lc0'", "]", "\n", "rv", ".", "append", "(", "int_lc", ")", "\n", "\n", "self", ".", "update_lc_artists", "(", "lc", ",", "int_lc", ")", "\n", "\n", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.update_lc_artists": [[383, 445], ["enumerate", "lc.get_paths", "lc.get_paths.clear", "enumerate", "lc.set_lw", "lc.set_color", "codes.append", "verts.append", "lc.get_paths.append", "numpy.linalg.norm", "matplotlib.path.Path", "lc.get_paths.append", "lws.append", "colors.append", "matplotlib.path.Path", "lws.append", "colors.append", "lws.append", "colors.append", "lws.append", "colors.append", "lws.append", "colors.append"], "methods", ["None"], ["", "def", "update_lc_artists", "(", "self", ",", "own_lc", ",", "int_lc", ")", ":", "\n", "        ", "'update line collection artist based on current state'", "\n", "\n", "assert", "self", ".", "vec_list", "\n", "\n", "for", "lc_index", ",", "lc", "in", "enumerate", "(", "[", "own_lc", ",", "int_lc", "]", ")", ":", "\n", "            ", "paths", "=", "lc", ".", "get_paths", "(", ")", "\n", "colors", "=", "[", "]", "\n", "lws", "=", "[", "]", "\n", "paths", ".", "clear", "(", ")", "\n", "last_command", "=", "-", "1", "\n", "codes", "=", "[", "]", "\n", "verts", "=", "[", "]", "\n", "\n", "for", "i", ",", "vec", "in", "enumerate", "(", "self", ".", "vec_list", ")", ":", "\n", "                ", "if", "np", ".", "linalg", ".", "norm", "(", "vec", "-", "self", ".", "state8", ")", "<", "1e-6", ":", "\n", "# done", "\n", "                    ", "break", "\n", "\n", "", "if", "lc_index", "==", "0", ":", "\n", "                    ", "cmd", "=", "self", ".", "commands", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "cmd", "=", "self", ".", "int_commands", "[", "i", "]", "\n", "\n", "", "x", "=", "0", "if", "lc_index", "==", "0", "else", "4", "\n", "y", "=", "1", "if", "lc_index", "==", "0", "else", "5", "\n", "\n", "# command[i] is the line from i to (i+1)", "\n", "if", "cmd", "!=", "last_command", ":", "\n", "                    ", "if", "codes", ":", "\n", "                        ", "paths", ".", "append", "(", "Path", "(", "verts", ",", "codes", ")", ")", "\n", "\n", "", "codes", "=", "[", "Path", ".", "MOVETO", "]", "\n", "verts", "=", "[", "(", "vec", "[", "x", "]", ",", "vec", "[", "y", "]", ")", "]", "\n", "\n", "if", "cmd", "==", "1", ":", "# weak left", "\n", "                        ", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'b'", ")", "\n", "", "elif", "cmd", "==", "2", ":", "# weak right", "\n", "                        ", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'c'", ")", "\n", "", "elif", "cmd", "==", "3", ":", "# strong left", "\n", "                        ", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'g'", ")", "\n", "", "elif", "cmd", "==", "4", ":", "# strong right", "\n", "                        ", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'r'", ")", "\n", "", "else", ":", "\n", "                        ", "assert", "cmd", "==", "0", "# coc", "\n", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'k'", ")", "\n", "\n", "", "", "codes", ".", "append", "(", "Path", ".", "LINETO", ")", "\n", "\n", "verts", ".", "append", "(", "(", "self", ".", "vec_list", "[", "i", "+", "1", "]", "[", "x", "]", ",", "self", ".", "vec_list", "[", "i", "+", "1", "]", "[", "y", "]", ")", ")", "\n", "\n", "# add last one", "\n", "", "if", "codes", ":", "\n", "                ", "paths", ".", "append", "(", "Path", "(", "verts", ",", "codes", ")", ")", "\n", "\n", "", "lc", ".", "set_lw", "(", "lws", ")", "\n", "lc", ".", "set_color", "(", "colors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.make_artists": [[446, 498], ["replay.get_airplane_img", "enumerate", "pos_lists.append", "l.set_visible", "math.atan2", "math.atan2", "axes.plot", "matplotlib.collections.LineCollection", "axes.add_collection", "matplotlib.collections.LineCollection", "axes.add_collection", "matplotlib.transforms.Bbox.from_bounds", "matplotlib.transforms.TransformedBbox", "matplotlib.image.BboxImage", "scipy.ndimage.rotate", "matplotlib.image.BboxImage.set_data", "axes.add_artist", "matplotlib.patches.Ellipse", "axes.add_patch", "axes.plot", "zip"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_airplane_img", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot"], ["", "", "def", "make_artists", "(", "self", ",", "axes", ",", "show_intruder", ",", "animated", "=", "True", ")", ":", "\n", "        ", "'make self.artists_dict'", "\n", "\n", "assert", "self", ".", "vec_list", "\n", "self", ".", "img", "=", "get_airplane_img", "(", ")", "\n", "\n", "posa_list", "=", "[", "(", "v", "[", "0", "]", ",", "v", "[", "1", "]", ",", "math", ".", "atan2", "(", "v", "[", "3", "]", ",", "v", "[", "2", "]", ")", ")", "for", "v", "in", "self", ".", "vec_list", "]", "\n", "posb_list", "=", "[", "(", "v", "[", "4", "]", ",", "v", "[", "5", "]", ",", "math", ".", "atan2", "(", "v", "[", "7", "]", ",", "v", "[", "6", "]", ")", ")", "for", "v", "in", "self", ".", "vec_list", "]", "\n", "\n", "pos_lists", "=", "[", "posa_list", ",", "posb_list", "]", "\n", "\n", "if", "show_intruder", ":", "\n", "            ", "pos_lists", ".", "append", "(", "posb_list", ")", "\n", "\n", "", "for", "i", ",", "pos_list", "in", "enumerate", "(", "pos_lists", ")", ":", "\n", "            ", "x", ",", "y", ",", "theta", "=", "pos_list", "[", "0", "]", "\n", "\n", "l", "=", "axes", ".", "plot", "(", "*", "zip", "(", "*", "pos_list", ")", ",", "'c-'", ",", "lw", "=", "0", ",", "zorder", "=", "1", ")", "[", "0", "]", "\n", "l", ".", "set_visible", "(", "False", ")", "\n", "self", ".", "artists_dict", "[", "f'line{i}'", "]", "=", "l", "\n", "\n", "if", "i", "==", "0", ":", "\n", "                ", "lc", "=", "LineCollection", "(", "[", "]", ",", "lw", "=", "2", ",", "animated", "=", "animated", ",", "color", "=", "'k'", ",", "zorder", "=", "1", ")", "\n", "axes", ".", "add_collection", "(", "lc", ")", "\n", "self", ".", "artists_dict", "[", "f'lc{i}'", "]", "=", "lc", "\n", "\n", "int_lc", "=", "LineCollection", "(", "[", "]", ",", "lw", "=", "2", ",", "animated", "=", "animated", ",", "color", "=", "'k'", ",", "zorder", "=", "1", ")", "\n", "axes", ".", "add_collection", "(", "int_lc", ")", "\n", "self", ".", "artists_dict", "[", "f'int_lc{i}'", "]", "=", "int_lc", "\n", "\n", "# only sim_index = 0 gets intruder aircraft", "\n", "", "if", "i", "==", "0", "or", "(", "i", "==", "1", "and", "show_intruder", ")", ":", "\n", "                ", "size", "=", "State", ".", "plane_size", "\n", "box", "=", "Bbox", ".", "from_bounds", "(", "x", "-", "size", "/", "2", ",", "y", "-", "size", "/", "2", ",", "size", ",", "size", ")", "\n", "tbox", "=", "TransformedBbox", "(", "box", ",", "axes", ".", "transData", ")", "\n", "box_image", "=", "BboxImage", "(", "tbox", ",", "zorder", "=", "2", ")", "\n", "\n", "theta_deg", "=", "(", "theta", "-", "np", ".", "pi", "/", "2", ")", "/", "np", ".", "pi", "*", "180", "# original image is facing up, not right", "\n", "img_rotated", "=", "ndimage", ".", "rotate", "(", "self", ".", "img", ",", "theta_deg", ",", "order", "=", "1", ")", "\n", "\n", "box_image", ".", "set_data", "(", "img_rotated", ")", "\n", "axes", ".", "add_artist", "(", "box_image", ")", "\n", "self", ".", "artists_dict", "[", "f'plane{i}'", "]", "=", "box_image", "\n", "\n", "", "if", "i", "==", "0", ":", "\n", "                ", "dot", "=", "axes", ".", "plot", "(", "[", "x", "]", ",", "[", "y", "]", ",", "'k.'", ",", "markersize", "=", "6.0", ",", "zorder", "=", "2", ")", "[", "0", "]", "\n", "self", ".", "artists_dict", "[", "f'dot{i}'", "]", "=", "dot", "\n", "\n", "rad", "=", "1500", "\n", "c", "=", "patches", ".", "Ellipse", "(", "(", "x", ",", "y", ")", ",", "rad", ",", "rad", ",", "color", "=", "'k'", ",", "lw", "=", "3.0", ",", "fill", "=", "False", ")", "\n", "axes", ".", "add_patch", "(", "c", ")", "\n", "self", ".", "artists_dict", "[", "f'circle{i}'", "]", "=", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.step": [[499, 533], ["replay.State.update_command", "replay.State.commands.append", "replay.State.int_commands.append", "print", "abs", "print", "print"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_command"], ["", "", "", "def", "step", "(", "self", ",", "stdout", "=", "False", ")", ":", "\n", "        ", "'execute one time step and update the model'", "\n", "\n", "tol", "=", "1e-6", "\n", "\n", "if", "self", ".", "next_nn_update", "<", "tol", ":", "\n", "            ", "assert", "abs", "(", "self", ".", "next_nn_update", ")", "<", "tol", ",", "f\"time step doesn't sync with nn update time. \"", "+", "f\"next update: {self.next_nn_update}\"", "\n", "\n", "if", "stdout", ":", "\n", "                ", "print", "(", "f\"\\nupdating nn command. Using network #{self.command}\"", ")", "\n", "\n", "# update command", "\n", "", "self", ".", "update_command", "(", "stdout", "=", "stdout", ")", "\n", "\n", "if", "stdout", ":", "\n", "                ", "print", "(", "f\"nn output cmd was {self.command}\"", ")", "\n", "\n", "", "self", ".", "next_nn_update", "=", "State", ".", "nn_update_rate", "\n", "\n", "", "self", ".", "next_nn_update", "-=", "State", ".", "dt", "\n", "intruder_cmd", "=", "self", ".", "u_list", "[", "self", ".", "u_list_index", "]", "\n", "\n", "if", "self", ".", "save_states", ":", "\n", "            ", "self", ".", "commands", ".", "append", "(", "self", ".", "command", ")", "\n", "self", ".", "int_commands", ".", "append", "(", "intruder_cmd", ")", "\n", "\n", "", "time_elapse_mat", "=", "State", ".", "time_elapse_mats", "[", "self", ".", "command", "]", "[", "intruder_cmd", "]", "\n", "\n", "self", ".", "state8", "=", "time_elapse_mat", "@", "self", ".", "state8", "\n", "self", ".", "time", "+=", "1", "\n", "\n", "if", "stdout", ":", "\n", "            ", "print", "(", "f\"state8: {self.state8}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.simulate": [[534, 584], ["isinstance", "math.sqrt", "len", "replay.State.step", "replay.State.tau_now", "replay.State.state8.copy", "rv.append", "replay.State.state8.copy"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.step", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.tau_now", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy"], ["", "", "def", "simulate", "(", "self", ",", "cmd_list", ",", "stdout", "=", "False", ")", ":", "\n", "        ", "'''simulate system\n\n        saves result in self.vec_list\n        also saves self.min_dist\n        '''", "\n", "\n", "self", ".", "u_list", "=", "cmd_list", "\n", "self", ".", "u_list_index", "=", "None", "\n", "self", ".", "time", "=", "0", "\n", "\n", "assert", "isinstance", "(", "cmd_list", ",", "list", ")", "\n", "assert", "State", ".", "dt", "==", "1.0", "\n", "tmax", "=", "len", "(", "cmd_list", ")", "*", "State", ".", "nn_update_rate", "\n", "\n", "t", "=", "0.0", "\n", "\n", "if", "self", ".", "save_states", ":", "\n", "            ", "rv", "=", "[", "self", ".", "state8", ".", "copy", "(", ")", "]", "\n", "\n", "#self.min_dist = 0, math.sqrt((self.vec[0] - self.vec[3])**2 + (self.vec[1] - self.vec[4])**2), self.vec.copy()", "\n", "", "if", "self", ".", "tau_init", "==", "0", ":", "\n", "            ", "min_dist_sq", "=", "(", "self", ".", "state8", "[", "0", "]", "-", "self", ".", "state8", "[", "4", "]", ")", "**", "2", "+", "(", "self", ".", "state8", "[", "1", "]", "-", "self", ".", "state8", "[", "5", "]", ")", "**", "2", "\n", "", "else", ":", "\n", "            ", "min_dist_sq", "=", "np", ".", "inf", "\n", "\n", "", "while", "t", "+", "1e-6", "<", "tmax", ":", "\n", "            ", "self", ".", "step", "(", "stdout", "=", "stdout", ")", "\n", "\n", "cur_dist_sq", "=", "(", "self", ".", "state8", "[", "0", "]", "-", "self", ".", "state8", "[", "4", "]", ")", "**", "2", "+", "(", "self", ".", "state8", "[", "1", "]", "-", "self", ".", "state8", "[", "5", "]", ")", "**", "2", "\n", "\n", "if", "self", ".", "save_states", ":", "\n", "                ", "rv", ".", "append", "(", "self", ".", "state8", ".", "copy", "(", ")", ")", "\n", "\n", "", "t", "+=", "State", ".", "dt", "\n", "\n", "tau_now", "=", "self", ".", "tau_now", "(", ")", "\n", "\n", "if", "tau_now", "==", "0", "and", "cur_dist_sq", "<", "min_dist_sq", ":", "\n", "                ", "min_dist_sq", "=", "cur_dist_sq", "\n", "\n", "", "", "self", ".", "min_dist", "=", "math", ".", "sqrt", "(", "min_dist_sq", ")", "\n", "\n", "if", "self", ".", "save_states", ":", "\n", "            ", "self", ".", "vec_list", "=", "rv", "\n", "\n", "", "if", "not", "self", ".", "save_states", ":", "\n", "            ", "assert", "not", "self", ".", "vec_list", "\n", "assert", "not", "self", ".", "commands", "\n", "assert", "not", "self", ".", "int_commands", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.tau_now": [[585, 589], ["round"], "methods", ["None"], ["", "", "def", "tau_now", "(", "self", ")", ":", "\n", "        ", "\"\"\"return the integer value of tau based on tau_init, tau_dot, and self.vec[-1]\"\"\"", "\n", "\n", "return", "round", "(", "self", ".", "tau_init", "+", "self", ".", "tau_dot", "*", "self", ".", "time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.State.update_command": [[590, 632], ["replay.state8_to_qinput_qstate", "replay.State.qinputs.append", "print", "print", "replay.network_index", "replay.run_network", "numpy.argmin", "min", "replay.State.tau_now", "len"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.state8_to_qinput_qstate", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.network_index", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.run_network", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.tau_now"], ["", "def", "update_command", "(", "self", ",", "stdout", "=", "False", ")", ":", "\n", "        ", "'update command based on current state'", "''", "\n", "\n", "qinput", ",", "qstate", "=", "state8_to_qinput_qstate", "(", "self", ".", "state8", ",", "stdout", "=", "stdout", ")", "\n", "rho", ",", "theta", ",", "psi", ",", "v_own", ",", "v_int", "=", "qinput", "\n", "\n", "if", "stdout", ":", "\n", "            ", "print", "(", "f\"state8: {self.state8}\"", ")", "\n", "print", "(", "f\"qinput: {rho, theta, psi, v_own, v_int}\"", ")", "\n", "\n", "# 0: rho, distance", "\n", "# 1: theta, angle to intruder relative to ownship heading", "\n", "# 2: psi, heading of intruder relative to ownship heading", "\n", "# 3: v_own, speed of ownship", "\n", "# 4: v_int, speed in intruder", "\n", "\n", "# min inputs: 0, -3.1415, -3.1415, 100, 0", "\n", "# max inputs: 60760, 3.1415, 3,1415, 1200, 1200", "\n", "", "last_command", "=", "self", ".", "command", "\n", "\n", "if", "rho", ">", "60760", ":", "\n", "            ", "self", ".", "command", "=", "0", "\n", "", "else", ":", "\n", "            ", "ni", "=", "network_index", "(", "last_command", ",", "self", ".", "tau_now", "(", ")", ")", "\n", "net", "=", "State", ".", "nets", "[", "ni", "]", "\n", "\n", "state", "=", "[", "rho", ",", "theta", ",", "psi", ",", "v_own", ",", "v_int", "]", "\n", "\n", "res", "=", "run_network", "(", "net", ",", "state", ")", "\n", "self", ".", "command", "=", "np", ".", "argmin", "(", "res", ")", "\n", "\n", "#names = ['clear-of-conflict', 'weak-left', 'weak-right', 'strong-left', 'strong-right']", "\n", "\n", "", "if", "self", ".", "u_list_index", "is", "None", ":", "\n", "            ", "self", ".", "u_list_index", "=", "0", "\n", "", "else", ":", "\n", "            ", "self", ".", "u_list_index", "+=", "1", "\n", "\n", "# repeat last command if no more commands", "\n", "self", ".", "u_list_index", "=", "min", "(", "self", ".", "u_list_index", ",", "len", "(", "self", ".", "u_list", ")", "-", "1", ")", "\n", "\n", "", "self", ".", "qinputs", ".", "append", "(", "(", "last_command", ",", "self", ".", "state8", ",", "qstate", ",", "qinput", ",", "self", ".", "command", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.init_plot": [[29, 35], ["os.path.join", "matplotlib.style.use"], "function", ["None"], ["def", "init_plot", "(", ")", ":", "\n", "    ", "'initialize plotting style'", "\n", "\n", "#matplotlib.use('TkAgg') # set backend", "\n", "p", "=", "os", ".", "path", ".", "join", "(", "'resources'", ",", "'bak_matplotlib.mlpstyle'", ")", "\n", "plt", ".", "style", ".", "use", "(", "[", "'bmh'", ",", "p", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.load_network": [[36, 52], ["onnxruntime.InferenceSession", "numpy.array", "ort.InferenceSession.run"], "function", ["None"], ["", "def", "load_network", "(", "last_cmd", ",", "tau", ")", ":", "\n", "    ", "'''load onnx neural network and return (session, range_for_scaling, means_for_scaling)'''", "\n", "\n", "onnx_filename", "=", "f\"resources/ACASXU_run2a_{last_cmd + 1}_{tau + 1}_batch_2000.onnx\"", "\n", "\n", "means_for_scaling", "=", "[", "19791.091", ",", "0.0", ",", "0.0", ",", "650.0", ",", "600.0", ",", "7.5188840201005975", "]", "\n", "range_for_scaling", "=", "[", "60261.0", ",", "6.28318530718", ",", "6.28318530718", ",", "1100.0", ",", "1200.0", "]", "\n", "\n", "session", "=", "ort", ".", "InferenceSession", "(", "onnx_filename", ")", "\n", "\n", "# warm up the network", "\n", "i", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "i", ".", "shape", "=", "(", "1", ",", "1", ",", "1", ",", "5", ")", "\n", "session", ".", "run", "(", "None", ",", "{", "'input'", ":", "i", "}", ")", "\n", "\n", "return", "session", ",", "range_for_scaling", ",", "means_for_scaling", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.load_networks": [[53, 63], ["range", "range", "nets.append", "replay.load_network"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.load_network"], ["", "def", "load_networks", "(", ")", ":", "\n", "    ", "'''load the 45 neural networks into nn-enum's data structures and return them as a list'''", "\n", "\n", "nets", "=", "[", "]", "\n", "\n", "for", "last_cmd", "in", "range", "(", "5", ")", ":", "\n", "        ", "for", "tau", "in", "range", "(", "9", ")", ":", "\n", "            ", "nets", ".", "append", "(", "load_network", "(", "last_cmd", ",", "tau", ")", ")", "\n", "\n", "", "", "return", "nets", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.get_tau_index": [[64, 91], ["enumerate", "len", "abs", "abs"], "function", ["None"], ["", "def", "get_tau_index", "(", "tau", ")", ":", "\n", "    ", "\"\"\"get tau index\"\"\"", "\n", "\n", "tau_list", "=", "[", "0", ",", "1", ",", "5", ",", "10", ",", "20", ",", "50", ",", "60", ",", "80", ",", "100", "]", "\n", "tau_index", "=", "-", "1", "\n", "\n", "if", "tau", "<=", "tau_list", "[", "0", "]", ":", "\n", "        ", "tau_index", "=", "0", "\n", "", "elif", "tau", ">=", "tau_list", "[", "-", "1", "]", ":", "\n", "        ", "tau_index", "=", "len", "(", "tau_list", ")", "-", "1", "\n", "", "else", ":", "\n", "# find the index of the closest tau value, rounding down to break ties", "\n", "\n", "        ", "for", "i", ",", "tau_min", "in", "enumerate", "(", "tau_list", "[", ":", "-", "1", "]", ")", ":", "\n", "            ", "tau_max", "=", "tau_list", "[", "i", "+", "1", "]", "\n", "\n", "if", "tau_min", "<=", "tau", "<=", "tau_max", ":", "\n", "                ", "if", "abs", "(", "tau", "-", "tau_min", ")", "-", "1e-6", "<=", "abs", "(", "tau", "-", "tau_max", ")", ":", "\n", "                    ", "tau_index", "=", "i", "\n", "", "else", ":", "\n", "                    ", "tau_index", "=", "i", "+", "1", "\n", "\n", "", "break", "\n", "\n", "", "", "", "assert", "tau_index", ">=", "0", ",", "f\"tau_index not found for tau = {tau}?\"", "\n", "\n", "return", "tau_index", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.network_index": [[92, 98], ["replay.get_tau_index"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_tau_index"], ["", "def", "network_index", "(", "alpha_prev", ":", "int", ",", "tau", ":", "float", ")", ":", "\n", "    ", "\"\"\"get network index\"\"\"", "\n", "\n", "ti", "=", "get_tau_index", "(", "tau", ")", "\n", "\n", "return", "9", "*", "alpha_prev", "+", "ti", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.get_time_elapse_mat": [[99, 125], ["numpy.array", "scipy.linalg.expm"], "function", ["None"], ["", "def", "get_time_elapse_mat", "(", "command1", ",", "dt", ",", "command2", "=", "0", ")", ":", "\n", "    ", "'''get the matrix exponential for the given command\n\n    state: x, y, vx, vy, x2, y2, vx2, vy2 \n    '''", "\n", "\n", "y_list", "=", "[", "0.0", ",", "1.5", ",", "-", "1.5", ",", "3.0", ",", "-", "3.0", "]", "\n", "y1", "=", "y_list", "[", "command1", "]", "\n", "y2", "=", "y_list", "[", "command2", "]", "\n", "\n", "dtheta1", "=", "(", "y1", "/", "180", "*", "np", ".", "pi", ")", "\n", "dtheta2", "=", "(", "y2", "/", "180", "*", "np", ".", "pi", ")", "\n", "\n", "a_mat", "=", "np", ".", "array", "(", "[", "\n", "[", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "# x' = vx", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "# y' = vy", "\n", "[", "0", ",", "0", ",", "0", ",", "-", "dtheta1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "# vx' = -vy * dtheta1", "\n", "[", "0", ",", "0", ",", "dtheta1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "# vy' = vx * dtheta1", "\n", "#", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", "]", ",", "# x' = vx", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", "]", ",", "# y' = vy", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "-", "dtheta2", "]", ",", "# vx' = -vy * dtheta2", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "dtheta2", ",", "0", "]", ",", "# vy' = vx * dtheta1", "\n", "]", ",", "dtype", "=", "float", ")", "\n", "\n", "return", "expm", "(", "a_mat", "*", "dt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.run_network": [[126, 143], ["range", "numpy.array", "session.run", "print"], "function", ["None"], ["", "def", "run_network", "(", "network_tuple", ",", "x", ",", "stdout", "=", "False", ")", ":", "\n", "    ", "'run the network and return the output'", "\n", "\n", "session", ",", "range_for_scaling", ",", "means_for_scaling", "=", "network_tuple", "\n", "\n", "# normalize input", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "        ", "x", "[", "i", "]", "=", "(", "x", "[", "i", "]", "-", "means_for_scaling", "[", "i", "]", ")", "/", "range_for_scaling", "[", "i", "]", "\n", "\n", "", "if", "stdout", ":", "\n", "        ", "print", "(", "f\"input (after scaling): {x}\"", ")", "\n", "\n", "", "in_array", "=", "np", ".", "array", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "in_array", ".", "shape", "=", "(", "1", ",", "1", ",", "1", ",", "5", ")", "\n", "outputs", "=", "session", ".", "run", "(", "None", ",", "{", "'input'", ":", "in_array", "}", ")", "\n", "\n", "return", "outputs", "[", "0", "]", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.quantize": [[144, 158], ["round"], "function", ["None"], ["", "def", "quantize", "(", "x", ",", "delta", "=", "50", ")", ":", "\n", "    ", "\"\"\"round to the nearest delta (offset by delta / 2)\n\n    for example using 50 will round anything between 0 and 50 to 25\n    \"\"\"", "\n", "\n", "global", "skip_quantization", "\n", "\n", "if", "skip_quantization", ":", "\n", "        ", "rv", "=", "x", "\n", "", "else", ":", "\n", "        ", "rv", "=", "delta", "/", "2", "+", "delta", "*", "round", "(", "(", "x", "-", "delta", "/", "2", ")", "/", "delta", ")", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.state8_to_qinput_qstate": [[159, 234], ["replay.quantize", "replay.quantize", "numpy.sqrt", "numpy.arctan2", "numpy.arctan2", "replay.quantize", "math.sqrt", "math.sqrt", "numpy.array", "len", "print", "abs", "print", "print", "print", "replay.quantize", "replay.quantize", "print", "print", "print", "print", "print", "print", "round"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.quantize", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.quantize", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.quantize", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.quantize", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.quantize"], ["", "def", "state8_to_qinput_qstate", "(", "state8", ",", "stdout", "=", "False", ")", ":", "\n", "    ", "\"\"\"compute rho, theta, psi from state7\"\"\"", "\n", "\n", "assert", "len", "(", "state8", ")", "==", "8", "\n", "\n", "x1", ",", "y1", ",", "vxo", ",", "vyo", ",", "x2", ",", "y2", ",", "vxi", ",", "vyi", "=", "state8", "\n", "\n", "pos_quantum", "=", "Settings", ".", "pos_q", "\n", "vel_quantum", "=", "Settings", ".", "vel_q", "\n", "theta1_quantum", "=", "Settings", ".", "theta1_q", "\n", "\n", "dy", "=", "quantize", "(", "y2", "-", "y1", ",", "pos_quantum", ")", "\n", "dx", "=", "quantize", "(", "x2", "-", "x1", ",", "pos_quantum", ")", "\n", "\n", "rho", "=", "np", ".", "sqrt", "(", "dx", "**", "2", "+", "dy", "**", "2", ")", "\n", "theta", "=", "np", ".", "arctan2", "(", "dy", ",", "dx", ")", "\n", "\n", "# psi should be ", "\n", "theta1", "=", "np", ".", "arctan2", "(", "vyo", ",", "vxo", ")", "## theta 1 is using ownship!!", "\n", "\n", "if", "stdout", ":", "\n", "        ", "print", "(", "f\"in state8_to_qstate5, real theta1: {theta1}\"", ")", "\n", "\n", "", "assert", "abs", "(", "vyi", ")", "<", "1e-6", "\n", "assert", "vxi", ">=", "0", "\n", "theta2", "=", "0", "\n", "theta1", "=", "quantize", "(", "theta1", ",", "theta1_quantum", ")", "\n", "\n", "if", "stdout", ":", "\n", "        ", "print", "(", "f\"quantized theta1: {theta1}\"", ")", "\n", "\n", "", "theta1_deg", "=", "theta1", "*", "360", "/", "(", "2", "*", "math", ".", "pi", ")", "\n", "\n", "if", "stdout", ":", "\n", "        ", "print", "(", "f\"theta1 quantized: {round(theta1_deg, 3)} deg\"", ")", "\n", "print", "(", "f\"ownship vx / vy = {vxo}, {vyo}\"", ")", "\n", "\n", "", "psi", "=", "theta2", "-", "theta1", "\n", "\n", "theta", "-=", "theta1", "\n", "\n", "while", "theta", "<", "-", "np", ".", "pi", ":", "\n", "        ", "theta", "+=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "theta", ">", "np", ".", "pi", ":", "\n", "        ", "theta", "-=", "2", "*", "np", ".", "pi", "\n", "\n", "", "if", "psi", "<", "-", "np", ".", "pi", ":", "\n", "        ", "psi", "+=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "psi", ">", "np", ".", "pi", ":", "\n", "        ", "psi", "-=", "2", "*", "np", ".", "pi", "\n", "\n", "", "own_vel", "=", "math", ".", "sqrt", "(", "vxo", "**", "2", "+", "vyo", "**", "2", ")", "\n", "int_vel", "=", "math", ".", "sqrt", "(", "vxi", "**", "2", ")", "\n", "\n", "if", "vel_quantum", "!=", "0", ":", "\n", "        ", "q_v_own", "=", "quantize", "(", "own_vel", ",", "vel_quantum", ")", "\n", "q_v_int", "=", "quantize", "(", "int_vel", ",", "vel_quantum", ")", "\n", "", "else", ":", "\n", "        ", "q_v_own", "=", "own_vel", "\n", "q_v_int", "=", "int_vel", "\n", "\n", "", "if", "stdout", ":", "\n", "        ", "print", "(", "f\"dx: {dx}\"", ")", "\n", "print", "(", "f\"dy: {dy}\"", ")", "\n", "print", "(", "f\"theta1: {theta1}\"", ")", "\n", "print", "(", "f\"theta2: {theta2}\"", ")", "\n", "print", "(", "f\"q_v_own: {q_v_own} (from {own_vel})\"", ")", "\n", "print", "(", "f\"q_v_int: {q_v_int}\"", ")", "\n", "\n", "", "qinput", "=", "np", ".", "array", "(", "[", "rho", ",", "theta", ",", "psi", ",", "q_v_own", ",", "q_v_int", "]", ")", "\n", "qstate", "=", "(", "dx", ",", "dy", ",", "theta1", ",", "theta2", ",", "q_v_own", ",", "q_v_int", ")", "\n", "\n", "return", "qinput", ",", "qstate", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.state7_to_state8": [[235, 251], ["numpy.array", "len", "math.cos", "math.sin", "math.cos", "math.sin"], "function", ["None"], ["", "def", "state7_to_state8", "(", "state7", ",", "v_own", ",", "v_int", ")", ":", "\n", "    ", "\"\"\"compute x,y, vx, vy, x2, y2, vx2, vy2 from state7\"\"\"", "\n", "\n", "assert", "len", "(", "state7", ")", "==", "7", "\n", "\n", "x1", "=", "state7", "[", "0", "]", "\n", "y1", "=", "state7", "[", "1", "]", "\n", "vx1", "=", "math", ".", "cos", "(", "state7", "[", "2", "]", ")", "*", "v_own", "\n", "vy1", "=", "math", ".", "sin", "(", "state7", "[", "2", "]", ")", "*", "v_own", "\n", "\n", "x2", "=", "state7", "[", "3", "]", "\n", "y2", "=", "state7", "[", "4", "]", "\n", "vx2", "=", "math", ".", "cos", "(", "state7", "[", "5", "]", ")", "*", "v_int", "\n", "vy2", "=", "math", ".", "sin", "(", "state7", "[", "5", "]", ")", "*", "v_int", "\n", "\n", "return", "np", ".", "array", "(", "[", "x1", ",", "y1", ",", "vx1", ",", "vy1", ",", "x2", ",", "y2", ",", "vx2", ",", "vy2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.get_airplane_img": [[252, 259], ["functools.lru_cache", "matplotlib.imread", "os.path.join"], "function", ["None"], ["", "@", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "get_airplane_img", "(", ")", ":", "\n", "    ", "\"\"\"load airplane image form file\"\"\"", "\n", "\n", "img", "=", "plt", ".", "imread", "(", "os", ".", "path", ".", "join", "(", "'resources'", ",", "'airplane.png'", ")", ")", "\n", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.init_time_elapse_mats": [[260, 273], ["range", "rv.append", "range", "replay.get_time_elapse_mat", "rv[].append"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_time_elapse_mat"], ["", "def", "init_time_elapse_mats", "(", "dt", ")", ":", "\n", "    ", "\"\"\"get value of time_elapse_mats array\"\"\"", "\n", "\n", "rv", "=", "[", "]", "\n", "\n", "for", "cmd", "in", "range", "(", "5", ")", ":", "\n", "        ", "rv", ".", "append", "(", "[", "]", ")", "\n", "\n", "for", "int_cmd", "in", "range", "(", "5", ")", ":", "\n", "            ", "mat", "=", "get_time_elapse_mat", "(", "cmd", ",", "dt", ",", "int_cmd", ")", "\n", "rv", "[", "-", "1", "]", ".", "append", "(", "mat", ")", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.plot": [[633, 733], ["math.sqrt", "print", "matplotlib.subplots", "axes.axis", "axes.set_title", "axes.set_xlabel", "axes.set_ylabel", "axes.text", "axes.text.set_visible", "axes.legend", "s.make_artists", "matplotlib.tight_layout", "len", "print", "matplotlib.animation.FuncAnimation", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "len", "max", "min", "len", "animation.FuncAnimation.save", "matplotlib.show", "print", "round", "axes.text.set_text", "axes.text.set_text", "s.update_artists", "s.artists_list", "s.set_plane_visible", "s.artists_list", "dict", "round", "round", "round", "round", "a.set_visible"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.make_artists", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_artists", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.artists_list", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.set_plane_visible", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.artists_list"], ["", "", "def", "plot", "(", "s", ",", "name", "=", "'sim'", ",", "save_mp4", "=", "False", ")", ":", "\n", "    ", "\"\"\"plot a specific simulation\"\"\"", "\n", "\n", "dx", "=", "s", ".", "state8", "[", "0", "]", "-", "s", ".", "state8", "[", "4", "]", "\n", "dy", "=", "s", ".", "state8", "[", "1", "]", "-", "s", ".", "state8", "[", "5", "]", "\n", "dist", "=", "math", ".", "sqrt", "(", "dx", "*", "dx", "+", "dy", "*", "dy", ")", "\n", "print", "(", "f\"Plotting sim with min_dist: {round(s.min_dist, 2)} and \"", "+", "f\"final dx: {round(dx, 1)}, dy: {round(dy, 1)}, dist: {round(dist, 2)}\"", ")", "\n", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "1", ",", "ncols", "=", "1", ",", "figsize", "=", "(", "12", ",", "8", ")", ")", "\n", "axes", ".", "axis", "(", "'equal'", ")", "\n", "\n", "axes", ".", "set_title", "(", "\"ACAS Xu Simulation\"", ")", "\n", "axes", ".", "set_xlabel", "(", "'X Position (ft)'", ")", "\n", "axes", ".", "set_ylabel", "(", "'Y Position (ft)'", ")", "\n", "\n", "time_text", "=", "axes", ".", "text", "(", "0.02", ",", "0.98", ",", "'Time: 0'", ",", "horizontalalignment", "=", "'left'", ",", "fontsize", "=", "14", ",", "\n", "verticalalignment", "=", "'top'", ",", "transform", "=", "axes", ".", "transAxes", ")", "\n", "time_text", ".", "set_visible", "(", "True", ")", "\n", "\n", "custom_lines", "=", "[", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'g'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'b'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'k'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'c'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'r'", ",", "lw", "=", "2", ")", "]", "\n", "\n", "axes", ".", "legend", "(", "custom_lines", ",", "[", "'Strong Left'", ",", "'Weak Left'", ",", "'Clear of Conflict'", ",", "'Weak Right'", ",", "'Strong Right'", "]", ",", "fontsize", "=", "14", ",", "loc", "=", "'lower left'", ")", "\n", "\n", "s", ".", "make_artists", "(", "axes", ",", "show_intruder", "=", "True", ")", "\n", "states", "=", "[", "s", "]", "\n", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "num_steps", "=", "len", "(", "states", "[", "0", "]", ".", "vec_list", ")", "\n", "interval", "=", "50", "# ms per frame", "\n", "freeze_frames", "=", "2", "if", "not", "save_mp4", "else", "5", "\n", "\n", "num_runs", "=", "1", "# 3", "\n", "num_frames", "=", "num_runs", "*", "num_steps", "+", "2", "*", "num_runs", "*", "freeze_frames", "\n", "\n", "print", "(", "f\"num_frames: {num_frames}\"", ")", "\n", "\n", "#plt.savefig('plot.png')", "\n", "#plot_commands(states[0])", "\n", "\n", "assert", "len", "(", "states", ")", "==", "1", "\n", "\n", "def", "animate", "(", "f", ")", ":", "\n", "        ", "'animate function'", "\n", "\n", "if", "(", "f", "+", "1", ")", "%", "10", "==", "0", "and", "save_mp4", ":", "\n", "            ", "print", "(", "f\"Frame: {f+1} / {num_frames}\"", ")", "\n", "\n", "", "run_index", "=", "f", "//", "(", "num_steps", "+", "2", "*", "freeze_frames", ")", "\n", "\n", "f", "=", "f", "-", "run_index", "*", "(", "num_steps", "+", "2", "*", "freeze_frames", ")", "\n", "\n", "f", "-=", "freeze_frames", "\n", "\n", "f", "=", "max", "(", "0", ",", "f", ")", "\n", "f", "=", "min", "(", "f", ",", "num_steps", "-", "1", ")", "\n", "\n", "num_states", "=", "len", "(", "states", ")", "\n", "\n", "if", "f", "==", "0", ":", "\n", "# initiaze current run_index", "\n", "            ", "show_plane", "=", "num_states", "<=", "10", "\n", "for", "s", "in", "states", "[", ":", "num_states", "]", ":", "\n", "                ", "s", ".", "set_plane_visible", "(", "show_plane", ")", "\n", "\n", "", "for", "s", "in", "states", "[", "num_states", ":", "]", ":", "\n", "                ", "for", "a", "in", "s", ".", "artists_list", "(", ")", ":", "\n", "                    ", "a", ".", "set_visible", "(", "False", ")", "\n", "\n", "", "", "", "if", "states", "[", "0", "]", ".", "tau_dot", "!=", "0", ":", "\n", "            ", "tau", "=", "round", "(", "states", "[", "0", "]", ".", "tau_init", "-", "f", ")", "\n", "time_text", ".", "set_text", "(", "f'Time: {f * State.dt:.1f}, $\\\\tau = {tau}$'", ")", "\n", "", "else", ":", "\n", "            ", "time_text", ".", "set_text", "(", "f'Time: {f * State.dt:.1f}'", ")", "\n", "\n", "", "artists", "=", "[", "time_text", "]", "\n", "\n", "for", "s", "in", "states", "[", ":", "num_states", "]", ":", "\n", "            ", "s", ".", "state8", "=", "s", ".", "vec_list", "[", "f", "]", "\n", "artists", "+=", "s", ".", "update_artists", "(", "axes", ")", "\n", "\n", "", "for", "s", "in", "states", "[", "num_states", ":", "]", ":", "\n", "            ", "artists", "+=", "s", ".", "artists_list", "(", ")", "\n", "\n", "", "return", "artists", "\n", "\n", "", "my_anim", "=", "animation", ".", "FuncAnimation", "(", "fig", ",", "animate", ",", "frames", "=", "num_frames", ",", "interval", "=", "interval", ",", "blit", "=", "True", ",", "repeat", "=", "True", ")", "\n", "\n", "if", "save_mp4", ":", "\n", "        ", "writer", "=", "animation", ".", "writers", "[", "'ffmpeg'", "]", "(", "fps", "=", "10", ",", "metadata", "=", "dict", "(", "artist", "=", "'Stanley Bak'", ")", ",", "bitrate", "=", "1800", ")", "\n", "\n", "my_anim", ".", "save", "(", "f'{name}.mp4'", ",", "writer", "=", "writer", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.plot_paper_image": [[734, 871], ["print", "math.sqrt", "print", "axes.axis", "axes.set_xlabel", "axes.set_ylabel", "s.make_artists", "s.set_plane_visible", "s.update_artists", "axes.text", "matplotlib.tight_layout", "abs", "int", "print", "print", "print", "print", "enumerate", "print", "matplotlib.subplots", "matplotlib.subplots", "axes.set_title", "axes.legend", "axes.set_xticks", "axes.text", "axes.text", "matplotlib.show", "matplotlib.savefig", "print", "print", "print", "print", "print", "math.sqrt", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "replay.get_tau_index", "print", "abs", "axes.get_xticks", "round", "round", "round", "round"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.make_artists", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.set_plane_visible", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_artists", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_tau_index"], ["", "", "def", "plot_paper_image", "(", "s", ",", "rewind_seconds", ",", "title", ",", "name", ",", "square", "=", "False", ",", "show_legend", "=", "True", ",", "ownship_below", "=", "True", ")", ":", "\n", "    ", "\"\"\"plot the simulation image for the paper (and print table data)\"\"\"", "\n", "\n", "# set plane size", "\n", "intx", "=", "s", ".", "qinputs", "[", "0", "]", "[", "1", "]", "[", "4", "]", "\n", "print", "(", "f\"intx: {intx}\"", ")", "\n", "\n", "State", ".", "plane_size", "=", "abs", "(", "intx", ")", "/", "20", "\n", "\n", "if", "square", ":", "\n", "        ", "State", ".", "plane_size", "=", "int", "(", "State", ".", "plane_size", "*", "1.33", ")", "\n", "\n", "# print latex table info", "\n", "", "qinput", "=", "s", ".", "qinputs", "[", "0", "]", "[", "3", "]", "\n", "\n", "rho", ",", "theta", ",", "psi", ",", "v_own", ",", "v_int", "=", "qinput", "\n", "theta_deg", "=", "theta", "*", "180", "/", "math", ".", "pi", "\n", "psi_deg", "=", "psi", "*", "180", "/", "math", ".", "pi", "\n", "\n", "if", "not", "square", ":", "\n", "        ", "print", "(", "\"\\n% Auto-generated\"", ")", "\n", "print", "(", "f\"% The unrounded initial state is $\\\\rho$ = {rho} ft, $\\\\theta$ = {theta} rad, $\\\\psi={psi}$ rad, \"", "+", "f\"$v_{{own}}$ = {v_own} ft/sec, and $v_{{int}}$ = {v_int} ft/sec.\"", ")", "\n", "\n", "print", "(", "\"\\\\toprule\"", ")", "\n", "if", "s", ".", "tau_init", "==", "0", ":", "\n", "            ", "print", "(", "\"Step & $\\\\alpha_\\\\text{prev}$ & Cmd & $\\\\rho$ (ft) & $\\\\theta$ (deg) & $\\\\psi$ (deg) \\\\\\\\\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Step & $\\\\alpha_\\\\text{prev}$ & $\\\\tau$ & Net & Cmd & $\\\\rho$ (ft) & $\\\\theta$ (deg) & $\\\\psi$ (deg) \\\\\\\\\"", ")", "\n", "\n", "", "print", "(", "\"\\\\midrule\"", ")", "\n", "\n", "cmd_str", "=", "[", "\"\\\\textsc{coc}\"", ",", "\"\\\\textsc{wl}\"", ",", "\"\\\\textsc{wr}\"", ",", "\"\\\\textsc{sl}\"", ",", "\"\\\\textsc{sr}\"", "]", "\n", "found_error", "=", "False", "\n", "\n", "cur_tau", "=", "s", ".", "tau_init", "\n", "\n", "for", "i", ",", "tup", "in", "enumerate", "(", "s", ".", "qinputs", ")", ":", "\n", "            ", "net", ",", "state8", ",", "qstate", ",", "qinput", ",", "cmd", "=", "tup", "\n", "rho", ",", "theta", ",", "psi", ",", "v_own", ",", "v_int", "=", "qinput", "\n", "\n", "theta_deg", "=", "theta", "*", "180", "/", "math", ".", "pi", "\n", "psi_deg", "=", "psi", "*", "180", "/", "math", ".", "pi", "\n", "prefix", "=", "\"\"", "if", "not", "found_error", "else", "\"% \"", "\n", "\n", "print", "(", "f\"{prefix}{i+1} & {cmd_str[net]} & \"", ",", "end", "=", "''", ")", "\n", "\n", "if", "s", ".", "tau_init", "!=", "0", ":", "\n", "                ", "tindex", "=", "get_tau_index", "(", "cur_tau", ")", "\n", "net_str", "=", "f\"$N_{{{net+1},{tindex+1}}}$\"", "\n", "print", "(", "f\"{cur_tau} & {net_str} & \"", ",", "end", "=", "''", ")", "\n", "cur_tau", "-=", "1", "\n", "\n", "", "print", "(", "f\"{cmd_str[cmd]} & {rho:.1f} & {theta_deg:.2f} & {psi_deg:.2f} \\\\\\\\\"", ")", "\n", "dx", "=", "state8", "[", "0", "]", "-", "state8", "[", "4", "]", "\n", "dy", "=", "state8", "[", "1", "]", "-", "state8", "[", "5", "]", "\n", "\n", "dist", "=", "math", ".", "sqrt", "(", "dx", "*", "dx", "+", "dy", "*", "dy", ")", "\n", "#print(f\"dx: {dx}, dy: {dy}, dist: {dist}\")", "\n", "\n", "if", "abs", "(", "dist", "-", "s", ".", "min_dist", ")", "<", "1e-6", ":", "\n", "                ", "found_error", "=", "True", "\n", "\n", "", "", "print", "(", "\"\\\\bottomrule\\n\"", ")", "\n", "\n", "######", "\n", "\n", "", "dx", "=", "s", ".", "state8", "[", "0", "]", "-", "s", ".", "state8", "[", "4", "]", "\n", "dy", "=", "s", ".", "state8", "[", "1", "]", "-", "s", ".", "state8", "[", "5", "]", "\n", "dist", "=", "math", ".", "sqrt", "(", "dx", "*", "dx", "+", "dy", "*", "dy", ")", "\n", "print", "(", "f\"Plotting state with min_dist: {round(s.min_dist, 2)} and \"", "+", "f\"final dx: {round(dx, 1)}, dy: {round(dy, 1)}, dist: {round(dist, 2)}\"", ")", "\n", "\n", "if", "square", ":", "\n", "        ", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "1", ",", "ncols", "=", "1", ",", "figsize", "=", "(", "7", ",", "5", ")", ")", "\n", "", "else", ":", "\n", "        ", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "1", ",", "ncols", "=", "1", ",", "figsize", "=", "(", "10", ",", "7", ")", ")", "\n", "\n", "", "axes", ".", "axis", "(", "'equal'", ")", "\n", "\n", "if", "not", "square", ":", "\n", "        ", "axes", ".", "set_title", "(", "title", ")", "\n", "\n", "", "axes", ".", "set_xlabel", "(", "'X Position (ft)'", ")", "\n", "axes", ".", "set_ylabel", "(", "'Y Position (ft)'", ")", "\n", "\n", "if", "show_legend", ":", "\n", "        ", "custom_lines", "=", "[", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'g'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'b'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'k'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'c'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'r'", ",", "lw", "=", "2", ")", "]", "\n", "\n", "\n", "axes", ".", "legend", "(", "custom_lines", ",", "[", "'Strong Left'", ",", "'Weak Left'", ",", "'Clear of Conflict'", ",", "'Weak Right'", ",", "'Strong Right'", "]", ",", "fontsize", "=", "14", ",", "loc", "=", "'lower left'", ")", "\n", "\n", "", "s", ".", "make_artists", "(", "axes", ",", "show_intruder", "=", "True", ",", "animated", "=", "False", ")", "\n", "s", ".", "set_plane_visible", "(", "True", ")", "\n", "\n", "#for a in s.artists_list():", "\n", "#    a.set_visible(True)", "\n", "\n", "#s.state8 = s.vec_list[80]", "\n", "s", ".", "update_artists", "(", "axes", ",", "plane_index", "=", "0", ")", "\n", "\n", "init_state8", "=", "s", ".", "vec_list", "[", "0", "]", "\n", "xown", ",", "yown", "=", "init_state8", "[", "0", "]", ",", "init_state8", "[", "1", "]", "\n", "xint", ",", "yint", "=", "init_state8", "[", "4", "]", ",", "init_state8", "[", "5", "]", "\n", "\n", "if", "square", ":", "\n", "        ", "axes", ".", "set_xticks", "(", "axes", ".", "get_xticks", "(", ")", "[", ":", ":", "2", "]", ")", "\n", "\n", "", "if", "ownship_below", ":", "\n", "        ", "axes", ".", "text", "(", "xown", ",", "yown", "-", "0.5", "*", "State", ".", "plane_size", ",", "'Ownship'", ",", "horizontalalignment", "=", "'center'", ",", "fontsize", "=", "16", ",", "\n", "verticalalignment", "=", "'top'", ")", "\n", "", "else", ":", "\n", "        ", "axes", ".", "text", "(", "xown", ",", "yown", "+", "0.5", "*", "State", ".", "plane_size", ",", "'Ownship'", ",", "horizontalalignment", "=", "'center'", ",", "fontsize", "=", "16", ",", "\n", "verticalalignment", "=", "'bottom'", ")", "\n", "\n", "", "axes", ".", "text", "(", "xint", "+", "0.3", "*", "State", ".", "plane_size", ",", "yint", "+", "0.7", "*", "State", ".", "plane_size", ",", "'Intruder'", ",", "horizontalalignment", "=", "'center'", ",", "fontsize", "=", "16", ",", "\n", "verticalalignment", "=", "'bottom'", ")", "\n", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "plot_to_screen", "=", "False", "\n", "\n", "if", "plot_to_screen", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "", "else", ":", "\n", "        ", "if", "square", ":", "\n", "            ", "filename", "=", "f'square_{name}.png'", "\n", "", "else", ":", "\n", "            ", "filename", "=", "f'{name}.png'", "\n", "\n", "", "plt", ".", "savefig", "(", "filename", ")", "\n", "print", "(", "f\"saved image to {filename}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.slow_int_counterexample": [[872, 891], ["numpy.array", "numpy.array"], "function", ["None"], ["", "", "def", "slow_int_counterexample", "(", ")", ":", "\n", "    ", "\"\"\"slow int counterexample\"\"\"", "\n", "\n", "alpha_prev_list", "=", "[", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", "]", "\n", "qtheta1", "=", "311", "\n", "qv_own", "=", "11", "\n", "qv_int", "=", "39", "\n", "# chebeshev center radius: 0.0745862895428716", "\n", "end", "=", "np", ".", "array", "(", "[", "-", "99.92541371", ",", "-", "499.92541371", ",", "74.1164437", ",", "-", "82.42611738", ",", "\n", "0.", ",", "390.10329256", "]", ")", "\n", "start", "=", "np", ".", "array", "(", "[", "-", "5360.83116819", ",", "7007.87669426", ",", "-", "65.21523383", ",", "-", "89.63417501", ",", "\n", "-", "40570.74242582", ",", "390.10329256", "]", ")", "\n", "\n", "label", "=", "\"Unsafe Simulation with Slow Intruder\"", "\n", "name", "=", "\"sintruder\"", "\n", "ownship_below", "=", "False", "\n", "rewind_secs", "=", "54", "\n", "\n", "return", "alpha_prev_list", ",", "qtheta1", ",", "qv_own", ",", "qv_int", ",", "end", ",", "start", ",", "rewind_secs", ",", "label", ",", "name", ",", "ownship_below", ",", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.fast_own_counterexample": [[892, 911], ["numpy.array", "numpy.array"], "function", ["None"], ["", "def", "fast_own_counterexample", "(", ")", ":", "\n", "    ", "\"\"\"fast ownship counterexample\"\"\"", "\n", "\n", "alpha_prev_list", "=", "[", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "2", ",", "4", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "qtheta1", "=", "271", "\n", "qv_own", "=", "141", "\n", "qv_int", "=", "191", "\n", "\n", "# chebeshev center radius: 0.0862464378412363", "\n", "end", "=", "np", ".", "array", "(", "[", "125.08624644", ",", "-", "374.91375356", ",", "832.65122387", ",", "-", "289.52569934", ",", "\n", "0.", ",", "1199.91375356", "]", ")", "\n", "start", "=", "np", ".", "array", "(", "[", "-", "27057.6501092", ",", "-", "12592.0447243", ",", "603.16465115", ",", "642.90403234", ",", "\n", "-", "43196.89512824", ",", "1199.91375356", "]", ")", "\n", "\n", "label", "=", "\"Unsafe Simulation with Fast Ownship\"", "\n", "name", "=", "\"fownship\"", "\n", "ownship_below", "=", "True", "\n", "\n", "return", "alpha_prev_list", ",", "qtheta1", ",", "qv_own", ",", "qv_int", ",", "end", ",", "start", ",", "40", ",", "label", ",", "name", ",", "ownship_below", ",", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.first_counterexample": [[912, 931], ["numpy.array", "numpy.array"], "function", ["None"], ["", "def", "first_counterexample", "(", ")", ":", "\n", "    ", "\"\"\"first counterexample found with full range\"\"\"", "\n", "\n", "alpha_prev_list", "=", "[", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "2", ",", "2", ",", "2", ",", "2", ",", "4", ",", "2", ",", "4", ",", "2", ",", "4", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "0", ",", "0", "]", "\n", "qtheta1", "=", "73", "\n", "qv_own", "=", "1", "\n", "qv_int", "=", "11", "\n", "\n", "# chebeshev center radius: 0.002787609183986557", "\n", "end", "=", "np", ".", "array", "(", "[", "-", "2.78760918e-03", ",", "-", "2.78760918e-03", ",", "1.40264128e+02", ",", "6.51710649e+00", ",", "\n", "0.00000000e+00", ",", "1.11319526e+03", "]", ")", "\n", "start", "=", "np", ".", "array", "(", "[", "-", "2.90279886e+03", ",", "-", "6.47159328e+03", ",", "-", "4.95421358e+01", ",", "1.31385216e+02", ",", "\n", "-", "6.45653252e+04", ",", "1.11319526e+03", "]", ")", "\n", "\n", "label", "=", "\"Unsafe Simulation from Full Range Search\"", "\n", "name", "=", "\"first\"", "\n", "ownship_below", "=", "True", "\n", "\n", "return", "alpha_prev_list", ",", "qtheta1", ",", "qv_own", ",", "qv_int", ",", "end", ",", "start", ",", "0", ",", "label", ",", "name", ",", "ownship_below", ",", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.causecrash_counterexample": [[932, 951], ["numpy.array", "numpy.array"], "function", ["None"], ["", "def", "causecrash_counterexample", "(", ")", ":", "\n", "    ", "\"\"\"counterexample with system causing crash\"\"\"", "\n", "\n", "alpha_prev_list", "=", "[", "2", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "0", ",", "0", "]", "\n", "qtheta1", "=", "251", "\n", "qv_own", "=", "1", "\n", "qv_int", "=", "11", "\n", "# chebeshev center radius: 0.3131329350035088", "\n", "end", "=", "np", ".", "array", "(", "[", "-", "91.14038384", ",", "-", "113.50961537", ",", "7.05436552", ",", "-", "114.0578106", ",", "\n", "0.", ",", "1100.31313294", "]", ")", "\n", "start", "=", "np", ".", "array", "(", "[", "-", "5.14945097e+03", ",", "2.35145935e+03", ",", "1.09259575e+02", ",", "3.34857199e+01", ",", "\n", "-", "6.16175354e+04", ",", "1.10031313e+03", "]", ")", "\n", "\n", "label", "=", "\"ACAS Xu Causes Crash\"", "\n", "name", "=", "\"causecrash\"", "\n", "ownship_below", "=", "False", "\n", "rewind_seconds", "=", "5", "\n", "\n", "return", "alpha_prev_list", ",", "qtheta1", ",", "qv_own", ",", "qv_int", ",", "end", ",", "start", ",", "rewind_seconds", ",", "label", ",", "name", ",", "ownship_below", ",", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.leftturn_counterexample": [[952, 971], ["numpy.array", "numpy.array"], "function", ["None"], ["", "def", "leftturn_counterexample", "(", ")", ":", "\n", "    ", "\"\"\"counterexample with left turn\"\"\"", "\n", "\n", "alpha_prev_list", "=", "[", "3", ",", "1", ",", "3", ",", "3", ",", "3", ",", "3", ",", "3", ",", "3", ",", "3", ",", "4", ",", "4", ",", "2", ",", "2", ",", "4", ",", "2", ",", "4", ",", "2", ",", "2", ",", "4", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "0", ",", "0", "]", "\n", "qtheta1", "=", "80", "\n", "qv_own", "=", "1", "\n", "qv_int", "=", "11", "\n", "# chebeshev center radius: 0.7098492629880065", "\n", "end", "=", "np", ".", "array", "(", "[", "-", "9.21718532e+01", ",", "-", "7.09849263e-01", ",", "3.31710259e+01", ",", "1.21053307e+02", ",", "\n", "0.00000000e+00", ",", "1.16386763e+03", "]", ")", "\n", "start", "=", "np", ".", "array", "(", "[", "-", "705.16444772", ",", "-", "6179.58516646", ",", "-", "64.9755391", ",", "107.38901002", ",", "\n", "-", "61684.98415307", ",", "1163.86762553", "]", ")", "\n", "\n", "label", "=", "\"leftturn\"", "\n", "name", "=", "\"leftturn\"", "\n", "rewind_seconds", "=", "40", "\n", "ownship_below", "=", "True", "\n", "\n", "return", "alpha_prev_list", ",", "qtheta1", ",", "qv_own", ",", "qv_int", ",", "end", ",", "start", ",", "rewind_seconds", ",", "label", ",", "name", ",", "ownship_below", ",", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.taudot_faster": [[972, 992], ["numpy.array", "numpy.array"], "function", ["None"], ["", "def", "taudot_faster", "(", ")", ":", "\n", "    ", "\"\"\"counterexample with faster taudo\"\"\"", "\n", "\n", "alpha_prev_list", "=", "[", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "4", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "2", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "qtheta1", "=", "1203", "\n", "qv_own", "=", "308", "\n", "qv_int", "=", "383", "\n", "tau_init", "=", "75", "\n", "# chebeshev center radius: 1.5625", "\n", "end", "=", "np", ".", "array", "(", "[", "157.8125", ",", "-", "472.82520614", ",", "880.07472818", ",", "-", "393.54488338", ",", "\n", "0.", ",", "1198.4375", "]", ")", "\n", "start", "=", "np", ".", "array", "(", "[", "-", "4.50466117e+04", ",", "-", "4.13894837e+04", ",", "-", "2.36741160e+01", ",", "9.63767938e+02", ",", "\n", "-", "8.98828125e+04", ",", "1.19843750e+03", "]", ")", "\n", "\n", "label", "=", "\"Unsafe with $v_{own} > 950$ ft/sec and $\\\\tau > 0$\"", "\n", "name", "=", "\"faster_taudot\"", "\n", "rewind_seconds", "=", "0", "\n", "ownship_below", "=", "True", "\n", "\n", "return", "alpha_prev_list", ",", "qtheta1", ",", "qv_own", ",", "qv_int", ",", "end", ",", "start", ",", "rewind_seconds", ",", "label", ",", "name", ",", "ownship_below", ",", "tau_init", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.main": [[993, 1144], ["replay.init_plot", "enumerate", "case_func", "math.sqrt", "math.sqrt", "math.sqrt", "print", "print", "print", "print", "replay.State", "replay.State.simulate", "print", "isinstance", "math.sqrt", "print", "print", "replay.get_time_elapse_mat", "print", "print", "print", "math.atan2", "print", "print", "replay.quantize", "print", "print", "cmd_list.append", "numpy.array", "print", "print", "print", "print", "numpy.linalg.norm", "print", "print", "print", "print", "print", "print", "print", "replay.plot", "matplotlib.clf", "replay.plot_paper_image", "matplotlib.clf", "replay.plot_paper_image", "len", "abs", "enumerate", "list", "list", "print", "print", "print", "reversed", "reversed", "round", "round", "round", "round", "list", "reversed", "tuple", "tuple"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.init_plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.simulate", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_time_elapse_mat", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.quantize", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.plot_paper_image", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.replay.plot_paper_image"], ["", "def", "main", "(", ")", ":", "\n", "    ", "'main entry point'", "\n", "\n", "global", "skip_quantization", "\n", "try_without_quantization", "=", "True", "\n", "\n", "init_plot", "(", ")", "\n", "#case_funcs = [first_counterexample, causecrash_counterexample, taudot_faster, slow_int_counterexample]", "\n", "case_funcs", "=", "[", "taudot_faster", "]", "\n", "paper", "=", "True", "# false = plot to screen, true = save images, print latex table, and save mp4 video (if uncommented)", "\n", "\n", "for", "i", ",", "case_func", "in", "enumerate", "(", "case_funcs", ")", ":", "\n", "        ", "alpha_prev_list", ",", "qtheta1", ",", "qv_own", ",", "qv_int", ",", "end", ",", "start", ",", "rewind_seconds", ",", "label", ",", "name", ",", "ownship_below", ",", "tau_init", "=", "case_func", "(", ")", "\n", "tau_dot", "=", "0", "if", "tau_init", "==", "0", "else", "-", "1", "\n", "\n", "###################", "\n", "#alpha_prev_list, qtheta1, qv_own, qv_int, end, start, label = fast_own_counterexample() #slow_int_counterexample()", "\n", "#alpha_prev_list, qtheta1, qv_own, qv_int, end, start, rewind_seconds, label, name = leftturn_counterexample()", "\n", "##################", "\n", "\n", "skip_checks", "=", "True", "\n", "\n", "if", "try_without_quantization", ":", "\n", "            ", "skip_quantization", "=", "True", "\n", "skip_checks", "=", "True", "\n", "#alpha_prev_list = []", "\n", "\n", "", "theta1_quantum", "=", "Settings", ".", "theta1_q", "\n", "\n", "q_theta1", "=", "qtheta1", "*", "theta1_quantum", "+", "theta1_quantum", "/", "2", "\n", "cmd_list", "=", "[", "0", "]", "*", "(", "len", "(", "alpha_prev_list", ")", "-", "1", ")", "\n", "\n", "init_vec", "=", "[", "start", "[", "0", "]", ",", "start", "[", "1", "]", ",", "start", "[", "2", "]", ",", "start", "[", "3", "]", ",", "start", "[", "4", "]", ",", "0", ",", "start", "[", "5", "]", ",", "0", "]", "\n", "\n", "# run time backwards N seconds", "\n", "\n", "if", "rewind_seconds", "!=", "0", ":", "\n", "            ", "assert", "isinstance", "(", "rewind_seconds", ",", "int", ")", "\n", "\n", "dx", "=", "init_vec", "[", "0", "]", "-", "init_vec", "[", "4", "]", "\n", "dy", "=", "init_vec", "[", "1", "]", "-", "0", "\n", "rho_before_rewind", "=", "math", ".", "sqrt", "(", "dx", "**", "2", "+", "dy", "**", "2", ")", "\n", "print", "(", "f\"before rewind rho: {rho_before_rewind}\"", ")", "\n", "\n", "print", "(", "f\"rewinding by {rewind_seconds} seconds\"", ")", "\n", "a_mat", "=", "get_time_elapse_mat", "(", "0", ",", "-", "rewind_seconds", ")", "\n", "init_vec", "=", "a_mat", "@", "init_vec", "\n", "\n", "cmd_list", "=", "[", "cmd_list", "[", "0", "]", "]", "*", "rewind_seconds", "+", "cmd_list", "\n", "########", "\n", "\n", "", "_", ",", "_", ",", "vx", ",", "vy", ",", "_", ",", "vxi", "=", "start", "\n", "own_vel", "=", "math", ".", "sqrt", "(", "vx", "**", "2", "+", "vy", "**", "2", ")", "\n", "int_vel", "=", "math", ".", "sqrt", "(", "vxi", "**", "2", ")", "\n", "dx", "=", "init_vec", "[", "0", "]", "-", "init_vec", "[", "4", "]", "\n", "dy", "=", "init_vec", "[", "1", "]", "-", "0", "\n", "init_rho", "=", "math", ".", "sqrt", "(", "dx", "**", "2", "+", "dy", "**", "2", ")", "\n", "\n", "print", "(", "f\"init tau: {tau_init}\"", ")", "\n", "print", "(", "f\"init rho: {init_rho}\"", ")", "\n", "print", "(", "f\"init own vel: {own_vel}\"", ")", "\n", "print", "(", "f\"init int vel: {int_vel}\"", ")", "\n", "\n", "if", "not", "skip_quantization", "and", "not", "skip_checks", ":", "\n", "# double-check quantization matches expectation", "\n", "\n", "            ", "print", "(", "f\"own_vel computed: {own_vel}, quantized: {qv_own}\"", ")", "\n", "print", "(", "f\"int_vel computed: {int_vel}, quantized: {qv_int}\"", ")", "\n", "\n", "print", "(", "f\"ownship vx / vy = {vx}, {vy}\"", ")", "\n", "\n", "theta1", "=", "math", ".", "atan2", "(", "vy", ",", "vx", ")", "\n", "print", "(", "f\"real theta1: {theta1}\"", ")", "\n", "theta1_deg", "=", "theta1", "*", "360", "/", "(", "2", "*", "math", ".", "pi", ")", "\n", "q_theta1_deg", "=", "q_theta1", "*", "360", "/", "(", "2", "*", "math", ".", "pi", ")", "\n", "print", "(", "f\"q_theta1 computed: {round(theta1_deg, 3)} deg, quantized: {round(q_theta1_deg, 3)} deg\"", ")", "\n", "\n", "actual_qtheta1", "=", "quantize", "(", "theta1", ",", "theta1_quantum", ")", "\n", "if", "actual_qtheta1", "<", "0", ":", "\n", "                ", "actual_qtheta1", "+=", "2", "*", "math", ".", "pi", "\n", "\n", "", "print", "(", "f\"actual_qtheta1: {actual_qtheta1}\"", ")", "\n", "actual_qtheta1_deg", "=", "actual_qtheta1", "*", "360", "/", "(", "2", "*", "math", ".", "pi", ")", "\n", "\n", "print", "(", "f\"actual_qtheta1_deg = {actual_qtheta1_deg}\"", ")", "\n", "assert", "abs", "(", "actual_qtheta1", "-", "q_theta1", ")", "<", "1e-4", ",", "f\"qtheta1 was actually {round(actual_qtheta1_deg, 3)}, \"", "+", "f\"expected {round(q_theta1_deg, 3)}\"", "\n", "\n", "# run the simulation", "\n", "", "s", "=", "State", "(", "init_vec", ",", "tau_init", ",", "tau_dot", ",", "save_states", "=", "True", ")", "\n", "\n", "s", ".", "command", "=", "alpha_prev_list", "[", "-", "1", "]", "\n", "\n", "if", "skip_checks", ":", "\n", "            ", "cmd_list", ".", "append", "(", "cmd_list", "[", "-", "1", "]", ")", "# simulate one extra step", "\n", "\n", "", "s", ".", "simulate", "(", "cmd_list", ",", "stdout", "=", "False", ")", "\n", "print", "(", "\"Simulation completed.\\n\"", ")", "\n", "\n", "if", "not", "skip_checks", ":", "\n", "\n", "# extra printing on trace", "\n", "            ", "if", "False", ":", "\n", "                ", "for", "i", ",", "(", "net", ",", "state8", ",", "qstate", ",", "qinput", ",", "cmd_out", ")", "in", "enumerate", "(", "s", ".", "qinputs", ")", ":", "\n", "                    ", "print", "(", "f\"{i+1}. network {net} with qinput: {tuple(q for q in qinput)} -> {cmd_out}\"", ")", "\n", "print", "(", "f\"state: {tuple(x for x in state8)}\"", ")", "\n", "print", "(", "f\"qstate: {[x for x in qstate]}\"", ")", "\n", "\n", "", "", "expected_end", "=", "np", ".", "array", "(", "[", "end", "[", "0", "]", ",", "end", "[", "1", "]", ",", "end", "[", "2", "]", ",", "end", "[", "3", "]", ",", "end", "[", "4", "]", ",", "0", ",", "end", "[", "5", "]", ",", "0", "]", ")", "\n", "print", "(", "f\"expected end: {expected_end}\"", ")", "\n", "print", "(", "f\"actual end: {s.state8}\"", ")", "\n", "\n", "print", "(", "f\"cmds: {s.commands}, alpha_prev_list: {list(reversed(alpha_prev_list[:-1]))}\"", ")", "\n", "\n", "assert", "s", ".", "commands", "==", "list", "(", "reversed", "(", "alpha_prev_list", "[", ":", "-", "1", "]", ")", ")", ",", "\"command mismatch\"", "\n", "print", "(", "\"commands matched!\"", ")", "\n", "\n", "difference", "=", "np", ".", "linalg", ".", "norm", "(", "s", ".", "state8", "-", "expected_end", ",", "ord", "=", "np", ".", "inf", ")", "\n", "print", "(", "f\"end state difference: {difference}\"", ")", "\n", "assert", "difference", "<", "1e-2", ",", "f\"end state mismatch. difference was {difference}\"", "\n", "print", "(", "\"end states were close enough\"", ")", "\n", "", "else", ":", "\n", "            ", "got_cmds", "=", "s", ".", "commands", "[", "rewind_seconds", ":", "rewind_seconds", "+", "10", "]", "\n", "expected_cmds", "=", "list", "(", "reversed", "(", "alpha_prev_list", "[", ":", "-", "1", "]", ")", ")", "[", "rewind_seconds", ":", "rewind_seconds", "+", "10", "]", "\n", "\n", "print", "(", "f\"Got first few commands: {got_cmds}\"", ")", "\n", "print", "(", "f\"Expected first few commands: {expected_cmds}\"", ")", "\n", "\n", "print", "(", "\"WARNING: skipped sanity checks on replay\"", ")", "\n", "\n", "", "if", "rewind_seconds", "!=", "0", ":", "\n", "            ", "print", "(", "f\"commands: {s.commands}\"", ")", "\n", "print", "(", "\"WARNING: rewind_seconds != 0\"", ")", "\n", "\n", "# optional: do plot", "\n", "\n", "#plot(s, save_mp4=True)", "\n", "#title = f\"Unsafe Simulation ($v_{{int}}$={round(int_vel, 2)} ft/sec)\"", "\n", "#title = f\"Unsafe Simulation ($v_{{own}}$={round(own_vel, 2)} ft/sec)\"", "\n", "", "if", "not", "paper", ":", "\n", "            ", "plot", "(", "s", ",", "save_mp4", "=", "False", ")", "\n", "break", "\n", "", "else", ":", "\n", "#plot(s, name=name, save_mp4=True)", "\n", "            ", "plt", ".", "clf", "(", ")", "\n", "plot_paper_image", "(", "s", ",", "rewind_seconds", ",", "label", ",", "name", ",", "ownship_below", "=", "ownship_below", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n", "show_legend", "=", "i", "==", "0", "\n", "plot_paper_image", "(", "s", ",", "rewind_seconds", ",", "label", ",", "name", ",", "square", "=", "True", ",", "show_legend", "=", "show_legend", ",", "\n", "ownship_below", "=", "ownship_below", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.dubins.init_to_constraints": [[16, 122], ["box.append", "box.append", "box.append", "box.append", "math.cos", "a_mat.append", "b_vec.append", "math.sin", "a_mat.append", "b_vec.append", "numpy.array().dot", "a_mat.append", "b_vec.append", "numpy.array", "a_mat.append", "b_vec.append", "numpy.array", "a_mat.append", "b_vec.append", "box.append", "box.append", "math.sin", "math.cos", "numpy.array", "numpy.array", "vx.append", "vy.append", "min", "max", "min", "max", "numpy.array", "math.cos", "math.sin", "math.cos", "math.sin", "math.cos", "math.sin", "math.cos", "math.sin", "math.cos", "math.sin"], "function", ["None"], ["def", "init_to_constraints", "(", "qx", ":", "int", ",", "qy", ":", "int", ",", "\n", "qv_own_min", ":", "int", ",", "qv_int_min", ":", "int", ",", "qtheta1_min", ":", "int", ")", ":", "\n", "    ", "\"\"\"convert initial variables to box bounds and constraints in linear space\n\n    returns box, a_mat, b_vec with Ax <= b constraints\n    \"\"\"", "\n", "\n", "box", ":", "List", "[", "Tuple", "[", "float", ",", "float", "]", "]", "=", "[", "]", "\n", "a_mat", ":", "List", "[", "List", "[", "float", "]", "]", "=", "[", "]", "\n", "b_vec", ":", "List", "[", "float", "]", "=", "[", "]", "\n", "\n", "pos_quantum", "=", "Settings", ".", "pos_q", "\n", "vel_quantum", "=", "Settings", ".", "vel_q", "\n", "theta1_quantum", "=", "Settings", ".", "theta1_q", "\n", "\n", "# convert to float ranges for box", "\n", "x", "=", "qx", "*", "pos_quantum", ",", "(", "qx", "+", "1", ")", "*", "pos_quantum", "\n", "y", "=", "qy", "*", "pos_quantum", ",", "(", "qy", "+", "1", ")", "*", "pos_quantum", "\n", "\n", "qv_own", "=", "qv_own_min", ",", "qv_own_min", "+", "1", "\n", "qv_int", "=", "qv_int_min", ",", "qv_int_min", "+", "1", "\n", "qtheta1", "=", "qtheta1_min", ",", "qtheta1_min", "+", "1", "\n", "\n", "if", "vel_quantum", "!=", "0", ":", "\n", "        ", "v_own", "=", "(", "qv_own", "[", "0", "]", "*", "vel_quantum", ",", "qv_own", "[", "1", "]", "*", "vel_quantum", ")", "\n", "v_int", "=", "(", "qv_int", "[", "0", "]", "*", "vel_quantum", ",", "qv_int", "[", "1", "]", "*", "vel_quantum", ")", "\n", "", "else", ":", "\n", "        ", "assert", "qv_own", "[", "0", "]", "+", "1", "==", "qv_own", "[", "1", "]", "and", "qv_int", "[", "0", "]", "+", "1", "==", "qv_int", "[", "1", "]", "\n", "# fixed velocities", "\n", "\n", "v_own", "=", "qv_own", "[", "0", "]", ",", "qv_own", "[", "0", "]", "\n", "v_int", "=", "qv_int", "[", "0", "]", ",", "qv_int", "[", "0", "]", "\n", "\n", "", "theta1", "=", "(", "qtheta1", "[", "0", "]", "*", "theta1_quantum", ",", "qtheta1", "[", "1", "]", "*", "theta1_quantum", ")", "\n", "\n", "box", ".", "append", "(", "x", ")", "\n", "box", ".", "append", "(", "y", ")", "\n", "\n", "# compute vx and vy from theta1 and v_own", "\n", "tol", "=", "1e-9", "\n", "\n", "# make sure limit will be one of the four sampled combinations", "\n", "assert", "theta1", "[", "0", "]", "<", "theta1", "[", "1", "]", "and", "theta1", "[", "0", "]", "+", "tol", ">=", "0", "and", "theta1", "[", "1", "]", "-", "tol", "<=", "2", "*", "pi", "\n", "assert", "not", "(", "theta1", "[", "0", "]", "+", "tol", "<", "pi", "/", "2", "<", "theta1", "[", "1", "]", "-", "tol", ")", "\n", "assert", "not", "(", "theta1", "[", "0", "]", "+", "tol", "<", "pi", "<", "theta1", "[", "1", "]", "-", "tol", ")", "\n", "assert", "not", "(", "theta1", "[", "0", "]", "+", "tol", "<", "3", "*", "pi", "/", "2", "<", "theta1", "[", "1", "]", "-", "tol", ")", "\n", "\n", "vx", "=", "[", "]", "\n", "vy", "=", "[", "]", "\n", "\n", "for", "theta1_scalar", "in", "theta1", ":", "\n", "        ", "for", "v_own_scalar", "in", "v_own", ":", "\n", "            ", "vx", ".", "append", "(", "cos", "(", "theta1_scalar", ")", "*", "v_own_scalar", ")", "\n", "vy", ".", "append", "(", "sin", "(", "theta1_scalar", ")", "*", "v_own_scalar", ")", "\n", "\n", "", "", "box", ".", "append", "(", "(", "min", "(", "vx", ")", ",", "max", "(", "vx", ")", ")", ")", "\n", "box", ".", "append", "(", "(", "min", "(", "vy", ")", ",", "max", "(", "vy", ")", ")", ")", "\n", "\n", "# make pie constraints", "\n", "\n", "# top-left", "\n", "row", "=", "[", "0.0", "]", "*", "Star", ".", "NUM_VARS", "\n", "row", "[", "Star", ".", "VX_OWN", "]", "=", "-", "sin", "(", "theta1", "[", "1", "]", ")", "\n", "row", "[", "Star", ".", "VY_OWN", "]", "=", "cos", "(", "theta1", "[", "1", "]", ")", "\n", "a_mat", ".", "append", "(", "row", ")", "\n", "b_vec", ".", "append", "(", "0", ")", "\n", "\n", "# bottom-right", "\n", "row", "=", "[", "0.0", "]", "*", "Star", ".", "NUM_VARS", "\n", "row", "[", "Star", ".", "VX_OWN", "]", "=", "sin", "(", "theta1", "[", "0", "]", ")", "\n", "row", "[", "Star", ".", "VY_OWN", "]", "=", "-", "cos", "(", "theta1", "[", "0", "]", ")", "\n", "a_mat", ".", "append", "(", "row", ")", "\n", "b_vec", ".", "append", "(", "0", ")", "\n", "\n", "# bottom-left", "\n", "p1", "=", "np", ".", "array", "(", "[", "cos", "(", "theta1", "[", "1", "]", ")", ",", "sin", "(", "theta1", "[", "1", "]", ")", "]", ")", "*", "v_own", "[", "0", "]", "\n", "p2", "=", "np", ".", "array", "(", "[", "cos", "(", "theta1", "[", "0", "]", ")", ",", "sin", "(", "theta1", "[", "0", "]", ")", "]", ")", "*", "v_own", "[", "0", "]", "\n", "delta", "=", "p1", "-", "p2", "\n", "row", "=", "[", "0.0", "]", "*", "Star", ".", "NUM_VARS", "\n", "row", "[", "Star", ".", "VX_OWN", "]", "=", "-", "delta", "[", "1", "]", "\n", "row", "[", "Star", ".", "VY_OWN", "]", "=", "delta", "[", "0", "]", "\n", "r", "=", "np", ".", "array", "(", "[", "-", "delta", "[", "1", "]", ",", "delta", "[", "0", "]", "]", ")", ".", "dot", "(", "p1", ")", "\n", "a_mat", ".", "append", "(", "row", ")", "\n", "b_vec", ".", "append", "(", "r", ")", "\n", "\n", "# top right (#1, left one)", "\n", "p1", "=", "np", ".", "array", "(", "[", "cos", "(", "theta1", "[", "1", "]", ")", ",", "sin", "(", "theta1", "[", "1", "]", ")", "]", ")", "\n", "row", "=", "[", "0.0", "]", "*", "Star", ".", "NUM_VARS", "\n", "row", "[", "Star", ".", "VX_OWN", "]", "=", "p1", "[", "0", "]", "\n", "row", "[", "Star", ".", "VY_OWN", "]", "=", "p1", "[", "1", "]", "\n", "a_mat", ".", "append", "(", "row", ")", "\n", "b_vec", ".", "append", "(", "v_own", "[", "1", "]", ")", "\n", "\n", "# top right (#2, right one)", "\n", "p1", "=", "np", ".", "array", "(", "[", "cos", "(", "theta1", "[", "0", "]", ")", ",", "sin", "(", "theta1", "[", "0", "]", ")", "]", ")", "\n", "row", "=", "[", "0.0", "]", "*", "Star", ".", "NUM_VARS", "\n", "row", "[", "Star", ".", "VX_OWN", "]", "=", "p1", "[", "0", "]", "\n", "row", "[", "Star", ".", "VY_OWN", "]", "=", "p1", "[", "1", "]", "\n", "a_mat", ".", "append", "(", "row", ")", "\n", "b_vec", ".", "append", "(", "v_own", "[", "1", "]", ")", "\n", "\n", "############", "\n", "box", ".", "append", "(", "(", "0.0", ",", "0.0", ")", ")", "# x_int", "\n", "box", ".", "append", "(", "v_int", ")", "# vx_int", "\n", "\n", "return", "box", ",", "a_mat", ",", "b_vec", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.dubins.get_time_elapse_mat": [[123, 148], ["functools.lru_cache", "numpy.array", "scipy.linalg.expm"], "function", ["None"], ["", "@", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "get_time_elapse_mat", "(", "command1", ",", "dt", ")", ":", "\n", "    ", "'''get the matrix exponential for the given command\n\n    state: x_own, y_own, vx_own, vy_own, x_int, vx_int\n    '''", "\n", "\n", "y_list", "=", "[", "0.0", ",", "1.5", ",", "-", "1.5", ",", "3.0", ",", "-", "3.0", "]", "\n", "y1", "=", "y_list", "[", "command1", "]", "\n", "\n", "dtheta1", "=", "(", "y1", "/", "180", "*", "np", ".", "pi", ")", "\n", "\n", "a_mat", "=", "np", ".", "array", "(", "[", "\n", "[", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "# x' = vx", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", "]", ",", "# y' = vy", "\n", "[", "0", ",", "0", ",", "0", ",", "-", "dtheta1", ",", "0", ",", "0", "]", ",", "# vx' = -vy * dtheta1", "\n", "[", "0", ",", "0", ",", "dtheta1", ",", "0", ",", "0", ",", "0", "]", ",", "# vy' = vx * dtheta1", "\n", "#", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", "]", ",", "# x_int' = vx_int", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "# vx_int' = 0", "\n", "]", ",", "dtype", "=", "float", ")", "\n", "\n", "assert", "a_mat", ".", "shape", "[", "0", "]", "==", "a_mat", ".", "shape", "[", "1", "]", "\n", "\n", "return", "expm", "(", "a_mat", "*", "dt", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.__init__": [[62, 77], ["swiglpk.glp_create_prob", "other_lpi.names.copy", "swiglpk.glp_copy_prob"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy"], ["def", "__init__", "(", "self", ",", "other_lpi", "=", "None", ")", ":", "\n", "        ", "'initialize the lp instance'", "\n", "\n", "self", ".", "lp", "=", "glpk", ".", "glp_create_prob", "(", ")", "# pylint: disable=invalid-name", "\n", "\n", "if", "other_lpi", "is", "None", ":", "\n", "# internal bookkeeping", "\n", "            ", "self", ".", "names", "=", "[", "]", "# column names", "\n", "\n", "# setup lp params", "\n", "", "else", ":", "\n", "# initialize from other lpi", "\n", "            ", "self", ".", "names", "=", "other_lpi", ".", "names", ".", "copy", "(", ")", "\n", "\n", "glpk", ".", "glp_copy_prob", "(", "self", ".", "lp", ",", "other_lpi", ".", "lp", ",", "glpk", ".", "GLP_OFF", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.__del__": [[78, 85], ["hasattr", "isinstance", "swiglpk.glp_delete_prob"], "methods", ["None"], ["", "", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "'lp'", ")", "and", "self", ".", "lp", "is", "not", "None", ":", "\n", "\n", "            ", "if", "not", "isinstance", "(", "self", ".", "lp", ",", "tuple", ")", ":", "\n", "                ", "glpk", ".", "glp_delete_prob", "(", "self", ".", "lp", ")", "\n", "\n", "", "self", ".", "lp", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.__deepcopy__": [[86, 88], ["lpinstance.LpInstance"], "methods", ["None"], ["", "", "def", "__deepcopy__", "(", "self", ",", "memo", ")", ":", "\n", "        ", "return", "LpInstance", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_col_bounds": [[89, 119], ["lpinstance.LpInstance.get_num_cols", "range", "swiglpk.glp_get_col_type", "col_bounds.append", "swiglpk.glp_get_col_ub", "swiglpk.glp_get_col_lb", "swiglpk.glp_get_col_lb", "swiglpk.glp_get_col_lb"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols"], ["", "def", "get_col_bounds", "(", "self", ")", ":", "\n", "        ", "'''get column bounds\n\n        for external use use star's get_input_bounds which may be tighter\n        '''", "\n", "\n", "lp_cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "# column lower and upper bounds", "\n", "col_bounds", "=", "[", "]", "\n", "\n", "for", "col", "in", "range", "(", "lp_cols", ")", ":", "\n", "            ", "col_type", "=", "glpk", ".", "glp_get_col_type", "(", "self", ".", "lp", ",", "col", "+", "1", ")", "\n", "\n", "ub", "=", "np", ".", "inf", "\n", "lb", "=", "-", "np", ".", "inf", "\n", "\n", "if", "col_type", "==", "glpk", ".", "GLP_DB", ":", "\n", "                ", "ub", "=", "glpk", ".", "glp_get_col_ub", "(", "self", ".", "lp", ",", "col", "+", "1", ")", "\n", "lb", "=", "glpk", ".", "glp_get_col_lb", "(", "self", ".", "lp", ",", "col", "+", "1", ")", "\n", "", "elif", "col_type", "==", "glpk", ".", "GLP_LO", ":", "\n", "                ", "lb", "=", "glpk", ".", "glp_get_col_lb", "(", "self", ".", "lp", ",", "col", "+", "1", ")", "\n", "", "elif", "col_type", "==", "glpk", ".", "GLP_FX", ":", "\n", "                ", "lb", "=", "ub", "=", "glpk", ".", "glp_get_col_lb", "(", "self", ".", "lp", ",", "col", "+", "1", ")", "\n", "", "else", ":", "\n", "                ", "assert", "col_type", "==", "glpk", ".", "GLP_FR", ",", "\"unsupported col type in get_col_bounds()\"", "\n", "\n", "", "col_bounds", ".", "append", "(", "(", "lb", ",", "ub", ")", ")", "\n", "\n", "", "return", "col_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.__getstate__": [[120, 154], ["lpinstance.LpInstance.get_num_rows", "lpinstance.LpInstance.get_num_cols", "lpinstance.SwigArray.get_int_array", "lpinstance.SwigArray.get_double_array", "range", "range", "lpinstance.LpInstance.get_col_bounds", "swiglpk.glp_get_mat_row", "range", "indptr.append", "rhs.append", "data.append", "glpk_indices.append", "len", "swiglpk.glp_get_row_type", "swiglpk.glp_get_row_ub"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_int_array", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_double_array", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_col_bounds"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "        ", "'need special handling due to swiglpk'", "\n", "\n", "# get constraints as csr matrix", "\n", "lp_rows", "=", "self", ".", "get_num_rows", "(", ")", "\n", "lp_cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "inds_row", "=", "SwigArray", ".", "get_int_array", "(", "lp_cols", "+", "1", ")", "\n", "vals_row", "=", "SwigArray", ".", "get_double_array", "(", "lp_cols", "+", "1", ")", "\n", "\n", "data", "=", "[", "]", "\n", "glpk_indices", "=", "[", "]", "\n", "indptr", "=", "[", "0", "]", "\n", "\n", "for", "row", "in", "range", "(", "lp_rows", ")", ":", "\n", "            ", "got_len", "=", "glpk", ".", "glp_get_mat_row", "(", "self", ".", "lp", ",", "row", "+", "1", ",", "inds_row", ",", "vals_row", ")", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "got_len", "+", "1", ")", ":", "\n", "                ", "data", ".", "append", "(", "vals_row", "[", "i", "]", ")", "\n", "glpk_indices", ".", "append", "(", "inds_row", "[", "i", "]", ")", "\n", "\n", "", "indptr", ".", "append", "(", "len", "(", "data", ")", ")", "\n", "\n", "# rhs", "\n", "", "rhs", "=", "[", "]", "\n", "\n", "for", "row", "in", "range", "(", "lp_rows", ")", ":", "\n", "            ", "assert", "glpk", ".", "glp_get_row_type", "(", "self", ".", "lp", ",", "row", "+", "1", ")", "==", "glpk", ".", "GLP_UP", "\n", "\n", "rhs", ".", "append", "(", "glpk", ".", "glp_get_row_ub", "(", "self", ".", "lp", ",", "row", "+", "1", ")", ")", "\n", "\n", "", "col_bounds", "=", "self", ".", "get_col_bounds", "(", ")", "\n", "\n", "return", "self", ".", "names", ",", "data", ",", "glpk_indices", ",", "indptr", ",", "rhs", ",", "col_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.__setstate__": [[155, 188], ["swiglpk.glp_create_prob", "len", "enumerate", "len", "lpinstance.LpInstance.add_rows_less_equal", "lpinstance.LpInstance.set_constraints_csr", "lpinstance.LpInstance.add_double_bounded_cols", "lpinstance.LpInstance.add_cols", "lpinstance.LpInstance.add_positive_cols"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_rows_less_equal", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.set_constraints_csr", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_double_bounded_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_positive_cols"], ["", "def", "__setstate__", "(", "self", ",", "tup", ")", ":", "\n", "        ", "'spectial de-pickling logic due to swiglpk'", "\n", "\n", "names", ",", "data", ",", "glpk_indices", ",", "indptr", ",", "rhs", ",", "col_bounds", "=", "tup", "\n", "\n", "self", ".", "lp", "=", "glpk", ".", "glp_create_prob", "(", ")", "\n", "\n", "# add cols", "\n", "self", ".", "names", "=", "[", "]", "# adding columns populates self.names", "\n", "\n", "num_cols", "=", "len", "(", "col_bounds", ")", "\n", "\n", "for", "i", ",", "(", "lb", ",", "ub", ")", "in", "enumerate", "(", "col_bounds", ")", ":", "\n", "            ", "name", "=", "names", "[", "i", "]", "\n", "\n", "if", "ub", "==", "np", ".", "inf", ":", "\n", "                ", "if", "lb", "==", "-", "np", ".", "inf", ":", "\n", "# free variable", "\n", "                    ", "self", ".", "add_cols", "(", "[", "name", "]", ")", "\n", "", "else", ":", "\n", "                    ", "assert", "lb", "==", "0", "\n", "\n", "self", ".", "add_positive_cols", "(", "[", "name", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "add_double_bounded_cols", "(", "[", "name", "]", ",", "lb", ",", "ub", ")", "\n", "\n", "# add rows", "\n", "", "", "num_rows", "=", "len", "(", "rhs", ")", "\n", "self", ".", "add_rows_less_equal", "(", "rhs", ")", "\n", "\n", "# set constraints", "\n", "shape", "=", "(", "num_rows", ",", "num_cols", ")", "\n", "self", ".", "set_constraints_csr", "(", "data", ",", "glpk_indices", ",", "indptr", ",", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._column_names_str": [[189, 211], ["enumerate", "swiglpk.glp_get_col_lb", "swiglpk.glp_get_col_ub", "name.rjust"], "methods", ["None"], ["", "def", "_column_names_str", "(", "self", ")", ":", "\n", "        ", "'get the line in __str__ for the column names'", "\n", "\n", "rv", "=", "\"    \"", "\n", "dbl_max", "=", "sys", ".", "float_info", ".", "max", "\n", "\n", "for", "col", ",", "name", "in", "enumerate", "(", "self", ".", "names", ")", ":", "\n", "            ", "name", "=", "self", ".", "names", "[", "col", "]", "\n", "\n", "lb", "=", "glpk", ".", "glp_get_col_lb", "(", "self", ".", "lp", ",", "col", "+", "1", ")", "\n", "ub", "=", "glpk", ".", "glp_get_col_ub", "(", "self", ".", "lp", ",", "col", "+", "1", ")", "\n", "\n", "if", "lb", "!=", "-", "dbl_max", "or", "ub", "!=", "dbl_max", ":", "\n", "                ", "name", "=", "\"*\"", "+", "name", "\n", "\n", "", "name", "=", "name", ".", "rjust", "(", "6", ")", "[", ":", "6", "]", "# fix width to exactly 6", "\n", "\n", "rv", "+=", "name", "+", "\" \"", "\n", "\n", "", "rv", "+=", "\"\\n\"", "\n", "\n", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._opt_dir_str": [[212, 233], ["lpinstance.LpInstance.get_num_cols", "range", "swiglpk.glp_get_obj_coef", "num.rjust", "lpinstance.LpInstance.__str__.zero_print"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols"], ["", "def", "_opt_dir_str", "(", "self", ",", "zero_print", ")", ":", "\n", "        ", "'get the optimization direction line for __str__'", "\n", "\n", "lp", "=", "self", ".", "lp", "\n", "cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "rv", "=", "\"min \"", "\n", "\n", "for", "col", "in", "range", "(", "1", ",", "cols", "+", "1", ")", ":", "\n", "            ", "val", "=", "glpk", ".", "glp_get_obj_coef", "(", "lp", ",", "col", ")", "\n", "\n", "num", "=", "f\"{val:.6f}\"", "\n", "num", "=", "num", ".", "rjust", "(", "6", ")", "[", ":", "6", "]", "# fix width to exactly 6", "\n", "\n", "if", "val", "==", "0", ":", "\n", "                ", "rv", "+=", "zero_print", "(", "num", ")", "+", "\" \"", "\n", "", "else", ":", "\n", "                ", "rv", "+=", "num", "+", "\" \"", "\n", "\n", "", "", "rv", "+=", "\"\\n\"", "\n", "\n", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._col_stat_str": [[234, 249], ["lpinstance.LpInstance.get_num_cols", "range", "swiglpk.glp_get_col_stat"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols"], ["", "def", "_col_stat_str", "(", "self", ")", ":", "\n", "        ", "'get the column statuses line for __str__'", "\n", "\n", "lp", "=", "self", ".", "lp", "\n", "cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "stat_labels", "=", "[", "\"?(0)?\"", ",", "\"BS\"", ",", "\"NL\"", ",", "\"NU\"", ",", "\"NF\"", ",", "\"NS\"", ",", "\"?(6)?\"", "]", "\n", "rv", "=", "\"   \"", "\n", "\n", "for", "col", "in", "range", "(", "1", ",", "cols", "+", "1", ")", ":", "\n", "            ", "rv", "+=", "\"{:>6} \"", ".", "format", "(", "stat_labels", "[", "glpk", ".", "glp_get_col_stat", "(", "lp", ",", "col", ")", "]", ")", "\n", "\n", "", "rv", "+=", "\"\\n\"", "\n", "\n", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._constraints_str": [[250, 296], ["lpinstance.LpInstance.get_num_rows", "lpinstance.LpInstance.get_num_cols", "lpinstance.SwigArray.get_int_array", "lpinstance.SwigArray.get_double_array", "range", "swiglpk.glp_get_row_stat", "swiglpk.glp_get_mat_row", "range", "swiglpk.glp_get_row_type", "swiglpk.glp_get_row_ub", "len", "range", "num.rjust", "num.rjust", "lpinstance.LpInstance.__str__.zero_print", "lpinstance.LpInstance.__str__.zero_print"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_int_array", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_double_array"], ["", "def", "_constraints_str", "(", "self", ",", "zero_print", ")", ":", "\n", "        ", "'get the constraints matrix lines for __str__'", "\n", "\n", "rv", "=", "\"\"", "\n", "lp", "=", "self", ".", "lp", "\n", "rows", "=", "self", ".", "get_num_rows", "(", ")", "\n", "cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "stat_labels", "=", "[", "\"?(0)?\"", ",", "\"BS\"", ",", "\"NL\"", ",", "\"NU\"", ",", "\"NF\"", ",", "\"NS\"", "]", "\n", "inds", "=", "SwigArray", ".", "get_int_array", "(", "cols", "+", "1", ")", "\n", "vals", "=", "SwigArray", ".", "get_double_array", "(", "cols", "+", "1", ")", "\n", "\n", "for", "row", "in", "range", "(", "1", ",", "rows", "+", "1", ")", ":", "\n", "            ", "stat", "=", "glpk", ".", "glp_get_row_stat", "(", "lp", ",", "row", ")", "\n", "assert", "0", "<=", "stat", "<=", "len", "(", "stat_labels", ")", "\n", "rv", "+=", "\"{:2}: {} \"", ".", "format", "(", "row", ",", "stat_labels", "[", "stat", "]", ")", "\n", "\n", "num_inds", "=", "glpk", ".", "glp_get_mat_row", "(", "lp", ",", "row", ",", "inds", ",", "vals", ")", "\n", "\n", "for", "col", "in", "range", "(", "1", ",", "cols", "+", "1", ")", ":", "\n", "                ", "val", "=", "0", "\n", "\n", "for", "index", "in", "range", "(", "1", ",", "num_inds", "+", "1", ")", ":", "\n", "                    ", "if", "inds", "[", "index", "]", "==", "col", ":", "\n", "                        ", "val", "=", "vals", "[", "index", "]", "\n", "break", "\n", "\n", "", "", "num", "=", "f\"{val:.6f}\"", "\n", "num", "=", "num", ".", "rjust", "(", "6", ")", "[", ":", "6", "]", "# fix width to exactly 6", "\n", "\n", "rv", "+=", "(", "zero_print", "(", "num", ")", "if", "val", "==", "0", "else", "num", ")", "+", "\" \"", "\n", "\n", "", "row_type", "=", "glpk", ".", "glp_get_row_type", "(", "lp", ",", "row", ")", "\n", "\n", "assert", "row_type", "==", "glpk", ".", "GLP_UP", "\n", "val", "=", "glpk", ".", "glp_get_row_ub", "(", "lp", ",", "row", ")", "\n", "rv", "+=", "\" <= \"", "\n", "\n", "num", "=", "f\"{val:.6f}\"", "\n", "num", "=", "num", ".", "rjust", "(", "6", ")", "[", ":", "6", "]", "# fix width to exactly 6", "\n", "\n", "rv", "+=", "(", "zero_print", "(", "num", ")", "if", "val", "==", "0", "else", "num", ")", "+", "\" \"", "\n", "\n", "rv", "+=", "\"\\n\"", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._var_bounds_str": [[297, 320], ["enumerate", "swiglpk.glp_get_col_lb", "swiglpk.glp_get_col_ub"], "methods", ["None"], ["", "def", "_var_bounds_str", "(", "self", ")", ":", "\n", "        ", "'get the variable bounds string used in __str__'", "\n", "\n", "rv", "=", "\"\"", "\n", "\n", "dbl_max", "=", "sys", ".", "float_info", ".", "max", "\n", "added_label", "=", "False", "\n", "\n", "for", "index", ",", "name", "in", "enumerate", "(", "self", ".", "names", ")", ":", "\n", "            ", "lb", "=", "glpk", ".", "glp_get_col_lb", "(", "self", ".", "lp", ",", "index", "+", "1", ")", "\n", "ub", "=", "glpk", ".", "glp_get_col_ub", "(", "self", ".", "lp", ",", "index", "+", "1", ")", "\n", "\n", "if", "not", "added_label", "and", "(", "lb", "!=", "-", "dbl_max", "or", "ub", "!=", "dbl_max", ")", ":", "\n", "                ", "added_label", "=", "True", "\n", "rv", "+=", "\"(*) Bounded variables:\"", "\n", "\n", "", "if", "lb", "!=", "-", "dbl_max", "or", "ub", "!=", "dbl_max", ":", "\n", "                ", "lb", "=", "\"-inf\"", "if", "lb", "==", "-", "dbl_max", "else", "lb", "\n", "ub", "=", "\"inf\"", "if", "ub", "==", "dbl_max", "else", "ub", "\n", "\n", "rv", "+=", "f\"\\n{name} in [{lb}, {ub}]\"", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.__str__": [[321, 349], ["lpinstance.LpInstance.get_num_rows", "lpinstance.LpInstance.get_num_cols", "lpinstance.LpInstance._column_names_str", "lpinstance.LpInstance._opt_dir_str", "lpinstance.LpInstance._col_stat_str", "lpinstance.LpInstance._constraints_str", "lpinstance.LpInstance._var_bounds_str", "termcolor.colored"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._column_names_str", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._opt_dir_str", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._col_stat_str", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._constraints_str", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._var_bounds_str"], ["", "def", "__str__", "(", "self", ",", "plain_text", "=", "False", ")", ":", "\n", "        ", "'get the LP as string (useful for debugging)'", "\n", "\n", "if", "plain_text", ":", "\n", "            ", "zero_print", "=", "lambda", "x", ":", "x", "\n", "", "else", ":", "\n", "            ", "def", "zero_print", "(", "s", ")", ":", "\n", "                ", "'print function for zeros'", "\n", "\n", "return", "colored", "(", "s", ",", "'white'", ",", "attrs", "=", "[", "'dark'", "]", ")", "\n", "\n", "", "", "rows", "=", "self", ".", "get_num_rows", "(", ")", "\n", "cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "rv", "=", "\"Lp has {} columns (variables) and {} rows (constraints)\\n\"", ".", "format", "(", "cols", ",", "rows", ")", "\n", "\n", "rv", "+=", "self", ".", "_column_names_str", "(", ")", "\n", "\n", "rv", "+=", "self", ".", "_opt_dir_str", "(", "zero_print", ")", "\n", "\n", "rv", "+=", "\"subject to:\\n\"", "\n", "\n", "rv", "+=", "self", ".", "_col_stat_str", "(", ")", "\n", "\n", "rv", "+=", "self", ".", "_constraints_str", "(", "zero_print", ")", "\n", "\n", "rv", "+=", "self", ".", "_var_bounds_str", "(", ")", "\n", "\n", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows": [[350, 354], ["swiglpk.glp_get_num_rows"], "methods", ["None"], ["", "def", "get_num_rows", "(", "self", ")", ":", "\n", "        ", "'get the number of rows in the lp'", "\n", "\n", "return", "glpk", ".", "glp_get_num_rows", "(", "self", ".", "lp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols": [[355, 363], ["swiglpk.glp_get_num_cols", "len", "len"], "methods", ["None"], ["", "def", "get_num_cols", "(", "self", ")", ":", "\n", "        ", "'get the number of columns in the lp'", "\n", "\n", "cols", "=", "glpk", ".", "glp_get_num_cols", "(", "self", ".", "lp", ")", "\n", "\n", "assert", "cols", "==", "len", "(", "self", ".", "names", ")", ",", "f\"lp had {cols} columns, but names list had {len(self.names)} names\"", "\n", "\n", "return", "cols", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_rows_less_equal": [[364, 383], ["isinstance", "numpy.array", "isinstance", "swiglpk.glp_get_num_rows", "swiglpk.glp_add_rows", "enumerate", "len", "len", "swiglpk.glp_set_row_bnds"], "methods", ["None"], ["", "def", "add_rows_less_equal", "(", "self", ",", "rhs_vec", ")", ":", "\n", "        ", "'''add rows to the LP with <= constraints\n\n        rhs_vector is the right-hand-side values of the constriants\n        '''", "\n", "\n", "if", "isinstance", "(", "rhs_vec", ",", "list", ")", ":", "\n", "            ", "rhs_vec", "=", "np", ".", "array", "(", "rhs_vec", ",", "dtype", "=", "float", ")", "\n", "\n", "", "assert", "isinstance", "(", "rhs_vec", ",", "np", ".", "ndarray", ")", "and", "len", "(", "rhs_vec", ".", "shape", ")", "==", "1", ",", "\"expected 1-d right-hand-side vector\"", "\n", "\n", "if", "rhs_vec", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "            ", "num_rows", "=", "glpk", ".", "glp_get_num_rows", "(", "self", ".", "lp", ")", "\n", "\n", "# create new row for each constraint", "\n", "glpk", ".", "glp_add_rows", "(", "self", ".", "lp", ",", "len", "(", "rhs_vec", ")", ")", "\n", "\n", "for", "i", ",", "rhs", "in", "enumerate", "(", "rhs_vec", ")", ":", "\n", "                ", "glpk", ".", "glp_set_row_bnds", "(", "self", ".", "lp", ",", "num_rows", "+", "i", "+", "1", ",", "glpk", ".", "GLP_UP", ",", "0", ",", "rhs", ")", "# '<=' constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_types": [[384, 394], ["swiglpk.glp_get_num_rows", "range", "rv.append", "swiglpk.glp_get_row_type"], "methods", ["None"], ["", "", "", "def", "get_types", "(", "self", ")", ":", "\n", "        ", "'''get the constraint types. These are swiglpk.GLP_FX, swiglpk.GLP_UP, or swiglpk.GLP_LO'''", "\n", "\n", "lp_rows", "=", "glpk", ".", "glp_get_num_rows", "(", "self", ".", "lp", ")", "\n", "rv", "=", "[", "]", "\n", "\n", "for", "row", "in", "range", "(", "lp_rows", ")", ":", "\n", "            ", "rv", ".", "append", "(", "glpk", ".", "glp_get_row_type", "(", "self", ".", "lp", ",", "row", "+", "1", ")", ")", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_positive_cols": [[395, 409], ["isinstance", "len", "lpinstance.LpInstance.get_num_cols", "swiglpk.glp_add_cols", "range", "swiglpk.glp_set_col_bnds"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols"], ["", "def", "add_positive_cols", "(", "self", ",", "names", ")", ":", "\n", "        ", "'add a certain number of columns to the LP with positive bounds'", "\n", "\n", "assert", "isinstance", "(", "names", ",", "list", ")", "\n", "num_vars", "=", "len", "(", "names", ")", "\n", "\n", "if", "num_vars", ">", "0", ":", "\n", "            ", "num_cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "self", ".", "names", "+=", "names", "\n", "glpk", ".", "glp_add_cols", "(", "self", ".", "lp", ",", "num_vars", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_vars", ")", ":", "\n", "                ", "glpk", ".", "glp_set_col_bnds", "(", "self", ".", "lp", ",", "num_cols", "+", "i", "+", "1", ",", "glpk", ".", "GLP_LO", ",", "0", ",", "0", ")", "# var with lower bounds (0, inf)", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_cols": [[410, 424], ["isinstance", "len", "lpinstance.LpInstance.get_num_cols", "swiglpk.glp_add_cols", "range", "swiglpk.glp_set_col_bnds"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols"], ["", "", "", "def", "add_cols", "(", "self", ",", "names", ")", ":", "\n", "        ", "'add a certain number of columns to the LP'", "\n", "\n", "assert", "isinstance", "(", "names", ",", "list", ")", "\n", "num_vars", "=", "len", "(", "names", ")", "\n", "\n", "if", "num_vars", ">", "0", ":", "\n", "            ", "num_cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "self", ".", "names", "+=", "names", "\n", "glpk", ".", "glp_add_cols", "(", "self", ".", "lp", ",", "num_vars", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_vars", ")", ":", "\n", "                ", "glpk", ".", "glp_set_col_bnds", "(", "self", ".", "lp", ",", "num_cols", "+", "i", "+", "1", ",", "glpk", ".", "GLP_FR", ",", "0", ",", "0", ")", "# free variable (-inf, inf)", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_double_bounded_cols": [[425, 451], ["float", "float", "isinstance", "len", "lpinstance.LpInstance.get_num_cols", "swiglpk.glp_add_cols", "range", "swiglpk.glp_set_col_bnds", "swiglpk.glp_set_col_bnds", "swiglpk.glp_set_col_bnds"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols"], ["", "", "", "def", "add_double_bounded_cols", "(", "self", ",", "names", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "'add a certain number of columns to the LP with the given lower and upper bound'", "\n", "\n", "assert", "lb", "!=", "-", "np", ".", "inf", "\n", "\n", "lb", "=", "float", "(", "lb", ")", "\n", "ub", "=", "float", "(", "ub", ")", "\n", "assert", "lb", "<=", "ub", ",", "f\"lb ({lb}) <= ub ({ub}). dif: {ub - lb}\"", "\n", "\n", "assert", "isinstance", "(", "names", ",", "list", ")", "\n", "num_vars", "=", "len", "(", "names", ")", "\n", "\n", "if", "num_vars", ">", "0", ":", "\n", "            ", "num_cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "self", ".", "names", "+=", "names", "\n", "glpk", ".", "glp_add_cols", "(", "self", ".", "lp", ",", "num_vars", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_vars", ")", ":", "\n", "                ", "if", "lb", "==", "ub", ":", "\n", "                    ", "glpk", ".", "glp_set_col_bnds", "(", "self", ".", "lp", ",", "num_cols", "+", "i", "+", "1", ",", "glpk", ".", "GLP_FX", ",", "lb", ",", "ub", ")", "# fixed variable", "\n", "", "elif", "ub", "==", "np", ".", "inf", ":", "\n", "                    ", "glpk", ".", "glp_set_col_bnds", "(", "self", ".", "lp", ",", "num_cols", "+", "i", "+", "1", ",", "glpk", ".", "GLP_LO", ",", "lb", ",", "ub", ")", "# lower-bounded variable", "\n", "", "else", ":", "\n", "                    ", "assert", "lb", "<", "ub", "\n", "glpk", ".", "glp_set_col_bnds", "(", "self", ".", "lp", ",", "num_cols", "+", "i", "+", "1", ",", "glpk", ".", "GLP_DB", ",", "lb", ",", "ub", ")", "# double-bounded variable", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_dense_row": [[452, 480], ["isinstance", "lpinstance.LpInstance.get_num_rows", "lpinstance.LpInstance.add_rows_less_equal", "lpinstance.SwigArray.as_double_array", "lpinstance.SwigArray.get_sequential_int_array", "swiglpk.glp_set_mat_row", "len", "lpinstance.LpInstance.get_num_cols", "timerutil.Timers.tic", "numpy.linalg.norm", "timerutil.Timers.toc", "len", "len", "lpinstance.LpInstance.get_num_cols"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_rows_less_equal", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.as_double_array", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_sequential_int_array", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.tic", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols"], ["", "", "", "", "@", "timed", "\n", "def", "add_dense_row", "(", "self", ",", "vec", ",", "rhs", ",", "normalize", "=", "False", ")", ":", "\n", "        ", "'''\n        add a row from a dense nd.array, row <= rhs\n        '''", "\n", "\n", "assert", "isinstance", "(", "vec", ",", "np", ".", "ndarray", ")", "\n", "assert", "len", "(", "vec", ".", "shape", ")", "==", "1", "or", "vec", ".", "shape", "[", "0", "]", "==", "1", "\n", "assert", "len", "(", "vec", ")", "==", "self", ".", "get_num_cols", "(", ")", ",", "f\"vec had {len(vec)} values, but lpi has {self.get_num_cols()} cols\"", "\n", "\n", "if", "normalize", ":", "\n", "            ", "Timers", ".", "tic", "(", "'normalize'", ")", "\n", "norm", "=", "np", ".", "linalg", ".", "norm", "(", "vec", ")", "\n", "\n", "if", "norm", ">", "1e-9", ":", "\n", "                ", "vec", "=", "vec", "/", "norm", "\n", "rhs", "=", "rhs", "/", "norm", "\n", "\n", "", "Timers", ".", "toc", "(", "'normalize'", ")", "\n", "\n", "", "rows_before", "=", "self", ".", "get_num_rows", "(", ")", "\n", "\n", "self", ".", "add_rows_less_equal", "(", "[", "rhs", "]", ")", "\n", "\n", "data_vec", "=", "SwigArray", ".", "as_double_array", "(", "vec", ",", "vec", ".", "size", ")", "\n", "indices_vec", "=", "SwigArray", ".", "get_sequential_int_array", "(", "vec", ".", "size", ")", "\n", "\n", "glpk", ".", "glp_set_mat_row", "(", "self", ".", "lp", ",", "rows_before", "+", "1", ",", "vec", ".", "size", ",", "indices_vec", ",", "data_vec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.set_constraints_csr": [[481, 509], ["isinstance", "range", "lpinstance.LpInstance.get_num_rows", "lpinstance.LpInstance.get_num_cols", "isinstance", "int", "lpinstance.SwigArray.as_int_array", "lpinstance.SwigArray.as_double_array", "swiglpk.glp_set_mat_row", "type"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.as_int_array", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.as_double_array"], ["", "def", "set_constraints_csr", "(", "self", ",", "data", ",", "glpk_indices", ",", "indptr", ",", "shape", ")", ":", "\n", "        ", "'''\n        set the constrains row by row to be equal to the passed-in csr matrix attribues\n\n        glpk_indices is already offset by one\n        '''", "\n", "\n", "assert", "shape", "[", "0", "]", "<=", "self", ".", "get_num_rows", "(", ")", "\n", "assert", "shape", "[", "1", "]", "<=", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "if", "glpk_indices", ":", "\n", "            ", "assert", "isinstance", "(", "glpk_indices", "[", "0", "]", ",", "int", ")", ",", "f\"indices type was not int: {type(glpk_indices[0])}\"", "\n", "\n", "# actually set the constraints row by row", "\n", "", "assert", "isinstance", "(", "data", ",", "list", ")", ",", "\"data was not a list\"", "\n", "\n", "for", "row", "in", "range", "(", "shape", "[", "0", "]", ")", ":", "\n", "# we must copy the indices since glpk is offset by 1 :(", "\n", "            ", "count", "=", "int", "(", "indptr", "[", "row", "+", "1", "]", "-", "indptr", "[", "row", "]", ")", "\n", "\n", "indices_list", "=", "glpk_indices", "[", "indptr", "[", "row", "]", ":", "indptr", "[", "row", "+", "1", "]", "]", "\n", "indices_vec", "=", "SwigArray", ".", "as_int_array", "(", "indices_list", ",", "count", ")", "\n", "\n", "#data_row_list = [float(d) for d in data[indptr[row]:indptr[row+1]]]", "\n", "#data_vec = SwigArray.as_double_array(data_row_list)", "\n", "data_vec", "=", "SwigArray", ".", "as_double_array", "(", "data", "[", "indptr", "[", "row", "]", ":", "indptr", "[", "row", "+", "1", "]", "]", ",", "count", ")", "\n", "\n", "glpk", ".", "glp_set_mat_row", "(", "self", ".", "lp", ",", "1", "+", "row", ",", "count", ",", "indices_vec", ",", "data_vec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_rhs": [[510, 531], ["numpy.array", "swiglpk.glp_get_num_rows", "range", "swiglpk.glp_get_row_type", "swiglpk.glp_get_row_ub", "rv.append"], "methods", ["None"], ["", "", "def", "get_rhs", "(", "self", ",", "row_indices", "=", "None", ")", ":", "\n", "        ", "'''get the rhs vector of the constraints\n        row_indices - a list of requested indices (None=all)\n        this returns an np.array of rhs values for the requested indices\n        '''", "\n", "\n", "rv", "=", "[", "]", "\n", "\n", "if", "row_indices", "is", "None", ":", "\n", "            ", "lp_rows", "=", "glpk", ".", "glp_get_num_rows", "(", "self", ".", "lp", ")", "\n", "row_indices", "=", "range", "(", "lp_rows", ")", "\n", "\n", "", "for", "row", "in", "row_indices", ":", "\n", "            ", "row_type", "=", "glpk", ".", "glp_get_row_type", "(", "self", ".", "lp", ",", "row", "+", "1", ")", "\n", "\n", "assert", "row_type", "==", "glpk", ".", "GLP_UP", ",", "\"Error: Unsupported type ({}) in getRhs() in row {}\"", ".", "format", "(", "row_type", ",", "row", ")", "\n", "\n", "limit", "=", "glpk", ".", "glp_get_row_ub", "(", "self", ".", "lp", ",", "row", "+", "1", ")", "\n", "rv", ".", "append", "(", "limit", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "rv", ",", "dtype", "=", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.set_rhs": [[532, 539], ["enumerate", "lpinstance.LpInstance.get_num_rows", "swiglpk.glp_set_row_bnds"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows"], ["", "def", "set_rhs", "(", "self", ",", "rhs_vec", ")", ":", "\n", "        ", "'set (overwrite) the rhs for exising rows'", "\n", "\n", "assert", "rhs_vec", ".", "size", "==", "self", ".", "get_num_rows", "(", ")", "\n", "\n", "for", "i", ",", "rhs", "in", "enumerate", "(", "rhs_vec", ")", ":", "\n", "            ", "glpk", ".", "glp_set_row_bnds", "(", "self", ".", "lp", ",", "i", "+", "1", ",", "glpk", ".", "GLP_UP", ",", "0", ",", "rhs", ")", "# '<=' constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_constraints_csr": [[540, 571], ["lpinstance.LpInstance.get_num_rows", "lpinstance.LpInstance.get_num_cols", "swiglpk.glp_get_num_nz", "numpy.zeros", "numpy.zeros", "numpy.zeros", "lpinstance.SwigArray.get_int_array", "lpinstance.SwigArray.get_double_array", "range", "scipy.sparse.csr_matrix", "scipy.sparse.csr_matrix.check_format", "swiglpk.glp_get_mat_row", "range"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_int_array", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_double_array"], ["", "", "def", "get_constraints_csr", "(", "self", ")", ":", "\n", "        ", "'''get the LP matrix as a csr_matrix\n        '''", "\n", "\n", "lp_rows", "=", "self", ".", "get_num_rows", "(", ")", "\n", "lp_cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "nnz", "=", "glpk", ".", "glp_get_num_nz", "(", "self", ".", "lp", ")", "\n", "\n", "data", "=", "np", ".", "zeros", "(", "(", "nnz", ",", ")", ",", "dtype", "=", "float", ")", "\n", "inds", "=", "np", ".", "zeros", "(", "(", "nnz", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "indptr", "=", "np", ".", "zeros", "(", "(", "lp_rows", "+", "1", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "inds_row", "=", "SwigArray", ".", "get_int_array", "(", "lp_cols", "+", "1", ")", "\n", "vals_row", "=", "SwigArray", ".", "get_double_array", "(", "lp_cols", "+", "1", ")", "\n", "data_index", "=", "0", "\n", "indptr", "[", "0", "]", "=", "0", "\n", "\n", "for", "row", "in", "range", "(", "1", ",", "lp_rows", "+", "1", ")", ":", "\n", "            ", "got_len", "=", "glpk", ".", "glp_get_mat_row", "(", "self", ".", "lp", ",", "row", ",", "inds_row", ",", "vals_row", ")", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "got_len", "+", "1", ")", ":", "\n", "                ", "data", "[", "data_index", "]", "=", "vals_row", "[", "i", "]", "\n", "inds", "[", "data_index", "]", "=", "inds_row", "[", "i", "]", "-", "1", "\n", "data_index", "+=", "1", "\n", "\n", "", "indptr", "[", "row", "]", "=", "data_index", "\n", "\n", "", "csr_mat", "=", "csr_matrix", "(", "(", "data", ",", "inds", ",", "indptr", ")", ",", "shape", "=", "(", "lp_rows", ",", "lp_cols", ")", ",", "dtype", "=", "float", ")", "\n", "csr_mat", ".", "check_format", "(", ")", "\n", "\n", "return", "csr_mat", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.is_feasible": [[572, 579], ["lpinstance.LpInstance.minimize"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.minimize"], ["", "def", "is_feasible", "(", "self", ")", ":", "\n", "        ", "'''check if the lp is feasible\n\n        returns a feasible point or None\n        '''", "\n", "\n", "return", "self", ".", "minimize", "(", "None", ",", "fail_on_unsat", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.contains_point": [[580, 603], ["print", "lpinstance.LpInstance.get_constraints_csr", "lpinstance.LpInstance.get_rhs", "lpinstance.LpInstance.dot", "zip"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_constraints_csr", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_rhs"], ["", "def", "contains_point", "(", "self", ",", "pt", ",", "tol", "=", "1e-9", ")", ":", "\n", "        ", "'''does this lpi contain the point?\n        this is slow, will pull the constraints and check them\n        '''", "\n", "\n", "print", "(", "\"Warning: called lpi.contains_point() (slow, used for testing)\"", ")", "\n", "\n", "csr", "=", "self", ".", "get_constraints_csr", "(", ")", "\n", "rhs", "=", "self", ".", "get_rhs", "(", ")", "\n", "\n", "# all rows are upper bounds", "\n", "\n", "vec", "=", "csr", ".", "dot", "(", "pt", ")", "\n", "\n", "assert", "vec", ".", "size", "==", "rhs", ".", "size", "\n", "rv", "=", "True", "\n", "\n", "for", "mine", ",", "bound", "in", "zip", "(", "vec", ",", "rhs", ")", ":", "\n", "            ", "if", "mine", "-", "1e-9", ">", "bound", ":", "\n", "                ", "rv", "=", "False", "\n", "break", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.set_minimize_direction": [[604, 614], ["enumerate", "len", "lpinstance.LpInstance.get_num_cols", "int", "swiglpk.glp_set_obj_coef", "float", "lpinstance.LpInstance.get_num_cols", "len"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols"], ["", "def", "set_minimize_direction", "(", "self", ",", "direction", ")", ":", "\n", "        ", "'''set the optimization direction'''", "\n", "\n", "assert", "len", "(", "direction", ")", "==", "self", ".", "get_num_cols", "(", ")", ",", "f\"expected {self.get_num_cols()} cols, but optimization \"", "+", "f\"vector had {len(direction)} variables\"", "\n", "\n", "for", "i", ",", "d", "in", "enumerate", "(", "direction", ")", ":", "\n", "            ", "col", "=", "int", "(", "1", "+", "i", ")", "\n", "\n", "glpk", ".", "glp_set_obj_coef", "(", "self", ".", "lp", ",", "col", ",", "float", "(", "d", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.reset_basis": [[615, 625], ["swiglpk.glp_std_basis", "swiglpk.glp_adv_basis", "swiglpk.glp_cpx_basis"], "methods", ["None"], ["", "", "def", "reset_basis", "(", "self", ",", "basis_type", "=", "'std'", ")", ":", "\n", "        ", "'reset initial lp basis'", "\n", "\n", "if", "basis_type", "==", "'std'", ":", "\n", "            ", "glpk", ".", "glp_std_basis", "(", "self", ".", "lp", ")", "\n", "", "elif", "basis_type", "==", "'adv'", ":", "\n", "            ", "glpk", ".", "glp_adv_basis", "(", "self", ".", "lp", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "assert", "basis_type", "==", "'cpx'", "\n", "glpk", ".", "glp_cpx_basis", "(", "self", ".", "lp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.minimize": [[626, 703], ["lpinstance.LpInstance.set_minimize_direction", "time.perf_counter", "swiglpk.glp_simplex", "lpinstance.LpInstance._process_simplex_result", "isinstance", "lpinstance.get_lp_params", "lpinstance.LpInstance.get_num_rows", "lpinstance.LpInstance.get_num_cols", "print", "print", "lpinstance.LpInstance.reset_basis", "time.perf_counter", "swiglpk.glp_simplex", "print", "print", "lpinstance.get_lp_params", "lpinstance.LpInstance.reset_basis", "time.perf_counter", "swiglpk.glp_simplex", "print", "print", "lpinstance.LpInstance.reset_basis", "lpinstance.LpInstance.minimize", "lpinstance.UnsatError", "lpinstance.LpInstance.get_num_cols", "time.perf_counter", "lpinstance.get_lp_params", "time.perf_counter", "time.perf_counter", "print", "lpinstance.LpInstance.reset_basis", "lpinstance.LpInstance.minimize", "print", "print", "print", "round", "round", "print", "round", "lpinstance.LpInstance.get_num_rows", "lpinstance.LpInstance.get_num_cols"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.set_minimize_direction", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._process_simplex_result", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.get_lp_params", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.reset_basis", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.get_lp_params", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.reset_basis", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.reset_basis", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.minimize", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.get_lp_params", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.reset_basis", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.minimize", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_rows", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols"], ["", "", "@", "timed", "\n", "def", "minimize", "(", "self", ",", "direction_vec", ",", "fail_on_unsat", "=", "True", ")", ":", "\n", "        ", "'''minimize the lp, returning a list of assigments to each of the variables\n\n        if direction_vec is not None, this will first assign the optimization direction\n\n        returns None if UNSAT, otherwise the optimization result.\n        '''", "\n", "\n", "assert", "not", "isinstance", "(", "self", ".", "lp", ",", "tuple", ")", ",", "\"self.lp was tuple. Did you call lpi.deserialize()?\"", "\n", "\n", "if", "direction_vec", "is", "None", ":", "\n", "            ", "direction_vec", "=", "[", "0", "]", "*", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "", "self", ".", "set_minimize_direction", "(", "direction_vec", ")", "\n", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "simplex_res", "=", "glpk", ".", "glp_simplex", "(", "self", ".", "lp", ",", "get_lp_params", "(", ")", ")", "\n", "\n", "if", "simplex_res", "!=", "0", ":", "# solver failure (possibly timeout)", "\n", "            ", "r", "=", "self", ".", "get_num_rows", "(", ")", "\n", "c", "=", "self", ".", "get_num_cols", "(", ")", "\n", "\n", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "print", "(", "f\"GLPK timed out / failed ({simplex_res}) after {round(diff, 3)} sec with primary \"", "+", "f\"settings with {r} rows and {c} cols\"", ")", "\n", "\n", "print", "(", "\"Retrying with reset\"", ")", "\n", "self", ".", "reset_basis", "(", ")", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "simplex_res", "=", "glpk", ".", "glp_simplex", "(", "self", ".", "lp", ",", "get_lp_params", "(", ")", ")", "\n", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "print", "(", "f\"result with reset  ({simplex_res}) {round(diff, 3)} sec\"", ")", "\n", "\n", "print", "(", "\"Retrying with reset + alternate GLPK settings\"", ")", "\n", "\n", "# retry with alternate params", "\n", "params", "=", "get_lp_params", "(", "alternate_lp_params", "=", "True", ")", "\n", "self", ".", "reset_basis", "(", ")", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "simplex_res", "=", "glpk", ".", "glp_simplex", "(", "self", ".", "lp", ",", "params", ")", "\n", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "print", "(", "f\"result with reset & alternate settings ({simplex_res}) {round(diff, 3)} sec\"", ")", "\n", "\n", "", "rv", "=", "self", ".", "_process_simplex_result", "(", "simplex_res", ")", "\n", "\n", "if", "rv", "is", "None", "and", "fail_on_unsat", ":", "\n", "# extra logic to try harder if fail_on_unsafe is True", "\n", "# glpk can sometimes be cajoled into providing a solution", "\n", "\n", "            ", "print", "(", "\"Note: minimize failed with fail_on_unsat was true, trying to reset basis...\"", ")", "\n", "\n", "self", ".", "reset_basis", "(", ")", "\n", "rv", "=", "self", ".", "minimize", "(", "direction_vec", ",", "fail_on_unsat", "=", "False", ")", "\n", "\n", "if", "rv", "is", "None", ":", "\n", "                ", "print", "(", "\"still unsat after reset basis, trying no-dir optimization\"", ")", "\n", "self", ".", "reset_basis", "(", ")", "\n", "\n", "result_nodir", "=", "self", ".", "minimize", "(", "None", ",", "fail_on_unsat", "=", "False", ")", "\n", "\n", "# lp became infeasible when I picked an optimization direction", "\n", "if", "result_nodir", "is", "not", "None", ":", "\n", "                    ", "print", "(", "\"Using result from no-direction optimization\"", ")", "\n", "rv", "=", "result_nodir", "\n", "", "else", ":", "\n", "                    ", "print", "(", "\"Error: No-dir result was also infeasible!\"", ")", "\n", "\n", "if", "self", ".", "get_num_rows", "(", ")", "<", "50", "and", "self", ".", "get_num_cols", "(", ")", "<", "50", ":", "\n", "                        ", "print", "(", "f\"{self}\"", ")", "\n", "", "", "", "else", ":", "\n", "                ", "print", "(", "\"Using result after reset basis (soltion was now feasible)\"", ")", "\n", "\n", "", "", "if", "rv", "is", "None", "and", "fail_on_unsat", ":", "\n", "            ", "raise", "UnsatError", "(", "\"minimize returned UNSAT and fail_on_unsat was True\"", ")", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_simplex_error_string": [[704, 760], ["zip"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_simplex_error_string", "(", "simplex_res", ")", ":", "\n", "        ", "'''get the error message when simplex() fails'''", "\n", "\n", "codes", "=", "[", "glpk", ".", "GLP_EBADB", ",", "glpk", ".", "GLP_ESING", ",", "glpk", ".", "GLP_ECOND", ",", "glpk", ".", "GLP_EBOUND", ",", "glpk", ".", "GLP_EFAIL", ",", "glpk", ".", "GLP_EOBJLL", ",", "\n", "glpk", ".", "GLP_EOBJUL", ",", "glpk", ".", "GLP_EITLIM", ",", "glpk", ".", "GLP_ETMLIM", ",", "glpk", ".", "GLP_ENOPFS", ",", "glpk", ".", "GLP_ENODFS", "]", "\n", "\n", "msgs", "=", "[", "\"Unable to start the search, because the initial basis specified \"", "+", "\"in the problem object is invalid-the number of basic (auxiliary \"", "+", "\"and structural) variables is not the same as the number of rows \"", "+", "\"in the problem object.\"", ",", "\n", "\n", "\"Unable to start the search, because the basis matrix corresponding \"", "+", "\"to the initial basis is singular within the working \"", "+", "\"precision.\"", ",", "\n", "\n", "\"Unable to start the search, because the basis matrix corresponding \"", "+", "\"to the initial basis is ill-conditioned, i.e. its \"", "+", "\"condition number is too large.\"", ",", "\n", "\n", "\"Unable to start the search, because some double-bounded \"", "+", "\"(auxiliary or structural) variables have incorrect bounds.\"", ",", "\n", "\n", "\"The search was prematurely terminated due to the solver \"", "+", "\"failure.\"", ",", "\n", "\n", "\"The search was prematurely terminated, because the objective \"", "+", "\"function being maximized has reached its lower \"", "+", "\"limit and continues decreasing (the dual simplex only).\"", ",", "\n", "\n", "\"The search was prematurely terminated, because the objective \"", "+", "\"function being minimized has reached its upper \"", "+", "\"limit and continues increasing (the dual simplex only).\"", ",", "\n", "\n", "\"The search was prematurely terminated, because the simplex \"", "+", "\"iteration limit has been exceeded.\"", ",", "\n", "\n", "\"The search was prematurely terminated, because the time \"", "+", "\"limit has been exceeded.\"", ",", "\n", "\n", "\"The LP problem instance has no primal feasible solution \"", "+", "\"(only if the LP presolver is used).\"", ",", "\n", "\n", "\"The LP problem instance has no dual feasible solution \"", "+", "\"(only if the LP presolver is used).\"", ",", "\n", "]", "\n", "\n", "rv", "=", "\"Unknown Error\"", "\n", "\n", "for", "code", ",", "message", "in", "zip", "(", "codes", ",", "msgs", ")", ":", "\n", "            ", "if", "simplex_res", "==", "code", ":", "\n", "                ", "rv", "=", "message", "\n", "break", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance._process_simplex_result": [[761, 810], ["swiglpk.glp_get_status", "RuntimeError", "lpinstance.LpInstance.get_num_cols", "numpy.zeros", "range", "zip", "RuntimeError", "lpinstance.LpInstance.get_simplex_error_string", "swiglpk.glp_get_col_prim", "swiglpk.glp_get_unbnd_ray", "int"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_simplex_error_string"], ["", "def", "_process_simplex_result", "(", "self", ",", "simplex_res", ")", ":", "\n", "        ", "'''process the result of a glp_simplex call\n\n        returns None on UNSAT, otherwise the optimization result with the requested columns\n        if columns is None, will return full result\n        '''", "\n", "\n", "rv", "=", "None", "\n", "\n", "if", "simplex_res", "!=", "glpk", ".", "GLP_ENOPFS", ":", "# skip if no primal feasible w/ presolver", "\n", "\n", "            ", "if", "simplex_res", "!=", "0", ":", "# simplex failed, report the error", "\n", "                ", "raise", "RuntimeError", "(", "\"glp_simplex returned nonzero status ({}): {}\"", ".", "format", "(", "\n", "simplex_res", ",", "LpInstance", ".", "get_simplex_error_string", "(", "simplex_res", ")", ")", ")", "\n", "\n", "", "status", "=", "glpk", ".", "glp_get_status", "(", "self", ".", "lp", ")", "\n", "\n", "if", "status", "==", "glpk", ".", "GLP_NOFEAS", ":", "# infeasible", "\n", "                ", "rv", "=", "None", "\n", "", "elif", "status", "==", "glpk", ".", "GLP_OPT", ":", "# optimal", "\n", "                ", "lp_cols", "=", "self", ".", "get_num_cols", "(", ")", "\n", "rv", "=", "np", ".", "zeros", "(", "lp_cols", ")", "\n", "\n", "for", "col", "in", "range", "(", "lp_cols", ")", ":", "\n", "                    ", "rv", "[", "col", "]", "=", "glpk", ".", "glp_get_col_prim", "(", "self", ".", "lp", ",", "int", "(", "1", "+", "col", ")", ")", "\n", "\n", "", "", "else", ":", "# neither infeasible nor optimal (for example, unbounded)", "\n", "                ", "error_msg", "=", "\"<Unknown Status>\"", "\n", "\n", "codes", "=", "[", "glpk", ".", "GLP_OPT", ",", "glpk", ".", "GLP_FEAS", ",", "glpk", ".", "GLP_INFEAS", ",", "glpk", ".", "GLP_NOFEAS", ",", "glpk", ".", "GLP_UNBND", ",", "glpk", ".", "GLP_UNDEF", "]", "\n", "msgs", "=", "[", "\"solution is optimal\"", ",", "\n", "\"solution is feasible\"", ",", "\n", "\"solution is infeasible\"", ",", "\n", "\"problem has no feasible solution\"", ",", "\n", "\"problem has unbounded solution\"", ",", "\n", "\"solution is undefined\"", "]", "\n", "\n", "for", "code", ",", "message", "in", "zip", "(", "codes", ",", "msgs", ")", ":", "\n", "                    ", "if", "status", "==", "code", ":", "\n", "                        ", "error_msg", "=", "message", "\n", "break", "\n", "\n", "", "", "if", "status", "==", "glpk", ".", "GLP_UNBND", ":", "\n", "                    ", "ray", "=", "glpk", ".", "glp_get_unbnd_ray", "(", "self", ".", "lp", ")", "\n", "error_msg", "+=", "f\"; unbounded ray was variable #{ray}\"", "\n", "\n", "", "raise", "RuntimeError", "(", "f\"LP status after minimize() was {status}: {error_msg}\"", ")", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_double_array": [[830, 841], ["swiglpk.doubleArray", "math.ceil", "math.log"], "methods", ["None"], ["@", "classmethod", "\n", "def", "get_double_array", "(", "cls", ",", "size", ")", ":", "\n", "        ", "'get a double array of the requested size (or greater)'", "\n", "\n", "if", "size", ">", "cls", ".", "dbl_array_size", ":", "\n", "            ", "cls", ".", "dbl_array_size", "=", "2", "**", "math", ".", "ceil", "(", "math", ".", "log", "(", "size", ",", "2", ")", ")", "# allocate in multiples of two", "\n", "cls", ".", "dbl_array", "=", "glpk", ".", "doubleArray", "(", "cls", ".", "dbl_array_size", ")", "\n", "\n", "#print(f\"allocated dbl array of size {cls.dbl_array_size} (requested {size})\")", "\n", "\n", "", "return", "cls", ".", "dbl_array", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_int_array": [[842, 855], ["swiglpk.intArray", "math.ceil", "math.log"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "get_int_array", "(", "cls", ",", "size", ")", ":", "\n", "        ", "'get a int array of the requested size (or greater)'", "\n", "\n", "if", "size", ">", "cls", ".", "int_array_size", ":", "\n", "            ", "cls", ".", "int_array_size", "=", "2", "**", "math", ".", "ceil", "(", "math", ".", "log", "(", "size", ",", "2", ")", ")", "# allocate in multiples of two", "\n", "cls", ".", "int_array", "=", "glpk", ".", "intArray", "(", "cls", ".", "int_array_size", ")", "\n", "\n", "#print(f\".allocated int array of size {cls.int_array_size} (requested {size})\")", "\n", "\n", "#print(f\".returning {cls.int_array} of size {cls.int_array_size} (requested {size})\")", "\n", "\n", "", "return", "cls", ".", "int_array", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.as_double_array": [[856, 867], ["cls.get_double_array", "enumerate", "float"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_double_array"], ["", "@", "classmethod", "\n", "def", "as_double_array", "(", "cls", ",", "list_data", ",", "size", ")", ":", "\n", "        ", "'wrapper for swig as_doubleArray'", "\n", "\n", "# about 3x slower than glpk.as_doubleArray, but doesn't leak memory", "\n", "arr", "=", "cls", ".", "get_double_array", "(", "size", "+", "1", ")", "\n", "\n", "for", "i", ",", "val", "in", "enumerate", "(", "list_data", ")", ":", "\n", "            ", "arr", "[", "i", "+", "1", "]", "=", "float", "(", "val", ")", "\n", "\n", "", "return", "arr", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.as_int_array": [[868, 880], ["cls.get_int_array", "enumerate"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_int_array"], ["", "@", "classmethod", "\n", "def", "as_int_array", "(", "cls", ",", "list_data", ",", "size", ")", ":", "\n", "        ", "'wrapper for swig as_intArray'", "\n", "\n", "# about 3x slower than glpk.as_intArray, but doesn't leak memory", "\n", "arr", "=", "cls", ".", "get_int_array", "(", "size", "+", "1", ")", "\n", "\n", "for", "i", ",", "val", "in", "enumerate", "(", "list_data", ")", ":", "\n", "#print(f\"setting {i+1} <- val: {val} ({type(val)}\")", "\n", "            ", "arr", "[", "i", "+", "1", "]", "=", "val", "\n", "\n", "", "return", "arr", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.SwigArray.get_sequential_int_array": [[881, 895], ["swiglpk.intArray", "range", "math.ceil", "math.log"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "get_sequential_int_array", "(", "cls", ",", "size", ")", ":", "\n", "        ", "'creates or returns a swig int array that counts from 1, 2, 3, 4, .. size'", "\n", "\n", "if", "size", ">", "(", "cls", ".", "seq_array_size", "-", "1", ")", ":", "\n", "            ", "cls", ".", "seq_array_size", "=", "1", "+", "2", "**", "math", ".", "ceil", "(", "math", ".", "log", "(", "size", ",", "2", ")", ")", "# allocate in multiples of two", "\n", "cls", ".", "seq_array", "=", "glpk", ".", "intArray", "(", "cls", ".", "seq_array_size", ")", "\n", "\n", "#print(f\"allocated seq array of size {cls.seq_array_size} (requested {size})\")", "\n", "\n", "for", "i", "in", "range", "(", "cls", ".", "seq_array_size", ")", ":", "\n", "                ", "cls", ".", "seq_array", "[", "i", "]", "=", "i", "\n", "\n", "", "", "return", "cls", ".", "seq_array", "\n", "", "", ""]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.get_lp_params": [[19, 56], ["hasattr", "swiglpk.glp_smcp", "swiglpk.glp_init_smcp", "int", "swiglpk.glp_smcp", "swiglpk.glp_init_smcp", "int"], "function", ["None"], ["def", "get_lp_params", "(", "alternate_lp_params", "=", "False", ")", ":", "\n", "    ", "'get the lp params object'", "\n", "\n", "if", "not", "hasattr", "(", "get_lp_params", ",", "'obj'", ")", ":", "\n", "        ", "params", "=", "glpk", ".", "glp_smcp", "(", ")", "\n", "glpk", ".", "glp_init_smcp", "(", "params", ")", "\n", "\n", "#params.msg_lev = glpk.GLP_MSG_ERR", "\n", "params", ".", "msg_lev", "=", "glpk", ".", "GLP_MSG_ERR", "\n", "params", ".", "meth", "=", "glpk", ".", "GLP_PRIMAL", "\n", "\n", "params", ".", "tm_lim", "=", "int", "(", "30", "*", "1000", ")", "\n", "params", ".", "out_dly", "=", "2", "*", "1000", "# start printing to terminal delay", "\n", "\n", "get_lp_params", ".", "obj", "=", "params", "\n", "\n", "# make alternative params", "\n", "params2", "=", "glpk", ".", "glp_smcp", "(", ")", "\n", "glpk", ".", "glp_init_smcp", "(", "params2", ")", "\n", "params2", ".", "meth", "=", "glpk", ".", "GLP_DUAL", "\n", "params2", ".", "msg_lev", "=", "glpk", ".", "GLP_MSG_ON", "\n", "\n", "params2", ".", "tm_lim", "=", "int", "(", "60", "*", "1000", ")", "\n", "params2", ".", "out_dly", "=", "1", "*", "1000", "# start printing to terminal status after 1 secs", "\n", "\n", "get_lp_params", ".", "alt_obj", "=", "params2", "\n", "\n", "#print(f\"Using GLPK version: {glpk.glp_version()}\")", "\n", "\n", "", "if", "alternate_lp_params", ":", "\n", "#glpk.glp_term_out(glpk.GLP_ON)", "\n", "        ", "rv", "=", "get_lp_params", ".", "alt_obj", "\n", "", "else", ":", "\n", "#glpk.glp_term_out(glpk.GLP_OFF)", "\n", "        ", "rv", "=", "get_lp_params", ".", "obj", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.settings.Settings.init_cmd_quantum_list": [[33, 48], ["round", "round", "round", "round", "round"], "methods", ["None"], ["@", "classmethod", "\n", "def", "init_cmd_quantum_list", "(", "cls", ")", ":", "\n", "        ", "'''init class variables'''", "\n", "\n", "theta1_quantum", "=", "cls", ".", "theta1_q", "\n", "\n", "q", "=", "2", "*", "pi", "/", "(", "360", "/", "1.5", ")", "\n", "assert", "theta1_quantum", "*", "round", "(", "q", "/", "theta1_quantum", ")", "-", "q", "<", "1e-6", "\n", "\n", "# initialize", "\n", "q", "=", "2", "*", "pi", "/", "(", "360", "/", "1.5", ")", "\n", "cls", ".", "cmd_quantum_list", "=", "[", "0", ",", "round", "(", "q", "/", "theta1_quantum", ")", ",", "-", "1", "*", "round", "(", "q", "/", "theta1_quantum", ")", ",", "\n", "2", "*", "round", "(", "q", "/", "theta1_quantum", ")", ",", "-", "2", "*", "round", "(", "q", "/", "theta1_quantum", ")", "]", "\n", "\n", "assert", "Settings", ".", "tau_dot", "in", "[", "0", ",", "-", "1", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.increment_index": [[34, 96], ["time.perf_counter", "shared_next_index.get_lock", "print", "range", "len", "print", "util.get_num_cores", "range", "print", "time.perf_counter", "util.get_num_cores", "len", "print", "util.to_time_str", "round", "util.to_time_str", "util.to_time_str", "len"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_num_cores", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_num_cores", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.to_time_str", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.to_time_str", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.to_time_str"], ["def", "increment_index", "(", ")", "->", "Tuple", "[", "int", ",", "Tuple", "[", "int", ",", "int", ",", "int", ",", "int", ",", "int", ",", "int", "]", "]", ":", "\n", "    ", "\"\"\"get next work index and params (and print update)\"\"\"", "\n", "\n", "next_index", "=", "-", "1", "\n", "now", "=", "time", ".", "perf_counter", "(", ")", "\n", "\n", "with", "shared_next_index", ".", "get_lock", "(", ")", ":", "\n", "        ", "next_index", "=", "shared_next_index", ".", "value", "\n", "shared_next_index", ".", "value", "+=", "1", "\n", "\n", "shared_cur_index", "[", "global_process_id", "]", "=", "next_index", "\n", "shared_cur_index_start_time", "[", "global_process_id", "]", "=", "now", "\n", "\n", "if", "next_index", "==", "0", ":", "# reset all times", "\n", "            ", "for", "i", "in", "range", "(", "get_num_cores", "(", ")", ")", ":", "\n", "                ", "shared_cur_index_start_time", "[", "i", "]", "=", "now", "\n", "shared_cur_index", "[", "i", "]", "=", "0", "\n", "shared_next_print_time", ".", "value", "=", "now", "\n", "\n", "", "", "if", "now", ">=", "shared_next_print_time", ".", "value", ":", "\n", "            ", "print_increment_secs", "=", "5", "\n", "shared_next_print_time", ".", "value", "=", "now", "+", "print_increment_secs", "\n", "\n", "if", "next_index", ">", "0", ":", "\n", "# print longest-running job", "\n", "                ", "longest", ":", "Tuple", "[", "float", ",", "int", "]", "=", "(", "now", "-", "shared_cur_index_start_time", "[", "0", "]", ",", "0", ")", "\n", "\n", "for", "i", "in", "range", "(", "get_num_cores", "(", ")", ")", ":", "\n", "                    ", "index", "=", "shared_cur_index", "[", "i", "]", "\n", "runtime", "=", "now", "-", "shared_cur_index_start_time", "[", "i", "]", "\n", "cur", ":", "Tuple", "[", "float", ",", "int", "]", "=", "(", "runtime", ",", "index", ")", "\n", "\n", "if", "cur", ">", "longest", ":", "\n", "                        ", "longest", "=", "cur", "\n", "\n", "", "", "runtime", ",", "index", "=", "longest", "\n", "\n", "if", "len", "(", "shared_counterexamples_list", ")", ">", "0", ":", "\n", "                    ", "print", "(", "f\"\\nTimeouts: {shared_num_timeouts.value}, Counterexamples \"", "+", "f\"({len(shared_counterexamples_list)}): {shared_counterexamples_list}\"", ",", "\n", "end", "=", "''", ")", "\n", "\n", "", "print", "(", "f\"\\nLongest Running Job: index={index} ({to_time_str(runtime)})\"", ")", "\n", "\n", "# print progress", "\n", "", "num_cases", "=", "len", "(", "global_params_list", ")", "\n", "percent", "=", "100", "*", "next_index", "/", "num_cases", "\n", "elapsed", "=", "time", ".", "perf_counter", "(", ")", "-", "global_start_time", "\n", "eta", "=", "elapsed", "*", "num_cases", "/", "(", "next_index", "+", "1", ")", "-", "elapsed", "\n", "\n", "print", "(", "f\"{round(percent, 2)}% Elapsed: {to_time_str(elapsed)}, ETA: {to_time_str(eta)} \"", "+", "f\"{next_index}/{num_cases}: \"", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "\n", "", "", "if", "next_index", "%", "100", "==", "0", ":", "\n", "        ", "print", "(", "\".\"", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "\n", "", "params", "=", "global_params_list", "[", "next_index", "]", "\n", "\n", "if", "Settings", ".", "max_counterexamples", "is", "not", "None", "and", "shared_num_counterexamples", ".", "value", ">", "Settings", ".", "max_counterexamples", ":", "\n", "        ", "next_index", "=", "-", "1", "\n", "\n", "", "return", "next_index", ",", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.worker_had_counterexample": [[97, 101], ["shared_counterexamples_list.append"], "function", ["None"], ["", "def", "worker_had_counterexample", "(", "res", ")", ":", "\n", "    ", "\"\"\"called when worker has a counterexample to update shared state\"\"\"", "\n", "\n", "shared_counterexamples_list", ".", "append", "(", "res", "[", "'index'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.make_params": [[102, 185], ["print", "round", "round", "round", "round", "round", "reversed", "round", "round", "round", "round", "range", "range", "reversed", "range", "range", "len", "range", "len", "range", "len", "range", "util.is_init_qx_qy", "params_list.append"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.is_init_qx_qy"], ["", "def", "make_params", "(", "max_index", "=", "None", ")", ":", "\n", "    ", "\"\"\"make params for parallel run\"\"\"", "\n", "\n", "# 1000-1200 is safe with 250, 50, 1.5, 950-1000 is not!", "\n", "# finished enumeration (1843200 cases) in 13.68 min, counterexamples: 0", "\n", "#num timeouts: 0", "\n", "#Avg runtime per case: 0.055 sec", "\n", "#longest runtime (15.23) (index: 949)", "\n", "\n", "\n", "# 900-1000 safe with 250, 25, 1.5, but not 850-900!", "\n", "#finished enumeration (3686400 cases) in 23.93 min, counterexamples: 0", "\n", "#num timeouts: 0", "\n", "#Avg runtime per case: 0.048 sec", "\n", "#longest runtime (58.26) (index: 693)", "\n", "\n", "# 881.5 has unsafe case!!!!!!", "\n", "\n", "vel_ownship", "=", "Settings", ".", "range_vel_ownship", "\n", "vel_intruder", "=", "Settings", ".", "range_vel_intruder", "#(0, 1200) # full range", "\n", "#vel_intruder = (0, 300)", "\n", "\n", "print", "(", "f\"Making params with vel_ownship={vel_ownship}, vel_intruder={vel_intruder}, \"", "+", "f\"and max_index={max_index}...\"", ")", "\n", "\n", "pos_quantum", "=", "Settings", ".", "pos_q", "\n", "vel_quantum", "=", "Settings", ".", "vel_q", "\n", "theta1_quantum", "=", "Settings", ".", "theta1_q", "\n", "\n", "assert", "-", "500", "%", "pos_quantum", "<", "1e-6", "\n", "assert", "500", "%", "pos_quantum", "<", "1e-6", "\n", "\n", "x_own_min", "=", "round", "(", "-", "500", "/", "pos_quantum", ")", "\n", "x_own_max", "=", "round", "(", "500", "/", "pos_quantum", ")", "\n", "\n", "y_own_min", "=", "round", "(", "-", "500", "/", "pos_quantum", ")", "\n", "y_own_max", "=", "round", "(", "500", "/", "pos_quantum", ")", "\n", "\n", "max_qtheta1", "=", "round", "(", "2", "*", "pi", "/", "theta1_quantum", ")", "\n", "\n", "if", "vel_quantum", "!=", "0", ":", "\n", "        ", "qvimin", "=", "round", "(", "vel_intruder", "[", "0", "]", "/", "vel_quantum", ")", "\n", "qvimax", "=", "round", "(", "vel_intruder", "[", "1", "]", "/", "vel_quantum", ")", "\n", "\n", "qvomin", "=", "round", "(", "vel_ownship", "[", "0", "]", "/", "vel_quantum", ")", "\n", "qvomax", "=", "round", "(", "vel_ownship", "[", "1", "]", "/", "vel_quantum", ")", "\n", "\n", "for", "i", "in", "range", "(", "2", ")", ":", "\n", "            ", "assert", "vel_ownship", "[", "i", "]", "%", "vel_quantum", "<", "1e-6", "\n", "assert", "vel_intruder", "[", "i", "]", "%", "vel_quantum", "<", "1e-6", "\n", "", "", "else", ":", "\n", "        ", "qvimin", "=", "vel_intruder", "[", "0", "]", "\n", "qvimax", "=", "vel_intruder", "[", "0", "]", "+", "1", "\n", "\n", "qvomin", "=", "vel_ownship", "[", "0", "]", "\n", "qvomax", "=", "vel_ownship", "[", "0", "]", "+", "1", "\n", "\n", "", "params_list", "=", "[", "]", "\n", "\n", "# try to do cases that are more likely to be false first", "\n", "for", "alpha_prev", "in", "reversed", "(", "range", "(", "5", ")", ")", ":", "\n", "        ", "if", "max_index", "is", "not", "None", "and", "len", "(", "params_list", ")", ">", "max_index", ":", "\n", "            ", "break", "\n", "\n", "", "for", "q_vint", "in", "reversed", "(", "range", "(", "qvimin", ",", "qvimax", ")", ")", ":", "\n", "            ", "if", "max_index", "is", "not", "None", "and", "len", "(", "params_list", ")", ">", "max_index", ":", "\n", "                ", "break", "\n", "\n", "", "for", "q_vown", "in", "range", "(", "qvomin", ",", "qvomax", ")", ":", "\n", "                ", "if", "max_index", "is", "not", "None", "and", "len", "(", "params_list", ")", ">", "max_index", ":", "\n", "                    ", "break", "\n", "\n", "", "for", "y_own", "in", "range", "(", "y_own_min", ",", "y_own_max", ")", ":", "\n", "                    ", "for", "x_own", "in", "range", "(", "x_own_min", ",", "x_own_max", ")", ":", "\n", "\n", "                        ", "if", "not", "is_init_qx_qy", "(", "x_own", ",", "y_own", ")", ":", "\n", "                            ", "continue", "\n", "\n", "", "for", "qtheta1", "in", "range", "(", "0", ",", "max_qtheta1", ")", ":", "\n", "                            ", "params", "=", "(", "alpha_prev", ",", "x_own", ",", "y_own", ",", "qtheta1", ",", "q_vown", ",", "q_vint", ")", "\n", "params_list", ".", "append", "(", "params", ")", "\n", "\n", "", "", "", "", "", "", "return", "params_list", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.init_process": [[186, 194], ["q.get"], "function", ["None"], ["", "def", "init_process", "(", "q", ")", ":", "\n", "    ", "\"\"\"init the process\"\"\"", "\n", "\n", "global", "global_process_id", "\n", "\n", "global_process_id", "=", "q", ".", "get", "(", ")", "\n", "\n", "Timers", ".", "enabled", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.print_result": [[195, 213], ["print", "print", "print", "res[].star.get_witness", "round"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.get_witness"], ["", "def", "print_result", "(", "label", ",", "res", ")", ":", "\n", "    ", "\"\"\"print info on the passed-in backreach result\"\"\"", "\n", "\n", "diff", "=", "res", "[", "'runtime'", "]", "\n", "index", "=", "res", "[", "'index'", "]", "\n", "alpha_prev", ",", "x_own", ",", "y_own", ",", "qtheta1", ",", "q_vown", ",", "q_vint", "=", "global_params_list", "[", "index", "]", "\n", "\n", "num_popped", "=", "res", "[", "'num_popped'", "]", "\n", "unique_paths", "=", "res", "[", "'unique_paths'", "]", "\n", "unsafe", "=", "res", "[", "'counterexample'", "]", "is", "not", "None", "\n", "\n", "print", "(", "f\"{label} ({round(diff, 2)}) (index: {index}) for:\\nalpha_prev={alpha_prev}\\nx_own={x_own}\\n\"", "+", "f\"y_own={y_own}\\nqtheta1={qtheta1}\\nq_vown={q_vown}\\nq_vint={q_vint}\"", ")", "\n", "print", "(", "f'num_popped: {num_popped}, unique_paths: {unique_paths}, has_counterexample: {unsafe}'", ")", "\n", "\n", "if", "unsafe", ":", "\n", "        ", "rad", "=", "res", "[", "'counterexample'", "]", ".", "star", ".", "get_witness", "(", "get_radius", "=", "True", ")", "[", "-", "1", "]", "\n", "print", "(", "f\"chebeshev radius of witness: {rad}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.get_counterexamples": [[214, 298], ["time.perf_counter", "multiprocessing.Queue", "range", "print", "print", "print", "len", "print", "time.perf_counter", "parallel.make_params", "len", "print", "util.get_num_cores", "multiprocessing.Queue.put", "multiprocessing.Pool", "pool.map", "time.perf_counter", "print", "print", "max", "time.perf_counter", "print", "util.get_num_cores", "range", "counterexamples.append", "counterexamples.append", "util.to_time_str", "round", "util.to_time_str", "len", "len"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.make_params", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_num_cores", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_num_cores", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.to_time_str", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.to_time_str"], ["", "", "def", "get_counterexamples", "(", "backreach_single", ",", "indices", "=", "None", ",", "params", "=", "None", ")", ":", "\n", "    ", "\"\"\"get all counterexamples at the current quantization\"\"\"", "\n", "\n", "global", "global_start_time", "\n", "global", "global_params_list", "\n", "\n", "# reset values", "\n", "shared_next_index", ".", "value", "=", "0", "\n", "shared_num_counterexamples", ".", "value", "=", "0", "\n", "shared_num_timeouts", ".", "value", "=", "0", "\n", "shared_counterexamples_list", "[", ":", "]", "=", "[", "]", "# clear list", "\n", "\n", "if", "params", "is", "not", "None", ":", "\n", "        ", "num_cases", "=", "len", "(", "params", ")", "\n", "global_params_list", "=", "params", "\n", "print", "(", "f\"Using passed-in params (num: {num_cases})\"", ")", "\n", "\n", "", "else", ":", "\n", "        ", "max_index", "=", "None", "\n", "\n", "if", "indices", "is", "not", "None", ":", "\n", "            ", "max_index", "=", "max", "(", "indices", ")", "\n", "\n", "", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "global_params_list", "=", "make_params", "(", "max_index", ")", "\n", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "\n", "if", "indices", "is", "not", "None", ":", "\n", "            ", "print", "(", "f\"WARNING: using fixed indices up to max_index={max_index}\"", ")", "\n", "global_params_list", "=", "[", "global_params_list", "[", "i", "]", "for", "i", "in", "indices", "]", "\n", "\n", "", "num_cases", "=", "len", "(", "global_params_list", ")", "\n", "print", "(", "f\"Made params for {num_cases} cases in {round(diff, 2)} secs\"", ")", "\n", "\n", "", "global_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "q", "=", "multiprocessing", ".", "Queue", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "get_num_cores", "(", ")", ")", ":", "\n", "        ", "q", ".", "put", "(", "i", ")", "\n", "\n", "", "counterexamples", "=", "[", "]", "\n", "total_runtime", "=", "0.0", "\n", "\n", "res_was_none", "=", "False", "\n", "\n", "with", "multiprocessing", ".", "Pool", "(", "get_num_cores", "(", ")", ",", "initializer", "=", "init_process", ",", "initargs", "=", "(", "q", ",", ")", ")", "as", "pool", ":", "\n", "        ", "res_list", "=", "pool", ".", "map", "(", "backreach_single", ",", "range", "(", "num_cases", ")", ",", "chunksize", "=", "1", ")", "\n", "max_runtime", "=", "res_list", "[", "0", "]", "\n", "timeouts", "=", "0", "\n", "\n", "for", "res", "in", "res_list", ":", "\n", "            ", "if", "res", "is", "None", ":", "\n", "                ", "res_was_none", "=", "True", "\n", "continue", "\n", "\n", "", "if", "res", "[", "'counterexample'", "]", "is", "not", "None", ":", "\n", "                ", "counterexamples", ".", "append", "(", "res", ")", "\n", "\n", "", "if", "res", "[", "'timeout'", "]", ":", "\n", "                ", "counterexamples", ".", "append", "(", "res", ")", "\n", "timeouts", "+=", "1", "\n", "\n", "", "t", "=", "res", "[", "'runtime'", "]", "\n", "total_runtime", "+=", "t", "\n", "\n", "if", "t", ">", "max_runtime", "[", "'runtime'", "]", ":", "\n", "                ", "max_runtime", "=", "res", "\n", "\n", "", "", "", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "global_start_time", "\n", "print", "(", "f\"\\nfinished enumeration ({num_cases} cases) in {to_time_str(diff)}, \"", "+", "f\"counterexamples: {len(counterexamples)}\"", ")", "\n", "\n", "print", "(", "f\"num timeouts: {timeouts}\"", ")", "\n", "\n", "if", "shared_counterexamples_list", ":", "\n", "        ", "print", "(", "f\"counterexamples ({len(shared_counterexamples_list)}): {shared_counterexamples_list}\"", ")", "\n", "\n", "", "print", "(", "f\"Avg runtime per case: {to_time_str(total_runtime / num_cases)}\"", ")", "\n", "\n", "if", "res_was_none", ":", "\n", "        ", "print", "(", "\"Warning: Incomplete analysis: res was None for some cases (number of counterexamples \"", "+", "f\"exceeded Settings.max_counterexamples={Settings.max_counterexamples})\"", ")", "\n", "\n", "", "return", "counterexamples", ",", "max_runtime", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.save_counterexamples": [[299, 311], ["print", "pickle.dumps", "print", "open", "f.write", "len", "len", "round"], "function", ["None"], ["", "def", "save_counterexamples", "(", "counterexamples", ",", "filename", ")", ":", "\n", "    ", "\"\"\"pickle and save all counterexamples\"\"\"", "\n", "\n", "print", "(", "\"saving counterexamples...\"", ")", "\n", "\n", "raw", "=", "pickle", ".", "dumps", "(", "counterexamples", ")", "\n", "mb", "=", "len", "(", "raw", ")", "/", "1024", "/", "1024", "\n", "\n", "with", "open", "(", "filename", ",", "\"wb\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "raw", ")", "\n", "\n", "", "print", "(", "f\"Saved {len(counterexamples)} counterexamples ({round(mb, 3)} MB) to {filename}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.is_real_counterexample": [[312, 404], ["s.star.get_witness", "range_pt.copy", "math.sqrt", "math.atan2", "math.sqrt", "math.sqrt", "util.get_tau_index", "networks.get_cmd_continuous", "dubins.get_time_elapse_mat", "len", "print", "print", "s.print_replay_init", "print"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.get_witness", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_tau_index", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.get_cmd_continuous", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_time_elapse_mat", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.print_replay_init"], ["", "def", "is_real_counterexample", "(", "res", ")", ":", "\n", "    ", "\"\"\"is the passed in backreach a real (non-quantized counter-example)\"\"\"", "\n", "\n", "assert", "res", "[", "'counterexample'", "]", "is", "not", "None", "\n", "\n", "s", "=", "res", "[", "'counterexample'", "]", "\n", "\n", "_", ",", "range_pt", ",", "radius", "=", "s", ".", "star", ".", "get_witness", "(", "get_radius", "=", "True", ")", "\n", "tau", "=", "s", ".", "tau", "\n", "\n", "if", "radius", "<", "1e-6", ":", "\n", "#print(f\"chebeshev radius was too small ({radius}), skipping replay\")", "\n", "        ", "return", "False", "\n", "\n", "", "pt", "=", "range_pt", ".", "copy", "(", ")", "\n", "\n", "#q_theta1 = s.qtheta1", "\n", "#s_copy = deepcopy(s)", "\n", "\n", "#pos_quantum = Settings.pos_q", "\n", "#mismatch_quantized = False", "\n", "#mismatch_continuous = False", "\n", "unsafe_continuous", "=", "False", "\n", "c_cmd_out", "=", "s", ".", "alpha_prev_list", "[", "-", "1", "]", "\n", "assert", "c_cmd_out", "==", "0", "\n", "\n", "if", "Settings", ".", "tau_dot", "!=", "0", ":", "\n", "        ", "assert", "tau", "+", "1", "==", "len", "(", "s", ".", "alpha_prev_list", ")", "\n", "\n", "", "for", "_", "in", "s", ".", "alpha_prev_list", ":", "\n", "#expected_cmd = s.alpha_prev_list[-(i+2)]", "\n", "\n", "        ", "dx", "=", "pt", "[", "Star", ".", "X_INT", "]", "-", "pt", "[", "Star", ".", "X_OWN", "]", "\n", "dy", "=", "0", "-", "pt", "[", "Star", ".", "Y_OWN", "]", "\n", "\n", "#qdx = floor(dx / pos_quantum)", "\n", "#qdy = floor(dy / pos_quantum)", "\n", "\n", "rho", "=", "sqrt", "(", "dx", "*", "dx", "+", "dy", "*", "dy", ")", "\n", "\n", "if", "rho", "<", "500", "and", "tau", "==", "0", ":", "\n", "            ", "print", "(", "f\"Non-quantized replay is unsafe (rho={rho})! Real counterexample.\"", ")", "\n", "print", "(", ")", "\n", "s", ".", "print_replay_init", "(", ")", "\n", "print", "(", ")", "\n", "\n", "unsafe_continuous", "=", "True", "\n", "break", "\n", "\n", "#qstate = (qdx, qdy, q_theta1, s.qv_own, s.qv_int)", "\n", "#q_cmd_out = get_cmd(net, *qstate)", "\n", "\n", "", "c_theta1", "=", "atan2", "(", "pt", "[", "Star", ".", "VY_OWN", "]", ",", "pt", "[", "Star", ".", "VX_OWN", "]", ")", "\n", "#quantized = q_theta1 * Settings.theta1_q + Settings.theta1_q / 2", "\n", "\n", "#vown = s.qv_own * Settings.vel_q + Settings.vel_q / 2", "\n", "#vint = s.qv_int * Settings.vel_q + Settings.vel_q / 2", "\n", "vown", "=", "sqrt", "(", "pt", "[", "Star", ".", "VX_OWN", "]", "**", "2", "+", "pt", "[", "Star", ".", "VY_OWN", "]", "**", "2", ")", "\n", "vint", "=", "sqrt", "(", "pt", "[", "Star", ".", "VX_INT", "]", "**", "2", "+", "0", "**", "2", ")", "\n", "cstate", "=", "(", "dx", ",", "dy", ",", "c_theta1", ",", "vown", ",", "vint", ")", "\n", "\n", "tau_index", "=", "get_tau_index", "(", "tau", ")", "\n", "c_cmd_out", "=", "get_cmd_continuous", "(", "c_cmd_out", ",", "tau_index", ",", "*", "cstate", ")", "\n", "\n", "#print(f\"{i}. net: {net}, cstate: {cstate}, c_cmd: {c_cmd_out}\")", "\n", "\n", "#if q_cmd_out != expected_cmd and not mismatch_quantized:", "\n", "#    #print(f\"Quantized mismatch at step {i+1}. got cmd {q_cmd_out}, expected cmd {expected_cmd}\")", "\n", "#   mismatch_quantized = True", "\n", "\n", "#if c_cmd_out != expected_cmd and not mismatch_continuous:", "\n", "#print(f\"Non-quantized mismatch at step {i+1}/{len(s.alpha_prev_list) - 1}. \" + \\", "\n", "#      f\"got cmd {c_cmd_out}, expected cmd {expected_cmd}\")", "\n", "#    mismatch_continuous = True", "\n", "\n", "#if mismatch_quantized and mismatch_continuous:", "\n", "#    break", "\n", "\n", "#s_copy.backstep(forward=True, forward_alpha_prev=expected_cmd)", "\n", "#s_copy.backstep(forward=True, forward_alpha_prev=c_cmd_out)", "\n", "\n", "mat", "=", "get_time_elapse_mat", "(", "c_cmd_out", ",", "1.0", ")", "\n", "pt", "=", "mat", "@", "pt", "\n", "tau", "+=", "Settings", ".", "tau_dot", "\n", "\n", "#delta_q_theta = Settings.cmd_quantum_list[expected_cmd]# * theta1_quantum", "\n", "#q_theta1 += delta_q_theta", "\n", "\n", "#if mismatch_quantized:", "\n", "#    print(\"Warning: Quantized replay DOES NOT match\")", "\n", "\n", "", "return", "unsafe_continuous", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.refine_counterexamples": [[405, 507], ["print", "print", "enumerate", "print", "parallel.is_real_counterexample", "len", "print", "print", "print", "parallel.get_counterexamples", "print", "print", "cqstates.append", "cqstates.append", "cqstates.append", "cqstates.append", "util.is_init_qx_qy", "len", "parallel.refine_counterexamples", "print", "len", "print", "settings.Settings.init_cmd_quantum_list", "cqstates.append", "cqstates.append", "cqstates.append", "cqstates.append", "cqstates.append", "cqstates.append", "qstates.append", "len"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.is_real_counterexample", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.get_counterexamples", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.is_init_qx_qy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.refine_counterexamples", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.settings.Settings.init_cmd_quantum_list"], ["", "def", "refine_counterexamples", "(", "backreach_single", ",", "counterexamples", ",", "level", "=", "0", ")", ":", "\n", "    ", "\"\"\"refine counterexamples\n\n    returns True if refinement is safe\n    \"\"\"", "\n", "\n", "print", "(", "f\"\\n####### level {level}: Refining {len(counterexamples)} counterexamples ######\"", ")", "\n", "\n", "# need to do this check before refining Settings", "\n", "print", "(", "\"Replaying counterexamples...\"", ")", "\n", "for", "i", ",", "counterexample", "in", "enumerate", "(", "counterexamples", ")", ":", "\n", "#print(f\"Replaying counterexample {i+1}/{len(counterexamples)}\")", "\n", "\n", "        ", "if", "counterexample", "[", "'timeout'", "]", ":", "\n", "#print(\"was timeout\")", "\n", "            ", "continue", "\n", "\n", "", "assert", "counterexample", "[", "'counterexample'", "]", "is", "not", "None", "\n", "\n", "if", "is_real_counterexample", "(", "counterexample", ")", ":", "\n", "            ", "print", "(", "f\"Found reach counterexample at state: {counterexample['params']}\"", ")", "\n", "return", "False", "\n", "\n", "", "", "qstates", "=", "[", "]", "# qstates after refinement", "\n", "\n", "levels", "=", "[", "'pos'", ",", "'vel'", ",", "'pos'", ",", "'vel'", ",", "'pos'", ",", "'vel'", ",", "'theta1'", ",", "'pos'", ",", "'vel'", ",", "'theta1'", ",", "\n", "'pos'", ",", "'vel'", ",", "'theta1'", ",", "'pos'", ",", "'vel'", ",", "'pos'", ",", "'vel'", ",", "'pos'", ",", "'vel'", "]", "\n", "\n", "if", "level", ">=", "len", "(", "levels", ")", ":", "\n", "        ", "print", "(", "f\"Refinement reached max level: {len(levels)}\"", ")", "\n", "return", "False", "\n", "\n", "", "if", "levels", "[", "level", "]", "==", "'pos'", "or", "(", "levels", "[", "level", "]", "==", "'vel'", "and", "Settings", ".", "vel_q", "==", "0", ")", ":", "\n", "        ", "print", "(", "f\"Level {level}: refining q_pos from {Settings.pos_q} to {Settings.pos_q / 2}\"", ")", "\n", "Settings", ".", "pos_q", "/=", "2", "\n", "", "elif", "levels", "[", "level", "]", "==", "'vel'", ":", "\n", "        ", "print", "(", "f\"Level {level}: refining q_vel from {Settings.vel_q} to {Settings.vel_q / 2}\"", ")", "\n", "Settings", ".", "vel_q", "/=", "2", "\n", "", "elif", "levels", "[", "level", "]", "==", "'theta1'", ":", "\n", "        ", "print", "(", "f\"Level {level}: refining q_theta1 from {Settings.theta1_q_deg} to {Settings.theta1_q_deg / 2}\"", ")", "\n", "Settings", ".", "theta1_q_deg", "/=", "2", "\n", "Settings", ".", "theta1_q", "/=", "2", "\n", "Settings", ".", "init_cmd_quantum_list", "(", ")", "# since theta1 was changed", "\n", "\n", "", "Settings", ".", "single_case_timeout", "*=", "2", "\n", "\n", "print", "(", "f\"Level {level} with Settings: pos={Settings.pos_q}, vel={Settings.vel_q}, theta1={Settings.theta1_q_deg}, \"", "+", "f\"timeout={Settings.single_case_timeout}\"", ")", "\n", "\n", "for", "counterexample", "in", "counterexamples", ":", "\n", "        ", "alpha_prev", ",", "x_own", ",", "y_own", ",", "qtheta1", ",", "q_vown", ",", "q_vint", "=", "counterexample", "[", "'params'", "]", "\n", "s", "=", "counterexample", "[", "'counterexample'", "]", "\n", "\n", "#if s is not None:", "\n", "#    _, _, radius = s.star.get_witness(get_radius=True)", "\n", "#    print(f\"rad: {radius}\")", "\n", "\n", "#    if radius < 1e-6: # radius was too small to be a real counterexample (replay fails due to numerics)", "\n", "#        continue", "\n", "\n", "cqstates", "=", "[", "]", "# candidate qstates for the next iteration", "\n", "\n", "# add refined states to qstates", "\n", "if", "levels", "[", "level", "]", "==", "'pos'", ":", "\n", "            ", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "2", "*", "x_own", ",", "2", "*", "y_own", ",", "qtheta1", ",", "q_vown", ",", "q_vint", ")", ")", "\n", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "2", "*", "x_own", "+", "1", ",", "2", "*", "y_own", ",", "qtheta1", ",", "q_vown", ",", "q_vint", ")", ")", "\n", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "2", "*", "x_own", ",", "2", "*", "y_own", "+", "1", ",", "qtheta1", ",", "q_vown", ",", "q_vint", ")", ")", "\n", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "2", "*", "x_own", "+", "1", ",", "2", "*", "y_own", "+", "1", ",", "qtheta1", ",", "q_vown", ",", "q_vint", ")", ")", "\n", "", "elif", "levels", "[", "level", "]", "==", "'vel'", ":", "\n", "            ", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "x_own", ",", "y_own", ",", "qtheta1", ",", "2", "*", "q_vown", ",", "2", "*", "q_vint", ")", ")", "\n", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "x_own", ",", "y_own", ",", "qtheta1", ",", "2", "*", "q_vown", "+", "1", ",", "2", "*", "q_vint", ")", ")", "\n", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "x_own", ",", "y_own", ",", "qtheta1", ",", "2", "*", "q_vown", ",", "2", "*", "q_vint", "+", "1", ")", ")", "\n", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "x_own", ",", "y_own", ",", "qtheta1", ",", "2", "*", "q_vown", "+", "1", ",", "2", "*", "q_vint", "+", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "assert", "levels", "[", "level", "]", "==", "'theta1'", "\n", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "x_own", ",", "y_own", ",", "2", "*", "qtheta1", ",", "q_vown", ",", "q_vint", ")", ")", "\n", "cqstates", ".", "append", "(", "(", "alpha_prev", ",", "x_own", ",", "y_own", ",", "2", "*", "qtheta1", "+", "1", ",", "q_vown", ",", "q_vint", ")", ")", "\n", "\n", "", "for", "qstate", "in", "cqstates", ":", "\n", "            ", "x_own", "=", "qstate", "[", "1", "]", "\n", "y_own", "=", "qstate", "[", "2", "]", "\n", "\n", "# make sure it's still an initial state after refinement", "\n", "if", "is_init_qx_qy", "(", "x_own", ",", "y_own", ")", ":", "\n", "                ", "qstates", ".", "append", "(", "qstate", ")", "\n", "\n", "", "", "", "rv", "=", "True", "\n", "\n", "if", "not", "qstates", ":", "\n", "        ", "print", "(", "\"no more qstates after trimming initial states, safe!\"", ")", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "qstates", ")", ">", "Settings", ".", "max_counterexamples", ":", "\n", "            ", "qstates", "=", "qstates", "[", ":", "Settings", ".", "max_counterexamples", "]", "\n", "\n", "", "new_counterexamples", ",", "_", "=", "get_counterexamples", "(", "backreach_single", ",", "params", "=", "qstates", ")", "\n", "\n", "if", "new_counterexamples", ":", "\n", "            ", "rv", "=", "refine_counterexamples", "(", "backreach_single", ",", "new_counterexamples", ",", "level", "=", "level", "+", "1", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"no new counterexamples found, safe!\"", ")", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.run_all_parallel": [[508, 551], ["parallel.get_counterexamples", "print", "parallel.print_result", "print", "print", "parallel.refine_counterexamples", "print", "print", "print", "print", "len"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.get_counterexamples", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.print_result", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.refine_counterexamples"], ["", "def", "run_all_parallel", "(", "backreach_single", ",", "tau_dot", ",", "indices", "=", "None", ")", ":", "\n", "    ", "\"\"\"loop over all cases, returns true if proven safe witout refining\"\"\"", "\n", "\n", "assert", "tau_dot", "in", "[", "-", "1", ",", "0", "]", "\n", "Settings", ".", "tau_dot", "=", "tau_dot", "\n", "\n", "counterexamples", ",", "max_runtime", "=", "get_counterexamples", "(", "backreach_single", ",", "indices", "=", "indices", ")", "\n", "\n", "print", "(", ")", "\n", "print_result", "(", "'longest runtime'", ",", "max_runtime", ")", "\n", "\n", "#for i, counterexample_res in enumerate(counterexamples):", "\n", "#    counterexample = counterexample_res['counterexample']", "\n", "\n", "#    print(f\"\\nCounterexample {i}:\")", "\n", "#    counterexample.print_replay_init()", "\n", "#    counterexample.print_replay_witness(plot=False)", "\n", "\n", "#    print_result(f\"Counterexample {i}\", counterexample_res)", "\n", "\n", "if", "indices", "is", "None", ":", "\n", "        ", "if", "counterexamples", ":", "\n", "            ", "print", "(", "\"\\nIncomplete analysis; had counterexamples.\"", ")", "\n", "\n", "#save_counterexamples(counterexamples, 'counterexamples.pkl')", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"\\nDone! No counterexamples.\"", ")", "\n", "", "", "else", ":", "\n", "        ", "print", "(", "f\"Finished passed-in {len(indices)} indices.\"", ")", "\n", "\n", "", "if", "not", "counterexamples", ":", "\n", "        ", "print", "(", "\"original system had no counterexamples\"", ")", "\n", "rv", "=", "True", "\n", "", "else", ":", "\n", "        ", "rv", "=", "False", "\n", "counterexamples_safe", "=", "refine_counterexamples", "(", "backreach_single", ",", "counterexamples", ")", "\n", "\n", "if", "counterexamples_safe", ":", "\n", "            ", "print", "(", "\"counterexamples proven safe after refining\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"counterexamples were not proven safe\"", ")", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.refine_indices": [[552, 577], ["isinstance", "isinstance", "max", "time.perf_counter", "parallel.make_params", "len", "print", "parallel.get_counterexamples", "print", "time.perf_counter", "parallel.refine_counterexamples", "round"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.make_params", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.get_counterexamples", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.refine_counterexamples"], ["", "def", "refine_indices", "(", "backreach_single", ",", "counterexample_index_list", ")", ":", "\n", "    ", "\"\"\"a debuggin function, refine a specific set of counterexample indices\"\"\"", "\n", "\n", "assert", "isinstance", "(", "counterexample_index_list", ",", "list", ")", "\n", "assert", "counterexample_index_list", ",", "\"empty list of counterexamples?\"", "\n", "assert", "isinstance", "(", "counterexample_index_list", "[", "0", "]", ",", "int", ")", "\n", "\n", "max_index", "=", "max", "(", "counterexample_index_list", ")", "\n", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "params", "=", "make_params", "(", "max_index", ")", "\n", "num_cases", "=", "len", "(", "params", ")", "\n", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "\n", "print", "(", "f\"Made params for {num_cases} cases in {round(diff, 2)} secs\"", ")", "\n", "\n", "params", "=", "[", "params", "[", "index", "]", "for", "index", "in", "counterexample_index_list", "]", "\n", "\n", "new_counterexamples", ",", "_", "=", "get_counterexamples", "(", "backreach_single", ",", "params", "=", "params", ")", "\n", "rv", "=", "True", "\n", "\n", "if", "new_counterexamples", ":", "\n", "        ", "rv", "=", "refine_counterexamples", "(", "backreach_single", ",", "new_counterexamples", ")", "\n", "\n", "", "print", "(", "f\"Finished refine_indices. Result was safe={rv}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.run_single_case": [[578, 605], ["print", "time.perf_counter", "parallel.make_params", "len", "print", "timerutil.Timers.tic", "backreach_single", "timerutil.Timers.toc", "timerutil.Timers.print_stats", "time.perf_counter", "print", "print", "print", "print", "matplotlib.show", "round"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.make_params", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.tic", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.backreach_single", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.print_stats"], ["", "def", "run_single_case", "(", "backreach_single", ",", "index", ",", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"test a single (difficult) case\"\"\"", "\n", "\n", "print", "(", "f\"running single with index={index}...\"", ")", "\n", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "params", "=", "make_params", "(", "index", "+", "1", ")", "\n", "num_cases", "=", "len", "(", "params", ")", "\n", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "\n", "print", "(", "f\"Made params for {num_cases} cases in {round(diff, 2)} secs\"", ")", "\n", "\n", "tup", "=", "params", "[", "index", "]", "\n", "\n", "Timers", ".", "tic", "(", "'top'", ")", "\n", "res", "=", "backreach_single", "(", "tup", ",", "parallel", "=", "False", ",", "plot", "=", "plot", ")", "\n", "Timers", ".", "toc", "(", "'top'", ")", "\n", "Timers", ".", "print_stats", "(", ")", "\n", "\n", "if", "res", "is", "not", "None", ":", "\n", "        ", "print", "(", "f\"popped: {res['num_popped']}\"", ")", "\n", "print", "(", "f\"unique_paths: {res['unique_paths']}\"", ")", "\n", "print", "(", "f\"counterexample: {res['counterexample'] is not None}\"", ")", "\n", "print", "(", "f\"timeout: {res['timeout']}\"", ")", "\n", "\n", "", "if", "plot", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_tau_index": [[15, 43], ["isinstance", "enumerate", "len", "abs", "abs"], "function", ["None"], ["def", "get_tau_index", "(", "tau", ")", ":", "\n", "    ", "\"\"\"get the index of the network given the value of tau in seconds\"\"\"", "\n", "\n", "assert", "isinstance", "(", "tau", ",", "int", ")", "\n", "\n", "tau_list", "=", "(", "0", ",", "1", ",", "5", ",", "10", ",", "20", ",", "50", ",", "60", ",", "80", ",", "100", ")", "\n", "tau_index", "=", "-", "1", "\n", "\n", "if", "tau", "<=", "tau_list", "[", "0", "]", ":", "\n", "        ", "tau_index", "=", "0", "\n", "", "elif", "tau", ">=", "tau_list", "[", "-", "1", "]", ":", "\n", "        ", "tau_index", "=", "len", "(", "tau_list", ")", "-", "1", "\n", "", "else", ":", "\n", "# find the index of the closest tau value, rounding down to break ties", "\n", "\n", "        ", "for", "i", ",", "tau_min", "in", "enumerate", "(", "tau_list", "[", ":", "-", "1", "]", ")", ":", "\n", "            ", "tau_max", "=", "tau_list", "[", "i", "+", "1", "]", "\n", "\n", "if", "tau_min", "<=", "tau", "<=", "tau_max", ":", "\n", "                ", "if", "abs", "(", "tau", "-", "tau_min", ")", "<=", "abs", "(", "tau", "-", "tau_max", ")", ":", "\n", "                    ", "tau_index", "=", "i", "\n", "", "else", ":", "\n", "                    ", "tau_index", "=", "i", "+", "1", "\n", "\n", "", "break", "\n", "\n", "", "", "", "assert", "tau_index", ">=", "0", ",", "f\"tau_index not found for tau = {tau}?\"", "\n", "return", "tau_index", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.is_init_qx_qy": [[44, 74], ["None"], "function", ["None"], ["", "def", "is_init_qx_qy", "(", "qx", ",", "qy", ")", ":", "\n", "    ", "\"\"\"is this an initial quantized location?\n\n    returns True if any of the corners is inside the collision circle\n    \"\"\"", "\n", "\n", "rv", "=", "False", "\n", "pos_quantum", "=", "Settings", ".", "pos_q", "\n", "\n", "xs", "=", "(", "qx", "*", "pos_quantum", ",", "(", "qx", "+", "1", ")", "*", "pos_quantum", ")", "\n", "ys", "=", "(", "qy", "*", "pos_quantum", ",", "(", "qy", "+", "1", ")", "*", "pos_quantum", ")", "\n", "\n", "# since qstates are algigned with x == 0 and y == 0 lines,", "\n", "# we just need to check if ant of the corners are initial states", "\n", "collision_rad_sq", "=", "500", "**", "2", "\n", "epsilon", "=", "1e-6", "\n", "\n", "for", "x", "in", "xs", ":", "\n", "        ", "for", "y", "in", "ys", ":", "\n", "            ", "dist_sq", "=", "x", "*", "x", "+", "y", "*", "y", "\n", "\n", "if", "dist_sq", "<", "collision_rad_sq", "-", "epsilon", ":", "\n", "# one of corners was inside collision circle", "\n", "                ", "rv", "=", "True", "\n", "break", "\n", "\n", "", "", "if", "rv", ":", "\n", "            ", "break", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_num_cores": [[75, 81], ["len", "os.sched_getaffinity"], "function", ["None"], ["", "def", "get_num_cores", "(", ")", ":", "\n", "    ", "\"\"\"get num cores available for comulation\"\"\"", "\n", "\n", "#print(\"DEBUG: two cores\")", "\n", "#return 2", "\n", "return", "len", "(", "os", ".", "sched_getaffinity", "(", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.to_time_str": [[82, 97], ["zip", "round"], "function", ["None"], ["", "def", "to_time_str", "(", "secs", ")", ":", "\n", "    ", "'return a string representation of the number of seconds'", "\n", "\n", "divisors", "=", "[", "1", ",", "60", ",", "60", "*", "60", ",", "24", "*", "60", "*", "60", ",", "7", "*", "24", "*", "60", "*", "60", ",", "365", "*", "24", "*", "60", "*", "60", ",", "np", ".", "inf", "]", "\n", "labels", "=", "[", "\"sec\"", ",", "\"min\"", ",", "\"hr\"", ",", "\"days\"", ",", "\"weeks\"", ",", "\"years\"", "]", "\n", "bounds", "=", "divisors", "[", "1", ":", "]", "\n", "digits", "=", "[", "3", ",", "2", ",", "3", ",", "4", ",", "4", ",", "4", "]", "\n", "time_str", "=", "\"\"", "\n", "\n", "for", "divisor", ",", "digit", ",", "label", ",", "bound", "in", "zip", "(", "divisors", ",", "digits", ",", "labels", ",", "bounds", ")", ":", "\n", "        ", "if", "secs", "<", "bound", ":", "\n", "            ", "time_str", "=", "f\"{round(secs / divisor, digit)} {label}\"", "\n", "break", "\n", "\n", "", "", "return", "time_str", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.quantize": [[98, 105], ["round"], "function", ["None"], ["", "def", "quantize", "(", "x", ",", "delta", "=", "50", ")", ":", "\n", "    ", "\"\"\"round to the nearest delta (offset by delta / 2)\n\n    for example using 50 will round anything between 0 and 50 to 25\n    \"\"\"", "\n", "\n", "return", "delta", "/", "2", "+", "delta", "*", "round", "(", "(", "x", "-", "delta", "/", "2", ")", "/", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.make_qstar": [[106, 145], ["timerutil.Timers.tic", "copy.deepcopy", "timerutil.Timers.toc", "copy.deepcopy.limit_dx_dy", "numpy.zeros", "np.zeros.copy", "copy.deepcopy.add_dense_row", "copy.deepcopy.add_dense_row", "np.zeros.copy", "copy.deepcopy.add_dense_row", "copy.deepcopy.add_dense_row"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.tic", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.limit_dx_dy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row"], ["", "@", "timed", "\n", "def", "make_qstar", "(", "orig_star", ",", "qstate", ")", ":", "\n", "    ", "\"\"\"return a subset of the star within the given quantization box\"\"\"", "\n", "\n", "pos_quantum", "=", "Settings", ".", "pos_q", "\n", "\n", "qdx", ",", "qdy", "=", "qstate", "[", ":", "2", "]", "\n", "max_x", "=", "(", "qdx", "+", "1", ")", "*", "pos_quantum", "\n", "min_x", "=", "(", "qdx", ")", "*", "pos_quantum", "\n", "max_y", "=", "(", "qdy", "+", "1", ")", "*", "pos_quantum", "\n", "min_y", "=", "(", "qdy", ")", "*", "pos_quantum", "\n", "\n", "# copy the lp and add box constraints", "\n", "Timers", ".", "tic", "(", "'deepcopy orig_star'", ")", "\n", "star", "=", "deepcopy", "(", "orig_star", ")", "\n", "Timers", ".", "toc", "(", "'deepcopy orig_star'", ")", "\n", "\n", "star", ".", "limit_dx_dy", "(", "(", "min_x", ",", "max_x", ")", ",", "(", "min_y", ",", "max_y", ")", ")", "\n", "\n", "if", "False", ":", "\n", "# dx constraints", "\n", "        ", "dims", "=", "star", ".", "a_mat", ".", "shape", "[", "1", "]", "\n", "zeros", "=", "np", ".", "zeros", "(", "dims", ")", "\n", "vec", "=", "zeros", ".", "copy", "(", ")", "\n", "vec", "[", "Star", ".", "X_INT", "]", "=", "1", "\n", "vec", "[", "Star", ".", "X_OWN", "]", "=", "-", "1", "\n", "\n", "star", ".", "add_dense_row", "(", "vec", ",", "max_x", ")", "\n", "star", ".", "add_dense_row", "(", "-", "vec", ",", "-", "min_x", ")", "\n", "\n", "# dy constraints", "\n", "vec", "=", "zeros", ".", "copy", "(", ")", "\n", "#vec[Star.Y_INT] = 1 # y-int is zero", "\n", "vec", "[", "Star", ".", "Y_OWN", "]", "=", "-", "1", "\n", "\n", "star", ".", "add_dense_row", "(", "vec", ",", "max_y", ")", "\n", "star", ".", "add_dense_row", "(", "-", "vec", ",", "-", "min_y", ")", "\n", "\n", "", "return", "star", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.make_large_qstar": [[146, 184], ["timerutil.Timers.tic", "copy.deepcopy", "timerutil.Timers.toc", "copy.deepcopy.limit_dx_dy", "numpy.zeros", "np.zeros.copy", "copy.deepcopy.add_dense_row", "copy.deepcopy.add_dense_row", "np.zeros.copy", "copy.deepcopy.add_dense_row", "copy.deepcopy.add_dense_row"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.tic", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.timerutil.Timers.toc", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.limit_dx_dy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row"], ["", "@", "timed", "\n", "def", "make_large_qstar", "(", "orig_star", ",", "qx_min", ",", "qx_max", ",", "qy_min", ",", "qy_max", ")", ":", "\n", "    ", "\"\"\"return a subset of the star within the given quantization box\"\"\"", "\n", "\n", "pos_quantum", "=", "Settings", ".", "pos_q", "\n", "\n", "max_x", "=", "(", "qx_max", ")", "*", "pos_quantum", "\n", "min_x", "=", "(", "qx_min", ")", "*", "pos_quantum", "\n", "max_y", "=", "(", "qy_max", ")", "*", "pos_quantum", "\n", "min_y", "=", "(", "qy_min", ")", "*", "pos_quantum", "\n", "\n", "# copy the lp and add box constraints", "\n", "Timers", ".", "tic", "(", "'deepcopy orig_star'", ")", "\n", "star", "=", "deepcopy", "(", "orig_star", ")", "\n", "Timers", ".", "toc", "(", "'deepcopy orig_star'", ")", "\n", "\n", "star", ".", "limit_dx_dy", "(", "(", "min_x", ",", "max_x", ")", ",", "(", "min_y", ",", "max_y", ")", ")", "\n", "\n", "if", "False", ":", "\n", "# dx constraints", "\n", "        ", "dims", "=", "star", ".", "a_mat", ".", "shape", "[", "1", "]", "\n", "zeros", "=", "np", ".", "zeros", "(", "dims", ")", "\n", "vec", "=", "zeros", ".", "copy", "(", ")", "\n", "vec", "[", "Star", ".", "X_INT", "]", "=", "1", "\n", "vec", "[", "Star", ".", "X_OWN", "]", "=", "-", "1", "\n", "\n", "star", ".", "add_dense_row", "(", "vec", ",", "max_x", ")", "\n", "star", ".", "add_dense_row", "(", "-", "vec", ",", "-", "min_x", ")", "\n", "\n", "# dy constraints", "\n", "vec", "=", "zeros", ".", "copy", "(", ")", "\n", "#vec[Star.Y_INT] = 1 # y-int is zero", "\n", "vec", "[", "Star", ".", "Y_OWN", "]", "=", "-", "1", "\n", "\n", "star", ".", "add_dense_row", "(", "vec", ",", "max_y", ")", "\n", "star", ".", "add_dense_row", "(", "-", "vec", ",", "-", "min_y", ")", "\n", "\n", "", "return", "star", "\n", "", ""]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.__init__": [[30, 53], ["len", "lpinstance.LpInstance", "numpy.identity", "numpy.zeros", "zip", "len", "len", "star.Star.hpoly.add_double_bounded_cols", "zip", "len", "len", "star.Star.hpoly.add_dense_row", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_double_bounded_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row"], ["def", "__init__", "(", "self", ",", "box", ",", "constraints_a_mat", "=", "None", ",", "constraints_b_vec", "=", "None", ")", ":", "\n", "        ", "\"\"\"create star from a list of box constraints\n        and inequality constrainta a_mat * x <= b_vec\n        \"\"\"", "\n", "\n", "names", "=", "(", "\"x_o\"", ",", "\"y_o\"", ",", "\"vx_o\"", ",", "\"vy_o\"", ",", "\"x_i\"", ",", "\"vx_i\"", ")", "\n", "self", ".", "dims", "=", "len", "(", "names", ")", "\n", "\n", "assert", "len", "(", "box", ")", "==", "len", "(", "names", ")", "\n", "\n", "self", ".", "hpoly", "=", "LpInstance", "(", ")", "\n", "self", ".", "a_mat", "=", "np", ".", "identity", "(", "self", ".", "dims", ")", "\n", "self", ".", "b_vec", "=", "np", ".", "zeros", "(", "self", ".", "dims", ")", "\n", "\n", "for", "name", ",", "(", "lb", ",", "ub", ")", "in", "zip", "(", "names", ",", "box", ")", ":", "\n", "            ", "self", ".", "hpoly", ".", "add_double_bounded_cols", "(", "[", "name", "]", ",", "lb", ",", "ub", ")", "\n", "\n", "# add constraints", "\n", "", "if", "constraints_a_mat", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "constraints_a_mat", ")", "==", "len", "(", "constraints_b_vec", ")", "\n", "\n", "for", "row", ",", "rhs", "in", "zip", "(", "constraints_a_mat", ",", "constraints_b_vec", ")", ":", "\n", "                ", "self", ".", "hpoly", ".", "add_dense_row", "(", "np", ".", "array", "(", "row", ",", "dtype", "=", "float", ")", ",", "rhs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.verts": [[54, 94], ["isinstance", "isinstance", "kamenev.get_verts", "numpy.zeros", "numpy.zeros", "star.Star.minimize_vec", "numpy.dot", "numpy.dot", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.kamenev.get_verts", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.minimize_vec"], ["", "", "", "def", "verts", "(", "self", ",", "xdim", "=", "0", ",", "ydim", "=", "1", ",", "epsilon", "=", "1e-7", ")", ":", "\n", "        ", "'get a 2-d projection of this lp_star'", "\n", "\n", "dims", "=", "self", ".", "a_mat", ".", "shape", "[", "0", "]", "\n", "\n", "if", "isinstance", "(", "xdim", ",", "int", ")", ":", "\n", "            ", "assert", "0", "<=", "xdim", "<", "dims", ",", "f\"xdim {xdim} out of bounds for star with {dims} dims\"", "\n", "vec", "=", "np", ".", "zeros", "(", "dims", ",", "dtype", "=", "float", ")", "\n", "vec", "[", "xdim", "]", "=", "1", "\n", "xdim", "=", "vec", "\n", "", "else", ":", "\n", "            ", "assert", "xdim", ".", "size", "==", "dims", "\n", "\n", "", "if", "isinstance", "(", "ydim", ",", "int", ")", ":", "\n", "            ", "assert", "0", "<=", "ydim", "<", "dims", ",", "f\"ydim {ydim} out of bounds for star with {dims} dims\"", "\n", "vec", "=", "np", ".", "zeros", "(", "dims", ",", "dtype", "=", "float", ")", "\n", "vec", "[", "ydim", "]", "=", "1", "\n", "ydim", "=", "vec", "\n", "", "else", ":", "\n", "            ", "assert", "ydim", ".", "size", "==", "dims", "\n", "\n", "", "def", "supp_point_func", "(", "vec2d", ")", ":", "\n", "            ", "'maximize a support function direction'", "\n", "\n", "# use negative to maximize", "\n", "lpdir", "=", "-", "vec2d", "[", "0", "]", "*", "xdim", "+", "-", "vec2d", "[", "1", "]", "*", "ydim", "\n", "\n", "res", "=", "self", ".", "minimize_vec", "(", "lpdir", ")", "\n", "\n", "# project onto x and y", "\n", "resx", "=", "np", ".", "dot", "(", "xdim", ",", "res", ")", "\n", "resy", "=", "np", ".", "dot", "(", "ydim", ",", "res", ")", "\n", "\n", "return", "np", ".", "array", "(", "[", "resx", ",", "resy", "]", ",", "dtype", "=", "float", ")", "\n", "\n", "", "verts", "=", "kamenev", ".", "get_verts", "(", "2", ",", "supp_point_func", ",", "epsilon", "=", "epsilon", ")", "\n", "\n", "#assert np.allclose(verts[0], verts[-1])", "\n", "\n", "return", "verts", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.limit_dx_dy": [[95, 115], ["star.Star.hpoly.add_dense_row", "star.Star.hpoly.add_dense_row", "star.Star.hpoly.add_dense_row", "star.Star.hpoly.add_dense_row"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row"], ["", "@", "timed", "\n", "def", "limit_dx_dy", "(", "self", ",", "dx_range", ",", "dy_range", ")", ":", "\n", "        ", "\"\"\"limit dx and dy range of the star\"\"\"", "\n", "\n", "for", "b", "in", "self", ".", "b_vec", ":", "\n", "            ", "assert", "b", "==", "0", "\n", "\n", "", "xint_row", "=", "self", ".", "a_mat", "[", "Star", ".", "X_INT", "]", "\n", "xown_row", "=", "self", ".", "a_mat", "[", "Star", ".", "X_OWN", "]", "\n", "yown_row", "=", "self", ".", "a_mat", "[", "Star", ".", "Y_OWN", "]", "\n", "\n", "dx_vec", "=", "xint_row", "-", "xown_row", "\n", "\n", "self", ".", "hpoly", ".", "add_dense_row", "(", "dx_vec", ",", "dx_range", "[", "1", "]", ")", "\n", "self", ".", "hpoly", ".", "add_dense_row", "(", "-", "dx_vec", ",", "-", "dx_range", "[", "0", "]", ")", "\n", "\n", "dy_vec", "=", "-", "yown_row", "\n", "\n", "self", ".", "hpoly", ".", "add_dense_row", "(", "dy_vec", ",", "dy_range", "[", "1", "]", ")", "\n", "self", ".", "hpoly", ".", "add_dense_row", "(", "-", "dy_vec", ",", "-", "dy_range", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row": [[116, 126], ["star.Star.hpoly.add_dense_row"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row"], ["", "@", "timed", "\n", "def", "add_dense_row", "(", "self", ",", "vec", ",", "rhs", ")", ":", "\n", "        ", "\"\"\"intersect the domain with a linear constraint\"\"\"", "\n", "\n", "# vec * (A*alpha + b) <= rhs", "\n", "\n", "lp_vec", "=", "vec", "@", "self", ".", "a_mat", "\n", "lp_rhs", "=", "rhs", "-", "vec", "@", "self", ".", "b_vec", "\n", "\n", "self", ".", "hpoly", ".", "add_dense_row", "(", "lp_vec", ",", "lp_rhs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.is_feasible": [[127, 135], ["star.Star.hpoly.is_feasible"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.is_feasible"], ["", "@", "timed", "\n", "def", "is_feasible", "(", "self", ")", ":", "\n", "        ", "\"\"\"is the star feasible?\n\n        returns None or a feasible point in the domain\n        \"\"\"", "\n", "\n", "return", "self", ".", "hpoly", ".", "is_feasible", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.get_witness": [[136, 203], ["star.Star.hpoly.get_constraints_csr().toarray", "star.Star.hpoly.get_col_bounds", "star.Star.hpoly.get_rhs", "lpinstance.LpInstance", "lpinstance.LpInstance.add_cols", "lpinstance.LpInstance.add_positive_cols", "lpinstance.LpInstance.get_num_cols", "zip", "enumerate", "numpy.zeros", "lpinstance.LpInstance.minimize", "star.Star.domain_to_range", "numpy.linalg.norm", "numpy.zeros", "lpinstance.LpInstance.add_dense_row", "star.Star.hpoly.get_constraints_csr", "numpy.zeros", "lpinstance.LpInstance.add_dense_row", "numpy.zeros", "lpinstance.LpInstance.add_dense_row", "abs", "abs"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_col_bounds", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_rhs", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.add_positive_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_num_cols", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.minimize", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.domain_to_range", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.get_constraints_csr", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.add_dense_row"], ["", "@", "timed", "\n", "def", "get_witness", "(", "self", ",", "get_radius", "=", "False", ")", ":", "\n", "        ", "\"\"\"get a witness point of the star, using the Chebeshev center\"\"\"", "\n", "\n", "#assert self.hpoly.is_feasible()", "\n", "\n", "constraints", "=", "self", ".", "hpoly", ".", "get_constraints_csr", "(", ")", ".", "toarray", "(", ")", "\n", "col_bounds", "=", "self", ".", "hpoly", ".", "get_col_bounds", "(", ")", "\n", "rhs_list", "=", "self", ".", "hpoly", ".", "get_rhs", "(", ")", "# this fails if exist constriants other than '<='", "\n", "\n", "lpi", "=", "LpInstance", "(", ")", "\n", "\n", "lpi", ".", "add_cols", "(", "self", ".", "hpoly", ".", "names", ")", "# note: added as free (unbounded) variables", "\n", "\n", "#for name, lb, ub in zip(self.hpoly.names, lbs, ubs):", "\n", "#    lpi.add_double_bounded_cols([name], lb, ub)", "\n", "\n", "lpi", ".", "add_positive_cols", "(", "[", "'r'", "]", ")", "# radius of circle", "\n", "cols", "=", "lpi", ".", "get_num_cols", "(", ")", "\n", "\n", "for", "row", ",", "rhs", "in", "zip", "(", "constraints", ",", "rhs_list", ")", ":", "\n", "            ", "norm", "=", "np", ".", "linalg", ".", "norm", "(", "row", ")", "\n", "\n", "v", "=", "np", ".", "zeros", "(", "cols", ")", "\n", "v", "[", ":", "-", "1", "]", "=", "row", "\n", "v", "[", "-", "1", "]", "=", "norm", "\n", "\n", "lpi", ".", "add_dense_row", "(", "v", ",", "rhs", ")", "\n", "\n", "# also add radius constraints related to each of the lower and upper bounds", "\n", "", "for", "i", ",", "(", "lb", ",", "ub", ")", "in", "enumerate", "(", "col_bounds", ")", ":", "\n", "# example: x in [50, 100]", "\n", "\n", "            ", "if", "ub", "!=", "np", ".", "inf", ":", "\n", "                ", "v", "=", "np", ".", "zeros", "(", "cols", ")", "\n", "v", "[", "i", "]", "=", "1", "\n", "\n", "if", "abs", "(", "lb", "-", "ub", ")", ">", "1e-6", ":", "\n", "                    ", "v", "[", "-", "1", "]", "=", "1", "\n", "\n", "# x + r <= 100", "\n", "", "lpi", ".", "add_dense_row", "(", "v", ",", "ub", ")", "\n", "\n", "", "if", "lb", "!=", "-", "np", ".", "inf", ":", "\n", "                ", "v", "=", "np", ".", "zeros", "(", "cols", ")", "\n", "v", "[", "i", "]", "=", "-", "1", "\n", "\n", "if", "abs", "(", "lb", "-", "ub", ")", ">", "1e-6", ":", "\n", "                    ", "v", "[", "-", "1", "]", "=", "1", "\n", "\n", "# x - r >= 50", "\n", "# -x + r <= -50", "\n", "", "lpi", ".", "add_dense_row", "(", "v", ",", "-", "lb", ")", "\n", "\n", "", "", "max_r", "=", "np", ".", "zeros", "(", "cols", ")", "\n", "max_r", "[", "-", "1", "]", "=", "-", "1", "\n", "\n", "res", "=", "lpi", ".", "minimize", "(", "max_r", ")", "\n", "\n", "domain_pt", "=", "res", "[", ":", "-", "1", "]", "\n", "range_pt", "=", "self", ".", "domain_to_range", "(", "domain_pt", ")", "\n", "\n", "if", "get_radius", ":", "\n", "            ", "radius", "=", "res", "[", "-", "1", "]", "\n", "return", "domain_pt", ",", "range_pt", ",", "radius", "\n", "\n", "", "return", "domain_pt", ",", "range_pt", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.domain_to_range": [[204, 208], ["None"], "methods", ["None"], ["", "def", "domain_to_range", "(", "self", ",", "domain_pt", ")", ":", "\n", "        ", "\"\"\"convert a domain pt to a range pt\"\"\"", "\n", "\n", "return", "self", ".", "a_mat", "@", "domain_pt", "+", "self", ".", "b_vec", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.minimize_vec": [[209, 248], ["isinstance", "star.Star.hpoly.minimize", "numpy.zeros", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.lpinstance.LpInstance.minimize"], ["", "def", "minimize_vec", "(", "self", ",", "vec", ",", "return_io", "=", "False", ",", "fail_on_unsat", "=", "True", ")", ":", "\n", "        ", "\"\"\"optimize over this set\n\n        vec is the vector of outputs we're optimizing over, None means use zero vector\n\n        if return_io is true, returns a tuple (input, output); otherwise just output\n        note that the cinput will be the compressed input if input space is not full dimensional\n\n        returns all the outputs (coutput) if return_io=False, else (cinput, coutput)\n        \"\"\"", "\n", "\n", "if", "vec", "is", "None", ":", "\n", "            ", "vec", "=", "np", ".", "zeros", "(", "(", "self", ".", "a_mat", ".", "shape", "[", "0", "]", ",", ")", ",", "dtype", "=", "float", ")", "\n", "\n", "", "assert", "len", "(", "vec", ")", "==", "self", ".", "a_mat", ".", "shape", "[", "0", "]", ",", "f\"minimize called with vector with {len(vec)} elements, \"", "+", "f\"but set has {self.a_mat.shape[0]} outputs\"", "\n", "\n", "assert", "isinstance", "(", "vec", ",", "np", ".", "ndarray", ")", "\n", "\n", "lp_vec", "=", "vec", "@", "self", ".", "a_mat", "\n", "assert", "lp_vec", ".", "shape", "==", "(", "len", "(", "lp_vec", ")", ",", ")", "\n", "\n", "num_init_vars", "=", "self", ".", "a_mat", ".", "shape", "[", "1", "]", "\n", "\n", "lp_result", "=", "self", ".", "hpoly", ".", "minimize", "(", "lp_vec", ",", "fail_on_unsat", "=", "fail_on_unsat", ")", "\n", "\n", "if", "lp_result", "is", "None", ":", "\n", "            ", "rv", "=", "None", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "lp_result", ")", "==", "num_init_vars", "\n", "\n", "# convert optimization result back to output space", "\n", "rv", "=", "self", ".", "a_mat", "@", "lp_result", "+", "self", ".", "b_vec", "\n", "\n", "# return input as well", "\n", "", "if", "rv", "is", "not", "None", "and", "return_io", ":", "\n", "            ", "rv", "=", "(", "lp_result", ",", "rv", ")", "\n", "\n", "", "return", "rv", "\n", "", "", ""]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.__init__": [[38, 54], ["isinstance", "backreach.State.assign_state_id"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.assign_state_id"], ["def", "__init__", "(", "self", ",", "alpha_prev", ":", "int", ",", "qtheta1", ":", "int", ",", "qv_own", ":", "int", ",", "qv_int", ":", "int", ",", "star", ":", "Star", ")", ":", "\n", "\n", "        ", "assert", "isinstance", "(", "qtheta1", ",", "int", ")", "\n", "\n", "self", ".", "tau", "=", "0", "\n", "self", ".", "qtheta1", "=", "qtheta1", "\n", "self", ".", "qv_own", "=", "qv_own", "\n", "self", ".", "qv_int", "=", "qv_int", "\n", "\n", "self", ".", "alpha_prev_list", "=", "[", "alpha_prev", "]", "\n", "\n", "self", ".", "star", "=", "star", "\n", "\n", "self", ".", "state_id", "=", "-", "1", "\n", "self", ".", "assign_state_id", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.__str__": [[55, 57], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "f\"State(id={self.state_id} with alpha_prev_list = {self.alpha_prev_list})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy": [[58, 76], ["copy.deepcopy", "copy.deepcopy.assign_state_id"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.assign_state_id"], ["", "@", "timed", "\n", "def", "copy", "(", "self", ",", "new_star", "=", "None", ")", ":", "\n", "        ", "\"\"\"return a deep copy of self\"\"\"", "\n", "\n", "if", "new_star", "is", "not", "None", ":", "\n", "            ", "self_star", "=", "self", ".", "star", "\n", "self", ".", "star", "=", "None", "\n", "\n", "", "rv", "=", "deepcopy", "(", "self", ")", "\n", "rv", ".", "assign_state_id", "(", ")", "\n", "\n", "if", "new_star", "is", "not", "None", ":", "\n", "            ", "rv", ".", "star", "=", "new_star", "\n", "\n", "# restore self.star", "\n", "self", ".", "star", "=", "self_star", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.print_replay_init": [[77, 89], ["print", "print", "print", "print", "print", "backreach.State.star.get_witness", "print", "print", "repr", "repr"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.get_witness"], ["", "def", "print_replay_init", "(", "self", ")", ":", "\n", "        ", "\"\"\"print initialization states for replay\"\"\"", "\n", "\n", "print", "(", "f\"alpha_prev_list = {self.alpha_prev_list}\"", ")", "\n", "print", "(", "f\"qtheta1 = {self.qtheta1}\"", ")", "\n", "print", "(", "f\"qv_own = {self.qv_own}\"", ")", "\n", "print", "(", "f\"qv_int = {self.qv_int}\"", ")", "\n", "print", "(", "f\"tau_init = {self.tau}\"", ")", "\n", "\n", "domain_pt", ",", "range_pt", ",", "rad", "=", "self", ".", "star", ".", "get_witness", "(", "get_radius", "=", "True", ")", "\n", "print", "(", "f\"# chebeshev center radius: {rad}\"", ")", "\n", "print", "(", "f\"end = np.{repr(domain_pt)}\\nstart = np.{repr(range_pt)}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.print_replay_witness": [[90, 150], ["backreach.State.star.get_witness", "print", "plotting.Plotter", "print", "range_pt.copy", "copy.deepcopy", "plotting.Plotter.plot_star", "range", "math.floor", "math.floor", "util.get_tau_index", "networks.get_cmd", "print", "print", "print", "copy.deepcopy.backstep", "plotting.Plotter.plot_star", "dubins.get_time_elapse_mat", "matplotlib.show", "print", "print", "len", "print", "list"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.get_witness", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.plotting.Plotter.plot_star", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_tau_index", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.get_cmd", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.backstep", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.plotting.Plotter.plot_star", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_time_elapse_mat"], ["", "def", "print_replay_witness", "(", "self", ",", "plot", "=", "False", ")", ":", "\n", "        ", "\"\"\"print a step-by-step replay for the witness point\"\"\"", "\n", "\n", "s", "=", "self", "\n", "\n", "_", ",", "range_pt", ",", "rad", "=", "s", ".", "star", ".", "get_witness", "(", "get_radius", "=", "True", ")", "\n", "\n", "if", "rad", "<", "1e-6", ":", "\n", "            ", "print", "(", "f\"WARNING: radius was tiny ({rad}), skipping replay (may mismatch due to numerics)\"", ")", "\n", "", "else", ":", "\n", "            ", "p", "=", "Plotter", "(", ")", "\n", "\n", "print", "(", ")", "\n", "\n", "pt", "=", "range_pt", ".", "copy", "(", ")", "\n", "\n", "q_theta1", "=", "s", ".", "qtheta1", "\n", "s_copy", "=", "deepcopy", "(", "s", ")", "\n", "\n", "p", ".", "plot_star", "(", "s", ".", "star", ",", "color", "=", "'r'", ")", "\n", "mismatch", "=", "False", "\n", "\n", "pos_quantum", "=", "Settings", ".", "pos_q", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "s", ".", "alpha_prev_list", ")", "-", "1", ")", ":", "\n", "                ", "alpha_prev", "=", "s", ".", "alpha_prev_list", "[", "-", "(", "i", "+", "1", ")", "]", "\n", "expected_cmd", "=", "s", ".", "alpha_prev_list", "[", "-", "(", "i", "+", "2", ")", "]", "\n", "\n", "dx", "=", "floor", "(", "(", "pt", "[", "Star", ".", "X_INT", "]", "-", "pt", "[", "Star", ".", "X_OWN", "]", ")", "/", "pos_quantum", ")", "\n", "dy", "=", "floor", "(", "(", "0", "-", "pt", "[", "Star", ".", "Y_OWN", "]", ")", "/", "pos_quantum", ")", "\n", "\n", "qstate", "=", "(", "dx", ",", "dy", ",", "q_theta1", ",", "s", ".", "qv_own", ",", "s", ".", "qv_int", ")", "\n", "\n", "tau_index", "=", "get_tau_index", "(", "s", ".", "tau", ")", "\n", "cmd_out", "=", "get_cmd", "(", "alpha_prev", ",", "tau_index", ",", "*", "qstate", ")", "\n", "print", "(", "f\"({i+1}). alpha_prev={alpha_prev}, (tau, tau_index)={s.tau, tau_index} -> {cmd_out}\"", ")", "\n", "print", "(", "f\"state: {list(pt)}\"", ")", "\n", "print", "(", "f\"qstate: {qstate}\"", ")", "\n", "\n", "if", "cmd_out", "!=", "expected_cmd", ":", "\n", "                    ", "print", "(", "f\"Mismatch at step {i+1}. got cmd {cmd_out}, expected cmd {expected_cmd}\"", ")", "\n", "mismatch", "=", "True", "\n", "break", "\n", "\n", "", "s_copy", ".", "backstep", "(", "forward", "=", "True", ",", "forward_alpha_prev", "=", "cmd_out", ")", "\n", "p", ".", "plot_star", "(", "s_copy", ".", "star", ")", "\n", "\n", "mat", "=", "get_time_elapse_mat", "(", "cmd_out", ",", "1.0", ")", "\n", "pt", "=", "mat", "@", "pt", "\n", "\n", "delta_q_theta", "=", "Settings", ".", "cmd_quantum_list", "[", "cmd_out", "]", "# * theta1_quantum", "\n", "q_theta1", "+=", "delta_q_theta", "\n", "\n", "", "if", "plot", ":", "\n", "                ", "plt", ".", "show", "(", ")", "\n", "\n", "", "if", "mismatch", ":", "\n", "                ", "print", "(", "\"mismatch in replay... was the chebyshev center radius tiny?\"", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"witness commands all matched expectation\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.assign_state_id": [[151, 156], ["None"], "methods", ["None"], ["", "", "", "def", "assign_state_id", "(", "self", ")", ":", "\n", "        ", "\"\"\"assign and increment state_id\"\"\"", "\n", "\n", "self", ".", "state_id", "=", "State", ".", "next_state_id", "\n", "State", ".", "next_state_id", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.backstep": [[157, 186], ["dubins.get_time_elapse_mat"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_time_elapse_mat"], ["", "@", "timed", "\n", "def", "backstep", "(", "self", ",", "forward", "=", "False", ",", "forward_alpha_prev", "=", "-", "1", ")", ":", "\n", "        ", "\"\"\"step backwards according to alpha_prev\"\"\"", "\n", "\n", "if", "forward", ":", "\n", "            ", "cmd", "=", "forward_alpha_prev", "\n", "", "else", ":", "\n", "            ", "cmd", "=", "self", ".", "alpha_prev_list", "[", "-", "1", "]", "\n", "\n", "", "assert", "0", "<=", "cmd", "<=", "4", "\n", "\n", "mat", "=", "get_time_elapse_mat", "(", "cmd", ",", "-", "1.0", "if", "not", "forward", "else", "1.0", ")", "\n", "\n", "#if forward:", "\n", "#    print(f\"condition number of transform mat: {np.linalg.cond(mat)}\")", "\n", "#    print(f\"condition number of a_mat: {np.linalg.cond(self.star.a_mat)}\")", "\n", "\n", "self", ".", "star", ".", "a_mat", "=", "mat", "@", "self", ".", "star", ".", "a_mat", "\n", "self", ".", "star", ".", "b_vec", "=", "mat", "@", "self", ".", "star", ".", "b_vec", "\n", "\n", "# clear, weak left, weak right, strong left, strong right", "\n", "delta_q_theta", "=", "Settings", ".", "cmd_quantum_list", "[", "cmd", "]", "\n", "\n", "if", "forward", ":", "\n", "            ", "self", ".", "qtheta1", "+=", "delta_q_theta", "\n", "self", ".", "tau", "+=", "Settings", ".", "tau_dot", "\n", "", "else", ":", "\n", "            ", "self", ".", "qtheta1", "-=", "delta_q_theta", "\n", "self", ".", "tau", "-=", "Settings", ".", "tau_dot", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.get_predecessors": [[187, 348], ["backreach.State.get_dx_dy_qrange", "backreach.State.backstep", "backreach.State.get_dx_dy_qrange", "range", "range", "range", "backreach.State.copy", "backreach.State.alpha_prev_list.append", "rv.append", "util.is_init_qx_qy", "util.get_tau_index", "networks.get_cmd", "util.make_qstar", "backreach.State.copy", "backreach.State.alpha_prev_list.append", "rv.append", "util.make_qstar", "util.make_large_qstar.is_feasible", "min", "correct_qstates.index", "correct_qstates.pop", "correct_qstates.append", "incorrect_qstates.append", "util.make_large_qstar.is_feasible", "backreach.State.copy", "backreach.State.alpha_prev_list.append", "rv.append", "range", "range", "util.make_large_qstar", "correct_qstates.remove", "range", "range", "util.make_large_qstar.is_feasible", "backreach.State.copy", "backreach.State.alpha_prev_list.append", "rv.append", "correct_qstates.remove", "util.make_large_qstar", "util.make_large_qstar.is_feasible", "backreach.State.copy", "backreach.State.alpha_prev_list.append", "rv.append"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.get_dx_dy_qrange", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.backstep", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.get_dx_dy_qrange", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.is_init_qx_qy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.get_tau_index", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.networks.get_cmd", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.make_qstar", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.make_qstar", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.is_feasible", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.is_feasible", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.make_large_qstar", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.is_feasible", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.util.make_large_qstar", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.is_feasible", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy"], ["", "", "@", "timed", "\n", "def", "get_predecessors", "(", "self", ",", "stdout", "=", "False", ")", ":", "\n", "        ", "\"\"\"get the valid predecessors of this star\n        \"\"\"", "\n", "\n", "dx_qrange", ",", "dy_qrange", "=", "self", ".", "get_dx_dy_qrange", "(", "stdout", "=", "stdout", ")", "\n", "\n", "# compute previous state", "\n", "self", ".", "backstep", "(", ")", "\n", "\n", "rv", ":", "List", "[", "State", "]", "=", "[", "]", "\n", "dx_qrange", ",", "dy_qrange", "=", "self", ".", "get_dx_dy_qrange", "(", "stdout", "=", "stdout", ")", "\n", "\n", "# pass 1: do all quantized states classify the same (correct way)?", "\n", "# alternatively: are they all incorrect?", "\n", "\n", "# pass 2: if partial correct / incorrect, are any of the incorrect ones feasible?", "\n", "# if so, we may need to split the set", "\n", "\n", "constants", "=", "(", "self", ".", "qtheta1", ",", "self", ".", "qv_own", ",", "self", ".", "qv_int", ")", "\n", "\n", "for", "prev_cmd", "in", "range", "(", "5", ")", ":", "\n", "            ", "qstate_to_cmd", ":", "Dict", "[", "Tuple", "[", "int", ",", "int", "]", ",", "int", "]", "=", "{", "}", "\n", "all_right", "=", "True", "\n", "all_wrong", "=", "True", "\n", "correct_qstates", "=", "[", "]", "\n", "incorrect_qstates", "=", "[", "]", "\n", "\n", "for", "qdx", "in", "range", "(", "dx_qrange", "[", "0", "]", ",", "dx_qrange", "[", "1", "]", "+", "1", ")", ":", "\n", "                ", "for", "qdy", "in", "range", "(", "dy_qrange", "[", "0", "]", ",", "dy_qrange", "[", "1", "]", "+", "1", ")", ":", "\n", "                    ", "qstate", "=", "(", "qdx", ",", "qdy", ")", "\n", "\n", "# skip predecessors that are also initial states", "\n", "if", "is_init_qx_qy", "(", "qdx", ",", "qdy", ")", ":", "\n", "                        ", "continue", "\n", "\n", "", "tau_index", "=", "get_tau_index", "(", "self", ".", "tau", ")", "\n", "out_cmd", "=", "get_cmd", "(", "prev_cmd", ",", "tau_index", ",", "qdx", ",", "qdy", ",", "*", "constants", ")", "\n", "\n", "qstate_to_cmd", "[", "qstate", "]", "=", "out_cmd", "\n", "\n", "if", "out_cmd", "==", "self", ".", "alpha_prev_list", "[", "-", "1", "]", ":", "\n", "# command is correct", "\n", "                        ", "correct_qstates", ".", "append", "(", "qstate", ")", "\n", "all_wrong", "=", "False", "\n", "", "else", ":", "\n", "# command is wrong", "\n", "                        ", "incorrect_qstates", ".", "append", "(", "qstate", ")", "\n", "all_right", "=", "False", "\n", "\n", "", "", "", "if", "all_wrong", ":", "\n", "                ", "continue", "\n", "\n", "# no splitting; all correct", "\n", "", "if", "all_right", ":", "\n", "                ", "prev_s", "=", "self", ".", "copy", "(", ")", "\n", "prev_s", ".", "alpha_prev_list", ".", "append", "(", "prev_cmd", ")", "\n", "\n", "rv", ".", "append", "(", "prev_s", ")", "\n", "continue", "\n", "\n", "", "check_if_all_incorrect_infeasible", "=", "True", "\n", "\n", "if", "check_if_all_incorrect_infeasible", ":", "\n", "# still have a chance at all correct (no splitting): if all incorrect state are infeasible", "\n", "                ", "all_incorrect_infeasible", "=", "True", "\n", "\n", "for", "qstate", "in", "incorrect_qstates", ":", "\n", "                    ", "star", "=", "make_qstar", "(", "self", ".", "star", ",", "qstate", ")", "\n", "\n", "if", "star", ".", "is_feasible", "(", ")", "is", "not", "None", ":", "\n", "                        ", "all_incorrect_infeasible", "=", "False", "\n", "break", "\n", "\n", "# no splitting; all incorrect states were infeasible", "\n", "", "", "if", "all_incorrect_infeasible", ":", "\n", "                    ", "prev_s", "=", "self", ".", "copy", "(", ")", "\n", "prev_s", ".", "alpha_prev_list", ".", "append", "(", "prev_cmd", ")", "\n", "\n", "rv", ".", "append", "(", "prev_s", ")", "\n", "continue", "\n", "\n", "", "", "split_all_single", "=", "False", "\n", "\n", "if", "split_all_single", ":", "\n", "# split along individual quantum boundaries", "\n", "                ", "for", "qstate", "in", "correct_qstates", ":", "\n", "                    ", "star", "=", "make_qstar", "(", "self", ".", "star", ",", "qstate", ")", "\n", "domain_witness", "=", "star", ".", "is_feasible", "(", ")", "\n", "\n", "if", "domain_witness", "is", "not", "None", ":", "\n", "                        ", "prev_s", "=", "self", ".", "copy", "(", "star", ")", "\n", "prev_s", ".", "alpha_prev_list", ".", "append", "(", "prev_cmd", ")", "\n", "\n", "rv", ".", "append", "(", "prev_s", ")", "\n", "", "", "", "else", ":", "\n", "# split along multi-quantum boundaries, similar to run-length encoding", "\n", "\n", "                ", "while", "correct_qstates", ":", "\n", "# pop top left", "\n", "                    ", "qdx", ",", "qdy", "=", "min", "(", "correct_qstates", ")", "\n", "index", "=", "correct_qstates", ".", "index", "(", "(", "qdx", ",", "qdy", ")", ")", "\n", "#single_star = feasible_correct_stars.pop(index)", "\n", "correct_qstates", ".", "pop", "(", "index", ")", "\n", "\n", "min_x", "=", "qdx", "\n", "max_x", "=", "qdx", "+", "1", "\n", "\n", "# expand x", "\n", "while", "True", ":", "\n", "                        ", "qstate", "=", "(", "max_x", ",", "qdy", ")", "\n", "\n", "if", "qstate", "in", "correct_qstates", ":", "\n", "                            ", "correct_qstates", ".", "remove", "(", "qstate", ")", "\n", "max_x", "+=", "1", "\n", "", "else", ":", "\n", "                            ", "break", "\n", "\n", "# expand y", "\n", "", "", "min_y", "=", "qdy", "\n", "max_y", "=", "qdy", "+", "1", "\n", "\n", "while", "True", ":", "\n", "                        ", "all_in", "=", "True", "\n", "\n", "for", "x", "in", "range", "(", "min_x", ",", "max_x", ")", ":", "\n", "                            ", "qstate", "=", "(", "x", ",", "max_y", ")", "\n", "if", "qstate", "not", "in", "correct_qstates", ":", "\n", "                                ", "all_in", "=", "False", "\n", "break", "\n", "\n", "", "", "if", "all_in", ":", "\n", "# expand y                            ", "\n", "                            ", "for", "x", "in", "range", "(", "min_x", ",", "max_x", ")", ":", "\n", "                                ", "qstate", "=", "(", "x", ",", "max_y", ")", "\n", "correct_qstates", ".", "remove", "(", "qstate", ")", "\n", "\n", "", "max_y", "+=", "1", "\n", "", "else", ":", "\n", "                            ", "break", "\n", "\n", "", "", "force_single_dx_dy", "=", "False", "\n", "\n", "if", "force_single_dx_dy", ":", "\n", "                        ", "for", "x", "in", "range", "(", "min_x", ",", "max_x", ")", ":", "\n", "                            ", "for", "y", "in", "range", "(", "min_y", ",", "max_y", ")", ":", "\n", "                                ", "qstate", "=", "(", "x", ",", "y", ")", "\n", "star", "=", "make_large_qstar", "(", "self", ".", "star", ",", "x", ",", "x", "+", "1", ",", "y", ",", "y", "+", "1", ")", "\n", "\n", "if", "star", ".", "is_feasible", "(", ")", "is", "not", "None", ":", "\n", "                                    ", "prev_s", "=", "self", ".", "copy", "(", "star", ")", "\n", "prev_s", ".", "alpha_prev_list", ".", "append", "(", "prev_cmd", ")", "\n", "rv", ".", "append", "(", "prev_s", ")", "\n", "", "", "", "", "else", ":", "\n", "                        ", "large_star", "=", "make_large_qstar", "(", "self", ".", "star", ",", "min_x", ",", "max_x", ",", "min_y", ",", "max_y", ")", "\n", "\n", "if", "large_star", ".", "is_feasible", "(", ")", "is", "not", "None", ":", "\n", "                            ", "prev_s", "=", "self", ".", "copy", "(", "large_star", ")", "\n", "prev_s", ".", "alpha_prev_list", ".", "append", "(", "prev_cmd", ")", "\n", "rv", ".", "append", "(", "prev_s", ")", "\n", "", "", "", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.get_dx_dy_qrange": [[349, 379], ["numpy.zeros", "math.floor", "math.ceil", "numpy.zeros", "math.floor", "math.ceil", "backreach.State.star.minimize_vec", "backreach.State.star.minimize_vec", "backreach.State.star.minimize_vec", "backreach.State.star.minimize_vec"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.minimize_vec", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.minimize_vec", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.minimize_vec", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.minimize_vec"], ["", "@", "timed", "\n", "def", "get_dx_dy_qrange", "(", "self", ",", "stdout", "=", "False", ")", "->", "Tuple", "[", "Tuple", "[", "int", ",", "int", "]", ",", "Tuple", "[", "int", ",", "int", "]", "]", ":", "\n", "        ", "\"\"\"get the quantized range for (dx, dy)\"\"\"", "\n", "\n", "pos_quantum", "=", "Settings", ".", "pos_q", "\n", "vec", "=", "np", ".", "zeros", "(", "Star", ".", "NUM_VARS", ")", "\n", "\n", "# dx = x_int - x_own", "\n", "vec", "[", "Star", ".", "X_INT", "]", "=", "1", "\n", "vec", "[", "Star", ".", "X_OWN", "]", "=", "-", "1", "\n", "dx_min", "=", "self", ".", "star", ".", "minimize_vec", "(", "vec", ")", "@", "vec", "\n", "dx_max", "=", "self", ".", "star", ".", "minimize_vec", "(", "-", "vec", ")", "@", "vec", "\n", "\n", "qdx_min", "=", "floor", "(", "dx_min", "/", "pos_quantum", ")", "\n", "qdx_max", "=", "ceil", "(", "dx_max", "/", "pos_quantum", ")", "\n", "dx_qrange", "=", "(", "qdx_min", ",", "qdx_max", ")", "\n", "\n", "# dy = y_int - y_own", "\n", "vec", "=", "np", ".", "zeros", "(", "Star", ".", "NUM_VARS", ")", "\n", "#vec[Star.Y_INT] = 1 # Y_int is always 0", "\n", "vec", "[", "Star", ".", "Y_OWN", "]", "=", "-", "1", "\n", "\n", "dy_min", "=", "self", ".", "star", ".", "minimize_vec", "(", "vec", ")", "@", "vec", "\n", "dy_max", "=", "self", ".", "star", ".", "minimize_vec", "(", "-", "vec", ")", "@", "vec", "\n", "\n", "qdy_min", "=", "floor", "(", "dy_min", "/", "pos_quantum", ")", "\n", "qdy_max", "=", "ceil", "(", "dy_max", "/", "pos_quantum", ")", "\n", "dy_qrange", "=", "(", "qdy_min", ",", "qdy_max", ")", "\n", "\n", "return", "dx_qrange", ",", "dy_qrange", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.backreach_single": [[389, 400], ["backreach.backreach_single_unwrapped", "print", "traceback.print_exc"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.backreach_single_unwrapped"], ["", "def", "backreach_single", "(", "arg", ",", "parallel", "=", "True", ",", "plot", "=", "False", ")", "->", "Optional", "[", "BackreachResult", "]", ":", "\n", "    ", "\"\"\"run backreachability from a single symbolic state\"\"\"", "\n", "\n", "try", ":", "\n", "        ", "rv", "=", "backreach_single_unwrapped", "(", "arg", ",", "parallel", "=", "parallel", ",", "plot", "=", "plot", ")", "\n", "", "except", ":", "\n", "        ", "print", "(", "\"WARNING: Exception was raised!\"", ")", "\n", "traceback", ".", "print_exc", "(", ")", "\n", "rv", "=", "None", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.backreach_single_unwrapped": [[401, 504], ["time.perf_counter", "dubins.init_to_constraints", "star.Star", "backreach.State", "set", "time.perf_counter", "len", "parallel.increment_index", "set", "plotting.Plotter", "plotting.Plotter.plot_star", "work.pop", "work.pop.get_predecessors", "time.perf_counter", "parallel.worker_had_counterexample", "tuple", "max", "print", "work.append", "set.add", "time.perf_counter", "plotting.Plotter.plot_star", "set.add", "len", "tuple", "parallel.shared_num_timeouts.get_lock", "p.star.get_witness", "copy.deepcopy", "len", "len", "parallel.shared_num_counterexamples.get_lock", "print"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.dubins.init_to_constraints", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.increment_index", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.plotting.Plotter.plot_star", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.get_predecessors", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.worker_had_counterexample", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.plotting.Plotter.plot_star", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.star.Star.get_witness"], ["", "def", "backreach_single_unwrapped", "(", "arg", ",", "parallel", "=", "True", ",", "plot", "=", "False", ")", "->", "Optional", "[", "BackreachResult", "]", ":", "\n", "    ", "\"\"\"run backreachability from a single symbolic state\"\"\"", "\n", "\n", "if", "parallel", ":", "\n", "        ", "index", ",", "params", "=", "increment_index", "(", ")", "\n", "", "else", ":", "\n", "        ", "assert", "arg", "is", "not", "None", "\n", "index", "=", "0", "\n", "params", "=", "arg", "\n", "\n", "", "if", "index", "<", "0", ":", "# exceeded max counterexamples", "\n", "        ", "return", "None", "\n", "\n", "", "init_alpha_prev", ",", "x_own", ",", "y_own", ",", "theta1", ",", "v_own", ",", "v_int", "=", "params", "\n", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "\n", "box", ",", "a_mat", ",", "b_vec", "=", "init_to_constraints", "(", "x_own", ",", "y_own", ",", "v_own", ",", "v_int", ",", "theta1", ")", "\n", "\n", "init_star", "=", "Star", "(", "box", ",", "a_mat", ",", "b_vec", ")", "\n", "init_s", "=", "State", "(", "init_alpha_prev", ",", "theta1", ",", "v_own", ",", "v_int", ",", "init_star", ")", "\n", "\n", "work", "=", "[", "init_s", "]", "\n", "popped", "=", "0", "\n", "\n", "rv", ":", "BackreachResult", "=", "{", "'counterexample'", ":", "None", ",", "'runtime'", ":", "np", ".", "inf", ",", "'params'", ":", "params", ",", "\n", "'num_popped'", ":", "0", ",", "'unique_paths'", ":", "0", ",", "'index'", ":", "index", ",", "'timeout'", ":", "False", "}", "\n", "deadends", "=", "set", "(", ")", "\n", "unique_prefixes", "=", "None", "\n", "\n", "plotter", ":", "Optional", "[", "Plotter", "]", "=", "None", "\n", "\n", "if", "plot", ":", "\n", "        ", "unique_prefixes", "=", "set", "(", ")", "\n", "plotter", "=", "Plotter", "(", ")", "\n", "plotter", ".", "plot_star", "(", "init_s", ".", "star", ",", "'r'", ")", "\n", "\n", "", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "\n", "while", "work", "and", "rv", "[", "'counterexample'", "]", "is", "None", ":", "\n", "        ", "s", "=", "work", ".", "pop", "(", ")", "\n", "popped", "+=", "1", "\n", "\n", "if", "popped", "%", "100", "==", "0", "and", "Settings", ".", "max_counterexamples", "is", "not", "None", "and", "shared_num_counterexamples", ".", "value", ">", "Settings", ".", "max_counterexamples", ":", "\n", "            ", "return", "None", "\n", "\n", "", "if", "time", ".", "perf_counter", "(", ")", "-", "start", ">", "Settings", ".", "single_case_timeout", ":", "\n", "            ", "rv", "[", "'timeout'", "]", "=", "True", "\n", "\n", "if", "parallel", ":", "\n", "                ", "with", "shared_num_timeouts", ".", "get_lock", "(", ")", ":", "\n", "                    ", "shared_num_timeouts", ".", "value", "+=", "1", "\n", "\n", "", "", "break", "\n", "\n", "", "if", "plotter", "is", "not", "None", ":", "\n", "            ", "tup", "=", "tuple", "(", "s", ".", "alpha_prev_list", ")", "\n", "if", "not", "tup", "in", "unique_prefixes", ":", "\n", "                ", "plotter", ".", "plot_star", "(", "s", ".", "star", ",", "'k'", ")", "\n", "unique_prefixes", ".", "add", "(", "tup", ")", "\n", "\n", "", "", "if", "not", "parallel", "and", "popped", "%", "1000", "==", "0", ":", "\n", "            ", "lens", "=", "[", "len", "(", "w", ".", "alpha_prev_list", ")", "for", "w", "in", "work", "]", "\n", "max_len", "=", "max", "(", "lens", ")", "\n", "\n", "print", "(", "f\"popped {popped}, unique_paths: {len(deadends)}, remaining_work: {len(work)}, max_len: {max_len}\"", ")", "\n", "\n", "", "predecessors", "=", "s", ".", "get_predecessors", "(", ")", "\n", "\n", "for", "p", "in", "predecessors", ":", "\n", "            ", "work", ".", "append", "(", "p", ")", "\n", "\n", "if", "p", ".", "alpha_prev_list", "[", "-", "2", "]", "==", "0", "and", "p", ".", "alpha_prev_list", "[", "-", "1", "]", "==", "0", ":", "\n", "# also check if > 20000 ft", "\n", "                ", "pt", "=", "p", ".", "star", ".", "get_witness", "(", ")", "[", "1", "]", "\n", "\n", "dx", "=", "(", "pt", "[", "Star", ".", "X_INT", "]", "-", "pt", "[", "Star", ".", "X_OWN", "]", ")", "\n", "dy", "=", "(", "0", "-", "pt", "[", "Star", ".", "Y_OWN", "]", ")", "\n", "\n", "if", "dx", "**", "2", "+", "dy", "**", "2", ">", "Settings", ".", "counterexample_start_dist", "**", "2", ":", "\n", "                    ", "rv", "[", "'counterexample'", "]", "=", "deepcopy", "(", "p", ")", "\n", "\n", "if", "parallel", ":", "\n", "                        ", "with", "shared_num_counterexamples", ".", "get_lock", "(", ")", ":", "\n", "                            ", "shared_num_counterexamples", ".", "value", "+=", "1", "\n", "print", "(", "f\"\\nIndex {index} found counterexample. Count: {shared_num_counterexamples.value} \"", ",", "\n", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "\n", "", "", "break", "\n", "\n", "", "", "", "if", "not", "predecessors", ":", "\n", "            ", "deadends", ".", "add", "(", "tuple", "(", "s", ".", "alpha_prev_list", ")", ")", "\n", "\n", "", "", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "rv", "[", "'runtime'", "]", "=", "diff", "\n", "rv", "[", "'num_popped'", "]", "=", "popped", "\n", "rv", "[", "'unique_paths'", "]", "=", "len", "(", "deadends", ")", "\n", "\n", "if", "rv", "[", "'counterexample'", "]", "is", "not", "None", "and", "parallel", ":", "\n", "        ", "worker_had_counterexample", "(", "rv", ")", "\n", "\n", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.main": [[505, 521], ["settings.Settings.init_cmd_quantum_list", "parallel.run_all_parallel", "print", "parallel.run_all_parallel", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.settings.Settings.init_cmd_quantum_list", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.run_all_parallel", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.parallel.run_all_parallel"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"main entry point\"\"\"", "\n", "\n", "Settings", ".", "init_cmd_quantum_list", "(", ")", "\n", "\n", "# emacs hard-warp command: M+x fill-paragraph", "\n", "safe", "=", "run_all_parallel", "(", "backreach_single", ",", "0", ")", "\n", "\n", "if", "safe", ":", "\n", "        ", "print", "(", "\"completed proof for tau_dot=0 case\"", ")", "\n", "\n", "safe", "=", "run_all_parallel", "(", "backreach_single", ",", "-", "1", ")", "\n", "print", "(", "\"completed proof for tau_dot=-1 case\"", ")", "\n", "print", "(", "f\"final proven safe?: {safe}\"", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"not proven safe for for tau_dot = 0\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.analyze_seeds.main": [[9, 44], ["analyze_seeds.get_seeds", "zip", "numpy.array", "numpy.array", "print", "print", "print", "acasxu_dubins.make_random_input", "acasxu_dubins.State", "acasxu_dubins.State.simulate", "np.array.append", "np.array.append", "numpy.max", "np.array.mean", "np.array.std", "numpy.min", "np.array.mean", "np.array.std"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.analyze_seeds.get_seeds", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.make_random_input", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.simulate"], ["def", "main", "(", ")", ":", "\n", "    ", "\"\"\"main entry point\"\"\"", "\n", "\n", "out_of_plane_seeds", ",", "in_plane_seeds", "=", "get_seeds", "(", ")", "\n", "\n", "labels", "=", "[", "'in-plane'", ",", "'out-of-plane'", "]", "\n", "tau_dots", "=", "[", "0", ",", "-", "1", "]", "\n", "seeds", "=", "[", "in_plane_seeds", ",", "out_of_plane_seeds", "]", "\n", "\n", "for", "label", ",", "tau_dot", ",", "seed_list", "in", "zip", "(", "labels", ",", "tau_dots", ",", "seeds", ")", ":", "\n", "        ", "max_tau", "=", "0", "if", "tau_dot", "==", "0", "else", "160", "\n", "\n", "vowns", "=", "[", "]", "\n", "vints", "=", "[", "]", "\n", "\n", "for", "seed", "in", "seed_list", ":", "\n", "            ", "init_vec", ",", "cmd_list", ",", "init_velo", ",", "tau_init", "=", "make_random_input", "(", "seed", ",", "max_tau", "=", "max_tau", ",", "intruder_can_turn", "=", "False", ")", "\n", "\n", "s", "=", "State", "(", "init_vec", ",", "tau_init", ",", "tau_dot", ",", "init_velo", "[", "0", "]", ",", "init_velo", "[", "1", "]", ",", "save_states", "=", "False", ")", "\n", "s", ".", "simulate", "(", "cmd_list", ")", "\n", "\n", "assert", "s", ".", "min_dist", "<", "500", ",", "f\"seed was safe: {seed}\"", "\n", "\n", "# state vector is: x, y, theta, x2, y2, theta2, time", "\n", "vown", ",", "vint", "=", "init_velo", "\n", "\n", "vowns", ".", "append", "(", "vown", ")", "\n", "vints", ".", "append", "(", "vint", ")", "\n", "\n", "", "vowns", "=", "np", ".", "array", "(", "vowns", ")", "\n", "vints", "=", "np", ".", "array", "(", "vints", ")", "\n", "\n", "print", "(", "f\"{label}, max vown: {np.max(vowns)}. mean: {vowns.mean()}, std: {vowns.std()}\"", ")", "\n", "print", "(", "f\"{label}, min vint: {np.min(vints)}. mean: {vints.mean()}, std: {vints.std()}\"", ")", "\n", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.analyze_seeds.get_seeds": [[45, 307], ["None"], "function", ["None"], ["", "", "def", "get_seeds", "(", ")", ":", "\n", "    ", "\"\"\"returns unsafe seeds from 150 million sims (with tau_max=160)\"\"\"", "\n", "\n", "# these are seeds from 150 million sims", "\n", "out_of_plane_seeds", "=", "[", "41754697", ",", "47176395", ",", "58288275", ",", "68144431", ",", "80325476", ",", "104860362", ",", "139313670", "]", "\n", "\n", "in_plane_seeds", "=", "[", "57305", ",", "174596", ",", "191434", ",", "207659", ",", "341255", ",", "468582", ",", "872977", ",", "\n", "891092", ",", "1084018", ",", "1182535", ",", "1339442", ",", "1379646", ",", "1380106", ",", "1381252", ",", "1741977", ",", "\n", "1827016", ",", "1995659", ",", "2047216", ",", "2103256", ",", "2107268", ",", "2109254", ",", "2159985", ",", "2185034", ",", "\n", "2223820", ",", "2449438", ",", "2525697", ",", "2559738", ",", "2587920", ",", "2715712", ",", "2811517", ",", "2843377", ",", "\n", "2910699", ",", "3036565", ",", "3041261", ",", "3355501", ",", "3463446", ",", "3523631", ",", "3595159", ",", "3670986", ",", "\n", "3786972", ",", "4032115", ",", "4147086", ",", "4177080", ",", "4186235", ",", "4321800", ",", "4419657", ",", "4420931", ",", "\n", "4461333", ",", "4490092", ",", "4497346", ",", "4561462", ",", "4602454", ",", "4671104", ",", "4896564", ",", "5040731", ",", "\n", "5067217", ",", "5146108", ",", "5155116", ",", "5166910", ",", "5175578", ",", "5283532", ",", "5291816", ",", "5425371", ",", "\n", "5469674", ",", "5486036", ",", "5539388", ",", "5573482", ",", "5830725", ",", "5939157", ",", "6070328", ",", "6222038", ",", "\n", "6238406", ",", "6322234", ",", "6327315", ",", "6521258", ",", "6792506", ",", "6826797", ",", "7007548", ",", "7129490", ",", "\n", "7240761", ",", "7265293", ",", "7324958", ",", "7345622", ",", "7429172", ",", "7494757", ",", "7550231", ",", "7566846", ",", "\n", "7639246", ",", "7751903", ",", "7809831", ",", "7827052", ",", "7859160", ",", "7952273", ",", "8016128", ",", "8029069", ",", "\n", "8115854", ",", "8164652", ",", "8192713", ",", "8203803", ",", "8210068", ",", "8245012", ",", "8255207", ",", "8368571", ",", "\n", "8583365", ",", "8650189", ",", "8654644", ",", "8683500", ",", "8786598", ",", "8796358", ",", "8913670", ",", "8956330", ",", "\n", "8995219", ",", "8999051", ",", "9025994", ",", "9156102", ",", "9205944", ",", "9227796", ",", "9237358", ",", "9238926", ",", "\n", "9253590", ",", "9272330", ",", "9363089", ",", "9418202", ",", "9426299", ",", "9456938", ",", "9480589", ",", "9495967", ",", "\n", "9499473", ",", "9577626", ",", "9632032", ",", "9984283", ",", "10160748", ",", "10438088", ",", "10550851", ",", "10599580", ",", "\n", "10600075", ",", "10706314", ",", "10785397", ",", "10799136", ",", "10902918", ",", "10933530", ",", "10952364", ",", "\n", "10994423", ",", "11128277", ",", "11153378", ",", "11379693", ",", "11380965", ",", "11443145", ",", "11454806", ",", "\n", "11478434", ",", "11493545", ",", "11502525", ",", "11534281", ",", "11584328", ",", "11617699", ",", "11633521", ",", "\n", "11644317", ",", "11704871", ",", "11782791", ",", "11805570", ",", "11806450", ",", "11826564", ",", "12017145", ",", "\n", "12137104", ",", "12137812", ",", "12313463", ",", "12389044", ",", "12413173", ",", "12442400", ",", "12521846", ",", "\n", "12526718", ",", "12597606", ",", "12627611", ",", "12688171", ",", "12689871", ",", "12870792", ",", "12959700", ",", "\n", "13541712", ",", "13543310", ",", "13544417", ",", "13918229", ",", "14197876", ",", "14228068", ",", "14305464", ",", "\n", "14357733", ",", "14588537", ",", "14593607", ",", "14670580", ",", "15138084", ",", "15150930", ",", "15184253", ",", "\n", "15446638", ",", "15452029", ",", "15571214", ",", "15618171", ",", "15629793", ",", "15709215", ",", "15892824", ",", "\n", "15933625", ",", "15954594", ",", "16098525", ",", "16184726", ",", "16280122", ",", "16397136", ",", "16445796", ",", "\n", "16619660", ",", "16777276", ",", "16837048", ",", "16941605", ",", "16960305", ",", "17107777", ",", "17194406", ",", "\n", "17197845", ",", "17209862", ",", "17299576", ",", "17524466", ",", "17620991", ",", "17922368", ",", "17988587", ",", "\n", "18094358", ",", "18110162", ",", "18132295", ",", "18376809", ",", "18427191", ",", "18600762", ",", "18716243", ",", "\n", "18718452", ",", "19039653", ",", "19111604", ",", "19157644", ",", "19360891", ",", "19421160", ",", "19623417", ",", "\n", "19653357", ",", "19923013", ",", "20014898", ",", "20091694", ",", "20099909", ",", "20304510", ",", "20498321", ",", "\n", "20516057", ",", "20611946", ",", "20689448", ",", "20820431", ",", "20866647", ",", "20881285", ",", "20934591", ",", "\n", "20984588", ",", "21051188", ",", "21188837", ",", "21263038", ",", "21281513", ",", "21369621", ",", "21485044", ",", "\n", "21506271", ",", "21521774", ",", "21532455", ",", "21716775", ",", "21729876", ",", "21810593", ",", "21821483", ",", "\n", "21852657", ",", "21913621", ",", "21969084", ",", "21972626", ",", "21984769", ",", "22164597", ",", "22191078", ",", "\n", "22365803", ",", "22439657", ",", "22503350", ",", "22534807", ",", "22674113", ",", "22750835", ",", "22759440", ",", "\n", "22813069", ",", "22878715", ",", "22911031", ",", "22995252", ",", "23005060", ",", "23005437", ",", "23291223", ",", "\n", "23339769", ",", "23350611", ",", "23371326", ",", "23407790", ",", "23415802", ",", "23579469", ",", "23629053", ",", "\n", "23878744", ",", "23884523", ",", "23895549", ",", "23945050", ",", "23982747", ",", "23988849", ",", "24053998", ",", "\n", "24067626", ",", "24169970", ",", "24232617", ",", "24292203", ",", "24350022", ",", "24603342", ",", "24623496", ",", "\n", "24803705", ",", "25011798", ",", "25179370", ",", "25251837", ",", "25313446", ",", "25394413", ",", "25417792", ",", "\n", "25614391", ",", "25627014", ",", "25651071", ",", "25690288", ",", "25818971", ",", "25933595", ",", "25979669", ",", "\n", "26031949", ",", "26072818", ",", "26140837", ",", "26225059", ",", "26253928", ",", "26523036", ",", "26571939", ",", "\n", "26742418", ",", "26753272", ",", "26815875", ",", "26876392", ",", "26921765", ",", "27080451", ",", "27184548", ",", "\n", "27230460", ",", "27316575", ",", "27431848", ",", "27504251", ",", "27505291", ",", "27575142", ",", "27619588", ",", "\n", "27698266", ",", "27739256", ",", "27767293", ",", "27794545", ",", "28002663", ",", "28030910", ",", "28360451", ",", "\n", "28390771", ",", "28525269", ",", "28587263", ",", "28859715", ",", "28939185", ",", "28979347", ",", "29179584", ",", "\n", "29282510", ",", "29332275", ",", "29405963", ",", "29436634", ",", "29965563", ",", "30064254", ",", "30288035", ",", "\n", "30381223", ",", "30385391", ",", "30435796", ",", "30533219", ",", "30867438", ",", "30906788", ",", "30947020", ",", "\n", "31038668", ",", "31095759", ",", "31147297", ",", "31174288", ",", "31258520", ",", "31278549", ",", "31393964", ",", "\n", "31578598", ",", "31603596", ",", "31662542", ",", "31696857", ",", "31720930", ",", "31825664", ",", "32076158", ",", "\n", "32131318", ",", "32217456", ",", "32233025", ",", "32521609", ",", "32572973", ",", "32764345", ",", "32820112", ",", "\n", "32944478", ",", "32980589", ",", "33163090", ",", "33193949", ",", "33269168", ",", "33299123", ",", "33308171", ",", "\n", "33344510", ",", "33604541", ",", "33632478", ",", "33649628", ",", "33660702", ",", "33719732", ",", "33959595", ",", "\n", "33973546", ",", "34109375", ",", "34285553", ",", "34367713", ",", "34549527", ",", "34589575", ",", "34687004", ",", "\n", "34748329", ",", "34758336", ",", "34924286", ",", "34949394", ",", "35004134", ",", "35017646", ",", "35036915", ",", "\n", "35127062", ",", "35131399", ",", "35161770", ",", "35167593", ",", "35172681", ",", "35197797", ",", "35237000", ",", "\n", "35299160", ",", "35529145", ",", "35538815", ",", "35769266", ",", "35848576", ",", "35925059", ",", "35941552", ",", "\n", "35997243", ",", "36193940", ",", "36243317", ",", "36283349", ",", "36333283", ",", "36380513", ",", "36385707", ",", "\n", "36494385", ",", "36512043", ",", "36512241", ",", "36672330", ",", "36791412", ",", "36804262", ",", "36808119", ",", "\n", "36858166", ",", "36877947", ",", "36958646", ",", "36973811", ",", "37062528", ",", "37484059", ",", "37515705", ",", "\n", "37541171", ",", "37543369", ",", "37548601", ",", "37613192", ",", "37704099", ",", "37735413", ",", "37804962", ",", "\n", "37881226", ",", "37991349", ",", "38000449", ",", "38036126", ",", "38124310", ",", "38160862", ",", "38207822", ",", "\n", "38303215", ",", "38396756", ",", "38426996", ",", "38444456", ",", "38451136", ",", "38555044", ",", "38665901", ",", "\n", "38839283", ",", "38981835", ",", "39103806", ",", "39164215", ",", "39312556", ",", "39400159", ",", "39401620", ",", "\n", "39401897", ",", "39648656", ",", "39663276", ",", "39673130", ",", "39715244", ",", "39722455", ",", "39936978", ",", "\n", "39938952", ",", "40024737", ",", "40213620", ",", "40391321", ",", "40462469", ",", "40588112", ",", "40651008", ",", "\n", "40734264", ",", "40748229", ",", "40863251", ",", "40867805", ",", "40912160", ",", "40913467", ",", "40960468", ",", "\n", "40968118", ",", "41147498", ",", "41255388", ",", "41515728", ",", "41625431", ",", "41713154", ",", "41758664", ",", "\n", "41833783", ",", "42178325", ",", "42240300", ",", "42315961", ",", "42362982", ",", "42438047", ",", "42506352", ",", "\n", "42575502", ",", "42647703", ",", "42805198", ",", "42898167", ",", "42937204", ",", "43010657", ",", "43076256", ",", "\n", "43108441", ",", "43201256", ",", "43362222", ",", "43429709", ",", "43504786", ",", "43614429", ",", "43716270", ",", "\n", "43890182", ",", "44069606", ",", "44089634", ",", "44302004", ",", "44336375", ",", "44470897", ",", "44545914", ",", "\n", "44553411", ",", "44582308", ",", "44619800", ",", "44654625", ",", "44818680", ",", "44826918", ",", "44834596", ",", "\n", "44973450", ",", "45096766", ",", "45234913", ",", "45251714", ",", "45337309", ",", "45342513", ",", "45396633", ",", "\n", "45453973", ",", "45488067", ",", "45631167", ",", "45926823", ",", "45985891", ",", "46283214", ",", "46290585", ",", "\n", "46422065", ",", "46468260", ",", "46489490", ",", "46512768", ",", "46531698", ",", "46533345", ",", "46544060", ",", "\n", "46669364", ",", "46896806", ",", "46975087", ",", "47009583", ",", "47117088", ",", "47148420", ",", "47314237", ",", "\n", "47317309", ",", "47451505", ",", "47584217", ",", "47624798", ",", "47628017", ",", "47718098", ",", "47729480", ",", "\n", "47782909", ",", "47798731", ",", "47865723", ",", "47866588", ",", "47930735", ",", "47969544", ",", "47976276", ",", "\n", "48056613", ",", "48148596", ",", "48194994", ",", "48309587", ",", "48355511", ",", "48445798", ",", "48520369", ",", "\n", "48550943", ",", "48670650", ",", "48881288", ",", "49184486", ",", "49220143", ",", "49236834", ",", "49393314", ",", "\n", "49480472", ",", "49719011", ",", "49825375", ",", "49871668", ",", "49872396", ",", "49873182", ",", "49953060", ",", "\n", "50034471", ",", "50218517", ",", "50261121", ",", "50303565", ",", "50313988", ",", "50400674", ",", "50432009", ",", "\n", "50476503", ",", "50484321", ",", "50570843", ",", "50614637", ",", "50624325", ",", "50724286", ",", "50776194", ",", "\n", "50854771", ",", "51073770", ",", "51375773", ",", "51408702", ",", "51441489", ",", "51449191", ",", "51527390", ",", "\n", "51587797", ",", "51610973", ",", "51672847", ",", "51675111", ",", "51739014", ",", "51745517", ",", "51779913", ",", "\n", "51807553", ",", "51854902", ",", "51943539", ",", "51946736", ",", "51982486", ",", "52130435", ",", "52139858", ",", "\n", "52164655", ",", "52642871", ",", "52894965", ",", "52999594", ",", "53014304", ",", "53144079", ",", "53238958", ",", "\n", "53248310", ",", "53301660", ",", "53433755", ",", "53435348", ",", "53438782", ",", "53507908", ",", "53511190", ",", "\n", "53581433", ",", "53655818", ",", "53915585", ",", "54053893", ",", "54134971", ",", "54261796", ",", "54300202", ",", "\n", "54454999", ",", "54595254", ",", "54717670", ",", "54874654", ",", "54984957", ",", "55026510", ",", "55083503", ",", "\n", "55104956", ",", "55164482", ",", "55283471", ",", "55388079", ",", "55480977", ",", "55655985", ",", "55660179", ",", "\n", "55846126", ",", "55965207", ",", "56001855", ",", "56046039", ",", "56049574", ",", "56075478", ",", "56101386", ",", "\n", "56234260", ",", "56289199", ",", "56496036", ",", "56601464", ",", "56717585", ",", "56991738", ",", "57200301", ",", "\n", "57261962", ",", "57439718", ",", "57440818", ",", "57595084", ",", "57675935", ",", "57723988", ",", "57798437", ",", "\n", "57855192", ",", "57865868", ",", "57933549", ",", "58102078", ",", "58227294", ",", "58253602", ",", "58307231", ",", "\n", "58649337", ",", "58658290", ",", "58681380", ",", "58806572", ",", "58921345", ",", "59153359", ",", "59229634", ",", "\n", "59310107", ",", "59535293", ",", "59580761", ",", "59680189", ",", "59723240", ",", "59794313", ",", "59840586", ",", "\n", "59840643", ",", "59862378", ",", "59906561", ",", "59942580", ",", "60229856", ",", "60269521", ",", "60345153", ",", "\n", "60440633", ",", "60458596", ",", "60486548", ",", "60627474", ",", "60819996", ",", "60912618", ",", "61128999", ",", "\n", "61180190", ",", "61213724", ",", "61245259", ",", "61268260", ",", "61536473", ",", "61572665", ",", "61924511", ",", "\n", "62084216", ",", "62148660", ",", "62348289", ",", "62366785", ",", "62405801", ",", "62462939", ",", "62570428", ",", "\n", "62574336", ",", "62608659", ",", "62671170", ",", "62891396", ",", "63223715", ",", "63377452", ",", "63451652", ",", "\n", "63486314", ",", "63624450", ",", "63735304", ",", "63802686", ",", "63837453", ",", "63844746", ",", "63900912", ",", "\n", "63961229", ",", "64027111", ",", "64119914", ",", "64193389", ",", "64232475", ",", "64284829", ",", "64440734", ",", "\n", "64548881", ",", "64588902", ",", "64643148", ",", "64660113", ",", "64677626", ",", "64737108", ",", "64874941", ",", "\n", "64919359", ",", "65108551", ",", "65121318", ",", "65124082", ",", "65181597", ",", "65461998", ",", "65621446", ",", "\n", "65768576", ",", "65801444", ",", "65852613", ",", "65935231", ",", "66017427", ",", "66333115", ",", "66356970", ",", "\n", "66395893", ",", "66411061", ",", "66474866", ",", "66550494", ",", "66615810", ",", "66630489", ",", "66816034", ",", "\n", "66893115", ",", "67003460", ",", "67009956", ",", "67102447", ",", "67104894", ",", "67129531", ",", "67173710", ",", "\n", "67199488", ",", "67454875", ",", "67497100", ",", "67535072", ",", "67594887", ",", "67613805", ",", "67741593", ",", "\n", "67860452", ",", "67907625", ",", "67996566", ",", "68004469", ",", "68056967", ",", "68252019", ",", "68494294", ",", "\n", "68508060", ",", "68517530", ",", "68572048", ",", "68655936", ",", "68791878", ",", "69060723", ",", "69261616", ",", "\n", "69309622", ",", "69400099", ",", "69416631", ",", "69466851", ",", "69543794", ",", "69554580", ",", "69567424", ",", "\n", "69625303", ",", "69701933", ",", "69931652", ",", "69998532", ",", "70016018", ",", "70035036", ",", "70038435", ",", "\n", "70186721", ",", "70236424", ",", "70365965", ",", "70417656", ",", "70452887", ",", "70506862", ",", "70689560", ",", "\n", "70720678", ",", "70766480", ",", "70853780", ",", "70862920", ",", "70986927", ",", "70992243", ",", "71000644", ",", "\n", "71039055", ",", "71162086", ",", "71195713", ",", "71227328", ",", "71478313", ",", "71575408", ",", "71601104", ",", "\n", "71605693", ",", "71862510", ",", "71920745", ",", "71948870", ",", "72237264", ",", "72246423", ",", "72259142", ",", "\n", "72329892", ",", "72379255", ",", "72450742", ",", "72740080", ",", "72782297", ",", "72805662", ",", "72939098", ",", "\n", "72969137", ",", "73032041", ",", "73032956", ",", "73234183", ",", "73236680", ",", "73325294", ",", "73435610", ",", "\n", "73493771", ",", "73687447", ",", "73729363", ",", "73876765", ",", "73936311", ",", "73968877", ",", "74132641", ",", "\n", "74193452", ",", "74649065", ",", "74674840", ",", "74779763", ",", "74807719", ",", "75295621", ",", "75513371", ",", "\n", "75687975", ",", "75815462", ",", "75884190", ",", "75901746", ",", "75962156", ",", "76040555", ",", "76186945", ",", "\n", "76495189", ",", "76668854", ",", "76821675", ",", "76904923", ",", "76957375", ",", "77028407", ",", "77078174", ",", "\n", "77141859", ",", "77147657", ",", "77181787", ",", "77254538", ",", "77295219", ",", "77460239", ",", "77466276", ",", "\n", "77584938", ",", "77917743", ",", "78021164", ",", "78141509", ",", "78173031", ",", "78337079", ",", "78370048", ",", "\n", "78399159", ",", "78464546", ",", "78561776", ",", "78622836", ",", "78671792", ",", "78682462", ",", "78709037", ",", "\n", "78843274", ",", "78893507", ",", "79024079", ",", "79024400", ",", "79033762", ",", "79037292", ",", "79119781", ",", "\n", "79264014", ",", "79346748", ",", "79372506", ",", "79373733", ",", "79562528", ",", "79580349", ",", "79653733", ",", "\n", "79709505", ",", "79731265", ",", "79779043", ",", "79788276", ",", "79845164", ",", "79897243", ",", "79914395", ",", "\n", "79982289", ",", "79995196", ",", "80001306", ",", "80180324", ",", "80257659", ",", "80354302", ",", "80432044", ",", "\n", "80632510", ",", "80706138", ",", "80817580", ",", "80979233", ",", "81028351", ",", "81177526", ",", "81259108", ",", "\n", "81314274", ",", "81451269", ",", "81541044", ",", "81579124", ",", "81772303", ",", "82009084", ",", "82221748", ",", "\n", "82387392", ",", "82388450", ",", "82470106", ",", "82473701", ",", "82498123", ",", "82609274", ",", "82701390", ",", "\n", "82711699", ",", "83130920", ",", "83289571", ",", "83292268", ",", "83326254", ",", "83341792", ",", "83461677", ",", "\n", "83524370", ",", "83679333", ",", "83695552", ",", "83797566", ",", "83802203", ",", "83832657", ",", "83860577", ",", "\n", "83955389", ",", "83964079", ",", "84060679", ",", "84192277", ",", "84249703", ",", "84359443", ",", "84391696", ",", "\n", "84411109", ",", "84518731", ",", "84540218", ",", "84567065", ",", "84612500", ",", "84693782", ",", "84944570", ",", "\n", "84954496", ",", "84994979", ",", "85043147", ",", "85148740", ",", "85497374", ",", "85505949", ",", "85508677", ",", "\n", "85572565", ",", "85626119", ",", "85632495", ",", "85694945", ",", "85759431", ",", "85806286", ",", "85859780", ",", "\n", "85868057", ",", "86029098", ",", "86060782", ",", "86076658", ",", "86085656", ",", "86130079", ",", "86146309", ",", "\n", "86158355", ",", "86255317", ",", "86286989", ",", "86327416", ",", "86339186", ",", "86360431", ",", "86409385", ",", "\n", "86419826", ",", "86453292", ",", "86475098", ",", "86514855", ",", "86724895", ",", "86772993", ",", "86801935", ",", "\n", "86807897", ",", "86876151", ",", "87269724", ",", "87391513", ",", "87491591", ",", "87493410", ",", "87503655", ",", "\n", "87596919", ",", "87647676", ",", "87666522", ",", "87886647", ",", "87893473", ",", "88100099", ",", "88131577", ",", "\n", "88168426", ",", "88226153", ",", "88367842", ",", "88476883", ",", "88494783", ",", "88505947", ",", "88677675", ",", "\n", "88716797", ",", "89033418", ",", "89140651", ",", "89184060", ",", "89210505", ",", "89469941", ",", "89497589", ",", "\n", "89502515", ",", "89673009", ",", "89738932", ",", "89846741", ",", "89896265", ",", "90157147", ",", "90164792", ",", "\n", "90171639", ",", "90176964", ",", "90334574", ",", "90438555", ",", "90512557", ",", "90592475", ",", "90666049", ",", "\n", "90879079", ",", "90933647", ",", "90933859", ",", "90934490", ",", "90962208", ",", "91019767", ",", "91134440", ",", "\n", "91195379", ",", "91293844", ",", "91322406", ",", "91644515", ",", "91781129", ",", "91805270", ",", "91836724", ",", "\n", "91955779", ",", "92082895", ",", "92152213", ",", "92295200", ",", "92465395", ",", "92567403", ",", "92656389", ",", "\n", "92846081", ",", "92949638", ",", "92979996", ",", "92996749", ",", "93032228", ",", "93044925", ",", "93055364", ",", "\n", "93141811", ",", "93401489", ",", "93455431", ",", "93455904", ",", "93530264", ",", "93639699", ",", "93685231", ",", "\n", "93731320", ",", "93944208", ",", "94218306", ",", "94458913", ",", "94552011", ",", "94562722", ",", "94766642", ",", "\n", "94775550", ",", "94780612", ",", "94907718", ",", "94915343", ",", "94920420", ",", "94973703", ",", "94984322", ",", "\n", "94988483", ",", "94999846", ",", "95290826", ",", "95406454", ",", "95494057", ",", "95588853", ",", "95686008", ",", "\n", "95690702", ",", "95778599", ",", "95836859", ",", "95982470", ",", "96024974", ",", "96045393", ",", "96469040", ",", "\n", "96563023", ",", "96629034", ",", "96702380", ",", "97024295", ",", "97126701", ",", "97151412", ",", "97173499", ",", "\n", "97207345", ",", "97228800", ",", "97234505", ",", "97285821", ",", "97338586", ",", "97652284", ",", "97772108", ",", "\n", "97812387", ",", "97887860", ",", "97972167", ",", "98010084", ",", "98032893", ",", "98061101", ",", "98089192", ",", "\n", "98224563", ",", "98259623", ",", "98280196", ",", "98478863", ",", "98660519", ",", "98714969", ",", "98751071", ",", "\n", "98826755", ",", "98867487", ",", "98871125", ",", "98871173", ",", "98932066", ",", "99011086", ",", "99064106", ",", "\n", "99160987", ",", "99307962", ",", "99342892", ",", "99369640", ",", "99559874", ",", "99626501", ",", "99666720", ",", "\n", "99748794", ",", "99804268", ",", "99928952", ",", "99952697", ",", "99978102", ",", "99988600", ",", "100037060", ",", "\n", "100062425", ",", "100101702", ",", "100131569", ",", "100175438", ",", "100213999", ",", "100445944", ",", "\n", "100479227", ",", "100493613", ",", "100605505", ",", "100656371", ",", "100912788", ",", "101122541", ",", "\n", "101140305", ",", "101175597", ",", "101242275", ",", "101367571", ",", "101417138", ",", "101539099", ",", "\n", "101598606", ",", "101667104", ",", "101681987", ",", "101741869", ",", "102079580", ",", "102244200", ",", "\n", "102275498", ",", "102344891", ",", "102417277", ",", "102429055", ",", "102446582", ",", "102479237", ",", "\n", "102509316", ",", "102560631", ",", "102590061", ",", "102658927", ",", "102728452", ",", "102769145", ",", "\n", "102792291", ",", "102930442", ",", "103015182", ",", "103119979", ",", "103121538", ",", "103424298", ",", "\n", "103483252", ",", "103483749", ",", "103498091", ",", "103523060", ",", "103763518", ",", "103795998", ",", "\n", "103884141", ",", "103885148", ",", "103956546", ",", "103986773", ",", "104038993", ",", "104148562", ",", "\n", "104361456", ",", "104627541", ",", "104646634", ",", "104862918", ",", "104880878", ",", "105040965", ",", "\n", "105354927", ",", "105364747", ",", "105441890", ",", "105481098", ",", "105553977", ",", "105743878", ",", "\n", "105748735", ",", "105827702", ",", "105905612", ",", "105936813", ",", "106001579", ",", "106080032", ",", "\n", "106380770", ",", "106435883", ",", "106679478", ",", "106679705", ",", "106751064", ",", "106785949", ",", "\n", "106890022", ",", "106992093", ",", "107015274", ",", "107230296", ",", "107345690", ",", "107421596", ",", "\n", "107544997", ",", "107625042", ",", "107707793", ",", "107902734", ",", "107998530", ",", "108044142", ",", "\n", "108226596", ",", "108249529", ",", "108289716", ",", "108364761", ",", "108380556", ",", "108420310", ",", "\n", "108443767", ",", "108522870", ",", "108554571", ",", "108649577", ",", "108699476", ",", "108864644", ",", "\n", "108970407", ",", "109011173", ",", "109396042", ",", "109674735", ",", "109698079", ",", "109725413", ",", "\n", "109745017", ",", "109887404", ",", "109891903", ",", "109935203", ",", "110256699", ",", "110282629", ",", "\n", "110288999", ",", "110359110", ",", "110399291", ",", "110407226", ",", "110482019", ",", "110569572", ",", "\n", "110626713", ",", "110768750", ",", "110965970", ",", "111031395", ",", "111044913", ",", "111082813", ",", "\n", "111144447", ",", "111398582", ",", "111477601", ",", "111523555", ",", "111535364", ",", "111545536", ",", "\n", "111651390", ",", "111838027", ",", "112059842", ",", "112085977", ",", "112360214", ",", "112384047", ",", "\n", "112481786", ",", "112528015", ",", "112615928", ",", "112693214", ",", "112858737", ",", "112918724", ",", "\n", "112985541", ",", "113093348", ",", "113187336", ",", "113244039", ",", "113317045", ",", "113429155", ",", "\n", "113435423", ",", "113484498", ",", "113490593", ",", "113503703", ",", "114096816", ",", "114312440", ",", "\n", "114594720", ",", "114725721", ",", "114779943", ",", "114866343", ",", "114952782", ",", "115060906", ",", "\n", "115139149", ",", "115230816", ",", "115342862", ",", "115541294", ",", "115580786", ",", "115843819", ",", "\n", "115881080", ",", "116097297", ",", "116258213", ",", "116305565", ",", "116400651", ",", "116408926", ",", "\n", "116481248", ",", "116495258", ",", "116513348", ",", "116568625", ",", "116672983", ",", "116729780", ",", "\n", "116952395", ",", "117042081", ",", "117683417", ",", "117747797", ",", "117751365", ",", "118038841", ",", "\n", "118196393", ",", "118262755", ",", "118320164", ",", "118461017", ",", "118656590", ",", "118711826", ",", "\n", "118842660", ",", "118869545", ",", "118915439", ",", "119012779", ",", "119248753", ",", "119459639", ",", "\n", "119577903", ",", "119591443", ",", "119595864", ",", "119630541", ",", "119778278", ",", "119826170", ",", "\n", "119826562", ",", "119850513", ",", "119853613", ",", "120007036", ",", "120013615", ",", "120064955", ",", "\n", "120086520", ",", "120118067", ",", "120179809", ",", "120180357", ",", "120220782", ",", "120284668", ",", "\n", "120312904", ",", "120358667", ",", "120693605", ",", "120741917", ",", "120850368", ",", "121034938", ",", "\n", "121088654", ",", "121090070", ",", "121264470", ",", "121278942", ",", "121495813", ",", "121497025", ",", "\n", "121556318", ",", "121638859", ",", "121669519", ",", "121890086", ",", "122025334", ",", "122113325", ",", "\n", "122203177", ",", "122381516", ",", "122514329", ",", "122558807", ",", "122596443", ",", "122647024", ",", "\n", "122830114", ",", "122833918", ",", "122856311", ",", "122861104", ",", "122962804", ",", "123178325", ",", "\n", "123305080", ",", "123321224", ",", "123361777", ",", "123383926", ",", "123434884", ",", "123442988", ",", "\n", "123686621", ",", "123782332", ",", "123941237", ",", "124068245", ",", "124334052", ",", "124383903", ",", "\n", "124434706", ",", "124528144", ",", "124568010", ",", "124574374", ",", "124707967", ",", "124882840", ",", "\n", "124889756", ",", "125051053", ",", "125063913", ",", "125177057", ",", "125395955", ",", "125584609", ",", "\n", "125600125", ",", "125749462", ",", "125856883", ",", "125867373", ",", "125879844", ",", "125887875", ",", "\n", "125987948", ",", "125989794", ",", "126182840", ",", "126300041", ",", "126424313", ",", "126555133", ",", "\n", "126677400", ",", "126744222", ",", "126767142", ",", "126928756", ",", "127014281", ",", "127118582", ",", "\n", "127319158", ",", "127409765", ",", "127713441", ",", "127824829", ",", "127953515", ",", "127959412", ",", "\n", "127959881", ",", "128033993", ",", "128246154", ",", "128253323", ",", "128303027", ",", "128304411", ",", "\n", "128341589", ",", "128539427", ",", "128802335", ",", "128820640", ",", "129106905", ",", "129361688", ",", "\n", "129369491", ",", "129420203", ",", "129513864", ",", "129533225", ",", "129547045", ",", "129695237", ",", "\n", "129735315", ",", "129743961", ",", "129833057", ",", "129840916", ",", "130024757", ",", "130128905", ",", "\n", "130140047", ",", "130184395", ",", "130190704", ",", "130521367", ",", "130554401", ",", "130635158", ",", "\n", "130770000", ",", "130813230", ",", "130921528", ",", "131076664", ",", "131496786", ",", "131701305", ",", "\n", "131838555", ",", "131877493", ",", "131890158", ",", "131987015", ",", "132011478", ",", "132090509", ",", "\n", "132090936", ",", "132354247", ",", "132401530", ",", "132918629", ",", "133285996", ",", "133327889", ",", "\n", "133403397", ",", "133423846", ",", "133457912", ",", "133547600", ",", "133564897", ",", "133658960", ",", "\n", "133716758", ",", "133771551", ",", "133873272", ",", "133989804", ",", "134092084", ",", "134110743", ",", "\n", "134139210", ",", "134303046", ",", "134469283", ",", "134728285", ",", "135132094", ",", "135279058", ",", "\n", "135439030", ",", "135439629", ",", "135454412", ",", "135647392", ",", "135659824", ",", "135670467", ",", "\n", "135712627", ",", "135750167", ",", "135916631", ",", "135940965", ",", "136036747", ",", "136174132", ",", "\n", "136320560", ",", "136406592", ",", "136590785", ",", "136662703", ",", "136663886", ",", "136668595", ",", "\n", "136775688", ",", "136849913", ",", "137306921", ",", "137383103", ",", "137453338", ",", "137478870", ",", "\n", "137563404", ",", "137643498", ",", "137775322", ",", "137817985", ",", "137818114", ",", "137863413", ",", "\n", "137909474", ",", "137950647", ",", "138021796", ",", "138055549", ",", "138160776", ",", "138263168", ",", "\n", "138364411", ",", "138435822", ",", "138512025", ",", "138753311", ",", "138762582", ",", "138912223", ",", "\n", "138968900", ",", "138979942", ",", "138988607", ",", "139221919", ",", "139440675", ",", "139464372", ",", "\n", "139535937", ",", "139616220", ",", "139779056", ",", "139889769", ",", "139894678", ",", "140289988", ",", "\n", "140451519", ",", "140465888", ",", "140618611", ",", "140710789", ",", "140981941", ",", "141016578", ",", "\n", "141045162", ",", "141120885", ",", "141187988", ",", "141285418", ",", "141288223", ",", "141334870", ",", "\n", "141844338", ",", "141956899", ",", "142162942", ",", "142165619", ",", "142233618", ",", "142335873", ",", "\n", "142364481", ",", "142415892", ",", "142429124", ",", "142479835", ",", "142654140", ",", "142889659", ",", "\n", "142912519", ",", "142921063", ",", "142981475", ",", "142993177", ",", "143026970", ",", "143029766", ",", "\n", "143043730", ",", "143108982", ",", "143171361", ",", "143271759", ",", "143486016", ",", "143507365", ",", "\n", "143567735", ",", "143894771", ",", "144346011", ",", "144728831", ",", "144744667", ",", "144748513", ",", "\n", "144821847", ",", "145018054", ",", "145073475", ",", "145172305", ",", "145373519", ",", "145597434", ",", "\n", "145631542", ",", "145677029", ",", "145843026", ",", "145909842", ",", "145991322", ",", "146167501", ",", "\n", "146195810", ",", "146403727", ",", "146504979", ",", "146534756", ",", "146554687", ",", "146646592", ",", "\n", "146737825", ",", "146796280", ",", "147249466", ",", "147344622", ",", "147397408", ",", "147584101", ",", "\n", "147708669", ",", "147716849", ",", "147804614", ",", "147828040", ",", "147842945", ",", "148037041", ",", "\n", "148053155", ",", "148122885", ",", "148139433", ",", "148159022", ",", "148259840", ",", "148295990", ",", "\n", "148517648", ",", "148534033", ",", "148586930", ",", "148654682", ",", "148751365", ",", "148857371", ",", "\n", "149049143", ",", "149075754", ",", "149144495", ",", "149225265", ",", "149248210", ",", "149286736", ",", "\n", "149345455", ",", "149439570", ",", "149470208", ",", "149524766", ",", "149527086", ",", "149587523", ",", "\n", "149613402", ",", "149784526", ",", "149787166", ",", "149878509", ",", "149902563", "]", "\n", "\n", "return", "out_of_plane_seeds", ",", "in_plane_seeds", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.parallel_acasxu_dubins.sim_single": [[17, 38], ["acasxu_dubins.make_random_input", "acasxu_dubins.State", "acasxu_dubins.State.simulate", "print", "print"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.make_random_input", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.simulate"], ["def", "sim_single", "(", "seed", ",", "intruder_can_turn", ",", "max_tau", ")", ":", "\n", "    ", "\"\"\"run single simulation and return min_dist\"\"\"", "\n", "\n", "rv", "=", "np", ".", "inf", "\n", "\n", "if", "seed", "%", "50000", "==", "0", ":", "\n", "        ", "print", "(", "f\"{(seed//50000) % 10}\"", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "", "elif", "seed", "%", "5000", "==", "0", ":", "\n", "        ", "print", "(", "\".\"", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "\n", "", "tau_dot", "=", "-", "1", "if", "max_tau", ">", "0", "else", "0", "\n", "\n", "init_vec", ",", "cmd_list", ",", "init_velo", ",", "tau_init", "=", "make_random_input", "(", "seed", ",", "max_tau", "=", "max_tau", ",", "intruder_can_turn", "=", "intruder_can_turn", ")", "\n", "\n", "# run the simulation", "\n", "s", "=", "State", "(", "init_vec", ",", "tau_init", ",", "tau_dot", ",", "init_velo", "[", "0", "]", ",", "init_velo", "[", "1", "]", ",", "save_states", "=", "False", ")", "\n", "s", ".", "simulate", "(", "cmd_list", ")", "\n", "\n", "rv", "=", "s", ".", "min_dist", "\n", "\n", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.parallel_acasxu_dubins.main": [[39, 146], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "time.perf_counter", "print", "round", "print", "print", "print", "round", "print", "multiprocessing.Pool", "time.perf_counter", "acasxu_dubins.make_random_input", "acasxu_dubins.State", "acasxu_dubins.State.simulate", "acasxu_dubins.plot", "min", "range", "pool.starmap", "print", "enumerate", "round", "round", "print", "len", "print", "print", "print", "abs", "params.append", "time.perf_counter", "round", "len", "round", "collision_seeds.append", "acasxu_dubins.make_random_input", "acasxu_dubins.State", "print", "round", "round", "round"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.make_random_input", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.simulate", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.make_random_input"], ["", "def", "main", "(", ")", ":", "\n", "    ", "'main entry point'", "\n", "\n", "# dt = 0.05", "\n", "#Did 1000000 parallel sims in 794.3 secs (0.794ms per sim)", "\n", "#Rejected 58480 sims. 5.848%", "\n", "#Collision in 3 sims. 0.0003%", "\n", "#Seed 350121 has min_dist 325.4ft", "\n", "\n", "# parse arguments", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Run ACASXU Dublins model simulator.'", ")", "\n", "parser", ".", "add_argument", "(", "\"--save-mp4\"", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "\"Save plotted mp4 files to disk.\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "save_mp4", "=", "args", ".", "save_mp4", "\n", "intruder_can_turn", "=", "False", "\n", "max_tau", "=", "0", "# 160 or 0", "\n", "tau_dot", "=", "-", "1", "if", "max_tau", ">", "0", "else", "0", "\n", "\n", "# home laptop (dt=0.05): 10000000 parallel sims take 5714.9 secs (0.571ms per sim)", "\n", "batch_size", "=", "1500000", "\n", "num_sims", "=", "batch_size", "*", "1", "# use \"* 100\" instead for 150 million", "\n", "\n", "remaining_sims", "=", "num_sims", "\n", "completed_sims", "=", "0", "\n", "\n", "collision_dist", "=", "500", "\n", "min_dist", "=", "np", ".", "inf", "\n", "min_seed", "=", "-", "1", "\n", "num_collisions", "=", "0", "\n", "collision_seeds", "=", "[", "]", "\n", "num_with_dist", "=", "0", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "\n", "print", "(", "f\"Running {num_sims} parallel simulations in batches of {batch_size}...\"", ")", "\n", "\n", "with", "multiprocessing", ".", "Pool", "(", ")", "as", "pool", ":", "\n", "        ", "while", "remaining_sims", ">", "0", ":", "\n", "            ", "cur_batch", "=", "min", "(", "batch_size", ",", "remaining_sims", ")", "\n", "params", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "cur_batch", ")", ":", "\n", "                ", "p", "=", "(", "completed_sims", "+", "i", ",", "intruder_can_turn", ",", "max_tau", ")", "\n", "params", ".", "append", "(", "p", ")", "\n", "\n", "", "results", "=", "pool", ".", "starmap", "(", "sim_single", ",", "params", ",", "chunksize", "=", "200", ")", "\n", "print", "(", ")", "\n", "\n", "for", "index", ",", "dist", "in", "enumerate", "(", "results", ")", ":", "\n", "                ", "seed", "=", "completed_sims", "+", "index", "\n", "\n", "if", "dist", "!=", "np", ".", "inf", ":", "\n", "                    ", "num_with_dist", "+=", "1", "\n", "\n", "", "if", "dist", "<", "min_dist", ":", "\n", "                    ", "min_dist", "=", "dist", "\n", "min_seed", "=", "seed", "\n", "\n", "", "if", "dist", "<", "collision_dist", ":", "\n", "                    ", "num_collisions", "+=", "1", "\n", "collision_seeds", ".", "append", "(", "seed", ")", "\n", "\n", "init_vec", ",", "cmd_list", ",", "init_velo", ",", "tau_init", "=", "make_random_input", "(", "seed", ",", "max_tau", "=", "max_tau", ",", "intruder_can_turn", "=", "intruder_can_turn", ")", "\n", "s", "=", "State", "(", "init_vec", ",", "tau_init", ",", "tau_dot", ",", "init_velo", "[", "0", "]", ",", "init_velo", "[", "1", "]", ")", "\n", "\n", "print", "(", "f\"{num_collisions}. Collision (dist={round(dist, 2)}) with seed {seed}: {s}\"", ")", "\n", "\n", "# print progress", "\n", "", "", "completed_sims", "+=", "cur_batch", "\n", "remaining_sims", "-=", "cur_batch", "\n", "\n", "frac", "=", "completed_sims", "/", "num_sims", "\n", "elapsed", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "total_estimate", "=", "(", "elapsed", "/", "frac", ")", "\n", "total_min", "=", "round", "(", "total_estimate", "/", "60", ",", "1", ")", "\n", "eta_estimate", "=", "total_estimate", "-", "elapsed", "\n", "eta_min", "=", "round", "(", "eta_estimate", "/", "60", ",", "1", ")", "\n", "\n", "print", "(", "f\"Collision seeds: {collision_seeds}\"", ")", "\n", "num_collisions", "=", "len", "(", "collision_seeds", ")", "\n", "print", "(", "f\"Collision in {num_collisions} sims. {round(100 * num_collisions / completed_sims, 8)}%\"", ")", "\n", "\n", "percent", "=", "100", "*", "num_with_dist", "/", "completed_sims", "\n", "print", "(", "f\"num with dist: {num_with_dist} / {completed_sims}: {percent:.4f}%\"", ")", "\n", "\n", "percent", "=", "100", "*", "completed_sims", "/", "num_sims", "\n", "print", "(", "f\"{completed_sims}/{num_sims} ({percent:.4f}%) total estimate: {total_min}min, ETA: {eta_min} min, \"", "+", "f\"col: {num_collisions} ({round(100 * num_collisions / completed_sims, 6)}%)\"", ")", "\n", "\n", "", "", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "ms_per_sim", "=", "round", "(", "1000", "*", "diff", "/", "num_sims", ",", "3", ")", "\n", "print", "(", "f\"\\nDid {num_sims} parallel sims in {round(diff, 1)} secs ({ms_per_sim}ms per sim)\"", ")", "\n", "print", "(", "f\"Collision seeds ({len(collision_seeds)}): {collision_seeds}\"", ")", "\n", "\n", "print", "(", "f\"Collision in {num_collisions} sims. {round(100 * num_collisions / num_sims, 6)}%\"", ")", "\n", "\n", "d", "=", "round", "(", "min_dist", ",", "1", ")", "\n", "print", "(", "f\"\\nSeed {min_seed} has min_dist {d} ft\"", ")", "\n", "\n", "# optional: do plot", "\n", "if", "False", ":", "\n", "        ", "init_vec", ",", "cmd_list", ",", "init_velo", ",", "tau_init", "=", "make_random_input", "(", "min_seed", ",", "max_tau", "=", "max_tau", ",", "intruder_can_turn", "=", "intruder_can_turn", ")", "\n", "s", "=", "State", "(", "init_vec", ",", "tau_init", ",", "tau_dot", ",", "init_velo", "[", "0", "]", ",", "init_velo", "[", "1", "]", ",", "save_states", "=", "True", ")", "\n", "s", ".", "simulate", "(", "cmd_list", ")", "\n", "assert", "abs", "(", "s", ".", "min_dist", "-", "min_dist", ")", "<", "1e-6", ",", "f\"got min dist: {s.min_dist}, expected: {min_dist}\"", "\n", "\n", "plot", "(", "s", ",", "save_mp4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.__init__": [[236, 265], ["numpy.array", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "init_vec", ",", "tau_init", "=", "0", ",", "tau_dot", "=", "0", ",", "v_own", "=", "800", ",", "v_int", "=", "500", ",", "save_states", "=", "False", ")", ":", "\n", "        ", "assert", "len", "(", "init_vec", ")", "==", "7", ",", "\"init vec should have length 7\"", "\n", "\n", "assert", "tau_dot", "in", "[", "0", ",", "-", "1", "]", "\n", "\n", "self", ".", "tau_dot", "=", "tau_dot", "\n", "self", ".", "tau_init", "=", "tau_init", "\n", "# tau_now = tau_init - self.vec[-1]", "\n", "\n", "self", ".", "vec", "=", "np", ".", "array", "(", "init_vec", ",", "dtype", "=", "float", ")", "# current state", "\n", "self", ".", "next_nn_update", "=", "0", "\n", "self", ".", "command", "=", "0", "# initial command", "\n", "self", ".", "v_own", "=", "v_own", "\n", "self", ".", "v_int", "=", "v_int", "\n", "\n", "# these are set when simulation() if save_states=True", "\n", "self", ".", "save_states", "=", "save_states", "\n", "self", ".", "vec_list", "=", "[", "]", "# state history", "\n", "self", ".", "commands", "=", "[", "]", "# commands history", "\n", "self", ".", "int_commands", "=", "[", "]", "# intruder command history", "\n", "\n", "# used only if plotting", "\n", "self", ".", "artists_dict", "=", "{", "}", "# set when make_artists is called", "\n", "self", ".", "img", "=", "None", "# assigned if plotting", "\n", "\n", "# assigned by simulate()", "\n", "self", ".", "u_list", "=", "[", "]", "\n", "self", ".", "u_list_index", "=", "None", "\n", "self", ".", "min_dist", "=", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.__str__": [[266, 271], ["numpy.sqrt"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "x1", ",", "y1", ",", "_theta1", ",", "x2", ",", "y2", ",", "_theta2", ",", "_", "=", "self", ".", "vec", "\n", "rho", "=", "np", ".", "sqrt", "(", "(", "x1", "-", "x2", ")", "**", "2", "+", "(", "y1", "-", "y2", ")", "**", "2", ")", "\n", "\n", "return", "f'State(v_own: {self.v_own}, v_int: {self.v_int}, rho: {rho})'", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.artists_list": [[272, 276], ["list", "acasxu_dubins.State.artists_dict.values"], "methods", ["None"], ["", "def", "artists_list", "(", "self", ")", ":", "\n", "        ", "'return list of artists'", "\n", "\n", "return", "list", "(", "self", ".", "artists_dict", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.set_plane_visible": [[277, 284], ["acasxu_dubins.State.artists_dict[].set_visible", "acasxu_dubins.State.artists_dict[].set_visible", "acasxu_dubins.State.artists_dict[].set_visible", "acasxu_dubins.State.artists_dict[].set_visible"], "methods", ["None"], ["", "def", "set_plane_visible", "(", "self", ",", "vis", ")", ":", "\n", "        ", "'set ownship plane visibility status'", "\n", "\n", "self", ".", "artists_dict", "[", "'dot0'", "]", ".", "set_visible", "(", "not", "vis", ")", "\n", "self", ".", "artists_dict", "[", "'circle0'", "]", ".", "set_visible", "(", "False", ")", "# circle always False", "\n", "self", ".", "artists_dict", "[", "'lc0'", "]", ".", "set_visible", "(", "True", ")", "\n", "self", ".", "artists_dict", "[", "'plane0'", "]", ".", "set_visible", "(", "vis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_artists": [[285, 334], ["zip", "rv.append", "rv.append", "acasxu_dubins.State.update_lc_artists", "rv.append", "plane.get_visible", "dot.set_data", "cir.set_center", "list", "scipy.ndimage.rotate", "list", "plane.set_data", "matplotlib.transforms.Bbox.from_bounds", "matplotlib.transforms.TransformedBbox", "zip"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_lc_artists"], ["", "def", "update_artists", "(", "self", ",", "axes", ")", ":", "\n", "        ", "'''update artists in self.artists_dict to be consistant with self.vec, returns a list of artists'''", "\n", "\n", "assert", "self", ".", "artists_dict", "\n", "rv", "=", "[", "]", "\n", "\n", "x1", ",", "y1", ",", "theta1", ",", "x2", ",", "y2", ",", "theta2", ",", "_", "=", "self", ".", "vec", "\n", "\n", "for", "i", ",", "x", ",", "y", ",", "theta", "in", "zip", "(", "[", "0", ",", "1", "]", ",", "[", "x1", ",", "x2", "]", ",", "[", "y1", ",", "y2", "]", ",", "[", "theta1", ",", "theta2", "]", ")", ":", "\n", "            ", "key", "=", "f'plane{i}'", "\n", "\n", "if", "key", "in", "self", ".", "artists_dict", ":", "\n", "                ", "plane", "=", "self", ".", "artists_dict", "[", "key", "]", "\n", "rv", ".", "append", "(", "plane", ")", "\n", "\n", "if", "plane", ".", "get_visible", "(", ")", ":", "\n", "                    ", "theta_deg", "=", "(", "theta", "-", "np", ".", "pi", "/", "2", ")", "/", "np", ".", "pi", "*", "180", "# original image is facing up, not right", "\n", "original_size", "=", "list", "(", "self", ".", "img", ".", "shape", ")", "\n", "img_rotated", "=", "ndimage", ".", "rotate", "(", "self", ".", "img", ",", "theta_deg", ",", "order", "=", "1", ")", "\n", "rotated_size", "=", "list", "(", "img_rotated", ".", "shape", ")", "\n", "ratios", "=", "[", "r", "/", "o", "for", "r", ",", "o", "in", "zip", "(", "rotated_size", ",", "original_size", ")", "]", "\n", "plane", ".", "set_data", "(", "img_rotated", ")", "\n", "\n", "size", "=", "State", ".", "plane_size", "\n", "width", "=", "size", "*", "ratios", "[", "0", "]", "\n", "height", "=", "size", "*", "ratios", "[", "1", "]", "\n", "box", "=", "Bbox", ".", "from_bounds", "(", "x", "-", "width", "/", "2", ",", "y", "-", "height", "/", "2", ",", "width", ",", "height", ")", "\n", "tbox", "=", "TransformedBbox", "(", "box", ",", "axes", ".", "transData", ")", "\n", "plane", ".", "bbox", "=", "tbox", "\n", "\n", "", "", "key", "=", "f'dot{i}'", "\n", "if", "key", "in", "self", ".", "artists_dict", ":", "\n", "                ", "dot", "=", "self", ".", "artists_dict", "[", "f'dot{i}'", "]", "\n", "cir", "=", "self", ".", "artists_dict", "[", "f'circle{i}'", "]", "\n", "rv", "+=", "[", "dot", ",", "cir", "]", "\n", "\n", "dot", ".", "set_data", "(", "[", "x", "]", ",", "[", "y", "]", ")", "\n", "cir", ".", "set_center", "(", "(", "x", ",", "y", ")", ")", "\n", "\n", "# line collection", "\n", "", "", "lc", "=", "self", ".", "artists_dict", "[", "'lc0'", "]", "\n", "rv", ".", "append", "(", "lc", ")", "\n", "\n", "int_lc", "=", "self", ".", "artists_dict", "[", "'int_lc0'", "]", "\n", "rv", ".", "append", "(", "int_lc", ")", "\n", "\n", "self", ".", "update_lc_artists", "(", "lc", ",", "int_lc", ")", "\n", "\n", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_lc_artists": [[335, 397], ["enumerate", "lc.get_paths", "lc.get_paths.clear", "enumerate", "lc.set_lw", "lc.set_color", "codes.append", "verts.append", "lc.get_paths.append", "numpy.linalg.norm", "matplotlib.path.Path", "lc.get_paths.append", "lws.append", "colors.append", "matplotlib.path.Path", "lws.append", "colors.append", "lws.append", "colors.append", "lws.append", "colors.append", "lws.append", "colors.append"], "methods", ["None"], ["", "def", "update_lc_artists", "(", "self", ",", "own_lc", ",", "int_lc", ")", ":", "\n", "        ", "'update line collection artist based on current state'", "\n", "\n", "assert", "self", ".", "vec_list", "\n", "\n", "for", "lc_index", ",", "lc", "in", "enumerate", "(", "[", "own_lc", ",", "int_lc", "]", ")", ":", "\n", "            ", "paths", "=", "lc", ".", "get_paths", "(", ")", "\n", "colors", "=", "[", "]", "\n", "lws", "=", "[", "]", "\n", "paths", ".", "clear", "(", ")", "\n", "last_command", "=", "-", "1", "\n", "codes", "=", "[", "]", "\n", "verts", "=", "[", "]", "\n", "\n", "for", "i", ",", "vec", "in", "enumerate", "(", "self", ".", "vec_list", ")", ":", "\n", "                ", "if", "np", ".", "linalg", ".", "norm", "(", "vec", "-", "self", ".", "vec", ")", "<", "1e-6", ":", "\n", "# done", "\n", "                    ", "break", "\n", "\n", "", "if", "lc_index", "==", "0", ":", "\n", "                    ", "cmd", "=", "self", ".", "commands", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "cmd", "=", "self", ".", "int_commands", "[", "i", "]", "\n", "\n", "", "x", "=", "0", "if", "lc_index", "==", "0", "else", "3", "\n", "y", "=", "1", "if", "lc_index", "==", "0", "else", "4", "\n", "\n", "# command[i] is the line from i to (i+1)", "\n", "if", "cmd", "!=", "last_command", ":", "\n", "                    ", "if", "codes", ":", "\n", "                        ", "paths", ".", "append", "(", "Path", "(", "verts", ",", "codes", ")", ")", "\n", "\n", "", "codes", "=", "[", "Path", ".", "MOVETO", "]", "\n", "verts", "=", "[", "(", "vec", "[", "x", "]", ",", "vec", "[", "y", "]", ")", "]", "\n", "\n", "if", "cmd", "==", "1", ":", "# weak left", "\n", "                        ", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'b'", ")", "\n", "", "elif", "cmd", "==", "2", ":", "# weak right", "\n", "                        ", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'c'", ")", "\n", "", "elif", "cmd", "==", "3", ":", "# strong left", "\n", "                        ", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'g'", ")", "\n", "", "elif", "cmd", "==", "4", ":", "# strong right", "\n", "                        ", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'r'", ")", "\n", "", "else", ":", "\n", "                        ", "assert", "cmd", "==", "0", "# coc", "\n", "lws", ".", "append", "(", "2", ")", "\n", "colors", ".", "append", "(", "'k'", ")", "\n", "\n", "", "", "codes", ".", "append", "(", "Path", ".", "LINETO", ")", "\n", "\n", "verts", ".", "append", "(", "(", "self", ".", "vec_list", "[", "i", "+", "1", "]", "[", "x", "]", ",", "self", ".", "vec_list", "[", "i", "+", "1", "]", "[", "y", "]", ")", ")", "\n", "\n", "# add last one", "\n", "", "if", "codes", ":", "\n", "                ", "paths", ".", "append", "(", "Path", "(", "verts", ",", "codes", ")", ")", "\n", "\n", "", "lc", ".", "set_lw", "(", "lws", ")", "\n", "lc", ".", "set_color", "(", "colors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.make_artists": [[398, 450], ["acasxu_dubins.get_airplane_img", "enumerate", "pos_lists.append", "l.set_visible", "axes.plot", "matplotlib.collections.LineCollection", "axes.add_collection", "matplotlib.collections.LineCollection", "axes.add_collection", "matplotlib.transforms.Bbox.from_bounds", "matplotlib.transforms.TransformedBbox", "matplotlib.image.BboxImage", "scipy.ndimage.rotate", "matplotlib.image.BboxImage.set_data", "axes.add_artist", "matplotlib.patches.Ellipse", "axes.add_patch", "axes.plot", "zip"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_airplane_img", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot"], ["", "", "def", "make_artists", "(", "self", ",", "axes", ",", "show_intruder", ")", ":", "\n", "        ", "'make self.artists_dict'", "\n", "\n", "assert", "self", ".", "vec_list", "\n", "self", ".", "img", "=", "get_airplane_img", "(", ")", "\n", "\n", "posa_list", "=", "[", "(", "v", "[", "0", "]", ",", "v", "[", "1", "]", ",", "v", "[", "2", "]", ")", "for", "v", "in", "self", ".", "vec_list", "]", "\n", "posb_list", "=", "[", "(", "v", "[", "3", "]", ",", "v", "[", "4", "]", ",", "v", "[", "5", "]", ")", "for", "v", "in", "self", ".", "vec_list", "]", "\n", "\n", "pos_lists", "=", "[", "posa_list", ",", "posb_list", "]", "\n", "\n", "if", "show_intruder", ":", "\n", "            ", "pos_lists", ".", "append", "(", "posb_list", ")", "\n", "\n", "", "for", "i", ",", "pos_list", "in", "enumerate", "(", "pos_lists", ")", ":", "\n", "            ", "x", ",", "y", ",", "theta", "=", "pos_list", "[", "0", "]", "\n", "\n", "l", "=", "axes", ".", "plot", "(", "*", "zip", "(", "*", "pos_list", ")", ",", "f'c-'", ",", "lw", "=", "0", ",", "zorder", "=", "1", ")", "[", "0", "]", "\n", "l", ".", "set_visible", "(", "False", ")", "\n", "self", ".", "artists_dict", "[", "f'line{i}'", "]", "=", "l", "\n", "\n", "if", "i", "==", "0", ":", "\n", "                ", "lc", "=", "LineCollection", "(", "[", "]", ",", "lw", "=", "2", ",", "animated", "=", "True", ",", "color", "=", "'k'", ",", "zorder", "=", "1", ")", "\n", "axes", ".", "add_collection", "(", "lc", ")", "\n", "self", ".", "artists_dict", "[", "f'lc{i}'", "]", "=", "lc", "\n", "\n", "int_lc", "=", "LineCollection", "(", "[", "]", ",", "lw", "=", "2", ",", "animated", "=", "True", ",", "color", "=", "'k'", ",", "zorder", "=", "1", ")", "\n", "axes", ".", "add_collection", "(", "int_lc", ")", "\n", "self", ".", "artists_dict", "[", "f'int_lc{i}'", "]", "=", "int_lc", "\n", "\n", "# only sim_index = 0 gets intruder aircraft", "\n", "", "if", "i", "==", "0", "or", "(", "i", "==", "1", "and", "show_intruder", ")", ":", "\n", "                ", "size", "=", "State", ".", "plane_size", "\n", "box", "=", "Bbox", ".", "from_bounds", "(", "x", "-", "size", "/", "2", ",", "y", "-", "size", "/", "2", ",", "size", ",", "size", ")", "\n", "tbox", "=", "TransformedBbox", "(", "box", ",", "axes", ".", "transData", ")", "\n", "box_image", "=", "BboxImage", "(", "tbox", ",", "zorder", "=", "2", ")", "\n", "\n", "theta_deg", "=", "(", "theta", "-", "np", ".", "pi", "/", "2", ")", "/", "np", ".", "pi", "*", "180", "# original image is facing up, not right", "\n", "img_rotated", "=", "ndimage", ".", "rotate", "(", "self", ".", "img", ",", "theta_deg", ",", "order", "=", "1", ")", "\n", "\n", "box_image", ".", "set_data", "(", "img_rotated", ")", "\n", "axes", ".", "add_artist", "(", "box_image", ")", "\n", "self", ".", "artists_dict", "[", "f'plane{i}'", "]", "=", "box_image", "\n", "\n", "", "if", "i", "==", "0", ":", "\n", "                ", "dot", "=", "axes", ".", "plot", "(", "[", "x", "]", ",", "[", "y", "]", ",", "'k.'", ",", "markersize", "=", "6.0", ",", "zorder", "=", "2", ")", "[", "0", "]", "\n", "self", ".", "artists_dict", "[", "f'dot{i}'", "]", "=", "dot", "\n", "\n", "rad", "=", "1500", "\n", "c", "=", "patches", ".", "Ellipse", "(", "(", "x", ",", "y", ")", ",", "rad", ",", "rad", ",", "color", "=", "'k'", ",", "lw", "=", "3.0", ",", "fill", "=", "False", ")", "\n", "axes", ".", "add_patch", "(", "c", ")", "\n", "self", ".", "artists_dict", "[", "f'circle{i}'", "]", "=", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.step": [[451, 475], ["acasxu_dubins.step_state", "acasxu_dubins.State.update_command", "acasxu_dubins.State.commands.append", "acasxu_dubins.State.int_commands.append", "abs"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.step_state", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_command"], ["", "", "", "def", "step", "(", "self", ")", ":", "\n", "        ", "'execute one time step and update the model'", "\n", "\n", "tol", "=", "1e-6", "\n", "\n", "if", "self", ".", "next_nn_update", "<", "tol", ":", "\n", "            ", "assert", "abs", "(", "self", ".", "next_nn_update", ")", "<", "tol", ",", "f\"time step doesn't sync with nn update time. \"", "+", "f\"next update: {self.next_nn_update}\"", "\n", "\n", "# update command", "\n", "self", ".", "update_command", "(", ")", "\n", "\n", "self", ".", "next_nn_update", "=", "State", ".", "nn_update_rate", "\n", "\n", "", "self", ".", "next_nn_update", "-=", "State", ".", "dt", "\n", "intruder_cmd", "=", "self", ".", "u_list", "[", "self", ".", "u_list_index", "]", "\n", "\n", "if", "self", ".", "save_states", ":", "\n", "            ", "self", ".", "commands", ".", "append", "(", "self", ".", "command", ")", "\n", "self", ".", "int_commands", ".", "append", "(", "intruder_cmd", ")", "\n", "\n", "", "time_elapse_mat", "=", "State", ".", "time_elapse_mats", "[", "self", ".", "command", "]", "[", "intruder_cmd", "]", "#get_time_elapse_mat(self.command, State.dt, intruder_cmd)", "\n", "\n", "self", ".", "vec", "=", "step_state", "(", "self", ".", "vec", ",", "self", ".", "v_own", ",", "self", ".", "v_int", ",", "time_elapse_mat", ",", "State", ".", "dt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.simulate": [[476, 535], ["isinstance", "math.sqrt", "len", "acasxu_dubins.State.step", "acasxu_dubins.State.tau_now", "acasxu_dubins.State.vec.copy", "rv.append", "min", "acasxu_dubins.State.vec.copy"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.step", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.tau_now", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.None.backreach.State.copy"], ["", "def", "simulate", "(", "self", ",", "cmd_list", ")", ":", "\n", "        ", "'''simulate system\n\n        saves result in self.vec_list\n        also saves self.min_dist\n        '''", "\n", "\n", "self", ".", "u_list", "=", "cmd_list", "\n", "self", ".", "u_list_index", "=", "None", "\n", "\n", "assert", "isinstance", "(", "cmd_list", ",", "list", ")", "\n", "tmax", "=", "len", "(", "cmd_list", ")", "*", "State", ".", "nn_update_rate", "\n", "\n", "t", "=", "0.0", "\n", "\n", "if", "self", ".", "save_states", ":", "\n", "            ", "rv", "=", "[", "self", ".", "vec", ".", "copy", "(", ")", "]", "\n", "\n", "#self.min_dist = 0, math.sqrt((self.vec[0] - self.vec[3])**2 + (self.vec[1] - self.vec[4])**2), self.vec.copy()", "\n", "", "prev_dist_sq", "=", "(", "self", ".", "vec", "[", "0", "]", "-", "self", ".", "vec", "[", "3", "]", ")", "**", "2", "+", "(", "self", ".", "vec", "[", "1", "]", "-", "self", ".", "vec", "[", "4", "]", ")", "**", "2", "\n", "\n", "if", "self", ".", "tau_init", "==", "0", ":", "\n", "            ", "min_dist_sq", "=", "prev_dist_sq", "\n", "", "else", ":", "\n", "            ", "min_dist_sq", "=", "np", ".", "inf", "\n", "\n", "", "while", "t", "+", "1e-6", "<", "tmax", ":", "\n", "            ", "self", ".", "step", "(", ")", "\n", "\n", "cur_dist_sq", "=", "(", "self", ".", "vec", "[", "0", "]", "-", "self", ".", "vec", "[", "3", "]", ")", "**", "2", "+", "(", "self", ".", "vec", "[", "1", "]", "-", "self", ".", "vec", "[", "4", "]", ")", "**", "2", "\n", "\n", "if", "self", ".", "save_states", ":", "\n", "                ", "rv", ".", "append", "(", "self", ".", "vec", ".", "copy", "(", ")", ")", "\n", "\n", "", "t", "+=", "State", ".", "dt", "\n", "\n", "tau_now", "=", "self", ".", "tau_now", "(", ")", "\n", "\n", "if", "tau_now", "==", "0", ":", "\n", "                ", "min_dist_sq", "=", "min", "(", "min_dist_sq", ",", "cur_dist_sq", ")", "\n", "\n", "", "if", "cur_dist_sq", ">", "prev_dist_sq", "and", "cur_dist_sq", ">", "500", "**", "2", ":", "\n", "# distance was increasing", "\n", "                ", "break", "\n", "\n", "", "if", "tau_now", "<", "0", ":", "\n", "                ", "break", "\n", "\n", "", "prev_dist_sq", "=", "cur_dist_sq", "\n", "\n", "", "self", ".", "min_dist", "=", "math", ".", "sqrt", "(", "min_dist_sq", ")", "\n", "\n", "if", "self", ".", "save_states", ":", "\n", "            ", "self", ".", "vec_list", "=", "rv", "\n", "\n", "", "if", "not", "self", ".", "save_states", ":", "\n", "            ", "assert", "not", "self", ".", "vec_list", "\n", "assert", "not", "self", ".", "commands", "\n", "assert", "not", "self", ".", "int_commands", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.tau_now": [[536, 540], ["round"], "methods", ["None"], ["", "", "def", "tau_now", "(", "self", ")", ":", "\n", "        ", "\"\"\"return the integer value of tau based on tau_init, tau_dot, and self.vec[-1]\"\"\"", "\n", "\n", "return", "round", "(", "self", ".", "tau_init", "+", "self", ".", "tau_dot", "*", "self", ".", "vec", "[", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_command": [[541, 577], ["acasxu_dubins.state7_to_state5", "acasxu_dubins.network_index", "acasxu_dubins.run_network", "numpy.argmin", "min", "acasxu_dubins.State.tau_now", "len"], "methods", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.state7_to_state5", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.network_index", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.run_network", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.tau_now"], ["", "def", "update_command", "(", "self", ")", ":", "\n", "        ", "'update command based on current state'", "''", "\n", "\n", "rho", ",", "theta", ",", "psi", ",", "v_own", ",", "v_int", "=", "state7_to_state5", "(", "self", ".", "vec", ",", "self", ".", "v_own", ",", "self", ".", "v_int", ")", "\n", "\n", "# 0: rho, distance", "\n", "# 1: theta, angle to intruder relative to ownship heading", "\n", "# 2: psi, heading of intruder relative to ownship heading", "\n", "# 3: v_own, speed of ownship", "\n", "# 4: v_int, speed in intruder", "\n", "\n", "# min inputs: 0, -3.1415, -3.1415, 100, 0", "\n", "# max inputs: 60760, 3.1415, 3,1415, 1200, 1200", "\n", "\n", "if", "rho", ">", "60760", ":", "\n", "            ", "self", ".", "command", "=", "0", "\n", "", "else", ":", "\n", "            ", "last_command", "=", "self", ".", "command", "\n", "\n", "ni", "=", "network_index", "(", "last_command", ",", "self", ".", "tau_now", "(", ")", ")", "\n", "net", "=", "State", ".", "nets", "[", "ni", "]", "\n", "\n", "state", "=", "[", "rho", ",", "theta", ",", "psi", ",", "v_own", ",", "v_int", "]", "\n", "\n", "res", "=", "run_network", "(", "net", ",", "state", ")", "\n", "self", ".", "command", "=", "np", ".", "argmin", "(", "res", ")", "\n", "\n", "#names = ['clear-of-conflict', 'weak-left', 'weak-right', 'strong-left', 'strong-right']", "\n", "\n", "", "if", "self", ".", "u_list_index", "is", "None", ":", "\n", "            ", "self", ".", "u_list_index", "=", "0", "\n", "", "else", ":", "\n", "            ", "self", ".", "u_list_index", "+=", "1", "\n", "\n", "# repeat last command if no more commands", "\n", "self", ".", "u_list_index", "=", "min", "(", "self", ".", "u_list_index", ",", "len", "(", "self", ".", "u_list", ")", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.init_plot": [[27, 34], ["matplotlib.style.use"], "function", ["None"], ["def", "init_plot", "(", ")", ":", "\n", "    ", "'initialize plotting style'", "\n", "\n", "#matplotlib.use('TkAgg') # set backend", "\n", "\n", "p", "=", "'../resources/bak_matplotlib.mlpstyle'", "\n", "plt", ".", "style", ".", "use", "(", "[", "'bmh'", ",", "p", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.load_network": [[35, 51], ["onnxruntime.InferenceSession", "numpy.array", "ort.InferenceSession.run"], "function", ["None"], ["", "def", "load_network", "(", "last_cmd", ",", "tau", ")", ":", "\n", "    ", "'''load onnx neural network and return (session, range_for_scaling, means_for_scaling)'''", "\n", "\n", "onnx_filename", "=", "f\"../resources/ACASXU_run2a_{last_cmd + 1}_{tau + 1}_batch_2000.onnx\"", "\n", "\n", "means_for_scaling", "=", "[", "19791.091", ",", "0.0", ",", "0.0", ",", "650.0", ",", "600.0", ",", "7.5188840201005975", "]", "\n", "range_for_scaling", "=", "[", "60261.0", ",", "6.28318530718", ",", "6.28318530718", ",", "1100.0", ",", "1200.0", "]", "\n", "\n", "session", "=", "ort", ".", "InferenceSession", "(", "onnx_filename", ")", "\n", "\n", "# warm up the network", "\n", "i", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "i", ".", "shape", "=", "(", "1", ",", "1", ",", "1", ",", "5", ")", "\n", "session", ".", "run", "(", "None", ",", "{", "'input'", ":", "i", "}", ")", "\n", "\n", "return", "session", ",", "range_for_scaling", ",", "means_for_scaling", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.load_networks": [[52, 62], ["range", "range", "nets.append", "acasxu_dubins.load_network"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.load_network"], ["", "def", "load_networks", "(", ")", ":", "\n", "    ", "'''load the 45 neural networks into nn-enum's data structures and return them as a list'''", "\n", "\n", "nets", "=", "[", "]", "\n", "\n", "for", "last_cmd", "in", "range", "(", "5", ")", ":", "\n", "        ", "for", "tau", "in", "range", "(", "9", ")", ":", "\n", "            ", "nets", ".", "append", "(", "load_network", "(", "last_cmd", ",", "tau", ")", ")", "\n", "\n", "", "", "return", "nets", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.network_index": [[63, 90], ["enumerate", "len", "len", "abs", "abs"], "function", ["None"], ["", "def", "network_index", "(", "alpha_prev", ":", "int", ",", "tau", ":", "float", ")", ":", "\n", "    ", "\"\"\"get network index\"\"\"", "\n", "\n", "tau_list", "=", "[", "0", ",", "1", ",", "5", ",", "10", ",", "20", ",", "50", ",", "60", ",", "80", ",", "100", "]", "\n", "tau_index", "=", "-", "1", "\n", "\n", "if", "tau", "<=", "tau_list", "[", "0", "]", ":", "\n", "        ", "tau_index", "=", "0", "\n", "", "elif", "tau", ">=", "tau_list", "[", "-", "1", "]", ":", "\n", "        ", "tau_index", "=", "len", "(", "tau_list", ")", "-", "1", "\n", "", "else", ":", "\n", "# find the index of the closest tau value, rounding down to break ties", "\n", "\n", "        ", "for", "i", ",", "tau_min", "in", "enumerate", "(", "tau_list", "[", ":", "-", "1", "]", ")", ":", "\n", "            ", "tau_max", "=", "tau_list", "[", "i", "+", "1", "]", "\n", "\n", "if", "tau_min", "<=", "tau", "<=", "tau_max", ":", "\n", "                ", "if", "abs", "(", "tau", "-", "tau_min", ")", "-", "1e-6", "<=", "abs", "(", "tau", "-", "tau_max", ")", ":", "\n", "                    ", "tau_index", "=", "i", "\n", "", "else", ":", "\n", "                    ", "tau_index", "=", "i", "+", "1", "\n", "\n", "", "break", "\n", "\n", "", "", "", "assert", "tau_index", ">=", "0", ",", "f\"tau_index not found for tau = {tau}?\"", "\n", "\n", "return", "len", "(", "tau_list", ")", "*", "alpha_prev", "+", "tau_index", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_time_elapse_mat": [[92, 118], ["numpy.array", "scipy.linalg.expm"], "function", ["None"], ["def", "get_time_elapse_mat", "(", "command1", ",", "dt", ",", "command2", "=", "0", ")", ":", "\n", "    ", "'''get the matrix exponential for the given command\n\n    state: x, y, vx, vy, x2, y2, vx2, vy2\n    '''", "\n", "\n", "y_list", "=", "[", "0.0", ",", "1.5", ",", "-", "1.5", ",", "3.0", ",", "-", "3.0", "]", "\n", "y1", "=", "y_list", "[", "command1", "]", "\n", "y2", "=", "y_list", "[", "command2", "]", "\n", "\n", "dtheta1", "=", "(", "y1", "/", "180", "*", "np", ".", "pi", ")", "\n", "dtheta2", "=", "(", "y2", "/", "180", "*", "np", ".", "pi", ")", "\n", "\n", "a_mat", "=", "np", ".", "array", "(", "[", "\n", "[", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "# x' = vx", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "# y' = vy", "\n", "[", "0", ",", "0", ",", "0", ",", "-", "dtheta1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "# vx' = -vy * dtheta1", "\n", "[", "0", ",", "0", ",", "dtheta1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "# vy' = vx * dtheta1", "\n", "#", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", "]", ",", "# x' = vx", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", "]", ",", "# y' = vy", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "-", "dtheta2", "]", ",", "# vx' = -vy * dtheta2", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "dtheta2", ",", "0", "]", ",", "# vy' = vx * dtheta1", "\n", "]", ",", "dtype", "=", "float", ")", "\n", "\n", "return", "expm", "(", "a_mat", "*", "dt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.run_network": [[119, 136], ["range", "numpy.array", "session.run", "print"], "function", ["None"], ["", "def", "run_network", "(", "network_tuple", ",", "x", ",", "stdout", "=", "False", ")", ":", "\n", "    ", "'run the network and return the output'", "\n", "\n", "session", ",", "range_for_scaling", ",", "means_for_scaling", "=", "network_tuple", "\n", "\n", "# normalize input", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "        ", "x", "[", "i", "]", "=", "(", "x", "[", "i", "]", "-", "means_for_scaling", "[", "i", "]", ")", "/", "range_for_scaling", "[", "i", "]", "\n", "\n", "", "if", "stdout", ":", "\n", "        ", "print", "(", "f\"input (after scaling): {x}\"", ")", "\n", "\n", "", "in_array", "=", "np", ".", "array", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "in_array", ".", "shape", "=", "(", "1", ",", "1", ",", "1", ",", "5", ")", "\n", "outputs", "=", "session", ".", "run", "(", "None", ",", "{", "'input'", ":", "in_array", "}", ")", "\n", "\n", "return", "outputs", "[", "0", "]", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.state7_to_state5": [[137, 168], ["numba.njit", "numpy.sqrt", "numpy.arctan2", "numpy.array", "len"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "state7_to_state5", "(", "state7", ",", "v_own", ",", "v_int", ")", ":", "\n", "    ", "\"\"\"compute rho, theta, psi from state7\"\"\"", "\n", "\n", "assert", "len", "(", "state7", ")", "==", "7", "\n", "\n", "x1", ",", "y1", ",", "theta1", ",", "x2", ",", "y2", ",", "theta2", ",", "_", "=", "state7", "\n", "\n", "rho", "=", "np", ".", "sqrt", "(", "(", "x1", "-", "x2", ")", "**", "2", "+", "(", "y1", "-", "y2", ")", "**", "2", ")", "\n", "\n", "dy", "=", "y2", "-", "y1", "\n", "dx", "=", "x2", "-", "x1", "\n", "\n", "theta", "=", "np", ".", "arctan2", "(", "dy", ",", "dx", ")", "\n", "psi", "=", "theta2", "-", "theta1", "\n", "\n", "theta", "-=", "theta1", "\n", "\n", "while", "theta", "<", "-", "np", ".", "pi", ":", "\n", "        ", "theta", "+=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "theta", ">", "np", ".", "pi", ":", "\n", "        ", "theta", "-=", "2", "*", "np", ".", "pi", "\n", "\n", "", "if", "psi", "<", "-", "np", ".", "pi", ":", "\n", "        ", "psi", "+=", "2", "*", "np", ".", "pi", "\n", "\n", "", "while", "psi", ">", "np", ".", "pi", ":", "\n", "        ", "psi", "-=", "2", "*", "np", ".", "pi", "\n", "\n", "", "return", "np", ".", "array", "(", "[", "rho", ",", "theta", ",", "psi", ",", "v_own", ",", "v_int", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.state7_to_state8": [[169, 186], ["numba.njit", "numpy.array", "len", "math.cos", "math.sin", "math.cos", "math.sin"], "function", ["None"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "state7_to_state8", "(", "state7", ",", "v_own", ",", "v_int", ")", ":", "\n", "    ", "\"\"\"compute x,y, vx, vy, x2, y2, vx2, vy2 from state7\"\"\"", "\n", "\n", "assert", "len", "(", "state7", ")", "==", "7", "\n", "\n", "x1", "=", "state7", "[", "0", "]", "\n", "y1", "=", "state7", "[", "1", "]", "\n", "vx1", "=", "math", ".", "cos", "(", "state7", "[", "2", "]", ")", "*", "v_own", "\n", "vy1", "=", "math", ".", "sin", "(", "state7", "[", "2", "]", ")", "*", "v_own", "\n", "\n", "x2", "=", "state7", "[", "3", "]", "\n", "y2", "=", "state7", "[", "4", "]", "\n", "vx2", "=", "math", ".", "cos", "(", "state7", "[", "5", "]", ")", "*", "v_int", "\n", "vy2", "=", "math", ".", "sin", "(", "state7", "[", "5", "]", ")", "*", "v_int", "\n", "\n", "return", "np", ".", "array", "(", "[", "x1", ",", "y1", ",", "vx1", ",", "vy1", ",", "x2", ",", "y2", ",", "vx2", ",", "vy2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_airplane_img": [[187, 194], ["functools.lru_cache", "matplotlib.imread"], "function", ["None"], ["", "@", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "get_airplane_img", "(", ")", ":", "\n", "    ", "\"\"\"load airplane image form file\"\"\"", "\n", "\n", "img", "=", "plt", ".", "imread", "(", "'../resources/airplane.png'", ")", "\n", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.init_time_elapse_mats": [[195, 208], ["range", "rv.append", "range", "acasxu_dubins.get_time_elapse_mat", "rv[].append"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.get_time_elapse_mat"], ["", "def", "init_time_elapse_mats", "(", "dt", ")", ":", "\n", "    ", "\"\"\"get value of time_elapse_mats array\"\"\"", "\n", "\n", "rv", "=", "[", "]", "\n", "\n", "for", "cmd", "in", "range", "(", "5", ")", ":", "\n", "        ", "rv", ".", "append", "(", "[", "]", ")", "\n", "\n", "for", "int_cmd", "in", "range", "(", "5", ")", ":", "\n", "            ", "mat", "=", "get_time_elapse_mat", "(", "cmd", ",", "dt", ",", "int_cmd", ")", "\n", "rv", "[", "-", "1", "]", ".", "append", "(", "mat", ")", "\n", "\n", "", "", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.step_state": [[209, 224], ["numba.njit", "acasxu_dubins.state7_to_state8", "math.atan2", "math.atan2", "numpy.array"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.state7_to_state8"], ["", "@", "njit", "(", "cache", "=", "True", ")", "\n", "def", "step_state", "(", "state7", ",", "v_own", ",", "v_int", ",", "time_elapse_mat", ",", "dt", ")", ":", "\n", "    ", "\"\"\"perform one time step with the given commands\"\"\"", "\n", "\n", "state8_vec", "=", "state7_to_state8", "(", "state7", ",", "v_own", ",", "v_int", ")", "\n", "\n", "s", "=", "time_elapse_mat", "@", "state8_vec", "\n", "\n", "# extract observation (like theta) from state", "\n", "new_time", "=", "state7", "[", "-", "1", "]", "+", "dt", "\n", "theta1", "=", "math", ".", "atan2", "(", "s", "[", "3", "]", ",", "s", "[", "2", "]", ")", "\n", "theta2", "=", "math", ".", "atan2", "(", "s", "[", "7", "]", ",", "s", "[", "6", "]", ")", "\n", "rv", "=", "np", ".", "array", "(", "[", "s", "[", "0", "]", ",", "s", "[", "1", "]", ",", "theta1", ",", "s", "[", "4", "]", ",", "s", "[", "5", "]", ",", "theta2", ",", "new_time", "]", ")", "\n", "\n", "return", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot": [[578, 682], ["print", "acasxu_dubins.init_plot", "matplotlib.subplots", "axes.axis", "axes.set_title", "axes.set_xlabel", "axes.set_ylabel", "axes.text", "axes.text.set_visible", "axes.legend", "s.make_artists", "matplotlib.tight_layout", "len", "matplotlib.animation.FuncAnimation", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "max", "min", "len", "round", "math.sqrt", "axes.text.set_text", "animation.FuncAnimation.save", "matplotlib.show", "print", "s.update_artists", "s.artists_list", "s.set_plane_visible", "s.artists_list", "dict", "a.set_visible"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.init_plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.make_artists", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.update_artists", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.artists_list", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.set_plane_visible", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.artists_list"], ["", "", "", "def", "plot", "(", "s", ",", "save_mp4", ")", ":", "\n", "    ", "\"\"\"plot a specific simulation\"\"\"", "\n", "\n", "s", ".", "vec", "=", "s", ".", "vec_list", "[", "0", "]", "# for printing the correct state", "\n", "print", "(", "f\"plotting state {s} with min_dist {s.min_dist}\"", ")", "\n", "\n", "init_plot", "(", ")", "\n", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "1", ",", "ncols", "=", "1", ",", "figsize", "=", "(", "8", ",", "8", ")", ")", "\n", "axes", ".", "axis", "(", "'equal'", ")", "\n", "\n", "axes", ".", "set_title", "(", "\"ACAS Xu Simulations\"", ")", "\n", "axes", ".", "set_xlabel", "(", "'X Position (ft)'", ")", "\n", "axes", ".", "set_ylabel", "(", "'Y Position (ft)'", ")", "\n", "\n", "time_text", "=", "axes", ".", "text", "(", "0.02", ",", "0.98", ",", "f'Time: 0 ($\\\\tau$ = {s.tau_init})'", ",", "\n", "horizontalalignment", "=", "'left'", ",", "fontsize", "=", "14", ",", "\n", "verticalalignment", "=", "'top'", ",", "transform", "=", "axes", ".", "transAxes", ")", "\n", "time_text", ".", "set_visible", "(", "True", ")", "\n", "\n", "custom_lines", "=", "[", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'g'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'b'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'k'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'c'", ",", "lw", "=", "2", ")", ",", "\n", "Line2D", "(", "[", "0", "]", ",", "[", "0", "]", ",", "color", "=", "'r'", ",", "lw", "=", "2", ")", "]", "\n", "\n", "axes", ".", "legend", "(", "custom_lines", ",", "[", "'Strong Left'", ",", "'Weak Left'", ",", "'Clear of Conflict'", ",", "'Weak Right'", ",", "'Strong Right'", "]", ",", "fontsize", "=", "14", ",", "loc", "=", "'lower left'", ")", "\n", "\n", "s", ".", "make_artists", "(", "axes", ",", "show_intruder", "=", "True", ")", "\n", "states", "=", "[", "s", "]", "\n", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "num_steps", "=", "len", "(", "states", "[", "0", "]", ".", "vec_list", ")", "\n", "interval", "=", "50", "# ms per frame", "\n", "freeze_frames", "=", "10", "if", "not", "save_mp4", "else", "80", "\n", "\n", "num_runs", "=", "1", "# 3", "\n", "num_frames", "=", "num_runs", "*", "num_steps", "+", "2", "*", "num_runs", "*", "freeze_frames", "\n", "\n", "#plt.savefig('plot.png')", "\n", "#plot_commands(states[0])", "\n", "\n", "def", "animate", "(", "f", ")", ":", "\n", "        ", "'animate function'", "\n", "\n", "#if not save_mp4:", "\n", "#    f *= 5 # multiplier to make animation faster", "\n", "\n", "if", "(", "f", "+", "1", ")", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "f\"Frame: {f+1} / {num_frames}\"", ")", "\n", "\n", "", "run_index", "=", "f", "//", "(", "num_steps", "+", "2", "*", "freeze_frames", ")", "\n", "\n", "f", "=", "f", "-", "run_index", "*", "(", "num_steps", "+", "2", "*", "freeze_frames", ")", "\n", "\n", "f", "-=", "freeze_frames", "\n", "\n", "f", "=", "max", "(", "0", ",", "f", ")", "\n", "f", "=", "min", "(", "f", ",", "num_steps", "-", "1", ")", "\n", "\n", "num_states", "=", "len", "(", "states", ")", "\n", "assert", "num_states", "==", "1", ",", "\"can only plot one state since we're displaying tau\"", "\n", "\n", "if", "f", "==", "0", ":", "\n", "# initiaze current run_index", "\n", "            ", "show_plane", "=", "num_states", "<=", "10", "\n", "for", "s", "in", "states", "[", ":", "num_states", "]", ":", "\n", "                ", "s", ".", "set_plane_visible", "(", "show_plane", ")", "\n", "\n", "", "for", "s", "in", "states", "[", "num_states", ":", "]", ":", "\n", "                ", "for", "a", "in", "s", ".", "artists_list", "(", ")", ":", "\n", "                    ", "a", ".", "set_visible", "(", "False", ")", "\n", "\n", "", "", "", "s", "=", "states", "[", "0", "]", "\n", "secs", "=", "f", "*", "State", ".", "dt", "\n", "tau", "=", "round", "(", "s", ".", "tau_init", "+", "s", ".", "tau_dot", "*", "secs", ")", "\n", "vec", "=", "s", ".", "vec_list", "[", "f", "]", "\n", "dx", "=", "vec", "[", "3", "]", "-", "vec", "[", "0", "]", "\n", "dy", "=", "vec", "[", "4", "]", "-", "vec", "[", "1", "]", "\n", "rho", "=", "math", ".", "sqrt", "(", "dx", "**", "2", "+", "dy", "**", "2", ")", "\n", "time_str", "=", "f'Time: {secs:.1f} ($\\\\tau$: {tau} sec, $\\\\rho$: {rho:.1f} ft)'", "\n", "time_text", ".", "set_text", "(", "time_str", ")", "\n", "\n", "artists", "=", "[", "time_text", "]", "\n", "\n", "for", "s", "in", "states", "[", ":", "num_states", "]", ":", "\n", "            ", "s", ".", "vec", "=", "s", ".", "vec_list", "[", "f", "]", "\n", "artists", "+=", "s", ".", "update_artists", "(", "axes", ")", "\n", "\n", "", "for", "s", "in", "states", "[", "num_states", ":", "]", ":", "\n", "            ", "artists", "+=", "s", ".", "artists_list", "(", ")", "\n", "\n", "", "return", "artists", "\n", "\n", "", "my_anim", "=", "animation", ".", "FuncAnimation", "(", "fig", ",", "animate", ",", "frames", "=", "num_frames", ",", "interval", "=", "interval", ",", "blit", "=", "True", ",", "repeat", "=", "True", ")", "\n", "\n", "if", "save_mp4", ":", "\n", "        ", "writer", "=", "animation", ".", "writers", "[", "'ffmpeg'", "]", "(", "fps", "=", "50", ",", "metadata", "=", "dict", "(", "artist", "=", "'Stanley Bak'", ")", ",", "bitrate", "=", "1800", ")", "\n", "\n", "my_anim", ".", "save", "(", "'sim.mp4'", ",", "writer", "=", "writer", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.make_random_input": [[683, 728], ["numpy.random.seed", "numpy.zeros", "numpy.cos", "numpy.sin", "range", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.random.randint", "cmd_list.append", "numpy.random.random", "numpy.random.randint", "numpy.random.random"], "function", ["None"], ["", "", "def", "make_random_input", "(", "seed", ",", "intruder_can_turn", "=", "True", ",", "max_tau", "=", "0", ",", "num_inputs", "=", "150", ")", ":", "\n", "    ", "\"\"\"make and return a random input for the system\"\"\"", "\n", "\n", "if", "max_tau", ">", "0", ":", "\n", "        ", "num_inputs", "=", "max_tau", "+", "1", "\n", "\n", "", "np", ".", "random", ".", "seed", "(", "seed", ")", "# deterministic random numbers", "\n", "\n", "# state vector is: x, y, theta, x2, y2, theta2, time", "\n", "init_vec", "=", "np", ".", "zeros", "(", "7", ")", "\n", "init_vec", "[", "2", "]", "=", "np", ".", "pi", "/", "2", "# ownship moving up initially", "\n", "\n", "#radius = 20000 + np.random.random() * 45000 # [20000, 65000]", "\n", "radius", "=", "60760", "+", "np", ".", "random", ".", "random", "(", ")", "*", "2400", "\n", "angle", "=", "np", ".", "random", ".", "random", "(", ")", "*", "2", "*", "np", ".", "pi", "\n", "int_x", "=", "radius", "*", "np", ".", "cos", "(", "angle", ")", "\n", "int_y", "=", "radius", "*", "np", ".", "sin", "(", "angle", ")", "\n", "int_heading", "=", "np", ".", "random", ".", "random", "(", ")", "*", "2", "*", "np", ".", "pi", "\n", "\n", "if", "max_tau", "==", "0", ":", "\n", "        ", "tau_init", "=", "0", "\n", "", "else", ":", "\n", "        ", "assert", "max_tau", ">", "25", "\n", "tau_init", "=", "25", "+", "np", ".", "random", ".", "randint", "(", "max_tau", "+", "1", "-", "25", ")", "\n", "\n", "", "init_vec", "[", "3", "]", "=", "int_x", "\n", "init_vec", "[", "4", "]", "=", "int_y", "\n", "init_vec", "[", "5", "]", "=", "int_heading", "\n", "\n", "# intruder commands for every control period (0 to 4)", "\n", "if", "intruder_can_turn", ":", "\n", "        ", "cmd_list", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "num_inputs", ")", ":", "\n", "            ", "cmd_list", ".", "append", "(", "np", ".", "random", ".", "randint", "(", "5", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "cmd_list", "=", "[", "0", "]", "*", "num_inputs", "\n", "\n", "# generate random valid velocities", "\n", "#init_velo = [np.random.randint(100, 1146),", "\n", "#             np.random.randint(60, 1146)]", "\n", "", "init_velo", "=", "[", "100", "+", "np", ".", "random", ".", "random", "(", ")", "*", "1100", ",", "\n", "np", ".", "random", ".", "random", "(", ")", "*", "1200", "]", "\n", "\n", "return", "init_vec", ",", "cmd_list", ",", "init_velo", ",", "tau_init", "\n", "\n"]], "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.main": [[729, 800], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "acasxu_dubins.make_random_input", "acasxu_dubins.State", "acasxu_dubins.State.simulate", "round", "print", "acasxu_dubins.plot", "time.perf_counter", "range", "print", "round", "print", "abs", "acasxu_dubins.make_random_input", "acasxu_dubins.State", "acasxu_dubins.State.simulate", "time.perf_counter", "print", "print", "round"], "function", ["home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.make_random_input", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.simulate", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.plot", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.make_random_input", "home.repos.pwc.inspect_result.stanleybak_quantized_nn_backreach.simulation.acasxu_dubins.State.simulate"], ["", "def", "main", "(", ")", ":", "\n", "    ", "'main entry point'", "\n", "\n", "# parse arguments", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Run ACASXU Dublins model simulator.'", ")", "\n", "parser", ".", "add_argument", "(", "\"--save-mp4\"", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "\"Save plotted mp4 files to disk.\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "intruder_can_turn", "=", "False", "\n", "\n", "save_mp4", "=", "args", ".", "save_mp4", "\n", "\n", "interesting_seed", "=", "-", "1", "\n", "interesting_state", "=", "None", "\n", "fixed_seed", "=", "None", "#835526", "\n", "max_tau", "=", "160", "\n", "\n", "tau_dot", "=", "-", "1", "if", "max_tau", ">", "0", "else", "0", "\n", "\n", "if", "fixed_seed", "is", "not", "None", ":", "\n", "        ", "interesting_seed", "=", "fixed_seed", "\n", "", "else", ":", "\n", "        ", "num_sims", "=", "10000", "\n", "# with 10000 sims, seed 671 has min_dist 4254.5ft", "\n", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "num_with_min_dist", "=", "0", "\n", "\n", "for", "seed", "in", "range", "(", "num_sims", ")", ":", "\n", "            ", "if", "seed", "%", "1000", "==", "0", ":", "\n", "                ", "print", "(", "f\"{(seed//1000) % 10}\"", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "", "elif", "seed", "%", "100", "==", "0", ":", "\n", "                ", "print", "(", "\".\"", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "\n", "", "init_vec", ",", "cmd_list", ",", "init_velo", ",", "tau_init", "=", "make_random_input", "(", "seed", ",", "max_tau", "=", "max_tau", ",", "intruder_can_turn", "=", "intruder_can_turn", ")", "\n", "\n", "v_own", "=", "init_velo", "[", "0", "]", "\n", "v_int", "=", "init_velo", "[", "1", "]", "\n", "\n", "# run the simulation", "\n", "s", "=", "State", "(", "init_vec", ",", "tau_init", ",", "tau_dot", ",", "v_own", ",", "v_int", ",", "save_states", "=", "False", ")", "\n", "s", ".", "simulate", "(", "cmd_list", ")", "\n", "\n", "if", "s", ".", "min_dist", "!=", "np", ".", "inf", ":", "\n", "                ", "num_with_min_dist", "+=", "1", "\n", "\n", "# save most interesting state based on some criteria", "\n", "", "if", "interesting_state", "is", "None", "or", "s", ".", "min_dist", "<", "interesting_state", ".", "min_dist", ":", "\n", "                ", "interesting_seed", "=", "seed", "\n", "interesting_state", "=", "s", "\n", "\n", "", "", "percent", "=", "100", "*", "num_with_min_dist", "/", "num_sims", "\n", "print", "(", "f\"Num sims reaching tau=0: {num_with_min_dist}/{num_sims} ({percent:.1f}%)\"", ")", "\n", "\n", "diff", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "ms_per_sim", "=", "round", "(", "1000", "*", "diff", "/", "num_sims", ",", "3", ")", "\n", "print", "(", "f\"\\nDid {num_sims} sims in {round(diff, 1)} secs ({ms_per_sim}ms per sim)\"", ")", "\n", "\n", "# optional: do plot", "\n", "", "assert", "interesting_seed", "!=", "-", "1", "\n", "\n", "init_vec", ",", "cmd_list", ",", "init_velo", ",", "tau_init", "=", "make_random_input", "(", "interesting_seed", ",", "max_tau", "=", "max_tau", ",", "\n", "intruder_can_turn", "=", "intruder_can_turn", ")", "\n", "s", "=", "State", "(", "init_vec", ",", "tau_init", ",", "tau_dot", ",", "init_velo", "[", "0", "]", ",", "init_velo", "[", "1", "]", ",", "save_states", "=", "True", ")", "\n", "s", ".", "simulate", "(", "cmd_list", ")", "\n", "\n", "assert", "abs", "(", "s", ".", "min_dist", "-", "interesting_state", ".", "min_dist", ")", "<", "1e-6", ",", "\"simulation mismatch\"", "\n", "\n", "d", "=", "round", "(", "s", ".", "min_dist", ",", "2", ")", "\n", "print", "(", "f\"\\nSeed {interesting_seed} has min_dist {d}ft\"", ")", "\n", "plot", "(", "s", ",", "save_mp4", ")", "\n", "\n"]]}