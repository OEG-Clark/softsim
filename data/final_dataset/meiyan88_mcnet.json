{"home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.MinimalRNNCell.__init__": [[38, 49], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "model.MinimalRNNCell.reset_parameters", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__init__", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.MinimalRNNCell.reset_parameters"], ["def", "__init__", "(", "self", ",", "input_size", ",", "hidden_size", ")", ":", "\n", "        ", "super", "(", "MinimalRNNCell", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "\n", "self", ".", "W_z", "=", "nn", ".", "Linear", "(", "input_size", ",", "hidden_size", ")", "\n", "self", ".", "weight_uh", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "weight_uz", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "bias_hh", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ")", ")", "\n", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.MinimalRNNCell.reset_parameters": [[50, 55], ["model.MinimalRNNCell.weight_uh.data.uniform_", "model.MinimalRNNCell.weight_uz.data.uniform_", "model.MinimalRNNCell.bias_hh.data.uniform_", "math.sqrt"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "stdv", "=", "1.0", "/", "math", ".", "sqrt", "(", "self", ".", "hidden_size", ")", "\n", "self", ".", "weight_uh", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "self", ".", "weight_uz", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "self", ".", "bias_hh", ".", "data", ".", "uniform_", "(", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.MinimalRNNCell.forward": [[56, 62], ["torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "model.MinimalRNNCell.W_z"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "ht_1", ")", ":", "\n", "        ", "ut", "=", "torch", ".", "tanh", "(", "self", ".", "W_z", "(", "input", ")", ")", "\n", "z", "=", "torch", ".", "addmm", "(", "self", ".", "bias_hh", ",", "ht_1", ",", "self", ".", "weight_uh", ")", "\n", "ft", "=", "torch", ".", "addmm", "(", "z", ",", "ut", ",", "self", ".", "weight_uz", ")", "\n", "ft", "=", "torch", ".", "sigmoid", "(", "ft", ")", "\n", "return", "ft", "*", "ht_1", "+", "(", "1", "-", "ft", ")", "*", "ut", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.ScaledDotProductAttention.__init__": [[66, 70], ["torch.Module.__init__", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__init__"], ["def", "__init__", "(", "self", ",", "temperature", ",", "attn_dropout", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "attn_dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.ScaledDotProductAttention.forward": [[71, 82], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "model.ScaledDotProductAttention.dropout", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "k.transpose", "attn.masked_fill.masked_fill.masked_fill", "torch.softmax", "torch.softmax", "torch.softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "q", ",", "k", ",", "v", ",", "mask", "=", "None", ")", ":", "\n", "\n", "        ", "attn", "=", "torch", ".", "matmul", "(", "q", "/", "self", ".", "temperature", ",", "k", ".", "transpose", "(", "2", ",", "3", ")", ")", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "attn", "=", "attn", ".", "masked_fill", "(", "mask", "==", "0", ",", "-", "1e9", ")", "\n", "\n", "", "attn", "=", "self", ".", "dropout", "(", "F", ".", "softmax", "(", "attn", ",", "dim", "=", "-", "1", ")", ")", "\n", "output", "=", "torch", ".", "matmul", "(", "attn", ",", "v", ")", "\n", "\n", "return", "output", ",", "attn", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.MultiHeadAttention.__init__": [[86, 102], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "model.ScaledDotProductAttention", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__init__"], ["def", "__init__", "(", "self", ",", "n_head", ",", "d_model", ",", "d_k", ",", "d_v", ",", "dropout", "=", "0.1", ",", "use_residual", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_head", "=", "n_head", "\n", "self", ".", "d_k", "=", "d_k", "\n", "self", ".", "d_v", "=", "d_v", "\n", "self", ".", "use_residual", "=", "use_residual", "\n", "self", ".", "w_qs", "=", "nn", ".", "Linear", "(", "d_model", ",", "n_head", "*", "d_k", ",", "bias", "=", "False", ")", "\n", "self", ".", "w_ks", "=", "nn", ".", "Linear", "(", "d_model", ",", "n_head", "*", "d_k", ",", "bias", "=", "False", ")", "\n", "self", ".", "w_vs", "=", "nn", ".", "Linear", "(", "d_model", ",", "n_head", "*", "d_v", ",", "bias", "=", "False", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "n_head", "*", "d_v", ",", "d_model", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "attention", "=", "ScaledDotProductAttention", "(", "temperature", "=", "d_k", "**", "0.5", ")", "\n", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.MultiHeadAttention.forward": [[104, 135], ["model.MultiHeadAttention.w_qs().view", "model.MultiHeadAttention.w_ks().view", "model.MultiHeadAttention.w_vs().view", "model.MultiHeadAttention.attention", "model.MultiHeadAttention.transpose().contiguous().view", "model.MultiHeadAttention.dropout", "model.MultiHeadAttention.layer_norm", "model.MultiHeadAttention.size", "model.MultiHeadAttention.size", "model.MultiHeadAttention.size", "model.MultiHeadAttention.size", "model.MultiHeadAttention.transpose", "model.MultiHeadAttention.transpose", "model.MultiHeadAttention.transpose", "mask.unsqueeze.unsqueeze.unsqueeze", "model.MultiHeadAttention.fc", "model.MultiHeadAttention.w_qs", "model.MultiHeadAttention.w_ks", "model.MultiHeadAttention.w_vs", "model.MultiHeadAttention.transpose().contiguous", "model.MultiHeadAttention.transpose"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "q", ",", "k", ",", "v", ",", "mask", "=", "None", ")", ":", "\n", "\n", "        ", "d_k", ",", "d_v", ",", "n_head", "=", "self", ".", "d_k", ",", "self", ".", "d_v", ",", "self", ".", "n_head", "\n", "sz_b", ",", "len_q", ",", "len_k", ",", "len_v", "=", "q", ".", "size", "(", "0", ")", ",", "q", ".", "size", "(", "1", ")", ",", "k", ".", "size", "(", "1", ")", ",", "v", ".", "size", "(", "1", ")", "\n", "\n", "residual", "=", "q", "\n", "\n", "# Pass through the pre-attention projection: b x lq x (n*dv)", "\n", "# Separate different heads: b x lq x n x dv", "\n", "q", "=", "self", ".", "w_qs", "(", "q", ")", ".", "view", "(", "sz_b", ",", "len_q", ",", "n_head", ",", "d_k", ")", "\n", "k", "=", "self", ".", "w_ks", "(", "k", ")", ".", "view", "(", "sz_b", ",", "len_k", ",", "n_head", ",", "d_k", ")", "\n", "v", "=", "self", ".", "w_vs", "(", "v", ")", ".", "view", "(", "sz_b", ",", "len_v", ",", "n_head", ",", "d_v", ")", "\n", "\n", "# Transpose for attention dot product: b x n x lq x dv", "\n", "q", ",", "k", ",", "v", "=", "q", ".", "transpose", "(", "1", ",", "2", ")", ",", "k", ".", "transpose", "(", "1", ",", "2", ")", ",", "v", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "mask", ".", "unsqueeze", "(", "1", ")", "# For head axis broadcasting.", "\n", "\n", "", "q", ",", "attn", "=", "self", ".", "attention", "(", "q", ",", "k", ",", "v", ",", "mask", "=", "mask", ")", "\n", "\n", "# Transpose to move the head dimension back: b x lq x n x dv", "\n", "# Combine the last two dimensions to concatenate all the heads together: b x lq x (n*dv)", "\n", "q", "=", "q", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "sz_b", ",", "len_q", ",", "-", "1", ")", "\n", "q", "=", "self", ".", "dropout", "(", "self", ".", "fc", "(", "q", ")", ")", "\n", "if", "self", ".", "use_residual", ":", "\n", "            ", "q", "+=", "residual", "\n", "\n", "", "q", "=", "self", ".", "layer_norm", "(", "q", ")", "\n", "\n", "return", "q", ",", "attn", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.RNNModel.__init__": [[142, 180], ["super().__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "model.MultiHeadAttention", "model.MultiHeadAttention", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "model.RNNModel.cells_mri.append", "range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "model.RNNModel.cells_pet.append", "celltype", "model.RNNModel.cells_mri.append", "celltype", "range", "int", "int", "int", "int", "celltype", "model.RNNModel.cells_pet.append", "celltype"], "methods", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__init__"], ["def", "__init__", "(", "self", ",", "celltype", ",", "nb_classes", ",", "nb_mri", ",", "nb_pet", ",", "h_mri", ",", "h_pet", ",", "h_drop", ",", "i_drop", ",", "nb_layers1", ",", "\n", "nb_layers2", ",", "alpha", ",", "beta", ",", "n_head", ")", ":", "\n", "        ", "super", "(", "RNNModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "h_ratio", "=", "1.", "-", "h_drop", "\n", "self", ".", "i_ratio", "=", "1.", "-", "i_drop", "\n", "\n", "# self.hid2category_mri = nn.Linear(h_mri, nb_classes)", "\n", "self", ".", "hid2measures_mri", "=", "nn", ".", "Linear", "(", "h_mri", "+", "h_pet", ",", "nb_mri", ")", "\n", "\n", "# self.hid2category_pet = nn.Linear(h_pet, nb_classes)", "\n", "self", ".", "hid2category", "=", "nn", ".", "Linear", "(", "h_pet", "+", "h_mri", ",", "nb_classes", ")", "\n", "self", ".", "hid2measures_pet1_1", "=", "nn", ".", "Linear", "(", "h_mri", ",", "h_mri", "//", "2", ")", "\n", "self", ".", "hid2measures_pet1_2", "=", "nn", ".", "Linear", "(", "h_mri", "//", "2", ",", "nb_pet", ")", "\n", "self", ".", "hid2measures_pet2", "=", "nn", ".", "Linear", "(", "h_mri", "+", "h_pet", ",", "nb_pet", ")", "\n", "\n", "self", ".", "h_mri", "=", "h_mri", "\n", "self", ".", "h_pet", "=", "h_pet", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "\n", "self", ".", "attention1", "=", "MultiHeadAttention", "(", "n_head", "=", "n_head", ",", "d_model", "=", "h_mri", ",", "\n", "d_k", "=", "int", "(", "(", "h_mri", ")", "/", "n_head", ")", ",", "d_v", "=", "int", "(", "(", "h_mri", ")", "/", "n_head", ")", ")", "\n", "self", ".", "attention2", "=", "MultiHeadAttention", "(", "n_head", "=", "n_head", ",", "d_model", "=", "h_mri", "*", "2", ",", "\n", "d_k", "=", "int", "(", "(", "h_mri", ")", "*", "2", "/", "n_head", ")", ",", "d_v", "=", "int", "(", "(", "h_mri", ")", "*", "2", "/", "n_head", ")", ")", "\n", "\n", "self", ".", "trans_fc", "=", "nn", ".", "Linear", "(", "h_mri", "*", "5", "+", "h_pet", "*", "5", ",", "2", ")", "\n", "self", ".", "fc_ac", "=", "nn", ".", "Softmax", "(", ")", "\n", "\n", "self", ".", "cells_mri", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "cells_mri", ".", "append", "(", "celltype", "(", "nb_mri", ",", "h_mri", ")", ")", "\n", "for", "_", "in", "range", "(", "1", ",", "nb_layers1", ")", ":", "\n", "            ", "self", ".", "cells_mri", ".", "append", "(", "celltype", "(", "h_mri", ",", "h_mri", ")", ")", "\n", "\n", "", "self", ".", "cells_pet", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "cells_pet", ".", "append", "(", "celltype", "(", "nb_pet", ",", "h_pet", ")", ")", "\n", "if", "nb_layers1", ">", "1", ":", "\n", "            ", "for", "_", "in", "range", "(", "1", ",", "nb_layers2", ")", ":", "\n", "                ", "self", ".", "cells_pet", ".", "append", "(", "celltype", "(", "h_pet", ",", "h_pet", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.RNNModel.init_hidden_state": [[181, 183], ["None"], "methods", ["None"], ["", "", "", "def", "init_hidden_state", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.RNNModel.dropout_mask_mri": [[184, 201], ["torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "next", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones.bernoulli_", "torch.ones.bernoulli_", "torch.ones.bernoulli_", "model.RNNModel.parameters", "mask.bernoulli_"], "methods", ["None"], ["", "def", "dropout_mask_mri", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "dev", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "i_mask", "=", "torch", ".", "ones", "(", "\n", "batch_size", ",", "self", ".", "hid2measures_mri", ".", "out_features", ",", "device", "=", "dev", ")", "\n", "r_mask", "=", "[", "\n", "torch", ".", "ones", "(", "batch_size", ",", "cell", ".", "hidden_size", ",", "device", "=", "dev", ")", "\n", "for", "cell", "in", "self", ".", "cells_mri", "\n", "]", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "i_mask", ".", "bernoulli_", "(", "self", ".", "i_ratio", ")", "\n", "for", "mask", "in", "r_mask", ":", "\n", "                ", "mask", ".", "bernoulli_", "(", "self", ".", "h_ratio", ")", "\n", "# i_mask = i_mask.bool()", "\n", "# for i, j in enumerate(r_mask):", "\n", "#     r_mask[i] = r_mask[i].bool()", "\n", "", "", "return", "i_mask", ",", "r_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.RNNModel.dropout_mask_pet": [[202, 219], ["torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "next", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones.bernoulli_", "torch.ones.bernoulli_", "torch.ones.bernoulli_", "model.RNNModel.parameters", "mask.bernoulli_"], "methods", ["None"], ["", "def", "dropout_mask_pet", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "dev", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "i_mask", "=", "torch", ".", "ones", "(", "\n", "batch_size", ",", "self", ".", "hid2measures_pet1_2", ".", "out_features", ",", "device", "=", "dev", ")", "\n", "r_mask", "=", "[", "\n", "torch", ".", "ones", "(", "batch_size", ",", "cell", ".", "hidden_size", ",", "device", "=", "dev", ")", "\n", "for", "cell", "in", "self", ".", "cells_pet", "\n", "]", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "i_mask", ".", "bernoulli_", "(", "self", ".", "i_ratio", ")", "\n", "for", "mask", "in", "r_mask", ":", "\n", "                ", "mask", ".", "bernoulli_", "(", "self", ".", "h_ratio", ")", "\n", "# i_mask = i_mask.bool()", "\n", "# for i, j in enumerate(r_mask):", "\n", "#     r_mask[i] = r_mask[i].bool()", "\n", "", "", "return", "i_mask", ",", "r_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.RNNModel.forward": [[220, 301], ["model.RNNModel.init_hidden_state", "model.RNNModel.dropout_mask_mri", "model.RNNModel.init_hidden_state_pet", "model.RNNModel.dropout_mask_pet", "_mri_seq.copy", "_pet_seq.copy", "zip", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.stack().permute", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.RNNModel.attention2", "torch.cat.reshape", "torch.cat.reshape", "torch.cat.reshape", "model.RNNModel.trans_fc", "model.RNNModel.fc_ac", "range", "range", "model.RNNModel.predict", "torch.tanh", "torch.tanh", "torch.tanh", "model.RNNModel.predict_pet", "model.RNNModel.hid2category", "out_cat_seq.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.RNNModel.attention1", "ht_set_new.view", "model.RNNModel.hid2category", "model.RNNModel.fc_ac", "out_cat_seq.append", "torch.stack().permute.append", "torch.stack().permute.append", "torch.stack().permute.append", "torch.stack().permute.append", "torch.stack().permute.append", "torch.stack().permute.append", "attns1.append", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "model.RNNModel.hid2measures_pet1_1", "model.RNNModel.hid2measures_pet1_2", "hidden_mri[].new", "pet_s_esti.append", "numpy.isnan", "pet_s_esti.append", "numpy.isnan", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.RNNModel.hid2measures_mri", "hidden_mri[].new", "model.RNNModel.hid2measures_pet2", "hidden_mri[].new", "len", "out_mri_seq.append", "numpy.isnan", "pet_f_esti.append", "numpy.isnan", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "len", "len", "torch.tanh.data.cpu().numpy", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mri_estimate.data.cpu().numpy", "pet_estimate2.data.cpu().numpy", "mri_h_t.unsqueeze", "pet_h_t.unsqueeze", "torch.tanh.data.cpu", "torch.tanh.data.cpu().numpy", "mri_estimate.data.cpu", "pet_estimate2.data.cpu", "torch.tanh.data.cpu"], "methods", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.SingleTimepoint.init_hidden_state", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.RNNModel.dropout_mask_mri", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.SingleTimepoint.init_hidden_state_pet", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.RNNModel.dropout_mask_pet", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.SingleTimepoint.predict", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.SingleTimepoint.predict_pet"], ["", "def", "forward", "(", "self", ",", "_mri_seq", ",", "_pet_seq", ")", ":", "\n", "        ", "out_cat_seq", ",", "out_mri_seq", "=", "[", "]", ",", "[", "]", "\n", "pet_s_esti", "=", "[", "]", "\n", "pet_f_esti", "=", "[", "]", "\n", "\n", "mri_h_out", "=", "[", "]", "\n", "pet_h_out", "=", "[", "]", "\n", "attns1", "=", "[", "]", "\n", "\n", "hidden_mri", "=", "self", ".", "init_hidden_state", "(", "_mri_seq", ".", "shape", "[", "1", "]", ")", "\n", "masks_mri", "=", "self", ".", "dropout_mask_mri", "(", "_mri_seq", ".", "shape", "[", "1", "]", ")", "\n", "\n", "hidden_pet", "=", "self", ".", "init_hidden_state_pet", "(", "_pet_seq", ".", "shape", "[", "1", "]", ")", "\n", "masks_pet", "=", "self", ".", "dropout_mask_pet", "(", "_pet_seq", ".", "shape", "[", "1", "]", ")", "\n", "\n", "# cat_seq = _cat_seq.copy()", "\n", "mri_seq", "=", "_mri_seq", ".", "copy", "(", ")", "\n", "pet_seq", "=", "_pet_seq", ".", "copy", "(", ")", "\n", "\n", "for", "i", ",", "j", "in", "zip", "(", "range", "(", "len", "(", "mri_seq", ")", "+", "1", ")", ",", "range", "(", "1", ",", "len", "(", "mri_seq", ")", "+", "1", ")", ")", ":", "\n", "            ", "hidden_mri", ",", "mri_h_t", "=", "self", ".", "predict", "(", "mri_seq", "[", "i", "]", ",", "hidden_mri", ",", "masks_mri", ")", "\n", "pet_estimate1", "=", "F", ".", "tanh", "(", "self", ".", "hid2measures_pet1_1", "(", "mri_h_t", ")", ")", "\n", "pet_estimate1", "=", "self", ".", "hid2measures_pet1_2", "(", "pet_estimate1", ")", "+", "hidden_mri", "[", "0", "]", ".", "new", "(", "mri_seq", "[", "i", "]", ")", "\n", "# out_cat_seq.append(o_cat)", "\n", "# mri_h_out.append(mri_h_t)", "\n", "if", "i", "==", "0", ":", "\n", "                ", "pet_s_esti", ".", "append", "(", "pet_estimate1", ")", "\n", "idx_f", "=", "np", ".", "isnan", "(", "_pet_seq", "[", "i", "]", ")", "\n", "pet_seq", "[", "i", "]", "[", "idx_f", "]", "=", "pet_estimate1", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "idx_f", "]", "\n", "", "else", ":", "\n", "                ", "pet_s_esti", ".", "append", "(", "pet_estimate1", ")", "\n", "idx_f", "=", "np", ".", "isnan", "(", "_pet_seq", "[", "i", "]", ")", "\n", "pet_seq", "[", "i", "]", "[", "idx_f", "]", "=", "self", ".", "alpha", "*", "pet_seq", "[", "i", "]", "[", "idx_f", "]", "+", "self", ".", "beta", "*", "pet_estimate1", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "idx_f", "]", "\n", "\n", "", "hidden_pet", ",", "pet_h_t", "=", "self", ".", "predict_pet", "(", "pet_seq", "[", "i", "]", ",", "hidden_pet", ",", "masks_pet", ")", "\n", "\n", "o_cat", "=", "self", ".", "hid2category", "(", "torch", ".", "cat", "(", "(", "mri_h_t", ",", "pet_h_t", ")", ",", "dim", "=", "-", "1", ")", ")", "\n", "\n", "mri_estimate", "=", "self", ".", "hid2measures_mri", "(", "torch", ".", "cat", "(", "(", "mri_h_t", ",", "pet_h_t", ")", ",", "dim", "=", "-", "1", ")", ")", "+", "hidden_mri", "[", "0", "]", ".", "new", "(", "mri_seq", "[", "i", "]", ")", "\n", "pet_estimate2", "=", "self", ".", "hid2measures_pet2", "(", "torch", ".", "cat", "(", "(", "mri_h_t", ",", "pet_h_t", ")", ",", "dim", "=", "-", "1", ")", ")", "+", "hidden_mri", "[", "0", "]", ".", "new", "(", "\n", "pet_seq", "[", "i", "]", ")", "\n", "\n", "out_cat_seq", ".", "append", "(", "o_cat", ")", "\n", "# pet_cat_seq.append(pet_cat)", "\n", "# pet_h_out.append(pet_h_t)", "\n", "\n", "# fill in the missing features of the next timepoint", "\n", "if", "j", "<", "len", "(", "mri_seq", ")", ":", "\n", "                ", "out_mri_seq", ".", "append", "(", "mri_estimate", ")", "\n", "idx", "=", "np", ".", "isnan", "(", "_mri_seq", "[", "j", "]", ")", "\n", "mri_seq", "[", "j", "]", "[", "idx", "]", "=", "mri_estimate", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "idx", "]", "\n", "\n", "pet_f_esti", ".", "append", "(", "pet_estimate2", ")", "\n", "idx_f", "=", "np", ".", "isnan", "(", "_pet_seq", "[", "j", "]", ")", "\n", "pet_seq", "[", "j", "]", "[", "idx_f", "]", "=", "pet_estimate2", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "idx_f", "]", "\n", "\n", "", "ht_set", "=", "torch", ".", "cat", "(", "(", "mri_h_t", ".", "unsqueeze", "(", "1", ")", ",", "pet_h_t", ".", "unsqueeze", "(", "1", ")", ")", ",", "dim", "=", "1", ")", "\n", "ht_set_new", ",", "attn1", "=", "self", ".", "attention1", "(", "ht_set", ",", "ht_set", ",", "ht_set", ")", "\n", "\n", "_ht_set_new", "=", "ht_set_new", ".", "view", "(", "batch_size", ",", "-", "1", ")", "\n", "o_cat", "=", "self", ".", "hid2category", "(", "_ht_set_new", ")", "\n", "o_cat", "=", "self", ".", "fc_ac", "(", "o_cat", ")", "\n", "out_cat_seq", ".", "append", "(", "o_cat", ")", "\n", "# pet_cat_seq.append(pet_cat)", "\n", "mri_h_out", ".", "append", "(", "ht_set_new", "[", ":", ",", "0", ",", ":", "]", ")", "\n", "pet_h_out", ".", "append", "(", "ht_set_new", "[", ":", ",", "1", ",", ":", "]", ")", "\n", "attns1", ".", "append", "(", "attn1", ")", "\n", "\n", "", "mri_h_out", "=", "torch", ".", "stack", "(", "mri_h_out", ")", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "pet_h_out", "=", "torch", ".", "stack", "(", "pet_h_out", ")", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "\n", "h_out", "=", "torch", ".", "cat", "(", "(", "mri_h_out", ",", "pet_h_out", ")", ",", "dim", "=", "-", "1", ")", "\n", "h_out", ",", "attn2", "=", "self", ".", "attention2", "(", "h_out", ",", "h_out", ",", "h_out", ")", "\n", "h_out_new", "=", "h_out", ".", "reshape", "(", "batch_size", ",", "-", "1", ")", "\n", "\n", "trans_out", "=", "self", ".", "trans_fc", "(", "h_out_new", ")", "\n", "trans_out", "=", "self", ".", "fc_ac", "(", "trans_out", ")", "\n", "\n", "return", "torch", ".", "stack", "(", "out_cat_seq", ")", ",", "torch", ".", "stack", "(", "out_mri_seq", ")", ",", "torch", ".", "stack", "(", "pet_s_esti", ")", ",", "torch", ".", "stack", "(", "pet_f_esti", ")", ",", "trans_out", ",", "attns1", ",", "attn2", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.SingleTimepoint.init_hidden_state": [[309, 315], ["next", "state.append", "model.SingleTimepoint.parameters", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["def", "init_hidden_state", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "dev", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "state", "=", "[", "]", "\n", "for", "cell", "in", "self", ".", "cells_mri", ":", "\n", "            ", "state", ".", "append", "(", "torch", ".", "zeros", "(", "batch_size", ",", "cell", ".", "hidden_size", ",", "device", "=", "dev", ")", ")", "\n", "", "return", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.SingleTimepoint.init_hidden_state_pet": [[316, 322], ["next", "state.append", "model.SingleTimepoint.parameters", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "init_hidden_state_pet", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "dev", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "state", "=", "[", "]", "\n", "for", "cell", "in", "self", ".", "cells_pet", ":", "\n", "            ", "state", ".", "append", "(", "torch", ".", "zeros", "(", "batch_size", ",", "cell", ".", "hidden_size", ",", "device", "=", "dev", ")", ")", "\n", "", "return", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.SingleTimepoint.predict": [[323, 336], ["zip", "hid[].new", "cell", "next_hid.append"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "i_val", ",", "hid", ",", "masks", ")", ":", "\n", "        ", "i_mask", ",", "r_mask", "=", "masks", "\n", "h_t", "=", "hid", "[", "0", "]", ".", "new", "(", "i_val", ")", "*", "i_mask", "\n", "\n", "next_hid", "=", "[", "]", "\n", "for", "cell", ",", "prev_h", ",", "mask", "in", "zip", "(", "self", ".", "cells_mri", ",", "hid", ",", "r_mask", ")", ":", "\n", "            ", "h_t", "=", "cell", "(", "h_t", ",", "prev_h", "*", "mask", ")", "\n", "next_hid", ".", "append", "(", "h_t", ")", "\n", "\n", "# mri_estimate = self.hid2measures_mri(h_t) + hid[0].new(i_val)", "\n", "# pet_estimate1 = self.hid2measures_pet1(h_t) + hid[0].new(i_val)", "\n", "\n", "", "return", "next_hid", ",", "h_t", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.SingleTimepoint.predict_pet": [[337, 349], ["zip", "hid[].new", "cell", "next_hid.append"], "methods", ["None"], ["", "def", "predict_pet", "(", "self", ",", "i_val", ",", "hid", ",", "masks", ")", ":", "\n", "        ", "i_mask", ",", "r_mask", "=", "masks", "\n", "h_t", "=", "hid", "[", "0", "]", ".", "new", "(", "i_val", ")", "*", "i_mask", "\n", "\n", "next_hid", "=", "[", "]", "\n", "for", "cell", ",", "prev_h", ",", "mask", "in", "zip", "(", "self", ".", "cells_pet", ",", "hid", ",", "r_mask", ")", ":", "\n", "            ", "h_t", "=", "cell", "(", "h_t", ",", "prev_h", "*", "mask", ")", "\n", "next_hid", ".", "append", "(", "h_t", ")", "\n", "\n", "# mri_estimate = self.hid2measures_pet(h_t) + hid[0].new(i_val)", "\n", "\n", "", "return", "next_hid", ",", "h_t", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.MinimalRNN.__init__": [[354, 358], ["model.RNNModel.__init__", "model.gate_init"], "methods", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__init__", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.gate_init"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "MinimalRNN", ",", "self", ")", ".", "__init__", "(", "MinimalRNNCell", ",", "**", "kwargs", ")", "\n", "for", "cell", "in", "self", ".", "cells_mri", ":", "\n", "            ", "gate_init", "(", "cell", ".", "bias_hh", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.GRU.__init__": [[363, 367], ["model.RNNModel.__init__", "model.gate_init"], "methods", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__init__", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.gate_init"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "GRU", ",", "self", ")", ".", "__init__", "(", "nn", ".", "GRUCell", ",", "**", "kwargs", ")", "\n", "for", "cell", "in", "self", ".", "cells_mri", ":", "\n", "            ", "gate_init", "(", "cell", ".", "bias_hh", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.Discriminator.__init__": [[371, 376], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "int", "int"], "methods", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__init__"], ["    ", "def", "__init__", "(", "self", ",", "x", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "x", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "1", "]", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "x", ".", "shape", "[", "1", "]", ",", "int", "(", "x", ".", "shape", "[", "1", "]", ")", "//", "2", ")", "\n", "self", ".", "linear3", "=", "nn", ".", "Linear", "(", "int", "(", "x", ".", "shape", "[", "1", "]", ")", "//", "2", ",", "x", ".", "shape", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.Discriminator.forward": [[377, 382], ["torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "model.Discriminator.linear1", "model.Discriminator.linear2", "model.Discriminator.linear3", "x.float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x1", "=", "F", ".", "tanh", "(", "self", ".", "linear1", "(", "x", ".", "float", "(", ")", ")", ")", "\n", "x2", "=", "F", ".", "tanh", "(", "self", ".", "linear2", "(", "x1", ")", ")", "\n", "predict_mask", "=", "F", ".", "sigmoid", "(", "self", ".", "linear3", "(", "x2", ")", ")", "\n", "return", "predict_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.model.gate_init": [[14, 22], ["forget_gate.data.fill_"], "function", ["None"], ["def", "gate_init", "(", "forget_gate", ")", ":", "\n", "    ", "\"\"\"\n    Initialize the forget gaste bias to 1\n    Args:\n        forget_gate: forget gate bias term\n    References: https://arxiv.org/abs/1602.02410\n    \"\"\"", "\n", "forget_gate", ".", "data", ".", "fill_", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.to_categorical": [[24, 36], ["numpy.full", "len", "y.squeeze.squeeze", "numpy.isnan", "len", "y[].astype"], "function", ["None"], ["def", "to_categorical", "(", "y", ",", "nb_classes", ")", ":", "\n", "    ", "\"\"\" Convert list of labels to one-hot vectors \"\"\"", "\n", "if", "len", "(", "y", ".", "shape", ")", "==", "2", ":", "\n", "        ", "y", "=", "y", ".", "squeeze", "(", "1", ")", "\n", "\n", "", "ret_mat", "=", "np", ".", "full", "(", "(", "len", "(", "y", ")", ",", "nb_classes", ")", ",", "np", ".", "nan", ")", "\n", "good", "=", "~", "np", ".", "isnan", "(", "y", ")", "\n", "\n", "ret_mat", "[", "good", "]", "=", "0", "\n", "ret_mat", "[", "good", ",", "y", "[", "good", "]", ".", "astype", "(", "int", ")", "]", "=", "1.", "\n", "\n", "return", "ret_mat", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.ent_loss": [[38, 61], ["isinstance", "pred.reshape.reshape", "mask.reshape.reshape", "pred.reshape.new_tensor", "isinstance", "isinstance", "torch.cross_entropy", "pred.reshape.size", "pred.reshape.size", "true.reshape", "pred.reshape.new_tensor", "mask.reshape.squeeze().astype", "mask.reshape.squeeze"], "function", ["None"], ["", "def", "ent_loss", "(", "pred", ",", "true", ",", "mask", ")", ":", "\n", "    ", "\"\"\"\n    Calculate cross-entropy loss\n    Args:\n        pred: predicted probability distribution,\n              [nb_timpoints, nb_subjects, nb_classes]\n        true: true class, [nb_timpoints, nb_subjects, 1]\n        mask: timepoints to evaluate, [nb_timpoints, nb_subjects, 1]\n    Returns:\n        cross-entropy loss\n    \"\"\"", "\n", "assert", "isinstance", "(", "pred", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "true", ",", "np", ".", "ndarray", ")", "and", "isinstance", "(", "mask", ",", "np", ".", "ndarray", ")", "\n", "nb_subjects", "=", "true", ".", "shape", "[", "1", "]", "\n", "\n", "pred", "=", "pred", ".", "reshape", "(", "pred", ".", "size", "(", "0", ")", "*", "pred", ".", "size", "(", "1", ")", ",", "-", "1", ")", "\n", "mask", "=", "mask", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "o_true", "=", "pred", ".", "new_tensor", "(", "true", ".", "reshape", "(", "-", "1", ",", "1", ")", "[", "mask", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "o_pred", "=", "pred", "[", "pred", ".", "new_tensor", "(", "\n", "mask", ".", "squeeze", "(", "1", ")", ".", "astype", "(", "np", ".", "bool", ")", ",", "dtype", "=", "torch", ".", "bool", ")", "]", "\n", "return", "F", ".", "cross_entropy", "(", "\n", "o_pred", ",", "o_true", ",", "reduction", "=", "'sum'", ")", "/", "nb_subjects", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.ent_loss_trans": [[63, 72], ["isinstance", "isinstance", "pred.new_tensor().squeeze", "torch.cross_entropy", "pred.new_tensor", "true.reshape"], "function", ["None"], ["", "def", "ent_loss_trans", "(", "pred", ",", "true", ")", ":", "\n", "    ", "assert", "isinstance", "(", "pred", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "true", ",", "np", ".", "ndarray", ")", "\n", "nb_subjects", "=", "true", ".", "shape", "[", "0", "]", "\n", "\n", "o_true", "=", "pred", ".", "new_tensor", "(", "true", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "dtype", "=", "torch", ".", "long", ")", ".", "squeeze", "(", ")", "\n", "# o_pred = pred[pred.new_tensor(dtype=torch.uint8)]", "\n", "return", "F", ".", "cross_entropy", "(", "\n", "pred", ",", "o_true", ",", "reduction", "=", "'sum'", ")", "/", "nb_subjects", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.mae_loss": [[74, 95], ["isinstance", "pred.new_tensor", "isinstance", "isinstance", "invalid.astype", "torch.l1_loss", "pred.new"], "function", ["None"], ["", "def", "mae_loss", "(", "pred", ",", "true", ",", "mask", ")", ":", "\n", "    ", "\"\"\"\n    Calculate mean absolute error (MAE)\n    Args:\n        pred: predicted values, [nb_timpoints, nb_subjects, nb_features]\n        true: true values, [nb_timpoints, nb_subjects, nb_features]\n        mask: values to evaluate, [nb_timpoints, nb_subjects, nb_features]\n    Returns:\n        MAE loss\n    \"\"\"", "\n", "assert", "isinstance", "(", "pred", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "true", ",", "np", ".", "ndarray", ")", "and", "isinstance", "(", "mask", ",", "np", ".", "ndarray", ")", "\n", "nb_subjects", "=", "true", ".", "shape", "[", "1", "]", "\n", "\n", "invalid", "=", "~", "mask", "\n", "true", "[", "invalid", "]", "=", "0", "\n", "indices", "=", "pred", ".", "new_tensor", "(", "invalid", ".", "astype", "(", "np", ".", "bool", ")", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "assert", "pred", ".", "shape", "==", "indices", ".", "shape", "\n", "pred", "[", "indices", "]", "=", "0", "\n", "return", "F", ".", "l1_loss", "(", "\n", "pred", ",", "pred", ".", "new", "(", "true", ")", ",", "reduction", "=", "'sum'", ")", "/", "nb_subjects", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.CB_loss_new": [[97, 111], ["pred.reshape.reshape", "mask.reshape.reshape", "pred.reshape.new_tensor", "utils.CB_loss", "pred.reshape.size", "pred.reshape.size", "true.reshape", "pred.reshape.new_tensor", "mask.reshape.squeeze().astype", "mask.reshape.squeeze"], "function", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.CB_loss"], ["", "def", "CB_loss_new", "(", "pred", ",", "true", ",", "mask", ")", ":", "\n", "    ", "nb_subjects", "=", "true", ".", "shape", "[", "1", "]", "\n", "\n", "pred", "=", "pred", ".", "reshape", "(", "pred", ".", "size", "(", "0", ")", "*", "pred", ".", "size", "(", "1", ")", ",", "-", "1", ")", "\n", "mask", "=", "mask", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "o_true", "=", "pred", ".", "new_tensor", "(", "true", ".", "reshape", "(", "-", "1", ",", "1", ")", "[", "mask", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "o_pred", "=", "pred", "[", "pred", ".", "new_tensor", "(", "\n", "mask", ".", "squeeze", "(", "1", ")", ".", "astype", "(", "np", ".", "uint8", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "]", "\n", "\n", "focal_loss", "=", "CB_loss", "(", "o_true", ",", "o_pred", ",", "[", "2330", ",", "580", "]", ",", "2", ",", "'focal'", ",", "0.8", ",", "5", ")", "\n", "focal_loss", "=", "(", "focal_loss", "*", "o_pred", ".", "shape", "[", "0", "]", ")", "/", "nb_subjects", "\n", "\n", "return", "focal_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.trans_label": [[113, 122], ["numpy.array", "trans.append", "trans.append"], "function", ["None"], ["", "def", "trans_label", "(", "label_seq", ")", ":", "\n", "    ", "trans", "=", "[", "]", "\n", "for", "i", "in", "label_seq", ":", "\n", "        ", "if", "1", "in", "i", ":", "\n", "            ", "trans", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "trans", ".", "append", "(", "0", ")", "\n", "\n", "", "", "return", "np", ".", "array", "(", "trans", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.model_eval": [[124, 138], ["smri_seq.transpose.transpose", "pet_seq.transpose.transpose", "model", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "run.trans_label", "numpy.equal().sum", "sklearn.metrics.roc_auc_score", "utils.calcBCA", "eval_pred_trans[].cpu().numpy", "torch.argmax().cpu", "torch.argmax().cpu", "numpy.equal", "eval_pred_trans[].cpu", "torch.argmax", "torch.argmax"], "function", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.trans_label", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.calcBCA"], ["", "def", "model_eval", "(", "smri_seq", ",", "pet_seq", ",", "label_seq", ",", "model", ")", ":", "\n", "    ", "smri_seq", "=", "smri_seq", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "pet_seq", "=", "pet_seq", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "eval_pred_cat", ",", "eval_pred_val", ",", "eval_pred_pet_val1", ",", "eval_pred_pet_val2", ",", "eval_pred_trans", "=", "model", "(", "smri_seq", ",", "pet_seq", ")", "\n", "\n", "eval_pred_trans_seq", "=", "torch", ".", "argmax", "(", "eval_pred_trans", ",", "dim", "=", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "eval_cat_last", "=", "trans_label", "(", "label_seq", ")", "\n", "eval_correct2", "=", "np", ".", "equal", "(", "eval_pred_trans_seq", ",", "eval_cat_last", ")", ".", "sum", "(", ")", "\n", "\n", "eval_acc", "=", "eval_correct2", "/", "eval_cat_last", ".", "shape", "[", "0", "]", "\n", "eval_auc", "=", "roc_auc_score", "(", "eval_cat_last", ",", "eval_pred_trans", "[", ":", ",", "1", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "eval_bca", "=", "calcBCA", "(", "eval_pred_trans_seq", ",", "eval_cat_last", ",", "2", ")", "\n", "return", "eval_acc", ",", "eval_auc", ",", "eval_bca", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.impute": [[140, 156], ["mask.permute.permute", "true.float.permute", "torch.where", "torch.where", "pred.float.float", "true.float.float", "true_later.clone", "torch.cat", "torch.cat"], "function", ["None"], ["", "def", "impute", "(", "pred", ",", "true", ",", "mask", ")", ":", "\n", "    ", "mask", "=", "mask", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "true", "=", "true", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "mask_later", "=", "mask", "[", "1", ":", "]", "\n", "idx", "=", "torch", ".", "where", "(", "mask_later", "==", "False", ")", "\n", "pred", "=", "pred", ".", "float", "(", ")", "\n", "true", "=", "true", ".", "float", "(", ")", "\n", "true_previous", "=", "true", "[", ":", "1", "]", "\n", "true_later", "=", "true", "[", "1", ":", "]", "\n", "\n", "new_val", "=", "true_later", ".", "clone", "(", ")", "\n", "# a = new_val.clone()", "\n", "new_val", "[", "idx", "]", "=", "pred", "[", "idx", "]", "\n", "new_val", "=", "torch", ".", "cat", "(", "(", "true_previous", ",", "new_val", ")", ",", "dim", "=", "0", ")", "\n", "\n", "return", "new_val", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.discriminator_loss": [[158, 168], ["isinstance", "isinstance", "pred.new_tensor().squeeze", "torch.binary_cross_entropy", "pred.new_tensor"], "function", ["None"], ["", "def", "discriminator_loss", "(", "pred", ",", "mask", ")", ":", "\n", "    ", "assert", "isinstance", "(", "pred", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "mask", ",", "torch", ".", "Tensor", ")", "\n", "nb_subjects", "=", "mask", ".", "shape", "[", "0", "]", "\n", "\n", "o_mask", "=", "pred", ".", "new_tensor", "(", "mask", ",", "dtype", "=", "torch", ".", "float", ")", ".", "squeeze", "(", ")", "\n", "\n", "loss", "=", "F", ".", "binary_cross_entropy", "(", "pred", ",", "o_mask", ",", "reduction", "=", "'sum'", ")", "/", "nb_subjects", "\n", "# loss = (loss_fake + loss_real) / nb_subjects", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.run.adversarial_loss": [[170, 183], ["isinstance", "prob.new_tensor().squeeze", "torch.where", "torch.where", "torch.autograd.Variable().to", "torch.binary_cross_entropy", "prob.new_tensor", "torch.autograd.Variable", "torch.Tensor().fill_", "torch.Tensor().fill_", "torch.Tensor", "torch.Tensor"], "function", ["None"], ["", "def", "adversarial_loss", "(", "prob", ",", "mask", ")", ":", "\n", "    ", "assert", "isinstance", "(", "mask", ",", "torch", ".", "Tensor", ")", "\n", "nb_subjects", "=", "mask", ".", "shape", "[", "0", "]", "\n", "\n", "o_mask", "=", "prob", ".", "new_tensor", "(", "mask", ",", "dtype", "=", "torch", ".", "long", ")", ".", "squeeze", "(", ")", "\n", "idx", "=", "torch", ".", "where", "(", "o_mask", "==", "0", ")", "\n", "label", "=", "Variable", "(", "torch", ".", "Tensor", "(", "idx", "[", "0", "]", ".", "shape", "[", "0", "]", ")", ".", "fill_", "(", "1.0", ")", ",", "requires_grad", "=", "False", ")", ".", "to", "(", "device", ")", "\n", "prob_new", "=", "prob", "[", "idx", "]", "\n", "# loss = -1 / torch.log(1-prob_new)", "\n", "\n", "loss", "=", "F", ".", "binary_cross_entropy", "(", "prob_new", ",", "label", ")", "\n", "# loss = torch.sum(loss)", "\n", "return", "loss", "/", "nb_subjects", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.FocalLoss.__init__": [[58, 65], ["torch.Module.__init__", "isinstance", "isinstance", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__init__"], ["    ", "def", "__init__", "(", "self", ",", "gamma", "=", "0", ",", "alpha", "=", "None", ",", "size_average", "=", "True", ")", ":", "\n", "        ", "super", "(", "FocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "alpha", "=", "alpha", "\n", "if", "isinstance", "(", "alpha", ",", "(", "float", ",", "int", ")", ")", ":", "self", ".", "alpha", "=", "torch", ".", "Tensor", "(", "[", "alpha", ",", "1", "-", "alpha", "]", ")", "\n", "if", "isinstance", "(", "alpha", ",", "list", ")", ":", "self", ".", "alpha", "=", "torch", ".", "Tensor", "(", "alpha", ")", "\n", "self", ".", "size_average", "=", "size_average", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.FocalLoss.forward": [[66, 87], ["target.view.view.view", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "logpt.view.view.gather", "logpt.view.view.view", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "input.contiguous().view.contiguous().view.dim", "input.contiguous().view.contiguous().view.view", "input.contiguous().view.contiguous().view.transpose", "input.contiguous().view.contiguous().view.contiguous().view", "logpt.view.view.data.exp", "utils.FocalLoss.alpha.gather", "loss.mean", "loss.sum", "input.contiguous().view.contiguous().view.size", "input.contiguous().view.contiguous().view.size", "input.contiguous().view.contiguous().view.size", "utils.FocalLoss.alpha.type", "input.contiguous().view.contiguous().view.data.type", "utils.FocalLoss.alpha.type_as", "target.view.view.data.view", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "input.contiguous().view.contiguous().view.contiguous"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "if", "input", ".", "dim", "(", ")", ">", "2", ":", "\n", "            ", "input", "=", "input", ".", "view", "(", "input", ".", "size", "(", "0", ")", ",", "input", ".", "size", "(", "1", ")", ",", "-", "1", ")", "# N,C,H,W => N,C,H*W", "\n", "input", "=", "input", ".", "transpose", "(", "1", ",", "2", ")", "# N,C,H*W => N,H*W,C", "\n", "input", "=", "input", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "input", ".", "size", "(", "2", ")", ")", "# N,H*W,C => N*H*W,C", "\n", "", "target", "=", "target", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "logpt", "=", "F", ".", "log_softmax", "(", "input", ")", "\n", "logpt", "=", "logpt", ".", "gather", "(", "1", ",", "target", ")", "\n", "logpt", "=", "logpt", ".", "view", "(", "-", "1", ")", "\n", "pt", "=", "Variable", "(", "logpt", ".", "data", ".", "exp", "(", ")", ")", "\n", "\n", "if", "self", ".", "alpha", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "alpha", ".", "type", "(", ")", "!=", "input", ".", "data", ".", "type", "(", ")", ":", "\n", "                ", "self", ".", "alpha", "=", "self", ".", "alpha", ".", "type_as", "(", "input", ".", "data", ")", "\n", "", "at", "=", "self", ".", "alpha", ".", "gather", "(", "0", ",", "target", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "logpt", "=", "logpt", "*", "Variable", "(", "at", ")", "\n", "\n", "", "loss", "=", "-", "1", "*", "(", "1", "-", "pt", ")", "**", "self", ".", "gamma", "*", "logpt", "\n", "if", "self", ".", "size_average", ":", "return", "loss", ".", "mean", "(", ")", "\n", "else", ":", "return", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.Vividict.__missing__": [[343, 346], ["type"], "methods", ["None"], ["    ", "def", "__missing__", "(", "self", ",", "key", ")", ":", "\n", "        ", "value", "=", "self", "[", "key", "]", "=", "type", "(", "self", ")", "(", ")", "\n", "return", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset1.__init__": [[361, 368], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data", ",", "label1", ",", "label2", ",", "mask_data", ",", "mask_label", ")", ":", "\n", "        ", "self", ".", "x_data", "=", "data", "\n", "self", ".", "y_data1", "=", "label1", "\n", "self", ".", "y_data2", "=", "label2", "\n", "self", ".", "mask_data", "=", "mask_data", "\n", "self", ".", "mask_label", "=", "mask_label", "\n", "self", ".", "len", "=", "data", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset1.__getitem__": [[369, 371], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "x_data", "[", "index", "]", ",", "self", ".", "y_data1", "[", "index", "]", ",", "self", ".", "y_data2", "[", "index", "]", ",", "self", ".", "mask_data", "[", "index", "]", ",", "self", ".", "mask_label", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset1.__len__": [[372, 374], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "len", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__init__": [[381, 388], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data", ",", "label1", ",", "label2", ",", "mask_data", ",", "mask_label", ")", ":", "\n", "        ", "self", ".", "x_data", "=", "data", "\n", "self", ".", "y_data1", "=", "label1", "\n", "self", ".", "y_data2", "=", "label2", "\n", "self", ".", "mask_data", "=", "mask_data", "\n", "self", ".", "mask_label", "=", "mask_label", "\n", "self", ".", "len", "=", "data", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__getitem__": [[389, 391], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "x_data", "[", "index", "]", ",", "self", ".", "y_data1", "[", "index", "]", ",", "self", ".", "y_data2", "[", "index", "]", ",", "self", ".", "mask_data", "[", "index", "]", ",", "self", ".", "mask_label", "[", "index", "]", ",", "index", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.DealDataset2.__len__": [[391, 393], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "len", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.a_value": [[11, 55], ["sorted", "enumerate", "float", "expanded_points.append", "instance[].item", "instance[].item"], "function", ["None"], ["def", "a_value", "(", "probabilities", ",", "zero_label", "=", "0", ",", "one_label", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Approximates the AUC by the method described in Hand and Till 2001,\n    equation 3.\n    NB: The class labels should be in the set [0,n-1] where n = # of classes.\n    The class probability should be at the index of its label in the\n    probability list.\n    I.e. With 3 classes the labels should be 0, 1, 2. The class probability\n    for class '1' will be found in index 1 in the class probability list\n    wrapped inside the zipped list with the labels.\n    Args:\n        probabilities (list): A zipped list of the labels and the\n            class probabilities in the form (m = # data instances):\n             [(label1, [p(x1c1), p(x1c2), ... p(x1cn)]),\n              (label2, [p(x2c1), p(x2c2), ... p(x2cn)])\n                             ...\n              (labelm, [p(xmc1), p(xmc2), ... (pxmcn)])\n             ]\n        zero_label (optional, int): The label to use as the class '0'.\n            Must be an integer, see above for details.\n        one_label (optional, int): The label to use as the class '1'.\n            Must be an integer, see above for details.\n    Returns:\n        The A-value as a floating point.\n    \"\"\"", "\n", "# Obtain a list of the probabilities for the specified zero label class", "\n", "expanded_points", "=", "[", "]", "\n", "for", "instance", "in", "probabilities", ":", "\n", "        ", "if", "instance", "[", "0", "]", "==", "zero_label", "or", "instance", "[", "0", "]", "==", "one_label", ":", "\n", "            ", "expanded_points", ".", "append", "(", "(", "instance", "[", "0", "]", ".", "item", "(", ")", ",", "instance", "[", "zero_label", "+", "1", "]", ".", "item", "(", ")", ")", ")", "\n", "", "", "sorted_ranks", "=", "sorted", "(", "expanded_points", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "\n", "\n", "n0", ",", "n1", ",", "sum_ranks", "=", "0", ",", "0", ",", "0", "\n", "# Iterate through ranks and increment counters for overall count and ranks of class 0", "\n", "for", "index", ",", "point", "in", "enumerate", "(", "sorted_ranks", ")", ":", "\n", "        ", "if", "point", "[", "0", "]", "==", "zero_label", ":", "\n", "            ", "n0", "+=", "1", "\n", "sum_ranks", "+=", "index", "+", "1", "# Add 1 as ranks are one-based", "\n", "", "elif", "point", "[", "0", "]", "==", "one_label", ":", "\n", "            ", "n1", "+=", "1", "\n", "", "else", ":", "\n", "            ", "pass", "# Not interested in this class", "\n", "\n", "", "", "return", "(", "sum_ranks", "-", "(", "n0", "*", "(", "n0", "+", "1", ")", "/", "2.0", ")", ")", "/", "float", "(", "n0", "*", "n1", ")", "# Eqn 3", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.focal_loss": [[88, 117], ["torch.softmax", "torch.softmax", "torch.softmax", "torch.binary_cross_entropy", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.exp", "torch.exp", "torch.exp", "torch.log", "torch.log", "torch.log", "torch.exp", "torch.exp", "torch.exp"], "function", ["None"], ["", "", "def", "focal_loss", "(", "labels", ",", "logits", ",", "alpha", ",", "gamma", ")", ":", "\n", "    ", "\"\"\"Compute the focal loss between `logits` and the ground truth `labels`.\n    Focal loss = -alpha_t * (1-pt)^gamma * log(pt)\n    where pt is the probability of being classified to the true class.\n    pt = p (if true class), otherwise pt = 1 - p. p = sigmoid(logit).\n    Args:\n      labels: A float tensor of size [batch, num_classes].\n      logits: A float tensor of size [batch, num_classes].\n      alpha: A float tensor of size [batch_size]\n        specifying per-example weight for balanced cross entropy.\n      gamma: A float scalar modulating loss from hard and easy examples.\n    Returns:\n      focal_loss: A float32 scalar representing normalized total loss.\n    \"\"\"", "\n", "logits", "=", "torch", ".", "softmax", "(", "logits", ",", "dim", "=", "1", ")", "\n", "BCLoss", "=", "F", ".", "binary_cross_entropy", "(", "input", "=", "logits", ",", "target", "=", "labels", ",", "reduction", "=", "\"none\"", ")", "\n", "\n", "if", "gamma", "==", "0.0", ":", "\n", "        ", "modulator", "=", "1.0", "\n", "", "else", ":", "\n", "        ", "modulator", "=", "torch", ".", "exp", "(", "-", "gamma", "*", "labels", "*", "logits", "-", "gamma", "*", "torch", ".", "log", "(", "1", "+", "torch", ".", "exp", "(", "-", "1.0", "*", "logits", ")", ")", ")", "\n", "\n", "", "loss", "=", "modulator", "*", "BCLoss", "\n", "\n", "weighted_loss", "=", "alpha", "*", "loss", "\n", "focal_loss", "=", "torch", ".", "sum", "(", "weighted_loss", ")", "\n", "\n", "focal_loss", "/=", "torch", ".", "sum", "(", "labels", ")", "\n", "return", "focal_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.get_focal_loss_weight": [[118, 141], ["torch.exp", "torch.exp", "torch.exp", "torch.log", "torch.log", "torch.log", "torch.exp", "torch.exp", "torch.exp"], "function", ["None"], ["", "def", "get_focal_loss_weight", "(", "labels", ",", "logits", ",", "alpha", ",", "gamma", ")", ":", "\n", "    ", "\"\"\"Compute the focal loss between `logits` and the ground truth `labels`.\n    Focal loss = -alpha_t * (1-pt)^gamma * log(pt)\n    where pt is the probability of being classified to the true class.\n    pt = p (if true class), otherwise pt = 1 - p. p = sigmoid(logit).\n    Args:\n      labels: A float tensor of size [batch, num_classes].\n      logits: A float tensor of size [batch, num_classes].\n      alpha: A float tensor of size [batch_size]\n        specifying per-example weight for balanced cross entropy.\n      gamma: A float scalar modulating loss from hard and easy examples.\n    Returns:\n      focal_loss: A float32 scalar representing normalized total loss.\n    \"\"\"", "\n", "# BCLoss = F.binary_cross_entropy_with_logits(input = logits, target = labels,reduction = \"none\")", "\n", "\n", "if", "gamma", "==", "0.0", ":", "\n", "        ", "modulator", "=", "1.0", "\n", "", "else", ":", "\n", "        ", "modulator", "=", "torch", ".", "exp", "(", "-", "gamma", "*", "labels", "*", "logits", "-", "gamma", "*", "torch", ".", "log", "(", "1", "+", "\n", "torch", ".", "exp", "(", "-", "1.0", "*", "logits", ")", ")", ")", "\n", "\n", "", "return", "modulator", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.getcb_weigth": [[142, 170], ["numpy.power", "numpy.array", "numpy.sum"], "function", ["None"], ["", "def", "getcb_weigth", "(", "samples_per_cls", ",", "no_of_classes", ",", "beta", ")", ":", "\n", "        ", "\"\"\"Compute the Class Balanced Loss between `logits` and the ground truth `labels`.\n        Class Balanced Loss: ((1-beta)/(1-beta^n))*Loss(labels, logits)\n        where Loss is one of the standard losses used for Neural Networks.\n        Args:\n          labels: A int tensor of size [batch].\n          logits: A float tensor of size [batch, no_of_classes].\n          samples_per_cls: A python list of size [no_of_classes].\n          no_of_classes: total number of classes. int\n          loss_type: string. One of \"sigmoid\", \"focal\", \"softmax\".\n          beta: float. Hyperparameter for Class balanced loss.\n          gamma: float. Hyperparameter for Focal loss.\n        Returns:\n          cb_loss: A float tensor representing class balanced loss\n        \"\"\"", "\n", "effective_num", "=", "1.0", "-", "np", ".", "power", "(", "beta", ",", "samples_per_cls", ")", "\n", "weights", "=", "(", "1.0", "-", "beta", ")", "/", "np", ".", "array", "(", "effective_num", ")", "\n", "weights", "=", "weights", "/", "np", ".", "sum", "(", "weights", ")", "*", "no_of_classes", "\n", "\n", "# labels_one_hot = F.one_hot(labels, no_of_classes).float()", "\n", "#", "\n", "# weights = torch.tensor(weights).float().cuda()", "\n", "# weights = weights.unsqueeze(0)", "\n", "# weights = weights.repeat(labels_one_hot.shape[0], 1) * labels_one_hot", "\n", "# weights = weights.sum(1)", "\n", "# weights = weights.unsqueeze(1)", "\n", "# weights = weights.repeat(1, no_of_classes)", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.focal_loss_single": [[171, 195], ["torch.binary_cross_entropy_with_logits", "torch.mean", "torch.mean", "torch.mean", "torch.exp", "torch.exp", "torch.exp", "torch.log", "torch.log", "torch.log", "torch.exp", "torch.exp", "torch.exp"], "function", ["None"], ["", "def", "focal_loss_single", "(", "labels", ",", "logits", ",", "alpha", ",", "gamma", ")", ":", "\n", "    ", "\"\"\"Compute the focal loss between `logits` and the ground truth `labels`.\n    Focal loss = -alpha_t * (1-pt)^gamma * log(pt)\n    where pt is the probability of being classified to the true class.\n    pt = p (if true class), otherwise pt = 1 - p. p = sigmoid(logit).\n    Args:\n      labels: A float tensor of size [batch, num_classes].\n      logits: A float tensor of size [batch, num_classes].\n      alpha: A float tensor of size [batch_size]\n        specifying per-example weight for balanced cross entropy.\n      gamma: A float scalar modulating loss from hard and easy examples.\n    Returns:\n      focal_loss: A float32 scalar representing normalized total loss.\n    \"\"\"", "\n", "BCLoss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "input", "=", "logits", ",", "target", "=", "labels", ",", "reduction", "=", "\"none\"", ")", "\n", "if", "gamma", "==", "0.0", ":", "\n", "        ", "modulator", "=", "1.0", "\n", "", "else", ":", "\n", "        ", "modulator", "=", "torch", ".", "exp", "(", "-", "gamma", "*", "labels", "*", "logits", "-", "gamma", "*", "torch", ".", "log", "(", "1", "+", "\n", "torch", ".", "exp", "(", "-", "1.0", "*", "logits", ")", ")", ")", "\n", "", "loss", "=", "modulator", "*", "BCLoss", "\n", "weighted_loss", "=", "alpha", "*", "loss", "\n", "focal_loss", "=", "torch", ".", "mean", "(", "weighted_loss", ")", "\n", "return", "focal_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.CB_loss_single": [[197, 225], ["numpy.power", "numpy.array", "utils.focal_loss_single", "numpy.sum", "torch.binary_cross_entropy_with_logits"], "function", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.focal_loss_single"], ["", "def", "CB_loss_single", "(", "labels", ",", "logits", ",", "samples_per_cls", ",", "no_of_classes", ",", "loss_type", ",", "beta", ",", "gamma", ")", ":", "\n", "    ", "\"\"\"Compute the Class Balanced Loss between `logits` and the ground truth `labels`.\n    Class Balanced Loss: ((1-beta)/(1-beta^n))*Loss(labels, logits)\n    where Loss is one of the standard losses used for Neural Networks.\n    Args:\n      labels: A int tensor of size [batch].\n      logits: A float tensor of size [batch, no_of_classes].\n      samples_per_cls: A python list of size [no_of_classes].\n      no_of_classes: total number of classes. int\n      loss_type: string. One of \"sigmoid\", \"focal\", \"softmax\".\n      beta: float. Hyperparameter for Class balanced loss.\n      gamma: float. Hyperparameter for Focal loss.\n    Returns:\n      cb_loss: A float tensor representing class balanced loss\n    \"\"\"", "\n", "effective_num", "=", "1.0", "-", "np", ".", "power", "(", "beta", ",", "samples_per_cls", ")", "\n", "weights", "=", "(", "1.0", "-", "beta", ")", "/", "np", ".", "array", "(", "effective_num", ")", "\n", "weights", "=", "weights", "/", "np", ".", "sum", "(", "weights", ")", "*", "no_of_classes", "\n", "\n", "# labels_one_hot = F.one_hot(labels, no_of_classes).float()", "\n", "neglabel", "=", "1", "-", "labels", "\n", "# weights = torch.tensor(weights).float().cuda()", "\n", "weights", "=", "neglabel", "*", "weights", "[", "0", "]", "+", "labels", "*", "weights", "[", "1", "]", "\n", "if", "loss_type", "==", "'focal'", ":", "\n", "        ", "cb_loss", "=", "focal_loss_single", "(", "labels", "=", "labels", ",", "logits", "=", "logits", ",", "alpha", "=", "weights", ",", "gamma", "=", "gamma", ")", "\n", "", "elif", "loss_type", "==", "'sigmoid'", ":", "\n", "        ", "cb_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "input", "=", "logits", ",", "target", "=", "labels", ",", "weight", "=", "weights", ")", "\n", "", "return", "cb_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.CB_loss": [[228, 266], ["torch.one_hot().float", "torch.tensor().float().cuda", "torch.tensor().float().cuda", "torch.tensor().float().cuda", "weights.repeat.unsqueeze", "weights.repeat.sum", "weights.repeat.unsqueeze", "weights.repeat.repeat", "numpy.power", "numpy.array", "weights.repeat.repeat", "utils.focal_loss", "numpy.sum", "torch.one_hot", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.binary_cross_entropy_with_logits", "logits.softmax", "torch.binary_cross_entropy", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.focal_loss"], ["", "def", "CB_loss", "(", "labels", ",", "logits", ",", "samples_per_cls", ",", "no_of_classes", ",", "loss_type", ",", "beta", ",", "gamma", ")", ":", "\n", "    ", "\"\"\"Compute the Class Balanced Loss between `logits` and the ground truth `labels`.\n    Class Balanced Loss: ((1-beta)/(1-beta^n))*Loss(labels, logits)\n    where Loss is one of the standard losses used for Neural Networks.\n    Args:\n      labels: A int tensor of size [batch].\n      logits: A float tensor of size [batch, no_of_classes].\n      samples_per_cls: A python list of size [no_of_classes].\n      no_of_classes: total number of classes. int\n      loss_type: string. One of \"sigmoid\", \"focal\", \"softmax\".\n      beta: float. Hyperparameter for Class balanced loss.\n      gamma: float. Hyperparameter for Focal loss.\n    Returns:\n      cb_loss: A float tensor representing class balanced loss\n    \"\"\"", "\n", "effective_num", "=", "1.0", "-", "np", ".", "power", "(", "beta", ",", "samples_per_cls", ")", "\n", "weights", "=", "(", "1.0", "-", "beta", ")", "/", "np", ".", "array", "(", "effective_num", ")", "\n", "weights", "=", "weights", "/", "np", ".", "sum", "(", "weights", ")", "*", "no_of_classes", "\n", "\n", "labels_one_hot", "=", "F", ".", "one_hot", "(", "labels", ",", "no_of_classes", ")", ".", "float", "(", ")", "\n", "\n", "weights", "=", "torch", ".", "tensor", "(", "weights", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "\n", "weights", "=", "weights", ".", "unsqueeze", "(", "0", ")", "\n", "weights", "=", "weights", ".", "repeat", "(", "labels_one_hot", ".", "shape", "[", "0", "]", ",", "1", ")", "*", "labels_one_hot", "\n", "weights", "=", "weights", ".", "sum", "(", "1", ")", "\n", "weights", "=", "weights", ".", "unsqueeze", "(", "1", ")", "\n", "weights", "=", "weights", ".", "repeat", "(", "1", ",", "no_of_classes", ")", "\n", "\n", "if", "loss_type", "==", "\"focal\"", ":", "\n", "        ", "cb_loss", "=", "focal_loss", "(", "labels_one_hot", ",", "logits", ",", "weights", ",", "gamma", ")", "\n", "", "elif", "loss_type", "==", "\"sigmoid\"", ":", "\n", "        ", "cb_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "input", "=", "logits", ",", "target", "=", "labels_one_hot", ",", "weight", "=", "weights", ")", "\n", "", "elif", "loss_type", "==", "\"softmax\"", ":", "\n", "        ", "pred", "=", "logits", ".", "softmax", "(", "dim", "=", "1", ")", "\n", "cb_loss", "=", "F", ".", "binary_cross_entropy", "(", "input", "=", "pred", ",", "target", "=", "labels_one_hot", ",", "weight", "=", "weights", ")", "\n", "", "elif", "loss_type", "==", "'weight'", ":", "\n", "        ", "return", "weights", "\n", "", "return", "cb_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.MAUC": [[268, 300], ["itertools.combinations", "float", "range", "utils.a_value", "utils.a_value"], "function", ["home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.a_value", "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.a_value"], ["", "def", "MAUC", "(", "data", ",", "num_classes", ")", ":", "\n", "    ", "\"\"\"\n    Calculates the MAUC over a set of multi-class probabilities and\n    their labels. This is equation 7 in Hand and Till's 2001 paper.\n    NB: The class labels should be in the set [0,n-1] where n = # of classes.\n    The class probability should be at the index of its label in the\n    probability list.\n    I.e. With 3 classes the labels should be 0, 1, 2. The class probability\n    for class '1' will be found in index 1 in the class probability list\n    wrapped inside the zipped list with the labels.\n    Args:\n        data (list): A zipped list (NOT A GENERATOR) of the labels and the\n            class probabilities in the form (m = # data instances):\n             [(label1, [p(x1c1), p(x1c2), ... p(x1cn)]),\n              (label2, [p(x2c1), p(x2c2), ... p(x2cn)])\n                             ...\n              (labelm, [p(xmc1), p(xmc2), ... (pxmcn)])\n             ]\n        num_classes (int): The number of classes in the dataset.\n    Returns:\n        The MAUC as a floating point value.\n    \"\"\"", "\n", "# Find all pairwise comparisons of labels", "\n", "class_pairs", "=", "[", "x", "for", "x", "in", "itertools", ".", "combinations", "(", "range", "(", "num_classes", ")", ",", "2", ")", "]", "\n", "\n", "# Have to take average of A value with both classes acting as label 0 as this", "\n", "# gives different outputs for more than 2 classes", "\n", "sum_avals", "=", "0", "\n", "for", "pairing", "in", "class_pairs", ":", "\n", "        ", "sum_avals", "+=", "(", "a_value", "(", "data", ",", "zero_label", "=", "pairing", "[", "0", "]", ",", "one_label", "=", "pairing", "[", "1", "]", ")", "+", "a_value", "(", "data", ",", "zero_label", "=", "pairing", "[", "1", "]", ",", "one_label", "=", "pairing", "[", "0", "]", ")", ")", "/", "2.0", "\n", "\n", "", "return", "sum_avals", "*", "(", "2", "/", "float", "(", "num_classes", "*", "(", "num_classes", "-", "1", ")", ")", ")", "# Eqn 7", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.calcBCA": [[301, 340], ["range", "numpy.mean", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "def", "calcBCA", "(", "estimLabels", ",", "trueLabels", ",", "no_classes", ")", ":", "\n", "    ", "\"\"\"\n    Calculates the balanced class accuracy (BCA)\n    Args:\n        estimLabels (ndarray): predicted classes\n        trueLabels (ndarray): ground truth classes\n        no_classes (int): The number of classes in the dataset.\n    Returns:\n        BCA value\n    \"\"\"", "\n", "bcaAll", "=", "[", "]", "\n", "for", "c0", "in", "range", "(", "no_classes", ")", ":", "\n", "# c0 can be either CTL, MCI or AD", "\n", "\n", "# one example when c0=CTL", "\n", "# TP - label was estimated as CTL, and the true label was also CTL", "\n", "# FP - label was estimated as CTL, but the true label was not CTL", "\n", "        ", "TP", "=", "np", ".", "sum", "(", "(", "estimLabels", "==", "c0", ")", "&", "(", "trueLabels", "==", "c0", ")", ")", "\n", "TN", "=", "np", ".", "sum", "(", "(", "estimLabels", "!=", "c0", ")", "&", "(", "trueLabels", "!=", "c0", ")", ")", "\n", "FP", "=", "np", ".", "sum", "(", "(", "estimLabels", "==", "c0", ")", "&", "(", "trueLabels", "!=", "c0", ")", ")", "\n", "FN", "=", "np", ".", "sum", "(", "(", "estimLabels", "!=", "c0", ")", "&", "(", "trueLabels", "==", "c0", ")", ")", "\n", "\n", "# sometimes the sensitivity of specificity can be NaN, if the user", "\n", "# doesn't forecast one of the classes.", "\n", "# In this case we assume a default value for sensitivity/specificity", "\n", "if", "(", "TP", "+", "FN", ")", "==", "0", ":", "\n", "            ", "sensitivity", "=", "0.5", "\n", "", "else", ":", "\n", "            ", "sensitivity", "=", "(", "1.", "*", "TP", ")", "/", "(", "TP", "+", "FN", ")", "\n", "\n", "", "if", "(", "TN", "+", "FP", ")", "==", "0", ":", "\n", "            ", "specificity", "=", "0.5", "\n", "", "else", ":", "\n", "            ", "specificity", "=", "(", "1.", "*", "TN", ")", "/", "(", "TN", "+", "FP", ")", "\n", "\n", "", "bcaCurr", "=", "0.5", "*", "(", "sensitivity", "+", "specificity", ")", "\n", "bcaAll", "+=", "[", "bcaCurr", "]", "\n", "\n", "", "return", "np", ".", "mean", "(", "bcaAll", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.save_obj": [[348, 351], ["open", "pickle.dump"], "function", ["None"], ["", "", "def", "save_obj", "(", "obj", ",", "name", ")", ":", "\n", "    ", "with", "open", "(", "name", "+", "'.pkl'", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "pickle", ".", "dump", "(", "obj", ",", "f", ",", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.meiyan88_mcnet.None.utils.load_obj": [[353, 356], ["open", "pickle.load"], "function", ["None"], ["", "", "def", "load_obj", "(", "name", ")", ":", "\n", "    ", "with", "open", "(", "name", "+", "'.pkl'", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "return", "pickle", ".", "load", "(", "f", ",", "encoding", "=", "'bytes'", ")", "\n", "\n"]]}