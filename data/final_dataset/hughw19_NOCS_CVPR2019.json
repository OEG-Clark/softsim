{"home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.config.Config.__init__": [[148, 162], ["numpy.array", "numpy.array", "int", "int", "math.ceil", "math.ceil"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set values of computed attributes.\"\"\"", "\n", "# Effective batch size", "\n", "self", ".", "BATCH_SIZE", "=", "self", ".", "IMAGES_PER_GPU", "*", "self", ".", "GPU_COUNT", "\n", "\n", "# Input image size", "\n", "self", ".", "IMAGE_SHAPE", "=", "np", ".", "array", "(", "\n", "[", "self", ".", "IMAGE_MAX_DIM", ",", "self", ".", "IMAGE_MAX_DIM", ",", "3", "]", ")", "\n", "\n", "# Compute backbone size from input image size", "\n", "self", ".", "BACKBONE_SHAPES", "=", "np", ".", "array", "(", "\n", "[", "[", "int", "(", "math", ".", "ceil", "(", "self", ".", "IMAGE_SHAPE", "[", "0", "]", "/", "stride", ")", ")", ",", "\n", "int", "(", "math", ".", "ceil", "(", "self", ".", "IMAGE_SHAPE", "[", "1", "]", "/", "stride", ")", ")", "]", "\n", "for", "stride", "in", "self", ".", "BACKBONE_STRIDES", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.config.Config.display": [[163, 170], ["print", "dir", "print", "print", "a.startswith", "callable", "getattr", "getattr"], "methods", ["None"], ["", "def", "display", "(", "self", ")", ":", "\n", "        ", "\"\"\"Display Configuration values.\"\"\"", "\n", "print", "(", "\"\\nConfigurations:\"", ")", "\n", "for", "a", "in", "dir", "(", "self", ")", ":", "\n", "            ", "if", "not", "a", ".", "startswith", "(", "\"__\"", ")", "and", "not", "callable", "(", "getattr", "(", "self", ",", "a", ")", ")", ":", "\n", "                ", "print", "(", "\"{:30} {}\"", ".", "format", "(", "a", ",", "getattr", "(", "self", ",", "a", ")", ")", ")", "\n", "", "", "print", "(", "\"\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.config.Config.log": [[172, 177], ["open", "dir", "f.write", "a.startswith", "callable", "getattr", "getattr"], "methods", ["None"], ["", "def", "log", "(", "self", ",", "output_path", ")", ":", "\n", "        ", "with", "open", "(", "output_path", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "for", "a", "in", "dir", "(", "self", ")", ":", "\n", "                ", "if", "not", "a", ".", "startswith", "(", "\"__\"", ")", "and", "not", "callable", "(", "getattr", "(", "self", ",", "a", ")", ")", ":", "\n", "                    ", "f", ".", "write", "(", "\"{:30} {}\\n\"", ".", "format", "(", "a", ",", "getattr", "(", "self", ",", "a", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.parallel_model.ParallelModel.__init__": [[30, 40], ["parallel_model.ParallelModel.make_parallel", "keras.Model.__init__"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.parallel_model.ParallelModel.make_parallel", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.__init__"], ["def", "__init__", "(", "self", ",", "keras_model", ",", "gpu_count", ")", ":", "\n", "        ", "\"\"\"Class constructor.\n        keras_model: The Keras model to parallelize\n        gpu_count: Number of GPUs. Must be > 1\n        \"\"\"", "\n", "self", ".", "inner_model", "=", "keras_model", "\n", "self", ".", "gpu_count", "=", "gpu_count", "\n", "merged_outputs", "=", "self", ".", "make_parallel", "(", ")", "\n", "super", "(", "ParallelModel", ",", "self", ")", ".", "__init__", "(", "inputs", "=", "self", ".", "inner_model", ".", "inputs", ",", "\n", "outputs", "=", "merged_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.parallel_model.ParallelModel.__getattribute__": [[41, 47], ["keras.Model.__getattribute__", "getattr"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.parallel_model.ParallelModel.__getattribute__"], ["", "def", "__getattribute__", "(", "self", ",", "attrname", ")", ":", "\n", "        ", "\"\"\"Redirect loading and saving methods to the inner model. That's where\n        the weights are stored.\"\"\"", "\n", "if", "'load'", "in", "attrname", "or", "'save'", "in", "attrname", ":", "\n", "            ", "return", "getattr", "(", "self", ".", "inner_model", ",", "attrname", ")", "\n", "", "return", "super", "(", "ParallelModel", ",", "self", ")", ".", "__getattribute__", "(", "attrname", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.parallel_model.ParallelModel.summary": [[48, 53], ["super().summary", "parallel_model.ParallelModel.inner_model.summary"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.parallel_model.ParallelModel.summary", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.parallel_model.ParallelModel.summary"], ["", "def", "summary", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Override summary() to display summaries of both, the wrapper\n        and inner models.\"\"\"", "\n", "super", "(", "ParallelModel", ",", "self", ")", ".", "summary", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "inner_model", ".", "summary", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.parallel_model.ParallelModel.make_parallel": [[54, 103], ["range", "range", "tensorflow.split", "len", "outputs_all.append", "tensorflow.device", "zip", "zip", "tensorflow.device", "list", "merged.append", "tensorflow.name_scope", "zip", "parallel_model.ParallelModel.inner_model", "enumerate", "map", "isinstance", "outputs_all[].append", "keras.int_shape", "keras.int_shape", "keras.int_shape", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.reshape", "keras.reshape", "keras.reshape"], "methods", ["None"], ["", "def", "make_parallel", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates a new wrapper model that consists of multiple replicas of\n        the original model placed on different GPUs.\n        \"\"\"", "\n", "# Slice inputs. Slice inputs on the CPU to avoid sending a copy", "\n", "# of the full inputs to all GPUs. Saves on bandwidth and memory.", "\n", "input_slices", "=", "{", "name", ":", "tf", ".", "split", "(", "x", ",", "self", ".", "gpu_count", ")", "\n", "for", "name", ",", "x", "in", "zip", "(", "self", ".", "inner_model", ".", "input_names", ",", "\n", "self", ".", "inner_model", ".", "inputs", ")", "}", "\n", "\n", "output_names", "=", "self", ".", "inner_model", ".", "output_names", "\n", "outputs_all", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "inner_model", ".", "outputs", ")", ")", ":", "\n", "            ", "outputs_all", ".", "append", "(", "[", "]", ")", "\n", "\n", "# Run the model call() on each GPU to place the ops there", "\n", "", "for", "i", "in", "range", "(", "self", ".", "gpu_count", ")", ":", "\n", "            ", "with", "tf", ".", "device", "(", "'/gpu:%d'", "%", "i", ")", ":", "\n", "                ", "with", "tf", ".", "name_scope", "(", "'tower_%d'", "%", "i", ")", ":", "\n", "# Run a slice of inputs through this replica", "\n", "                    ", "zipped_inputs", "=", "zip", "(", "self", ".", "inner_model", ".", "input_names", ",", "\n", "self", ".", "inner_model", ".", "inputs", ")", "\n", "inputs", "=", "[", "\n", "KL", ".", "Lambda", "(", "lambda", "s", ":", "input_slices", "[", "name", "]", "[", "i", "]", ",", "\n", "output_shape", "=", "lambda", "s", ":", "(", "None", ",", ")", "+", "s", "[", "1", ":", "]", ")", "(", "tensor", ")", "\n", "for", "name", ",", "tensor", "in", "zipped_inputs", "]", "\n", "# Create the model replica and get the outputs", "\n", "outputs", "=", "self", ".", "inner_model", "(", "inputs", ")", "\n", "if", "not", "isinstance", "(", "outputs", ",", "list", ")", ":", "\n", "                        ", "outputs", "=", "[", "outputs", "]", "\n", "# Save the outputs for merging back together later", "\n", "", "for", "l", ",", "o", "in", "enumerate", "(", "outputs", ")", ":", "\n", "                        ", "outputs_all", "[", "l", "]", ".", "append", "(", "o", ")", "\n", "\n", "# Merge outputs on CPU", "\n", "", "", "", "", "with", "tf", ".", "device", "(", "'/cpu:0'", ")", ":", "\n", "            ", "merged", "=", "[", "]", "\n", "for", "outputs", ",", "name", "in", "zip", "(", "outputs_all", ",", "output_names", ")", ":", "\n", "# If outputs are numbers without dimensions, add a batch dim.", "\n", "                ", "def", "add_dim", "(", "tensor", ")", ":", "\n", "                    ", "\"\"\"Add a dimension to tensors that don't have any.\"\"\"", "\n", "if", "K", ".", "int_shape", "(", "tensor", ")", "==", "(", ")", ":", "\n", "                        ", "return", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "reshape", "(", "t", ",", "[", "1", ",", "1", "]", ")", ")", "(", "tensor", ")", "\n", "", "return", "tensor", "\n", "", "outputs", "=", "list", "(", "map", "(", "add_dim", ",", "outputs", ")", ")", "\n", "\n", "# Concatenate", "\n", "merged", ".", "append", "(", "KL", ".", "Concatenate", "(", "axis", "=", "0", ",", "name", "=", "name", ")", "(", "outputs", ")", ")", "\n", "", "", "return", "merged", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.ICP.draw_registration_result": [[14, 21], ["copy.deepcopy", "copy.deepcopy", "copy.deepcopy.paint_uniform_color", "copy.deepcopy.paint_uniform_color", "copy.deepcopy.transform", "draw_geometries"], "function", ["None"], ["def", "draw_registration_result", "(", "source", ",", "target", ",", "transformation", ")", ":", "\n", "    ", "source_temp", "=", "copy", ".", "deepcopy", "(", "source", ")", "\n", "target_temp", "=", "copy", ".", "deepcopy", "(", "target", ")", "\n", "source_temp", ".", "paint_uniform_color", "(", "[", "1", ",", "0.706", ",", "0", "]", ")", "\n", "target_temp", ".", "paint_uniform_color", "(", "[", "0", ",", "0.651", ",", "0.929", "]", ")", "\n", "source_temp", ".", "transform", "(", "transformation", ")", "\n", "draw_geometries", "(", "[", "source_temp", ",", "target_temp", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.ICP.doICP": [[22, 81], ["PointCloud", "Vector3dVector", "numpy.asarray", "PointCloud", "Vector3dVector", "matplotlib.mlab.PCA", "matplotlib.mlab.PCA", "numpy.array", "range", "PointCloud", "Vector3dVector", "PointCloud", "Vector3dVector", "numpy.identity", "print", "registration_icp", "print", "registration_icp.transformation.copy", "TransformationEstimationPointToPoint", "ICP.draw_registration_result", "ICP.draw_registration_result"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.ICP.draw_registration_result", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.ICP.draw_registration_result"], ["", "def", "doICP", "(", "model_pts_np", ",", "pred_pts_np", ",", "SigmaFactor", "=", "5", ",", "threshold", "=", "1000", ",", "isViz", "=", "False", ")", ":", "\n", "    ", "model_pts", "=", "PointCloud", "(", ")", "\n", "model_pts", ".", "points", "=", "Vector3dVector", "(", "model_pts_np", ")", "\n", "model_pts_orig", "=", "model_pts", "\n", "model_pts_orig_np", "=", "np", ".", "asarray", "(", "model_pts_orig", ".", "points", ")", "\n", "pred_pts", "=", "PointCloud", "(", ")", "\n", "pred_pts", ".", "points", "=", "Vector3dVector", "(", "pred_pts_np", ")", "\n", "\n", "# First use PCA to compute the dimensions of target", "\n", "model_pca", "=", "PCA", "(", "model_pts_np", ")", "\n", "pred_pca", "=", "PCA", "(", "pred_pts_np", ")", "\n", "# print('Model mean:', model_pca.mu)", "\n", "# print('Model sigma:', model_pca.sigma)", "\n", "# print('Prediction mean:', pred_pca.mu)", "\n", "# print('Prediction sigma:', pred_pca.sigma)", "\n", "#", "\n", "# Scale model and move its center to prediction center", "\n", "ScaleFactor", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", "]", ")", "\n", "\n", "\n", "#ScaleFactor = pred_pca.sigma * SigmaFactor * SigmaFactor # OUTPUT 1", "\n", "PredCenter", "=", "pred_pca", ".", "mu", "\n", "for", "i", "in", "range", "(", "0", ",", "3", ")", ":", "\n", "# model_pts_np[:, i] = (model_pts_np[:, i] - model_pca.mu[i]) * ScaleFactor[i] * Factor + pred_pca.mu[i]", "\n", "        ", "model_pts_np", "[", ":", ",", "i", "]", "=", "(", "model_pts_np", "[", ":", ",", "i", "]", ")", "*", "ScaleFactor", "[", "i", "]", "+", "PredCenter", "[", "i", "]", "# Scale and then move model origin to origin of prediction depth point cloud", "\n", "model_pts_orig_np", "[", ":", ",", "i", "]", "=", "(", "model_pts_orig_np", "[", ":", ",", "i", "]", ")", "*", "ScaleFactor", "[", "i", "]", "\n", "\n", "", "model_pts", "=", "PointCloud", "(", ")", "\n", "model_pts", ".", "points", "=", "Vector3dVector", "(", "model_pts_np", ")", "\n", "model_pts_orig", "=", "PointCloud", "(", ")", "\n", "model_pts_orig", ".", "points", "=", "Vector3dVector", "(", "model_pts_orig_np", ")", "\n", "# model_pca = PCA(model_pts_np)", "\n", "# print('Model mean (after transform):', model_pca.mu)", "\n", "# print('Model sigma (after transform):', model_pca.sigma)", "\n", "\n", "trans_init", "=", "np", ".", "identity", "(", "4", ")", "\n", "print", "(", "'Apply point-to-point ICP'", ")", "\n", "reg_p2p", "=", "registration_icp", "(", "model_pts", ",", "pred_pts", ",", "threshold", ",", "trans_init", ",", "\n", "TransformationEstimationPointToPoint", "(", ")", ")", "\n", "print", "(", "reg_p2p", ")", "\n", "# print('Transformation is:')", "\n", "# print(reg_p2p.transformation) # OUTPUT 2, 3", "\n", "if", "isViz", ":", "\n", "        ", "draw_registration_result", "(", "model_pts", ",", "pred_pts", ",", "reg_p2p", ".", "transformation", ")", "\n", "\n", "", "FinalTrans", "=", "reg_p2p", ".", "transformation", ".", "copy", "(", ")", "\n", "# print('Before:\\n', FinalTrans)", "\n", "FinalTrans", "[", ":", "3", ",", "3", "]", "=", "FinalTrans", "[", ":", "3", ",", "3", "]", "+", "FinalTrans", "[", ":", "3", ",", ":", "3", "]", "@", "PredCenter", "\n", "# print('After:\\n', FinalTrans)", "\n", "Translation", "=", "FinalTrans", "[", ":", "3", ",", "3", "]", "\n", "Rotation", "=", "FinalTrans", "[", ":", "3", ",", ":", "3", "]", "\n", "# print('PredCenter:', PredCenter)", "\n", "# print('ICP Addition:', reg_p2p.transformation[:3, 3])", "\n", "# print('Final Translation:', Translation)", "\n", "\n", "if", "isViz", ":", "\n", "        ", "draw_registration_result", "(", "model_pts_orig", ",", "pred_pts", ",", "FinalTrans", ")", "\n", "\n", "", "return", "ScaleFactor", ",", "Rotation", ",", "Translation", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.__init__": [[22, 42], ["config.Config", "enumerate", "dataset.NOCSDataset.add_class"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.add_class"], ["def", "__init__", "(", "self", ",", "synset_names", ",", "subset", ",", "config", "=", "Config", "(", ")", ")", ":", "\n", "        ", "self", ".", "_image_ids", "=", "[", "]", "\n", "self", ".", "image_info", "=", "[", "]", "\n", "# Background is always the first class", "\n", "self", ".", "class_info", "=", "[", "{", "\"source\"", ":", "\"\"", ",", "\"id\"", ":", "0", ",", "\"name\"", ":", "\"BG\"", "}", "]", "\n", "self", ".", "source_class_ids", "=", "{", "}", "\n", "\n", "# which dataset: train/val/test", "\n", "self", ".", "subset", "=", "subset", "\n", "assert", "subset", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", "\n", "\n", "self", ".", "config", "=", "config", "\n", "\n", "self", ".", "source_image_ids", "=", "{", "}", "\n", "\n", "# Add classes", "\n", "for", "i", ",", "obj_name", "in", "enumerate", "(", "synset_names", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "## class 0 is bg class", "\n", "                ", "continue", "\n", "", "self", ".", "add_class", "(", "\"BG\"", ",", "i", ",", "obj_name", ")", "## class id starts with 1", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.load_camera_scenes": [[43, 107], ["os.path.join", "len", "len", "range", "numpy.zeros", "len", "numpy.arange", "print", "os.path.join", "os.path.join", "dataset.NOCSDataset.add_image", "numpy.mean", "print", "os.listdir", "os.path.isdir", "int", "int", "os.path.exists", "open", "cv2.imread().astype", "print", "numpy.expand_dims", "numpy.append", "os.path.join", "line.split", "int", "int", "numpy.mean", "cv2.imread"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.add_image"], ["", "", "def", "load_camera_scenes", "(", "self", ",", "dataset_dir", ",", "if_calculate_mean", "=", "False", ")", ":", "\n", "        ", "\"\"\"Load a subset of the CAMERA dataset.\n        dataset_dir: The root directory of the CAMERA dataset.\n        subset: What to load (train, val)\n        if_calculate_mean: if calculate the mean color of the images in this dataset\n        \"\"\"", "\n", "\n", "image_dir", "=", "os", ".", "path", ".", "join", "(", "dataset_dir", ",", "self", ".", "subset", ")", "\n", "source", "=", "\"CAMERA\"", "\n", "num_images_before_load", "=", "len", "(", "self", ".", "image_info", ")", "\n", "\n", "folder_list", "=", "[", "name", "for", "name", "in", "os", ".", "listdir", "(", "image_dir", ")", "if", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "image_dir", ",", "name", ")", ")", "]", "\n", "\n", "num_total_folders", "=", "len", "(", "folder_list", ")", "\n", "\n", "image_ids", "=", "range", "(", "10", "*", "num_total_folders", ")", "\n", "color_mean", "=", "np", ".", "zeros", "(", "(", "0", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# Add images", "\n", "for", "i", "in", "image_ids", ":", "\n", "            ", "image_id", "=", "int", "(", "i", ")", "%", "10", "\n", "folder_id", "=", "int", "(", "i", ")", "//", "10", "\n", "\n", "image_path", "=", "os", ".", "path", ".", "join", "(", "image_dir", ",", "'{:05d}'", ".", "format", "(", "folder_id", ")", ",", "'{:04d}'", ".", "format", "(", "image_id", ")", ")", "\n", "color_path", "=", "image_path", "+", "'_color.png'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "color_path", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "meta_path", "=", "os", ".", "path", ".", "join", "(", "image_dir", ",", "'{:05d}'", ".", "format", "(", "folder_id", ")", ",", "'{:04d}_meta.txt'", ".", "format", "(", "image_id", ")", ")", "\n", "inst_dict", "=", "{", "}", "\n", "with", "open", "(", "meta_path", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "for", "line", "in", "f", ":", "\n", "                    ", "line_info", "=", "line", ".", "split", "(", "' '", ")", "\n", "inst_id", "=", "int", "(", "line_info", "[", "0", "]", ")", "##one-indexed", "\n", "cls_id", "=", "int", "(", "line_info", "[", "1", "]", ")", "##zero-indexed", "\n", "# skip background objs", "\n", "# symmetry_id = int(line_info[2])", "\n", "inst_dict", "[", "inst_id", "]", "=", "cls_id", "\n", "\n", "", "", "width", "=", "self", ".", "config", ".", "IMAGE_MAX_DIM", "# meta_data['viewport_size_x'].flatten()[0]", "\n", "height", "=", "self", ".", "config", ".", "IMAGE_MIN_DIM", "# meta_data['viewport_size_y'].flatten()[0]", "\n", "\n", "self", ".", "add_image", "(", "\n", "source", "=", "source", ",", "\n", "image_id", "=", "image_id", ",", "\n", "path", "=", "image_path", ",", "\n", "width", "=", "width", ",", "\n", "height", "=", "height", ",", "\n", "inst_dict", "=", "inst_dict", ")", "\n", "\n", "if", "if_calculate_mean", ":", "\n", "                ", "image_file", "=", "image_path", "+", "'_color.png'", "\n", "image", "=", "cv2", ".", "imread", "(", "image_file", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "print", "(", "i", ")", "\n", "color_mean_image", "=", "np", ".", "mean", "(", "image", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "[", ":", "3", "]", "\n", "color_mean_image", "=", "np", ".", "expand_dims", "(", "color_mean_image", ",", "axis", "=", "0", ")", "\n", "color_mean", "=", "np", ".", "append", "(", "color_mean", ",", "color_mean_image", ",", "axis", "=", "0", ")", "\n", "\n", "", "", "if", "if_calculate_mean", ":", "\n", "            ", "dataset_color_mean", "=", "np", ".", "mean", "(", "color_mean", "[", ":", ":", "-", "1", "]", ",", "axis", "=", "0", ")", "\n", "print", "(", "'The mean color of this dataset is '", ",", "dataset_color_mean", ")", "\n", "\n", "", "num_images_after_load", "=", "len", "(", "self", ".", "image_info", ")", "\n", "self", ".", "source_image_ids", "[", "source", "]", "=", "np", ".", "arange", "(", "num_images_before_load", ",", "num_images_after_load", ")", "\n", "print", "(", "'{} images are loaded into the dataset from {}.'", ".", "format", "(", "num_images_after_load", "-", "num_images_before_load", ",", "source", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.load_real_scenes": [[109, 161], ["len", "os.path.join", "sorted", "len", "numpy.arange", "print", "glob.glob", "glob.glob", "glob.glob", "glob.glob", "sorted", "glob.glob", "glob.glob", "glob.glob", "glob.glob", "os.path.isdir", "os.path.join", "os.path.basename", "os.path.join", "dataset.NOCSDataset.add_image", "os.path.basename.split", "open", "line.split", "int", "int"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.add_image"], ["", "def", "load_real_scenes", "(", "self", ",", "dataset_dir", ")", ":", "\n", "        ", "\"\"\"Load a subset of the Real dataset.\n        dataset_dir: The root directory of the Real dataset.\n        subset: What to load (train, val, test)\n        if_calculate_mean: if calculate the mean color of the images in this dataset\n        \"\"\"", "\n", "\n", "source", "=", "\"Real\"", "\n", "num_images_before_load", "=", "len", "(", "self", ".", "image_info", ")", "\n", "\n", "folder_name", "=", "'train'", "if", "self", ".", "subset", "==", "'train'", "else", "'test'", "\n", "image_dir", "=", "os", ".", "path", ".", "join", "(", "dataset_dir", ",", "folder_name", ")", "\n", "folder_list", "=", "[", "name", "for", "name", "in", "glob", ".", "glob", "(", "image_dir", "+", "'/*'", ")", "if", "os", ".", "path", ".", "isdir", "(", "name", ")", "]", "\n", "folder_list", "=", "sorted", "(", "folder_list", ")", "\n", "\n", "image_id", "=", "0", "\n", "for", "folder", "in", "folder_list", ":", "\n", "            ", "image_list", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "folder", ",", "'*_color.png'", ")", ")", "\n", "image_list", "=", "sorted", "(", "image_list", ")", "\n", "\n", "for", "image_full_path", "in", "image_list", ":", "\n", "                ", "image_name", "=", "os", ".", "path", ".", "basename", "(", "image_full_path", ")", "\n", "image_ind", "=", "image_name", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "image_path", "=", "os", ".", "path", ".", "join", "(", "folder", ",", "image_ind", ")", "\n", "\n", "meta_path", "=", "image_path", "+", "'_meta.txt'", "\n", "inst_dict", "=", "{", "}", "\n", "with", "open", "(", "meta_path", ",", "'r'", ")", "as", "f", ":", "\n", "                    ", "for", "line", "in", "f", ":", "\n", "                        ", "line_info", "=", "line", ".", "split", "(", "' '", ")", "\n", "inst_id", "=", "int", "(", "line_info", "[", "0", "]", ")", "##one-indexed", "\n", "cls_id", "=", "int", "(", "line_info", "[", "1", "]", ")", "##zero-indexed", "\n", "# symmetry_id = int(line_info[2])", "\n", "inst_dict", "[", "inst_id", "]", "=", "cls_id", "\n", "\n", "\n", "", "", "width", "=", "self", ".", "config", ".", "IMAGE_MAX_DIM", "# meta_data['viewport_size_x'].flatten()[0]", "\n", "height", "=", "self", ".", "config", ".", "IMAGE_MIN_DIM", "# meta_data['viewport_size_y'].flatten()[0]", "\n", "\n", "self", ".", "add_image", "(", "\n", "source", "=", "source", ",", "\n", "image_id", "=", "image_id", ",", "\n", "path", "=", "image_path", ",", "\n", "width", "=", "width", ",", "\n", "height", "=", "height", ",", "\n", "inst_dict", "=", "inst_dict", ")", "\n", "image_id", "+=", "1", "\n", "\n", "\n", "", "", "num_images_after_load", "=", "len", "(", "self", ".", "image_info", ")", "\n", "self", ".", "source_image_ids", "[", "source", "]", "=", "np", ".", "arange", "(", "num_images_before_load", ",", "num_images_after_load", ")", "\n", "print", "(", "'{} images are loaded into the dataset from {}.'", ".", "format", "(", "num_images_after_load", "-", "num_images_before_load", ",", "source", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.load_coco": [[163, 213], ["len", "os.path.join", "pycocotools.coco.COCO", "set", "pycocotools.coco.COCO.getCatIds", "list", "len", "enumerate", "len", "numpy.arange", "print", "os.path.join", "pycocotools.coco.COCO.getCatIds", "pycocotools.coco.COCO.getImgIds", "image_ids.union.union.union", "set", "dataset.NOCSDataset.add_class", "print", "dataset.NOCSDataset.add_image", "set", "os.path.join", "pycocotools.coco.COCO.loadAnns", "pycocotools.coco.COCO.loadCats", "pycocotools.coco.COCO.getAnnIds", "pycocotools.coco.COCO.loadCats"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.add_class", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.add_image"], ["", "def", "load_coco", "(", "self", ",", "dataset_dir", ",", "subset", ",", "class_names", ")", ":", "\n", "        ", "\"\"\"Load a subset of the COCO dataset.\n        dataset_dir: The root directory of the COCO dataset.\n        subset: What to load (train, val, minival, val35k)\n        class_ids: If provided, only loads images that have the given classes.\n        \"\"\"", "\n", "source", "=", "\"coco\"", "\n", "num_images_before_load", "=", "len", "(", "self", ".", "image_info", ")", "\n", "\n", "image_dir", "=", "os", ".", "path", ".", "join", "(", "dataset_dir", ",", "\"images\"", ",", "\"train2017\"", "if", "subset", "==", "\"train\"", "\n", "else", "\"val2017\"", ")", "\n", "\n", "# Create COCO object", "\n", "json_path_dict", "=", "{", "\n", "\"train\"", ":", "\"annotations/instances_train2017.json\"", ",", "\n", "\"val\"", ":", "\"annotations/instances_val2017.json\"", ",", "\n", "}", "\n", "coco", "=", "COCO", "(", "os", ".", "path", ".", "join", "(", "dataset_dir", ",", "json_path_dict", "[", "subset", "]", ")", ")", "\n", "\n", "# Load all classes or a subset?", "\n", "\n", "image_ids", "=", "set", "(", ")", "\n", "class_ids", "=", "coco", ".", "getCatIds", "(", "catNms", "=", "class_names", ")", "\n", "\n", "for", "cls_name", "in", "class_names", ":", "\n", "            ", "catIds", "=", "coco", ".", "getCatIds", "(", "catNms", "=", "[", "cls_name", "]", ")", "\n", "imgIds", "=", "coco", ".", "getImgIds", "(", "catIds", "=", "catIds", ")", "\n", "image_ids", "=", "image_ids", ".", "union", "(", "set", "(", "imgIds", ")", ")", "\n", "\n", "", "image_ids", "=", "list", "(", "set", "(", "image_ids", ")", ")", "\n", "\n", "# Add classes", "\n", "for", "cls_id", "in", "class_ids", ":", "\n", "            ", "self", ".", "add_class", "(", "\"coco\"", ",", "cls_id", ",", "coco", ".", "loadCats", "(", "cls_id", ")", "[", "0", "]", "[", "\"name\"", "]", ")", "\n", "print", "(", "'Add coco class: '", "+", "coco", ".", "loadCats", "(", "cls_id", ")", "[", "0", "]", "[", "\"name\"", "]", ")", "\n", "\n", "# Add images", "\n", "", "num_existing_images", "=", "len", "(", "self", ".", "image_info", ")", "\n", "for", "i", ",", "image_id", "in", "enumerate", "(", "image_ids", ")", ":", "\n", "            ", "self", ".", "add_image", "(", "\n", "source", "=", "source", ",", "\n", "image_id", "=", "i", "+", "num_existing_images", ",", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "image_dir", ",", "coco", ".", "imgs", "[", "image_id", "]", "[", "'file_name'", "]", ")", ",", "\n", "width", "=", "coco", ".", "imgs", "[", "image_id", "]", "[", "\"width\"", "]", ",", "\n", "height", "=", "coco", ".", "imgs", "[", "image_id", "]", "[", "\"height\"", "]", ",", "\n", "annotations", "=", "coco", ".", "loadAnns", "(", "coco", ".", "getAnnIds", "(", "imgIds", "=", "[", "image_id", "]", ",", "iscrowd", "=", "False", ")", ")", ")", "\n", "\n", "", "num_images_after_load", "=", "len", "(", "self", ".", "image_info", ")", "\n", "self", ".", "source_image_ids", "[", "source", "]", "=", "np", ".", "arange", "(", "num_images_before_load", ",", "num_images_after_load", ")", "\n", "print", "(", "'{} images are loaded into the dataset from {}.'", ".", "format", "(", "num_images_after_load", "-", "num_images_before_load", ",", "source", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.load_image": [[216, 241], ["os.path.exists", "cv2.imread", "cv2.cvtColor"], "methods", ["None"], ["", "def", "load_image", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Generate an image from the specs of the given image ID.\n        Typically this function loads the image from a file.\n        \"\"\"", "\n", "info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "if", "info", "[", "\"source\"", "]", "in", "[", "\"CAMERA\"", ",", "\"Real\"", "]", ":", "\n", "            ", "image_path", "=", "info", "[", "\"path\"", "]", "+", "'_color.png'", "\n", "assert", "os", ".", "path", ".", "exists", "(", "image_path", ")", ",", "\"{} is missing\"", ".", "format", "(", "image_path", ")", "\n", "\n", "#depth_path = info[\"path\"] + '_depth.png'", "\n", "", "elif", "info", "[", "\"source\"", "]", "==", "'coco'", ":", "\n", "            ", "image_path", "=", "info", "[", "\"path\"", "]", "\n", "", "else", ":", "\n", "            ", "assert", "False", ",", "\"[ Error ]: Unknown image source: {}\"", ".", "format", "(", "info", "[", "\"source\"", "]", ")", "\n", "\n", "# print(image_path)", "\n", "", "image", "=", "cv2", ".", "imread", "(", "image_path", ")", "[", ":", ",", ":", ",", ":", "3", "]", "\n", "image", "=", "image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "\n", "# If grayscale. Convert to RGB for consistency.", "\n", "if", "image", ".", "ndim", "!=", "3", ":", "\n", "            ", "image", "=", "cv2", ".", "cvtColor", "(", "image", ",", "cv2", ".", "COLOR_GRAY2RGB", ")", "\n", "\n", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.load_depth": [[242, 263], ["cv2.imread", "len", "depth16.astype.astype.astype", "numpy.uint16", "numpy.uint16", "len"], "methods", ["None"], ["", "def", "load_depth", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Generate an image from the specs of the given image ID.\n        Typically this function loads the image from a file.\n        \"\"\"", "\n", "info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "if", "info", "[", "\"source\"", "]", "in", "[", "\"CAMERA\"", ",", "\"Real\"", "]", ":", "\n", "            ", "depth_path", "=", "info", "[", "\"path\"", "]", "+", "'_depth.png'", "\n", "depth", "=", "cv2", ".", "imread", "(", "depth_path", ",", "-", "1", ")", "\n", "\n", "if", "len", "(", "depth", ".", "shape", ")", "==", "3", ":", "\n", "# This is encoded depth image, let's convert", "\n", "                ", "depth16", "=", "np", ".", "uint16", "(", "depth", "[", ":", ",", ":", ",", "1", "]", "*", "256", ")", "+", "np", ".", "uint16", "(", "depth", "[", ":", ",", ":", ",", "2", "]", ")", "# NOTE: RGB is actually BGR in opencv", "\n", "depth16", "=", "depth16", ".", "astype", "(", "np", ".", "uint16", ")", "\n", "", "elif", "len", "(", "depth", ".", "shape", ")", "==", "2", "and", "depth", ".", "dtype", "==", "'uint16'", ":", "\n", "                ", "depth16", "=", "depth", "\n", "", "else", ":", "\n", "                ", "assert", "False", ",", "'[ Error ]: Unsupported depth type.'", "\n", "", "", "else", ":", "\n", "            ", "depth16", "=", "None", "\n", "\n", "", "return", "depth16", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.image_reference": [[265, 272], ["super().image_reference"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.image_reference"], ["", "def", "image_reference", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Return the object data of the image.\"\"\"", "\n", "info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "if", "info", "[", "\"source\"", "]", "in", "[", "\"ShapeNetTOI\"", ",", "\"Real\"", "]", ":", "\n", "            ", "return", "info", "[", "\"inst_dict\"", "]", "\n", "", "else", ":", "\n", "            ", "super", "(", "self", ".", "__class__", ")", ".", "image_reference", "(", "self", ",", "image_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.load_objs": [[274, 307], ["enumerate", "open", "f.readlines", "line[].split", "int", "utils.load_mesh", "Vs.append", "Fs.append", "len", "os.path.join", "words[].replace", "os.path.join", "os.path.join", "len"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.load_mesh"], ["", "", "def", "load_objs", "(", "self", ",", "image_id", ",", "is_normalized", ")", ":", "\n", "        ", "info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "meta_path", "=", "info", "[", "\"path\"", "]", "+", "'_meta.txt'", "\n", "inst_dict", "=", "info", "[", "\"inst_dict\"", "]", "\n", "\n", "with", "open", "(", "meta_path", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "", "Vs", "=", "[", "]", "\n", "Fs", "=", "[", "]", "\n", "for", "i", ",", "line", "in", "enumerate", "(", "lines", ")", ":", "\n", "            ", "words", "=", "line", "[", ":", "-", "1", "]", ".", "split", "(", "' '", ")", "\n", "inst_id", "=", "int", "(", "words", "[", "0", "]", ")", "\n", "if", "not", "inst_id", "in", "inst_dict", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "len", "(", "words", ")", "==", "3", ":", "## real data", "\n", "                ", "if", "words", "[", "2", "]", "[", "-", "3", ":", "]", "==", "'npz'", ":", "\n", "                    ", "obj_name", "=", "words", "[", "2", "]", ".", "replace", "(", "'.npz'", ",", "'_norm.obj'", ")", "\n", "mesh_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "config", ".", "OBJ_MODEL_DIR", ",", "'real_val'", ",", "obj_name", ")", "\n", "", "else", ":", "\n", "                    ", "mesh_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "config", ".", "OBJ_MODEL_DIR", ",", "'real_'", "+", "self", ".", "subset", ",", "words", "[", "2", "]", "+", "'.obj'", ")", "\n", "", "flip_flag", "=", "False", "\n", "", "else", ":", "\n", "                ", "assert", "len", "(", "words", ")", "==", "4", "## synthetic data", "\n", "mesh_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "config", ".", "OBJ_MODEL_DIR", ",", "self", ".", "subset", ",", "words", "[", "2", "]", ",", "words", "[", "3", "]", ",", "'model.obj'", ")", "\n", "flip_flag", "=", "True", "\n", "\n", "", "vertices", ",", "faces", "=", "utils", ".", "load_mesh", "(", "mesh_file", ",", "is_normalized", ",", "flip_flag", ")", "\n", "Vs", ".", "append", "(", "vertices", ")", "\n", "Fs", ".", "append", "(", "faces", ")", "\n", "\n", "", "return", "Vs", ",", "Fs", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.process_data": [[309, 397], ["numpy.array", "list", "sorted", "len", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "inst_dict.keys", "numpy.clip", "numpy.unique", "numpy.array", "open", "f.readlines", "line[].split", "numpy.equal", "numpy.multiply", "len", "len", "numpy.linalg.norm", "os.path.join", "numpy.loadtxt", "inst_id_to_be_deleted.append", "numpy.sum", "numpy.expand_dims", "numpy.unique", "os.path.join", "os.path.join", "numpy.loadtxt", "numpy.load"], "methods", ["None"], ["", "def", "process_data", "(", "self", ",", "mask_im", ",", "coord_map", ",", "inst_dict", ",", "meta_path", ",", "load_RT", "=", "False", ")", ":", "\n", "# parsing mask", "\n", "        ", "cdata", "=", "mask_im", "\n", "cdata", "=", "np", ".", "array", "(", "cdata", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "# instance ids", "\n", "instance_ids", "=", "list", "(", "np", ".", "unique", "(", "cdata", ")", ")", "\n", "instance_ids", "=", "sorted", "(", "instance_ids", ")", "\n", "# remove background", "\n", "assert", "instance_ids", "[", "-", "1", "]", "==", "255", "\n", "del", "instance_ids", "[", "-", "1", "]", "\n", "\n", "cdata", "[", "cdata", "==", "255", "]", "=", "-", "1", "\n", "assert", "(", "np", ".", "unique", "(", "cdata", ")", ".", "shape", "[", "0", "]", "<", "20", ")", "\n", "\n", "num_instance", "=", "len", "(", "instance_ids", ")", "\n", "h", ",", "w", "=", "cdata", ".", "shape", "\n", "\n", "# flip z axis of coord map", "\n", "coord_map", "=", "np", ".", "array", "(", "coord_map", ",", "dtype", "=", "np", ".", "float32", ")", "/", "255", "\n", "coord_map", "[", ":", ",", ":", ",", "2", "]", "=", "1", "-", "coord_map", "[", ":", ",", ":", ",", "2", "]", "\n", "\n", "\n", "masks", "=", "np", ".", "zeros", "(", "[", "h", ",", "w", ",", "num_instance", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "coords", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ",", "num_instance", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "class_ids", "=", "np", ".", "zeros", "(", "[", "num_instance", "]", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "scales", "=", "np", ".", "zeros", "(", "[", "num_instance", ",", "3", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "with", "open", "(", "meta_path", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "", "scale_factor", "=", "np", ".", "zeros", "(", "(", "len", "(", "lines", ")", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", ",", "line", "in", "enumerate", "(", "lines", ")", ":", "\n", "            ", "words", "=", "line", "[", ":", "-", "1", "]", ".", "split", "(", "' '", ")", "\n", "\n", "if", "len", "(", "words", ")", "==", "3", ":", "\n", "## real scanned objs", "\n", "                ", "if", "words", "[", "2", "]", "[", "-", "3", ":", "]", "==", "'npz'", ":", "\n", "                    ", "npz_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "config", ".", "OBJ_MODEL_DIR", ",", "'real_val'", ",", "words", "[", "2", "]", ")", "\n", "with", "np", ".", "load", "(", "npz_path", ")", "as", "npz_file", ":", "\n", "                        ", "scale_factor", "[", "i", ",", ":", "]", "=", "npz_file", "[", "'scale'", "]", "\n", "", "", "else", ":", "\n", "                    ", "bbox_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "config", ".", "OBJ_MODEL_DIR", ",", "'real_'", "+", "self", ".", "subset", ",", "words", "[", "2", "]", "+", "'.txt'", ")", "\n", "scale_factor", "[", "i", ",", ":", "]", "=", "np", ".", "loadtxt", "(", "bbox_file", ")", "\n", "\n", "", "scale_factor", "[", "i", ",", ":", "]", "/=", "np", ".", "linalg", ".", "norm", "(", "scale_factor", "[", "i", ",", ":", "]", ")", "\n", "\n", "", "else", ":", "\n", "                ", "bbox_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "config", ".", "OBJ_MODEL_DIR", ",", "self", ".", "subset", ",", "words", "[", "2", "]", ",", "words", "[", "3", "]", ",", "'bbox.txt'", ")", "\n", "bbox", "=", "np", ".", "loadtxt", "(", "bbox_file", ")", "\n", "scale_factor", "[", "i", ",", ":", "]", "=", "bbox", "[", "0", ",", ":", "]", "-", "bbox", "[", "1", ",", ":", "]", "\n", "\n", "", "", "i", "=", "0", "\n", "\n", "# delete ids of background objects and non-existing objects ", "\n", "inst_id_to_be_deleted", "=", "[", "]", "\n", "for", "inst_id", "in", "inst_dict", ".", "keys", "(", ")", ":", "\n", "            ", "if", "inst_dict", "[", "inst_id", "]", "==", "0", "or", "(", "not", "inst_id", "in", "instance_ids", ")", ":", "\n", "                ", "inst_id_to_be_deleted", ".", "append", "(", "inst_id", ")", "\n", "", "", "for", "delete_id", "in", "inst_id_to_be_deleted", ":", "\n", "            ", "del", "inst_dict", "[", "delete_id", "]", "\n", "\n", "\n", "", "for", "inst_id", "in", "instance_ids", ":", "# instance mask is one-indexed", "\n", "            ", "if", "not", "inst_id", "in", "inst_dict", ":", "\n", "                ", "continue", "\n", "", "inst_mask", "=", "np", ".", "equal", "(", "cdata", ",", "inst_id", ")", "\n", "assert", "np", ".", "sum", "(", "inst_mask", ")", ">", "0", "\n", "assert", "inst_dict", "[", "inst_id", "]", "\n", "\n", "masks", "[", ":", ",", ":", ",", "i", "]", "=", "inst_mask", "\n", "coords", "[", ":", ",", ":", ",", "i", ",", ":", "]", "=", "np", ".", "multiply", "(", "coord_map", ",", "np", ".", "expand_dims", "(", "inst_mask", ",", "axis", "=", "-", "1", ")", ")", "\n", "\n", "# class ids is also one-indexed", "\n", "class_ids", "[", "i", "]", "=", "inst_dict", "[", "inst_id", "]", "\n", "scales", "[", "i", ",", ":", "]", "=", "scale_factor", "[", "inst_id", "-", "1", ",", ":", "]", "\n", "i", "+=", "1", "\n", "\n", "# print('before: ', inst_dict)", "\n", "\n", "", "masks", "=", "masks", "[", ":", ",", ":", ",", ":", "i", "]", "\n", "coords", "=", "coords", "[", ":", ",", ":", ",", ":", "i", ",", ":", "]", "\n", "coords", "=", "np", ".", "clip", "(", "coords", ",", "0", ",", "1", ")", "\n", "\n", "class_ids", "=", "class_ids", "[", ":", "i", "]", "\n", "scales", "=", "scales", "[", ":", "i", "]", "\n", "\n", "return", "masks", ",", "coords", ",", "class_ids", ",", "scales", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.load_mask": [[399, 462], ["os.path.exists", "os.path.exists", "dataset.NOCSDataset.process_data", "cv2.imread", "cv2.imread", "numpy.zeros", "numpy.ones", "dataset.NOCSDataset.map_source_class_id", "numpy.stack", "numpy.array", "numpy.empty", "numpy.empty", "utils.annToMask", "instance_masks.append", "numpy.empty.append", "len", "utils.annToMask.max"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.process_data", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.map_source_class_id", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.annToMask"], ["", "def", "load_mask", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Generate instance masks for the objects in the image with the given ID.\n        \"\"\"", "\n", "info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "#masks, coords, class_ids, scales, domain_label = None, None, None, None, None", "\n", "\n", "if", "info", "[", "\"source\"", "]", "in", "[", "\"CAMERA\"", ",", "\"Real\"", "]", ":", "\n", "            ", "domain_label", "=", "0", "## has coordinate map loss", "\n", "\n", "mask_path", "=", "info", "[", "\"path\"", "]", "+", "'_mask.png'", "\n", "coord_path", "=", "info", "[", "\"path\"", "]", "+", "'_coord.png'", "\n", "\n", "assert", "os", ".", "path", ".", "exists", "(", "mask_path", ")", ",", "\"{} is missing\"", ".", "format", "(", "mask_path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "coord_path", ")", ",", "\"{} is missing\"", ".", "format", "(", "coord_path", ")", "\n", "\n", "inst_dict", "=", "info", "[", "'inst_dict'", "]", "\n", "meta_path", "=", "info", "[", "\"path\"", "]", "+", "'_meta.txt'", "\n", "\n", "mask_im", "=", "cv2", ".", "imread", "(", "mask_path", ")", "[", ":", ",", ":", ",", "2", "]", "\n", "coord_map", "=", "cv2", ".", "imread", "(", "coord_path", ")", "[", ":", ",", ":", ",", ":", "3", "]", "\n", "coord_map", "=", "coord_map", "[", ":", ",", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "\n", "\n", "masks", ",", "coords", ",", "class_ids", ",", "scales", "=", "self", ".", "process_data", "(", "mask_im", ",", "coord_map", ",", "inst_dict", ",", "meta_path", ")", "\n", "\n", "\n", "", "elif", "info", "[", "\"source\"", "]", "==", "\"coco\"", ":", "\n", "            ", "domain_label", "=", "1", "## no coordinate map loss", "\n", "\n", "instance_masks", "=", "[", "]", "\n", "class_ids", "=", "[", "]", "\n", "annotations", "=", "self", ".", "image_info", "[", "image_id", "]", "[", "\"annotations\"", "]", "\n", "# Build mask of shape [height, width, instance_count] and list", "\n", "# of class IDs that correspond to each channel of the mask.", "\n", "for", "annotation", "in", "annotations", ":", "\n", "                ", "class_id", "=", "self", ".", "map_source_class_id", "(", "\n", "\"coco.{}\"", ".", "format", "(", "annotation", "[", "'category_id'", "]", ")", ")", "\n", "if", "class_id", ":", "\n", "                    ", "m", "=", "utils", ".", "annToMask", "(", "annotation", ",", "info", "[", "\"height\"", "]", ",", "\n", "info", "[", "\"width\"", "]", ")", "\n", "# Some objects are so small that they're less than 1 pixel area", "\n", "# and end up rounded out. Skip those objects.", "\n", "if", "m", ".", "max", "(", ")", "<", "1", ":", "\n", "                        ", "continue", "\n", "", "instance_masks", ".", "append", "(", "m", ")", "\n", "class_ids", ".", "append", "(", "class_id", ")", "\n", "\n", "# Pack instance masks into an array", "\n", "", "", "if", "class_ids", ":", "\n", "                ", "masks", "=", "np", ".", "stack", "(", "instance_masks", ",", "axis", "=", "2", ")", "\n", "class_ids", "=", "np", ".", "array", "(", "class_ids", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "", "else", ":", "\n", "# Call super class to return an empty mask", "\n", "                ", "masks", "=", "np", ".", "empty", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "class_ids", "=", "np", ".", "empty", "(", "[", "0", "]", ",", "np", ".", "int32", ")", "\n", "\n", "# use zero arrays as coord map for COCO images", "\n", "", "coords", "=", "np", ".", "zeros", "(", "masks", ".", "shape", "+", "(", "3", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "scales", "=", "np", ".", "ones", "(", "(", "len", "(", "class_ids", ")", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "#print('\\nwithout augmented, masks shape: {}'.format(masks.shape))", "\n", "", "else", ":", "\n", "            ", "assert", "False", "\n", "\n", "", "return", "masks", ",", "coords", ",", "class_ids", ",", "scales", ",", "domain_label", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.load_augment_data": [[464, 558], ["dataset.NOCSDataset.load_image", "numpy.random.uniform", "numpy.random.uniform", "skimage.exposure.adjust_gamma", "numpy.random.uniform", "utils.rotate_and_crop_images", "dataset.NOCSDataset.process_data", "cv2.imread", "cv2.imread", "numpy.stack", "numpy.array", "utils.rotate_and_crop_images", "range", "numpy.zeros", "numpy.ones", "dataset.NOCSDataset.map_source_class_id", "len", "final_masks.append", "final_class_ids.append", "numpy.stack", "numpy.array", "numpy.empty", "numpy.empty", "utils.annToMask", "instance_masks.append", "numpy.empty.append", "utils.annToMask.max", "len", "utils.annToMask.max"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.load_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.rotate_and_crop_images", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.process_data", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.rotate_and_crop_images", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.map_source_class_id", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.annToMask"], ["", "def", "load_augment_data", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Generate augmented data for the image with the given ID.\n        \"\"\"", "\n", "info", "=", "self", ".", "image_info", "[", "image_id", "]", "\n", "image", "=", "self", ".", "load_image", "(", "image_id", ")", "\n", "\n", "# apply random gamma correction to the image", "\n", "gamma", "=", "np", ".", "random", ".", "uniform", "(", "0.8", ",", "1", ")", "\n", "gain", "=", "np", ".", "random", ".", "uniform", "(", "0.8", ",", "1", ")", "\n", "image", "=", "exposure", ".", "adjust_gamma", "(", "image", ",", "gamma", ",", "gain", ")", "\n", "\n", "# generate random rotation degree", "\n", "rotate_degree", "=", "np", ".", "random", ".", "uniform", "(", "-", "5", ",", "5", ")", "\n", "\n", "if", "info", "[", "\"source\"", "]", "in", "[", "\"CAMERA\"", ",", "\"Real\"", "]", ":", "\n", "            ", "domain_label", "=", "0", "## has coordinate map loss", "\n", "\n", "mask_path", "=", "info", "[", "\"path\"", "]", "+", "'_mask.png'", "\n", "coord_path", "=", "info", "[", "\"path\"", "]", "+", "'_coord.png'", "\n", "inst_dict", "=", "info", "[", "'inst_dict'", "]", "\n", "meta_path", "=", "info", "[", "\"path\"", "]", "+", "'_meta.txt'", "\n", "\n", "mask_im", "=", "cv2", ".", "imread", "(", "mask_path", ")", "[", ":", ",", ":", ",", "2", "]", "\n", "coord_map", "=", "cv2", ".", "imread", "(", "coord_path", ")", "[", ":", ",", ":", ",", ":", "3", "]", "\n", "coord_map", "=", "coord_map", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "\n", "image", ",", "mask_im", ",", "coord_map", "=", "utils", ".", "rotate_and_crop_images", "(", "image", ",", "\n", "masks", "=", "mask_im", ",", "\n", "coords", "=", "coord_map", ",", "\n", "rotate_degree", "=", "rotate_degree", ")", "\n", "masks", ",", "coords", ",", "class_ids", ",", "scales", "=", "self", ".", "process_data", "(", "mask_im", ",", "coord_map", ",", "inst_dict", ",", "meta_path", ")", "\n", "", "elif", "info", "[", "\"source\"", "]", "==", "\"coco\"", ":", "\n", "            ", "domain_label", "=", "1", "## no coordinate map loss", "\n", "\n", "instance_masks", "=", "[", "]", "\n", "class_ids", "=", "[", "]", "\n", "annotations", "=", "self", ".", "image_info", "[", "image_id", "]", "[", "\"annotations\"", "]", "\n", "# Build mask of shape [height, width, instance_count] and list", "\n", "# of class IDs that correspond to each channel of the mask.", "\n", "for", "annotation", "in", "annotations", ":", "\n", "                ", "class_id", "=", "self", ".", "map_source_class_id", "(", "\n", "\"coco.{}\"", ".", "format", "(", "annotation", "[", "'category_id'", "]", ")", ")", "\n", "if", "class_id", ":", "\n", "                    ", "m", "=", "utils", ".", "annToMask", "(", "annotation", ",", "info", "[", "\"height\"", "]", ",", "\n", "info", "[", "\"width\"", "]", ")", "\n", "# Some objects are so small that they're less than 1 pixel area", "\n", "# and end up rounded out. Skip those objects.", "\n", "if", "m", ".", "max", "(", ")", "<", "1", ":", "\n", "                        ", "continue", "\n", "", "instance_masks", ".", "append", "(", "m", ")", "\n", "class_ids", ".", "append", "(", "class_id", ")", "\n", "\n", "# Pack instance masks into an array", "\n", "", "", "masks", "=", "np", ".", "stack", "(", "instance_masks", ",", "axis", "=", "2", ")", "\n", "class_ids", "=", "np", ".", "array", "(", "class_ids", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "#print('\\nbefore augmented, image shape: {}, masks shape: {}'.format(image.shape, masks.shape))", "\n", "image", ",", "masks", "=", "utils", ".", "rotate_and_crop_images", "(", "image", ",", "\n", "masks", "=", "masks", ",", "\n", "coords", "=", "None", ",", "\n", "rotate_degree", "=", "rotate_degree", ")", "\n", "\n", "#print('\\nafter augmented, image shape: {}, masks shape: {}'.format(image.shape, masks.shape))", "\n", "\n", "if", "len", "(", "masks", ".", "shape", ")", "==", "2", ":", "\n", "                ", "masks", "=", "masks", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "", "final_masks", "=", "[", "]", "\n", "final_class_ids", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "masks", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "                ", "m", "=", "masks", "[", ":", ",", ":", ",", "i", "]", "\n", "if", "m", ".", "max", "(", ")", "<", "1", ":", "\n", "                    ", "continue", "\n", "", "final_masks", ".", "append", "(", "m", ")", "\n", "final_class_ids", ".", "append", "(", "class_ids", "[", "i", "]", ")", "\n", "\n", "", "if", "final_class_ids", ":", "\n", "                ", "masks", "=", "np", ".", "stack", "(", "final_masks", ",", "axis", "=", "2", ")", "\n", "class_ids", "=", "np", ".", "array", "(", "final_class_ids", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "", "else", ":", "\n", "# Call super class to return an empty mask", "\n", "                ", "masks", "=", "np", ".", "empty", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "class_ids", "=", "np", ".", "empty", "(", "[", "0", "]", ",", "np", ".", "int32", ")", "\n", "\n", "\n", "# use zero arrays as coord map for COCO images", "\n", "", "coords", "=", "np", ".", "zeros", "(", "masks", ".", "shape", "+", "(", "3", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "scales", "=", "np", ".", "ones", "(", "(", "len", "(", "class_ids", ")", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "", "else", ":", "\n", "            ", "assert", "False", "\n", "\n", "\n", "", "return", "image", ",", "masks", ",", "coords", ",", "class_ids", ",", "scales", ",", "domain_label", "", "", "", ""]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.estimateSimilarityTransform": [[12, 44], ["numpy.transpose", "numpy.transpose", "numpy.mean", "numpy.mean", "aligning.getRANSACInliers", "aligning.estimateSimilarityUmeyama", "numpy.hstack", "numpy.hstack", "numpy.linalg.norm", "numpy.linalg.norm", "print", "print", "print", "print", "print", "print", "print", "print", "numpy.ones", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.getRANSACInliers", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.estimateSimilarityUmeyama"], ["def", "estimateSimilarityTransform", "(", "source", ":", "np", ".", "array", ",", "target", ":", "np", ".", "array", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "SourceHom", "=", "np", ".", "transpose", "(", "np", ".", "hstack", "(", "[", "source", ",", "np", ".", "ones", "(", "[", "source", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "]", ")", ")", "\n", "TargetHom", "=", "np", ".", "transpose", "(", "np", ".", "hstack", "(", "[", "target", ",", "np", ".", "ones", "(", "[", "source", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "]", ")", ")", "\n", "\n", "# Auto-parameter selection based on source-target heuristics", "\n", "TargetNorm", "=", "np", ".", "mean", "(", "np", ".", "linalg", ".", "norm", "(", "target", ",", "axis", "=", "1", ")", ")", "\n", "SourceNorm", "=", "np", ".", "mean", "(", "np", ".", "linalg", ".", "norm", "(", "source", ",", "axis", "=", "1", ")", ")", "\n", "RatioTS", "=", "(", "TargetNorm", "/", "SourceNorm", ")", "\n", "RatioST", "=", "(", "SourceNorm", "/", "TargetNorm", ")", "\n", "PassT", "=", "RatioST", "if", "(", "RatioST", ">", "RatioTS", ")", "else", "RatioTS", "\n", "StopT", "=", "PassT", "/", "100", "\n", "nIter", "=", "100", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'Pass threshold: '", ",", "PassT", ")", "\n", "print", "(", "'Stop threshold: '", ",", "StopT", ")", "\n", "print", "(", "'Number of iterations: '", ",", "nIter", ")", "\n", "\n", "", "SourceInliersHom", ",", "TargetInliersHom", ",", "BestInlierRatio", "=", "getRANSACInliers", "(", "SourceHom", ",", "TargetHom", ",", "MaxIterations", "=", "nIter", ",", "PassThreshold", "=", "PassT", ",", "StopThreshold", "=", "StopT", ")", "\n", "\n", "if", "(", "BestInlierRatio", "<", "0.1", ")", ":", "\n", "        ", "print", "(", "'[ WARN ] - Something is wrong. Small BestInlierRatio: '", ",", "BestInlierRatio", ")", "\n", "return", "None", ",", "None", ",", "None", ",", "None", "\n", "\n", "", "Scales", ",", "Rotation", ",", "Translation", ",", "OutTransform", "=", "estimateSimilarityUmeyama", "(", "SourceInliersHom", ",", "TargetInliersHom", ")", "\n", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'BestInlierRatio:'", ",", "BestInlierRatio", ")", "\n", "print", "(", "'Rotation:\\n'", ",", "Rotation", ")", "\n", "print", "(", "'Translation:\\n'", ",", "Translation", ")", "\n", "print", "(", "'Scales:'", ",", "Scales", ")", "\n", "\n", "", "return", "Scales", ",", "Rotation", ",", "Translation", ",", "OutTransform", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.estimateRestrictedAffineTransform": [[45, 95], ["numpy.transpose", "numpy.transpose", "cv2.estimateAffine3D", "numpy.linalg.svd", "list", "numpy.identity", "numpy.identity", "numpy.hstack", "numpy.hstack", "print", "itertools.permutations", "numpy.asarray", "numpy.identity", "aligning.evaluateModelNonHom", "print", "print", "print", "print", "print", "numpy.diag", "print", "print", "print", "numpy.ones", "numpy.ones", "aligning.evaluateModelNoThresh", "numpy.diag"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.evaluateModelNonHom", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.evaluateModelNoThresh"], ["", "def", "estimateRestrictedAffineTransform", "(", "source", ":", "np", ".", "array", ",", "target", ":", "np", ".", "array", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "SourceHom", "=", "np", ".", "transpose", "(", "np", ".", "hstack", "(", "[", "source", ",", "np", ".", "ones", "(", "[", "source", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "]", ")", ")", "\n", "TargetHom", "=", "np", ".", "transpose", "(", "np", ".", "hstack", "(", "[", "target", ",", "np", ".", "ones", "(", "[", "source", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "]", ")", ")", "\n", "\n", "RetVal", ",", "AffineTrans", ",", "Inliers", "=", "cv2", ".", "estimateAffine3D", "(", "source", ",", "target", ")", "\n", "# We assume no shear in the affine matrix and decompose into rotation, non-uniform scales, and translation", "\n", "Translation", "=", "AffineTrans", "[", ":", "3", ",", "3", "]", "\n", "NUScaleRotMat", "=", "AffineTrans", "[", ":", "3", ",", ":", "3", "]", "\n", "# NUScaleRotMat should be the matrix SR, where S is a diagonal scale matrix and R is the rotation matrix (equivalently RS)", "\n", "# Let us do the SVD of NUScaleRotMat to obtain R1*S*R2 and then R = R1 * R2", "\n", "R1", ",", "ScalesSorted", ",", "R2", "=", "np", ".", "linalg", ".", "svd", "(", "NUScaleRotMat", ",", "full_matrices", "=", "True", ")", "\n", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'-----------------------------------------------------------------------'", ")", "\n", "# Now, the scales are sort in ascending order which is painful because we don't know the x, y, z scales", "\n", "# Let's figure that out by evaluating all 6 possible permutations of the scales", "\n", "", "ScalePermutations", "=", "list", "(", "itertools", ".", "permutations", "(", "ScalesSorted", ")", ")", "\n", "MinResidual", "=", "1e8", "\n", "Scales", "=", "ScalePermutations", "[", "0", "]", "\n", "OutTransform", "=", "np", ".", "identity", "(", "4", ")", "\n", "Rotation", "=", "np", ".", "identity", "(", "3", ")", "\n", "for", "ScaleCand", "in", "ScalePermutations", ":", "\n", "        ", "CurrScale", "=", "np", ".", "asarray", "(", "ScaleCand", ")", "\n", "CurrTransform", "=", "np", ".", "identity", "(", "4", ")", "\n", "CurrRotation", "=", "(", "np", ".", "diag", "(", "1", "/", "CurrScale", ")", "@", "NUScaleRotMat", ")", ".", "transpose", "(", ")", "\n", "CurrTransform", "[", ":", "3", ",", ":", "3", "]", "=", "np", ".", "diag", "(", "CurrScale", ")", "@", "CurrRotation", "\n", "CurrTransform", "[", ":", "3", ",", "3", "]", "=", "Translation", "\n", "# Residual = evaluateModel(CurrTransform, SourceHom, TargetHom)", "\n", "Residual", "=", "evaluateModelNonHom", "(", "source", ",", "target", ",", "CurrScale", ",", "CurrRotation", ",", "Translation", ")", "\n", "if", "verbose", ":", "\n", "# print('CurrTransform:\\n', CurrTransform)", "\n", "            ", "print", "(", "'CurrScale:'", ",", "CurrScale", ")", "\n", "print", "(", "'Residual:'", ",", "Residual", ")", "\n", "print", "(", "'AltRes:'", ",", "evaluateModelNoThresh", "(", "CurrTransform", ",", "SourceHom", ",", "TargetHom", ")", ")", "\n", "", "if", "Residual", "<", "MinResidual", ":", "\n", "            ", "MinResidual", "=", "Residual", "\n", "Scales", "=", "CurrScale", "\n", "Rotation", "=", "CurrRotation", "\n", "OutTransform", "=", "CurrTransform", "\n", "\n", "", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'Best Scale:'", ",", "Scales", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'Affine Scales:'", ",", "Scales", ")", "\n", "print", "(", "'Affine Translation:'", ",", "Translation", ")", "\n", "print", "(", "'Affine Rotation:\\n'", ",", "Rotation", ")", "\n", "print", "(", "'-----------------------------------------------------------------------'", ")", "\n", "\n", "", "return", "Scales", ",", "Rotation", ",", "Translation", ",", "OutTransform", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.getRANSACInliers": [[96, 117], ["numpy.arange", "range", "numpy.random.randint", "aligning.estimateSimilarityUmeyama", "aligning.evaluateModel"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.estimateSimilarityUmeyama", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.evaluateModel"], ["", "def", "getRANSACInliers", "(", "SourceHom", ",", "TargetHom", ",", "MaxIterations", "=", "100", ",", "PassThreshold", "=", "200", ",", "StopThreshold", "=", "1", ")", ":", "\n", "    ", "BestResidual", "=", "1e10", "\n", "BestInlierRatio", "=", "0", "\n", "BestInlierIdx", "=", "np", ".", "arange", "(", "SourceHom", ".", "shape", "[", "1", "]", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "MaxIterations", ")", ":", "\n", "# Pick 5 random (but corresponding) points from source and target", "\n", "        ", "RandIdx", "=", "np", ".", "random", ".", "randint", "(", "SourceHom", ".", "shape", "[", "1", "]", ",", "size", "=", "5", ")", "\n", "_", ",", "_", ",", "_", ",", "OutTransform", "=", "estimateSimilarityUmeyama", "(", "SourceHom", "[", ":", ",", "RandIdx", "]", ",", "TargetHom", "[", ":", ",", "RandIdx", "]", ")", "\n", "Residual", ",", "InlierRatio", ",", "InlierIdx", "=", "evaluateModel", "(", "OutTransform", ",", "SourceHom", ",", "TargetHom", ",", "PassThreshold", ")", "\n", "if", "Residual", "<", "BestResidual", ":", "\n", "            ", "BestResidual", "=", "Residual", "\n", "BestInlierRatio", "=", "InlierRatio", "\n", "BestInlierIdx", "=", "InlierIdx", "\n", "", "if", "BestResidual", "<", "StopThreshold", ":", "\n", "            ", "break", "\n", "\n", "# print('Iteration: ', i)", "\n", "# print('Residual: ', Residual)", "\n", "# print('Inlier ratio: ', InlierRatio)", "\n", "\n", "", "", "return", "SourceHom", "[", ":", ",", "BestInlierIdx", "]", ",", "TargetHom", "[", ":", ",", "BestInlierIdx", "]", ",", "BestInlierRatio", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.evaluateModel": [[118, 126], ["numpy.linalg.norm", "numpy.linalg.norm", "numpy.where", "numpy.count_nonzero", "numpy.matmul"], "function", ["None"], ["", "def", "evaluateModel", "(", "OutTransform", ",", "SourceHom", ",", "TargetHom", ",", "PassThreshold", ")", ":", "\n", "    ", "Diff", "=", "TargetHom", "-", "np", ".", "matmul", "(", "OutTransform", ",", "SourceHom", ")", "\n", "ResidualVec", "=", "np", ".", "linalg", ".", "norm", "(", "Diff", "[", ":", "3", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "Residual", "=", "np", ".", "linalg", ".", "norm", "(", "ResidualVec", ")", "\n", "InlierIdx", "=", "np", ".", "where", "(", "ResidualVec", "<", "PassThreshold", ")", "\n", "nInliers", "=", "np", ".", "count_nonzero", "(", "InlierIdx", ")", "\n", "InlierRatio", "=", "nInliers", "/", "SourceHom", ".", "shape", "[", "1", "]", "\n", "return", "Residual", ",", "InlierRatio", ",", "InlierIdx", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.evaluateModelNoThresh": [[127, 132], ["numpy.linalg.norm", "numpy.linalg.norm", "numpy.matmul"], "function", ["None"], ["", "def", "evaluateModelNoThresh", "(", "OutTransform", ",", "SourceHom", ",", "TargetHom", ")", ":", "\n", "    ", "Diff", "=", "TargetHom", "-", "np", ".", "matmul", "(", "OutTransform", ",", "SourceHom", ")", "\n", "ResidualVec", "=", "np", ".", "linalg", ".", "norm", "(", "Diff", "[", ":", "3", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "Residual", "=", "np", ".", "linalg", ".", "norm", "(", "ResidualVec", ")", "\n", "return", "Residual", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.evaluateModelNonHom": [[133, 140], ["numpy.tile", "numpy.linalg.norm", "numpy.linalg.norm", "np.tile.transpose", "source.transpose", "numpy.diag"], "function", ["None"], ["", "def", "evaluateModelNonHom", "(", "source", ",", "target", ",", "Scales", ",", "Rotation", ",", "Translation", ")", ":", "\n", "    ", "RepTrans", "=", "np", ".", "tile", "(", "Translation", ",", "(", "source", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "TransSource", "=", "(", "np", ".", "diag", "(", "Scales", ")", "@", "Rotation", "@", "source", ".", "transpose", "(", ")", "+", "RepTrans", ".", "transpose", "(", ")", ")", ".", "transpose", "(", ")", "\n", "Diff", "=", "target", "-", "TransSource", "\n", "ResidualVec", "=", "np", ".", "linalg", ".", "norm", "(", "Diff", ",", "axis", "=", "0", ")", "\n", "Residual", "=", "np", ".", "linalg", ".", "norm", "(", "ResidualVec", ")", "\n", "return", "Residual", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.testNonUniformScale": [[141, 156], ["numpy.matmul", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.vstack", "print", "numpy.array", "numpy.linalg.pinv", "numpy.linalg.norm"], "function", ["None"], ["", "def", "testNonUniformScale", "(", "SourceHom", ",", "TargetHom", ")", ":", "\n", "    ", "OutTransform", "=", "np", ".", "matmul", "(", "TargetHom", ",", "np", ".", "linalg", ".", "pinv", "(", "SourceHom", ")", ")", "\n", "ScaledRotation", "=", "OutTransform", "[", ":", "3", ",", ":", "3", "]", "\n", "Translation", "=", "OutTransform", "[", ":", "3", ",", "3", "]", "\n", "Sx", "=", "np", ".", "linalg", ".", "norm", "(", "ScaledRotation", "[", "0", ",", ":", "]", ")", "\n", "Sy", "=", "np", ".", "linalg", ".", "norm", "(", "ScaledRotation", "[", "1", ",", ":", "]", ")", "\n", "Sz", "=", "np", ".", "linalg", ".", "norm", "(", "ScaledRotation", "[", "2", ",", ":", "]", ")", "\n", "Rotation", "=", "np", ".", "vstack", "(", "[", "ScaledRotation", "[", "0", ",", ":", "]", "/", "Sx", ",", "ScaledRotation", "[", "1", ",", ":", "]", "/", "Sy", ",", "ScaledRotation", "[", "2", ",", ":", "]", "/", "Sz", "]", ")", "\n", "print", "(", "'Rotation matrix norm:'", ",", "np", ".", "linalg", ".", "norm", "(", "Rotation", ")", ")", "\n", "Scales", "=", "np", ".", "array", "(", "[", "Sx", ",", "Sy", ",", "Sz", "]", ")", "\n", "\n", "# # Check", "\n", "# Diff = TargetHom - np.matmul(OutTransform, SourceHom)", "\n", "# Residual = np.linalg.norm(Diff[:3, :], axis=0)", "\n", "return", "Scales", ",", "Rotation", ",", "Translation", ",", "OutTransform", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.estimateSimilarityUmeyama": [[157, 197], ["numpy.mean", "numpy.mean", "numpy.isnan().any", "numpy.linalg.svd", "numpy.var().sum", "numpy.array", "numpy.diag", "numpy.identity", "numpy.tile().transpose", "numpy.tile().transpose", "numpy.matmul", "print", "print", "print", "RuntimeError", "numpy.matmul", "numpy.sum", "TargetHom[].mean", "SourceHom[].mean().dot", "numpy.transpose", "numpy.isnan", "numpy.linalg.det", "numpy.linalg.det", "numpy.var", "numpy.tile", "numpy.tile", "SourceHom[].mean"], "function", ["None"], ["", "def", "estimateSimilarityUmeyama", "(", "SourceHom", ",", "TargetHom", ")", ":", "\n", "# Copy of original paper is at: http://web.stanford.edu/class/cs273/refs/umeyama.pdf", "\n", "    ", "SourceCentroid", "=", "np", ".", "mean", "(", "SourceHom", "[", ":", "3", ",", ":", "]", ",", "axis", "=", "1", ")", "\n", "TargetCentroid", "=", "np", ".", "mean", "(", "TargetHom", "[", ":", "3", ",", ":", "]", ",", "axis", "=", "1", ")", "\n", "nPoints", "=", "SourceHom", ".", "shape", "[", "1", "]", "\n", "\n", "CenteredSource", "=", "SourceHom", "[", ":", "3", ",", ":", "]", "-", "np", ".", "tile", "(", "SourceCentroid", ",", "(", "nPoints", ",", "1", ")", ")", ".", "transpose", "(", ")", "\n", "CenteredTarget", "=", "TargetHom", "[", ":", "3", ",", ":", "]", "-", "np", ".", "tile", "(", "TargetCentroid", ",", "(", "nPoints", ",", "1", ")", ")", ".", "transpose", "(", ")", "\n", "\n", "CovMatrix", "=", "np", ".", "matmul", "(", "CenteredTarget", ",", "np", ".", "transpose", "(", "CenteredSource", ")", ")", "/", "nPoints", "\n", "\n", "if", "np", ".", "isnan", "(", "CovMatrix", ")", ".", "any", "(", ")", ":", "\n", "        ", "print", "(", "'nPoints:'", ",", "nPoints", ")", "\n", "print", "(", "SourceHom", ".", "shape", ")", "\n", "print", "(", "TargetHom", ".", "shape", ")", "\n", "raise", "RuntimeError", "(", "'There are NANs in the input.'", ")", "\n", "\n", "", "U", ",", "D", ",", "Vh", "=", "np", ".", "linalg", ".", "svd", "(", "CovMatrix", ",", "full_matrices", "=", "True", ")", "\n", "d", "=", "(", "np", ".", "linalg", ".", "det", "(", "U", ")", "*", "np", ".", "linalg", ".", "det", "(", "Vh", ")", ")", "<", "0.0", "\n", "if", "d", ":", "\n", "        ", "D", "[", "-", "1", "]", "=", "-", "D", "[", "-", "1", "]", "\n", "U", "[", ":", ",", "-", "1", "]", "=", "-", "U", "[", ":", ",", "-", "1", "]", "\n", "\n", "", "Rotation", "=", "np", ".", "matmul", "(", "U", ",", "Vh", ")", ".", "T", "# Transpose is the one that works", "\n", "\n", "varP", "=", "np", ".", "var", "(", "SourceHom", "[", ":", "3", ",", ":", "]", ",", "axis", "=", "1", ")", ".", "sum", "(", ")", "\n", "ScaleFact", "=", "1", "/", "varP", "*", "np", ".", "sum", "(", "D", ")", "# scale factor", "\n", "Scales", "=", "np", ".", "array", "(", "[", "ScaleFact", ",", "ScaleFact", ",", "ScaleFact", "]", ")", "\n", "ScaleMatrix", "=", "np", ".", "diag", "(", "Scales", ")", "\n", "\n", "Translation", "=", "TargetHom", "[", ":", "3", ",", ":", "]", ".", "mean", "(", "axis", "=", "1", ")", "-", "SourceHom", "[", ":", "3", ",", ":", "]", ".", "mean", "(", "axis", "=", "1", ")", ".", "dot", "(", "ScaleFact", "*", "Rotation", ")", "\n", "\n", "OutTransform", "=", "np", ".", "identity", "(", "4", ")", "\n", "OutTransform", "[", ":", "3", ",", ":", "3", "]", "=", "ScaleMatrix", "@", "Rotation", "\n", "OutTransform", "[", ":", "3", ",", "3", "]", "=", "Translation", "\n", "\n", "# # Check", "\n", "# Diff = TargetHom - np.matmul(OutTransform, SourceHom)", "\n", "# Residual = np.linalg.norm(Diff[:3, :], axis=0)", "\n", "return", "Scales", ",", "Rotation", ",", "Translation", ",", "OutTransform", "\n", "", ""]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.BatchNorm.call": [[59, 61], ["super().call"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.DetectionLayer.call"], ["def", "call", "(", "self", ",", "inputs", ",", "training", "=", "None", ")", ":", "\n", "        ", "return", "super", "(", "self", ".", "__class__", ",", "self", ")", ".", "call", "(", "inputs", ",", "training", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.ProposalLayer.__init__": [[232, 242], ["keras.Layer.__init__", "anchors.astype"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.__init__"], ["def", "__init__", "(", "self", ",", "proposal_count", ",", "nms_threshold", ",", "anchors", ",", "\n", "config", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        anchors: [N, (y1, x1, y2, x2)] anchors defined in image coordinates\n        \"\"\"", "\n", "super", "(", "ProposalLayer", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "config", "=", "config", "\n", "self", ".", "proposal_count", "=", "proposal_count", "\n", "self", ".", "nms_threshold", "=", "nms_threshold", "\n", "self", ".", "anchors", "=", "anchors", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.ProposalLayer.call": [[243, 299], ["min", "utils.batch_slice", "utils.batch_slice", "utils.batch_slice", "utils.batch_slice", "numpy.array().astype", "utils.batch_slice", "utils.batch_slice", "numpy.reshape", "tensorflow.nn.top_k", "numpy.array", "tensorflow.image.non_max_suppression", "tensorflow.gather", "tensorflow.concat", "tensorflow.gather", "tensorflow.gather", "tensorflow.gather", "model.apply_box_deltas_graph", "numpy.array", "model.clip_boxes_graph", "tensorflow.shape", "tensorflow.zeros"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.batch_slice", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.batch_slice", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.batch_slice", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.batch_slice", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.batch_slice", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.batch_slice", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.non_max_suppression", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.apply_box_deltas_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.clip_boxes_graph"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "# Box Scores. Use the foreground class confidence. [Batch, num_rois, 1]", "\n", "        ", "scores", "=", "inputs", "[", "0", "]", "[", ":", ",", ":", ",", "1", "]", "\n", "# Box deltas [batch, num_rois, 4]", "\n", "deltas", "=", "inputs", "[", "1", "]", "\n", "deltas", "=", "deltas", "*", "np", ".", "reshape", "(", "self", ".", "config", ".", "RPN_BBOX_STD_DEV", ",", "[", "1", ",", "1", ",", "4", "]", ")", "\n", "# Base anchors", "\n", "anchors", "=", "self", ".", "anchors", "\n", "\n", "# Improve performance by trimming to top anchors by score", "\n", "# and doing the rest on the smaller subset.", "\n", "pre_nms_limit", "=", "min", "(", "10000", ",", "self", ".", "anchors", ".", "shape", "[", "0", "]", ")", "\n", "ix", "=", "tf", ".", "nn", ".", "top_k", "(", "scores", ",", "pre_nms_limit", ",", "sorted", "=", "True", ",", "name", "=", "\"top_anchors\"", ")", ".", "indices", "\n", "scores", "=", "utils", ".", "batch_slice", "(", "[", "scores", ",", "ix", "]", ",", "lambda", "x", ",", "y", ":", "tf", ".", "gather", "(", "x", ",", "y", ")", ",", "\n", "self", ".", "config", ".", "IMAGES_PER_GPU", ")", "\n", "deltas", "=", "utils", ".", "batch_slice", "(", "[", "deltas", ",", "ix", "]", ",", "lambda", "x", ",", "y", ":", "tf", ".", "gather", "(", "x", ",", "y", ")", ",", "\n", "self", ".", "config", ".", "IMAGES_PER_GPU", ")", "\n", "anchors", "=", "utils", ".", "batch_slice", "(", "ix", ",", "lambda", "x", ":", "tf", ".", "gather", "(", "anchors", ",", "x", ")", ",", "\n", "self", ".", "config", ".", "IMAGES_PER_GPU", ",", "\n", "names", "=", "[", "\"pre_nms_anchors\"", "]", ")", "\n", "\n", "# Apply deltas to anchors to get refined anchors.", "\n", "# [batch, N, (y1, x1, y2, x2)]", "\n", "boxes", "=", "utils", ".", "batch_slice", "(", "[", "anchors", ",", "deltas", "]", ",", "\n", "lambda", "x", ",", "y", ":", "apply_box_deltas_graph", "(", "x", ",", "y", ")", ",", "\n", "self", ".", "config", ".", "IMAGES_PER_GPU", ",", "\n", "names", "=", "[", "\"refined_anchors\"", "]", ")", "\n", "\n", "# Clip to image boundaries. [batch, N, (y1, x1, y2, x2)]", "\n", "height", ",", "width", "=", "self", ".", "config", ".", "IMAGE_SHAPE", "[", ":", "2", "]", "\n", "window", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "height", ",", "width", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "boxes", "=", "utils", ".", "batch_slice", "(", "boxes", ",", "\n", "lambda", "x", ":", "clip_boxes_graph", "(", "x", ",", "window", ")", ",", "\n", "self", ".", "config", ".", "IMAGES_PER_GPU", ",", "\n", "names", "=", "[", "\"refined_anchors_clipped\"", "]", ")", "\n", "\n", "# Filter out small boxes", "\n", "# According to Xinlei Chen's paper, this reduces detection accuracy", "\n", "# for small objects, so we're skipping it.", "\n", "\n", "# Normalize dimensions to range of 0 to 1.", "\n", "normalized_boxes", "=", "boxes", "/", "np", ".", "array", "(", "[", "[", "height", ",", "width", ",", "height", ",", "width", "]", "]", ")", "\n", "\n", "# Non-max suppression", "\n", "def", "nms", "(", "normalized_boxes", ",", "scores", ")", ":", "\n", "            ", "indices", "=", "tf", ".", "image", ".", "non_max_suppression", "(", "\n", "normalized_boxes", ",", "scores", ",", "self", ".", "proposal_count", ",", "\n", "self", ".", "nms_threshold", ",", "name", "=", "\"rpn_non_max_suppression\"", ")", "\n", "proposals", "=", "tf", ".", "gather", "(", "normalized_boxes", ",", "indices", ")", "\n", "# Pad if needed", "\n", "padding", "=", "self", ".", "proposal_count", "-", "tf", ".", "shape", "(", "proposals", ")", "[", "0", "]", "\n", "proposals", "=", "tf", ".", "concat", "(", "[", "proposals", ",", "tf", ".", "zeros", "(", "[", "padding", ",", "4", "]", ")", "]", ",", "0", ")", "\n", "return", "proposals", "\n", "", "proposals", "=", "utils", ".", "batch_slice", "(", "[", "normalized_boxes", ",", "scores", "]", ",", "nms", ",", "\n", "self", ".", "config", ".", "IMAGES_PER_GPU", ")", "\n", "return", "proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.ProposalLayer.compute_output_shape": [[300, 302], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "(", "None", ",", "self", ".", "proposal_count", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.PyramidROIAlign.__init__": [[332, 336], ["keras.Layer.__init__", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.__init__"], ["def", "__init__", "(", "self", ",", "pool_shape", ",", "image_shape", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "PyramidROIAlign", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "pool_shape", "=", "tuple", "(", "pool_shape", ")", "\n", "self", ".", "image_shape", "=", "tuple", "(", "image_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.PyramidROIAlign.call": [[337, 410], ["tensorflow.split", "tensorflow.cast", "model.log2_graph", "tensorflow.minimum", "tensorflow.squeeze", "enumerate", "tensorflow.concat", "tensorflow.concat", "tensorflow.expand_dims", "tensorflow.concat", "tensorflow.gather", "tensorflow.gather", "tensorflow.expand_dims", "tensorflow.maximum", "range", "tensorflow.where", "tensorflow.gather_nd", "tensorflow.cast", "tensorflow.concat.append", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.expand_dims.append", "tensorflow.range", "tensorflow.sqrt", "tensorflow.equal", "tensorflow.image.crop_and_resize", "tensorflow.cast", "tensorflow.nn.top_k", "tensorflow.sqrt", "tensorflow.cast", "tensorflow.shape", "tensorflow.round", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log2_graph"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "# Crop boxes [batch, num_boxes, (y1, x1, y2, x2)] in normalized coords", "\n", "        ", "boxes", "=", "inputs", "[", "0", "]", "\n", "\n", "# Feature Maps. List of feature maps from different level of the", "\n", "# feature pyramid. Each is [batch, height, width, channels]", "\n", "feature_maps", "=", "inputs", "[", "1", ":", "]", "\n", "\n", "# Assign each ROI to a level in the pyramid based on the ROI area.", "\n", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "tf", ".", "split", "(", "boxes", ",", "4", ",", "axis", "=", "2", ")", "\n", "h", "=", "y2", "-", "y1", "\n", "w", "=", "x2", "-", "x1", "\n", "# Equation 1 in the Feature Pyramid Networks paper. Account for", "\n", "# the fact that our coordinates are normalized here.", "\n", "# e.g. a 224x224 ROI (in pixels) maps to P4", "\n", "image_area", "=", "tf", ".", "cast", "(", "self", ".", "image_shape", "[", "0", "]", "*", "self", ".", "image_shape", "[", "1", "]", ",", "tf", ".", "float32", ")", "\n", "\n", "# equivalent to tf.sqrt(h*w*image_area)/224", "\n", "roi_level", "=", "log2_graph", "(", "tf", ".", "sqrt", "(", "h", "*", "w", ")", "/", "(", "224.0", "/", "tf", ".", "sqrt", "(", "image_area", ")", ")", ")", "\n", "roi_level", "=", "tf", ".", "minimum", "(", "5", ",", "tf", ".", "maximum", "(", "2", ",", "4", "+", "tf", ".", "cast", "(", "tf", ".", "round", "(", "roi_level", ")", ",", "tf", ".", "int32", ")", ")", ")", "\n", "roi_level", "=", "tf", ".", "squeeze", "(", "roi_level", ",", "2", ")", "\n", "\n", "# Loop through levels and apply ROI pooling to each. P2 to P5.", "\n", "pooled", "=", "[", "]", "\n", "box_to_level", "=", "[", "]", "\n", "for", "i", ",", "level", "in", "enumerate", "(", "range", "(", "2", ",", "6", ")", ")", ":", "\n", "            ", "ix", "=", "tf", ".", "where", "(", "tf", ".", "equal", "(", "roi_level", ",", "level", ")", ")", "\n", "level_boxes", "=", "tf", ".", "gather_nd", "(", "boxes", ",", "ix", ")", "\n", "\n", "# Box indicies for crop_and_resize.", "\n", "box_indices", "=", "tf", ".", "cast", "(", "ix", "[", ":", ",", "0", "]", ",", "tf", ".", "int32", ")", "\n", "\n", "# Keep track of which box is mapped to which level", "\n", "box_to_level", ".", "append", "(", "ix", ")", "\n", "\n", "# Stop gradient propogation to ROI proposals", "\n", "level_boxes", "=", "tf", ".", "stop_gradient", "(", "level_boxes", ")", "\n", "box_indices", "=", "tf", ".", "stop_gradient", "(", "box_indices", ")", "\n", "\n", "# Crop and Resize", "\n", "# From Mask R-CNN paper: \"We sample four regular locations, so", "\n", "# that we can evaluate either max or average pooling. In fact,", "\n", "# interpolating only a single value at each bin center (without", "\n", "# pooling) is nearly as effective.\"", "\n", "#", "\n", "# Here we use the simplified approach of a single value per bin,", "\n", "# which is how it's done in tf.crop_and_resize()", "\n", "# Result: [batch * num_boxes, pool_height, pool_width, channels]", "\n", "pooled", ".", "append", "(", "tf", ".", "image", ".", "crop_and_resize", "(", "\n", "feature_maps", "[", "i", "]", ",", "level_boxes", ",", "box_indices", ",", "self", ".", "pool_shape", ",", "\n", "method", "=", "\"bilinear\"", ")", ")", "\n", "\n", "# Pack pooled features into one tensor", "\n", "", "pooled", "=", "tf", ".", "concat", "(", "pooled", ",", "axis", "=", "0", ")", "\n", "\n", "# Pack box_to_level mapping into one array and add another", "\n", "# column representing the order of pooled boxes", "\n", "box_to_level", "=", "tf", ".", "concat", "(", "box_to_level", ",", "axis", "=", "0", ")", "\n", "box_range", "=", "tf", ".", "expand_dims", "(", "tf", ".", "range", "(", "tf", ".", "shape", "(", "box_to_level", ")", "[", "0", "]", ")", ",", "1", ")", "\n", "box_to_level", "=", "tf", ".", "concat", "(", "[", "tf", ".", "cast", "(", "box_to_level", ",", "tf", ".", "int32", ")", ",", "box_range", "]", ",", "\n", "axis", "=", "1", ")", "\n", "\n", "# Rearrange pooled features to match the order of the original boxes", "\n", "# Sort box_to_level by batch then box index", "\n", "# TF doesn't have a way to sort by two columns, so merge them and sort.", "\n", "sorting_tensor", "=", "box_to_level", "[", ":", ",", "0", "]", "*", "100000", "+", "box_to_level", "[", ":", ",", "1", "]", "\n", "ix", "=", "tf", ".", "nn", ".", "top_k", "(", "sorting_tensor", ",", "k", "=", "tf", ".", "shape", "(", "box_to_level", ")", "[", "0", "]", ")", ".", "indices", "[", ":", ":", "-", "1", "]", "\n", "ix", "=", "tf", ".", "gather", "(", "box_to_level", "[", ":", ",", "2", "]", ",", "ix", ")", "\n", "pooled", "=", "tf", ".", "gather", "(", "pooled", ",", "ix", ")", "\n", "\n", "# Re-add the batch dimension", "\n", "pooled", "=", "tf", ".", "expand_dims", "(", "pooled", ",", "0", ")", "\n", "return", "pooled", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.PyramidROIAlign.compute_output_shape": [[411, 413], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "[", "0", "]", "[", ":", "2", "]", "+", "self", ".", "pool_shape", "+", "(", "input_shape", "[", "1", "]", "[", "-", "1", "]", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.DetectionTargetLayer.__init__": [[635, 638], ["keras.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.__init__"], ["def", "__init__", "(", "self", ",", "config", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "DetectionTargetLayer", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "config", "=", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.DetectionTargetLayer.call": [[639, 655], ["utils.batch_slice", "model.detection_targets_graph"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.batch_slice", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.detection_targets_graph"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "proposals", "=", "inputs", "[", "0", "]", "\n", "gt_boxes", "=", "inputs", "[", "1", "]", "\n", "gt_masks", "=", "inputs", "[", "2", "]", "\n", "gt_coords", "=", "inputs", "[", "3", "]", "\n", "\n", "# Slice the batch and run a graph for each slice", "\n", "# TODO: Optimize by supporting batch > 1", "\n", "# TODO: Rename target_bbox to target_deltas for clarity", "\n", "names", "=", "[", "\"rois\"", ",", "\"target_class_ids\"", ",", "\"target_bbox\"", ",", "\"target_mask\"", ",", "\n", "\"target_coord_x\"", ",", "\"target_coord_y\"", ",", "\"target_coord_z\"", "]", "\n", "outputs", "=", "utils", ".", "batch_slice", "(", "\n", "[", "proposals", ",", "gt_boxes", ",", "gt_masks", ",", "gt_coords", "]", ",", "\n", "lambda", "x", ",", "y", ",", "z", ",", "u", ":", "detection_targets_graph", "(", "x", ",", "y", ",", "z", ",", "u", ",", "self", ".", "config", ")", ",", "\n", "self", ".", "config", ".", "IMAGES_PER_GPU", ",", "names", "=", "names", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.DetectionTargetLayer.compute_output_shape": [[656, 665], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "[", "\n", "(", "None", ",", "self", ".", "config", ".", "TRAIN_ROIS_PER_IMAGE", ",", "4", ")", ",", "# rois", "\n", "(", "None", ",", "1", ")", ",", "# class_ids", "\n", "(", "None", ",", "self", ".", "config", ".", "TRAIN_ROIS_PER_IMAGE", ",", "4", ")", ",", "# deltas", "\n", "(", "None", ",", "self", ".", "config", ".", "TRAIN_ROIS_PER_IMAGE", ",", "self", ".", "config", ".", "MASK_SHAPE", "[", "0", "]", ",", "self", ".", "config", ".", "MASK_SHAPE", "[", "1", "]", ")", ",", "# masks", "\n", "(", "None", ",", "self", ".", "config", ".", "TRAIN_ROIS_PER_IMAGE", ",", "self", ".", "config", ".", "COORD_SHAPE", "[", "0", "]", ",", "self", ".", "config", ".", "COORD_SHAPE", "[", "1", "]", ")", ",", "# coordinate_x", "\n", "(", "None", ",", "self", ".", "config", ".", "TRAIN_ROIS_PER_IMAGE", ",", "self", ".", "config", ".", "COORD_SHAPE", "[", "0", "]", ",", "self", ".", "config", ".", "COORD_SHAPE", "[", "1", "]", ")", ",", "# coordinate_y", "\n", "(", "None", ",", "self", ".", "config", ".", "TRAIN_ROIS_PER_IMAGE", ",", "self", ".", "config", ".", "COORD_SHAPE", "[", "0", "]", ",", "self", ".", "config", ".", "COORD_SHAPE", "[", "1", "]", ")", "# coordinate_z", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.DetectionTargetLayer.compute_mask": [[667, 669], ["None"], "methods", ["None"], ["", "def", "compute_mask", "(", "self", ",", "inputs", ",", "mask", "=", "None", ")", ":", "\n", "        ", "return", "[", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.DetectionLayer.__init__": [[768, 771], ["keras.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.__init__"], ["def", "__init__", "(", "self", ",", "config", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "DetectionLayer", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "config", "=", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.DetectionLayer.call": [[772, 797], ["tensorflow.py_func", "model.parse_image_meta", "model.refine_detections", "numpy.pad.astype", "numpy.reshape", "numpy.pad"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.parse_image_meta", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.refine_detections"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "def", "wrapper", "(", "rois", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "image_meta", ")", ":", "\n", "# currently supports one image per batch", "\n", "            ", "b", "=", "0", "\n", "_", ",", "_", ",", "window", ",", "_", "=", "parse_image_meta", "(", "image_meta", ")", "\n", "detections", "=", "refine_detections", "(", "\n", "rois", "[", "b", "]", ",", "mrcnn_class", "[", "b", "]", ",", "mrcnn_bbox", "[", "b", "]", ",", "window", "[", "b", "]", ",", "self", ".", "config", ")", "\n", "# Pad with zeros if detections < DETECTION_MAX_INSTANCES", "\n", "gap", "=", "self", ".", "config", ".", "DETECTION_MAX_INSTANCES", "-", "detections", ".", "shape", "[", "0", "]", "\n", "assert", "gap", ">=", "0", "\n", "if", "gap", ">", "0", ":", "\n", "                ", "detections", "=", "np", ".", "pad", "(", "detections", ",", "[", "(", "0", ",", "gap", ")", ",", "(", "0", ",", "0", ")", "]", ",", "\n", "'constant'", ",", "constant_values", "=", "0", ")", "\n", "\n", "# Cast to float32", "\n", "# TODO: track where float64 is introduced", "\n", "", "detections", "=", "detections", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# Reshape output", "\n", "# [batch, num_detections, (y1, x1, y2, x2, class_score)] in pixels", "\n", "return", "np", ".", "reshape", "(", "detections", ",", "\n", "[", "1", ",", "self", ".", "config", ".", "DETECTION_MAX_INSTANCES", ",", "6", "]", ")", "\n", "\n", "# Return wrapped function", "\n", "", "return", "tf", ".", "py_func", "(", "wrapper", ",", "inputs", ",", "tf", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.DetectionLayer.compute_output_shape": [[798, 800], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "(", "None", ",", "self", ".", "config", ".", "DETECTION_MAX_INSTANCES", ",", "6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.__init__": [[3182, 3196], ["model.MaskRCNN.set_log_dir", "model.MaskRCNN.build"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.set_log_dir", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.build"], ["def", "__init__", "(", "self", ",", "mode", ",", "config", ",", "model_dir", ")", ":", "\n", "        ", "\"\"\"\n        mode: Either \"training\" or \"inference\"\n        config: A Sub-class of the Config class\n        model_dir: Directory to save training logs and trained weights\n        \"\"\"", "\n", "assert", "mode", "in", "[", "'training'", ",", "'inference'", "]", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "config", "=", "config", "\n", "\n", "self", ".", "model_dir", "=", "model_dir", "\n", "self", ".", "set_log_dir", "(", ")", "\n", "\n", "self", ".", "keras_model", "=", "self", ".", "build", "(", "mode", "=", "mode", ",", "config", "=", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.build": [[3197, 3928], ["keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "model.resnet_graph", "utils.generate_pyramid_anchors", "model.build_rpn_model", "list", "Exception", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.MaxPooling2D", "keras.MaxPooling2D", "keras.MaxPooling2D", "keras.MaxPooling2D", "keras.MaxPooling2D", "len", "layer_outputs.append", "zip", "ParallelModel.ProposalLayer", "model.fpn_classifier_graph", "model.build_fpn_mask_graph", "keras.Model", "keras.Model", "keras.Model", "keras.Model", "keras.Model", "model.fpn_classifier_graph", "model.build_fpn_mask_graph", "keras.Model", "keras.Model", "keras.Model", "keras.Model", "keras.Model", "ParallelModel", "int", "int", "config.IMAGE_SHAPE.tolist", "keras.stack", "keras.stack", "keras.stack", "keras.stack", "keras.stack", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "build_rpn_model.", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "list", "zip", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "keras.Input", "ParallelModel.DetectionTargetLayer", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "inputs.append", "ParallelModel.DetectionLayer", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "keras.shape", "keras.shape", "keras.shape", "keras.shape", "keras.shape", "keras.shape", "keras.shape", "keras.shape", "keras.shape", "keras.shape", "keras.UpSampling2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.UpSampling2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Conv2D", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "model.build_fpn_coords_bins_graph", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "fn", "fn", "fn", "fn", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "model.mrcnn_coord_symmetry_loss_graph", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "model.build_fpn_coords_bins_graph", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "model.build_fpn_coord_graph", "fn", "fn", "fn", "model.parse_image_meta_graph", "tensorflow.tile", "tensorflow.stack", "model.rpn_class_loss_graph", "model.rpn_bbox_loss_graph", "model.mrcnn_class_loss_graph", "model.mrcnn_bbox_loss_graph", "fn", "fn", "fn", "fn", "fn", "fn", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "model.mrcnn_mask_loss_graph", "tensorflow.stack", "fn", "fn", "fn", "fn", "fn", "fn", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Add", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "keras.Concatenate", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "tensorflow.reshape", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "tensorflow.reshape", "tensorflow.reshape", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "tensorflow.reshape", "tensorflow.reshape", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "tensorflow.reshape", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "model.mrcnn_coord_symmetry_loss_graph", "model.mrcnn_coord_reg_loss_graph", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "keras.identity", "mrcnn_coord_symmetry_l1_diff_graph", "model.mrcnn_coord_symmetry_euclidean_distance_graph", "model.mrcnn_coord_l1_loss_graph", "model.mrcnn_coord_l1_loss_graph", "model.mrcnn_coord_l1_loss_graph", "model.mrcnn_coords_l2_loss_graph", "numpy.array", "tensorflow.reshape", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "tensorflow.reshape", "tensorflow.reshape", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "tensorflow.reshape", "tensorflow.reshape", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "keras.argmax", "tensorflow.reshape", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "tensorflow.stack", "model.mrcnn_coord_bins_symmetry_loss_graph", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "model.mrcnn_coord_bins_loss_graph", "model.mrcnn_coord_bins_loss_graph", "model.mrcnn_coord_bins_loss_graph", "model.mrcnn_coord_smooth_l1_loss_graph", "model.mrcnn_coord_smooth_l1_loss_graph", "model.mrcnn_coord_smooth_l1_loss_graph", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "model.mrcnn_coord_symmetry_loss_graph", "tensorflow.identity", "tensorflow.identity", "tensorflow.identity", "tensorflow.identity", "tensorflow.identity", "tensorflow.identity", "tensorflow.stack", "model.mrcnn_coord_symmetry_loss_graph", "mrcnn_coord_loss_graph", "model.mrcnn_coord_reg_loss_graph", "mrcnn_coord_loss_graph", "mrcnn_coord_loss_graph", "mrcnn_coord_loss_graph", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "keras.cast", "tensorflow.shape", "model.mrcnn_coord_delta_index", "model.mrcnn_coord_delta_index", "model.mrcnn_coord_delta_index", "tensorflow.stack", "model.mrcnn_coord_symmetry_loss_graph", "mrcnn_coord_loss_graph", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "model.mrcnn_coord_l1_loss_graph", "model.mrcnn_coord_l1_loss_graph", "model.mrcnn_coord_l1_loss_graph", "model.mrcnn_coord_symmetry_loss_graph", "model.mrcnn_coord_reg_loss_graph", "model.mrcnn_coord_delta_index", "model.mrcnn_coord_delta_index", "model.mrcnn_coord_delta_index", "model.mrcnn_coord_symmetry_loss_graph"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.resnet_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.generate_pyramid_anchors", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_rpn_model", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.fpn_classifier_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_mask_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.fpn_classifier_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_mask_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_coords_bins_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_coords_bins_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_coord_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.parse_image_meta_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.rpn_class_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.rpn_bbox_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_class_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_bbox_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_mask_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_reg_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_euclidean_distance_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_l1_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_l1_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_l1_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coords_l2_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_bins_symmetry_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_bins_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_bins_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_bins_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_smooth_l1_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_smooth_l1_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_smooth_l1_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_reg_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_delta_index", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_delta_index", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_delta_index", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_l1_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_l1_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_l1_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_reg_loss_graph", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_delta_index", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_delta_index", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_delta_index", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_loss_graph"], ["", "def", "build", "(", "self", ",", "mode", ",", "config", ")", ":", "\n", "        ", "\"\"\"Build Mask R-CNN architecture.\n            input_shape: The shape of the input image.\n            mode: Either \"training\" or \"inference\". The inputs and \n                outputs of the model differ accordingly.\n        \"\"\"", "\n", "assert", "mode", "in", "[", "'training'", ",", "'inference'", "]", "\n", "\n", "# Image size must be dividable by 2 multiple times", "\n", "h", ",", "w", "=", "config", ".", "IMAGE_SHAPE", "[", ":", "2", "]", "\n", "if", "h", "/", "2", "**", "6", "!=", "int", "(", "h", "/", "2", "**", "6", ")", "or", "w", "/", "2", "**", "6", "!=", "int", "(", "w", "/", "2", "**", "6", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Image size must be dividable by 2 at least 6 times \"", "\n", "\"to avoid fractions when downscaling and upscaling.\"", "\n", "\"For example, use 256, 320, 384, 448, 512, ... etc. \"", ")", "\n", "\n", "# Inputs", "\n", "", "input_image", "=", "KL", ".", "Input", "(", "shape", "=", "config", ".", "IMAGE_SHAPE", ".", "tolist", "(", ")", ",", "name", "=", "\"input_image\"", ")", "\n", "input_image_meta", "=", "KL", ".", "Input", "(", "shape", "=", "[", "None", "]", ",", "name", "=", "\"input_image_meta\"", ")", "\n", "if", "mode", "==", "\"training\"", ":", "\n", "# RPN GT", "\n", "            ", "input_rpn_match", "=", "KL", ".", "Input", "(", "shape", "=", "[", "None", ",", "1", "]", ",", "name", "=", "\"input_rpn_match\"", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "input_rpn_bbox", "=", "KL", ".", "Input", "(", "shape", "=", "[", "None", ",", "4", "]", ",", "name", "=", "\"input_rpn_bbox\"", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "# GT Boxes (zero padded)", "\n", "# [batch, MAX_GT_INSTANCES, (y1, x1, y2, x2, class_id)] in image coordinates", "\n", "input_gt_boxes", "=", "KL", ".", "Input", "(", "shape", "=", "[", "None", ",", "5", "]", ",", "name", "=", "\"input_gt_boxes\"", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "# Normalize coordinates", "\n", "h", ",", "w", "=", "K", ".", "shape", "(", "input_image", ")", "[", "1", "]", ",", "K", ".", "shape", "(", "input_image", ")", "[", "2", "]", "\n", "image_scale", "=", "K", ".", "cast", "(", "K", ".", "stack", "(", "[", "h", ",", "w", ",", "h", ",", "w", ",", "1", "]", ",", "axis", "=", "0", ")", ",", "tf", ".", "float32", ")", "\n", "gt_boxes", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "cast", "(", "x", ",", "tf", ".", "float32", ")", "/", "image_scale", ")", "(", "input_gt_boxes", ")", "\n", "# GT Masks (zero padded)", "\n", "# [batch, height, width, MAX_GT_INSTANCES]", "\n", "if", "config", ".", "USE_MINI_MASK", ":", "\n", "                ", "input_gt_masks", "=", "KL", ".", "Input", "(", "\n", "shape", "=", "[", "config", ".", "MINI_MASK_SHAPE", "[", "0", "]", ",", "config", ".", "MINI_MASK_SHAPE", "[", "1", "]", ",", "None", "]", ",", "\n", "name", "=", "\"input_gt_masks\"", ",", "dtype", "=", "bool", ")", "\n", "input_gt_coords", "=", "KL", ".", "Input", "(", "\n", "shape", "=", "[", "config", ".", "MINI_MASK_SHAPE", "[", "0", "]", ",", "config", ".", "MINI_MASK_SHAPE", "[", "1", "]", ",", "None", ",", "3", "]", ",", "\n", "name", "=", "\"input_gt_coords\"", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "", "else", ":", "\n", "                ", "input_gt_masks", "=", "KL", ".", "Input", "(", "\n", "shape", "=", "[", "config", ".", "IMAGE_SHAPE", "[", "0", "]", ",", "config", ".", "IMAGE_SHAPE", "[", "1", "]", ",", "None", "]", ",", "\n", "name", "=", "\"input_gt_masks\"", ",", "dtype", "=", "bool", ")", "\n", "input_gt_coords", "=", "KL", ".", "Input", "(", "\n", "shape", "=", "[", "config", ".", "IMAGE_SHAPE", "[", "0", "]", ",", "config", ".", "IMAGE_SHAPE", "[", "1", "]", ",", "None", ",", "3", "]", ",", "\n", "name", "=", "\"input_gt_coords\"", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "", "input_gt_domain_labels", "=", "KL", ".", "Input", "(", "shape", "=", "[", "1", "]", ",", "name", "=", "\"input_domain_label\"", ",", "dtype", "=", "tf", ".", "bool", ")", "\n", "\n", "# Build the shared convolutional layers.", "\n", "# Bottom-up Layers", "\n", "# Returns a list of the last layers of each stage, 5 in total.", "\n", "# Don't create the thead (stage 5), so we pick the 4th item in the list.", "\n", "", "_", ",", "C2", ",", "C3", ",", "C4", ",", "C5", "=", "resnet_graph", "(", "input_image", ",", "config", ".", "RESNET", ",", "stage5", "=", "True", ")", "\n", "# Top-down Layers", "\n", "# TODO: add assert to varify feature map sizes match what's in config", "\n", "P5", "=", "KL", ".", "Conv2D", "(", "256", ",", "(", "1", ",", "1", ")", ",", "name", "=", "'fpn_c5p5'", ")", "(", "C5", ")", "\n", "P4", "=", "KL", ".", "Add", "(", "name", "=", "\"fpn_p4add\"", ")", "(", "[", "\n", "KL", ".", "UpSampling2D", "(", "size", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"fpn_p5upsampled\"", ")", "(", "P5", ")", ",", "\n", "KL", ".", "Conv2D", "(", "256", ",", "(", "1", ",", "1", ")", ",", "name", "=", "'fpn_c4p4'", ")", "(", "C4", ")", "]", ")", "\n", "P3", "=", "KL", ".", "Add", "(", "name", "=", "\"fpn_p3add\"", ")", "(", "[", "\n", "KL", ".", "UpSampling2D", "(", "size", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"fpn_p4upsampled\"", ")", "(", "P4", ")", ",", "\n", "KL", ".", "Conv2D", "(", "256", ",", "(", "1", ",", "1", ")", ",", "name", "=", "'fpn_c3p3'", ")", "(", "C3", ")", "]", ")", "\n", "P2", "=", "KL", ".", "Add", "(", "name", "=", "\"fpn_p2add\"", ")", "(", "[", "\n", "KL", ".", "UpSampling2D", "(", "size", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"fpn_p3upsampled\"", ")", "(", "P3", ")", ",", "\n", "KL", ".", "Conv2D", "(", "256", ",", "(", "1", ",", "1", ")", ",", "name", "=", "'fpn_c2p2'", ")", "(", "C2", ")", "]", ")", "\n", "\n", "# Attach 3x3 conv to all P layers to get the final feature maps.", "\n", "P2", "=", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"SAME\"", ",", "name", "=", "\"fpn_p2\"", ")", "(", "P2", ")", "\n", "P3", "=", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"SAME\"", ",", "name", "=", "\"fpn_p3\"", ")", "(", "P3", ")", "\n", "P4", "=", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"SAME\"", ",", "name", "=", "\"fpn_p4\"", ")", "(", "P4", ")", "\n", "P5", "=", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"SAME\"", ",", "name", "=", "\"fpn_p5\"", ")", "(", "P5", ")", "\n", "# P6 is used for the 5th anchor scale in RPN. Generated by", "\n", "# subsampling from P5 with stride of 2.", "\n", "P6", "=", "KL", ".", "MaxPooling2D", "(", "pool_size", "=", "(", "1", ",", "1", ")", ",", "strides", "=", "2", ",", "name", "=", "\"fpn_p6\"", ")", "(", "P5", ")", "\n", "\n", "# Note that P6 is used in RPN, but not in the classifier heads.", "\n", "rpn_feature_maps", "=", "[", "P2", ",", "P3", ",", "P4", ",", "P5", ",", "P6", "]", "\n", "mrcnn_feature_maps", "=", "[", "P2", ",", "P3", ",", "P4", ",", "P5", "]", "\n", "\n", "# Generate Anchors", "\n", "self", ".", "anchors", "=", "utils", ".", "generate_pyramid_anchors", "(", "config", ".", "RPN_ANCHOR_SCALES", ",", "\n", "config", ".", "RPN_ANCHOR_RATIOS", ",", "\n", "config", ".", "BACKBONE_SHAPES", ",", "\n", "config", ".", "BACKBONE_STRIDES", ",", "\n", "config", ".", "RPN_ANCHOR_STRIDE", ")", "\n", "\n", "# RPN Model", "\n", "rpn", "=", "build_rpn_model", "(", "config", ".", "RPN_ANCHOR_STRIDE", ",", "\n", "len", "(", "config", ".", "RPN_ANCHOR_RATIOS", ")", ",", "256", ")", "\n", "# Loop through pyramid layers", "\n", "layer_outputs", "=", "[", "]", "# list of lists", "\n", "for", "p", "in", "rpn_feature_maps", ":", "\n", "            ", "layer_outputs", ".", "append", "(", "rpn", "(", "[", "p", "]", ")", ")", "\n", "# Concatenate layer outputs", "\n", "# Convert from list of lists of level outputs to list of lists ", "\n", "# of outputs across levels. ", "\n", "# e.g. [[a1, b1, c1], [a2, b2, c2]] => [[a1, a2], [b1, b2], [c1, c2]]", "\n", "", "output_names", "=", "[", "\"rpn_class_logits\"", ",", "\"rpn_class\"", ",", "\"rpn_bbox\"", "]", "\n", "outputs", "=", "list", "(", "zip", "(", "*", "layer_outputs", ")", ")", "\n", "outputs", "=", "[", "KL", ".", "Concatenate", "(", "axis", "=", "1", ",", "name", "=", "n", ")", "(", "list", "(", "o", ")", ")", "\n", "for", "o", ",", "n", "in", "zip", "(", "outputs", ",", "output_names", ")", "]", "\n", "\n", "rpn_class_logits", ",", "rpn_class", ",", "rpn_bbox", "=", "outputs", "\n", "\n", "# Generate proposals", "\n", "# Proposals are [N, (y1, x1, y2, x2)] in normalized coordinates.", "\n", "proposal_count", "=", "config", ".", "POST_NMS_ROIS_TRAINING", "if", "mode", "==", "\"training\"", "else", "config", ".", "POST_NMS_ROIS_INFERENCE", "\n", "rpn_rois", "=", "ProposalLayer", "(", "proposal_count", "=", "proposal_count", ",", "\n", "nms_threshold", "=", "0.7", ",", "\n", "name", "=", "\"ROI\"", ",", "\n", "anchors", "=", "self", ".", "anchors", ",", "\n", "config", "=", "config", ")", "(", "[", "rpn_class", ",", "rpn_bbox", "]", ")", "\n", "\n", "if", "mode", "==", "\"training\"", ":", "\n", "# Class ID mask to mark class IDs supported by the dataset the image", "\n", "# came from.", "\n", "            ", "_", ",", "_", ",", "_", ",", "active_class_ids", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "parse_image_meta_graph", "(", "x", ")", ",", "\n", "mask", "=", "[", "None", ",", "None", ",", "None", ",", "None", "]", ")", "(", "input_image_meta", ")", "\n", "\n", "if", "not", "config", ".", "USE_RPN_ROIS", ":", "\n", "# Ignore predicted ROIs and use ROIs provided as an input.", "\n", "                ", "input_rois", "=", "KL", ".", "Input", "(", "shape", "=", "[", "config", ".", "POST_NMS_ROIS_TRAINING", ",", "4", "]", ",", "\n", "name", "=", "\"input_roi\"", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "# Normalize coordinates to 0-1 range.", "\n", "target_rois", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "cast", "(", "x", ",", "tf", ".", "float32", ")", "/", "image_scale", "[", ":", "4", "]", ")", "(", "input_rois", ")", "\n", "", "else", ":", "\n", "                ", "target_rois", "=", "rpn_rois", "\n", "\n", "# Generate detection targets", "\n", "# Subsamples proposals and generates target outputs for training", "\n", "# Note that proposals, gt_boxes, and gt_masks might be zero padded", "\n", "# Equally, returned rois and targets might be zero padded as well", "\n", "", "rois", ",", "target_class_ids", ",", "target_bbox", ",", "target_mask", ",", "target_coord_x", ",", "target_coord_y", ",", "target_coord_z", "=", "DetectionTargetLayer", "(", "config", ",", "name", "=", "\"proposal_targets\"", ")", "(", "[", "\n", "target_rois", ",", "gt_boxes", ",", "input_gt_masks", ",", "input_gt_coords", "]", ")", "\n", "\n", "\n", "target_domain_labels", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "tile", "(", "x", "[", "0", "]", ",", "[", "1", ",", "tf", ".", "shape", "(", "x", "[", "1", "]", ")", "[", "1", "]", "]", ")", ",", "\n", "name", "=", "'target_domain_labels'", ")", "(", "[", "input_gt_domain_labels", ",", "target_class_ids", "]", ")", "\n", "\n", "target_coords", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "stack", "(", "x", ",", "axis", "=", "4", ")", ",", "name", "=", "\"target_coords\"", ")", "(", "\n", "[", "target_coord_x", ",", "target_coord_y", ",", "target_coord_z", "]", ")", "\n", "\n", "\n", "#(lambda x: tf.Print(x, [tf.shape(x)], message=\"target_coords shape before use\"))(target_coords)", "\n", "\n", "\n", "\n", "# Network Heads", "\n", "# TODO: verify that this handles zero padded ROIs", "\n", "mrcnn_class_logits", ",", "mrcnn_class", ",", "mrcnn_bbox", "=", "fpn_classifier_graph", "(", "rois", ",", "mrcnn_feature_maps", ",", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "POOL_SIZE", ",", "config", ".", "NUM_CLASSES", ")", "\n", "\n", "\n", "# TODO: clean up (use tf.identify if necessary)", "\n", "output_rois", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "*", "1", ",", "name", "=", "\"output_rois\"", ")", "(", "rois", ")", "\n", "\n", "# Losses", "\n", "rpn_class_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "rpn_class_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"rpn_class_loss\"", ")", "(", "\n", "[", "input_rpn_match", ",", "rpn_class_logits", "]", ")", "\n", "rpn_bbox_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "rpn_bbox_loss_graph", "(", "config", ",", "*", "x", ")", ",", "name", "=", "\"rpn_bbox_loss\"", ")", "(", "\n", "[", "input_rpn_bbox", ",", "input_rpn_match", ",", "rpn_bbox", "]", ")", "\n", "class_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_class_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_class_loss\"", ")", "(", "\n", "[", "target_class_ids", ",", "mrcnn_class_logits", ",", "active_class_ids", "]", ")", "\n", "bbox_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_bbox_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_bbox_loss\"", ")", "(", "\n", "[", "target_bbox", ",", "target_class_ids", ",", "mrcnn_bbox", "]", ")", "\n", "\n", "\n", "\n", "#if config.JOINT_PREDICT:", "\n", "mrcnn_mask", ",", "mrcnn_mask_feature", "=", "build_fpn_mask_graph", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "MASK_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'mask'", ")", "\n", "## mrcnn_mask_feature: [batch_size, num_of_rois, height, width, 256]", "\n", "\n", "\n", "\n", "## quantize the coordinate map and do classification", "\n", "if", "config", ".", "COORD_USE_BINS", ":", "\n", "                ", "if", "config", ".", "COORD_SHARE_WEIGHTS", ":", "\n", "                    ", "mrcnn_coord_x_bin", ",", "mrcnn_coord_y_bin", ",", "mrcnn_coord_z_bin", ",", "mrcnn_coord_bin_feature", "=", "build_fpn_coords_bins_graph", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "config", ".", "USE_BN", ")", "\n", "", "else", ":", "\n", "                    ", "if", "config", ".", "COORD_USE_DELTA", ":", "\n", "                        ", "fn", "=", "build_fpn_coord_bins_delta_graph", "\n", "mrcnn_coord_x_bin", ",", "mrcnn_coord_x_delta_bins", "=", "fn", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "'coord_x'", ")", "\n", "mrcnn_coord_y_bin", ",", "mrcnn_coord_y_delta_bins", "=", "fn", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "'coord_y'", ")", "\n", "mrcnn_coord_z_bin", ",", "mrcnn_coord_z_delta_bins", "=", "fn", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "'coord_z'", ")", "\n", "\n", "", "else", ":", "\n", "                        ", "fn", "=", "build_fpn_coord_bins_graph", "\n", "mrcnn_coord_x_bin", ",", "mrcnn_coord_x_feature", "=", "fn", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_x'", ")", "\n", "mrcnn_coord_y_bin", ",", "mrcnn_coord_y_feature", "=", "fn", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_y'", ")", "\n", "mrcnn_coord_z_bin", ",", "mrcnn_coord_z_feature", "=", "fn", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_z'", ")", "\n", "\n", "\n", "## calculate bin classification loss", "\n", "", "", "if", "config", ".", "USE_SYMMETRY_LOSS", ":", "\n", "                    ", "mrcnn_coords_bin", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "stack", "(", "x", ",", "axis", "=", "-", "1", ")", ",", "name", "=", "\"mrcnn_coords_bin\"", ")", "(", "\n", "[", "mrcnn_coord_x_bin", ",", "mrcnn_coord_y_bin", ",", "mrcnn_coord_z_bin", "]", ")", "\n", "coord_bin_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_bins_symmetry_loss_graph", "(", "*", "x", ")", ",", "\n", "name", "=", "\"mrcnn_coord_bin_loss\"", ")", "(", "[", "target_mask", ",", "target_coords", ",", "target_class_ids", ",", "\n", "target_domain_labels", ",", "mrcnn_coords_bin", "]", ")", "\n", "coord_x_bin_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "reshape", "(", "x", "[", "0", "]", ",", "(", "1", ",", "1", ")", ")", ",", "\n", "name", "=", "\"mrcnn_coord_x_bin_loss\"", ")", "(", "coord_bin_loss", ")", "\n", "coord_y_bin_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "reshape", "(", "x", "[", "1", "]", ",", "(", "1", ",", "1", ")", ")", ",", "\n", "name", "=", "\"mrcnn_coord_y_bin_loss\"", ")", "(", "coord_bin_loss", ")", "\n", "coord_z_bin_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "reshape", "(", "x", "[", "2", "]", ",", "(", "1", ",", "1", ")", ")", ",", "\n", "name", "=", "\"mrcnn_coord_z_bin_loss\"", ")", "(", "coord_bin_loss", ")", "\n", "\n", "#target_coords = KL.Lambda(", "\n", "#    lambda x: tf.Print(x, [tf.shape(x)], message=\"target_coords shape after loss\"))(target_coords)", "\n", "\n", "\n", "", "else", ":", "\n", "                    ", "coord_x_bin_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_bins_loss_graph", "(", "*", "x", ")", ",", "\n", "name", "=", "\"mrcnn_coord_x_bin_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_x", ",", "target_class_ids", ",", "mrcnn_coord_x_bin", "]", ")", "\n", "coord_y_bin_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_bins_loss_graph", "(", "*", "x", ")", ",", "\n", "name", "=", "\"mrcnn_coord_y_bin_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_y", ",", "target_class_ids", ",", "mrcnn_coord_y_bin", "]", ")", "\n", "coord_z_bin_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_bins_loss_graph", "(", "*", "x", ")", ",", "\n", "name", "=", "\"mrcnn_coord_z_bin_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_z", ",", "target_class_ids", ",", "mrcnn_coord_z_bin", "]", ")", "\n", "\n", "\n", "\n", "\n", "coord_x_softl1_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_smooth_l1_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_x_l1_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_x", ",", "target_class_ids", ",", "mrcnn_coord_x_bin", "]", ")", "\n", "coord_y_softl1_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_smooth_l1_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_y_l1_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_y", ",", "target_class_ids", ",", "mrcnn_coord_y_bin", "]", ")", "\n", "coord_z_softl1_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_smooth_l1_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_z_l1_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_z", ",", "target_class_ids", ",", "mrcnn_coord_z_bin", "]", ")", "\n", "\n", "coord_x_loss", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_coord_x_loss\"", ")", "(", "[", "coord_x_bin_loss", ",", "coord_x_softl1_loss", "]", ")", "\n", "coord_y_loss", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_coord_y_loss\"", ")", "(", "[", "coord_y_bin_loss", ",", "coord_y_softl1_loss", "]", ")", "\n", "coord_z_loss", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_coord_z_loss\"", ")", "(", "[", "coord_z_bin_loss", ",", "coord_z_softl1_loss", "]", ")", "\n", "\n", "\n", "\n", "## convert bins to float values", "\n", "", "mrcnn_coord_x_shape", "=", "tf", ".", "shape", "(", "mrcnn_coord_x_bin", ")", "\n", "mrcnn_coord_x_bin_reshape", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "-", "1", ",", "mrcnn_coord_x_shape", "[", "-", "1", "]", "]", ")", ")", "(", "\n", "mrcnn_coord_x_bin", ")", "\n", "\n", "mrcnn_coord_x_bin_ind", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "argmax", "(", "t", ",", "axis", "=", "-", "1", ")", ")", "(", "mrcnn_coord_x_bin_reshape", ")", "\n", "mrcnn_coord_x_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "cast", "(", "t", ",", "dtype", "=", "tf", ".", "float32", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ")", "(", "mrcnn_coord_x_bin_ind", ")", "\n", "mrcnn_coord_x_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "mrcnn_coord_x_shape", "[", ":", "-", "1", "]", ")", ")", "(", "mrcnn_coord_x_bin_value", ")", "\n", "\n", "mrcnn_coord_y_shape", "=", "tf", ".", "shape", "(", "mrcnn_coord_y_bin", ")", "\n", "mrcnn_coord_y_bin_reshape", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "-", "1", ",", "mrcnn_coord_y_shape", "[", "-", "1", "]", "]", ")", ")", "(", "\n", "mrcnn_coord_y_bin", ")", "\n", "\n", "mrcnn_coord_y_bin_ind", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "argmax", "(", "t", ",", "axis", "=", "-", "1", ")", ")", "(", "mrcnn_coord_y_bin_reshape", ")", "\n", "mrcnn_coord_y_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "cast", "(", "t", ",", "dtype", "=", "tf", ".", "float32", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ")", "(", "mrcnn_coord_y_bin_ind", ")", "\n", "mrcnn_coord_y_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "mrcnn_coord_y_shape", "[", ":", "-", "1", "]", ")", ")", "(", "\n", "mrcnn_coord_y_bin_value", ")", "\n", "\n", "mrcnn_coord_z_shape", "=", "tf", ".", "shape", "(", "mrcnn_coord_z_bin", ")", "\n", "mrcnn_coord_z_bin_reshape", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "-", "1", ",", "mrcnn_coord_z_shape", "[", "-", "1", "]", "]", ")", ")", "(", "\n", "mrcnn_coord_z_bin", ")", "\n", "\n", "mrcnn_coord_z_bin_ind", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "argmax", "(", "t", ",", "axis", "=", "-", "1", ")", ")", "(", "mrcnn_coord_z_bin_reshape", ")", "\n", "mrcnn_coord_z_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "cast", "(", "t", ",", "dtype", "=", "tf", ".", "float32", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ")", "(", "mrcnn_coord_z_bin_ind", ")", "\n", "mrcnn_coord_z_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "mrcnn_coord_z_shape", "[", ":", "-", "1", "]", ")", ")", "(", "\n", "mrcnn_coord_z_bin_value", ")", "\n", "\n", "\n", "\n", "## merge deltas and bin together for losses and coordinate values", "\n", "if", "config", ".", "COORD_USE_DELTA", ":", "\n", "                    ", "mrcnn_coord_x_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_delta_index", "(", "*", "x", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ",", "\n", "name", "=", "\"mrcnn_coord_delta_x\"", ")", "(", "\n", "[", "mrcnn_coord_x_delta_bins", ",", "mrcnn_coord_x_bin_ind", "]", ")", "\n", "mrcnn_coord_y_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_delta_index", "(", "*", "x", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ",", "\n", "name", "=", "\"mrcnn_coord_delta_y\"", ")", "(", "\n", "[", "mrcnn_coord_y_delta_bins", ",", "mrcnn_coord_y_bin_ind", "]", ")", "\n", "mrcnn_coord_z_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_delta_index", "(", "*", "x", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ",", "\n", "name", "=", "\"mrcnn_coord_delta_z\"", ")", "(", "\n", "[", "mrcnn_coord_z_delta_bins", ",", "mrcnn_coord_z_bin_ind", "]", ")", "\n", "\n", "mrcnn_coord_x", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_coord_x_final\"", ")", "(", "[", "mrcnn_coord_x_bin_value", ",", "mrcnn_coord_x_delta", "]", ")", "\n", "mrcnn_coord_y", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_coord_y_final\"", ")", "(", "[", "mrcnn_coord_y_bin_value", ",", "mrcnn_coord_y_delta", "]", ")", "\n", "mrcnn_coord_z", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_coord_z_final\"", ")", "(", "[", "mrcnn_coord_z_bin_value", ",", "mrcnn_coord_z_delta", "]", ")", "\n", "\n", "if", "config", ".", "USE_SYMMETRY_LOSS", ":", "\n", "                        ", "mrcnn_coords_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "stack", "(", "x", ",", "axis", "=", "5", ")", ",", "name", "=", "\"mrcnn_coords_delta\"", ")", "(", "\n", "[", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", "]", ")", "\n", "if", "config", ".", "COORD_REGRESS_LOSS", "==", "'Soft_L1'", ":", "\n", "                            ", "mrcnn_coord_loss_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ",", "w", ":", "mrcnn_coord_symmetry_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "w", ",", "smooth_l1_diff", ")", "\n", "", "elif", "config", ".", "COORD_REGRESS_LOSS", "==", "'L1'", ":", "\n", "                            ", "mrcnn_coord_loss_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ",", "w", ":", "mrcnn_coord_symmetry_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "w", ",", "tf", ".", "identity", ")", "\n", "", "elif", "config", ".", "COORD_REGRESS_LOSS", "==", "'L2'", ":", "\n", "                            ", "mrcnn_coord_loss_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ",", "w", ":", "mrcnn_coord_symmetry_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "w", ",", "tf", ".", "square", ")", "\n", "", "else", ":", "\n", "                            ", "assert", "False", ",", "'wrong regression loss name!'", "\n", "\n", "", "coord_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coords_delta_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coords", ",", "target_class_ids", ",", "target_domain_labels", ",", "mrcnn_coords_delta", "]", ")", "\n", "\n", "#coord_loss = K.switch(tf.size(coord_loss) > 0, K.mean(coord_loss), tf.constant([0.0, 0.0, 0.0]))", "\n", "\n", "coord_x_delta_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "reshape", "(", "x", "[", "0", "]", ",", "(", "1", ",", "1", ")", ")", ",", "name", "=", "\"mrcnn_coord_x_delta_loss\"", ")", "(", "coord_loss", ")", "\n", "coord_y_delta_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "reshape", "(", "x", "[", "1", "]", ",", "(", "1", ",", "1", ")", ")", ",", "name", "=", "\"mrcnn_coord_y_delta_loss\"", ")", "(", "coord_loss", ")", "\n", "coord_z_delta_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "reshape", "(", "x", "[", "2", "]", ",", "(", "1", ",", "1", ")", ")", ",", "name", "=", "\"mrcnn_coord_z_delta_loss\"", ")", "(", "coord_loss", ")", "\n", "", "else", ":", "\n", "                        ", "coord_x_delta_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_l1_loss_graph", "(", "*", "x", ")", ",", "\n", "name", "=", "\"mrcnn_coord_x_delta_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_x", ",", "target_class_ids", ",", "mrcnn_coord_x", "]", ")", "\n", "coord_y_delta_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_l1_loss_graph", "(", "*", "x", ")", ",", "\n", "name", "=", "\"mrcnn_coord_y_delta_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_y", ",", "target_class_ids", ",", "mrcnn_coord_y", "]", ")", "\n", "coord_z_delta_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_l1_loss_graph", "(", "*", "x", ")", ",", "\n", "name", "=", "\"mrcnn_coord_z_delta_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_z", ",", "target_class_ids", ",", "mrcnn_coord_z", "]", ")", "\n", "\n", "", "coord_x_loss", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_coord_x_loss\"", ")", "(", "[", "coord_x_bin_loss", ",", "coord_x_delta_loss", "]", ")", "\n", "coord_y_loss", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_coord_y_loss\"", ")", "(", "[", "coord_y_bin_loss", ",", "coord_y_delta_loss", "]", ")", "\n", "coord_z_loss", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_coord_z_loss\"", ")", "(", "[", "coord_z_bin_loss", ",", "coord_z_delta_loss", "]", ")", "\n", "\n", "\n", "", "else", ":", "\n", "                    ", "mrcnn_coord_x", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "identity", "(", "x", ")", ",", "name", "=", "\"mrcnn_coord_x_final\"", ")", "(", "mrcnn_coord_x_bin_value", ")", "\n", "mrcnn_coord_y", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "identity", "(", "x", ")", ",", "name", "=", "\"mrcnn_coord_y_final\"", ")", "(", "mrcnn_coord_y_bin_value", ")", "\n", "mrcnn_coord_z", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "identity", "(", "x", ")", ",", "name", "=", "\"mrcnn_coord_z_final\"", ")", "(", "mrcnn_coord_z_bin_value", ")", "\n", "\n", "coord_x_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "identity", "(", "x", ")", ",", "name", "=", "\"mrcnn_coord_x_loss\"", ")", "(", "coord_x_bin_loss", ")", "\n", "coord_y_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "identity", "(", "x", ")", ",", "name", "=", "\"mrcnn_coord_y_loss\"", ")", "(", "coord_y_bin_loss", ")", "\n", "coord_z_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "identity", "(", "x", ")", ",", "name", "=", "\"mrcnn_coord_z_loss\"", ")", "(", "coord_z_bin_loss", ")", "\n", "\n", "\n", "\n", "# direct regress", "\n", "", "", "else", ":", "\n", "## regress the coordinate map with shared weights", "\n", "                ", "if", "config", ".", "COORD_SHARE_WEIGHTS", ":", "\n", "                    ", "fn", "=", "build_fpn_coord_graph", "\n", "\n", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", ",", "mrcnn_coord_feature", "=", "fn", "(", "rois", ",", "\n", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ")", "\n", "## mrcnn_coord_feature: [batch_size, num_of_rois, height, width, 512]", "\n", "## regress the coordinate map without sharing weights", "\n", "", "else", ":", "\n", "                    ", "fn", "=", "build_fpn_mask_graph", "\n", "\n", "\n", "mrcnn_coord_x", ",", "mrcnn_coord_x_feature", "=", "fn", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_x'", ")", "\n", "mrcnn_coord_y", ",", "mrcnn_coord_y_feature", "=", "fn", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_y'", ")", "\n", "mrcnn_coord_z", ",", "mrcnn_coord_z_feature", "=", "fn", "(", "rois", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_z'", ")", "\n", "\n", "mrcnn_coord_feature", "=", "KL", ".", "Concatenate", "(", "name", "=", "\"mrcnn_coord_feature\"", ")", "(", "\n", "[", "mrcnn_coord_x_feature", ",", "mrcnn_coord_y_feature", ",", "mrcnn_coord_z_feature", "]", ")", "\n", "## mrcnn_coord_feature: [batch_size, num_of_rois, height, width, 256*3]", "\n", "\n", "\n", "", "if", "config", ".", "USE_SYMMETRY_LOSS", ":", "\n", "                    ", "mrcnn_coords", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "stack", "(", "x", ",", "axis", "=", "5", ")", ",", "name", "=", "\"mrcnn_coords_reg\"", ")", "(", "\n", "[", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", "]", ")", "\n", "if", "config", ".", "COORD_REGRESS_LOSS", "==", "'Soft_L1'", ":", "\n", "                        ", "mrcnn_coord_loss_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ",", "w", ":", "mrcnn_coord_symmetry_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "w", ",", "smooth_l1_diff", ")", "\n", "", "elif", "config", ".", "COORD_REGRESS_LOSS", "==", "'L1'", ":", "\n", "                        ", "mrcnn_coord_loss_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ",", "w", ":", "mrcnn_coord_symmetry_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "w", ",", "tf", ".", "identity", ")", "\n", "", "elif", "config", ".", "COORD_REGRESS_LOSS", "==", "'L2'", ":", "\n", "                        ", "mrcnn_coord_loss_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ",", "w", ":", "mrcnn_coord_symmetry_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "w", ",", "tf", ".", "square", ")", "\n", "", "else", ":", "\n", "                        ", "assert", "False", ",", "'wrong regression loss name!'", "\n", "\n", "", "coord_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coords_intm_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coords", ",", "target_class_ids", ",", "target_domain_labels", ",", "mrcnn_coords", "]", ")", "\n", "\n", "coord_x_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "0", "]", ",", "name", "=", "\"mrcnn_coord_x_intm_loss\"", ")", "(", "coord_loss", ")", "\n", "coord_y_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "1", "]", ",", "name", "=", "\"mrcnn_coord_y_intm_loss\"", ")", "(", "coord_loss", ")", "\n", "coord_z_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "2", "]", ",", "name", "=", "\"mrcnn_coord_z_intm_loss\"", ")", "(", "coord_loss", ")", "\n", "\n", "\n", "", "else", ":", "\n", "                    ", "if", "config", ".", "COORD_REGRESS_LOSS", "==", "'Soft_L1'", ":", "\n", "                        ", "mrcnn_coord_loss_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ":", "mrcnn_coord_reg_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "smooth_l1_diff", ")", "\n", "", "elif", "config", ".", "COORD_REGRESS_LOSS", "==", "'L1'", ":", "\n", "                        ", "mrcnn_coord_loss_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ":", "mrcnn_coord_reg_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "tf", ".", "identity", ")", "\n", "", "elif", "config", ".", "COORD_REGRESS_LOSS", "==", "'L2'", ":", "\n", "                        ", "mrcnn_coord_loss_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ":", "mrcnn_coord_reg_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "tf", ".", "square", ")", "\n", "", "else", ":", "\n", "                        ", "assert", "False", ",", "'wrong regression loss name!'", "\n", "\n", "", "coord_x_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_x_intm_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_x", ",", "target_class_ids", ",", "mrcnn_coord_x", "]", ")", "\n", "\n", "\n", "coord_y_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_y_intm_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_y", ",", "target_class_ids", ",", "mrcnn_coord_y", "]", ")", "\n", "coord_z_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_z_intm_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_z", ",", "target_class_ids", ",", "mrcnn_coord_z", "]", ")", "\n", "\n", "\n", "", "coord_x_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "identity", "(", "x", ")", ",", "name", "=", "\"mrcnn_coord_x_loss\"", ")", "(", "coord_x_loss", ")", "\n", "coord_y_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "identity", "(", "x", ")", ",", "name", "=", "\"mrcnn_coord_y_loss\"", ")", "(", "coord_y_loss", ")", "\n", "coord_z_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "identity", "(", "x", ")", ",", "name", "=", "\"mrcnn_coord_z_loss\"", ")", "(", "coord_z_loss", ")", "\n", "\n", "\n", "\n", "\n", "\n", "## Final loss ", "\n", "", "mask_loss", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_mask_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_mask_loss\"", ")", "(", "\n", "[", "target_mask", ",", "target_class_ids", ",", "mrcnn_mask", "]", ")", "\n", "\n", "mrcnn_coords", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "tf", ".", "stack", "(", "x", ",", "axis", "=", "-", "1", ")", ",", "name", "=", "\"mrcnn_coords\"", ")", "(", "\n", "[", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", "]", ")", "\n", "\n", "# L1_diff metric", "\n", "if", "config", ".", "USE_SYMMETRY_LOSS", ":", "\n", "                ", "mrcnn_coord_symmetry_l1_diff_graph", "=", "lambda", "x", ",", "y", ",", "u", ",", "v", ",", "w", ":", "mrcnn_coord_symmetry_loss_graph", "(", "x", ",", "y", ",", "u", ",", "v", ",", "w", ",", "tf", ".", "identity", ")", "\n", "coord_diff", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_symmetry_l1_diff_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coords_diff\"", ")", "(", "\n", "[", "target_mask", ",", "target_coords", ",", "target_class_ids", ",", "target_domain_labels", ",", "mrcnn_coords", "]", ")", "\n", "coord_x_diff", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "0", "]", ",", "name", "=", "\"mrcnn_coord_x_diff\"", ")", "(", "coord_diff", ")", "\n", "coord_y_diff", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "1", "]", ",", "name", "=", "\"mrcnn_coord_y_diff\"", ")", "(", "coord_diff", ")", "\n", "coord_z_diff", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "2", "]", ",", "name", "=", "\"mrcnn_coord_z_diff\"", ")", "(", "coord_diff", ")", "\n", "coord_l2_diff", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_symmetry_euclidean_distance_graph", "(", "*", "x", ")", ",", "\n", "name", "=", "\"mrcnn_coord_l2_diff\"", ")", "(", "[", "target_mask", ",", "target_coords", ",", "target_class_ids", ",", "\n", "target_domain_labels", ",", "mrcnn_coords", "]", ")", "\n", "\n", "", "else", ":", "\n", "                ", "coord_x_diff", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_l1_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_x_diff\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_x", ",", "target_class_ids", ",", "mrcnn_coord_x", "]", ")", "\n", "coord_y_diff", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_l1_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_y_diff\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_y", ",", "target_class_ids", ",", "mrcnn_coord_y", "]", ")", "\n", "coord_z_diff", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_l1_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_z_diff\"", ")", "(", "\n", "[", "target_mask", ",", "target_coord_z", ",", "target_class_ids", ",", "mrcnn_coord_z", "]", ")", "\n", "\n", "coord_l2_diff", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coords_l2_loss_graph", "(", "*", "x", ")", ",", "name", "=", "\"mrcnn_coord_l2_diff\"", ")", "(", "\n", "[", "target_mask", ",", "target_coords", ",", "target_class_ids", ",", "mrcnn_coords", "]", ")", "\n", "\n", "\n", "\n", "\n", "# Model", "\n", "", "inputs", "=", "[", "input_image", ",", "input_image_meta", ",", "\n", "input_rpn_match", ",", "input_rpn_bbox", ",", "input_gt_boxes", ",", "input_gt_masks", ",", "input_gt_coords", ",", "\n", "input_gt_domain_labels", "]", "\n", "if", "not", "config", ".", "USE_RPN_ROIS", ":", "\n", "                ", "inputs", ".", "append", "(", "input_rois", ")", "\n", "", "outputs", "=", "[", "rpn_class_logits", ",", "rpn_class", ",", "rpn_bbox", ",", "\n", "mrcnn_class_logits", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "\n", "mrcnn_mask", ",", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", ",", "\n", "rpn_rois", ",", "output_rois", ",", "\n", "rpn_class_loss", ",", "rpn_bbox_loss", ",", "class_loss", ",", "bbox_loss", ",", "\n", "mask_loss", ",", "coord_x_loss", ",", "coord_y_loss", ",", "coord_z_loss", ",", "\n", "coord_x_diff", ",", "coord_y_diff", ",", "coord_z_diff", ",", "coord_l2_diff", "]", "\n", "\n", "model", "=", "KM", ".", "Model", "(", "inputs", ",", "outputs", ",", "name", "=", "'mask_rcnn'", ")", "\n", "\n", "\n", "\n", "\n", "\n", "", "else", ":", "\n", "# Network Heads", "\n", "# Proposal classifier and BBox regressor heads", "\n", "            ", "mrcnn_class_logits", ",", "mrcnn_class", ",", "mrcnn_bbox", "=", "fpn_classifier_graph", "(", "rpn_rois", ",", "mrcnn_feature_maps", ",", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "POOL_SIZE", ",", "config", ".", "NUM_CLASSES", ")", "\n", "\n", "# Detections", "\n", "# output is [batch, num_detections, (y1, x1, y2, x2, class_id, score)] in image coordinates", "\n", "detections", "=", "DetectionLayer", "(", "config", ",", "name", "=", "\"mrcnn_detection\"", ")", "(", "\n", "[", "rpn_rois", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "input_image_meta", "]", ")", "\n", "\n", "# Convert boxes to normalized coordinates", "\n", "# TODO: let DetectionLayer return normalized coordinates to avoid unnecessary conversions", "\n", "h", ",", "w", "=", "config", ".", "IMAGE_SHAPE", "[", ":", "2", "]", "\n", "detection_boxes", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", "...", ",", ":", "4", "]", "/", "np", ".", "array", "(", "[", "h", ",", "w", ",", "h", ",", "w", "]", ")", ")", "(", "detections", ")", "\n", "\n", "# Create masks for detections", "\n", "mrcnn_mask", ",", "mrcnn_mask_feature", "=", "build_fpn_mask_graph", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "MASK_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'mask'", ")", "\n", "\n", "\n", "if", "config", ".", "COORD_USE_BINS", ":", "\n", "                ", "if", "config", ".", "COORD_SHARE_WEIGHTS", ":", "\n", "                    ", "mrcnn_coord_x_bin", ",", "mrcnn_coord_y_bin", ",", "mrcnn_coord_z_bin", "=", "build_fpn_coords_bins_graph", "(", "detection_boxes", ",", "\n", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "config", ".", "USE_BN", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "if", "config", ".", "COORD_USE_DELTA", ":", "\n", "                        ", "fn", "=", "build_fpn_coord_bins_delta_graph", "\n", "\n", "\n", "mrcnn_coord_x_bin", ",", "mrcnn_coord_x_delta_bins", "=", "fn", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "'coord_x'", ")", "\n", "mrcnn_coord_y_bin", ",", "mrcnn_coord_y_delta_bins", "=", "fn", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "'coord_y'", ")", "\n", "mrcnn_coord_z_bin", ",", "mrcnn_coord_z_delta_bins", "=", "fn", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "'coord_z'", ")", "\n", "\n", "", "else", ":", "\n", "                        ", "fn", "=", "build_fpn_coord_bins_graph", "\n", "mrcnn_coord_x_bin", ",", "mrcnn_coord_x_feature", "=", "fn", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_x'", ")", "\n", "mrcnn_coord_y_bin", ",", "mrcnn_coord_y_feature", "=", "fn", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_y'", ")", "\n", "mrcnn_coord_z_bin", ",", "mrcnn_coord_z_feature", "=", "fn", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "COORD_NUM_BINS", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_z'", ")", "\n", "\n", "\n", "# convert results from bin index to float value", "\n", "# tf reshape can only handle 6 channels", "\n", "", "", "mrcnn_coord_x_shape", "=", "tf", ".", "shape", "(", "mrcnn_coord_x_bin", ")", "\n", "mrcnn_coord_x_bin_reshape", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "-", "1", ",", "mrcnn_coord_x_shape", "[", "-", "1", "]", "]", ")", ")", "(", "\n", "mrcnn_coord_x_bin", ")", "\n", "\n", "mrcnn_coord_x_bin_ind", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "argmax", "(", "t", ",", "axis", "=", "-", "1", ")", ")", "(", "mrcnn_coord_x_bin_reshape", ")", "\n", "mrcnn_coord_x_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "cast", "(", "t", ",", "dtype", "=", "tf", ".", "float32", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ")", "(", "mrcnn_coord_x_bin_ind", ")", "\n", "mrcnn_coord_x_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "mrcnn_coord_x_shape", "[", ":", "-", "1", "]", ")", ",", "\n", "name", "=", "'mrcnn_coord_x_bin_value'", ")", "(", "mrcnn_coord_x_bin_value", ")", "\n", "\n", "\n", "mrcnn_coord_y_shape", "=", "tf", ".", "shape", "(", "mrcnn_coord_y_bin", ")", "\n", "mrcnn_coord_y_bin_reshape", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "-", "1", ",", "mrcnn_coord_y_shape", "[", "-", "1", "]", "]", ")", ")", "(", "\n", "mrcnn_coord_y_bin", ")", "\n", "\n", "mrcnn_coord_y_bin_ind", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "argmax", "(", "t", ",", "axis", "=", "-", "1", ")", ")", "(", "mrcnn_coord_y_bin_reshape", ")", "\n", "mrcnn_coord_y_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "cast", "(", "t", ",", "dtype", "=", "tf", ".", "float32", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ")", "(", "mrcnn_coord_y_bin_ind", ")", "\n", "mrcnn_coord_y_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "mrcnn_coord_y_shape", "[", ":", "-", "1", "]", ")", ",", "\n", "name", "=", "'mrcnn_coord_y_bin_value'", ")", "(", "mrcnn_coord_y_bin_value", ")", "\n", "\n", "mrcnn_coord_z_shape", "=", "tf", ".", "shape", "(", "mrcnn_coord_z_bin", ")", "\n", "mrcnn_coord_z_bin_reshape", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "-", "1", ",", "mrcnn_coord_z_shape", "[", "-", "1", "]", "]", ")", ")", "(", "\n", "mrcnn_coord_z_bin", ")", "\n", "\n", "mrcnn_coord_z_bin_ind", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "argmax", "(", "t", ",", "axis", "=", "-", "1", ")", ")", "(", "mrcnn_coord_z_bin_reshape", ")", "\n", "mrcnn_coord_z_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "K", ".", "cast", "(", "t", ",", "dtype", "=", "tf", ".", "float32", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ")", "(", "mrcnn_coord_z_bin_ind", ")", "\n", "mrcnn_coord_z_bin_value", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "mrcnn_coord_z_shape", "[", ":", "-", "1", "]", ")", ",", "\n", "name", "=", "'mrcnn_coord_z_bin_value'", ")", "(", "mrcnn_coord_z_bin_value", ")", "\n", "\n", "\n", "if", "config", ".", "COORD_USE_DELTA", ":", "\n", "\n", "                    ", "mrcnn_coord_x_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_delta_index", "(", "*", "x", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ",", "\n", "name", "=", "\"mrcnn_coord_delta_x\"", ")", "(", "\n", "[", "mrcnn_coord_x_delta_bins", ",", "mrcnn_coord_x_bin_ind", "]", ")", "\n", "mrcnn_coord_y_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_delta_index", "(", "*", "x", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ",", "\n", "name", "=", "\"mrcnn_coord_delta_y\"", ")", "(", "\n", "[", "mrcnn_coord_y_delta_bins", ",", "mrcnn_coord_y_bin_ind", "]", ")", "\n", "mrcnn_coord_z_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "mrcnn_coord_delta_index", "(", "*", "x", ")", "/", "(", "config", ".", "COORD_NUM_BINS", ")", ",", "\n", "name", "=", "\"mrcnn_coord_delta_z\"", ")", "(", "\n", "[", "mrcnn_coord_z_delta_bins", ",", "mrcnn_coord_z_bin_ind", "]", ")", "\n", "\n", "mrcnn_coord_x", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_mask_coord_x\"", ")", "(", "[", "mrcnn_coord_x_bin_value", ",", "mrcnn_coord_x_delta", "]", ")", "\n", "mrcnn_coord_y", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_mask_coord_y\"", ")", "(", "[", "mrcnn_coord_y_bin_value", ",", "mrcnn_coord_y_delta", "]", ")", "\n", "mrcnn_coord_z", "=", "KL", ".", "Add", "(", "name", "=", "\"mrcnn_mask_coord_z\"", ")", "(", "[", "mrcnn_coord_z_bin_value", ",", "mrcnn_coord_z_delta", "]", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "mrcnn_coord_x", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "*", "1", ",", "name", "=", "\"mrcnn_mask_coord_x\"", ")", "(", "mrcnn_coord_x_bin_value", ")", "\n", "mrcnn_coord_y", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "*", "1", ",", "name", "=", "\"mrcnn_mask_coord_y\"", ")", "(", "mrcnn_coord_y_bin_value", ")", "\n", "mrcnn_coord_z", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "*", "1", ",", "name", "=", "\"mrcnn_mask_coord_z\"", ")", "(", "mrcnn_coord_z_bin_value", ")", "\n", "\n", "\n", "", "", "else", ":", "\n", "## regress the coordinate map with shared weights", "\n", "                ", "if", "config", ".", "COORD_SHARE_WEIGHTS", ":", "\n", "                    ", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", ",", "mrcnn_coord_feature", "=", "build_fpn_coord_graph", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ")", "\n", "## regress the coordinate map without sharing weights", "\n", "", "else", ":", "\n", "                    ", "fn", "=", "build_fpn_mask_graph", "\n", "\n", "\n", "mrcnn_coord_x", ",", "mrcnn_coord_x_feature", "=", "fn", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_x'", ")", "\n", "mrcnn_coord_y", ",", "mrcnn_coord_y_feature", "=", "fn", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_y'", ")", "\n", "mrcnn_coord_z", ",", "mrcnn_coord_z_feature", "=", "fn", "(", "detection_boxes", ",", "mrcnn_feature_maps", ",", "\n", "config", ".", "IMAGE_SHAPE", ",", "\n", "config", ".", "COORD_POOL_SIZE", ",", "\n", "config", ".", "NUM_CLASSES", ",", "\n", "config", ".", "USE_BN", ",", "\n", "'coord_z'", ")", "\n", "\n", "mrcnn_coord_feature", "=", "KL", ".", "Concatenate", "(", "name", "=", "\"mrcnn_coord_feature\"", ")", "(", "\n", "[", "mrcnn_coord_x_feature", ",", "mrcnn_coord_y_feature", ",", "mrcnn_coord_z_feature", "]", ")", "\n", "## mrcnn_coord_feature: [batch_size, num_of_rois, height, width, 256*3]", "\n", "\n", "\n", "", "", "model", "=", "KM", ".", "Model", "(", "[", "input_image", ",", "input_image_meta", "]", ",", "\n", "[", "detections", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "\n", "mrcnn_mask", ",", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", ",", "\n", "rpn_rois", ",", "rpn_class", ",", "rpn_bbox", "]", ",", "\n", "name", "=", "'mask_rcnn'", ")", "\n", "\n", "# Add multi-GPU support.", "\n", "", "if", "config", ".", "GPU_COUNT", ">", "1", ":", "\n", "            ", "from", "parallel_model", "import", "ParallelModel", "\n", "model", "=", "ParallelModel", "(", "model", ",", "config", ".", "GPU_COUNT", ")", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.find_last": [[3929, 3953], ["model.MaskRCNN.config.NAME.lower", "filter", "sorted", "os.path.join", "filter", "sorted", "os.path.join", "next", "next", "os.walk", "f.startswith", "os.walk", "f.startswith"], "methods", ["None"], ["", "def", "find_last", "(", "self", ")", ":", "\n", "        ", "\"\"\"Finds the last checkpoint file of the last trained model in the\n        model directory.\n        Returns:\n            log_dir: The directory where events and weights are saved\n            checkpoint_path: the path to the last checkpoint file\n        \"\"\"", "\n", "# Get directory names. Each directory corresponds to a model", "\n", "dir_names", "=", "next", "(", "os", ".", "walk", "(", "self", ".", "model_dir", ")", ")", "[", "1", "]", "\n", "key", "=", "self", ".", "config", ".", "NAME", ".", "lower", "(", ")", "\n", "dir_names", "=", "filter", "(", "lambda", "f", ":", "f", ".", "startswith", "(", "key", ")", ",", "dir_names", ")", "\n", "dir_names", "=", "sorted", "(", "dir_names", ")", "\n", "if", "not", "dir_names", ":", "\n", "            ", "return", "None", ",", "None", "\n", "# Pick last directory", "\n", "", "dir_name", "=", "os", ".", "path", ".", "join", "(", "self", ".", "model_dir", ",", "dir_names", "[", "-", "1", "]", ")", "\n", "# Find the last checkpoint", "\n", "checkpoints", "=", "next", "(", "os", ".", "walk", "(", "dir_name", ")", ")", "[", "2", "]", "\n", "checkpoints", "=", "filter", "(", "lambda", "f", ":", "f", ".", "startswith", "(", "\"mask_rcnn\"", ")", ",", "checkpoints", ")", "\n", "checkpoints", "=", "sorted", "(", "checkpoints", ")", "\n", "if", "not", "checkpoints", ":", "\n", "            ", "return", "dir_name", ",", "None", "\n", "", "checkpoint", "=", "os", ".", "path", ".", "join", "(", "dir_name", ",", "checkpoints", "[", "-", "1", "]", ")", "\n", "return", "dir_name", ",", "checkpoint", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.load_weights": [[3954, 4017], ["h5py.File", "hasattr", "model.MaskRCNN.set_log_dir", "ImportError", "hasattr", "filter", "saving.load_weights_from_hdf5_group_by_name", "saving.load_weights_from_hdf5_group", "h5py.File.close"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.set_log_dir"], ["", "def", "load_weights", "(", "self", ",", "filepath", ",", "by_name", "=", "False", ",", "exclude", "=", "None", ")", ":", "\n", "        ", "\"\"\"Modified version of the correspoding Keras function with\n        the addition of multi-GPU support and the ability to exclude\n        some layers from loading.\n        exlude: list of layer names to excluce\n        \"\"\"", "\n", "import", "h5py", "\n", "from", "keras", ".", "engine", "import", "saving", "\n", "\n", "if", "exclude", ":", "\n", "            ", "by_name", "=", "True", "\n", "\n", "", "if", "h5py", "is", "None", ":", "\n", "            ", "raise", "ImportError", "(", "'`load_weights` requires h5py.'", ")", "\n", "", "f", "=", "h5py", ".", "File", "(", "filepath", ",", "mode", "=", "'r'", ")", "\n", "if", "'layer_names'", "not", "in", "f", ".", "attrs", "and", "'model_weights'", "in", "f", ":", "\n", "            ", "f", "=", "f", "[", "'model_weights'", "]", "\n", "\n", "# In multi-GPU training, we wrap the model. Get layers", "\n", "# of the inner model because they have the weights.", "\n", "", "keras_model", "=", "self", ".", "keras_model", "\n", "layers", "=", "keras_model", ".", "inner_model", ".", "layers", "if", "hasattr", "(", "keras_model", ",", "\"inner_model\"", ")", "else", "keras_model", ".", "layers", "\n", "'''\n        for layer in layers:\n            # Is the layer a model?\n            if layer.__class__.__name__ == 'Model':\n                print(\"In model: \", layer.name)\n                self.set_trainable(layer_regex, keras_model=layer, indent=indent + 4)\n                continue\n\n            if not layer.weights:\n                continue\n            # Is it trainable?\n            trainable = bool(re.fullmatch(layer_regex, layer.name))\n            # Update layer. If layer is a container, update inner layer.\n            if layer.__class__.__name__ == 'TimeDistributed':\n                layer.layer.trainable = trainable\n            else:\n                layer.trainable = trainable\n            # Print trainble layer names\n            if trainable and verbose > 0:\n                log(\"{}{:20}   ({})\".format(\" \" * indent, layer.name,\n                                            layer.__class__.__name__))\n        weights_list = keras_model.get_weights()\n        print(weights_list)\n        exit()\n        \n        '''", "\n", "\n", "# Exclude some layers", "\n", "if", "exclude", ":", "\n", "            ", "layers", "=", "filter", "(", "lambda", "l", ":", "l", ".", "name", "not", "in", "exclude", ",", "layers", ")", "\n", "\n", "", "if", "by_name", ":", "\n", "            ", "saving", ".", "load_weights_from_hdf5_group_by_name", "(", "f", ",", "layers", ")", "\n", "", "else", ":", "\n", "            ", "saving", ".", "load_weights_from_hdf5_group", "(", "f", ",", "layers", ")", "\n", "", "if", "hasattr", "(", "f", ",", "'close'", ")", ":", "\n", "            ", "f", ".", "close", "(", ")", "\n", "\n", "# Update the log directory", "\n", "", "self", ".", "set_log_dir", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.get_imagenet_weights": [[4018, 4031], ["get_file"], "methods", ["None"], ["", "def", "get_imagenet_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Downloads ImageNet trained weights from Keras.\n        Returns path to weights file.\n        \"\"\"", "\n", "from", "keras", ".", "utils", ".", "data_utils", "import", "get_file", "\n", "TF_WEIGHTS_PATH_NO_TOP", "=", "'https://github.com/fchollet/deep-learning-models/'", "'releases/download/v0.2/'", "'resnet50_weights_tf_dim_ordering_tf_kernels_notop.h5'", "\n", "weights_path", "=", "get_file", "(", "'resnet50_weights_tf_dim_ordering_tf_kernels_notop.h5'", ",", "\n", "TF_WEIGHTS_PATH_NO_TOP", ",", "\n", "cache_subdir", "=", "'models'", ",", "\n", "md5_hash", "=", "'a268eb855778b3df3c7506639542a6af'", ")", "\n", "return", "weights_path", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.compile": [[4032, 4081], ["keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "keras.optimizers.SGD", "tensorflow.add_n", "model.MaskRCNN.keras_model.add_loss", "model.MaskRCNN.keras_model.compile", "model.MaskRCNN.keras_model.metrics_names.append", "model.MaskRCNN.keras_model.metrics_tensors.append", "model.MaskRCNN.keras_model.get_layer", "model.MaskRCNN.keras_model.get_layer", "model.MaskRCNN.keras_model.metrics_names.append", "model.MaskRCNN.keras_model.metrics_tensors.append", "tensorflow.reduce_mean", "model.MaskRCNN.keras_model.add_loss", "model.MaskRCNN.keras_model.add_loss", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "len", "tensorflow.reduce_mean"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.compile"], ["", "def", "compile", "(", "self", ",", "learning_rate", ",", "momentum", ")", ":", "\n", "        ", "\"\"\"Gets the model ready for training. Adds losses, regularization, and\n        metrics. Then calls the Keras compile() function.\n        \"\"\"", "\n", "# Optimizer object", "\n", "optimizer", "=", "keras", ".", "optimizers", ".", "SGD", "(", "lr", "=", "learning_rate", ",", "momentum", "=", "momentum", ",", "\n", "clipnorm", "=", "5.0", ")", "\n", "# Add Losses", "\n", "# First, clear previously set losses to avoid duplication", "\n", "self", ".", "keras_model", ".", "_losses", "=", "[", "]", "\n", "self", ".", "keras_model", ".", "metrics_tensors", "=", "[", "]", "\n", "self", ".", "keras_model", ".", "_per_input_losses", "=", "{", "}", "\n", "loss_names", "=", "[", "\"rpn_class_loss\"", ",", "\"rpn_bbox_loss\"", ",", "\n", "\"mrcnn_class_loss\"", ",", "\"mrcnn_bbox_loss\"", ",", "\"mrcnn_mask_loss\"", ",", "\n", "\"mrcnn_coord_x_loss\"", ",", "\"mrcnn_coord_y_loss\"", ",", "\"mrcnn_coord_z_loss\"", "]", "\n", "for", "name", "in", "loss_names", ":", "\n", "            ", "layer", "=", "self", ".", "keras_model", ".", "get_layer", "(", "name", ")", "\n", "if", "layer", ".", "output", "in", "self", ".", "keras_model", ".", "losses", ":", "\n", "                ", "continue", "\n", "", "if", "name", "in", "[", "\"mrcnn_coord_x_loss\"", ",", "\"mrcnn_coord_y_loss\"", ",", "\"mrcnn_coord_z_loss\"", "]", ":", "\n", "                ", "self", ".", "keras_model", ".", "add_loss", "(", "self", ".", "config", ".", "COORD_LOSS_SCALE", "*", "tf", ".", "reduce_mean", "(", "layer", ".", "output", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "keras_model", ".", "add_loss", "(", "tf", ".", "reduce_mean", "(", "layer", ".", "output", ")", ")", "\n", "\n", "# Add L2 Regularization", "\n", "", "", "reg_losses", "=", "[", "keras", ".", "regularizers", ".", "l2", "(", "self", ".", "config", ".", "WEIGHT_DECAY", ")", "(", "w", ")", "\n", "for", "w", "in", "self", ".", "keras_model", ".", "trainable_weights", "]", "\n", "reg_loss", "=", "tf", ".", "add_n", "(", "reg_losses", ")", "\n", "\n", "self", ".", "keras_model", ".", "add_loss", "(", "reg_loss", ")", "\n", "\n", "# Compile", "\n", "self", ".", "keras_model", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "[", "None", "]", "*", "len", "(", "self", ".", "keras_model", ".", "outputs", ")", ")", "\n", "\n", "# Add metrics", "\n", "metric_names", "=", "[", "\"rpn_class_loss\"", ",", "\"rpn_bbox_loss\"", ",", "\n", "\"mrcnn_class_loss\"", ",", "\"mrcnn_bbox_loss\"", ",", "\"mrcnn_mask_loss\"", ",", "\n", "\"mrcnn_coord_x_loss\"", ",", "\"mrcnn_coord_y_loss\"", ",", "\"mrcnn_coord_z_loss\"", ",", "\n", "\"mrcnn_coord_x_diff\"", ",", "\"mrcnn_coord_y_diff\"", ",", "\"mrcnn_coord_z_diff\"", ",", "\n", "\"mrcnn_coord_l2_diff\"", "]", "\n", "for", "name", "in", "metric_names", ":", "\n", "            ", "if", "name", "in", "self", ".", "keras_model", ".", "metrics_names", ":", "\n", "                ", "continue", "\n", "", "layer", "=", "self", ".", "keras_model", ".", "get_layer", "(", "name", ")", "\n", "self", ".", "keras_model", ".", "metrics_names", ".", "append", "(", "name", ")", "\n", "self", ".", "keras_model", ".", "metrics_tensors", ".", "append", "(", "tf", ".", "reduce_mean", "(", "layer", ".", "output", ")", ")", "\n", "\n", "", "self", ".", "keras_model", ".", "metrics_names", ".", "append", "(", "\"weight_reg_loss\"", ")", "\n", "self", ".", "keras_model", ".", "metrics_tensors", ".", "append", "(", "tf", ".", "reduce_mean", "(", "reg_loss", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.set_trainable": [[4083, 4118], ["model.log", "hasattr", "bool", "print", "model.MaskRCNN.set_trainable", "re.fullmatch", "model.log"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.set_trainable", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log"], ["", "def", "set_trainable", "(", "self", ",", "layer_regex", ",", "keras_model", "=", "None", ",", "indent", "=", "0", ",", "verbose", "=", "1", ")", ":", "\n", "        ", "\"\"\"Sets model layers as trainable if their names match\n        the given regular expression.\n        \"\"\"", "\n", "# Print message on the first call (but not on recursive calls)", "\n", "if", "verbose", ">", "0", "and", "keras_model", "is", "None", ":", "\n", "            ", "log", "(", "\"Selecting layers to train\"", ")", "\n", "\n", "", "keras_model", "=", "keras_model", "or", "self", ".", "keras_model", "\n", "\n", "# In multi-GPU training, we wrap the model. Get layers", "\n", "# of the inner model because they have the weights.", "\n", "layers", "=", "keras_model", ".", "inner_model", ".", "layers", "if", "hasattr", "(", "keras_model", ",", "\"inner_model\"", ")", "else", "keras_model", ".", "layers", "\n", "\n", "for", "layer", "in", "layers", ":", "\n", "# Is the layer a model?", "\n", "            ", "if", "layer", ".", "__class__", ".", "__name__", "==", "'Model'", ":", "\n", "                ", "print", "(", "\"In model: \"", ",", "layer", ".", "name", ")", "\n", "self", ".", "set_trainable", "(", "layer_regex", ",", "keras_model", "=", "layer", ",", "indent", "=", "indent", "+", "4", ")", "\n", "continue", "\n", "\n", "", "if", "not", "layer", ".", "weights", ":", "\n", "                ", "continue", "\n", "# Is it trainable?", "\n", "", "trainable", "=", "bool", "(", "re", ".", "fullmatch", "(", "layer_regex", ",", "layer", ".", "name", ")", ")", "\n", "# Update layer. If layer is a container, update inner layer.", "\n", "if", "layer", ".", "__class__", ".", "__name__", "==", "'TimeDistributed'", ":", "\n", "                ", "layer", ".", "layer", ".", "trainable", "=", "trainable", "\n", "", "else", ":", "\n", "                ", "layer", ".", "trainable", "=", "trainable", "\n", "# Print trainble layer names", "\n", "", "if", "trainable", "and", "verbose", ">", "0", ":", "\n", "                ", "log", "(", "\"{}{:20}   ({})\"", ".", "format", "(", "\" \"", "*", "indent", ",", "layer", ".", "name", ",", "\n", "layer", ".", "__class__", ".", "__name__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.set_log_dir": [[4119, 4155], ["datetime.datetime.now", "os.path.join", "os.path.join", "model.MaskRCNN.checkpoint_path.replace", "re.match", "os.path.exists", "os.makedirs", "datetime.datetime", "int", "model.MaskRCNN.config.NAME.lower", "model.MaskRCNN.config.NAME.lower", "int", "int", "int", "int", "int", "re.match.group", "re.match.group", "re.match.group", "re.match.group", "re.match.group", "re.match.group"], "methods", ["None"], ["", "", "", "def", "set_log_dir", "(", "self", ",", "model_path", "=", "None", ")", ":", "\n", "        ", "\"\"\"Sets the model log directory and epoch counter.\n\n        model_path: If None, or a format different from what this code uses\n            then set a new log directory and start epochs from 0. Otherwise,\n            extract the log directory and the epoch counter from the file\n            name.\n        \"\"\"", "\n", "# Set date and epoch counter as if starting a new model", "\n", "self", ".", "epoch", "=", "0", "\n", "now", "=", "datetime", ".", "datetime", ".", "now", "(", ")", "\n", "\n", "# If we have a model path with date and epochs use them", "\n", "if", "model_path", ":", "\n", "# Continue from we left of. Get epoch and date from the file name", "\n", "# A sample model path might look like:", "\n", "# /path/to/logs/coco20171029T2315/mask_rcnn_coco_0001.h5", "\n", "            ", "regex", "=", "r\".*/\\w+(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})/mask\\_rcnn\\_\\w+(\\d{4})\\.h5\"", "\n", "m", "=", "re", ".", "match", "(", "regex", ",", "model_path", ")", "\n", "if", "m", ":", "\n", "                ", "now", "=", "datetime", ".", "datetime", "(", "int", "(", "m", ".", "group", "(", "1", ")", ")", ",", "int", "(", "m", ".", "group", "(", "2", ")", ")", ",", "int", "(", "m", ".", "group", "(", "3", ")", ")", ",", "\n", "int", "(", "m", ".", "group", "(", "4", ")", ")", ",", "int", "(", "m", ".", "group", "(", "5", ")", ")", ")", "\n", "self", ".", "epoch", "=", "int", "(", "m", ".", "group", "(", "6", ")", ")", "\n", "\n", "\n", "# Directory for training logs", "\n", "", "", "self", ".", "log_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "model_dir", ",", "\"{}{:%Y%m%dT%H%M}\"", ".", "format", "(", "\n", "self", ".", "config", ".", "NAME", ".", "lower", "(", ")", ",", "now", ")", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "log_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "log_dir", ")", "\n", "\n", "# Path to save after each epoch. Include placeholders that get filled by Keras.", "\n", "", "self", ".", "checkpoint_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "log_dir", ",", "\"mask_rcnn_{}_*epoch*.h5\"", ".", "format", "(", "\n", "self", ".", "config", ".", "NAME", ".", "lower", "(", ")", ")", ")", "\n", "self", ".", "checkpoint_path", "=", "self", ".", "checkpoint_path", ".", "replace", "(", "\"*epoch*\"", ",", "\"{epoch:04d}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.train": [[4157, 4237], ["model.data_generator", "model.data_generator", "model.log", "model.log", "model.MaskRCNN.set_trainable", "model.MaskRCNN.compile", "os.path.join", "model.MaskRCNN.config.log", "model.MaskRCNN.keras_model.fit_generator", "max", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.TensorBoard", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.ModelCheckpoint", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "keras.callbacks.CSVLogger", "next", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.data_generator", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.data_generator", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.set_trainable", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.compile", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log"], ["", "def", "train", "(", "self", ",", "train_dataset", ",", "val_dataset", ",", "learning_rate", ",", "epochs", ",", "layers_name", ")", ":", "\n", "        ", "\"\"\"Train the model.\n        train_dataset, val_dataset: Training and validation Dataset objects.\n        learning_rate: The learning rate to train with\n        epochs: Number of training epochs. Note that previous training epochs\n                are considered to be done alreay, so this actually determines\n                the epochs to train in total rather than in this particaular\n                call.\n        layers: Allows selecting wich layers to train. It can be:\n            - A regular expression to match layer names to train\n            - One of these predefined values:\n              heaads: The RPN, classifier and mask heads of the network\n              all: All the layers\n              3+: Train Resnet stage 3 and up\n              4+: Train Resnet stage 4 and up\n              5+: Train Resnet stage 5 and up\n        \"\"\"", "\n", "assert", "self", ".", "mode", "==", "\"training\"", ",", "\"Create model in training mode.\"", "\n", "\n", "# Pre-defined layer regular expressions", "\n", "layer_regex", "=", "{", "\n", "# only coord map heads", "\n", "\"coords\"", ":", "r\"(mrcnn_coord\\_.*)\"", ",", "\n", "# all layers but the backbone", "\n", "\"heads\"", ":", "r\"(mrcnn\\_.*)|(rpn\\_.*)|(fpn\\_.*)\"", ",", "\n", "# From Resnet stage 4 layers and up", "\n", "\"3+\"", ":", "r\"(res3.*)|(bn3.*)|(res4.*)|(bn4.*)|(res5.*)|(bn5.*)|(mrcnn\\_.*)|(rpn\\_.*)|(fpn\\_.*)\"", ",", "\n", "\"4+\"", ":", "r\"(res4.*)|(bn4.*)|(res5.*)|(bn5.*)|(mrcnn\\_.*)|(rpn\\_.*)|(fpn\\_.*)\"", ",", "\n", "\"5+\"", ":", "r\"(res5.*)|(bn5.*)|(mrcnn\\_.*)|(rpn\\_.*)|(fpn\\_.*)\"", ",", "\n", "# All layers", "\n", "\"all\"", ":", "\".*\"", ",", "\n", "}", "\n", "if", "layers_name", "in", "layer_regex", ":", "\n", "            ", "layers", "=", "layer_regex", "[", "layers_name", "]", "\n", "", "else", ":", "\n", "            ", "assert", "False", ",", "\"[ Error ]: Unknown layers name {}.\"", ".", "format", "(", "layers_name", ")", "\n", "\n", "# Data generators", "\n", "", "train_generator", "=", "data_generator", "(", "train_dataset", ",", "self", ".", "config", ",", "shuffle", "=", "True", ",", "augment", "=", "False", ",", "\n", "batch_size", "=", "self", ".", "config", ".", "BATCH_SIZE", ")", "\n", "val_generator", "=", "data_generator", "(", "val_dataset", ",", "self", ".", "config", ",", "shuffle", "=", "True", ",", "augment", "=", "False", ",", "\n", "batch_size", "=", "self", ".", "config", ".", "BATCH_SIZE", ")", "\n", "\n", "# Callbacks", "\n", "callbacks", "=", "[", "\n", "keras", ".", "callbacks", ".", "TensorBoard", "(", "log_dir", "=", "self", ".", "log_dir", ",", "\n", "histogram_freq", "=", "0", ",", "write_graph", "=", "True", ",", "write_images", "=", "False", ")", ",", "\n", "keras", ".", "callbacks", ".", "ModelCheckpoint", "(", "self", ".", "checkpoint_path", ",", "\n", "verbose", "=", "0", ",", "save_weights_only", "=", "True", ",", "period", "=", "5", ")", ",", "\n", "keras", ".", "callbacks", ".", "CSVLogger", "(", "filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "log_dir", ",", "'training.csv'", ")", ")", "\n", "]", "\n", "\n", "# Common parameters to pass to fit_generator()", "\n", "fit_kwargs", "=", "{", "\n", "\"steps_per_epoch\"", ":", "self", ".", "config", ".", "STEPS_PER_EPOCH", ",", "\n", "\"callbacks\"", ":", "callbacks", ",", "\n", "\"validation_data\"", ":", "next", "(", "val_generator", ")", ",", "\n", "\"validation_steps\"", ":", "self", ".", "config", ".", "VALIDATION_STEPS", ",", "\n", "\"max_queue_size\"", ":", "2", ",", "\n", "\"workers\"", ":", "1", ",", "#max(self.config.BATCH_SIZE // 2, 2),", "\n", "\"use_multiprocessing\"", ":", "True", ",", "\n", "}", "\n", "\n", "# Train", "\n", "log", "(", "\"\\nStarting at epoch {}. LR={}\\n\"", ".", "format", "(", "self", ".", "epoch", ",", "learning_rate", ")", ")", "\n", "log", "(", "\"Checkpoint Path: {}\"", ".", "format", "(", "self", ".", "checkpoint_path", ")", ")", "\n", "self", ".", "set_trainable", "(", "layers", ")", "\n", "self", ".", "compile", "(", "learning_rate", ",", "self", ".", "config", ".", "LEARNING_MOMENTUM", ")", "\n", "\n", "config_output_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "log_dir", ",", "\"training_config_layer_{}_epoch_{}.txt\"", ".", "format", "(", "layers_name", ",", "epochs", ")", ")", "\n", "self", ".", "config", ".", "log", "(", "config_output_path", ")", "\n", "\n", "self", ".", "keras_model", ".", "fit_generator", "(", "\n", "train_generator", ",", "\n", "initial_epoch", "=", "self", ".", "epoch", ",", "\n", "epochs", "=", "epochs", ",", "\n", "**", "fit_kwargs", "\n", ")", "\n", "\n", "self", ".", "epoch", "=", "max", "(", "self", ".", "epoch", ",", "epochs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.mold_inputs": [[4238, 4275], ["numpy.stack", "numpy.stack", "numpy.stack", "utils.resize_image", "model.mold_image", "model.compose_image_meta", "numpy.stack.append", "numpy.stack.append", "numpy.stack.append", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.resize_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mold_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.compose_image_meta"], ["", "def", "mold_inputs", "(", "self", ",", "images", ")", ":", "\n", "        ", "\"\"\"Takes a list of images and modifies them to the format expected\n        as an input to the neural network.\n        images: List of image matricies [height,width,depth]. Images can have\n            different sizes.\n        \n        Returns 3 Numpy matricies:\n        molded_images: [N, h, w, 3]. Images resized and normalized.\n        image_metas: [N, length of meta data]. Details about each image.\n        windows: [N, (y1, x1, y2, x2)]. The portion of the image that has the\n            original image (padding excluded).\n        \"\"\"", "\n", "molded_images", "=", "[", "]", "\n", "image_metas", "=", "[", "]", "\n", "windows", "=", "[", "]", "\n", "for", "image", "in", "images", ":", "\n", "# Resize image to fit the model expected size", "\n", "# TODO: move resizing to mold_image()", "\n", "            ", "molded_image", ",", "window", ",", "scale", ",", "padding", "=", "utils", ".", "resize_image", "(", "\n", "image", ",", "\n", "min_dim", "=", "self", ".", "config", ".", "IMAGE_MIN_DIM", ",", "\n", "max_dim", "=", "self", ".", "config", ".", "IMAGE_MAX_DIM", ",", "\n", "padding", "=", "self", ".", "config", ".", "IMAGE_PADDING", ")", "\n", "molded_image", "=", "mold_image", "(", "molded_image", ",", "self", ".", "config", ")", "\n", "# Build image_meta", "\n", "image_meta", "=", "compose_image_meta", "(", "\n", "0", ",", "image", ".", "shape", ",", "window", ",", "\n", "np", ".", "zeros", "(", "[", "self", ".", "config", ".", "NUM_CLASSES", "]", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "# Append", "\n", "molded_images", ".", "append", "(", "molded_image", ")", "\n", "windows", ".", "append", "(", "window", ")", "\n", "image_metas", ".", "append", "(", "image_meta", ")", "\n", "# Pack into arrays", "\n", "", "molded_images", "=", "np", ".", "stack", "(", "molded_images", ")", "\n", "image_metas", "=", "np", ".", "stack", "(", "image_metas", ")", "\n", "windows", "=", "np", ".", "stack", "(", "windows", ")", "\n", "return", "molded_images", ",", "image_metas", ",", "windows", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.unmold_detections": [[4277, 4347], ["detections[].astype", "min", "numpy.array", "numpy.array", "numpy.multiply().astype", "range", "numpy.where", "numpy.where", "numpy.delete", "numpy.delete", "numpy.delete", "numpy.delete", "numpy.delete", "utils.unmold_mask", "full_masks.append", "utils.unmold_coord", "full_coords.append", "numpy.stack", "numpy.empty", "numpy.stack", "numpy.empty", "numpy.multiply", "numpy.arange", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.unmold_mask", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.unmold_coord"], ["", "def", "unmold_detections", "(", "self", ",", "detections", ",", "mrcnn_mask", ",", "mrcnn_coord", ",", "image_shape", ",", "window", ")", ":", "\n", "        ", "\"\"\"Reformats the detections of one image from the format of the neural\n        network output to a format suitable for use in the rest of the\n        application.\n\n        detections: [N, (y1, x1, y2, x2, class_id, score)]\n        mrcnn_mask: [N, height, width, num_classes]\n        mrcnn_coord: [N, height, width, num_classes, 3]\n        image_shape: [height, width, depth] Original size of the image before resizing\n        window: [y1, x1, y2, x2] Box in the image where the real image is\n                excluding the padding.\n        \n        Returns:\n        boxes: [N, (y1, x1, y2, x2)] Bounding boxes in pixels\n        class_ids: [N] Integer class IDs for each bounding box\n        scores: [N] Float probability scores of the class_id\n        masks: [height, width, num_instances] Instance masks\n        coords: [height, width, num_instances]\n        \"\"\"", "\n", "# How many detections do we have?", "\n", "# Detections array is padded with zeros. Find the first class_id == 0.", "\n", "zero_ix", "=", "np", ".", "where", "(", "detections", "[", ":", ",", "4", "]", "==", "0", ")", "[", "0", "]", "\n", "N", "=", "zero_ix", "[", "0", "]", "if", "zero_ix", ".", "shape", "[", "0", "]", ">", "0", "else", "detections", ".", "shape", "[", "0", "]", "\n", "\n", "# Extract boxes, class_ids, scores, and class-specific masks", "\n", "boxes", "=", "detections", "[", ":", "N", ",", ":", "4", "]", "\n", "class_ids", "=", "detections", "[", ":", "N", ",", "4", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "scores", "=", "detections", "[", ":", "N", ",", "5", "]", "\n", "masks", "=", "mrcnn_mask", "[", "np", ".", "arange", "(", "N", ")", ",", ":", ",", ":", ",", "class_ids", "]", "\n", "coords", "=", "mrcnn_coord", "[", "np", ".", "arange", "(", "N", ")", ",", ":", ",", ":", ",", "class_ids", ",", ":", "]", "\n", "\n", "# Filter out detections with zero area. Often only happens in early", "\n", "# stages of training when the network weights are still a bit random.", "\n", "exclude_ix", "=", "np", ".", "where", "(", "(", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", ")", "*", "(", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", ")", "<=", "0", ")", "[", "0", "]", "\n", "if", "exclude_ix", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "            ", "boxes", "=", "np", ".", "delete", "(", "boxes", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "class_ids", "=", "np", ".", "delete", "(", "class_ids", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "scores", "=", "np", ".", "delete", "(", "scores", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "masks", "=", "np", ".", "delete", "(", "masks", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "coords", "=", "np", ".", "delete", "(", "coords", ",", "exclude_ix", ",", "axis", "=", "0", ")", "\n", "N", "=", "class_ids", ".", "shape", "[", "0", "]", "\n", "\n", "# Compute scale and shift to translate coordinates to image domain.", "\n", "", "h_scale", "=", "image_shape", "[", "0", "]", "/", "(", "window", "[", "2", "]", "-", "window", "[", "0", "]", ")", "\n", "w_scale", "=", "image_shape", "[", "1", "]", "/", "(", "window", "[", "3", "]", "-", "window", "[", "1", "]", ")", "\n", "scale", "=", "min", "(", "h_scale", ",", "w_scale", ")", "\n", "shift", "=", "window", "[", ":", "2", "]", "# y, x", "\n", "scales", "=", "np", ".", "array", "(", "[", "scale", ",", "scale", ",", "scale", ",", "scale", "]", ")", "\n", "shifts", "=", "np", ".", "array", "(", "[", "shift", "[", "0", "]", ",", "shift", "[", "1", "]", ",", "shift", "[", "0", "]", ",", "shift", "[", "1", "]", "]", ")", "\n", "\n", "# Translate bounding boxes to image domain", "\n", "boxes", "=", "np", ".", "multiply", "(", "boxes", "-", "shifts", ",", "scales", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "# Resize masks to original image size and set boundary threshold.", "\n", "full_masks", "=", "[", "]", "\n", "full_coords", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "# Convert neural network mask to full size mask", "\n", "            ", "full_mask", "=", "utils", ".", "unmold_mask", "(", "masks", "[", "i", "]", ",", "boxes", "[", "i", "]", ",", "image_shape", ")", "\n", "full_masks", ".", "append", "(", "full_mask", ")", "\n", "\n", "full_coord", "=", "utils", ".", "unmold_coord", "(", "coords", "[", "i", "]", ",", "boxes", "[", "i", "]", ",", "image_shape", ")", "\n", "full_coords", ".", "append", "(", "full_coord", ")", "\n", "\n", "", "full_masks", "=", "np", ".", "stack", "(", "full_masks", ",", "axis", "=", "-", "1", ")", "if", "full_masks", "else", "np", ".", "empty", "(", "(", "0", ",", ")", "+", "masks", ".", "shape", "[", "1", ":", "3", "]", ")", "\n", "full_coords", "=", "np", ".", "stack", "(", "full_coords", ",", "axis", "=", "-", "2", ")", "if", "full_coords", "else", "np", ".", "empty", "(", "(", "0", ",", ")", "+", "coords", ".", "shape", "[", "1", ":", "4", "]", ")", "\n", "\n", "return", "boxes", ",", "class_ids", ",", "scores", ",", "full_masks", ",", "full_coords", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.detect": [[4348, 4403], ["model.MaskRCNN.mold_inputs", "model.MaskRCNN.keras_model.predict", "numpy.amax", "numpy.amax", "numpy.amax", "print", "print", "numpy.stack", "enumerate", "model.log", "model.log", "model.log", "model.MaskRCNN.unmold_detections", "results.append", "model.log", "len"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.mold_inputs", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.unmold_detections", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log"], ["", "def", "detect", "(", "self", ",", "images", ",", "verbose", "=", "0", ")", ":", "\n", "        ", "\"\"\"Runs the detection pipeline.\n\n        images: List of images, potentially of different sizes.\n\n        Returns a list of dicts, one dict per image. The dict contains:\n        rois: [N, (y1, x1, y2, x2)] detection bounding boxes\n        class_ids: [N] int class IDs\n        scores: [N] float probability scores for the class IDs\n        masks: [H, W, N] instance binary masks\n        \"\"\"", "\n", "assert", "self", ".", "mode", "==", "\"inference\"", ",", "\"Create model in inference mode.\"", "\n", "\n", "if", "verbose", ":", "\n", "            ", "log", "(", "\"Processing {} images\"", ".", "format", "(", "len", "(", "images", ")", ")", ")", "\n", "for", "image", "in", "images", ":", "\n", "                ", "log", "(", "\"image\"", ",", "image", ")", "\n", "# Mold inputs to format expected by the neural network", "\n", "", "", "molded_images", ",", "image_metas", ",", "windows", "=", "self", ".", "mold_inputs", "(", "images", ")", "\n", "if", "verbose", ":", "\n", "            ", "log", "(", "\"molded_images\"", ",", "molded_images", ")", "\n", "log", "(", "\"image_metas\"", ",", "image_metas", ")", "\n", "# Run object detection", "\n", "#detections, mrcnn_class, mrcnn_bbox, mrcnn_mask, \\", "\n", "#rois, rpn_class, rpn_bbox =\\", "\n", "\n", "", "detections", ",", "mrcnn_class", ",", "mrcnn_bbox", ",", "mrcnn_mask", ",", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", ",", "rois", ",", "rpn_class", ",", "rpn_bbox", "=", "self", ".", "keras_model", ".", "predict", "(", "[", "molded_images", ",", "image_metas", "]", ",", "verbose", "=", "0", ")", "\n", "# Process detections", "\n", "\n", "max_coord_x", "=", "np", ".", "amax", "(", "mrcnn_coord_x", ")", "\n", "max_coord_y", "=", "np", ".", "amax", "(", "mrcnn_coord_y", ")", "\n", "max_coord_z", "=", "np", ".", "amax", "(", "mrcnn_coord_z", ")", "\n", "\n", "print", "(", "'predict result:'", ")", "\n", "print", "(", "max_coord_x", ",", "max_coord_y", ",", "max_coord_z", ")", "\n", "\n", "\n", "\n", "mrcnn_coord", "=", "np", ".", "stack", "(", "[", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", "]", ",", "axis", "=", "-", "1", ")", "\n", "results", "=", "[", "]", "\n", "for", "i", ",", "image", "in", "enumerate", "(", "images", ")", ":", "\n", "            ", "final_rois", ",", "final_class_ids", ",", "final_scores", ",", "final_masks", ",", "final_coords", "=", "self", ".", "unmold_detections", "(", "detections", "[", "i", "]", ",", "mrcnn_mask", "[", "i", "]", ",", "mrcnn_coord", "[", "i", "]", ",", "\n", "image", ".", "shape", ",", "windows", "[", "i", "]", ")", "\n", "results", ".", "append", "(", "{", "\n", "\"rois\"", ":", "final_rois", ",", "\n", "\"class_ids\"", ":", "final_class_ids", ",", "\n", "\"scores\"", ":", "final_scores", ",", "\n", "\"masks\"", ":", "final_masks", ",", "\n", "\"coords\"", ":", "final_coords", "\n", "}", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.ancestor": [[4404, 4431], ["isinstance", "len", "re.compile", "bool", "checked.append", "model.MaskRCNN.ancestor", "re.compile.replace", "re.fullmatch"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.compile", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.ancestor"], ["", "def", "ancestor", "(", "self", ",", "tensor", ",", "name", ",", "checked", "=", "None", ")", ":", "\n", "        ", "\"\"\"Finds the ancestor of a TF tensor in the computation graph.\n        tensor: TensorFlow symbolic tensor.\n        name: Name of ancestor tensor to find\n        checked: For internal use. A list of tensors that were already \n                 searched to avoid loops in traversing the graph.\n        \"\"\"", "\n", "checked", "=", "checked", "if", "checked", "is", "not", "None", "else", "[", "]", "\n", "# Put a limit on how deep we go to avoid very long loops", "\n", "if", "len", "(", "checked", ")", ">", "500", ":", "\n", "            ", "return", "None", "\n", "# Convert name to a regex and allow matching a number prefix", "\n", "# because Keras adds them automatically", "\n", "", "if", "isinstance", "(", "name", ",", "str", ")", ":", "\n", "            ", "name", "=", "re", ".", "compile", "(", "name", ".", "replace", "(", "\"/\"", ",", "r\"(\\_\\d+)*/\"", ")", ")", "\n", "\n", "", "parents", "=", "tensor", ".", "op", ".", "inputs", "\n", "for", "p", "in", "parents", ":", "\n", "            ", "if", "p", "in", "checked", ":", "\n", "                ", "continue", "\n", "", "if", "bool", "(", "re", ".", "fullmatch", "(", "name", ",", "p", ".", "name", ")", ")", ":", "\n", "                ", "return", "p", "\n", "", "checked", ".", "append", "(", "p", ")", "\n", "a", "=", "self", ".", "ancestor", "(", "p", ",", "name", ",", "checked", ")", "\n", "if", "a", "is", "not", "None", ":", "\n", "                ", "return", "a", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.find_trainable_layer": [[4432, 4440], ["model.MaskRCNN.find_trainable_layer"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.find_trainable_layer"], ["", "def", "find_trainable_layer", "(", "self", ",", "layer", ")", ":", "\n", "        ", "\"\"\"If a layer is encapsulated by another layer, this function\n        digs through the encapsulation and returns the layer that holds\n        the weights.\n        \"\"\"", "\n", "if", "layer", ".", "__class__", ".", "__name__", "==", "'TimeDistributed'", ":", "\n", "            ", "return", "self", ".", "find_trainable_layer", "(", "layer", ".", "layer", ")", "\n", "", "return", "layer", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.get_trainable_layers": [[4441, 4452], ["model.MaskRCNN.find_trainable_layer", "model.MaskRCNN.get_weights", "layers.append"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.find_trainable_layer"], ["", "def", "get_trainable_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns a list of layers that have weights.\"\"\"", "\n", "layers", "=", "[", "]", "\n", "# Loop through all layers", "\n", "for", "l", "in", "self", ".", "keras_model", ".", "layers", ":", "\n", "# If layer is a wrapper, find inner trainable layer", "\n", "            ", "l", "=", "self", ".", "find_trainable_layer", "(", "l", ")", "\n", "# Include layer if it has weights", "\n", "if", "l", ".", "get_weights", "(", ")", ":", "\n", "                ", "layers", ".", "append", "(", "l", ")", "\n", "", "", "return", "layers", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.run_graph": [[4453, 4500], ["collections.OrderedDict", "collections.OrderedDict.values", "keras.function", "keras.function", "keras.function", "keras.function", "keras.function", "model.MaskRCNN.mold_inputs", "keras.function.", "collections.OrderedDict", "collections.OrderedDict.items", "list", "model_in.append", "model.log", "isinstance", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "collections.OrderedDict.values", "isinstance", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "keras.learning_phase", "zip", "collections.OrderedDict.keys"], "methods", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.MaskRCNN.mold_inputs", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log"], ["", "def", "run_graph", "(", "self", ",", "images", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"Runs a sub-set of the computation graph that computes the given\n        outputs.\n\n        outputs: List of tuples (name, tensor) to compute. The tensors are \n            symbolic TensorFlow tensors and the names are for easy tracking.\n\n        Returns an ordered dict of results. Keys are the names received in the\n        input and values are Numpy arrays.\n        \"\"\"", "\n", "model", "=", "self", ".", "keras_model", "\n", "\n", "# Organize desired outputs into an ordered dict", "\n", "outputs", "=", "OrderedDict", "(", "outputs", ")", "\n", "for", "o", "in", "outputs", ".", "values", "(", ")", ":", "\n", "            ", "assert", "o", "is", "not", "None", "\n", "\n", "# Build a Keras function to run parts of the computation graph", "\n", "", "inputs", "=", "model", ".", "inputs", "\n", "if", "model", ".", "uses_learning_phase", "and", "not", "isinstance", "(", "K", ".", "learning_phase", "(", ")", ",", "int", ")", ":", "\n", "            ", "inputs", "+=", "[", "K", ".", "learning_phase", "(", ")", "]", "\n", "", "kf", "=", "K", ".", "function", "(", "model", ".", "inputs", ",", "list", "(", "outputs", ".", "values", "(", ")", ")", ")", "\n", "\n", "# Run inference", "\n", "molded_images", ",", "image_metas", ",", "windows", "=", "self", ".", "mold_inputs", "(", "images", ")", "\n", "# TODO: support training mode?", "\n", "# if TEST_MODE == \"training\":", "\n", "#     model_in = [molded_images, image_metas, ", "\n", "#                 target_rpn_match, target_rpn_bbox, ", "\n", "#                 gt_boxes, gt_masks]", "\n", "#     if not config.USE_RPN_ROIS:", "\n", "#         model_in.append(target_rois)", "\n", "#     if model.uses_learning_phase and not isinstance(K.learning_phase(), int):", "\n", "#         model_in.append(1.)", "\n", "#     outputs_np = kf(model_in)", "\n", "# else:", "\n", "\n", "model_in", "=", "[", "molded_images", ",", "image_metas", "]", "\n", "if", "model", ".", "uses_learning_phase", "and", "not", "isinstance", "(", "K", ".", "learning_phase", "(", ")", ",", "int", ")", ":", "\n", "            ", "model_in", ".", "append", "(", "0.", ")", "\n", "", "outputs_np", "=", "kf", "(", "model_in", ")", "\n", "\n", "# Pack the generated Numpy arrays into a a dict and log the results.", "\n", "outputs_np", "=", "OrderedDict", "(", "[", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "zip", "(", "outputs", ".", "keys", "(", ")", ",", "outputs_np", ")", "]", ")", "\n", "for", "k", ",", "v", "in", "outputs_np", ".", "items", "(", ")", ":", "\n", "            ", "log", "(", "k", ",", "v", ")", "\n", "", "return", "outputs_np", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log": [[38, 49], ["print", "text.ljust.ljust", "str", "array.min", "array.max"], "function", ["None"], ["def", "log", "(", "text", ",", "array", "=", "None", ")", ":", "\n", "    ", "\"\"\"Prints a text message. And, optionally, if a Numpy array is provided it\n    prints it's shape, min, and max values.\n    \"\"\"", "\n", "if", "array", "is", "not", "None", ":", "\n", "        ", "text", "=", "text", ".", "ljust", "(", "25", ")", "\n", "text", "+=", "(", "\"shape: {:20}  min: {:10.5f}  max: {:10.5f}\"", ".", "format", "(", "\n", "str", "(", "array", ".", "shape", ")", ",", "\n", "array", ".", "min", "(", ")", "if", "array", ".", "size", "else", "\"\"", ",", "\n", "array", ".", "max", "(", ")", "if", "array", ".", "size", "else", "\"\"", ")", ")", "\n", "", "print", "(", "text", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.identity_block": [[70, 101], ["keras.Conv2D", "model.BatchNorm", "keras.Activation", "keras.Conv2D", "model.BatchNorm", "keras.Activation", "keras.Conv2D", "model.BatchNorm", "keras.Add", "keras.Activation", "str", "str", "str"], "function", ["None"], ["", "", "def", "identity_block", "(", "input_tensor", ",", "kernel_size", ",", "filters", ",", "stage", ",", "block", ",", "\n", "use_bias", "=", "True", ")", ":", "\n", "    ", "\"\"\"The identity_block is the block that has no conv layer at shortcut\n    # Arguments\n        input_tensor: input tensor\n        kernel_size: default 3, the kernel size of middle conv layer at main path\n        filters: list of integers, the nb_filters of 3 conv layer at main path\n        stage: integer, current stage label, used for generating layer names\n        block: 'a','b'..., current block label, used for generating layer names\n    \"\"\"", "\n", "nb_filter1", ",", "nb_filter2", ",", "nb_filter3", "=", "filters", "\n", "conv_name_base", "=", "'res'", "+", "str", "(", "stage", ")", "+", "block", "+", "'_branch'", "\n", "bn_name_base", "=", "'bn'", "+", "str", "(", "stage", ")", "+", "block", "+", "'_branch'", "\n", "\n", "x", "=", "KL", ".", "Conv2D", "(", "nb_filter1", ",", "(", "1", ",", "1", ")", ",", "name", "=", "conv_name_base", "+", "'2a'", ",", "\n", "use_bias", "=", "use_bias", ")", "(", "input_tensor", ")", "\n", "x", "=", "BatchNorm", "(", "axis", "=", "-", "1", ",", "name", "=", "bn_name_base", "+", "'2a'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "Conv2D", "(", "nb_filter2", ",", "(", "kernel_size", ",", "kernel_size", ")", ",", "padding", "=", "'same'", ",", "\n", "name", "=", "conv_name_base", "+", "'2b'", ",", "use_bias", "=", "use_bias", ")", "(", "x", ")", "\n", "x", "=", "BatchNorm", "(", "axis", "=", "-", "1", ",", "name", "=", "bn_name_base", "+", "'2b'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "Conv2D", "(", "nb_filter3", ",", "(", "1", ",", "1", ")", ",", "name", "=", "conv_name_base", "+", "'2c'", ",", "\n", "use_bias", "=", "use_bias", ")", "(", "x", ")", "\n", "x", "=", "BatchNorm", "(", "axis", "=", "-", "1", ",", "name", "=", "bn_name_base", "+", "'2c'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "Add", "(", ")", "(", "[", "x", ",", "input_tensor", "]", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ",", "name", "=", "'res'", "+", "str", "(", "stage", ")", "+", "block", "+", "'_out'", ")", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.conv_block": [[103, 139], ["keras.Conv2D", "model.BatchNorm", "keras.Activation", "keras.Conv2D", "model.BatchNorm", "keras.Activation", "keras.Conv2D", "model.BatchNorm", "keras.Conv2D", "model.BatchNorm", "keras.Add", "keras.Activation", "str", "str", "str"], "function", ["None"], ["", "def", "conv_block", "(", "input_tensor", ",", "kernel_size", ",", "filters", ",", "stage", ",", "block", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "use_bias", "=", "True", ")", ":", "\n", "    ", "\"\"\"conv_block is the block that has a conv layer at shortcut\n    # Arguments\n        input_tensor: input tensor\n        kernel_size: defualt 3, the kernel size of middle conv layer at main path\n        filters: list of integers, the nb_filters of 3 conv layer at main path\n        stage: integer, current stage label, used for generating layer names\n        block: 'a','b'..., current block label, used for generating layer names\n    Note that from stage 3, the first conv layer at main path is with subsample=(2,2)\n    And the shortcut should have subsample=(2,2) as well\n    \"\"\"", "\n", "nb_filter1", ",", "nb_filter2", ",", "nb_filter3", "=", "filters", "\n", "conv_name_base", "=", "'res'", "+", "str", "(", "stage", ")", "+", "block", "+", "'_branch'", "\n", "bn_name_base", "=", "'bn'", "+", "str", "(", "stage", ")", "+", "block", "+", "'_branch'", "\n", "\n", "x", "=", "KL", ".", "Conv2D", "(", "nb_filter1", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "strides", ",", "\n", "name", "=", "conv_name_base", "+", "'2a'", ",", "use_bias", "=", "use_bias", ")", "(", "input_tensor", ")", "\n", "x", "=", "BatchNorm", "(", "axis", "=", "-", "1", ",", "name", "=", "bn_name_base", "+", "'2a'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "Conv2D", "(", "nb_filter2", ",", "(", "kernel_size", ",", "kernel_size", ")", ",", "padding", "=", "'same'", ",", "\n", "name", "=", "conv_name_base", "+", "'2b'", ",", "use_bias", "=", "use_bias", ")", "(", "x", ")", "\n", "x", "=", "BatchNorm", "(", "axis", "=", "-", "1", ",", "name", "=", "bn_name_base", "+", "'2b'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "Conv2D", "(", "nb_filter3", ",", "(", "1", ",", "1", ")", ",", "name", "=", "conv_name_base", "+", "'2c'", ",", "use_bias", "=", "use_bias", ")", "(", "x", ")", "\n", "x", "=", "BatchNorm", "(", "axis", "=", "-", "1", ",", "name", "=", "bn_name_base", "+", "'2c'", ")", "(", "x", ")", "\n", "\n", "shortcut", "=", "KL", ".", "Conv2D", "(", "nb_filter3", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "strides", ",", "\n", "name", "=", "conv_name_base", "+", "'1'", ",", "use_bias", "=", "use_bias", ")", "(", "input_tensor", ")", "\n", "shortcut", "=", "BatchNorm", "(", "axis", "=", "-", "1", ",", "name", "=", "bn_name_base", "+", "'1'", ")", "(", "shortcut", ")", "\n", "\n", "x", "=", "KL", ".", "Add", "(", ")", "(", "[", "x", ",", "shortcut", "]", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ",", "name", "=", "'res'", "+", "str", "(", "stage", ")", "+", "block", "+", "'_out'", ")", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.resnet_graph": [[141, 172], ["model.conv_block", "model.identity_block", "model.identity_block", "model.conv_block", "model.identity_block", "model.identity_block", "model.identity_block", "model.conv_block", "range", "keras.ZeroPadding2D", "keras.Conv2D", "model.BatchNorm", "keras.Activation", "keras.MaxPooling2D", "model.identity_block", "model.conv_block", "model.identity_block", "model.identity_block", "chr"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.conv_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.identity_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.identity_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.conv_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.identity_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.identity_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.identity_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.conv_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.identity_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.conv_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.identity_block", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.identity_block"], ["", "def", "resnet_graph", "(", "input_image", ",", "architecture", ",", "stage5", "=", "False", ")", ":", "\n", "    ", "assert", "architecture", "in", "[", "\"resnet50\"", ",", "\"resnet101\"", "]", "\n", "# Stage 1", "\n", "x", "=", "KL", ".", "ZeroPadding2D", "(", "(", "3", ",", "3", ")", ")", "(", "input_image", ")", "\n", "x", "=", "KL", ".", "Conv2D", "(", "64", ",", "(", "7", ",", "7", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "'conv1'", ",", "use_bias", "=", "True", ")", "(", "x", ")", "\n", "x", "=", "BatchNorm", "(", "axis", "=", "-", "1", ",", "name", "=", "'bn_conv1'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "C1", "=", "x", "=", "KL", ".", "MaxPooling2D", "(", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "padding", "=", "\"same\"", ")", "(", "x", ")", "\n", "# Stage 2", "\n", "x", "=", "conv_block", "(", "x", ",", "3", ",", "[", "64", ",", "64", ",", "256", "]", ",", "stage", "=", "2", ",", "block", "=", "'a'", ",", "strides", "=", "(", "1", ",", "1", ")", ")", "\n", "x", "=", "identity_block", "(", "x", ",", "3", ",", "[", "64", ",", "64", ",", "256", "]", ",", "stage", "=", "2", ",", "block", "=", "'b'", ")", "\n", "C2", "=", "x", "=", "identity_block", "(", "x", ",", "3", ",", "[", "64", ",", "64", ",", "256", "]", ",", "stage", "=", "2", ",", "block", "=", "'c'", ")", "\n", "# Stage 3", "\n", "x", "=", "conv_block", "(", "x", ",", "3", ",", "[", "128", ",", "128", ",", "512", "]", ",", "stage", "=", "3", ",", "block", "=", "'a'", ")", "\n", "x", "=", "identity_block", "(", "x", ",", "3", ",", "[", "128", ",", "128", ",", "512", "]", ",", "stage", "=", "3", ",", "block", "=", "'b'", ")", "\n", "x", "=", "identity_block", "(", "x", ",", "3", ",", "[", "128", ",", "128", ",", "512", "]", ",", "stage", "=", "3", ",", "block", "=", "'c'", ")", "\n", "C3", "=", "x", "=", "identity_block", "(", "x", ",", "3", ",", "[", "128", ",", "128", ",", "512", "]", ",", "stage", "=", "3", ",", "block", "=", "'d'", ")", "\n", "# Stage 4", "\n", "x", "=", "conv_block", "(", "x", ",", "3", ",", "[", "256", ",", "256", ",", "1024", "]", ",", "stage", "=", "4", ",", "block", "=", "'a'", ")", "\n", "block_count", "=", "{", "\"resnet50\"", ":", "5", ",", "\"resnet101\"", ":", "22", "}", "[", "architecture", "]", "\n", "for", "i", "in", "range", "(", "block_count", ")", ":", "\n", "        ", "x", "=", "identity_block", "(", "x", ",", "3", ",", "[", "256", ",", "256", ",", "1024", "]", ",", "stage", "=", "4", ",", "block", "=", "chr", "(", "98", "+", "i", ")", ")", "\n", "", "C4", "=", "x", "\n", "# Stage 5", "\n", "if", "stage5", ":", "\n", "        ", "x", "=", "conv_block", "(", "x", ",", "3", ",", "[", "512", ",", "512", ",", "2048", "]", ",", "stage", "=", "5", ",", "block", "=", "'a'", ")", "\n", "x", "=", "identity_block", "(", "x", ",", "3", ",", "[", "512", ",", "512", ",", "2048", "]", ",", "stage", "=", "5", ",", "block", "=", "'b'", ")", "\n", "C5", "=", "x", "=", "identity_block", "(", "x", ",", "3", ",", "[", "512", ",", "512", ",", "2048", "]", ",", "stage", "=", "5", ",", "block", "=", "'c'", ")", "\n", "", "else", ":", "\n", "        ", "C5", "=", "None", "\n", "", "return", "[", "C1", ",", "C2", ",", "C3", ",", "C4", ",", "C5", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.apply_box_deltas_graph": [[178, 200], ["tensorflow.exp", "tensorflow.exp", "tensorflow.stack"], "function", ["None"], ["", "def", "apply_box_deltas_graph", "(", "boxes", ",", "deltas", ")", ":", "\n", "    ", "\"\"\"Applies the given deltas to the given boxes.\n    boxes: [N, 4] where each row is y1, x1, y2, x2\n    deltas: [N, 4] where each row is [dy, dx, log(dh), log(dw)]\n    \"\"\"", "\n", "# Convert to y, x, h, w", "\n", "height", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "width", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "center_y", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "height", "\n", "center_x", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "width", "\n", "# Apply deltas", "\n", "center_y", "+=", "deltas", "[", ":", ",", "0", "]", "*", "height", "\n", "center_x", "+=", "deltas", "[", ":", ",", "1", "]", "*", "width", "\n", "height", "*=", "tf", ".", "exp", "(", "deltas", "[", ":", ",", "2", "]", ")", "\n", "width", "*=", "tf", ".", "exp", "(", "deltas", "[", ":", ",", "3", "]", ")", "\n", "# Convert back to y1, x1, y2, x2", "\n", "y1", "=", "center_y", "-", "0.5", "*", "height", "\n", "x1", "=", "center_x", "-", "0.5", "*", "width", "\n", "y2", "=", "y1", "+", "height", "\n", "x2", "=", "x1", "+", "width", "\n", "result", "=", "tf", ".", "stack", "(", "[", "y1", ",", "x1", ",", "y2", ",", "x2", "]", ",", "axis", "=", "1", ",", "name", "=", "\"apply_box_deltas_out\"", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.clip_boxes_graph": [[202, 217], ["tensorflow.split", "tensorflow.split", "tensorflow.maximum", "tensorflow.maximum", "tensorflow.maximum", "tensorflow.maximum", "tensorflow.concat", "tensorflow.minimum", "tensorflow.minimum", "tensorflow.minimum", "tensorflow.minimum"], "function", ["None"], ["", "def", "clip_boxes_graph", "(", "boxes", ",", "window", ")", ":", "\n", "    ", "\"\"\"\n    boxes: [N, 4] each row is y1, x1, y2, x2\n    window: [4] in the form y1, x1, y2, x2\n    \"\"\"", "\n", "# Split corners", "\n", "wy1", ",", "wx1", ",", "wy2", ",", "wx2", "=", "tf", ".", "split", "(", "window", ",", "4", ")", "\n", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "tf", ".", "split", "(", "boxes", ",", "4", ",", "axis", "=", "1", ")", "\n", "# Clip", "\n", "y1", "=", "tf", ".", "maximum", "(", "tf", ".", "minimum", "(", "y1", ",", "wy2", ")", ",", "wy1", ")", "\n", "x1", "=", "tf", ".", "maximum", "(", "tf", ".", "minimum", "(", "x1", ",", "wx2", ")", ",", "wx1", ")", "\n", "y2", "=", "tf", ".", "maximum", "(", "tf", ".", "minimum", "(", "y2", ",", "wy2", ")", ",", "wy1", ")", "\n", "x2", "=", "tf", ".", "maximum", "(", "tf", ".", "minimum", "(", "x2", ",", "wx2", ")", ",", "wx1", ")", "\n", "clipped", "=", "tf", ".", "concat", "(", "[", "y1", ",", "x1", ",", "y2", ",", "x2", "]", ",", "axis", "=", "1", ",", "name", "=", "\"clipped_boxes\"", ")", "\n", "return", "clipped", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log2_graph": [[308, 311], ["tensorflow.log", "tensorflow.log"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log"], ["", "", "def", "log2_graph", "(", "x", ")", ":", "\n", "    ", "\"\"\"Implementatin of Log2. TF doesn't have a native implemenation.\"\"\"", "\n", "return", "tf", ".", "log", "(", "x", ")", "/", "tf", ".", "log", "(", "2.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.detection_targets_graph": [[419, 600], ["tensorflow.cast", "tensorflow.boolean_mask", "tensorflow.reshape", "tensorflow.tile", "tensorflow.split", "tensorflow.split", "tensorflow.maximum", "tensorflow.maximum", "tensorflow.minimum", "tensorflow.minimum", "tensorflow.reshape", "tensorflow.reduce_max", "int", "tensorflow.gather", "tensorflow.gather", "tensorflow.gather", "tensorflow.argmax", "tensorflow.gather", "utils.box_refinement_graph", "tensorflow.expand_dims", "tensorflow.cast", "tensorflow.transpose", "tensorflow.gather", "tensorflow.gather", "tensorflow.gather", "tensorflow.assert_equal", "tensorflow.range", "tensorflow.assert_equal", "tensorflow.squeeze", "tensorflow.round", "tensorflow.concat", "tensorflow.maximum", "tensorflow.pad", "tensorflow.pad", "tensorflow.pad", "tensorflow.pad", "tensorflow.squeeze", "tensorflow.squeeze", "tensorflow.squeeze", "tensorflow.pad", "tensorflow.pad", "tensorflow.pad", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.Assert", "tensorflow.control_dependencies", "tensorflow.identity", "tensorflow.reduce_sum", "tensorflow.tile", "tensorflow.maximum", "tensorflow.maximum", "tensorflow.where", "tensorflow.where", "tensorflow.random_shuffle", "tensorflow.random_shuffle", "tensorflow.transpose", "tensorflow.shape", "tensorflow.shape", "tensorflow.control_dependencies", "tensorflow.gather", "tensorflow.gather", "tensorflow.gather", "tensorflow.gather", "tensorflow.split", "tensorflow.split", "tensorflow.concat", "tensorflow.shape", "tensorflow.shape", "tensorflow.control_dependencies", "tensorflow.image.crop_and_resize", "tensorflow.image.crop_and_resize", "tensorflow.image.crop_and_resize", "tensorflow.image.crop_and_resize", "tensorflow.shape", "tensorflow.greater", "tensorflow.abs", "tensorflow.expand_dims", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.box_refinement_graph"], ["", "", "def", "detection_targets_graph", "(", "proposals", ",", "gt_boxes", ",", "gt_masks", ",", "gt_coords", ",", "config", ")", ":", "\n", "    ", "\"\"\"Generates detection targets for one image. Subsamples proposals and\n    generates target class IDs, bounding box deltas, and masks for each.\n\n    Inputs:\n    proposals: [N, (y1, x1, y2, x2)] in normalized coordinates. Might\n               be zero padded if there are not enough proposals.\n    gt_boxes: [MAX_GT_INSTANCES, (y1, x1, y2, x2, class_id)] in\n              normalized coordinates.\n    gt_masks: [height, width, MAX_GT_INSTANCES] of boolean type.\n    gt_coords: [height, width, MAX_GT_INSTANCES, 3] of float32 type in the range of [0, 1].\n\n    Returns: Target ROIs and corresponding class IDs, bounding box shifts, masks and coordinate maps.\n    rois: [TRAIN_ROIS_PER_IMAGE, (y1, x1, y2, x2)] in normalized coordinates\n    class_ids: [TRAIN_ROIS_PER_IMAGE]. Integer class IDs. Zero padded.\n    deltas: [TRAIN_ROIS_PER_IMAGE, NUM_CLASSES, (dy, dx, log(dh), log(dw))]\n            Class-specific bbox refinments.\n    masks: [TRAIN_ROIS_PER_IMAGE, height, width]. Masks cropped to bbox\n           boundaries and resized to neural network output size.f\n    coords: [TRAIN_ROIS_PER_IMAGE, height, width, 3]. Coordinate maps cropped to bbox\n           boundaries and resized to neural network output size.\n\n    Note: Returned arrays might be zero padded if not enough target ROIs.\n    \"\"\"", "\n", "# Assertions", "\n", "asserts", "=", "[", "\n", "tf", ".", "Assert", "(", "tf", ".", "greater", "(", "tf", ".", "shape", "(", "proposals", ")", "[", "0", "]", ",", "0", ")", ",", "[", "proposals", "]", ",", "\n", "name", "=", "\"roi_assertion\"", ")", ",", "\n", "]", "\n", "with", "tf", ".", "control_dependencies", "(", "asserts", ")", ":", "\n", "        ", "proposals", "=", "tf", ".", "identity", "(", "proposals", ")", "\n", "\n", "# Remove proposals zero padding", "\n", "", "non_zeros", "=", "tf", ".", "cast", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "abs", "(", "proposals", ")", ",", "axis", "=", "1", ")", ",", "tf", ".", "bool", ")", "\n", "proposals", "=", "tf", ".", "boolean_mask", "(", "proposals", ",", "non_zeros", ")", "\n", "\n", "# TODO: Remove zero padding from gt_boxes and gt_masks", "\n", "\n", "# Compute overlaps matrix [rpn_rois, gt_boxes]", "\n", "# 1. Tile GT boxes and repeate ROIs tensor. This", "\n", "# allows us to compare every ROI against every GT box without loops.", "\n", "# TF doesn't have an equivalent to np.repeate() so simulate it", "\n", "# using tf.tile() and tf.reshape.", "\n", "rois", "=", "tf", ".", "reshape", "(", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "proposals", ",", "1", ")", ",", "\n", "[", "1", ",", "1", ",", "tf", ".", "shape", "(", "gt_boxes", ")", "[", "0", "]", "]", ")", ",", "[", "-", "1", ",", "4", "]", ")", "\n", "boxes", "=", "tf", ".", "tile", "(", "gt_boxes", ",", "[", "tf", ".", "shape", "(", "proposals", ")", "[", "0", "]", ",", "1", "]", ")", "\n", "# 2. Compute intersections", "\n", "roi_y1", ",", "roi_x1", ",", "roi_y2", ",", "roi_x2", "=", "tf", ".", "split", "(", "rois", ",", "4", ",", "axis", "=", "1", ")", "\n", "box_y1", ",", "box_x1", ",", "box_y2", ",", "box_x2", ",", "class_ids", "=", "tf", ".", "split", "(", "boxes", ",", "5", ",", "axis", "=", "1", ")", "\n", "y1", "=", "tf", ".", "maximum", "(", "roi_y1", ",", "box_y1", ")", "\n", "x1", "=", "tf", ".", "maximum", "(", "roi_x1", ",", "box_x1", ")", "\n", "y2", "=", "tf", ".", "minimum", "(", "roi_y2", ",", "box_y2", ")", "\n", "x2", "=", "tf", ".", "minimum", "(", "roi_x2", ",", "box_x2", ")", "\n", "intersection", "=", "tf", ".", "maximum", "(", "x2", "-", "x1", ",", "0", ")", "*", "tf", ".", "maximum", "(", "y2", "-", "y1", ",", "0", ")", "\n", "# 3. Compute unions", "\n", "roi_area", "=", "(", "roi_y2", "-", "roi_y1", ")", "*", "(", "roi_x2", "-", "roi_x1", ")", "\n", "box_area", "=", "(", "box_y2", "-", "box_y1", ")", "*", "(", "box_x2", "-", "box_x1", ")", "\n", "union", "=", "roi_area", "+", "box_area", "-", "intersection", "\n", "# 4. Compute IoU and reshape to [rois, boxes]", "\n", "iou", "=", "intersection", "/", "union", "\n", "overlaps", "=", "tf", ".", "reshape", "(", "iou", ",", "[", "tf", ".", "shape", "(", "proposals", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "gt_boxes", ")", "[", "0", "]", "]", ")", "\n", "\n", "# Determine postive and negative ROIs", "\n", "roi_iou_max", "=", "tf", ".", "reduce_max", "(", "overlaps", ",", "axis", "=", "1", ")", "\n", "# 1. Positive ROIs are those with >= 0.5 IoU with a GT box", "\n", "positive_roi_bool", "=", "(", "roi_iou_max", ">=", "0.5", ")", "\n", "positive_indices", "=", "tf", ".", "where", "(", "positive_roi_bool", ")", "[", ":", ",", "0", "]", "\n", "# 2. Negative ROIs are those with < 0.5 with every GT box", "\n", "negative_indices", "=", "tf", ".", "where", "(", "roi_iou_max", "<", "0.5", ")", "[", ":", ",", "0", "]", "\n", "\n", "# Subsample ROIs. Aim for 33% positive", "\n", "# Positive ROIs", "\n", "positive_count", "=", "int", "(", "config", ".", "TRAIN_ROIS_PER_IMAGE", "*", "config", ".", "ROI_POSITIVE_RATIO", ")", "\n", "positive_indices", "=", "tf", ".", "random_shuffle", "(", "positive_indices", ")", "[", ":", "positive_count", "]", "\n", "# Negative ROIs. Fill the rest of the batch.", "\n", "negative_count", "=", "config", ".", "TRAIN_ROIS_PER_IMAGE", "-", "tf", ".", "shape", "(", "positive_indices", ")", "[", "0", "]", "\n", "negative_indices", "=", "tf", ".", "random_shuffle", "(", "negative_indices", ")", "[", ":", "negative_count", "]", "\n", "# Gather selected ROIs", "\n", "positive_rois", "=", "tf", ".", "gather", "(", "proposals", ",", "positive_indices", ")", "\n", "negative_rois", "=", "tf", ".", "gather", "(", "proposals", ",", "negative_indices", ")", "\n", "\n", "# Assign positive ROIs to GT boxes.", "\n", "positive_overlaps", "=", "tf", ".", "gather", "(", "overlaps", ",", "positive_indices", ")", "\n", "roi_gt_box_assignment", "=", "tf", ".", "argmax", "(", "positive_overlaps", ",", "axis", "=", "1", ")", "\n", "roi_gt_boxes", "=", "tf", ".", "gather", "(", "gt_boxes", ",", "roi_gt_box_assignment", ")", "\n", "\n", "# Compute bbox refinement for positive ROIs", "\n", "deltas", "=", "utils", ".", "box_refinement_graph", "(", "positive_rois", ",", "roi_gt_boxes", "[", ":", ",", ":", "4", "]", ")", "\n", "deltas", "/=", "config", ".", "BBOX_STD_DEV", "\n", "\n", "# Assign positive ROIs to GT masks", "\n", "# Permute masks to [N, height, width, 1]", "\n", "transposed_masks", "=", "tf", ".", "expand_dims", "(", "tf", ".", "transpose", "(", "gt_masks", ",", "[", "2", ",", "0", ",", "1", "]", ")", ",", "-", "1", ")", "\n", "transposed_masks", "=", "tf", ".", "cast", "(", "transposed_masks", ",", "tf", ".", "float32", ")", "\n", "\n", "transposed_coords", "=", "tf", ".", "transpose", "(", "gt_coords", ",", "[", "2", ",", "0", ",", "1", ",", "3", "]", ")", "\n", "transposed_coord_x", "=", "tf", ".", "gather", "(", "transposed_coords", ",", "[", "0", "]", ",", "axis", "=", "3", ")", "\n", "transposed_coord_y", "=", "tf", ".", "gather", "(", "transposed_coords", ",", "[", "1", "]", ",", "axis", "=", "3", ")", "\n", "transposed_coord_z", "=", "tf", ".", "gather", "(", "transposed_coords", ",", "[", "2", "]", ",", "axis", "=", "3", ")", "\n", "\n", "assert_op", "=", "tf", ".", "assert_equal", "(", "tf", ".", "shape", "(", "transposed_masks", ")", ",", "tf", ".", "shape", "(", "transposed_coord_x", ")", ",", "\n", "[", "tf", ".", "shape", "(", "transposed_masks", ")", ",", "tf", ".", "shape", "(", "transposed_coord_x", ")", "]", ",", "name", "=", "'coord_mask'", ")", "\n", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "assert_op", "]", ")", ":", "\n", "#transposed_mask_coord = tf.concat([transposed_masks, transposed_coords], axis=3)", "\n", "\n", "# Pick the right mask for each ROI", "\n", "        ", "roi_masks", "=", "tf", ".", "gather", "(", "transposed_masks", ",", "roi_gt_box_assignment", ")", "\n", "roi_coord_x", "=", "tf", ".", "gather", "(", "transposed_coord_x", ",", "roi_gt_box_assignment", ")", "\n", "roi_coord_y", "=", "tf", ".", "gather", "(", "transposed_coord_y", ",", "roi_gt_box_assignment", ")", "\n", "roi_coord_z", "=", "tf", ".", "gather", "(", "transposed_coord_z", ",", "roi_gt_box_assignment", ")", "\n", "\n", "# Compute mask targets", "\n", "", "boxes", "=", "positive_rois", "\n", "if", "config", ".", "USE_MINI_MASK", ":", "\n", "# Transform ROI corrdinates from normalized image space", "\n", "# to normalized mini-mask space.", "\n", "        ", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "tf", ".", "split", "(", "positive_rois", ",", "4", ",", "axis", "=", "1", ")", "\n", "gt_y1", ",", "gt_x1", ",", "gt_y2", ",", "gt_x2", ",", "_", "=", "tf", ".", "split", "(", "roi_gt_boxes", ",", "5", ",", "axis", "=", "1", ")", "\n", "gt_h", "=", "gt_y2", "-", "gt_y1", "\n", "gt_w", "=", "gt_x2", "-", "gt_x1", "\n", "y1", "=", "(", "y1", "-", "gt_y1", ")", "/", "gt_h", "\n", "x1", "=", "(", "x1", "-", "gt_x1", ")", "/", "gt_w", "\n", "y2", "=", "(", "y2", "-", "gt_y1", ")", "/", "gt_h", "\n", "x2", "=", "(", "x2", "-", "gt_x1", ")", "/", "gt_w", "\n", "boxes", "=", "tf", ".", "concat", "(", "[", "y1", ",", "x1", ",", "y2", ",", "x2", "]", ",", "1", ")", "\n", "", "box_ids", "=", "tf", ".", "range", "(", "0", ",", "tf", ".", "shape", "(", "roi_masks", ")", "[", "0", "]", ")", "\n", "\n", "assert_op_new", "=", "tf", ".", "assert_equal", "(", "tf", ".", "shape", "(", "roi_masks", ")", ",", "tf", ".", "shape", "(", "roi_coord_x", ")", ",", "\n", "[", "tf", ".", "shape", "(", "roi_masks", ")", ",", "tf", ".", "shape", "(", "roi_coord_x", ")", "]", ",", "name", "=", "'coord_mask_2'", ")", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "assert_op_new", "]", ")", ":", "\n", "        ", "masks", "=", "tf", ".", "image", ".", "crop_and_resize", "(", "tf", ".", "cast", "(", "roi_masks", ",", "tf", ".", "float32", ")", ",", "boxes", ",", "\n", "box_ids", ",", "\n", "config", ".", "MASK_SHAPE", ")", "\n", "coord_x", "=", "tf", ".", "image", ".", "crop_and_resize", "(", "tf", ".", "cast", "(", "roi_coord_x", ",", "tf", ".", "float32", ")", ",", "boxes", ",", "\n", "box_ids", ",", "\n", "config", ".", "COORD_SHAPE", ")", "\n", "coord_y", "=", "tf", ".", "image", ".", "crop_and_resize", "(", "tf", ".", "cast", "(", "roi_coord_y", ",", "tf", ".", "float32", ")", ",", "boxes", ",", "\n", "box_ids", ",", "\n", "config", ".", "COORD_SHAPE", ")", "\n", "coord_z", "=", "tf", ".", "image", ".", "crop_and_resize", "(", "tf", ".", "cast", "(", "roi_coord_z", ",", "tf", ".", "float32", ")", ",", "boxes", ",", "\n", "box_ids", ",", "\n", "config", ".", "COORD_SHAPE", ")", "\n", "\n", "\n", "#masks =  tf.gather(mask_coord, indices=[0], axis=-1)", "\n", "#coords = tf.gather(mask_coord, indices=[1, 2, 3], axis=-1)", "\n", "\n", "# Remove the extra dimension from masks.", "\n", "", "masks", "=", "tf", ".", "squeeze", "(", "masks", ",", "axis", "=", "3", ")", "\n", "\n", "# Threshold mask pixels at 0.5 to have GT masks be 0 or 1 to use with", "\n", "# binary cross entropy loss.", "\n", "masks", "=", "tf", ".", "round", "(", "masks", ")", "\n", "\n", "# Append negative ROIs and pad bbox deltas and masks that", "\n", "# are not used for negative ROIs with zeros.", "\n", "rois", "=", "tf", ".", "concat", "(", "[", "positive_rois", ",", "negative_rois", "]", ",", "axis", "=", "0", ")", "\n", "N", "=", "tf", ".", "shape", "(", "negative_rois", ")", "[", "0", "]", "\n", "P", "=", "tf", ".", "maximum", "(", "config", ".", "TRAIN_ROIS_PER_IMAGE", "-", "tf", ".", "shape", "(", "rois", ")", "[", "0", "]", ",", "0", ")", "\n", "rois", "=", "tf", ".", "pad", "(", "rois", ",", "[", "(", "0", ",", "P", ")", ",", "(", "0", ",", "0", ")", "]", ")", "\n", "roi_gt_boxes", "=", "tf", ".", "pad", "(", "roi_gt_boxes", ",", "[", "(", "0", ",", "N", "+", "P", ")", ",", "(", "0", ",", "0", ")", "]", ")", "\n", "deltas", "=", "tf", ".", "pad", "(", "deltas", ",", "[", "(", "0", ",", "N", "+", "P", ")", ",", "(", "0", ",", "0", ")", "]", ")", "\n", "masks", "=", "tf", ".", "pad", "(", "masks", ",", "[", "[", "0", ",", "N", "+", "P", "]", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", "]", ")", "\n", "\n", "coord_x", "=", "tf", ".", "squeeze", "(", "coord_x", ",", "axis", "=", "3", ")", "\n", "coord_y", "=", "tf", ".", "squeeze", "(", "coord_y", ",", "axis", "=", "3", ")", "\n", "coord_z", "=", "tf", ".", "squeeze", "(", "coord_z", ",", "axis", "=", "3", ")", "\n", "\n", "coord_x", "=", "tf", ".", "pad", "(", "coord_x", ",", "[", "[", "0", ",", "N", "+", "P", "]", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", "]", ")", "\n", "coord_y", "=", "tf", ".", "pad", "(", "coord_y", ",", "[", "[", "0", ",", "N", "+", "P", "]", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", "]", ")", "\n", "coord_z", "=", "tf", ".", "pad", "(", "coord_z", ",", "[", "[", "0", ",", "N", "+", "P", "]", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", "]", ")", "\n", "\n", "coord_x", "=", "tf", ".", "cast", "(", "coord_x", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "coord_y", "=", "tf", ".", "cast", "(", "coord_y", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "coord_z", "=", "tf", ".", "cast", "(", "coord_z", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "\n", "#tf.assert_equal(tf.shape(coords)[-1], 3, [tf.shape(coords)])", "\n", "\n", "return", "rois", ",", "roi_gt_boxes", "[", ":", ",", "4", "]", ",", "deltas", ",", "masks", ",", "coord_x", ",", "coord_y", ",", "coord_z", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.clip_to_window": [[675, 685], ["numpy.maximum", "numpy.maximum", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.minimum", "numpy.minimum"], "function", ["None"], ["", "", "def", "clip_to_window", "(", "window", ",", "boxes", ")", ":", "\n", "    ", "\"\"\"\n    window: (y1, x1, y2, x2). The window in the image we want to clip to.\n    boxes: [N, (y1, x1, y2, x2)]\n    \"\"\"", "\n", "boxes", "[", ":", ",", "0", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "0", "]", ",", "window", "[", "2", "]", ")", ",", "window", "[", "0", "]", ")", "\n", "boxes", "[", ":", ",", "1", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "1", "]", ",", "window", "[", "3", "]", ")", ",", "window", "[", "1", "]", ")", "\n", "boxes", "[", ":", ",", "2", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "2", "]", ",", "window", "[", "2", "]", ")", ",", "window", "[", "0", "]", ")", "\n", "boxes", "[", ":", ",", "3", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "3", "]", ",", "window", "[", "3", "]", ")", ",", "window", "[", "1", "]", ")", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.refine_detections": [[687, 757], ["numpy.argmax", "utils.apply_box_deltas", "numpy.array", "model.clip_to_window", "numpy.rint().astype", "numpy.unique", "numpy.intersect1d().astype", "numpy.hstack", "numpy.where", "numpy.intersect1d", "utils.non_max_suppression", "numpy.union1d", "numpy.rint", "numpy.where", "numpy.intersect1d", "numpy.argsort", "numpy.arange", "numpy.arange", "numpy.where"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.apply_box_deltas", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.clip_to_window", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.non_max_suppression"], ["", "def", "refine_detections", "(", "rois", ",", "probs", ",", "deltas", ",", "window", ",", "config", ")", ":", "\n", "    ", "\"\"\"Refine classified proposals and filter overlaps and return final\n    detections.\n\n    Inputs:\n        rois: [N, (y1, x1, y2, x2)] in normalized coordinates\n        probs: [N, num_classes]. Class probabilities.\n        deltas: [N, num_classes, (dy, dx, log(dh), log(dw))]. Class-specific\n                bounding box deltas.\n        window: (y1, x1, y2, x2) in image coordinates. The part of the image\n            that contains the image excluding the padding.\n\n    Returns detections shaped: [N, (y1, x1, y2, x2, class_id, score)]\n    \"\"\"", "\n", "# Class IDs per ROI", "\n", "class_ids", "=", "np", ".", "argmax", "(", "probs", ",", "axis", "=", "1", ")", "\n", "# Class probability of the top class of each ROI", "\n", "class_scores", "=", "probs", "[", "np", ".", "arange", "(", "class_ids", ".", "shape", "[", "0", "]", ")", ",", "class_ids", "]", "\n", "# Class-specific bounding box deltas", "\n", "deltas_specific", "=", "deltas", "[", "np", ".", "arange", "(", "deltas", ".", "shape", "[", "0", "]", ")", ",", "class_ids", "]", "\n", "# Apply bounding box deltas", "\n", "# Shape: [boxes, (y1, x1, y2, x2)] in normalized coordinates", "\n", "refined_rois", "=", "utils", ".", "apply_box_deltas", "(", "\n", "rois", ",", "deltas_specific", "*", "config", ".", "BBOX_STD_DEV", ")", "\n", "# Convert coordiates to image domain", "\n", "# TODO: better to keep them normalized until later", "\n", "height", ",", "width", "=", "config", ".", "IMAGE_SHAPE", "[", ":", "2", "]", "\n", "refined_rois", "*=", "np", ".", "array", "(", "[", "height", ",", "width", ",", "height", ",", "width", "]", ")", "\n", "# Clip boxes to image window", "\n", "refined_rois", "=", "clip_to_window", "(", "window", ",", "refined_rois", ")", "\n", "# Round and cast to int since we're deadling with pixels now", "\n", "refined_rois", "=", "np", ".", "rint", "(", "refined_rois", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "# TODO: Filter out boxes with zero area", "\n", "\n", "# Filter out background boxes", "\n", "keep", "=", "np", ".", "where", "(", "class_ids", ">", "0", ")", "[", "0", "]", "\n", "# Filter out low confidence boxes", "\n", "if", "config", ".", "DETECTION_MIN_CONFIDENCE", ":", "\n", "        ", "keep", "=", "np", ".", "intersect1d", "(", "\n", "keep", ",", "np", ".", "where", "(", "class_scores", ">=", "config", ".", "DETECTION_MIN_CONFIDENCE", ")", "[", "0", "]", ")", "\n", "\n", "# Apply per-class NMS", "\n", "", "pre_nms_class_ids", "=", "class_ids", "[", "keep", "]", "\n", "pre_nms_scores", "=", "class_scores", "[", "keep", "]", "\n", "pre_nms_rois", "=", "refined_rois", "[", "keep", "]", "\n", "nms_keep", "=", "[", "]", "\n", "for", "class_id", "in", "np", ".", "unique", "(", "pre_nms_class_ids", ")", ":", "\n", "# Pick detections of this class", "\n", "        ", "ixs", "=", "np", ".", "where", "(", "pre_nms_class_ids", "==", "class_id", ")", "[", "0", "]", "\n", "# Apply NMS", "\n", "class_keep", "=", "utils", ".", "non_max_suppression", "(", "\n", "pre_nms_rois", "[", "ixs", "]", ",", "pre_nms_scores", "[", "ixs", "]", ",", "\n", "config", ".", "DETECTION_NMS_THRESHOLD", ")", "\n", "# Map indicies", "\n", "class_keep", "=", "keep", "[", "ixs", "[", "class_keep", "]", "]", "\n", "nms_keep", "=", "np", ".", "union1d", "(", "nms_keep", ",", "class_keep", ")", "\n", "", "keep", "=", "np", ".", "intersect1d", "(", "keep", ",", "nms_keep", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "# Keep top detections", "\n", "roi_count", "=", "config", ".", "DETECTION_MAX_INSTANCES", "\n", "top_ids", "=", "np", ".", "argsort", "(", "class_scores", "[", "keep", "]", ")", "[", ":", ":", "-", "1", "]", "[", ":", "roi_count", "]", "\n", "keep", "=", "keep", "[", "top_ids", "]", "\n", "\n", "# Arrange output as [N, (y1, x1, y2, x2, class_id, score)]", "\n", "# Coordinates are in image domain.", "\n", "result", "=", "np", ".", "hstack", "(", "(", "refined_rois", "[", "keep", "]", ",", "\n", "class_ids", "[", "keep", "]", "[", "...", ",", "np", ".", "newaxis", "]", ",", "\n", "class_scores", "[", "keep", "]", "[", "...", ",", "np", ".", "newaxis", "]", ")", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.rpn_graph": [[804, 845], ["keras.Conv2D", "keras.Conv2D", "keras.Lambda", "keras.Activation", "keras.Conv2D", "keras.Lambda", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["", "", "def", "rpn_graph", "(", "feature_map", ",", "anchors_per_location", ",", "anchor_stride", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of Region Proposal Network.\n\n    feature_map: backbone features [batch, height, width, depth]\n    anchors_per_location: number of anchors per pixel in the feature map\n    anchor_stride: Controls the density of anchors. Typically 1 (anchors for\n                   every pixel in the feature map), or 2 (every other pixel).\n\n    Returns:\n        rpn_logits: [batch, H, W, 2] Anchor classifier logits (before softmax)\n        rpn_probs: [batch, W, W, 2] Anchor classifier probabilities.\n        rpn_bbox: [batch, H, W, (dy, dx, log(dh), log(dw))] Deltas to be\n                  applied to anchors.\n    \"\"\"", "\n", "# TODO: check if stride of 2 causes alignment issues if the featuremap", "\n", "#       is not even.", "\n", "# Shared convolutional base of the RPN", "\n", "shared", "=", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'same'", ",", "activation", "=", "'relu'", ",", "\n", "strides", "=", "anchor_stride", ",", "\n", "name", "=", "'rpn_conv_shared'", ")", "(", "feature_map", ")", "\n", "\n", "# Anchor Score. [batch, height, width, anchors per location * 2].", "\n", "x", "=", "KL", ".", "Conv2D", "(", "2", "*", "anchors_per_location", ",", "(", "1", ",", "1", ")", ",", "padding", "=", "'valid'", ",", "\n", "activation", "=", "'linear'", ",", "name", "=", "'rpn_class_raw'", ")", "(", "shared", ")", "\n", "\n", "# Reshape to [batch, anchors, 2]", "\n", "rpn_class_logits", "=", "KL", ".", "Lambda", "(", "\n", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "-", "1", ",", "2", "]", ")", ")", "(", "x", ")", "\n", "\n", "# Softmax on last dimension of BG/FG.", "\n", "rpn_probs", "=", "KL", ".", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"rpn_class_xxx\"", ")", "(", "rpn_class_logits", ")", "\n", "\n", "# Bounding box refinement. [batch, H, W, anchors per location, depth]", "\n", "# where depth is [x, y, log(w), log(h)]", "\n", "x", "=", "KL", ".", "Conv2D", "(", "anchors_per_location", "*", "4", ",", "(", "1", ",", "1", ")", ",", "padding", "=", "\"valid\"", ",", "\n", "activation", "=", "'linear'", ",", "name", "=", "'rpn_bbox_pred'", ")", "(", "shared", ")", "\n", "\n", "# Reshape to [batch, anchors, 4]", "\n", "rpn_bbox", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "-", "1", ",", "4", "]", ")", ")", "(", "x", ")", "\n", "\n", "return", "[", "rpn_class_logits", ",", "rpn_probs", ",", "rpn_bbox", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_rpn_model": [[847, 867], ["keras.Input", "model.rpn_graph", "keras.Model"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.rpn_graph"], ["", "def", "build_rpn_model", "(", "anchor_stride", ",", "anchors_per_location", ",", "depth", ")", ":", "\n", "    ", "\"\"\"Builds a Keras model of the Region Proposal Network.\n    It wraps the RPN graph so it can be used multiple times with shared\n    weights.\n\n    anchors_per_location: number of anchors per pixel in the feature map\n    anchor_stride: Controls the density of anchors. Typically 1 (anchors for\n                   every pixel in the feature map), or 2 (every other pixel).\n    depth: Depth of the backbone feature map.\n\n    Returns a Keras Model object. The model outputs, when called, are:\n    rpn_logits: [batch, H, W, 2] Anchor classifier logits (before softmax)\n    rpn_probs: [batch, W, W, 2] Anchor classifier probabilities.\n    rpn_bbox: [batch, H, W, (dy, dx, log(dh), log(dw))] Deltas to be\n                applied to anchors.\n    \"\"\"", "\n", "input_feature_map", "=", "KL", ".", "Input", "(", "shape", "=", "[", "None", ",", "None", ",", "depth", "]", ",", "\n", "name", "=", "\"input_rpn_feature_map\"", ")", "\n", "outputs", "=", "rpn_graph", "(", "input_feature_map", ",", "anchors_per_location", ",", "anchor_stride", ")", "\n", "return", "KM", ".", "Model", "(", "[", "input_feature_map", "]", ",", "outputs", ",", "name", "=", "\"rpn_model\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.fpn_classifier_graph": [[873, 926], ["keras.int_shape", "model.PyramidROIAlign", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.Dropout", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.Lambda", "keras.TimeDistributed", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Reshape", "keras.Conv2D", "model.BatchNorm", "keras.Conv2D", "model.BatchNorm", "keras.Dense", "keras.Activation", "keras.Dense", "keras.squeeze", "keras.squeeze"], "function", ["None"], ["", "def", "fpn_classifier_graph", "(", "rois", ",", "feature_maps", ",", "\n", "image_shape", ",", "pool_size", ",", "num_classes", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of the feature pyramid network classifier\n    and regressor heads.\n\n    rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized\n          coordinates.\n    feature_maps: List of feature maps from diffent layers of the pyramid,\n                  [P2, P3, P4, P5]. Each has a different resolution.\n    image_shape: [height, width, depth]\n    pool_size: The width of the square feature map generated from ROI Pooling.\n    num_classes: number of classes, which determines the depth of the results\n\n    Returns:\n        logits: [N, NUM_CLASSES] classifier logits (before softmax)\n        probs: [N, NUM_CLASSES] classifier probabilities\n        bbox_deltas: [N, (dy, dx, log(dh), log(dw))] Deltas to apply to \n                     proposal boxes\n    \"\"\"", "\n", "# ROI Pooling", "\n", "# Shape: [batch, num_boxes, pool_height, pool_width, channels]", "\n", "x", "=", "PyramidROIAlign", "(", "[", "pool_size", ",", "pool_size", "]", ",", "image_shape", ",", "\n", "name", "=", "\"roi_align_classifier\"", ")", "(", "[", "rois", "]", "+", "feature_maps", ")", "\n", "# Two 1024 FC layers (implemented with Conv2D for consistency)", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "1024", ",", "(", "pool_size", ",", "pool_size", ")", ",", "padding", "=", "\"valid\"", ")", ",", "\n", "name", "=", "\"mrcnn_class_conv1\"", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "name", "=", "'mrcnn_class_bn1'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Dropout", "(", "0.5", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "1024", ",", "(", "1", ",", "1", ")", ")", ",", "\n", "name", "=", "\"mrcnn_class_conv2\"", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_class_bn2'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "shared", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "K", ".", "squeeze", "(", "K", ".", "squeeze", "(", "x", ",", "3", ")", ",", "2", ")", ",", "\n", "name", "=", "\"pool_squeeze\"", ")", "(", "x", ")", "\n", "\n", "# Classifier head", "\n", "mrcnn_class_logits", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Dense", "(", "num_classes", ")", ",", "\n", "name", "=", "'mrcnn_class_logits'", ")", "(", "shared", ")", "\n", "mrcnn_probs", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Activation", "(", "\"softmax\"", ")", ",", "\n", "name", "=", "\"mrcnn_class\"", ")", "(", "mrcnn_class_logits", ")", "\n", "\n", "# BBox head", "\n", "# [batch, boxes, num_classes * (dy, dx, log(dh), log(dw))]", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Dense", "(", "num_classes", "*", "4", ",", "activation", "=", "'linear'", ")", ",", "\n", "name", "=", "'mrcnn_bbox_fc'", ")", "(", "shared", ")", "\n", "# Reshape to [batch, boxes, num_classes, (dy, dx, log(dh), log(dw))]", "\n", "s", "=", "K", ".", "int_shape", "(", "x", ")", "\n", "mrcnn_bbox", "=", "KL", ".", "Reshape", "(", "(", "s", "[", "1", "]", ",", "num_classes", ",", "4", ")", ",", "name", "=", "\"mrcnn_bbox\"", ")", "(", "x", ")", "\n", "\n", "return", "mrcnn_class_logits", ",", "mrcnn_probs", ",", "mrcnn_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_mask_graph": [[928, 990], ["model.PyramidROIAlign", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2DTranspose", "keras.Conv2D", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm"], "function", ["None"], ["", "def", "build_fpn_mask_graph", "(", "rois", ",", "feature_maps", ",", "\n", "image_shape", ",", "pool_size", ",", "num_classes", ",", "use_bn", ",", "net_name", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of the mask head of Feature Pyramid Network.\n\n    rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized\n          coordinates.\n    feature_maps: List of feature maps from diffent layers of the pyramid,\n                  [P2, P3, P4, P5]. Each has a different resolution.\n    image_shape: [height, width, depth]\n    pool_size: The width of the square feature map generated from ROI Pooling.\n    num_classes: number of classes, which determines the depth of the results\n\n    Returns: Masks [batch, roi_count, height, width, num_classes]\n    \"\"\"", "\n", "# ROI Pooling", "\n", "# Shape: [batch, boxes, pool_height, pool_width, channels]", "\n", "\n", "if", "net_name", "==", "'mask'", ":", "\n", "        ", "net_ext", "=", "''", "\n", "", "elif", "net_name", "in", "[", "'coord_x'", ",", "'coord_y'", ",", "'coord_z'", "]", ":", "\n", "        ", "net_ext", "=", "'_'", "+", "net_name", "\n", "", "else", ":", "\n", "        ", "assert", "False", "\n", "\n", "\n", "", "x", "=", "PyramidROIAlign", "(", "[", "pool_size", ",", "pool_size", "]", ",", "image_shape", ",", "\n", "name", "=", "\"roi_align_{}\"", ".", "format", "(", "net_name", ")", ")", "(", "[", "rois", "]", "+", "feature_maps", ")", "\n", "\n", "# Conv layers", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_mask_conv1{}\"", ".", "format", "(", "net_ext", ")", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_mask_bn1{}'", ".", "format", "(", "net_ext", ")", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_mask_conv2{}\"", ".", "format", "(", "net_ext", ")", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_mask_bn2{}'", ".", "format", "(", "net_ext", ")", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_mask_conv3{}\"", ".", "format", "(", "net_ext", ")", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_mask_bn3{}'", ".", "format", "(", "net_ext", ")", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_mask_conv4{}\"", ".", "format", "(", "net_ext", ")", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_mask_bn4{}'", ".", "format", "(", "net_ext", ")", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "feature_x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2DTranspose", "(", "256", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "2", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "name", "=", "\"mrcnn_mask_deconv{}\"", ".", "format", "(", "net_ext", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "num_classes", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ",", "activation", "=", "\"sigmoid\"", ")", ",", "\n", "name", "=", "\"mrcnn_mask{}\"", ".", "format", "(", "net_ext", ")", ")", "(", "feature_x", ")", "\n", "return", "x", ",", "feature_x", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_coord_graph": [[992, 1082], ["model.PyramidROIAlign", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2DTranspose", "keras.Conv2D", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "tensorflow.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["", "def", "build_fpn_coord_graph", "(", "rois", ",", "feature_maps", ",", "\n", "image_shape", ",", "pool_size", ",", "num_classes", ",", "use_bn", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of the coordinate map head of Feature Pyramid Network.\n\n    rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized\n          coordinates.\n    feature_maps: List of feature maps from different layers of the pyramid,\n                  [P2, P3, P4, P5]. Each has a different resolution.\n    image_shape: [height, width, depth]\n    pool_size: The width of the square feature map generated from ROI Pooling.\n    num_classes: number of classes, which determines the depth of the results\n\n    Returns: Coordinate maps [batch, roi_count, height, width, num_classes, 3]\n    \"\"\"", "\n", "# ROI Pooling", "\n", "# Shape: [batch, boxes, pool_height, pool_width, channels]", "\n", "x", "=", "PyramidROIAlign", "(", "[", "pool_size", ",", "pool_size", "]", ",", "image_shape", ",", "\n", "name", "=", "\"roi_align_coord\"", ")", "(", "[", "rois", "]", "+", "feature_maps", ")", "\n", "\n", "# Conv layers", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv1\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn1'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv2\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn2'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv3\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn3'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv4\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn4'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv5\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn5'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv6\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn6'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv7\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn7'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv8\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn8'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "feature_x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2DTranspose", "(", "512", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "2", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_deconv\"", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "3", "*", "num_classes", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ",", "activation", "=", "\"sigmoid\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_reshape\"", ")", "(", "feature_x", ")", "\n", "\n", "x", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "3", "]", ",", "-", "1", ",", "3", "]", ")", ",", "name", "=", "\"mrcnn_coord\"", ")", "(", "x", ")", "\n", "\n", "mrcnn_coord_x", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "0", "]", ",", "name", "=", "\"mrcnn_coord_x\"", ")", "(", "x", ")", "\n", "mrcnn_coord_y", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "1", "]", ",", "name", "=", "\"mrcnn_coord_y\"", ")", "(", "x", ")", "\n", "mrcnn_coord_z", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "2", "]", ",", "name", "=", "\"mrcnn_coord_z\"", ")", "(", "x", ")", "\n", "\n", "\n", "return", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", ",", "feature_x", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_mask_coords_graph": [[1084, 1177], ["model.PyramidROIAlign", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2DTranspose", "keras.Conv2D", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "tensorflow.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["", "def", "build_fpn_mask_coords_graph", "(", "rois", ",", "feature_maps", ",", "\n", "image_shape", ",", "pool_size", ",", "num_classes", ",", "use_bn", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of the coordinate map head of Feature Pyramid Network.\n\n    rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized\n          coordinates.\n    feature_maps: List of feature maps from different layers of the pyramid,\n                  [P2, P3, P4, P5]. Each has a different resolution.\n    image_shape: [height, width, depth]\n    pool_size: The width of the square feature map generated from ROI Pooling.\n    num_classes: number of classes, which determines the depth of the results\n\n    Returns: Coordinate maps [batch, roi_count, height, width, num_classes, 3]\n    \"\"\"", "\n", "# ROI Pooling", "\n", "# Shape: [batch, boxes, pool_height, pool_width, channels]", "\n", "x", "=", "PyramidROIAlign", "(", "[", "pool_size", ",", "pool_size", "]", ",", "image_shape", ",", "\n", "name", "=", "\"roi_align_coord\"", ")", "(", "[", "rois", "]", "+", "feature_maps", ")", "\n", "\n", "# Conv layers", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv1\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn1'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv2\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn2'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv3\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn3'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv4\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn4'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv5\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn5'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv6\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn6'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv7\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn7'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv8\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn8'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "feature_x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2DTranspose", "(", "512", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "2", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_deconv\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "4", "*", "num_classes", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ",", "activation", "=", "\"sigmoid\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_reshape\"", ")", "(", "feature_x", ")", "\n", "\n", "x", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "3", "]", ",", "-", "1", ",", "4", "]", ")", ",", "name", "=", "\"mrcnn_coord\"", ")", "(", "x", ")", "\n", "\n", "\n", "mrcnn_mask", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "0", "]", ",", "name", "=", "\"mrcnn_mask\"", ")", "(", "x", ")", "\n", "mrcnn_coord_x", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "1", "]", ",", "name", "=", "\"mrcnn_coord_x\"", ")", "(", "x", ")", "\n", "mrcnn_coord_y", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "2", "]", ",", "name", "=", "\"mrcnn_coord_y\"", ")", "(", "x", ")", "\n", "mrcnn_coord_z", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "3", "]", ",", "name", "=", "\"mrcnn_coord_z\"", ")", "(", "x", ")", "\n", "\n", "\n", "return", "mrcnn_mask", ",", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", ",", "feature_x", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_mask_coords_deeper_graph": [[1179, 1273], ["model.PyramidROIAlign", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2DTranspose", "keras.Conv2D", "keras.Conv2D", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "tensorflow.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["", "def", "build_fpn_mask_coords_deeper_graph", "(", "rois", ",", "feature_maps", ",", "\n", "image_shape", ",", "pool_size", ",", "num_classes", ",", "use_bn", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of the coordinate map head of Feature Pyramid Network.\n\n    rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized\n          coordinates.\n    feature_maps: List of feature maps from different layers of the pyramid,\n                  [P2, P3, P4, P5]. Each has a different resolution.\n    image_shape: [height, width, depth]\n    pool_size: The width of the square feature map generated from ROI Pooling.\n    num_classes: number of classes, which determines the depth of the results\n\n    Returns: Coordinate maps [batch, roi_count, height, width, num_classes, 3]\n    \"\"\"", "\n", "# ROI Pooling", "\n", "# Shape: [batch, boxes, pool_height, pool_width, channels]", "\n", "x", "=", "PyramidROIAlign", "(", "[", "pool_size", ",", "pool_size", "]", ",", "image_shape", ",", "\n", "name", "=", "\"roi_align_coord\"", ")", "(", "[", "rois", "]", "+", "feature_maps", ")", "\n", "\n", "# Conv layers", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv1\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn1'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv2\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn2'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv3\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn3'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv4\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn4'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv5\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn5'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv6\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn6'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv7\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn7'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv8\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn8'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "feature_x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2DTranspose", "(", "512", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "2", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_deconv\"", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_deeper\"", ")", "(", "feature_x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "4", "*", "num_classes", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ",", "activation", "=", "\"sigmoid\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_reshape\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "3", "]", ",", "-", "1", ",", "4", "]", ")", ",", "name", "=", "\"mrcnn_coord\"", ")", "(", "x", ")", "\n", "\n", "\n", "mrcnn_mask", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "0", "]", ",", "name", "=", "\"mrcnn_mask\"", ")", "(", "x", ")", "\n", "mrcnn_coord_x", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "1", "]", ",", "name", "=", "\"mrcnn_coord_x\"", ")", "(", "x", ")", "\n", "mrcnn_coord_y", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "2", "]", ",", "name", "=", "\"mrcnn_coord_y\"", ")", "(", "x", ")", "\n", "mrcnn_coord_z", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "3", "]", ",", "name", "=", "\"mrcnn_coord_z\"", ")", "(", "x", ")", "\n", "\n", "\n", "return", "mrcnn_mask", ",", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", ",", "feature_x", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_coords_bins_graph": [[1274, 1364], ["model.PyramidROIAlign", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2DTranspose", "keras.Conv2D", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "tensorflow.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["", "def", "build_fpn_coords_bins_graph", "(", "rois", ",", "feature_maps", ",", "\n", "image_shape", ",", "pool_size", ",", "num_classes", ",", "num_bins", ",", "use_bn", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of the coordinate map head of Feature Pyramid Network.\n\n    rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized\n          coordinates.\n    feature_maps: List of feature maps from different layers of the pyramid,\n                  [P2, P3, P4, P5]. Each has a different resolution.\n    image_shape: [height, width, depth]\n    pool_size: The width of the square feature map generated from ROI Pooling.\n    num_classes: number of classes, which determines the depth of the results\n\n    Returns: Coordinate maps [batch, roi_count, height, width, num_classes, 3]\n    \"\"\"", "\n", "# ROI Pooling", "\n", "# Shape: [batch, boxes, pool_height, pool_width, channels]", "\n", "x", "=", "PyramidROIAlign", "(", "[", "pool_size", ",", "pool_size", "]", ",", "image_shape", ",", "\n", "name", "=", "\"roi_align_coord\"", ")", "(", "[", "rois", "]", "+", "feature_maps", ")", "\n", "\n", "# Conv layers", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv1\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn1'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv2\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn2'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv3\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn3'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv4\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn4'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv5\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn5'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv6\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn6'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv7\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn7'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "512", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv8\"", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn8'", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "feature_x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2DTranspose", "(", "512", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "2", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_deconv\"", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "3", "*", "num_classes", "*", "num_bins", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ",", "activation", "=", "\"sigmoid\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_reshape\"", ")", "(", "feature_x", ")", "\n", "\n", "x", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "3", "]", ",", "-", "1", ",", "3", ",", "\n", "num_bins", "]", ")", ",", "name", "=", "\"mrcnn_coord_bins_reshape\"", ")", "(", "x", ")", "\n", "\n", "mrcnn_coord_x", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "0", ",", ":", "]", ",", "name", "=", "\"mrcnn_coord_x\"", ")", "(", "x", ")", "\n", "mrcnn_coord_y", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "1", ",", ":", "]", ",", "name", "=", "\"mrcnn_coord_y\"", ")", "(", "x", ")", "\n", "mrcnn_coord_z", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "2", ",", ":", "]", ",", "name", "=", "\"mrcnn_coord_z\"", ")", "(", "x", ")", "\n", "\n", "return", "mrcnn_coord_x", ",", "mrcnn_coord_y", ",", "mrcnn_coord_z", ",", "feature_x", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_coords_bins_delta_graph": [[1367, 1441], ["model.PyramidROIAlign", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Lambda", "keras.Lambda", "keras.Activation", "keras.Activation", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Lambda", "keras.Conv2D", "model.BatchNorm", "keras.Conv2D", "model.BatchNorm", "keras.Conv2D", "model.BatchNorm", "keras.Conv2D", "model.BatchNorm", "keras.Conv2DTranspose", "keras.Conv2D", "keras.Conv2D", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["", "def", "build_fpn_coords_bins_delta_graph", "(", "rois", ",", "feature_maps", ",", "\n", "image_shape", ",", "pool_size", ",", "num_classes", ",", "num_bins", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of the coordinate map head of Feature Pyramid Network.\n\n    rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized\n          coordinates.\n    feature_maps: List of feature maps from different layers of the pyramid,\n                  [P2, P3, P4, P5]. Each has a different resolution.\n    image_shape: [height, width, depth]\n    pool_size: The width of the square feature map generated from ROI Pooling.\n    num_classes: number of classes, which determines the depth of the results\n\n    Returns: Coordinate maps [batch, roi_count, height, width, num_classes, 3]\n    \"\"\"", "\n", "# ROI Pooling", "\n", "# Shape: [batch, boxes, pool_height, pool_width, channels]", "\n", "x", "=", "PyramidROIAlign", "(", "[", "pool_size", ",", "pool_size", "]", ",", "image_shape", ",", "\n", "name", "=", "\"roi_align_coord\"", ")", "(", "[", "rois", "]", "+", "feature_maps", ")", "\n", "\n", "# Conv layers", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv1\"", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn1'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv2\"", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn2'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv3\"", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn3'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv4\"", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_coord_bn4'", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2DTranspose", "(", "256", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "2", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "name", "=", "\"mrcnn_coord_deconv\"", ")", "(", "x", ")", "\n", "\n", "\n", "x1", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "3", "*", "num_bins", "*", "num_classes", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv_bins\"", ")", "(", "x", ")", "\n", "x2", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "3", "*", "num_bins", "*", "num_classes", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ")", ",", "\n", "name", "=", "\"mrcnn_coord_conv_delta\"", ")", "(", "x", ")", "\n", "\n", "\n", "\n", "x1", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "3", "]", ",", "-", "1", ",", "3", ",", "num_bins", "]", ")", ",", "name", "=", "\"mrcnn_coord_bins_reshape\"", ")", "(", "x1", ")", "\n", "x2", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "3", "]", ",", "-", "1", ",", "3", ",", "\n", "num_bins", "]", ")", ",", "name", "=", "\"mrcnn_coord_delta_reshape\"", ")", "(", "x2", ")", "\n", "\n", "x1", "=", "KL", ".", "Activation", "(", "'softmax'", ",", "name", "=", "'mrcnn_coord_bins'", ")", "(", "x1", ")", "\n", "x2", "=", "KL", ".", "Activation", "(", "'sigmoid'", ",", "name", "=", "'mrcnn_coord_delta'", ")", "(", "x2", ")", "\n", "\n", "mrcnn_coord_x_bin", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "0", ",", ":", "]", ",", "name", "=", "\"mrcnn_coord_x_bin\"", ")", "(", "x1", ")", "\n", "mrcnn_coord_y_bin", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "1", ",", ":", "]", ",", "name", "=", "\"mrcnn_coord_y_bin\"", ")", "(", "x1", ")", "\n", "mrcnn_coord_z_bin", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "2", ",", ":", "]", ",", "name", "=", "\"mrcnn_coord_z_bin\"", ")", "(", "x1", ")", "\n", "\n", "mrcnn_coord_x_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "0", ",", ":", "]", ",", "name", "=", "\"mrcnn_coord_x_delta\"", ")", "(", "x2", ")", "\n", "mrcnn_coord_y_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "1", ",", ":", "]", ",", "name", "=", "\"mrcnn_coord_y_delta\"", ")", "(", "x2", ")", "\n", "mrcnn_coord_z_delta", "=", "KL", ".", "Lambda", "(", "lambda", "x", ":", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ",", "2", ",", ":", "]", ",", "name", "=", "\"mrcnn_coord_z_delta\"", ")", "(", "x2", ")", "\n", "\n", "return", "mrcnn_coord_x_bin", ",", "mrcnn_coord_y_bin", ",", "mrcnn_coord_z_bin", ",", "mrcnn_coord_x_delta", ",", "mrcnn_coord_y_delta", ",", "mrcnn_coord_z_delta", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_coord_bins_graph": [[1443, 1503], ["model.PyramidROIAlign", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Lambda", "keras.Activation", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2D", "keras.TimeDistributed", "keras.Conv2DTranspose", "keras.Conv2D", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "model.BatchNorm", "tensorflow.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["", "def", "build_fpn_coord_bins_graph", "(", "rois", ",", "feature_maps", ",", "\n", "image_shape", ",", "pool_size", ",", "num_classes", ",", "num_bins", ",", "use_bn", ",", "net_name", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of the coordinate map head of Feature Pyramid Network.\n\n    rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized\n          coordinates.\n    feature_maps: List of feature maps from different layers of the pyramid,\n                  [P2, P3, P4, P5]. Each has a different resolution.\n    image_shape: [height, width, depth]\n    pool_size: The width of the square feature map generated from ROI Pooling.\n    num_classes: number of classes, which determines the depth of the results\n\n    Returns: Coordinate maps [batch, roi_count, height, width, num_classes, num_bins]\n    \"\"\"", "\n", "# ROI Pooling", "\n", "# Shape: [batch, boxes, pool_height, pool_width, channels]", "\n", "x", "=", "PyramidROIAlign", "(", "[", "pool_size", ",", "pool_size", "]", ",", "image_shape", ",", "\n", "name", "=", "\"roi_align_{}\"", ".", "format", "(", "net_name", ")", ")", "(", "[", "rois", "]", "+", "feature_maps", ")", "\n", "\n", "# Conv layers", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv1\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_{}_bn1'", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv2\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_{}_bn2'", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv3\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_{}_bn3'", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv4\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "if", "use_bn", ":", "\n", "        ", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_{}_bn4'", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x_feature", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2DTranspose", "(", "256", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "2", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_deconv\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "num_bins", "*", "num_classes", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv_bins\"", ".", "format", "(", "net_name", ")", ")", "(", "x_feature", ")", "\n", "\n", "x", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "3", "]", ",", "-", "1", ",", "num_bins", "]", ")", ",", "name", "=", "\"mrcnn_{}_bins_reshape\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "Activation", "(", "'softmax'", ",", "name", "=", "'mrcnn_{}_bins'", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "\n", "\n", "return", "x", ",", "x_feature", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_fpn_coord_bins_delta_graph": [[1505, 1575], ["model.PyramidROIAlign", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Activation", "keras.TimeDistributed", "keras.TimeDistributed", "keras.TimeDistributed", "keras.Lambda", "keras.Activation", "keras.Lambda", "keras.Activation", "keras.Conv2D", "model.BatchNorm", "keras.Conv2D", "model.BatchNorm", "keras.Conv2D", "model.BatchNorm", "keras.Conv2D", "model.BatchNorm", "keras.Conv2DTranspose", "keras.Conv2D", "keras.Conv2D", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["", "def", "build_fpn_coord_bins_delta_graph", "(", "rois", ",", "feature_maps", ",", "\n", "image_shape", ",", "pool_size", ",", "num_classes", ",", "num_bins", ",", "net_name", ")", ":", "\n", "    ", "\"\"\"Builds the computation graph of the coordinate map head of Feature Pyramid Network.\n\n    rois: [batch, num_rois, (y1, x1, y2, x2)] Proposal boxes in normalized\n          coordinates.\n    feature_maps: List of feature maps from different layers of the pyramid,\n                  [P2, P3, P4, P5]. Each has a different resolution.\n    image_shape: [height, width, depth]\n    pool_size: The width of the square feature map generated from ROI Pooling.\n    num_classes: number of classes, which determines the depth of the results\n\n    Returns: Coordinate maps [batch, roi_count, height, width, num_classes, num_bins]\n    \"\"\"", "\n", "# ROI Pooling", "\n", "# Shape: [batch, boxes, pool_height, pool_width, channels]", "\n", "x", "=", "PyramidROIAlign", "(", "[", "pool_size", ",", "pool_size", "]", ",", "image_shape", ",", "\n", "name", "=", "\"roi_align_{}\"", ".", "format", "(", "net_name", ")", ")", "(", "[", "rois", "]", "+", "feature_maps", ")", "\n", "\n", "# Conv layers", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv1\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_{}_bn1'", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv2\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_{}_bn2'", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv3\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_{}_bn3'", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "256", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "\"same\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv4\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "BatchNorm", "(", "axis", "=", "-", "1", ")", ",", "\n", "name", "=", "'mrcnn_{}_bn4'", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "x", "=", "KL", ".", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "x", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2DTranspose", "(", "256", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "2", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "name", "=", "\"mrcnn_{}_deconv\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "\n", "# after deconv, two braches diverge: one for bin classification, one for delta regression", "\n", "x1", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "num_bins", "*", "num_classes", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv_bins\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "\n", "x2", "=", "KL", ".", "TimeDistributed", "(", "KL", ".", "Conv2D", "(", "num_bins", "*", "num_classes", ",", "(", "1", ",", "1", ")", ",", "strides", "=", "1", ")", ",", "\n", "name", "=", "\"mrcnn_{}_conv_delta\"", ".", "format", "(", "net_name", ")", ")", "(", "x", ")", "\n", "\n", "\n", "\n", "x1", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "3", "]", ",", "-", "1", ",", "num_bins", "]", ")", ",", "name", "=", "\"mrcnn_{}_bins_reshape\"", ".", "format", "(", "net_name", ")", ")", "(", "x1", ")", "\n", "\n", "x1", "=", "KL", ".", "Activation", "(", "'softmax'", ",", "name", "=", "'mrcnn_{}_bins'", ".", "format", "(", "net_name", ")", ")", "(", "x1", ")", "\n", "\n", "x2", "=", "KL", ".", "Lambda", "(", "lambda", "t", ":", "tf", ".", "reshape", "(", "t", ",", "\n", "[", "tf", ".", "shape", "(", "t", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "2", "]", ",", "tf", ".", "shape", "(", "t", ")", "[", "3", "]", ",", "-", "1", ",", "num_bins", "]", ")", ",", "\n", "name", "=", "\"mrcnn_{}_delta_reshape\"", ".", "format", "(", "net_name", ")", ")", "(", "x2", ")", "\n", "\n", "x2", "=", "KL", ".", "Activation", "(", "'sigmoid'", ",", "name", "=", "'mrcnn_{}_delta_bins'", ".", "format", "(", "net_name", ")", ")", "(", "x2", ")", "\n", "\n", "\n", "\n", "return", "x1", ",", "x2", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.smooth_l1_loss": [[1581, 1591], ["keras.abs", "keras.cast", "keras.less"], "function", ["None"], ["", "def", "smooth_l1_loss", "(", "y_true", ",", "y_pred", ")", ":", "\n", "    ", "\"\"\"Implements Smooth-L1 loss.\n    y_true and y_pred are typicallly: [N, 4], but could be any shape.\n    \"\"\"", "\n", "diff", "=", "K", ".", "abs", "(", "y_true", "-", "y_pred", ")", "\n", "less_than_one", "=", "K", ".", "cast", "(", "K", ".", "less", "(", "diff", ",", "1.0", ")", ",", "\"float32\"", ")", "\n", "loss", "=", "(", "less_than_one", "*", "0.5", "*", "diff", "**", "2", ")", "+", "(", "1", "-", "less_than_one", ")", "*", "(", "diff", "-", "0.5", ")", "\n", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.smooth_l1_diff": [[1593, 1605], ["keras.cast", "keras.less"], "function", ["None"], ["", "def", "smooth_l1_diff", "(", "diff", ",", "threshold", "=", "0.1", ")", ":", "\n", "    ", "coefficient", "=", "1", "/", "(", "2", "*", "threshold", ")", "\n", "#coefficient = tf.Print(coefficient, [coefficient], message='coefficient', summarize=15)", "\n", "\n", "less_than_threshold", "=", "K", ".", "cast", "(", "K", ".", "less", "(", "diff", ",", "threshold", ")", ",", "\"float32\"", ")", "\n", "#less_than_threshold = tf.Print(less_than_threshold, [less_than_threshold], message='less_than_threshold', summarize=15)", "\n", "\n", "loss", "=", "(", "less_than_threshold", "*", "coefficient", "*", "diff", "**", "2", ")", "+", "(", "1", "-", "less_than_threshold", ")", "*", "(", "diff", "-", "threshold", "/", "2", ")", "\n", "#loss = tf.Print(loss, [loss], message='loss',", "\n", "#                              summarize=15)", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.rpn_class_loss_graph": [[1606, 1629], ["tensorflow.squeeze", "keras.cast", "tensorflow.where", "tensorflow.gather_nd", "tensorflow.gather_nd", "keras.sparse_categorical_crossentropy", "keras.switch", "keras.equal", "keras.not_equal", "keras.mean", "tensorflow.constant", "tensorflow.size"], "function", ["None"], ["", "def", "rpn_class_loss_graph", "(", "rpn_match", ",", "rpn_class_logits", ")", ":", "\n", "    ", "\"\"\"RPN anchor classifier loss.\n\n    rpn_match: [batch, anchors, 1]. Anchor match type. 1=positive,\n               -1=negative, 0=neutral anchor.\n    rpn_class_logits: [batch, anchors, 2]. RPN classifier logits for FG/BG.\n    \"\"\"", "\n", "# Squeeze last dim to simplify", "\n", "rpn_match", "=", "tf", ".", "squeeze", "(", "rpn_match", ",", "-", "1", ")", "\n", "# Get anchor classes. Convert the -1/+1 match to 0/1 values.", "\n", "anchor_class", "=", "K", ".", "cast", "(", "K", ".", "equal", "(", "rpn_match", ",", "1", ")", ",", "tf", ".", "int32", ")", "\n", "# Positive and Negative anchors contribute to the loss,", "\n", "# but neutral anchors (match value = 0) don't.", "\n", "indices", "=", "tf", ".", "where", "(", "K", ".", "not_equal", "(", "rpn_match", ",", "0", ")", ")", "\n", "# Pick rows that contribute to the loss and filter out the rest.", "\n", "rpn_class_logits", "=", "tf", ".", "gather_nd", "(", "rpn_class_logits", ",", "indices", ")", "\n", "anchor_class", "=", "tf", ".", "gather_nd", "(", "anchor_class", ",", "indices", ")", "\n", "# Crossentropy loss", "\n", "loss", "=", "K", ".", "sparse_categorical_crossentropy", "(", "target", "=", "anchor_class", ",", "\n", "output", "=", "rpn_class_logits", ",", "\n", "from_logits", "=", "True", ")", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "size", "(", "loss", ")", ">", "0", ",", "K", ".", "mean", "(", "loss", ")", ",", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.rpn_bbox_loss_graph": [[1631, 1662], ["keras.squeeze", "tensorflow.where", "tensorflow.gather_nd", "keras.sum", "model.batch_pack_graph", "keras.abs", "keras.cast", "keras.switch", "keras.equal", "keras.cast", "keras.less", "keras.mean", "tensorflow.constant", "keras.equal", "tensorflow.size"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.batch_pack_graph"], ["", "def", "rpn_bbox_loss_graph", "(", "config", ",", "target_bbox", ",", "rpn_match", ",", "rpn_bbox", ")", ":", "\n", "    ", "\"\"\"Return the RPN bounding box loss graph.\n\n    config: the model config object.\n    target_bbox: [batch, max positive anchors, (dy, dx, log(dh), log(dw))].\n        Uses 0 padding to fill in unsed bbox deltas.\n    rpn_match: [batch, anchors, 1]. Anchor match type. 1=positive,\n               -1=negative, 0=neutral anchor.\n    rpn_bbox: [batch, anchors, (dy, dx, log(dh), log(dw))]\n    \"\"\"", "\n", "# Positive anchors contribute to the loss, but negative and", "\n", "# neutral anchors (match value of 0 or -1) don't.", "\n", "rpn_match", "=", "K", ".", "squeeze", "(", "rpn_match", ",", "-", "1", ")", "\n", "indices", "=", "tf", ".", "where", "(", "K", ".", "equal", "(", "rpn_match", ",", "1", ")", ")", "\n", "\n", "# Pick bbox deltas that contribute to the loss", "\n", "rpn_bbox", "=", "tf", ".", "gather_nd", "(", "rpn_bbox", ",", "indices", ")", "\n", "\n", "# Trim target bounding box deltas to the same length as rpn_bbox.", "\n", "batch_counts", "=", "K", ".", "sum", "(", "K", ".", "cast", "(", "K", ".", "equal", "(", "rpn_match", ",", "1", ")", ",", "tf", ".", "int32", ")", ",", "axis", "=", "1", ")", "\n", "target_bbox", "=", "batch_pack_graph", "(", "target_bbox", ",", "batch_counts", ",", "\n", "config", ".", "IMAGES_PER_GPU", ")", "\n", "\n", "# TODO: use smooth_l1_loss() rather than reimplementing here", "\n", "#       to reduce code duplication", "\n", "diff", "=", "K", ".", "abs", "(", "target_bbox", "-", "rpn_bbox", ")", "\n", "less_than_one", "=", "K", ".", "cast", "(", "K", ".", "less", "(", "diff", ",", "1.0", ")", ",", "\"float32\"", ")", "\n", "loss", "=", "(", "less_than_one", "*", "0.5", "*", "diff", "**", "2", ")", "+", "(", "1", "-", "less_than_one", ")", "*", "(", "diff", "-", "0.5", ")", "\n", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "size", "(", "loss", ")", ">", "0", ",", "K", ".", "mean", "(", "loss", ")", ",", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_class_loss_graph": [[1664, 1705], ["tensorflow.cast", "tensorflow.argmax", "tensorflow.gather", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "keras.switch", "tensorflow.constant", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum"], "function", ["None"], ["", "def", "mrcnn_class_loss_graph", "(", "target_class_ids", ",", "pred_class_logits", ",", "\n", "active_class_ids", ")", ":", "\n", "    ", "\"\"\"Loss for the classifier head of Mask RCNN.\n\n    target_class_ids: [batch, num_rois]. Integer class IDs. Uses zero\n        padding to fill in the array.\n    pred_class_logits: [batch, num_rois, num_classes]\n    active_class_ids: [batch, num_classes]. Has a value of 1 for\n        classes that are in the dataset of the image, and 0\n        for classes that are not in the dataset.\n    \"\"\"", "\n", "target_class_ids", "=", "tf", ".", "cast", "(", "target_class_ids", ",", "'int64'", ")", "\n", "#target_class_ids = tf.Print(target_class_ids, [target_class_ids], message=\"target_class_ids\", summarize=15)", "\n", "\n", "# Find predictions of classes that are not in the dataset.", "\n", "pred_class_ids", "=", "tf", ".", "argmax", "(", "pred_class_logits", ",", "axis", "=", "2", ")", "\n", "# TODO: Update this line to work with batch > 1. Right now it assumes all", "\n", "#       images in a batch have the same active_class_ids", "\n", "#pred_class_ids = tf.Print(pred_class_ids, [pred_class_logits], message=\"pred_class_logits\", summarize=200)", "\n", "pred_active", "=", "tf", ".", "gather", "(", "active_class_ids", "[", "0", "]", ",", "pred_class_ids", ")", "\n", "#pred_active = tf.Print(pred_active, [pred_active], message=\"pred_active\", summarize=15)", "\n", "\n", "# Loss", "\n", "loss", "=", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "\n", "labels", "=", "target_class_ids", ",", "logits", "=", "pred_class_logits", ")", "\n", "#loss = tf.Print(loss, [loss], message=\"loss\", summarize=15)", "\n", "\n", "# Erase losses of predictions of classes that are not in the active", "\n", "# classes of the image.", "\n", "loss", "=", "loss", "*", "pred_active", "\n", "#loss = tf.Print(loss, [loss], message=\"loss_after_multiply\", summarize=15)", "\n", "\n", "# Computer loss mean. Use only predictions that contribute", "\n", "# to the loss to get a correct mean.", "\n", "#loss = tf.Print(loss, [loss, tf.reduce_sum(pred_active), tf.reduce_sum(loss)], message=\"loss_after_mean\",", "\n", "#                summarize=15)", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "reduce_sum", "(", "pred_active", ")", ">", "0", ",", "tf", ".", "reduce_sum", "(", "loss", ")", "/", "tf", ".", "reduce_sum", "(", "pred_active", ")", ",", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "\n", "##tf.reduce_sum(loss) / tf.reduce_sum(pred_active)", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_bbox_loss_graph": [[1707, 1736], ["keras.reshape", "keras.reshape", "keras.reshape", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather", "tensorflow.gather_nd", "keras.switch", "keras.mean", "keras.reshape", "tensorflow.where", "tensorflow.gather", "model.smooth_l1_loss", "tensorflow.constant", "tensorflow.size", "keras.int_shape"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.smooth_l1_loss"], ["", "def", "mrcnn_bbox_loss_graph", "(", "target_bbox", ",", "target_class_ids", ",", "pred_bbox", ")", ":", "\n", "    ", "\"\"\"Loss for Mask R-CNN bounding box refinement.\n\n    target_bbox: [batch, num_rois, (dy, dx, log(dh), log(dw))]\n    target_class_ids: [batch, num_rois]. Integer class IDs.\n    pred_bbox: [batch, num_rois, num_classes, (dy, dx, log(dh), log(dw))]\n    \"\"\"", "\n", "# Reshape to merge batch and roi dimensions for simplicity.", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "target_bbox", "=", "K", ".", "reshape", "(", "target_bbox", ",", "(", "-", "1", ",", "4", ")", ")", "\n", "pred_bbox", "=", "K", ".", "reshape", "(", "pred_bbox", ",", "(", "-", "1", ",", "K", ".", "int_shape", "(", "pred_bbox", ")", "[", "2", "]", ",", "4", ")", ")", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the right class_id of each ROI. Get their indicies.", "\n", "positive_roi_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_roi_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_roi_ix", ")", ",", "tf", ".", "int64", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_roi_ix", ",", "positive_roi_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Gather the deltas (predicted and true) that contribute to loss", "\n", "target_bbox", "=", "tf", ".", "gather", "(", "target_bbox", ",", "positive_roi_ix", ")", "\n", "pred_bbox", "=", "tf", ".", "gather_nd", "(", "pred_bbox", ",", "indices", ")", "\n", "\n", "# Smooth-L1 Loss", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "size", "(", "target_bbox", ")", ">", "0", ",", "\n", "smooth_l1_loss", "(", "y_true", "=", "target_bbox", ",", "y_pred", "=", "pred_bbox", ")", ",", "\n", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "loss", "=", "K", ".", "mean", "(", "loss", ")", "\n", "loss", "=", "K", ".", "reshape", "(", "loss", ",", "[", "1", ",", "1", "]", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_mask_loss_graph": [[1737, 1777], ["keras.reshape", "tensorflow.shape", "keras.reshape", "tensorflow.shape", "keras.reshape", "tensorflow.transpose", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather", "tensorflow.gather_nd", "keras.binary_crossentropy", "keras.switch", "keras.mean", "keras.reshape", "tensorflow.where", "tensorflow.gather", "tensorflow.constant", "tensorflow.size"], "function", ["None"], ["", "def", "mrcnn_mask_loss_graph", "(", "target_masks", ",", "target_class_ids", ",", "pred_masks", ")", ":", "\n", "    ", "\"\"\"Mask binary cross-entropy loss for the masks head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_masks: [batch, proposals, height, width, num_classes] float32 tensor\n                with values from 0 to 1.\n    \"\"\"", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_masks", ")", "\n", "pred_masks", "=", "K", ".", "reshape", "(", "pred_masks", ",", "\n", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ")", ")", "\n", "# Permute predicted masks to [N, num_classes, height, width]", "\n", "pred_masks", "=", "tf", ".", "transpose", "(", "pred_masks", ",", "[", "0", ",", "3", ",", "1", ",", "2", "]", ")", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the class specific mask of each ROI.", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Gather the masks (predicted and true) that contribute to loss", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_masks", ",", "indices", ")", "\n", "\n", "# Compute binary cross entropy. If no positive ROIs, then return 0.", "\n", "# shape: [batch, roi, num_classes]", "\n", "\n", "binary_crossentropy_loss", "=", "K", ".", "binary_crossentropy", "(", "target", "=", "y_true", ",", "output", "=", "y_pred", ")", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "size", "(", "y_true", ")", ">", "0", ",", "\n", "binary_crossentropy_loss", ",", "\n", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "\n", "loss", "=", "K", ".", "mean", "(", "loss", ")", "\n", "loss", "=", "K", ".", "reshape", "(", "loss", ",", "[", "1", ",", "1", "]", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_l1_loss_graph": [[1779, 1834], ["keras.reshape", "tensorflow.shape", "keras.reshape", "keras.reshape", "tensorflow.shape", "keras.reshape", "tensorflow.transpose", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather", "tensorflow.gather", "tensorflow.cast", "tensorflow.boolean_mask", "tensorflow.gather_nd", "tensorflow.boolean_mask", "keras.abs", "keras.mean", "keras.switch", "keras.reshape", "tensorflow.where", "tensorflow.gather", "tensorflow.constant", "tensorflow.size"], "function", ["None"], ["", "def", "mrcnn_coord_l1_loss_graph", "(", "target_masks", ",", "target_coord", ",", "target_class_ids", ",", "pred_coord", ")", ":", "\n", "    ", "\"\"\"Mask L1 loss for the coordinates head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_coord: [batch, num_rois, height, width]. Might be for x, y or z channel.\n        A float32 tensor of values in the range of [0, 1]. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_coord: [batch, proposals, height, width, num_classes] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "\n", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "target_coord", "=", "K", ".", "reshape", "(", "target_coord", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_coord", ")", "\n", "pred_coord", "=", "K", ".", "reshape", "(", "pred_coord", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ")", ")", "\n", "# Permute predicted masks to [N, num_classes, height, width]", "\n", "pred_coord", "=", "tf", ".", "transpose", "(", "pred_coord", ",", "[", "0", ",", "3", ",", "1", ",", "2", "]", ")", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the class specific mask of each ROI.", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width]", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_coord", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "mask", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "mask", "=", "tf", ".", "cast", "(", "mask", ",", "dtype", "=", "tf", ".", "bool", ")", "\n", "y_true_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_true", ",", "mask", ")", "## shape: [num_pos_rois, height, width]", "\n", "\n", "\n", "#y_mask = tf.gather(target_masks, positive_ix)", "\n", "#num_of_pixels = tf.reduce_sum(y_mask, axis=[1, 2]) + 0.00001", "\n", "#y_pred = tf.gather_nd(pred_coord, indices)", "\n", "#y_pred_in_mask = tf.multiply(y_mask, y_pred)", "\n", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_coord", ",", "indices", ")", "\n", "y_pred_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_pred", ",", "mask", ")", "\n", "\n", "#coord_loss = K.sum(K.abs(y_true_in_mask - y_pred_in_mask), axis=[1, 2])", "\n", "\n", "coord_loss", "=", "K", ".", "abs", "(", "y_true_in_mask", "-", "y_pred_in_mask", ")", "\n", "mean_loss", "=", "K", ".", "mean", "(", "coord_loss", ")", "\n", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "size", "(", "y_true", ")", ">", "0", ",", "mean_loss", ",", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "loss", "=", "K", ".", "reshape", "(", "loss", ",", "[", "1", ",", "1", "]", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.rotation_y_matrix": [[1837, 1844], ["tensorflow.stack", "tensorflow.reshape", "tensorflow.cos", "tensorflow.sin", "tensorflow.cos", "tensorflow.sin"], "function", ["None"], ["", "def", "rotation_y_matrix", "(", "theta", ")", ":", "\n", "    ", "rotation_matrix", "=", "tf", ".", "stack", "(", "[", "tf", ".", "cos", "(", "theta", ")", ",", "0", ",", "tf", ".", "sin", "(", "theta", ")", ",", "\n", "0", ",", "1", ",", "0", ",", "\n", "-", "tf", ".", "sin", "(", "theta", ")", ",", "0", ",", "tf", ".", "cos", "(", "theta", ")", "]", ")", "\n", "rotation_matrix", "=", "tf", ".", "reshape", "(", "rotation_matrix", ",", "(", "3", ",", "3", ")", ")", "\n", "return", "rotation_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.class_id_to_theta": [[1845, 1861], ["tensorflow.py_func", "numpy.float32", "numpy.float32"], "function", ["None"], ["", "def", "class_id_to_theta", "(", "class_id", ")", ":", "\n", "#     synset_names = ['BG', #0", "\n", "#                 'bottle', #1", "\n", "#                 'bowl', #2", "\n", "#                 'camera', #3", "\n", "#                 'can',  #4", "\n", "#                 'laptop',#5", "\n", "#                 'mug'#6", "\n", "#                 ]", "\n", "\n", "    ", "def", "my_func", "(", "class_id", ")", ":", "\n", "        ", "if", "class_id", "in", "[", "1", ",", "2", ",", "4", "]", ":", "\n", "            ", "return", "np", ".", "float32", "(", "2", "*", "math", ".", "pi", "/", "6", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "float32", "(", "0", ")", "\n", "", "", "return", "tf", ".", "py_func", "(", "my_func", ",", "[", "class_id", "]", ",", "tf", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_loss_graph": [[1863, 1981], ["tensorflow.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.image.resize_nearest_neighbor", "tensorflow.image.resize_nearest_neighbor", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.equal", "tensorflow.multiply", "tensorflow.cond", "tensorflow.cast", "tensorflow.where", "tensorflow.cast", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.tile", "tensorflow.gather", "tensorflow.expand_dims", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.concat", "tensorflow.transpose", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.expand_dims", "tensorflow.tile", "keras.abs", "tensorflow.gather", "tensorflow.reshape", "tensorflow.multiply", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.argmin", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.divide", "tensorflow.reduce_mean", "tensorflow.constant", "tensorflow.gather", "tensorflow.reduce_sum", "tensorflow.expand_dims", "tensorflow.size", "model.mrcnn_coord_symmetry_loss_graph.nonzero_positive_loss", "tensorflow.tf.identity", "model.smooth_l1_diff", "model.smooth_l1_diff", "tensorflow.tf.identity", "tensorflow.tf.identity", "tensorflow.tf.square", "tensorflow.tf.square"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.smooth_l1_diff", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.smooth_l1_diff"], ["", "def", "mrcnn_coord_symmetry_loss_graph", "(", "target_masks", ",", "target_coords", ",", "target_class_ids", ",", "target_domain_labels", ",", "pred_coords", ",", "loss_fn", ")", ":", "\n", "    ", "\"\"\"Mask L1 loss for the coordinates head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_coords: [batch, num_rois, height, width, 3].\n        A float32 tensor of values in the range of [0, 1]. Uses zero padding to fill array.\n\n    target_domain_labels: [batch, num_rois]. Bool. 1 for real data, 0 for synthetic data.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_coords: [batch, proposals, height, width, num_classes, 3] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "target_class_ids", "=", "tf", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "coord_shape", "=", "tf", ".", "shape", "(", "target_coords", ")", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_coords", ")", "\n", "\n", "target_masks", "=", "tf", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ",", "1", ")", ")", "\n", "target_coords", "=", "tf", ".", "reshape", "(", "target_coords", ",", "(", "-", "1", ",", "coord_shape", "[", "2", "]", ",", "coord_shape", "[", "3", "]", ",", "3", ")", ")", "\n", "target_coords", "=", "tf", ".", "image", ".", "resize_nearest_neighbor", "(", "target_coords", ",", "(", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ")", ")", "\n", "target_masks", "=", "tf", ".", "image", ".", "resize_nearest_neighbor", "(", "target_masks", ",", "(", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ")", ")", "\n", "target_masks", "=", "tf", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ")", ")", "\n", "\n", "\n", "# Permute predicted coords to [N, num_classes, height, width, 3]", "\n", "pred_coords", "=", "tf", ".", "reshape", "(", "pred_coords", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ",", "3", ")", ")", "\n", "pred_coords", "=", "tf", ".", "transpose", "(", "pred_coords", ",", "[", "0", ",", "3", ",", "1", ",", "2", ",", "4", "]", ")", "\n", "\n", "\n", "# Only positive ROIs contribute to the loss. And only the class specific mask of each ROI.", "\n", "# Only ROIs from synthetic images have the ground truth coord map and therefore contribute to the loss.", "\n", "target_domain_labels", "=", "tf", ".", "reshape", "(", "target_domain_labels", ",", "(", "-", "1", ",", ")", ")", "\n", "domain_ix", "=", "tf", ".", "equal", "(", "target_domain_labels", ",", "False", ")", "\n", "target_class_ids", "=", "tf", ".", "multiply", "(", "target_class_ids", ",", "tf", ".", "cast", "(", "domain_ix", ",", "dtype", "=", "tf", ".", "float32", ")", ")", "\n", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "\n", "\n", "def", "nonzero_positive_loss", "(", "target_masks", ",", "target_coords", ",", "pred_coords", ",", "positive_ix", ")", ":", "\n", "        ", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "# [num_pos_rois]", "\n", "positive_class_rotation_theta", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "class_id_to_theta", "(", "x", ")", ",", "positive_class_ids", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "positive_class_rotation_matrix", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "rotation_y_matrix", "(", "x", ")", ",", "positive_class_rotation_theta", ")", "\n", "positive_class_rotation_matrix", "=", "tf", ".", "reshape", "(", "positive_class_rotation_matrix", ",", "(", "-", "1", ",", "3", ",", "3", ")", ")", "# [num_pos_rois, 3, 3]", "\n", "positive_class_rotation_matrix", "=", "tf", ".", "reshape", "(", "positive_class_rotation_matrix", ",", "\n", "(", "-", "1", ",", "1", ",", "1", ",", "3", ",", "3", ")", ")", "# [num_pos_rois, 1, 1, 3, 3]", "\n", "\n", "tiled_rotation_matrix", "=", "tf", ".", "tile", "(", "positive_class_rotation_matrix", ",", "\n", "[", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "1", ",", "1", "]", ")", "# [num_pos_rois, height, width, 3, 3]", "\n", "# [num_pos_rois, height, weigths, 3, 3]", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width]", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_coords", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width, 3]", "\n", "y_true", "=", "y_true", "-", "0.5", "\n", "y_true", "=", "tf", ".", "expand_dims", "(", "y_true", ",", "axis", "=", "4", ")", "## shape: [num_pos_rois, height, width, 3, 1]", "\n", "#y_true = tf.Print(y_true, [tf.shape(y_true)], message='y_true shape', summarize=10)", "\n", "\n", "## num_rotations = 6", "\n", "rotated_y_true_1", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "y_true", ")", "\n", "rotated_y_true_2", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_1", ")", "\n", "rotated_y_true_3", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_2", ")", "\n", "rotated_y_true_4", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_3", ")", "\n", "rotated_y_true_5", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_4", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width, bins]", "\n", "y_true_stack", "=", "tf", ".", "concat", "(", "[", "y_true", ",", "rotated_y_true_1", ",", "rotated_y_true_2", ",", "rotated_y_true_3", ",", "\n", "rotated_y_true_4", ",", "rotated_y_true_5", "]", ",", "\n", "axis", "=", "4", ")", "## shape: [num_pos_rois, height, width, 3, 6]", "\n", "y_true_stack", "=", "tf", ".", "transpose", "(", "y_true_stack", ",", "(", "0", ",", "1", ",", "2", ",", "4", ",", "3", ")", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "y_true_stack", "=", "y_true_stack", "+", "0.5", "\n", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_coords", ",", "indices", ")", "## shape: [num_pos_roi, height, width, 3]", "\n", "y_pred", "=", "tf", ".", "expand_dims", "(", "y_pred", ",", "axis", "=", "3", ")", "## shape: [num_pos_roi, height, width, 1, 3]", "\n", "y_pred_stack", "=", "tf", ".", "tile", "(", "y_pred", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "tf", ".", "shape", "(", "y_true_stack", ")", "[", "3", "]", ",", "1", "]", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "\n", "diff", "=", "K", ".", "abs", "(", "y_true_stack", "-", "y_pred_stack", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "diff", "=", "loss_fn", "(", "diff", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "\n", "mask", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "# mask = tf.cast(mask, dtype=tf.bool)", "\n", "# y_true_in_mask_stack = tf.boolean_mask(y_true_stack, mask)  ## shape: [num_pixels_in_mask, 6, 3]", "\n", "reshape_mask", "=", "tf", ".", "reshape", "(", "mask", ",", "(", "\n", "tf", ".", "shape", "(", "mask", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "mask", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "mask", ")", "[", "2", "]", ",", "1", ",", "1", ")", ")", "## shape: [num_pixels_in_mask, height, width, 1, 1]", "\n", "num_of_pixels", "=", "tf", ".", "reduce_sum", "(", "mask", ",", "axis", "=", "[", "1", ",", "2", "]", ")", "+", "0.00001", "## shape: [num_pos_rois]", "\n", "\n", "diff_in_mask", "=", "tf", ".", "multiply", "(", "diff", ",", "reshape_mask", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "sum_diff_in_mask", "=", "tf", ".", "reduce_sum", "(", "diff_in_mask", ",", "axis", "=", "[", "1", ",", "2", "]", ")", "## shape: [num_pos_rois, 6, 3]", "\n", "total_sum_diff_in_mask", "=", "tf", ".", "reduce_sum", "(", "sum_diff_in_mask", ",", "axis", "=", "[", "-", "1", "]", ")", "## shape: [num_pos_rois, 6]", "\n", "\n", "arg_min_rotation", "=", "tf", ".", "argmin", "(", "total_sum_diff_in_mask", ",", "axis", "=", "-", "1", ")", "##shape: [num_pos_rois]", "\n", "arg_min_rotation", "=", "tf", ".", "cast", "(", "arg_min_rotation", ",", "tf", ".", "int32", ")", "\n", "\n", "min_indices", "=", "tf", ".", "stack", "(", "[", "tf", ".", "range", "(", "tf", ".", "shape", "(", "arg_min_rotation", ")", "[", "0", "]", ")", ",", "arg_min_rotation", "]", ",", "axis", "=", "-", "1", ")", "\n", "min_diff_in_mask", "=", "tf", ".", "gather_nd", "(", "sum_diff_in_mask", ",", "min_indices", ")", "## shape: [num_pos_rois, 3]", "\n", "\n", "mean_diff_in_mask", "=", "tf", ".", "divide", "(", "min_diff_in_mask", ",", "tf", ".", "expand_dims", "(", "num_of_pixels", ",", "axis", "=", "1", ")", ")", "## shape: [num_pos_rois, 3]", "\n", "\n", "loss", "=", "tf", ".", "reduce_mean", "(", "mean_diff_in_mask", ",", "axis", "=", "0", ")", "## shape:[3]", "\n", "\n", "#loss = tf.Print(loss, [tf.shape(loss)], message='loss shape')", "\n", "return", "loss", "\n", "\n", "", "def", "zero_positive_loss", "(", ")", ":", "\n", "        ", "return", "tf", ".", "constant", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ")", "\n", "\n", "\n", "", "loss", "=", "tf", ".", "cond", "(", "tf", ".", "size", "(", "positive_ix", ")", ">", "0", ",", "\n", "lambda", ":", "nonzero_positive_loss", "(", "target_masks", ",", "target_coords", ",", "pred_coords", ",", "positive_ix", ")", ",", "\n", "lambda", ":", "zero_positive_loss", "(", ")", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_symmetry_euclidean_distance_graph": [[1983, 2106], ["keras.reshape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "keras.reshape", "keras.reshape", "tensorflow.image.resize_nearest_neighbor", "tensorflow.image.resize_nearest_neighbor", "keras.reshape", "keras.reshape", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.equal", "tensorflow.multiply", "tensorflow.cond", "keras.reshape", "tensorflow.cast", "tensorflow.where", "tensorflow.cast", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.tile", "tensorflow.gather", "tensorflow.expand_dims", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.concat", "tensorflow.transpose", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.expand_dims", "tensorflow.tile", "keras.abs", "tensorflow.square", "tensorflow.gather", "tensorflow.reshape", "tensorflow.multiply", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_min", "tensorflow.divide", "tensorflow.sqrt", "tensorflow.reduce_mean", "tensorflow.constant", "tensorflow.gather", "tensorflow.reduce_sum", "tensorflow.size", "model.mrcnn_coord_symmetry_loss_graph.nonzero_positive_loss"], "function", ["None"], ["", "def", "mrcnn_coord_symmetry_euclidean_distance_graph", "(", "target_masks", ",", "target_coords", ",", "target_class_ids", ",", "target_domain_labels", ",", "pred_coords", ")", ":", "\n", "    ", "\"\"\"Mask euclidean distance for the coordinates head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_coords: [batch, num_rois, height, width, 3].\n        A float32 tensor of values in the range of [0, 1]. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_coords: [batch, proposals, height, width, num_classes, 3] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "\n", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "coord_shape", "=", "tf", ".", "shape", "(", "target_coords", ")", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_coords", ")", "\n", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ",", "1", ")", ")", "\n", "\n", "target_coords", "=", "K", ".", "reshape", "(", "target_coords", ",", "(", "-", "1", ",", "coord_shape", "[", "2", "]", ",", "coord_shape", "[", "3", "]", ",", "3", ")", ")", "\n", "target_coords", "=", "tf", ".", "image", ".", "resize_nearest_neighbor", "(", "target_coords", ",", "(", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ")", ")", "\n", "\n", "target_masks", "=", "tf", ".", "image", ".", "resize_nearest_neighbor", "(", "target_masks", ",", "(", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ")", ")", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ")", ")", "\n", "\n", "\n", "pred_coords", "=", "K", ".", "reshape", "(", "pred_coords", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ",", "3", ")", ")", "\n", "# Permute predicted coords to [N, num_classes, height, width, 3]", "\n", "pred_coords", "=", "tf", ".", "transpose", "(", "pred_coords", ",", "[", "0", ",", "3", ",", "1", ",", "2", ",", "4", "]", ")", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the class specific mask of each ROI.", "\n", "# Only ROIs from synthetic images have the ground truth coord map and therefore contribute to the loss.", "\n", "target_domain_labels", "=", "tf", ".", "reshape", "(", "target_domain_labels", ",", "(", "-", "1", ",", ")", ")", "\n", "domain_ix", "=", "tf", ".", "equal", "(", "target_domain_labels", ",", "False", ")", "\n", "target_class_ids", "=", "tf", ".", "multiply", "(", "target_class_ids", ",", "tf", ".", "cast", "(", "domain_ix", ",", "dtype", "=", "tf", ".", "float32", ")", ")", "\n", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "\n", "def", "nonzero_positive_loss", "(", "target_masks", ",", "target_coords", ",", "pred_coords", ",", "positive_ix", ")", ":", "\n", "        ", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "# [num_pos_rois]", "\n", "positive_class_rotation_theta", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "class_id_to_theta", "(", "x", ")", ",", "positive_class_ids", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "positive_class_rotation_matrix", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "rotation_y_matrix", "(", "x", ")", ",", "positive_class_rotation_theta", ")", "\n", "positive_class_rotation_matrix", "=", "tf", ".", "reshape", "(", "positive_class_rotation_matrix", ",", "(", "-", "1", ",", "3", ",", "3", ")", ")", "# [num_pos_rois, 3, 3]", "\n", "positive_class_rotation_matrix", "=", "tf", ".", "reshape", "(", "positive_class_rotation_matrix", ",", "\n", "(", "-", "1", ",", "1", ",", "1", ",", "3", ",", "3", ")", ")", "# [num_pos_rois, 1, 1, 3, 3]", "\n", "\n", "tiled_rotation_matrix", "=", "tf", ".", "tile", "(", "positive_class_rotation_matrix", ",", "\n", "[", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "1", ",", "1", "]", ")", "# [num_pos_rois, height, width, 3, 3]", "\n", "# [num_pos_rois, height, weigths, 3, 3]", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width]", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_coords", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width, 3]", "\n", "y_true", "=", "y_true", "-", "0.5", "\n", "y_true", "=", "tf", ".", "expand_dims", "(", "y_true", ",", "axis", "=", "4", ")", "## shape: [num_pos_rois, height, width, 3, 1]", "\n", "# y_true = tf.Print(y_true, [tf.shape(y_true)], message='y_true shape', summarize=10)", "\n", "\n", "## num_rotations = 6", "\n", "rotated_y_true_1", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "y_true", ")", "\n", "rotated_y_true_2", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_1", ")", "\n", "rotated_y_true_3", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_2", ")", "\n", "rotated_y_true_4", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_3", ")", "\n", "rotated_y_true_5", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_4", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width, bins]", "\n", "y_true_stack", "=", "tf", ".", "concat", "(", "[", "y_true", ",", "rotated_y_true_1", ",", "rotated_y_true_2", ",", "rotated_y_true_3", ",", "\n", "rotated_y_true_4", ",", "rotated_y_true_5", "]", ",", "\n", "axis", "=", "4", ")", "## shape: [num_pos_rois, height, width, 3, 6]", "\n", "y_true_stack", "=", "tf", ".", "transpose", "(", "y_true_stack", ",", "(", "0", ",", "1", ",", "2", ",", "4", ",", "3", ")", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "y_true_stack", "=", "y_true_stack", "+", "0.5", "\n", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_coords", ",", "indices", ")", "## shape: [num_pos_roi, height, width, 3]", "\n", "y_pred", "=", "tf", ".", "expand_dims", "(", "y_pred", ",", "axis", "=", "3", ")", "## shape: [num_pos_roi, height, width, 1, 3]", "\n", "y_pred_stack", "=", "tf", ".", "tile", "(", "y_pred", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "tf", ".", "shape", "(", "y_true_stack", ")", "[", "3", "]", ",", "1", "]", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "\n", "diff", "=", "K", ".", "abs", "(", "y_true_stack", "-", "y_pred_stack", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "diff", "=", "tf", ".", "square", "(", "diff", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "\n", "mask", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "# mask = tf.cast(mask, dtype=tf.bool)", "\n", "# y_true_in_mask_stack = tf.boolean_mask(y_true_stack, mask)  ## shape: [num_pixels_in_mask, 6, 3]", "\n", "reshape_mask", "=", "tf", ".", "reshape", "(", "mask", ",", "(", "\n", "tf", ".", "shape", "(", "mask", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "mask", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "mask", ")", "[", "2", "]", ",", "1", ",", "\n", "1", ")", ")", "## shape: [num_pixels_in_mask, height, width, 1, 1]", "\n", "num_of_pixels", "=", "tf", ".", "reduce_sum", "(", "mask", ",", "axis", "=", "[", "1", ",", "2", "]", ")", "+", "0.00001", "## shape: [num_pos_rois]", "\n", "\n", "diff_in_mask", "=", "tf", ".", "multiply", "(", "diff", ",", "reshape_mask", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "sum_diff_in_mask", "=", "tf", ".", "reduce_sum", "(", "diff_in_mask", ",", "axis", "=", "[", "1", ",", "2", "]", ")", "## shape: [num_pos_rois, 6, 3]", "\n", "total_sum_diff_in_mask", "=", "tf", ".", "reduce_sum", "(", "sum_diff_in_mask", ",", "axis", "=", "[", "-", "1", "]", ")", "## shape: [num_pos_rois, 6]", "\n", "\n", "#arg_min_rotation = tf.argmin(total_sum_diff_in_mask, axis=-1)  ##shape: [num_pos_rois]", "\n", "#arg_min_rotation = tf.cast(arg_min_rotation, tf.int32)", "\n", "\n", "#min_indices = tf.stack([tf.range(tf.shape(arg_min_rotation)[0]), arg_min_rotation], axis=-1)", "\n", "#min_diff_in_mask = tf.gather_nd(sum_diff_in_mask, min_indices)  ## shape: [num_pos_rois, 3]", "\n", "\n", "min_squared_diff_sum_in_mask", "=", "tf", ".", "reduce_min", "(", "total_sum_diff_in_mask", ",", "axis", "=", "-", "1", ")", "## shape: [num_pos_rois]", "\n", "mean_squared_diff_sum_in_mask", "=", "tf", ".", "divide", "(", "min_squared_diff_sum_in_mask", ",", "num_of_pixels", ")", "## shape: [num_pos_rois]", "\n", "euclidean_dist_in_mask", "=", "tf", ".", "sqrt", "(", "mean_squared_diff_sum_in_mask", ")", "\n", "\n", "\n", "dist", "=", "tf", ".", "reduce_mean", "(", "euclidean_dist_in_mask", ",", "axis", "=", "0", ")", "## shape:[1]", "\n", "\n", "# loss = tf.Print(loss, [tf.shape(loss)], message='loss shape')", "\n", "return", "dist", "\n", "\n", "", "def", "zero_positive_loss", "(", ")", ":", "\n", "        ", "return", "tf", ".", "constant", "(", "[", "0.0", "]", ")", "\n", "\n", "", "dist", "=", "tf", ".", "cond", "(", "tf", ".", "size", "(", "positive_ix", ")", ">", "0", ",", "\n", "lambda", ":", "nonzero_positive_loss", "(", "target_masks", ",", "target_coords", ",", "pred_coords", ",", "positive_ix", ")", ",", "\n", "lambda", ":", "zero_positive_loss", "(", ")", ")", "\n", "\n", "dist", "=", "K", ".", "reshape", "(", "dist", ",", "[", "1", ",", "1", "]", ")", "\n", "\n", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_bins_symmetry_loss_graph": [[2108, 2229], ["keras.reshape", "tensorflow.shape", "keras.reshape", "keras.reshape", "tensorflow.shape", "keras.reshape", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.equal", "tensorflow.multiply", "tensorflow.cond", "tensorflow.shape", "tensorflow.cast", "tensorflow.where", "tensorflow.cast", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.tile", "tensorflow.stack", "tensorflow.gather", "tensorflow.expand_dims", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.concat", "tensorflow.transpose", "tensorflow.floor", "tensorflow.cast", "tensorflow.one_hot", "tensorflow.gather_nd", "tensorflow.expand_dims", "tensorflow.tile", "keras.categorical_crossentropy", "tensorflow.gather", "tensorflow.reshape", "tensorflow.multiply", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.argmin", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.divide", "tensorflow.reduce_mean", "tensorflow.constant", "tensorflow.gather", "tensorflow.reduce_sum", "tensorflow.expand_dims", "tensorflow.size", "model.mrcnn_coord_symmetry_loss_graph.nonzero_positive_loss"], "function", ["None"], ["", "def", "mrcnn_coord_bins_symmetry_loss_graph", "(", "target_masks", ",", "target_coords", ",", "target_class_ids", ",", "target_domain_labels", ",", "pred_coords", ")", ":", "\n", "    ", "\"\"\"Mask L2 loss for the coordinates head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_coords: [batch, num_rois, height, width, 3].\n        A float32 tensor of values in the range of [0, 1]. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_coords: [batch, proposals, height, width, num_classes, num_bins, 3] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "\n", "# num_bins = 32", "\n", "num_bins", "=", "tf", ".", "shape", "(", "pred_coords", ")", "[", "-", "2", "]", "\n", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "target_coords", "=", "K", ".", "reshape", "(", "target_coords", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ",", "3", ")", ")", "\n", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_coords", ")", "\n", "pred_coords_reshape", "=", "K", ".", "reshape", "(", "pred_coords", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ",", "num_bins", ",", "3", ")", ")", "\n", "# Permute predicted coords to [N, num_classes, height, width, 3, num_bins]", "\n", "pred_coords_trans", "=", "tf", ".", "transpose", "(", "pred_coords_reshape", ",", "[", "0", ",", "3", ",", "1", ",", "2", ",", "5", ",", "4", "]", ")", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the class specific mask of each ROI.", "\n", "# Only ROIs from synthetic images have the ground truth coord map and therefore contribute to the loss.", "\n", "target_domain_labels", "=", "tf", ".", "reshape", "(", "target_domain_labels", ",", "(", "-", "1", ",", ")", ")", "\n", "domain_ix", "=", "tf", ".", "equal", "(", "target_domain_labels", ",", "False", ")", "\n", "target_class_ids", "=", "tf", ".", "multiply", "(", "target_class_ids", ",", "tf", ".", "cast", "(", "domain_ix", ",", "dtype", "=", "tf", ".", "float32", ")", ")", "\n", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "\n", "def", "nonzero_positive_loss", "(", "target_masks", ",", "target_coords", ",", "pred_coords_trans", ",", "positive_ix", ")", ":", "\n", "        ", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "# [num_pos_rois]", "\n", "# positive_class_ids = tf.Print(positive_class_ids, [positive_class_ids], message=\"cls_ids\", summarize=20)", "\n", "\n", "positive_class_rotation_theta", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "class_id_to_theta", "(", "x", ")", ",", "positive_class_ids", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "# positive_class_rotation_theta = tf.Print(positive_class_rotation_theta, [positive_class_rotation_theta], message=\"thetas\", summarize=20)#", "\n", "#", "\n", "\n", "positive_class_rotation_matrix", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "rotation_y_matrix", "(", "x", ")", ",", "positive_class_rotation_theta", ")", "\n", "positive_class_rotation_matrix", "=", "tf", ".", "reshape", "(", "positive_class_rotation_matrix", ",", "(", "-", "1", ",", "3", ",", "3", ")", ")", "# [num_pos_rois, 3, 3]", "\n", "positive_class_rotation_matrix", "=", "tf", ".", "reshape", "(", "positive_class_rotation_matrix", ",", "\n", "(", "-", "1", ",", "1", ",", "1", ",", "3", ",", "3", ")", ")", "# [num_pos_rois, 1, 1, 3, 3]", "\n", "\n", "tiled_rotation_matrix", "=", "tf", ".", "tile", "(", "positive_class_rotation_matrix", ",", "\n", "[", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ",", "1", ",", "1", "]", ")", "# [num_pos_rois, height, width, 3, 3]", "\n", "# [num_pos_rois, height, weigths, 3, 3]", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width]", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_coords", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width, 3]", "\n", "y_true", "=", "y_true", "-", "0.5", "\n", "y_true", "=", "tf", ".", "expand_dims", "(", "y_true", ",", "axis", "=", "4", ")", "## shape: [num_pos_rois, height, width, 3, 1]", "\n", "\n", "## num_rotations = 6", "\n", "rotated_y_true_1", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "y_true", ")", "\n", "rotated_y_true_2", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_1", ")", "\n", "rotated_y_true_3", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_2", ")", "\n", "rotated_y_true_4", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_3", ")", "\n", "rotated_y_true_5", "=", "tf", ".", "matmul", "(", "tiled_rotation_matrix", ",", "rotated_y_true_4", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width, bins]", "\n", "y_true_stack", "=", "tf", ".", "concat", "(", "[", "y_true", ",", "rotated_y_true_1", ",", "rotated_y_true_2", ",", "rotated_y_true_3", ",", "\n", "rotated_y_true_4", ",", "rotated_y_true_5", "]", ",", "\n", "axis", "=", "4", ")", "## shape: [num_pos_rois, height, width, 3, 6]", "\n", "y_true_stack", "=", "tf", ".", "transpose", "(", "y_true_stack", ",", "(", "0", ",", "1", ",", "2", ",", "4", ",", "3", ")", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "y_true_stack", "=", "y_true_stack", "+", "0.5", "\n", "\n", "y_true_bins_stack", "=", "y_true_stack", "*", "tf", ".", "cast", "(", "num_bins", ",", "tf", ".", "float32", ")", "-", "0.000001", "\n", "y_true_bins_stack", "=", "tf", ".", "floor", "(", "y_true_bins_stack", ")", "\n", "y_true_bins_stack", "=", "tf", ".", "cast", "(", "y_true_bins_stack", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "y_true_bins_stack", "=", "tf", ".", "one_hot", "(", "y_true_bins_stack", ",", "num_bins", ",", "axis", "=", "-", "1", ")", "\n", "## shape: [num_pos_rois, height, width, 6, 3, num_bins]", "\n", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_coords_trans", ",", "indices", ")", "##shape: [num_pos_rois, height, width, 3, num_bins]", "\n", "y_pred", "=", "tf", ".", "expand_dims", "(", "y_pred", ",", "axis", "=", "3", ")", "## shape: [num_pos_roi, height, width, 1, 3, num_bins]", "\n", "y_pred_stack", "=", "tf", ".", "tile", "(", "y_pred", ",", "[", "1", ",", "1", ",", "1", ",", "tf", ".", "shape", "(", "y_true_stack", ")", "[", "3", "]", ",", "1", ",", "1", "]", ")", "\n", "## shape: [num_pos_rois, height, width, 6, 3, num_bins]", "\n", "\n", "\n", "cross_loss", "=", "K", ".", "categorical_crossentropy", "(", "y_true_bins_stack", ",", "\n", "y_pred_stack", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "\n", "mask", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "# mask = tf.cast(mask, dtype=tf.bool)", "\n", "# y_true_in_mask_stack = tf.boolean_mask(y_true_stack, mask)  ## shape: [num_pixels_in_mask, 6, 3]", "\n", "reshape_mask", "=", "tf", ".", "reshape", "(", "mask", ",", "(", "tf", ".", "shape", "(", "mask", ")", "[", "0", "]", ",", "tf", ".", "shape", "(", "mask", ")", "[", "1", "]", ",", "tf", ".", "shape", "(", "mask", ")", "[", "2", "]", ",", "1", ",", "1", ")", ")", "\n", "## shape: [num_pos_rois, height, width, 1, 1]", "\n", "\n", "num_of_pixels", "=", "tf", ".", "reduce_sum", "(", "mask", ",", "axis", "=", "[", "1", ",", "2", "]", ")", "+", "0.00001", "## shape: [num_pos_rois]", "\n", "\n", "cross_loss_in_mask", "=", "tf", ".", "multiply", "(", "cross_loss", ",", "reshape_mask", ")", "## shape: [num_pos_rois, height, width, 6, 3]", "\n", "sum_loss_in_mask", "=", "tf", ".", "reduce_sum", "(", "cross_loss_in_mask", ",", "axis", "=", "[", "1", ",", "2", "]", ")", "## shape: [num_pos_rois, 6, 3]", "\n", "total_sum_loss_in_mask", "=", "tf", ".", "reduce_sum", "(", "sum_loss_in_mask", ",", "axis", "=", "-", "1", ")", "## shape: [num_pos_rois, 6]", "\n", "\n", "arg_min_rotation", "=", "tf", ".", "argmin", "(", "total_sum_loss_in_mask", ",", "axis", "=", "-", "1", ")", "##shape: [num_pos_rois]", "\n", "arg_min_rotation", "=", "tf", ".", "cast", "(", "arg_min_rotation", ",", "tf", ".", "int32", ")", "\n", "\n", "min_indices", "=", "tf", ".", "stack", "(", "[", "tf", ".", "range", "(", "tf", ".", "shape", "(", "arg_min_rotation", ")", "[", "0", "]", ")", ",", "arg_min_rotation", "]", ",", "axis", "=", "-", "1", ")", "\n", "min_loss_in_mask", "=", "tf", ".", "gather_nd", "(", "sum_loss_in_mask", ",", "min_indices", ")", "## shape: [num_pos_rois, 3]", "\n", "\n", "mean_loss_in_mask", "=", "tf", ".", "divide", "(", "min_loss_in_mask", ",", "tf", ".", "expand_dims", "(", "num_of_pixels", ",", "axis", "=", "1", ")", ")", "## shape: [num_pos_rois, 3]", "\n", "sym_loss", "=", "tf", ".", "reduce_mean", "(", "mean_loss_in_mask", ",", "axis", "=", "0", ")", "## shape:[3]", "\n", "return", "sym_loss", "\n", "\n", "", "def", "zero_positive_loss", "(", "target_masks", ",", "target_coords", ",", "pred_coords_trans", ",", "positive_ix", ")", ":", "\n", "        ", "return", "tf", ".", "constant", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ")", "\n", "\n", "\n", "", "loss", "=", "tf", ".", "cond", "(", "tf", ".", "size", "(", "positive_ix", ")", ">", "0", ",", "\n", "lambda", ":", "nonzero_positive_loss", "(", "target_masks", ",", "target_coords", ",", "pred_coords_trans", ",", "positive_ix", ")", ",", "\n", "lambda", ":", "zero_positive_loss", "(", "target_masks", ",", "target_coords", ",", "pred_coords_trans", ",", "positive_ix", ")", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_reg_loss_graph": [[2231, 2292], ["keras.reshape", "tensorflow.shape", "keras.reshape", "keras.reshape", "tensorflow.shape", "keras.reshape", "tensorflow.transpose", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather", "tensorflow.gather", "tensorflow.cast", "tensorflow.boolean_mask", "tensorflow.gather_nd", "tensorflow.boolean_mask", "keras.abs", "keras.switch", "tensorflow.where", "tensorflow.gather", "keras.mean", "tensorflow.constant", "tensorflow.size", "model.smooth_l1_diff", "tensorflow.tf.identity", "tensorflow.tf.square"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.smooth_l1_diff"], ["", "def", "mrcnn_coord_reg_loss_graph", "(", "target_masks", ",", "target_coord", ",", "target_class_ids", ",", "pred_coord", ",", "loss_fn", ")", ":", "\n", "    ", "\"\"\"Mask L1 loss for the coordinates head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_coord: [batch, num_rois, height, width]. Might be for x, y or z channel.\n        A float32 tensor of values in the range of [0, 1]. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_coord: [batch, proposals, height, width, num_classes] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "\n", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "target_coord", "=", "K", ".", "reshape", "(", "target_coord", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_coord", ")", "\n", "pred_coord", "=", "K", ".", "reshape", "(", "pred_coord", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ")", ")", "\n", "# Permute predicted masks to [N, num_classes, height, width]", "\n", "pred_coord", "=", "tf", ".", "transpose", "(", "pred_coord", ",", "[", "0", ",", "3", ",", "1", ",", "2", "]", ")", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the class specific mask of each ROI.", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "\n", "\n", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width]", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_coord", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "mask", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "mask", "=", "tf", ".", "cast", "(", "mask", ",", "dtype", "=", "tf", ".", "bool", ")", "\n", "\n", "#assert_op = tf.Assert(tf.greater(tf.reduce_max(tf.cast(mask, dtype=tf.float32)), 0.),", "\n", "#                      [tf.size(mask), tf.size(positive_ix), target_class_ids])", "\n", "\n", "#with tf.control_dependencies([assert_op]):", "\n", "\n", "y_true_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_true", ",", "mask", ")", "## shape: [num_pixels_in_masks_for_all_pos_rois]", "\n", "\n", "# y_mask = tf.gather(target_masks, positive_ix)", "\n", "# num_of_pixels = tf.reduce_sum(y_mask, axis=[1, 2]) + 0.00001", "\n", "# y_pred = tf.gather_nd(pred_coord, indices)", "\n", "# y_pred_in_mask = tf.multiply(y_mask, y_pred)", "\n", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_coord", ",", "indices", ")", "\n", "y_pred_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_pred", ",", "mask", ")", "\n", "\n", "# coord_loss = K.sum(K.abs(y_true_in_mask - y_pred_in_mask), axis=[1, 2])", "\n", "\n", "diff", "=", "K", ".", "abs", "(", "y_true_in_mask", "-", "y_pred_in_mask", ")", "\n", "loss", "=", "loss_fn", "(", "diff", ")", "\n", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "size", "(", "loss", ")", ">", "0", ",", "K", ".", "mean", "(", "loss", ")", ",", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_smooth_l1_loss_graph": [[2294, 2348], ["keras.reshape", "tensorflow.shape", "keras.reshape", "keras.reshape", "tensorflow.shape", "keras.reshape", "tensorflow.transpose", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather", "tensorflow.gather", "tensorflow.cast", "tensorflow.boolean_mask", "tensorflow.gather_nd", "tensorflow.boolean_mask", "keras.abs", "keras.cast", "tensorflow.where", "tensorflow.gather", "keras.less"], "function", ["None"], ["", "def", "mrcnn_coord_smooth_l1_loss_graph", "(", "target_masks", ",", "target_coord", ",", "target_class_ids", ",", "pred_coord", ")", ":", "\n", "    ", "\"\"\"Mask L1 loss for the coordinates head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_coord: [batch, num_rois, height, width]. Might be for x, y or z channel.\n        A float32 tensor of values in the range of [0, 1]. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_coord: [batch, proposals, height, width, num_classes] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "\n", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "target_coord", "=", "K", ".", "reshape", "(", "target_coord", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_coord", ")", "\n", "pred_coord", "=", "K", ".", "reshape", "(", "pred_coord", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ")", ")", "\n", "# Permute predicted masks to [N, num_classes, height, width]", "\n", "pred_coord", "=", "tf", ".", "transpose", "(", "pred_coord", ",", "[", "0", ",", "3", ",", "1", ",", "2", "]", ")", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the class specific mask of each ROI.", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width]", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_coord", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "mask", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "mask", "=", "tf", ".", "cast", "(", "mask", ",", "dtype", "=", "tf", ".", "bool", ")", "\n", "y_true_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_true", ",", "mask", ")", "## shape: [num_pos_rois, height, width]", "\n", "\n", "# y_mask = tf.gather(target_masks, positive_ix)", "\n", "# num_of_pixels = tf.reduce_sum(y_mask, axis=[1, 2]) + 0.00001", "\n", "# y_pred = tf.gather_nd(pred_coord, indices)", "\n", "# y_pred_in_mask = tf.multiply(y_mask, y_pred)", "\n", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_coord", ",", "indices", ")", "\n", "y_pred_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_pred", ",", "mask", ")", "\n", "\n", "# coord_loss = K.sum(K.abs(y_true_in_mask - y_pred_in_mask), axis=[1, 2])", "\n", "\n", "diff", "=", "K", ".", "abs", "(", "y_true_in_mask", "-", "y_pred_in_mask", ")", "\n", "threshold", "=", "0.1", "\n", "coefficient", "=", "1", "/", "(", "2", "*", "threshold", ")", "\n", "less_than_threshold", "=", "K", ".", "cast", "(", "K", ".", "less", "(", "diff", ",", "threshold", ")", ",", "\"float32\"", ")", "\n", "loss", "=", "(", "less_than_threshold", "*", "coefficient", "*", "diff", "**", "2", ")", "+", "(", "1", "-", "less_than_threshold", ")", "*", "(", "diff", "-", "threshold", "/", "2", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_l2_loss_graph": [[2349, 2399], ["keras.reshape", "tensorflow.shape", "keras.reshape", "keras.reshape", "tensorflow.shape", "tensorflow.shape", "keras.reshape", "tensorflow.transpose", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather", "tensorflow.gather", "tensorflow.gather_nd", "tensorflow.multiply", "keras.sum", "keras.switch", "keras.mean", "keras.reshape", "tensorflow.where", "tensorflow.gather", "tensorflow.reduce_sum", "keras.square", "tensorflow.constant", "tensorflow.size"], "function", ["None"], ["", "def", "mrcnn_coord_l2_loss_graph", "(", "target_masks", ",", "target_coord", ",", "target_class_ids", ",", "pred_coord", ")", ":", "\n", "    ", "\"\"\"Mask L2 loss for the coordinates head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_coord: [batch, num_rois, height, width]. Might be for x, y or z channel.\n        A float32 tensor of values in the range of [0, 1]. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_coord: [batch, proposals, height, width, num_classes] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "\n", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "target_coord", "=", "K", ".", "reshape", "(", "target_coord", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "coord_shape", "=", "tf", ".", "shape", "(", "target_coord", ")", "\n", "\n", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_coord", ")", "\n", "pred_coord", "=", "K", ".", "reshape", "(", "pred_coord", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ")", ")", "\n", "# Permute predicted masks to [N, num_classes, height, width]", "\n", "pred_coord", "=", "tf", ".", "transpose", "(", "pred_coord", ",", "[", "0", ",", "3", ",", "1", ",", "2", "]", ")", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the class specific mask of each ROI.", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width]", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_coord", ",", "positive_ix", ")", "\n", "y_mask", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "\n", "num_of_pixels", "=", "tf", ".", "reduce_sum", "(", "y_mask", ",", "axis", "=", "[", "1", ",", "2", "]", ")", "+", "0.00001", "\n", "#num_of_pixels = tf.Print(num_of_pixels, [num_of_pixels, tf.shape(num_of_pixels)], message='number_of_pixels_for_each_roi')", "\n", "\n", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_coord", ",", "indices", ")", "\n", "y_pred_in_mask", "=", "tf", ".", "multiply", "(", "y_mask", ",", "y_pred", ")", "\n", "\n", "coord_loss", "=", "K", ".", "sum", "(", "K", ".", "square", "(", "y_pred_in_mask", "-", "y_true", ")", ",", "axis", "=", "[", "1", ",", "2", "]", ")", "\n", "mean_loss", "=", "coord_loss", "/", "num_of_pixels", "\n", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "size", "(", "y_true", ")", ">", "0", ",", "mean_loss", ",", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "loss", "=", "K", ".", "mean", "(", "loss", ")", "\n", "loss", "=", "K", ".", "reshape", "(", "loss", ",", "[", "1", ",", "1", "]", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coords_l2_loss_graph": [[2401, 2454], ["keras.reshape", "tensorflow.shape", "keras.reshape", "keras.reshape", "tensorflow.shape", "keras.reshape", "tensorflow.transpose", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather", "tensorflow.gather", "tensorflow.cast", "tensorflow.boolean_mask", "tensorflow.gather_nd", "tensorflow.boolean_mask", "tensorflow.sqrt", "keras.mean", "keras.switch", "keras.reshape", "tensorflow.where", "tensorflow.gather", "tensorflow.reduce_sum", "tensorflow.constant", "tensorflow.square", "tensorflow.size"], "function", ["None"], ["", "def", "mrcnn_coords_l2_loss_graph", "(", "target_masks", ",", "target_coords", ",", "target_class_ids", ",", "pred_coords", ")", ":", "\n", "    ", "\"\"\"Mask L2 loss for the coordinates head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_coord: [batch, num_rois, height, width]. Might be for x, y or z channel.\n        A float32 tensor of values in the range of [0, 1]. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_coord: [batch, proposals, height, width, num_classes, 3] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "\n", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "target_coords", "=", "K", ".", "reshape", "(", "target_coords", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ",", "3", ")", ")", "\n", "\n", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_coords", ")", "\n", "pred_coords", "=", "K", ".", "reshape", "(", "pred_coords", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ",", "3", ")", ")", "\n", "# Permute predicted masks to [N, num_classes, height, width, 3]", "\n", "pred_coords", "=", "tf", ".", "transpose", "(", "pred_coords", ",", "[", "0", ",", "3", ",", "1", ",", "2", ",", "4", "]", ")", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the class specific mask of each ROI.", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width]", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_coords", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width, 3]", "\n", "mask", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "## shape: [num_pos_rois, height, width]", "\n", "mask", "=", "tf", ".", "cast", "(", "mask", ",", "dtype", "=", "tf", ".", "bool", ")", "\n", "y_true_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_true", ",", "mask", ")", "## shape: [num_pos_pixels, 3]", "\n", "\n", "# y_mask = tf.gather(target_masks, positive_ix)", "\n", "# num_of_pixels = tf.reduce_sum(y_mask, axis=[1, 2]) + 0.00001", "\n", "# y_pred = tf.gather_nd(pred_coord, indices)", "\n", "# y_pred_in_mask = tf.multiply(y_mask, y_pred)", "\n", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_coords", ",", "indices", ")", "\n", "y_pred_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_pred", ",", "mask", ")", "## shape: [num_pos_pixels, 3]", "\n", "\n", "coord_loss", "=", "tf", ".", "sqrt", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "y_pred_in_mask", "-", "y_true_in_mask", ")", ",", "axis", "=", "[", "1", "]", ")", ")", "\n", "\n", "loss", "=", "K", ".", "mean", "(", "coord_loss", ")", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "size", "(", "y_true_in_mask", ")", ">", "0", ",", "loss", ",", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "\n", "loss", "=", "K", ".", "reshape", "(", "loss", ",", "[", "1", ",", "1", "]", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_bins_loss_graph": [[2455, 2530], ["keras.reshape", "tensorflow.shape", "keras.reshape", "keras.reshape", "tensorflow.shape", "tensorflow.floor", "tensorflow.cast", "keras.flatten", "tensorflow.one_hot", "keras.reshape", "tensorflow.shape", "keras.reshape", "tensorflow.transpose", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather", "tensorflow.gather", "tensorflow.cast", "tensorflow.boolean_mask", "tensorflow.gather_nd", "tensorflow.boolean_mask", "keras.categorical_crossentropy", "keras.mean", "keras.switch", "keras.reshape", "tensorflow.shape", "tensorflow.where", "tensorflow.gather", "tensorflow.constant", "tensorflow.cast", "tensorflow.size"], "function", ["None"], ["", "def", "mrcnn_coord_bins_loss_graph", "(", "target_masks", ",", "target_coord", ",", "target_class_ids", ",", "pred_coord", ")", ":", "\n", "    ", "\"\"\"Mask L2 loss for the coordinates head.\n\n    target_masks: [batch, num_rois, height, width].\n        A float32 tensor of values 0 or 1. Uses zero padding to fill array.\n    target_coord: [batch, num_rois, height, width]. Might be for x, y or z channel.\n        A float32 tensor of values in the range of [0, 1]. Uses zero padding to fill array.\n    target_class_ids: [batch, num_rois]. Integer class IDs. Zero padded.\n    pred_coord: [batch, proposals, height, width, num_classes, num_bins] float32 tensor with values from 0 to 1.\n    \"\"\"", "\n", "\n", "# Reshape for simplicity. Merge first two dimensions into one.", "\n", "\n", "#num_bins = 32", "\n", "num_bins", "=", "tf", ".", "shape", "(", "pred_coord", ")", "[", "-", "1", "]", "\n", "\n", "\n", "target_class_ids", "=", "K", ".", "reshape", "(", "target_class_ids", ",", "(", "-", "1", ",", ")", ")", "\n", "mask_shape", "=", "tf", ".", "shape", "(", "target_masks", ")", "\n", "target_masks", "=", "K", ".", "reshape", "(", "target_masks", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "\n", "target_coord", "=", "K", ".", "reshape", "(", "target_coord", ",", "(", "-", "1", ",", "mask_shape", "[", "2", "]", ",", "mask_shape", "[", "3", "]", ")", ")", "\n", "coord_shape", "=", "tf", ".", "shape", "(", "target_coord", ")", "\n", "\n", "\n", "#target_coord_bins = target_coord*(num_bins-1)", "\n", "\n", "\n", "target_coord_bins", "=", "target_coord", "*", "tf", ".", "cast", "(", "num_bins", ",", "tf", ".", "float32", ")", "-", "0.000001", "\n", "target_coord_bins", "=", "tf", ".", "floor", "(", "target_coord_bins", ")", "\n", "target_coord_bins", "=", "tf", ".", "cast", "(", "target_coord_bins", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "target_coord_bins_flatten", "=", "K", ".", "flatten", "(", "target_coord_bins", ")", "\n", "\n", "target_coord_one_hot", "=", "tf", ".", "one_hot", "(", "target_coord_bins_flatten", ",", "num_bins", ")", "\n", "target_coord_one_hot", "=", "K", ".", "reshape", "(", "target_coord_one_hot", ",", "(", "coord_shape", "[", "0", "]", ",", "coord_shape", "[", "1", "]", ",", "coord_shape", "[", "2", "]", ",", "num_bins", ")", ")", "\n", "\n", "pred_shape", "=", "tf", ".", "shape", "(", "pred_coord", ")", "\n", "pred_coord", "=", "K", ".", "reshape", "(", "pred_coord", ",", "(", "-", "1", ",", "pred_shape", "[", "2", "]", ",", "pred_shape", "[", "3", "]", ",", "pred_shape", "[", "4", "]", ",", "pred_shape", "[", "5", "]", ")", ")", "\n", "# Permute predicted masks to [N, num_classes, height, width, bins]", "\n", "pred_coord", "=", "tf", ".", "transpose", "(", "pred_coord", ",", "[", "0", ",", "3", ",", "1", ",", "2", ",", "4", "]", ")", "\n", "#pred_coord = tf.Print(pred_coord, [tf.shape(pred_coord)[-1]], message='pred_coord')", "\n", "\n", "\n", "# Only positive ROIs contribute to the loss. And only", "\n", "# the class specific mask of each ROI.", "\n", "positive_ix", "=", "tf", ".", "where", "(", "target_class_ids", ">", "0", ")", "[", ":", ",", "0", "]", "\n", "positive_class_ids", "=", "tf", ".", "cast", "(", "tf", ".", "gather", "(", "target_class_ids", ",", "positive_ix", ")", ",", "tf", ".", "int64", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "positive_ix", ",", "positive_class_ids", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# Gather the coordinate maps and masks (predicted and true) that contribute to loss", "\n", "# true coord map:[N', height, width, bins]", "\n", "y_true", "=", "tf", ".", "gather", "(", "target_coord_one_hot", ",", "positive_ix", ")", "\n", "# masks: [N', height, width]", "\n", "mask", "=", "tf", ".", "gather", "(", "target_masks", ",", "positive_ix", ")", "\n", "mask", "=", "tf", ".", "cast", "(", "mask", ",", "dtype", "=", "tf", ".", "bool", ")", "\n", "y_true_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_true", ",", "mask", ")", "\n", "\n", "#y_true_in_mask = tf.Print(y_true_in_mask, [tf.shape(y_true_in_mask)], message='y_true_in_mask')", "\n", "\n", "# num_of_pixels = tf.reduce_sum(y_mask, axis=[1, 2])", "\n", "# num_of_pixels = tf.Print(num_of_pixels, [num_of_pixels, tf.shape(num_of_pixels)], message='number_of_pixels_for_each_roi')", "\n", "\n", "# predicted coord map:[N', height, width, bins]", "\n", "y_pred", "=", "tf", ".", "gather_nd", "(", "pred_coord", ",", "indices", ")", "\n", "y_pred_in_mask", "=", "tf", ".", "boolean_mask", "(", "y_pred", ",", "mask", ")", "\n", "\n", "#y_pred_in_mask = tf.Print(y_pred_in_mask, [tf.shape(y_pred_in_mask)], message='y_pred_in_mask')", "\n", "\n", "coord_loss_in_mask", "=", "K", ".", "categorical_crossentropy", "(", "y_true_in_mask", ",", "y_pred_in_mask", ")", "\n", "mean_loss", "=", "K", ".", "mean", "(", "coord_loss_in_mask", ")", "\n", "\n", "loss", "=", "K", ".", "switch", "(", "tf", ".", "size", "(", "y_true", ")", ">", "0", ",", "mean_loss", ",", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "# loss = K.mean(loss)", "\n", "loss", "=", "K", ".", "reshape", "(", "loss", ",", "[", "1", ",", "1", "]", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mrcnn_coord_delta_index": [[2532, 2555], ["tensorflow.shape", "tensorflow.reshape", "tensorflow.cast", "tensorflow.cast", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.range", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["", "def", "mrcnn_coord_delta_index", "(", "mrcnn_coord_delta", ",", "mrcnn_coord_bin", ")", ":", "\n", "    ", "\"\"\"\n        Might be for x, y or z channel.\n        mrcnn_coord_delta: [batch, proposals, height, width, num_classes, num_bins].\n        mrcnn_coord_bin: [batch, proposals, height, width, num_classes, 1].\n    \"\"\"", "\n", "\n", "shape", "=", "tf", ".", "shape", "(", "mrcnn_coord_delta", ")", "\n", "reshape_params", "=", "tf", ".", "reshape", "(", "mrcnn_coord_delta", ",", "[", "-", "1", ",", "tf", ".", "shape", "(", "mrcnn_coord_delta", ")", "[", "-", "1", "]", "]", ")", "\n", "\n", "reshape_indices", "=", "tf", ".", "cast", "(", "tf", ".", "reshape", "(", "mrcnn_coord_bin", ",", "[", "-", "1", "]", ")", ",", "tf", ".", "int64", ")", "\n", "\n", "nums", "=", "tf", ".", "cast", "(", "tf", ".", "range", "(", "tf", ".", "shape", "(", "reshape_params", ")", "[", "0", "]", ")", ",", "tf", ".", "int64", ")", "\n", "new_indice", "=", "tf", ".", "stack", "(", "[", "nums", ",", "reshape_indices", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# X, Y = tf.meshgrid(num_0, num_1)", "\n", "# new_indices = tf.stack([Y, X, indices], axis=2)", "\n", "\n", "\n", "output", "=", "tf", ".", "gather_nd", "(", "reshape_params", ",", "new_indice", ")", "\n", "output", "=", "tf", ".", "reshape", "(", "output", ",", "shape", "[", ":", "-", "1", "]", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.load_image_gt": [[2562, 2647], ["utils.resize_image", "utils.resize_mask", "utils.resize_mask", "utils.extract_bboxes", "numpy.hstack", "numpy.ones", "model.compose_image_meta", "dataset.load_augment_data", "dataset.load_image", "dataset.load_mask", "utils.minimize_mask", "utils.minimize_mask"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.resize_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.resize_mask", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.resize_mask", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.extract_bboxes", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.compose_image_meta", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.dataset.NOCSDataset.load_augment_data", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.load_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.load_mask", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.minimize_mask", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.minimize_mask"], ["", "def", "load_image_gt", "(", "dataset", ",", "config", ",", "image_id", ",", "augment", "=", "False", ",", "\n", "use_mini_mask", "=", "False", ",", "load_scale", "=", "False", ")", ":", "\n", "    ", "\"\"\"Load and return ground truth data for an image (image, mask, bounding boxes).\n\n    augment: If true, apply random image augmentation. Currently, only\n        horizontal flipping is offered.\n    use_mini_mask: If False, returns full-size masks that are the same height\n        and width as the original image. These can be big, for example\n        1024x1024x100 (for 100 instances). Mini masks are smaller, typically,\n        224x224 and are generated by extracting the bounding box of the\n        object and resizing it to MINI_MASK_SHAPE.\n\n    Returns:\n    image: [height, width, 3]\n    shape: the original shape of the image before resizing and cropping.\n    bbox: [instance_count, (y1, x1, y2, x2, class_id)]\n    mask: [height, width, instance_count]. The height and width are those\n        of the image unless use_mini_mask is True, in which case they are\n        defined in MINI_MASK_SHAPE.\n    \"\"\"", "\n", "# Load image and mask", "\n", "\n", "if", "config", ".", "TRAINING_AUGMENTATION", "and", "dataset", ".", "subset", "==", "'train'", ":", "\n", "        ", "image", ",", "mask", ",", "coord", ",", "class_ids", ",", "scales", ",", "domain_label", "=", "dataset", ".", "load_augment_data", "(", "image_id", ")", "\n", "", "else", ":", "\n", "        ", "image", "=", "dataset", ".", "load_image", "(", "image_id", ")", "\n", "mask", ",", "coord", ",", "class_ids", ",", "scales", ",", "domain_label", "=", "dataset", ".", "load_mask", "(", "image_id", ")", "\n", "\n", "#print('maximum mask: ', np.amax(mask))", "\n", "#print('maximum coord: ', np.amax(coord))", "\n", "", "shape", "=", "image", ".", "shape", "\n", "image", ",", "window", ",", "scale", ",", "padding", "=", "utils", ".", "resize_image", "(", "\n", "image", ",", "\n", "min_dim", "=", "config", ".", "IMAGE_MIN_DIM", ",", "\n", "max_dim", "=", "config", ".", "IMAGE_MAX_DIM", ",", "\n", "padding", "=", "config", ".", "IMAGE_PADDING", ")", "\n", "mask", "=", "utils", ".", "resize_mask", "(", "mask", ",", "scale", ",", "padding", ")", "\n", "coord", "=", "utils", ".", "resize_mask", "(", "coord", ",", "scale", ",", "padding", ")", "\n", "#print('maximum mask after resize: ', np.amax(mask))", "\n", "#print('maximum coord after resize: ', np.amax(coord))", "\n", "\n", "# Random horizontal flips.", "\n", "#if augment:", "\n", "#    if random.randint(0, 1):", "\n", "#        image = np.fliplr(image)", "\n", "#        mask = np.fliplr(mask)", "\n", "#        coord = np.fliplr(coord)", "\n", "\n", "# Bounding boxes. Note that some boxes might be all zeros", "\n", "# if the corresponding mask got cropped out.", "\n", "# bbox: [num_instances, (y1, x1, y2, x2)]", "\n", "bbox", "=", "utils", ".", "extract_bboxes", "(", "mask", ")", "\n", "\n", "# Add class_id as the last value in bbox", "\n", "bbox", "=", "np", ".", "hstack", "(", "(", "bbox", ",", "class_ids", "[", ":", ",", "np", ".", "newaxis", "]", ")", ")", "\n", "#print(class_ids)", "\n", "\n", "# Active classes", "\n", "# Different datasets have different classes, so track the", "\n", "# classes supported in the dataset of this image.", "\n", "#active_class_ids = np.zeros([dataset.num_classes], dtype=np.int32)", "\n", "#class_ids_2 = dataset.source_class_ids[dataset.image_info[image_id][\"source\"]]", "\n", "#print(class_ids_2)", "\n", "\n", "####assert set(class_ids) == set(class_ids_2)", "\n", "#active_class_ids[class_ids_2] = 1", "\n", "active_class_ids", "=", "np", ".", "ones", "(", "[", "dataset", ".", "num_classes", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "# Resize masks to smaller size to reduce memory usage", "\n", "if", "use_mini_mask", ":", "\n", "#print('\\n')", "\n", "#print(bbox)", "\n", "        ", "mask", "=", "utils", ".", "minimize_mask", "(", "bbox", ",", "mask", ",", "config", ".", "MINI_MASK_SHAPE", ")", "\n", "coord", "=", "utils", ".", "minimize_mask", "(", "bbox", ",", "coord", ",", "config", ".", "MINI_MASK_SHAPE", ")", "\n", "#print('maximum mask after mini mask: ', np.amax(mask))", "\n", "#print('maximum coord after mini mask: ', np.amax(coord))", "\n", "\n", "# Image meta data", "\n", "", "image_meta", "=", "compose_image_meta", "(", "image_id", ",", "shape", ",", "window", ",", "active_class_ids", ")", "\n", "\n", "\n", "if", "load_scale", ":", "\n", "        ", "return", "image", ",", "image_meta", ",", "bbox", ",", "mask", ",", "coord", ",", "domain_label", ",", "scales", "\n", "", "else", ":", "\n", "        ", "return", "image", ",", "image_meta", ",", "bbox", ",", "mask", ",", "coord", ",", "domain_label", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_detection_targets": [[2649, 2788], ["numpy.zeros", "range", "numpy.argmax", "int", "numpy.concatenate", "roi_gt_boxes[].astype", "numpy.zeros", "utils.box_refinement", "numpy.zeros", "numpy.where", "utils.compute_iou", "numpy.where", "numpy.where", "numpy.random.choice", "numpy.random.choice", "numpy.where", "[].astype", "numpy.random.choice", "numpy.concatenate", "numpy.random.choice", "numpy.concatenate", "numpy.zeros", "numpy.round().astype", "scipy.misc.imresize", "numpy.arange", "numpy.where", "m.astype", "numpy.round", "scipy.misc.imresize", "class_mask.astype"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.box_refinement", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_iou"], ["", "", "def", "build_detection_targets", "(", "rpn_rois", ",", "gt_boxes", ",", "gt_masks", ",", "config", ")", ":", "\n", "    ", "\"\"\"Generate targets for training Stage 2 classifier and mask heads.\n\n    Inputs:\n    rpn_rois: [N, (y1, x1, y2, x2)] proposal boxes.\n    gt_boxes: [instance count, (y1, x1, y2, x2, class_id)]\n    gt_masks: [height, width, instance count] Grund truth masks. Can be full\n              size or mini-masks.\n\n    Returns:\n    rois: [TRAIN_ROIS_PER_IMAGE, (y1, x1, y2, x2)]\n    class_ids: [TRAIN_ROIS_PER_IMAGE]. Int class IDs.\n    bboxes: [TRAIN_ROIS_PER_IMAGE, NUM_CLASSES, 5]. Rows are class-specific \n            bbox refinments [y, x, log(h), log(w), weight].\n    masks: [TRAIN_ROIS_PER_IMAGE, height, width, NUM_CLASSES). Class specific masks cropped\n           to bbox boundaries and resized to neural network output size.\n    \"\"\"", "\n", "assert", "rpn_rois", ".", "shape", "[", "0", "]", ">", "0", "\n", "assert", "gt_boxes", ".", "dtype", "==", "np", ".", "int32", ",", "\"Expected int but got {}\"", ".", "format", "(", "gt_boxes", ".", "dtype", ")", "\n", "assert", "gt_masks", ".", "dtype", "==", "np", ".", "bool_", ",", "\"Expected bool but got {}\"", ".", "format", "(", "gt_masks", ".", "dtype", ")", "\n", "\n", "# It's common to add GT Boxes to ROIs but we don't do that here because", "\n", "# according to XinLei Chen's paper, it doesn't help.", "\n", "\n", "# Trim empty padding in gt_boxes and gt_masks parts", "\n", "instance_ids", "=", "np", ".", "where", "(", "gt_boxes", "[", ":", ",", "4", "]", ">", "0", ")", "[", "0", "]", "\n", "assert", "instance_ids", ".", "shape", "[", "0", "]", ">", "0", ",", "\"Image must contain instances.\"", "\n", "gt_boxes", "=", "gt_boxes", "[", "instance_ids", "]", "\n", "gt_masks", "=", "gt_masks", "[", ":", ",", ":", ",", "instance_ids", "]", "\n", "\n", "# Compute areas of ROIs and ground truth boxes.", "\n", "rpn_roi_area", "=", "(", "rpn_rois", "[", ":", ",", "2", "]", "-", "rpn_rois", "[", ":", ",", "0", "]", ")", "*", "(", "rpn_rois", "[", ":", ",", "3", "]", "-", "rpn_rois", "[", ":", ",", "1", "]", ")", "\n", "gt_box_area", "=", "(", "gt_boxes", "[", ":", ",", "2", "]", "-", "gt_boxes", "[", ":", ",", "0", "]", ")", "*", "(", "gt_boxes", "[", ":", ",", "3", "]", "-", "gt_boxes", "[", ":", ",", "1", "]", ")", "\n", "\n", "# Compute overlaps [rpn_rois, gt_boxes]", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "rpn_rois", ".", "shape", "[", "0", "]", ",", "gt_boxes", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "overlaps", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "gt", "=", "gt_boxes", "[", "i", "]", "[", ":", "4", "]", "\n", "overlaps", "[", ":", ",", "i", "]", "=", "utils", ".", "compute_iou", "(", "gt", ",", "rpn_rois", ",", "gt_box_area", "[", "i", "]", ",", "rpn_roi_area", ")", "\n", "\n", "# Assign ROIs to GT boxes", "\n", "", "rpn_roi_iou_argmax", "=", "np", ".", "argmax", "(", "overlaps", ",", "axis", "=", "1", ")", "\n", "rpn_roi_iou_max", "=", "overlaps", "[", "np", ".", "arange", "(", "overlaps", ".", "shape", "[", "0", "]", ")", ",", "rpn_roi_iou_argmax", "]", "\n", "rpn_roi_gt_boxes", "=", "gt_boxes", "[", "rpn_roi_iou_argmax", "]", "# GT box assigned to each ROI", "\n", "\n", "# Positive ROIs are those with >= 0.5 IoU with a GT box. ", "\n", "fg_ids", "=", "np", ".", "where", "(", "rpn_roi_iou_max", ">", "0.5", ")", "[", "0", "]", "\n", "\n", "# Negative ROIs are those with max IoU 0.1-0.5 (hard example mining)", "\n", "# TODO: To hard example mine or not to hard example mine, that's the question", "\n", "#     bg_ids = np.where((rpn_roi_iou_max >= 0.1) & (rpn_roi_iou_max < 0.5))[0]", "\n", "bg_ids", "=", "np", ".", "where", "(", "rpn_roi_iou_max", "<", "0.5", ")", "[", "0", "]", "\n", "\n", "# Subsample ROIs. Aim for 33% foreground.", "\n", "# FG", "\n", "fg_roi_count", "=", "int", "(", "config", ".", "TRAIN_ROIS_PER_IMAGE", "*", "config", ".", "ROI_POSITIVE_RATIO", ")", "\n", "if", "fg_ids", ".", "shape", "[", "0", "]", ">", "fg_roi_count", ":", "\n", "        ", "keep_fg_ids", "=", "np", ".", "random", ".", "choice", "(", "fg_ids", ",", "fg_roi_count", ",", "replace", "=", "False", ")", "\n", "", "else", ":", "\n", "        ", "keep_fg_ids", "=", "fg_ids", "\n", "# BG", "\n", "", "remaining", "=", "config", ".", "TRAIN_ROIS_PER_IMAGE", "-", "keep_fg_ids", ".", "shape", "[", "0", "]", "\n", "if", "bg_ids", ".", "shape", "[", "0", "]", ">", "remaining", ":", "\n", "        ", "keep_bg_ids", "=", "np", ".", "random", ".", "choice", "(", "bg_ids", ",", "remaining", ",", "replace", "=", "False", ")", "\n", "", "else", ":", "\n", "        ", "keep_bg_ids", "=", "bg_ids", "\n", "# Combine indicies of ROIs to keep", "\n", "", "keep", "=", "np", ".", "concatenate", "(", "[", "keep_fg_ids", ",", "keep_bg_ids", "]", ")", "\n", "# Need more?", "\n", "remaining", "=", "config", ".", "TRAIN_ROIS_PER_IMAGE", "-", "keep", ".", "shape", "[", "0", "]", "\n", "if", "remaining", ">", "0", ":", "\n", "# Looks like we don't have enough samples to maintain the desired", "\n", "# balance. Reduce requirements and fill in the rest. This is", "\n", "# likely different from the Mask RCNN paper.", "\n", "\n", "# There is a small chance we have neither fg nor bg samples.", "\n", "        ", "if", "keep", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "# Pick bg regions with easier IoU threshold", "\n", "            ", "bg_ids", "=", "np", ".", "where", "(", "rpn_roi_iou_max", "<", "0.5", ")", "[", "0", "]", "\n", "assert", "bg_ids", ".", "shape", "[", "0", "]", ">=", "remaining", "\n", "keep_bg_ids", "=", "np", ".", "random", ".", "choice", "(", "bg_ids", ",", "remaining", ",", "replace", "=", "False", ")", "\n", "assert", "keep_bg_ids", ".", "shape", "[", "0", "]", "==", "remaining", "\n", "keep", "=", "np", ".", "concatenate", "(", "[", "keep", ",", "keep_bg_ids", "]", ")", "\n", "", "else", ":", "\n", "# Fill the rest with repeated bg rois.", "\n", "            ", "keep_extra_ids", "=", "np", ".", "random", ".", "choice", "(", "keep_bg_ids", ",", "remaining", ",", "replace", "=", "True", ")", "\n", "keep", "=", "np", ".", "concatenate", "(", "[", "keep", ",", "keep_extra_ids", "]", ")", "\n", "", "", "assert", "keep", ".", "shape", "[", "0", "]", "==", "config", ".", "TRAIN_ROIS_PER_IMAGE", ",", "\"keep doesn't match ROI batch size {}, {}\"", ".", "format", "(", "\n", "keep", ".", "shape", "[", "0", "]", ",", "config", ".", "TRAIN_ROIS_PER_IMAGE", ")", "\n", "\n", "# Reset the gt boxes assigned to BG ROIs.", "\n", "rpn_roi_gt_boxes", "[", "keep_bg_ids", ",", ":", "]", "=", "0", "\n", "\n", "# For each kept ROI, assign a class_id, and for FG ROIs also add bbox refinement.", "\n", "rois", "=", "rpn_rois", "[", "keep", ",", ":", "4", "]", "\n", "roi_gt_boxes", "=", "rpn_roi_gt_boxes", "[", "keep", "]", "\n", "class_ids", "=", "roi_gt_boxes", "[", ":", ",", "4", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "roi_gt_assignment", "=", "rpn_roi_iou_argmax", "[", "keep", "]", "\n", "\n", "# Class-aware bbox shifts. [y, x, log(h), log(w), weight]. Weight is 0 or 1 to", "\n", "# determine if a bbox is included in the loss.", "\n", "bboxes", "=", "np", ".", "zeros", "(", "(", "config", ".", "TRAIN_ROIS_PER_IMAGE", ",", "config", ".", "NUM_CLASSES", ",", "5", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "pos_ids", "=", "np", ".", "where", "(", "class_ids", ">", "0", ")", "[", "0", "]", "\n", "bboxes", "[", "pos_ids", ",", "class_ids", "[", "pos_ids", "]", ",", ":", "4", "]", "=", "utils", ".", "box_refinement", "(", "rois", "[", "pos_ids", "]", ",", "roi_gt_boxes", "[", "pos_ids", ",", ":", "4", "]", ")", "\n", "bboxes", "[", "pos_ids", ",", "class_ids", "[", "pos_ids", "]", ",", "4", "]", "=", "1", "# weight = 1 to influence the loss", "\n", "# Normalize bbox refinments", "\n", "bboxes", "[", ":", ",", ":", ",", ":", "4", "]", "/=", "config", ".", "BBOX_STD_DEV", "\n", "\n", "# Generate class-specific target masks.", "\n", "masks", "=", "np", ".", "zeros", "(", "(", "config", ".", "TRAIN_ROIS_PER_IMAGE", ",", "config", ".", "MASK_SHAPE", "[", "0", "]", ",", "config", ".", "MASK_SHAPE", "[", "1", "]", ",", "config", ".", "NUM_CLASSES", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "pos_ids", ":", "\n", "        ", "class_id", "=", "class_ids", "[", "i", "]", "\n", "assert", "class_id", ">", "0", ",", "\"class id must be greater than 0\"", "\n", "gt_id", "=", "roi_gt_assignment", "[", "i", "]", "\n", "class_mask", "=", "gt_masks", "[", ":", ",", ":", ",", "gt_id", "]", "\n", "\n", "if", "config", ".", "USE_MINI_MASK", ":", "\n", "# Create a mask placeholder, the size of the image", "\n", "            ", "placeholder", "=", "np", ".", "zeros", "(", "config", ".", "IMAGE_SHAPE", "[", ":", "2", "]", ",", "dtype", "=", "bool", ")", "\n", "# GT box", "\n", "gt_y1", ",", "gt_x1", ",", "gt_y2", ",", "gt_x2", "=", "gt_boxes", "[", "gt_id", "]", "[", ":", "4", "]", "\n", "gt_w", "=", "gt_x2", "-", "gt_x1", "\n", "gt_h", "=", "gt_y2", "-", "gt_y1", "\n", "# Resize mini mask to size of GT box", "\n", "placeholder", "[", "gt_y1", ":", "gt_y2", ",", "gt_x1", ":", "gt_x2", "]", "=", "np", ".", "round", "(", "scipy", ".", "misc", ".", "imresize", "(", "class_mask", ".", "astype", "(", "float", ")", ",", "(", "gt_h", ",", "gt_w", ")", ",", "\n", "interp", "=", "'nearest'", ")", "/", "255.0", ")", ".", "astype", "(", "bool", ")", "\n", "# Place the mini batch in the placeholder", "\n", "class_mask", "=", "placeholder", "\n", "\n", "# Pick part of the mask and resize it", "\n", "", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "rois", "[", "i", "]", "[", ":", "4", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "m", "=", "class_mask", "[", "y1", ":", "y2", ",", "x1", ":", "x2", "]", "\n", "mask", "=", "scipy", ".", "misc", ".", "imresize", "(", "m", ".", "astype", "(", "float", ")", ",", "config", ".", "MASK_SHAPE", ",", "interp", "=", "'nearest'", ")", "/", "255.0", "\n", "masks", "[", "i", ",", ":", ",", ":", ",", "class_id", "]", "=", "mask", "\n", "\n", "", "return", "rois", ",", "class_ids", ",", "bboxes", ",", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_rpn_targets": [[2790, 2886], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "numpy.argmax", "numpy.argmax", "zip", "utils.compute_iou", "numpy.where", "len", "numpy.random.choice", "numpy.where", "len", "numpy.random.choice", "numpy.where", "numpy.sum", "numpy.log", "numpy.log", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_iou", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log"], ["", "def", "build_rpn_targets", "(", "image_shape", ",", "anchors", ",", "gt_boxes", ",", "config", ")", ":", "\n", "    ", "\"\"\"Given the anchors and GT boxes, compute overlaps and identify positive\n    anchors and deltas to refine them to match their corresponding GT boxes.\n\n    anchors: [num_anchors, (y1, x1, y2, x2)]\n    gt_boxes: [num_gt_boxes, (y1, x1, y2, x2, class_id)]\n\n    Returns:\n    rpn_match: [N] (int32) matches between anchors and GT boxes.\n               1 = positive anchor, -1 = negative anchor, 0 = neutral\n    rpn_bbox: [N, (dy, dx, log(dh), log(dw))] Anchor bbox deltas.\n    \"\"\"", "\n", "# RPN Match: 1 = positive anchor, -1 = negative anchor, 0 = neutral", "\n", "rpn_match", "=", "np", ".", "zeros", "(", "[", "anchors", ".", "shape", "[", "0", "]", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "# RPN bounding boxes: [max anchors per image, (dy, dx, log(dh), log(dw))]", "\n", "rpn_bbox", "=", "np", ".", "zeros", "(", "(", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", ",", "4", ")", ")", "\n", "\n", "# Areas of anchors and GT boxes", "\n", "gt_box_area", "=", "(", "gt_boxes", "[", ":", ",", "2", "]", "-", "gt_boxes", "[", ":", ",", "0", "]", ")", "*", "(", "gt_boxes", "[", ":", ",", "3", "]", "-", "gt_boxes", "[", ":", ",", "1", "]", ")", "\n", "anchor_area", "=", "(", "anchors", "[", ":", ",", "2", "]", "-", "anchors", "[", ":", ",", "0", "]", ")", "*", "(", "anchors", "[", ":", ",", "3", "]", "-", "anchors", "[", ":", ",", "1", "]", ")", "\n", "\n", "# Compute overlaps [num_anchors, num_gt_boxes]", "\n", "# Each cell contains the IoU of an anchor and GT box.", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "anchors", ".", "shape", "[", "0", "]", ",", "gt_boxes", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "overlaps", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "gt", "=", "gt_boxes", "[", "i", "]", "[", ":", "4", "]", "\n", "overlaps", "[", ":", ",", "i", "]", "=", "utils", ".", "compute_iou", "(", "gt", ",", "anchors", ",", "gt_box_area", "[", "i", "]", ",", "anchor_area", ")", "\n", "\n", "# Match anchors to GT Boxes", "\n", "# If an anchor overlaps a GT box with IoU >= 0.7 then it's positive.", "\n", "# If an anchor overlaps a GT box with IoU < 0.3 then it's negative.", "\n", "# Neutral anchors are those that don't match the conditions above, ", "\n", "# and they don't influence the loss function.", "\n", "# However, don't keep any GT box unmatched (rare, but happens). Instead,", "\n", "# match it to the closest anchor (even if its max IoU is < 0.3).", "\n", "#", "\n", "# 1. Set negative anchors first. It gets overwritten if a gt box is matched to them.", "\n", "", "anchor_iou_argmax", "=", "np", ".", "argmax", "(", "overlaps", ",", "axis", "=", "1", ")", "\n", "anchor_iou_max", "=", "overlaps", "[", "np", ".", "arange", "(", "overlaps", ".", "shape", "[", "0", "]", ")", ",", "anchor_iou_argmax", "]", "\n", "rpn_match", "[", "anchor_iou_max", "<", "0.3", "]", "=", "-", "1", "\n", "# 2. Set an anchor for each GT box (regardless of IoU value).", "\n", "# TODO: If multiple anchors have the same IoU match all of them", "\n", "gt_iou_argmax", "=", "np", ".", "argmax", "(", "overlaps", ",", "axis", "=", "0", ")", "\n", "rpn_match", "[", "gt_iou_argmax", "]", "=", "1", "\n", "# 3. Set anchors with high overlap as positive.", "\n", "rpn_match", "[", "anchor_iou_max", ">=", "0.7", "]", "=", "1", "\n", "\n", "# Subsample to balance positive and negative anchors", "\n", "# Don't let positives be more than half the anchors", "\n", "ids", "=", "np", ".", "where", "(", "rpn_match", "==", "1", ")", "[", "0", "]", "\n", "extra", "=", "len", "(", "ids", ")", "-", "(", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", "//", "2", ")", "\n", "if", "extra", ">", "0", ":", "\n", "# Reset the extra ones to neutral", "\n", "        ", "ids", "=", "np", ".", "random", ".", "choice", "(", "ids", ",", "extra", ",", "replace", "=", "False", ")", "\n", "rpn_match", "[", "ids", "]", "=", "0", "\n", "# Same for negative proposals", "\n", "", "ids", "=", "np", ".", "where", "(", "rpn_match", "==", "-", "1", ")", "[", "0", "]", "\n", "extra", "=", "len", "(", "ids", ")", "-", "(", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", "-", "np", ".", "sum", "(", "rpn_match", "==", "1", ")", ")", "\n", "if", "extra", ">", "0", ":", "\n", "# Rest the extra ones to neutral", "\n", "        ", "ids", "=", "np", ".", "random", ".", "choice", "(", "ids", ",", "extra", ",", "replace", "=", "False", ")", "\n", "rpn_match", "[", "ids", "]", "=", "0", "\n", "\n", "# For positive anchors, compute shift and scale needed to transform them", "\n", "# to match the corresponding GT boxes.", "\n", "", "ids", "=", "np", ".", "where", "(", "rpn_match", "==", "1", ")", "[", "0", "]", "\n", "ix", "=", "0", "# index into rpn_bbox", "\n", "# TODO: use box_refinment() rather that duplicating the code here", "\n", "for", "i", ",", "a", "in", "zip", "(", "ids", ",", "anchors", "[", "ids", "]", ")", ":", "\n", "# Closest gt box (it might have IoU < 0.7)", "\n", "        ", "gt", "=", "gt_boxes", "[", "anchor_iou_argmax", "[", "i", "]", ",", ":", "4", "]", "\n", "\n", "# Convert coordinates to center plus width/height.", "\n", "# GT Box", "\n", "gt_h", "=", "gt", "[", "2", "]", "-", "gt", "[", "0", "]", "\n", "gt_w", "=", "gt", "[", "3", "]", "-", "gt", "[", "1", "]", "\n", "gt_center_y", "=", "gt", "[", "0", "]", "+", "0.5", "*", "gt_h", "\n", "gt_center_x", "=", "gt", "[", "1", "]", "+", "0.5", "*", "gt_w", "\n", "# Anchor", "\n", "a_h", "=", "a", "[", "2", "]", "-", "a", "[", "0", "]", "\n", "a_w", "=", "a", "[", "3", "]", "-", "a", "[", "1", "]", "\n", "a_center_y", "=", "a", "[", "0", "]", "+", "0.5", "*", "a_h", "\n", "a_center_x", "=", "a", "[", "1", "]", "+", "0.5", "*", "a_w", "\n", "\n", "# Compute the bbox refinement that the RPN should predict.", "\n", "rpn_bbox", "[", "ix", "]", "=", "[", "\n", "(", "gt_center_y", "-", "a_center_y", ")", "/", "a_h", ",", "\n", "(", "gt_center_x", "-", "a_center_x", ")", "/", "a_w", ",", "\n", "np", ".", "log", "(", "gt_h", "/", "a_h", ")", ",", "\n", "np", ".", "log", "(", "gt_w", "/", "a_w", ")", ",", "\n", "]", "\n", "# Normalize", "\n", "rpn_bbox", "[", "ix", "]", "/=", "config", ".", "RPN_BBOX_STD_DEV", "\n", "ix", "+=", "1", "\n", "\n", "", "return", "rpn_match", ",", "rpn_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.generate_random_rois": [[2888, 2955], ["numpy.zeros", "int", "range", "numpy.split", "numpy.split", "numpy.hstack", "max", "min", "max", "min", "numpy.split", "numpy.split", "numpy.hstack", "numpy.random.randint", "numpy.random.randint", "numpy.sort", "numpy.sort", "numpy.random.randint", "numpy.random.randint", "numpy.sort", "numpy.sort", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs"], "function", ["None"], ["", "def", "generate_random_rois", "(", "image_shape", ",", "count", ",", "gt_boxes", ")", ":", "\n", "    ", "\"\"\"Generates ROI proposals similar to what a region proposal network\n    would generate.\n\n    image_shape: [Height, Width, Depth]\n    count: Number of ROIs to generate\n    gt_boxes: [N, (y1, x1, y2, x2, class_id)] Ground trugh boxes in pixels.\n\n    Returns: [count, (y1, x1, y2, x2)] ROI boxes in pixels.\n    \"\"\"", "\n", "# placeholder", "\n", "rois", "=", "np", ".", "zeros", "(", "(", "count", ",", "4", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "# Generate random ROIs around GT boxes (90% of count)", "\n", "rois_per_box", "=", "int", "(", "0.9", "*", "count", "/", "gt_boxes", ".", "shape", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "gt_boxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "gt_y1", ",", "gt_x1", ",", "gt_y2", ",", "gt_x2", "=", "gt_boxes", "[", "i", ",", ":", "4", "]", "\n", "h", "=", "gt_y2", "-", "gt_y1", "\n", "w", "=", "gt_x2", "-", "gt_x1", "\n", "# random boundaries", "\n", "r_y1", "=", "max", "(", "gt_y1", "-", "h", ",", "0", ")", "\n", "r_y2", "=", "min", "(", "gt_y2", "+", "h", ",", "image_shape", "[", "0", "]", ")", "\n", "r_x1", "=", "max", "(", "gt_x1", "-", "w", ",", "0", ")", "\n", "r_x2", "=", "min", "(", "gt_x2", "+", "w", ",", "image_shape", "[", "1", "]", ")", "\n", "\n", "# To avoid generating boxes with zero area, we generate double what", "\n", "# we need and filter out the extra. If we get fewer valid boxes ", "\n", "# than we need, we loop and try again.", "\n", "while", "True", ":", "\n", "            ", "y1y2", "=", "np", ".", "random", ".", "randint", "(", "r_y1", ",", "r_y2", ",", "(", "rois_per_box", "*", "2", ",", "2", ")", ")", "\n", "x1x2", "=", "np", ".", "random", ".", "randint", "(", "r_x1", ",", "r_x2", ",", "(", "rois_per_box", "*", "2", ",", "2", ")", ")", "\n", "# Filter out zero area boxes", "\n", "threshold", "=", "1", "\n", "y1y2", "=", "y1y2", "[", "np", ".", "abs", "(", "y1y2", "[", ":", ",", "0", "]", "-", "y1y2", "[", ":", ",", "1", "]", ")", ">=", "threshold", "]", "[", ":", "rois_per_box", "]", "\n", "x1x2", "=", "x1x2", "[", "np", ".", "abs", "(", "x1x2", "[", ":", ",", "0", "]", "-", "x1x2", "[", ":", ",", "1", "]", ")", ">=", "threshold", "]", "[", ":", "rois_per_box", "]", "\n", "if", "y1y2", ".", "shape", "[", "0", "]", "==", "rois_per_box", "and", "x1x2", ".", "shape", "[", "0", "]", "==", "rois_per_box", ":", "\n", "                ", "break", "\n", "\n", "# Sort on axis 1 to ensure x1 <= x2 and y1 <= y2 and then reshape", "\n", "# into x1, y1, x2, y2 order", "\n", "", "", "x1", ",", "x2", "=", "np", ".", "split", "(", "np", ".", "sort", "(", "x1x2", ",", "axis", "=", "1", ")", ",", "2", ",", "axis", "=", "1", ")", "\n", "y1", ",", "y2", "=", "np", ".", "split", "(", "np", ".", "sort", "(", "y1y2", ",", "axis", "=", "1", ")", ",", "2", ",", "axis", "=", "1", ")", "\n", "box_rois", "=", "np", ".", "hstack", "(", "[", "y1", ",", "x1", ",", "y2", ",", "x2", "]", ")", "\n", "rois", "[", "rois_per_box", "*", "i", ":", "rois_per_box", "*", "(", "i", "+", "1", ")", "]", "=", "box_rois", "\n", "\n", "# Generate random ROIs anywhere in the image (10% of count)", "\n", "", "remaining_count", "=", "count", "-", "(", "rois_per_box", "*", "gt_boxes", ".", "shape", "[", "0", "]", ")", "\n", "# To avoid generating boxes with zero area, we generate double what", "\n", "# we need and filter out the extra. If we get fewer valid boxes ", "\n", "# than we need, we loop and try again.", "\n", "while", "True", ":", "\n", "        ", "y1y2", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "image_shape", "[", "0", "]", ",", "(", "remaining_count", "*", "2", ",", "2", ")", ")", "\n", "x1x2", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "image_shape", "[", "1", "]", ",", "(", "remaining_count", "*", "2", ",", "2", ")", ")", "\n", "# Filter out zero area boxes", "\n", "threshold", "=", "1", "\n", "y1y2", "=", "y1y2", "[", "np", ".", "abs", "(", "y1y2", "[", ":", ",", "0", "]", "-", "y1y2", "[", ":", ",", "1", "]", ")", ">=", "threshold", "]", "[", ":", "remaining_count", "]", "\n", "x1x2", "=", "x1x2", "[", "np", ".", "abs", "(", "x1x2", "[", ":", ",", "0", "]", "-", "x1x2", "[", ":", ",", "1", "]", ")", ">=", "threshold", "]", "[", ":", "remaining_count", "]", "\n", "if", "y1y2", ".", "shape", "[", "0", "]", "==", "remaining_count", "and", "x1x2", ".", "shape", "[", "0", "]", "==", "remaining_count", ":", "\n", "            ", "break", "\n", "\n", "# Sort on axis 1 to ensure x1 <= x2 and y1 <= y2 and then reshape", "\n", "# into x1, y1, x2, y2 order", "\n", "", "", "x1", ",", "x2", "=", "np", ".", "split", "(", "np", ".", "sort", "(", "x1x2", ",", "axis", "=", "1", ")", ",", "2", ",", "axis", "=", "1", ")", "\n", "y1", ",", "y2", "=", "np", ".", "split", "(", "np", ".", "sort", "(", "y1y2", ",", "axis", "=", "1", ")", ",", "2", ",", "axis", "=", "1", ")", "\n", "global_rois", "=", "np", ".", "hstack", "(", "[", "y1", ",", "x1", ",", "y2", ",", "x2", "]", ")", "\n", "rois", "[", "-", "remaining_count", ":", "]", "=", "global_rois", "\n", "return", "rois", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.data_generator": [[2957, 3169], ["dataset.source_image_ids.copy", "dataset.source_image_ids.copy.keys", "print", "numpy.array", "enumerate", "utils.generate_pyramid_anchors", "numpy.sum", "numpy.sum", "model.load_image_gt", "model.build_rpn_targets", "model.mold_image", "numpy.random.choice", "len", "numpy.random.shuffle", "numpy.sum", "model.generate_random_rois", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.random.choice", "image.astype", "logging.exception", "numpy.hstack", "model.build_detection_targets", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.arange", "inputs.extend", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "inputs.extend", "numpy.expand_dims", "outputs.extend", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.generate_pyramid_anchors", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.load_image_gt", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_rpn_targets", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mold_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.generate_random_rois", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.build_detection_targets"], ["", "def", "data_generator", "(", "dataset", ",", "config", ",", "shuffle", "=", "True", ",", "augment", "=", "False", ",", "random_rois", "=", "0", ",", "\n", "batch_size", "=", "1", ",", "detection_targets", "=", "False", ")", ":", "\n", "    ", "\"\"\"A generator that returns images and corresponding target class ids, \n    bounding box deltas, and masks.\n\n    dataset: The Dataset object to pick data from\n    config: The model config object\n    shuffle: If True, shuffles the samples before every epoch\n    augment: If True, applies image augmentation to images (currently only \n             horizontal flips are supported)\n    random_rois: If > 0 then generate proposals to be used to train the\n                 network classifier and mask heads. Useful if training\n                 the Mask RCNN part without the RPN.\n    batch_size: How many images to return in each call\n    detection_targets: If True, generate detection targets (class IDs, bbox\n        deltas, and masks). Typically for debugging or visualizations because\n        in trainig detection targets are generated by DetectionTargetLayer.\n\n    Returns a Python generator. Upon calling next() on it, the \n    generator returns two lists, inputs and outputs. The containtes\n    of the lists differs depending on the received arguments:\n    inputs list:\n    - images: [batch, H, W, C]\n    - image_meta: [batch, size of image meta]\n    - rpn_match: [batch, N] Integer (1=positive anchor, -1=negative, 0=neutral)\n    - rpn_bbox: [batch, N, (dy, dx, log(dh), log(dw))] Anchor bbox deltas.\n    - gt_boxes: [batch, MAX_GT_INSTANCES, (y1, x1, y2, x2, class_id)]\n    - gt_masks: [batch, height, width, MAX_GT_INSTANCES]. The height and width\n                are those of the image unless use_mini_mask is True, in which\n                case they are defined in MINI_MASK_SHAPE.\n    - gt_coords: [batch, height, width, MAX_GT_INSTANCES, 3]. The height and width\n                are those of the image unless use_mini_mask is True, in which\n                case they are defined in MINI_MASK_SHAPE.\n\n    outputs list: Usually empty in regular training. But if detection_targets\n        is True then the outputs list contains target class_ids, bbox deltas,\n        and masks.\n    \"\"\"", "\n", "\n", "\n", "b", "=", "0", "# batch item index", "\n", "#image_index = -1", "\n", "#image_ids = np.copy(dataset.image_ids)", "\n", "\n", "\n", "source_image_ids", "=", "dataset", ".", "source_image_ids", ".", "copy", "(", ")", "\n", "sources", "=", "source_image_ids", ".", "keys", "(", ")", "\n", "print", "(", "sources", ")", "\n", "\n", "# ShapeNetTOI, Real, coco", "\n", "source_names", "=", "[", "'CAMERA'", ",", "'Real'", ",", "'coco'", "]", "\n", "weight", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "weight_consts", "=", "config", ".", "SOURCE_WEIGHT", "#[3, 1, 1]", "\n", "weight_sum", "=", "0.0", "\n", "\n", "for", "i", ",", "source_name", "in", "enumerate", "(", "source_names", ")", ":", "\n", "        ", "if", "source_name", "in", "sources", ":", "\n", "            ", "weight", "[", "i", "]", "=", "weight_consts", "[", "i", "]", "\n", "weight_sum", "+=", "weight_consts", "[", "i", "]", "\n", "\n", "", "", "weight", "=", "weight", "/", "weight_sum", "\n", "assert", "np", ".", "sum", "(", "weight", ")", "==", "1", ",", "\"[ Error ]: total sum of weights is {} != 1\"", ".", "format", "(", "np", ".", "sum", "(", "weight", ")", ")", "\n", "\n", "source_image_index", "=", "{", "}", "\n", "for", "source_name", "in", "sources", ":", "\n", "        ", "source_image_index", "[", "source_name", "]", "=", "-", "1", "\n", "\n", "\n", "", "error_count", "=", "0", "\n", "\n", "# Anchors", "\n", "# [anchor_count, (y1, x1, y2, x2)]", "\n", "anchors", "=", "utils", ".", "generate_pyramid_anchors", "(", "config", ".", "RPN_ANCHOR_SCALES", ",", "\n", "config", ".", "RPN_ANCHOR_RATIOS", ",", "\n", "config", ".", "BACKBONE_SHAPES", ",", "\n", "config", ".", "BACKBONE_STRIDES", ",", "\n", "config", ".", "RPN_ANCHOR_STRIDE", ")", "\n", "\n", "\n", "# Keras requires a generator to run indefinately.", "\n", "while", "True", ":", "\n", "        ", "try", ":", "\n", "# draw a random number from 0, 1, 2 according to weight", "\n", "            ", "source_ind", "=", "np", ".", "random", ".", "choice", "(", "[", "0", ",", "1", ",", "2", "]", ",", "1", ",", "p", "=", "weight", ")", "[", "0", "]", "\n", "draw_source_name", "=", "source_names", "[", "source_ind", "]", "\n", "#print('draw_source_name: ', draw_source_name)", "\n", "\n", "# the image_ids list for the drawn source ", "\n", "draw_source_ids", "=", "source_image_ids", "[", "draw_source_name", "]", "\n", "\n", "# Increment index to pick next image.", "\n", "source_image_index", "[", "draw_source_name", "]", "=", "(", "source_image_index", "[", "draw_source_name", "]", "+", "1", ")", "%", "len", "(", "draw_source_ids", ")", "\n", "image_id_in_draw_source", "=", "source_image_index", "[", "draw_source_name", "]", "\n", "\n", "## shuffle if at the start of an epoch.", "\n", "if", "shuffle", "and", "image_id_in_draw_source", "==", "0", ":", "\n", "                ", "np", ".", "random", ".", "shuffle", "(", "source_image_ids", "[", "draw_source_name", "]", ")", "\n", "\n", "# image_index = (image_index + 1) % len(image_ids)", "\n", "# ## shuffle if at the start of an epoch.", "\n", "# if shuffle and image_index == 0:", "\n", "#     np.random.shuffle(image_ids)", "\n", "\n", "# Get GT bounding boxes and masks for image.", "\n", "# image_id = image_ids[image_index]", "\n", "\n", "", "image_id", "=", "source_image_ids", "[", "draw_source_name", "]", "[", "image_id_in_draw_source", "]", "\n", "#print('image_id_in_draw_source: ', image_id_in_draw_source)", "\n", "#print('image_id: ', image_id)", "\n", "\n", "image", ",", "image_meta", ",", "gt_boxes", ",", "gt_masks", ",", "gt_coords", ",", "gt_domain_label", "=", "load_image_gt", "(", "dataset", ",", "config", ",", "image_id", ",", "augment", "=", "augment", ",", "use_mini_mask", "=", "config", ".", "USE_MINI_MASK", ")", "\n", "\n", "# Skip images that have no instances. This can happen in cases ", "\n", "# where we train on a subset of classes and the image doesn't", "\n", "# have any of the classes we care about.", "\n", "if", "np", ".", "sum", "(", "gt_boxes", ")", "<=", "0", ":", "\n", "                ", "continue", "\n", "\n", "# RPN Targets", "\n", "", "rpn_match", ",", "rpn_bbox", "=", "build_rpn_targets", "(", "image", ".", "shape", ",", "anchors", ",", "gt_boxes", ",", "config", ")", "\n", "\n", "# Mask R-CNN Targets", "\n", "if", "random_rois", ":", "\n", "                ", "rpn_rois", "=", "generate_random_rois", "(", "image", ".", "shape", ",", "random_rois", ",", "gt_boxes", ")", "\n", "# TODO: mrcnn_coord for detection_targets = True", "\n", "if", "detection_targets", ":", "\n", "# Append two columns of zeros. TODO: needed?", "\n", "                    ", "rpn_rois", "=", "np", ".", "hstack", "(", "[", "rpn_rois", ",", "np", ".", "zeros", "(", "[", "rpn_rois", ".", "shape", "[", "0", "]", ",", "2", "]", ",", "dtype", "=", "np", ".", "int32", ")", "]", ")", "\n", "rois", ",", "mrcnn_class_ids", ",", "mrcnn_bbox", ",", "mrcnn_mask", "=", "build_detection_targets", "(", "rpn_rois", ",", "gt_boxes", ",", "gt_masks", ",", "config", ")", "\n", "\n", "# Init batch arrays", "\n", "", "", "if", "b", "==", "0", ":", "\n", "                ", "batch_image_meta", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "image_meta", ".", "shape", ",", "dtype", "=", "image_meta", ".", "dtype", ")", "\n", "batch_rpn_match", "=", "np", ".", "zeros", "(", "[", "batch_size", ",", "anchors", ".", "shape", "[", "0", "]", ",", "1", "]", ",", "dtype", "=", "rpn_match", ".", "dtype", ")", "\n", "batch_rpn_bbox", "=", "np", ".", "zeros", "(", "[", "batch_size", ",", "config", ".", "RPN_TRAIN_ANCHORS_PER_IMAGE", ",", "4", "]", ",", "dtype", "=", "rpn_bbox", ".", "dtype", ")", "\n", "batch_images", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "image", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "batch_gt_boxes", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "config", ".", "MAX_GT_INSTANCES", ",", "5", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "batch_gt_domain_labels", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "1", ")", ",", "dtype", "=", "np", ".", "bool_", ")", "\n", "\n", "\n", "if", "config", ".", "USE_MINI_MASK", ":", "\n", "                    ", "batch_gt_masks", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "config", ".", "MINI_MASK_SHAPE", "[", "0", "]", ",", "config", ".", "MINI_MASK_SHAPE", "[", "1", "]", ",", "\n", "config", ".", "MAX_GT_INSTANCES", ")", ")", "\n", "batch_gt_coords", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "config", ".", "MINI_MASK_SHAPE", "[", "0", "]", ",", "config", ".", "MINI_MASK_SHAPE", "[", "1", "]", ",", "\n", "config", ".", "MAX_GT_INSTANCES", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "batch_gt_masks", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "image", ".", "shape", "[", "0", "]", ",", "image", ".", "shape", "[", "1", "]", ",", "config", ".", "MAX_GT_INSTANCES", ")", ")", "\n", "batch_gt_coords", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "image", ".", "shape", "[", "0", "]", ",", "image", ".", "shape", "[", "1", "]", ",", "config", ".", "MAX_GT_INSTANCES", ",", "3", ")", ")", "\n", "\n", "", "if", "random_rois", ":", "\n", "                    ", "batch_rpn_rois", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "rpn_rois", ".", "shape", "[", "0", "]", ",", "4", ")", ",", "dtype", "=", "rpn_rois", ".", "dtype", ")", "\n", "if", "detection_targets", ":", "\n", "                        ", "batch_rois", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "rois", ".", "shape", ",", "dtype", "=", "rois", ".", "dtype", ")", "\n", "batch_mrcnn_class_ids", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "mrcnn_class_ids", ".", "shape", ",", "dtype", "=", "mrcnn_class_ids", ".", "dtype", ")", "\n", "batch_mrcnn_bbox", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "mrcnn_bbox", ".", "shape", ",", "dtype", "=", "mrcnn_bbox", ".", "dtype", ")", "\n", "batch_mrcnn_mask", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "mrcnn_mask", ".", "shape", ",", "dtype", "=", "mrcnn_mask", ".", "dtype", ")", "\n", "\n", "# If more instances than fits in the array, sub-sample from them.", "\n", "", "", "", "if", "gt_boxes", ".", "shape", "[", "0", "]", ">", "config", ".", "MAX_GT_INSTANCES", ":", "\n", "                ", "ids", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "gt_boxes", ".", "shape", "[", "0", "]", ")", ",", "config", ".", "MAX_GT_INSTANCES", ",", "replace", "=", "False", ")", "\n", "gt_boxes", "=", "gt_boxes", "[", "ids", "]", "\n", "gt_masks", "=", "gt_masks", "[", ":", ",", ":", ",", "ids", "]", "\n", "gt_coords", "=", "gt_coords", "[", ":", ",", ":", ",", "ids", ",", ":", "]", "\n", "\n", "# Add to batch", "\n", "", "batch_image_meta", "[", "b", "]", "=", "image_meta", "\n", "batch_rpn_match", "[", "b", "]", "=", "rpn_match", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "batch_rpn_bbox", "[", "b", "]", "=", "rpn_bbox", "\n", "batch_images", "[", "b", "]", "=", "mold_image", "(", "image", ".", "astype", "(", "np", ".", "float32", ")", ",", "config", ")", "\n", "batch_gt_boxes", "[", "b", ",", ":", "gt_boxes", ".", "shape", "[", "0", "]", "]", "=", "gt_boxes", "\n", "batch_gt_masks", "[", "b", ",", ":", ",", ":", ",", ":", "gt_masks", ".", "shape", "[", "-", "1", "]", "]", "=", "gt_masks", "\n", "batch_gt_coords", "[", "b", ",", ":", ",", ":", ",", ":", "gt_coords", ".", "shape", "[", "-", "2", "]", ",", ":", "]", "=", "gt_coords", "\n", "batch_gt_domain_labels", "[", "b", "]", "=", "gt_domain_label", "\n", "\n", "if", "random_rois", ":", "\n", "                ", "batch_rpn_rois", "[", "b", "]", "=", "rpn_rois", "[", ":", ",", ":", "4", "]", "\n", "if", "detection_targets", ":", "\n", "                    ", "batch_rois", "[", "b", "]", "=", "rois", "\n", "batch_mrcnn_class_ids", "[", "b", "]", "=", "mrcnn_class_ids", "\n", "batch_mrcnn_bbox", "[", "b", "]", "=", "mrcnn_bbox", "\n", "batch_mrcnn_mask", "[", "b", "]", "=", "mrcnn_mask", "\n", "", "", "b", "+=", "1", "\n", "\n", "# Batch full?", "\n", "if", "b", ">=", "batch_size", ":", "\n", "                ", "inputs", "=", "[", "batch_images", ",", "batch_image_meta", ",", "batch_rpn_match", ",", "batch_rpn_bbox", ",", "\n", "batch_gt_boxes", ",", "batch_gt_masks", ",", "batch_gt_coords", ",", "batch_gt_domain_labels", "]", "\n", "outputs", "=", "[", "]", "\n", "\n", "if", "random_rois", ":", "\n", "                    ", "inputs", ".", "extend", "(", "[", "batch_rpn_rois", "]", ")", "\n", "if", "detection_targets", ":", "\n", "                        ", "inputs", ".", "extend", "(", "[", "batch_rois", "]", ")", "\n", "# Keras requires that output and targets have the same number of dimensions", "\n", "batch_mrcnn_class_ids", "=", "np", ".", "expand_dims", "(", "batch_mrcnn_class_ids", ",", "-", "1", ")", "\n", "outputs", ".", "extend", "(", "[", "batch_mrcnn_class_ids", ",", "batch_mrcnn_bbox", ",", "batch_mrcnn_mask", "]", ")", "\n", "\n", "", "", "yield", "inputs", ",", "outputs", "\n", "\n", "# start a new batch", "\n", "b", "=", "0", "\n", "", "", "except", "(", "GeneratorExit", ",", "KeyboardInterrupt", ")", ":", "\n", "            ", "raise", "\n", "", "except", ":", "\n", "# Log it and skip the image", "\n", "            ", "logging", ".", "exception", "(", "\"Error processing image {}\"", ".", "format", "(", "dataset", ".", "image_info", "[", "draw_source_ids", "]", ")", ")", "\n", "error_count", "+=", "1", "\n", "if", "error_count", ">", "5", ":", "\n", "                ", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.compose_image_meta": [[4506, 4525], ["numpy.array", "list", "list", "list"], "function", ["None"], ["", "", "def", "compose_image_meta", "(", "image_id", ",", "image_shape", ",", "window", ",", "active_class_ids", ")", ":", "\n", "    ", "\"\"\"Takes attributes of an image and puts them in one 1D array. Use\n    parse_image_meta() to parse the values back.\n    \n    image_id: An int ID of the image. Useful for debugging.\n    image_shape: [height, width, channels]\n    window: (y1, x1, y2, x2) in pixels. The area of the image where the real\n            image is (excluding the padding)\n    active_class_ids: List of class_ids available in the dataset from which\n        the image came. Useful if training on images from multiple datasets\n        where not all classes are present in all datasets.\n    \"\"\"", "\n", "meta", "=", "np", ".", "array", "(", "\n", "[", "image_id", "]", "+", "# size=1", "\n", "list", "(", "image_shape", ")", "+", "# size=3", "\n", "list", "(", "window", ")", "+", "# size=4 (y1, x1, y2, x2) in image cooredinates", "\n", "list", "(", "active_class_ids", ")", "# size=num_classes", "\n", ")", "\n", "return", "meta", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.parse_image_meta": [[4528, 4537], ["None"], "function", ["None"], ["", "def", "parse_image_meta", "(", "meta", ")", ":", "\n", "    ", "\"\"\"Parses an image info Numpy array to its components.\n    See compose_image_meta() for more details.\n    \"\"\"", "\n", "image_id", "=", "meta", "[", ":", ",", "0", "]", "\n", "image_shape", "=", "meta", "[", ":", ",", "1", ":", "4", "]", "\n", "window", "=", "meta", "[", ":", ",", "4", ":", "8", "]", "# (y1, x1, y2, x2) window of image in in pixels", "\n", "active_class_ids", "=", "meta", "[", ":", ",", "8", ":", "]", "\n", "return", "image_id", ",", "image_shape", ",", "window", ",", "active_class_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.parse_image_meta_graph": [[4539, 4550], ["None"], "function", ["None"], ["", "def", "parse_image_meta_graph", "(", "meta", ")", ":", "\n", "    ", "\"\"\"Parses a tensor that contains image attributes to its components.\n    See compose_image_meta() for more details.\n\n    meta: [batch, meta length] where meta length depends on NUM_CLASSES\n    \"\"\"", "\n", "image_id", "=", "meta", "[", ":", ",", "0", "]", "\n", "image_shape", "=", "meta", "[", ":", ",", "1", ":", "4", "]", "\n", "window", "=", "meta", "[", ":", ",", "4", ":", "8", "]", "\n", "active_class_ids", "=", "meta", "[", ":", ",", "8", ":", "]", "\n", "return", "[", "image_id", ",", "image_shape", ",", "window", ",", "active_class_ids", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.mold_image": [[4552, 4559], ["images.astype"], "function", ["None"], ["", "def", "mold_image", "(", "images", ",", "config", ")", ":", "\n", "    ", "\"\"\"\n    Takes RGB images with 0-255 values and subtraces\n    the mean pixel and converts it to float. Expects image\n    colors in RGB order.\n    \"\"\"", "\n", "return", "images", ".", "astype", "(", "np", ".", "float32", ")", "-", "config", ".", "MEAN_PIXEL", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.unmold_image": [[4561, 4564], ["None"], "function", ["None"], ["", "def", "unmold_image", "(", "normalized_images", ",", "config", ")", ":", "\n", "    ", "\"\"\"Takes a image normalized with mold() and returns the original.\"\"\"", "\n", "return", "(", "normalized_images", "+", "config", ".", "MEAN_PIXEL", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.trim_zeros_graph": [[4570, 4580], ["tensorflow.boolean_mask", "tensorflow.cast", "tensorflow.reduce_sum", "tensorflow.abs"], "function", ["None"], ["", "def", "trim_zeros_graph", "(", "boxes", ")", ":", "\n", "    ", "\"\"\"Often boxes are represented with matricies of shape [N, 4] and\n    are padded with zeros. This removes zero boxes.\n\n    boxes: [N, 4] matrix of boxes.\n\n    TODO: use this function to reduce code duplication\n    \"\"\"", "\n", "area", "=", "tf", ".", "boolean_mask", "(", "boxes", ",", "tf", ".", "cast", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "abs", "(", "boxes", ")", ",", "axis", "=", "1", ")", ",", "\n", "tf", ".", "bool", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.batch_pack_graph": [[4582, 4590], ["range", "tensorflow.concat", "outputs.append"], "function", ["None"], ["", "def", "batch_pack_graph", "(", "x", ",", "counts", ",", "num_rows", ")", ":", "\n", "    ", "\"\"\"Picks different number of values from each row\n    in x depending on the values in counts.\n    \"\"\"", "\n", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_rows", ")", ":", "\n", "        ", "outputs", ".", "append", "(", "x", "[", "i", ",", ":", "counts", "[", "i", "]", "]", ")", "\n", "", "return", "tf", ".", "concat", "(", "outputs", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.__init__": [[902, 908], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "class_map", "=", "None", ")", ":", "\n", "        ", "self", ".", "_image_ids", "=", "[", "]", "\n", "self", ".", "image_info", "=", "[", "]", "\n", "# Background is always the first class", "\n", "self", ".", "class_info", "=", "[", "{", "\"source\"", ":", "\"\"", ",", "\"id\"", ":", "0", ",", "\"name\"", ":", "\"BG\"", "}", "]", "\n", "self", ".", "source_class_ids", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.add_class": [[909, 921], ["utils.Dataset.class_info.append"], "methods", ["None"], ["", "def", "add_class", "(", "self", ",", "source", ",", "class_id", ",", "class_name", ")", ":", "\n", "        ", "assert", "\".\"", "not", "in", "source", ",", "\"Source name cannot contain a dot\"", "\n", "# Does the class exist already?", "\n", "for", "info", "in", "self", ".", "class_info", ":", "\n", "            ", "if", "info", "[", "'source'", "]", "==", "source", "and", "info", "[", "\"id\"", "]", "==", "class_id", ":", "\n", "# source.class_id combination already available, skip", "\n", "                ", "return", "\n", "# Add the class", "\n", "", "", "self", ".", "class_info", ".", "append", "(", "{", "\n", "\"source\"", ":", "source", ",", "\n", "\"id\"", ":", "class_id", ",", "\n", "\"name\"", ":", "class_name", ",", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.add_image": [[923, 931], ["image_info.update", "utils.Dataset.image_info.append"], "methods", ["None"], ["", "def", "add_image", "(", "self", ",", "source", ",", "image_id", ",", "path", ",", "**", "kwargs", ")", ":", "\n", "        ", "image_info", "=", "{", "\n", "\"id\"", ":", "image_id", ",", "\n", "\"source\"", ":", "source", ",", "\n", "\"path\"", ":", "path", ",", "\n", "}", "\n", "image_info", ".", "update", "(", "kwargs", ")", "\n", "self", ".", "image_info", ".", "append", "(", "image_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.image_reference": [[932, 939], ["None"], "methods", ["None"], ["", "def", "image_reference", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Return a link to the image in its source Website or details about\n        the image that help looking it up or debugging it.\n        Override for your dataset, but pass to this function\n        if you encounter images not in your dataset.\n        \"\"\"", "\n", "return", "\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.prepare": [[940, 1003], ["len", "numpy.arange", "list", "print", "print", "print", "set", "utils.Dataset.class_names.index", "utils.Dataset.class_ids.append", "utils.Dataset.class_names.append", "zip", "name.split"], "methods", ["None"], ["", "def", "prepare", "(", "self", ",", "class_map", "=", "None", ")", ":", "\n", "        ", "\"\"\"Prepares the Dataset class for use.d\n        \"\"\"", "\n", "def", "clean_name", "(", "name", ")", ":", "\n", "            ", "\"\"\"Returns a shorter version of object names for cleaner display.\"\"\"", "\n", "return", "\",\"", ".", "join", "(", "name", ".", "split", "(", "\",\"", ")", "[", ":", "1", "]", ")", "\n", "\n", "# Build (or rebuild) everything else from the info dicts.", "\n", "#self.num_classes = len(self.class_info)", "\n", "", "self", ".", "num_classes", "=", "0", "\n", "\n", "#self.class_ids = np.arange(self.num_classes)", "\n", "self", ".", "class_ids", "=", "[", "]", "\n", "\n", "#self.class_names = [clean_name(c[\"name\"]) for c in self.class_info]", "\n", "self", ".", "class_names", "=", "[", "]", "\n", "\n", "\n", "#self.class_from_source_map = {\"{}.{}\".format(info['source'], info['id']): id", "\n", "#                              for info, id in zip(self.class_info, self.class_ids)}", "\n", "self", ".", "class_from_source_map", "=", "{", "}", "\n", "\n", "for", "cls_info", "in", "self", ".", "class_info", ":", "\n", "            ", "source", "=", "cls_info", "[", "\"source\"", "]", "\n", "if", "source", "==", "'coco'", ":", "\n", "                ", "map_key", "=", "\"{}.{}\"", ".", "format", "(", "cls_info", "[", "'source'", "]", ",", "cls_info", "[", "'id'", "]", ")", "\n", "self", ".", "class_from_source_map", "[", "map_key", "]", "=", "self", ".", "class_names", ".", "index", "(", "class_map", "[", "cls_info", "[", "\"name\"", "]", "]", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "class_ids", ".", "append", "(", "self", ".", "num_classes", ")", "\n", "self", ".", "num_classes", "+=", "1", "\n", "self", ".", "class_names", ".", "append", "(", "cls_info", "[", "\"name\"", "]", ")", "\n", "\n", "map_key", "=", "\"{}.{}\"", ".", "format", "(", "cls_info", "[", "'source'", "]", ",", "cls_info", "[", "'id'", "]", ")", "\n", "self", ".", "class_from_source_map", "[", "map_key", "]", "=", "self", ".", "class_ids", "[", "-", "1", "]", "\n", "\n", "\n", "", "", "self", ".", "num_images", "=", "len", "(", "self", ".", "image_info", ")", "\n", "self", ".", "_image_ids", "=", "np", ".", "arange", "(", "self", ".", "num_images", ")", "\n", "\n", "\n", "# Mapping from source class and image IDs to internal IDs", "\n", "self", ".", "image_from_source_map", "=", "{", "\"{}.{}\"", ".", "format", "(", "info", "[", "'source'", "]", ",", "info", "[", "'id'", "]", ")", ":", "id", "\n", "for", "info", ",", "id", "in", "zip", "(", "self", ".", "image_info", ",", "self", ".", "image_ids", ")", "}", "\n", "\n", "# Map sources to class_ids they support", "\n", "self", ".", "sources", "=", "list", "(", "set", "(", "[", "i", "[", "'source'", "]", "for", "i", "in", "self", ".", "class_info", "]", ")", ")", "\n", "\n", "\n", "'''\n        self.source_class_ids = {}\n        # Loop over datasets\n        for source in self.sources:\n            self.source_class_ids[source] = []\n            # Find classes that belong to this dataset\n            for i, info in enumerate(self.class_info):\n                # Include BG class in all datasets\n                if i == 0 or source == info['source']:\n                    self.source_class_ids[source].append(i)\n        '''", "\n", "\n", "print", "(", "self", ".", "class_names", ")", "\n", "print", "(", "self", ".", "class_from_source_map", ")", "\n", "print", "(", "self", ".", "sources", ")", "\n", "#print(self.source_class_ids)", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.map_source_class_id": [[1007, 1013], ["None"], "methods", ["None"], ["", "def", "map_source_class_id", "(", "self", ",", "source_class_id", ")", ":", "\n", "        ", "\"\"\"Takes a source class ID and returns the int class ID assigned to it.\n        For example:\n        dataset.map_source_class_id(\"coco.12\") -> 23\n        \"\"\"", "\n", "return", "self", ".", "class_from_source_map", "[", "source_class_id", "]", "if", "source_class_id", "in", "self", ".", "class_from_source_map", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.get_source_class_id": [[1014, 1019], ["None"], "methods", ["None"], ["", "def", "get_source_class_id", "(", "self", ",", "class_id", ",", "source", ")", ":", "\n", "        ", "\"\"\"Map an internal class ID to the corresponding class ID in the source dataset.\"\"\"", "\n", "info", "=", "self", ".", "class_info", "[", "class_id", "]", "\n", "assert", "info", "[", "'source'", "]", "==", "source", "\n", "return", "info", "[", "'id'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.append_data": [[1020, 1030], ["enumerate", "enumerate", "str", "str"], "methods", ["None"], ["", "def", "append_data", "(", "self", ",", "class_info", ",", "image_info", ")", ":", "\n", "        ", "self", ".", "external_to_class_id", "=", "{", "}", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "self", ".", "class_info", ")", ":", "\n", "            ", "for", "ds", ",", "id", "in", "c", "[", "\"map\"", "]", ":", "\n", "                ", "self", ".", "external_to_class_id", "[", "ds", "+", "str", "(", "id", ")", "]", "=", "i", "\n", "\n", "# Map external image IDs to internal ones.", "\n", "", "", "self", ".", "external_to_image_id", "=", "{", "}", "\n", "for", "i", ",", "info", "in", "enumerate", "(", "self", ".", "image_info", ")", ":", "\n", "            ", "self", ".", "external_to_image_id", "[", "info", "[", "\"ds\"", "]", "+", "str", "(", "info", "[", "\"id\"", "]", ")", "]", "=", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.image_ids": [[1031, 1034], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "image_ids", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_image_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.source_image_link": [[1035, 1041], ["None"], "methods", ["None"], ["", "def", "source_image_link", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Returns the path or URL to the image.\n        Override this to return a URL to the image if it's availble online for easy\n        debugging.\n        \"\"\"", "\n", "return", "self", ".", "image_info", "[", "image_id", "]", "[", "\"path\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.load_image": [[1042, 1051], ["scipy.misc.imread", "skimage.color.gray2rgb"], "methods", ["None"], ["", "def", "load_image", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified image and return a [H,W,3] Numpy array.\n        \"\"\"", "\n", "# Load image", "\n", "image", "=", "scipy", ".", "misc", ".", "imread", "(", "self", ".", "image_info", "[", "image_id", "]", "[", "'path'", "]", ")", "\n", "# If grayscale. Convert to RGB for consistency.", "\n", "if", "image", ".", "ndim", "!=", "3", ":", "\n", "            ", "image", "=", "skimage", ".", "color", ".", "gray2rgb", "(", "image", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.Dataset.load_mask": [[1052, 1067], ["numpy.empty", "numpy.empty"], "methods", ["None"], ["", "def", "load_mask", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load instance masks for the given image.\n        Different datasets use different ways to store masks. Override this\n        method to load instance masks and return them in the form of am\n        array of binary masks of shape [height, width, instances].\n        Returns:\n            masks: A bool array of shape [height, width, instance count] with\n                a binary mask per instance.\n            class_ids: a 1D array of class IDs of the instance masks.\n        \"\"\"", "\n", "# Override this function to load a mask from your dataset.", "\n", "# Otherwise, it returns an empty mask.", "\n", "mask", "=", "np", ".", "empty", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "class_ids", "=", "np", ".", "empty", "(", "[", "0", "]", ",", "np", ".", "int32", ")", "\n", "return", "mask", ",", "class_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.extract_bboxes": [[39, 62], ["numpy.zeros", "range", "np.zeros.astype", "numpy.array", "numpy.where", "numpy.where", "numpy.any", "numpy.any"], "function", ["None"], ["def", "extract_bboxes", "(", "mask", ")", ":", "\n", "    ", "\"\"\"Compute bounding boxes from masks.\n    mask: [height, width, num_instances]. Mask pixels are either 1 or 0.\n    Returns: bbox array [num_instances, (y1, x1, y2, x2)].\n    \"\"\"", "\n", "boxes", "=", "np", ".", "zeros", "(", "[", "mask", ".", "shape", "[", "-", "1", "]", ",", "4", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "        ", "m", "=", "mask", "[", ":", ",", ":", ",", "i", "]", "\n", "# Bounding box.", "\n", "horizontal_indicies", "=", "np", ".", "where", "(", "np", ".", "any", "(", "m", ",", "axis", "=", "0", ")", ")", "[", "0", "]", "\n", "vertical_indicies", "=", "np", ".", "where", "(", "np", ".", "any", "(", "m", ",", "axis", "=", "1", ")", ")", "[", "0", "]", "\n", "if", "horizontal_indicies", ".", "shape", "[", "0", "]", ":", "\n", "            ", "x1", ",", "x2", "=", "horizontal_indicies", "[", "[", "0", ",", "-", "1", "]", "]", "\n", "y1", ",", "y2", "=", "vertical_indicies", "[", "[", "0", ",", "-", "1", "]", "]", "\n", "# x2 and y2 should not be part of the box. Increment by 1.", "\n", "x2", "+=", "1", "\n", "y2", "+=", "1", "\n", "", "else", ":", "\n", "# No mask for this instance. Might happen due to", "\n", "# resizing or cropping. Set bbox to zeros", "\n", "            ", "x1", ",", "x2", ",", "y1", ",", "y2", "=", "0", ",", "0", ",", "0", ",", "0", "\n", "", "boxes", "[", "i", "]", "=", "np", ".", "array", "(", "[", "y1", ",", "x1", ",", "y2", ",", "x2", "]", ")", "\n", "", "return", "boxes", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_iou": [[64, 82], ["numpy.maximum", "numpy.minimum", "numpy.maximum", "numpy.minimum", "numpy.maximum", "numpy.maximum"], "function", ["None"], ["", "def", "compute_iou", "(", "box", ",", "boxes", ",", "box_area", ",", "boxes_area", ")", ":", "\n", "    ", "\"\"\"Calculates IoU of the given box with the array of the given boxes.\n    box: 1D vector [y1, x1, y2, x2]\n    boxes: [boxes_count, (y1, x1, y2, x2)]\n    box_area: float. the area of 'box'\n    boxes_area: array of length boxes_count.\n    Note: the areas are passed in rather than calculated here for\n          efficiency. Calculate once in the caller to avoid duplicate work.\n    \"\"\"", "\n", "# Calculate intersection areas", "\n", "y1", "=", "np", ".", "maximum", "(", "box", "[", "0", "]", ",", "boxes", "[", ":", ",", "0", "]", ")", "\n", "y2", "=", "np", ".", "minimum", "(", "box", "[", "2", "]", ",", "boxes", "[", ":", ",", "2", "]", ")", "\n", "x1", "=", "np", ".", "maximum", "(", "box", "[", "1", "]", ",", "boxes", "[", ":", ",", "1", "]", ")", "\n", "x2", "=", "np", ".", "minimum", "(", "box", "[", "3", "]", ",", "boxes", "[", ":", ",", "3", "]", ")", "\n", "intersection", "=", "np", ".", "maximum", "(", "x2", "-", "x1", ",", "0", ")", "*", "np", ".", "maximum", "(", "y2", "-", "y1", ",", "0", ")", "\n", "union", "=", "box_area", "+", "boxes_area", "[", ":", "]", "-", "intersection", "[", ":", "]", "\n", "iou", "=", "intersection", "/", "union", "\n", "return", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_overlaps": [[84, 100], ["numpy.zeros", "range", "utils.compute_iou"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_iou"], ["", "def", "compute_overlaps", "(", "boxes1", ",", "boxes2", ")", ":", "\n", "    ", "\"\"\"Computes IoU overlaps between two sets of boxes.\n    boxes1, boxes2: [N, (y1, x1, y2, x2)].\n    For better performance, pass the largest set first and the smaller second.\n    \"\"\"", "\n", "# Areas of anchors and GT boxes", "\n", "area1", "=", "(", "boxes1", "[", ":", ",", "2", "]", "-", "boxes1", "[", ":", ",", "0", "]", ")", "*", "(", "boxes1", "[", ":", ",", "3", "]", "-", "boxes1", "[", ":", ",", "1", "]", ")", "\n", "area2", "=", "(", "boxes2", "[", ":", ",", "2", "]", "-", "boxes2", "[", ":", ",", "0", "]", ")", "*", "(", "boxes2", "[", ":", ",", "3", "]", "-", "boxes2", "[", ":", ",", "1", "]", ")", "\n", "\n", "# Compute overlaps to generate matrix [boxes1 count, boxes2 count]", "\n", "# Each cell contains the IoU value.", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "boxes1", ".", "shape", "[", "0", "]", ",", "boxes2", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "overlaps", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "box2", "=", "boxes2", "[", "i", "]", "\n", "overlaps", "[", ":", ",", "i", "]", "=", "compute_iou", "(", "box2", ",", "boxes1", ",", "area2", "[", "i", "]", ",", "area1", ")", "\n", "", "return", "overlaps", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_overlaps_masks": [[103, 119], ["numpy.reshape().astype", "numpy.reshape().astype", "numpy.sum", "numpy.sum", "numpy.dot", "numpy.reshape", "numpy.reshape"], "function", ["None"], ["", "def", "compute_overlaps_masks", "(", "masks1", ",", "masks2", ")", ":", "\n", "    ", "'''Computes IoU overlaps between two sets of masks.\n    masks1, masks2: [Height, Width, instances]\n    '''", "\n", "# flatten masks", "\n", "masks1", "=", "np", ".", "reshape", "(", "masks1", ">", ".5", ",", "(", "-", "1", ",", "masks1", ".", "shape", "[", "-", "1", "]", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "masks2", "=", "np", ".", "reshape", "(", "masks2", ">", ".5", ",", "(", "-", "1", ",", "masks2", ".", "shape", "[", "-", "1", "]", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "area1", "=", "np", ".", "sum", "(", "masks1", ",", "axis", "=", "0", ")", "\n", "area2", "=", "np", ".", "sum", "(", "masks2", ",", "axis", "=", "0", ")", "\n", "\n", "# intersections and union", "\n", "intersections", "=", "np", ".", "dot", "(", "masks1", ".", "T", ",", "masks2", ")", "\n", "union", "=", "area1", "[", ":", ",", "None", "]", "+", "area2", "[", "None", ",", ":", "]", "-", "intersections", "\n", "overlaps", "=", "intersections", "/", "union", "\n", "\n", "return", "overlaps", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_mean_l1_coord_diff": [[121, 182], ["numpy.reshape().astype", "numpy.reshape().astype", "numpy.reshape().astype", "numpy.reshape().astype", "numpy.logical_and", "len", "coord1[].transpose", "coord2[].transpose", "numpy.array", "numpy.reshape", "numpy.zeros", "range", "pts2.reshape", "numpy.mean", "numpy.amin", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.where", "numpy.linalg.norm", "numpy.zeros", "range", "pts2.reshape", "numpy.mean", "numpy.amin", "numpy.linalg.norm", "numpy.mean", "numpy.cos", "numpy.sin", "numpy.cos", "utils.compute_mean_l1_coord_diff.rotation_y_matrix"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.rotation_y_matrix"], ["", "def", "compute_mean_l1_coord_diff", "(", "mask1", ",", "mask2", ",", "coord1", ",", "coord2", ",", "synset", ",", "cls_id", ")", ":", "\n", "    ", "'''Computes IoU overlaps between two sets of masks.\n    mask1, mask2: [Height, Width]\n    coord1, coord2: [Height, Width, 3]\n    \n    '''", "\n", "# flatten masks", "\n", "num_pixels", "=", "mask1", ".", "shape", "[", "0", "]", "*", "mask1", ".", "shape", "[", "1", "]", "\n", "\n", "mask1", "=", "np", ".", "reshape", "(", "mask1", ">", ".5", ",", "(", "-", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "mask2", "=", "np", ".", "reshape", "(", "mask2", ">", ".5", ",", "(", "-", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "coord1", "=", "np", ".", "reshape", "(", "coord1", ",", "(", "-", "1", ",", "3", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "coord2", "=", "np", ".", "reshape", "(", "coord2", ",", "(", "-", "1", ",", "3", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# intersections and union", "\n", "intersections", "=", "np", ".", "logical_and", "(", "mask1", ",", "mask2", ")", "\n", "num_pixel_intersection", "=", "len", "(", "np", ".", "where", "(", "intersections", ")", "[", "0", "]", ")", "\n", "\n", "pts1", "=", "coord1", "[", "intersections", ",", ":", "]", ".", "transpose", "(", ")", "-", "0.5", "\n", "pts2", "=", "coord2", "[", "intersections", ",", ":", "]", ".", "transpose", "(", ")", "-", "0.5", "\n", "\n", "def", "rotation_y_matrix", "(", "theta", ")", ":", "\n", "        ", "rotation_matrix", "=", "np", ".", "array", "(", "[", "np", ".", "cos", "(", "theta", ")", ",", "0", ",", "np", ".", "sin", "(", "theta", ")", ",", "\n", "0", ",", "1", ",", "0", ",", "\n", "-", "np", ".", "sin", "(", "theta", ")", ",", "0", ",", "np", ".", "cos", "(", "theta", ")", "]", ")", "\n", "rotation_matrix", "=", "np", ".", "reshape", "(", "rotation_matrix", ",", "(", "3", ",", "3", ")", ")", "\n", "return", "rotation_matrix", "\n", "\n", "", "if", "synset", "[", "cls_id", "]", "in", "[", "'bottle'", ",", "'bowl'", ",", "'can'", "]", ":", "\n", "        ", "M", "=", "20", "\n", "pts1_symmetry", "=", "np", ".", "zeros", "(", "pts1", ".", "shape", "+", "(", "M", ",", ")", ")", "## shape: (3, N, 6)", "\n", "for", "i", "in", "range", "(", "M", ")", ":", "\n", "            ", "rotated_pts1", "=", "rotation_y_matrix", "(", "float", "(", "i", ")", "*", "np", ".", "float32", "(", "2", "*", "math", ".", "pi", "/", "M", ")", ")", "@", "pts1", "\n", "pts1_symmetry", "[", ":", ",", ":", ",", "i", "]", "=", "rotated_pts1", "\n", "\n", "", "pts2_reshape", "=", "pts2", ".", "reshape", "(", "[", "3", ",", "-", "1", ",", "1", "]", ")", "\n", "mean_dists", "=", "np", ".", "mean", "(", "np", ".", "linalg", ".", "norm", "(", "pts1_symmetry", "-", "pts2_reshape", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", "\n", "mean_dist", "=", "np", ".", "amin", "(", "mean_dists", ")", "\n", "", "elif", "synset", "[", "cls_id", "]", "in", "[", "'phone'", "]", ":", "\n", "        ", "pts1_symmetry", "=", "np", ".", "zeros", "(", "pts1", ".", "shape", "+", "(", "2", ",", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "2", ")", ":", "\n", "            ", "rotated_pts1", "=", "rotation_y_matrix", "(", "float", "(", "i", ")", "*", "np", ".", "float32", "(", "2", "*", "math", ".", "pi", "/", "2", ")", ")", "@", "pts1", "\n", "#print(rotated_pts1)", "\n", "pts1_symmetry", "[", ":", ",", ":", ",", "i", "]", "=", "rotated_pts1", "\n", "\n", "", "pts2_reshape", "=", "pts2", ".", "reshape", "(", "[", "3", ",", "-", "1", ",", "1", "]", ")", "\n", "mean_dists", "=", "np", ".", "mean", "(", "np", ".", "linalg", ".", "norm", "(", "pts1_symmetry", "-", "pts2_reshape", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", "\n", "mean_dist", "=", "np", ".", "amin", "(", "mean_dists", ")", "\n", "", "else", ":", "\n", "#print(synset[cls_id])", "\n", "        ", "diff", "=", "pts1", "-", "pts2", "\n", "dist", "=", "np", ".", "linalg", ".", "norm", "(", "diff", ",", "axis", "=", "0", ")", "\n", "assert", "dist", ".", "shape", "[", "0", "]", "==", "num_pixel_intersection", "\n", "mean_dist", "=", "np", ".", "mean", "(", "dist", ")", "\n", "\n", "", "mean_l1_coord_diff", "=", "mean_dist", "\n", "#print(mean_l1_coord_diff, pts1.shape[0])", "\n", "\n", "return", "mean_l1_coord_diff", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_3d_iou": [[186, 236], ["numpy.amax", "numpy.amin", "numpy.amax", "numpy.amin", "numpy.maximum", "numpy.minimum", "print", "numpy.array", "range", "utils.compute_3d_iou.asymmetric_3d_iou"], "function", ["None"], ["", "def", "compute_3d_iou", "(", "bbox_3d_1", ",", "bbox_3d_2", ",", "handle_visibility", ",", "class_name_1", ",", "class_name_2", ")", ":", "\n", "    ", "'''Computes IoU overlaps between two 3d bboxes.\n       bbox_3d_1, bbox_3d_1: [3, 8]\n    '''", "\n", "# flatten masks", "\n", "def", "asymmetric_3d_iou", "(", "bbox_3d_1", ",", "bbox_3d_2", ")", ":", "\n", "        ", "bbox_1_max", "=", "np", ".", "amax", "(", "bbox_3d_1", ",", "axis", "=", "0", ")", "\n", "bbox_1_min", "=", "np", ".", "amin", "(", "bbox_3d_1", ",", "axis", "=", "0", ")", "\n", "bbox_2_max", "=", "np", ".", "amax", "(", "bbox_3d_2", ",", "axis", "=", "0", ")", "\n", "bbox_2_min", "=", "np", ".", "amin", "(", "bbox_3d_2", ",", "axis", "=", "0", ")", "\n", "\n", "overlap_min", "=", "np", ".", "maximum", "(", "bbox_1_min", ",", "bbox_2_min", ")", "\n", "overlap_max", "=", "np", ".", "minimum", "(", "bbox_1_max", ",", "bbox_2_max", ")", "\n", "\n", "# intersections and union", "\n", "if", "np", ".", "amin", "(", "overlap_max", "-", "overlap_min", ")", "<", "0", ":", "\n", "        \t", "intersections", "=", "0", "\n", "", "else", ":", "\n", "        \t", "intersections", "=", "np", ".", "prod", "(", "overlap_max", "-", "overlap_min", ")", "\n", "", "union", "=", "np", ".", "prod", "(", "bbox_1_max", "-", "bbox_1_min", ")", "+", "np", ".", "prod", "(", "bbox_2_max", "-", "bbox_2_min", ")", "-", "intersections", "\n", "overlaps", "=", "intersections", "/", "union", "\n", "return", "overlaps", "\n", "\n", "\n", "", "if", "bbox_3d_1", "is", "None", "or", "bbox_3d_2", "is", "None", ":", "\n", "        ", "return", "-", "1", "\n", "\n", "", "symmetry_flag", "=", "False", "\n", "if", "class_name_1", "in", "[", "'bottle'", ",", "'bowl'", ",", "'can'", "]", "and", "class_name_1", "==", "class_name_2", ":", "\n", "        ", "symmetry_flag", "=", "True", "\n", "", "if", "class_name_1", "==", "'mug'", "and", "class_name_1", "==", "class_name_2", "and", "handle_visibility", "==", "0", ":", "\n", "        ", "symmetry_flag", "=", "True", "\n", "\n", "", "if", "symmetry_flag", ":", "\n", "        ", "print", "(", "'*'", "*", "10", ")", "\n", "n", "=", "20", "\n", "theta", "=", "2", "*", "math", ".", "pi", "/", "n", "\n", "\n", "y_rotation_matrix", "=", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "theta", ")", ",", "0", ",", "np", ".", "sin", "(", "theta", ")", "]", ",", "\n", "[", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "-", "np", ".", "sin", "(", "theta", ")", ",", "0", ",", "np", ".", "cos", "(", "theta", ")", "]", "]", ")", "\n", "\n", "max_iou", "=", "0", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "bbox_center", "=", "np", ".", "mean", "(", "bbox_3d_1", ",", "-", "1", ",", "keepdims", "=", "True", ")", "\n", "bbox_3d_1", "=", "y_rotation_matrix", "@", "(", "bbox_3d_1", "-", "bbox_center", ")", "+", "bbox_center", "\n", "max_iou", "=", "max", "(", "max_iou", ",", "asymmetric_3d_iou", "(", "bbox_3d_1", ",", "bbox_3d_2", ")", ")", "\n", "", "return", "max_iou", "\n", "", "else", ":", "\n", "        ", "return", "asymmetric_3d_iou", "(", "bbox_3d_1", ",", "bbox_3d_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_3d_iou_new": [[239, 298], ["utils.get_3d_bbox", "utils.transform_coordinates_3d", "utils.get_3d_bbox", "utils.transform_coordinates_3d", "numpy.amax", "numpy.amin", "numpy.amax", "numpy.amin", "numpy.maximum", "numpy.minimum", "print", "utils.get_3d_bbox", "utils.get_3d_bbox", "utils.transform_coordinates_3d", "range", "utils.compute_3d_iou.asymmetric_3d_iou"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.get_3d_bbox", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.get_3d_bbox", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.get_3d_bbox", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.get_3d_bbox", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d"], ["", "", "def", "compute_3d_iou_new", "(", "RT_1", ",", "RT_2", ",", "scales_1", ",", "scales_2", ",", "handle_visibility", ",", "class_name_1", ",", "class_name_2", ")", ":", "\n", "    ", "'''Computes IoU overlaps between two 3d bboxes.\n       bbox_3d_1, bbox_3d_1: [3, 8]\n    '''", "\n", "# flatten masks", "\n", "def", "asymmetric_3d_iou", "(", "RT_1", ",", "RT_2", ",", "scales_1", ",", "scales_2", ")", ":", "\n", "        ", "noc_cube_1", "=", "get_3d_bbox", "(", "scales_1", ",", "0", ")", "\n", "bbox_3d_1", "=", "transform_coordinates_3d", "(", "noc_cube_1", ",", "RT_1", ")", "\n", "\n", "noc_cube_2", "=", "get_3d_bbox", "(", "scales_2", ",", "0", ")", "\n", "bbox_3d_2", "=", "transform_coordinates_3d", "(", "noc_cube_2", ",", "RT_2", ")", "\n", "\n", "\n", "bbox_1_max", "=", "np", ".", "amax", "(", "bbox_3d_1", ",", "axis", "=", "0", ")", "\n", "bbox_1_min", "=", "np", ".", "amin", "(", "bbox_3d_1", ",", "axis", "=", "0", ")", "\n", "bbox_2_max", "=", "np", ".", "amax", "(", "bbox_3d_2", ",", "axis", "=", "0", ")", "\n", "bbox_2_min", "=", "np", ".", "amin", "(", "bbox_3d_2", ",", "axis", "=", "0", ")", "\n", "\n", "overlap_min", "=", "np", ".", "maximum", "(", "bbox_1_min", ",", "bbox_2_min", ")", "\n", "overlap_max", "=", "np", ".", "minimum", "(", "bbox_1_max", ",", "bbox_2_max", ")", "\n", "\n", "# intersections and union", "\n", "if", "np", ".", "amin", "(", "overlap_max", "-", "overlap_min", ")", "<", "0", ":", "\n", "            ", "intersections", "=", "0", "\n", "", "else", ":", "\n", "            ", "intersections", "=", "np", ".", "prod", "(", "overlap_max", "-", "overlap_min", ")", "\n", "", "union", "=", "np", ".", "prod", "(", "bbox_1_max", "-", "bbox_1_min", ")", "+", "np", ".", "prod", "(", "bbox_2_max", "-", "bbox_2_min", ")", "-", "intersections", "\n", "overlaps", "=", "intersections", "/", "union", "\n", "return", "overlaps", "\n", "\n", "\n", "", "if", "RT_1", "is", "None", "or", "RT_2", "is", "None", ":", "\n", "        ", "return", "-", "1", "\n", "\n", "", "symmetry_flag", "=", "False", "\n", "if", "(", "class_name_1", "in", "[", "'bottle'", ",", "'bowl'", ",", "'can'", "]", "and", "class_name_1", "==", "class_name_2", ")", "or", "(", "class_name_1", "==", "'mug'", "and", "class_name_1", "==", "class_name_2", "and", "handle_visibility", "==", "0", ")", ":", "\n", "        ", "print", "(", "'*'", "*", "10", ")", "\n", "\n", "noc_cube_1", "=", "get_3d_bbox", "(", "scales_1", ",", "0", ")", "\n", "noc_cube_2", "=", "get_3d_bbox", "(", "scales_2", ",", "0", ")", "\n", "bbox_3d_2", "=", "transform_coordinates_3d", "(", "noc_cube_2", ",", "RT_2", ")", "\n", "\n", "def", "y_rotation_matrix", "(", "theta", ")", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "theta", ")", ",", "0", ",", "np", ".", "sin", "(", "theta", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "-", "np", ".", "sin", "(", "theta", ")", ",", "0", ",", "np", ".", "cos", "(", "theta", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "", "n", "=", "20", "\n", "max_iou", "=", "0", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "rotated_RT_1", "=", "RT_1", "@", "y_rotation_matrix", "(", "2", "*", "math", ".", "pi", "*", "i", "/", "float", "(", "n", ")", ")", "\n", "max_iou", "=", "max", "(", "max_iou", ",", "\n", "asymmetric_3d_iou", "(", "rotated_RT_1", ",", "RT_2", ",", "scales_1", ",", "scales_2", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "max_iou", "=", "asymmetric_3d_iou", "(", "RT_1", ",", "RT_2", ",", "scales_1", ",", "scales_2", ")", "\n", "\n", "\n", "", "return", "max_iou", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_distances": [[302, 336], ["numpy.array_equal", "numpy.array_equal", "numpy.cbrt", "numpy.cbrt", "R2.transpose", "numpy.linalg.norm", "numpy.array", "print", "numpy.linalg.det", "numpy.linalg.det", "numpy.arccos", "numpy.trace"], "function", ["None"], ["", "def", "compute_RT_distances", "(", "RT_1", ",", "RT_2", ")", ":", "\n", "    ", "'''\n    :param RT_1: [4, 4]. homogeneous affine transformation\n    :param RT_2: [4, 4]. homogeneous affine transformation\n    :return: theta: angle difference of R in degree, shift: l2 difference of T in centimeter\n    '''", "\n", "#print(RT_1[3, :], RT_2[3, :])", "\n", "## make sure the last row is [0, 0, 0, 1]", "\n", "if", "RT_1", "is", "None", "or", "RT_2", "is", "None", ":", "\n", "        ", "return", "-", "1", "\n", "\n", "", "try", ":", "\n", "        ", "assert", "np", ".", "array_equal", "(", "RT_1", "[", "3", ",", ":", "]", ",", "RT_2", "[", "3", ",", ":", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "RT_1", "[", "3", ",", ":", "]", ",", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "1", "]", ")", ")", "\n", "", "except", "AssertionError", ":", "\n", "        ", "print", "(", "RT_1", "[", "3", ",", ":", "]", ",", "RT_2", "[", "3", ",", ":", "]", ")", "\n", "\n", "\n", "\n", "", "R1", "=", "RT_1", "[", ":", "3", ",", ":", "3", "]", "/", "np", ".", "cbrt", "(", "np", ".", "linalg", ".", "det", "(", "RT_1", "[", ":", "3", ",", ":", "3", "]", ")", ")", "\n", "T1", "=", "RT_1", "[", ":", "3", ",", "3", "]", "\n", "\n", "R2", "=", "RT_2", "[", ":", "3", ",", ":", "3", "]", "/", "np", ".", "cbrt", "(", "np", ".", "linalg", ".", "det", "(", "RT_2", "[", ":", "3", ",", ":", "3", "]", ")", ")", "\n", "T2", "=", "RT_2", "[", ":", "3", ",", "3", "]", "\n", "\n", "R", "=", "R1", "@", "R2", ".", "transpose", "(", ")", "\n", "theta", "=", "np", ".", "arccos", "(", "(", "np", ".", "trace", "(", "R", ")", "-", "1", ")", "/", "2", ")", "*", "180", "/", "np", ".", "pi", "\n", "shift", "=", "np", ".", "linalg", ".", "norm", "(", "T1", "-", "T2", ")", "*", "100", "\n", "# print(theta, shift)", "\n", "\n", "if", "theta", "<", "5", "and", "shift", "<", "5", ":", "\n", "        ", "return", "10", "-", "theta", "-", "shift", "\n", "", "else", ":", "\n", "        ", "return", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_degree_cm_symmetry": [[338, 414], ["numpy.array", "numpy.array_equal", "numpy.array_equal", "numpy.cbrt", "numpy.cbrt", "numpy.array", "numpy.arccos", "numpy.linalg.norm", "numpy.array", "print", "exit", "numpy.linalg.det", "numpy.linalg.det", "numpy.array", "numpy.arccos", "y1.dot", "numpy.diag", "min", "numpy.arccos", "numpy.linalg.norm", "numpy.linalg.norm", "y1.dot", "R2.transpose", "R2.transpose", "numpy.arccos", "numpy.arccos", "R2.transpose", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.trace", "numpy.trace", "numpy.trace"], "function", ["None"], ["", "", "def", "compute_RT_degree_cm_symmetry", "(", "RT_1", ",", "RT_2", ",", "class_id", ",", "handle_visibility", ",", "synset_names", ")", ":", "\n", "    ", "'''\n    :param RT_1: [4, 4]. homogeneous affine transformation\n    :param RT_2: [4, 4]. homogeneous affine transformation\n    :return: theta: angle difference of R in degree, shift: l2 difference of T in centimeter\n\n\n    synset_names = ['BG',  # 0\n                    'bottle',  # 1\n                    'bowl',  # 2\n                    'camera',  # 3\n                    'can',  # 4\n                    'cap',  # 5\n                    'phone',  # 6\n                    'monitor',  # 7\n                    'laptop',  # 8\n                    'mug'  # 9\n                    ]\n    \n    synset_names = ['BG',  # 0\n                    'bottle',  # 1\n                    'bowl',  # 2\n                    'camera',  # 3\n                    'can',  # 4\n                    'laptop',  # 5\n                    'mug'  # 6\n                    ]\n    '''", "\n", "\n", "## make sure the last row is [0, 0, 0, 1]", "\n", "if", "RT_1", "is", "None", "or", "RT_2", "is", "None", ":", "\n", "        ", "return", "-", "1", "\n", "", "try", ":", "\n", "        ", "assert", "np", ".", "array_equal", "(", "RT_1", "[", "3", ",", ":", "]", ",", "RT_2", "[", "3", ",", ":", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "RT_1", "[", "3", ",", ":", "]", ",", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "1", "]", ")", ")", "\n", "", "except", "AssertionError", ":", "\n", "        ", "print", "(", "RT_1", "[", "3", ",", ":", "]", ",", "RT_2", "[", "3", ",", ":", "]", ")", "\n", "exit", "(", ")", "\n", "\n", "", "R1", "=", "RT_1", "[", ":", "3", ",", ":", "3", "]", "/", "np", ".", "cbrt", "(", "np", ".", "linalg", ".", "det", "(", "RT_1", "[", ":", "3", ",", ":", "3", "]", ")", ")", "\n", "T1", "=", "RT_1", "[", ":", "3", ",", "3", "]", "\n", "\n", "R2", "=", "RT_2", "[", ":", "3", ",", ":", "3", "]", "/", "np", ".", "cbrt", "(", "np", ".", "linalg", ".", "det", "(", "RT_2", "[", ":", "3", ",", ":", "3", "]", ")", ")", "\n", "T2", "=", "RT_2", "[", ":", "3", ",", "3", "]", "\n", "\n", "#     try:", "\n", "#         assert np.abs(np.linalg.det(R1) - 1) < 0.01", "\n", "#         assert np.abs(np.linalg.det(R2) - 1) < 0.01", "\n", "#     except AssertionError:", "\n", "#         print(np.linalg.det(R1), np.linalg.det(R2))", "\n", "\n", "if", "synset_names", "[", "class_id", "]", "in", "[", "'bottle'", ",", "'can'", ",", "'bowl'", "]", ":", "## symmetric when rotating around y-axis", "\n", "        ", "y", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "0", "]", ")", "\n", "y1", "=", "R1", "@", "y", "\n", "y2", "=", "R2", "@", "y", "\n", "theta", "=", "np", ".", "arccos", "(", "y1", ".", "dot", "(", "y2", ")", "/", "(", "np", ".", "linalg", ".", "norm", "(", "y1", ")", "*", "np", ".", "linalg", ".", "norm", "(", "y2", ")", ")", ")", "\n", "", "elif", "synset_names", "[", "class_id", "]", "==", "'mug'", "and", "handle_visibility", "==", "0", ":", "## symmetric when rotating around y-axis", "\n", "        ", "y", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "0", "]", ")", "\n", "y1", "=", "R1", "@", "y", "\n", "y2", "=", "R2", "@", "y", "\n", "theta", "=", "np", ".", "arccos", "(", "y1", ".", "dot", "(", "y2", ")", "/", "(", "np", ".", "linalg", ".", "norm", "(", "y1", ")", "*", "np", ".", "linalg", ".", "norm", "(", "y2", ")", ")", ")", "\n", "", "elif", "synset_names", "[", "class_id", "]", "in", "[", "'phone'", ",", "'eggbox'", ",", "'glue'", "]", ":", "\n", "        ", "y_180_RT", "=", "np", ".", "diag", "(", "[", "-", "1.0", ",", "1.0", ",", "-", "1.0", "]", ")", "\n", "R", "=", "R1", "@", "R2", ".", "transpose", "(", ")", "\n", "R_rot", "=", "R1", "@", "y_180_RT", "@", "R2", ".", "transpose", "(", ")", "\n", "theta", "=", "min", "(", "np", ".", "arccos", "(", "(", "np", ".", "trace", "(", "R", ")", "-", "1", ")", "/", "2", ")", ",", "\n", "np", ".", "arccos", "(", "(", "np", ".", "trace", "(", "R_rot", ")", "-", "1", ")", "/", "2", ")", ")", "\n", "", "else", ":", "\n", "        ", "R", "=", "R1", "@", "R2", ".", "transpose", "(", ")", "\n", "theta", "=", "np", ".", "arccos", "(", "(", "np", ".", "trace", "(", "R", ")", "-", "1", ")", "/", "2", ")", "\n", "\n", "", "theta", "*=", "180", "/", "np", ".", "pi", "\n", "shift", "=", "np", ".", "linalg", ".", "norm", "(", "T1", "-", "T2", ")", "*", "100", "\n", "result", "=", "np", ".", "array", "(", "[", "theta", ",", "shift", "]", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_projection_2d_symmetry": [[416, 520], ["numpy.amax", "numpy.amax", "numpy.amin", "numpy.amin", "utils.transform_coordinates_3d", "utils.calculate_2d_projections", "utils.transform_coordinates_3d", "utils.calculate_2d_projections", "numpy.linalg.norm", "numpy.mean", "numpy.array_equal", "numpy.array_equal", "numpy.cbrt", "numpy.cbrt", "numpy.copy", "numpy.amax", "numpy.amax", "numpy.amin", "numpy.amin", "len", "range", "numpy.array", "print", "exit", "numpy.linalg.det", "numpy.linalg.det", "numpy.abs", "numpy.abs", "print", "numpy.array", "utils.transform_coordinates_3d", "utils.calculate_2d_projections", "numpy.linalg.norm", "min", "numpy.diag", "utils.transform_coordinates_3d", "utils.calculate_2d_projections", "numpy.linalg.norm", "min", "numpy.linalg.det", "numpy.linalg.det", "float", "len", "numpy.mean", "len", "numpy.mean", "numpy.diag", "utils.transform_coordinates_3d", "utils.calculate_2d_projections", "numpy.linalg.norm", "min", "numpy.linalg.det", "numpy.linalg.det", "utils.compute_3d_iou_new.y_rotation_matrix"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections"], ["", "def", "compute_RT_projection_2d_symmetry", "(", "RT_1", ",", "RT_2", ",", "class_id", ",", "handle_visibility", ",", "mesh_vertices", ",", "intrinsics", ",", "synset_names", ",", "num_rotation", "=", "20", ")", ":", "\n", "    ", "'''\n    :param RT_1: [4, 4]. homogeneous affine transformation\n    :param RT_2: [4, 4]. homogeneous affine transformation\n    :param vertices: [3, N].\n    :param intrinsics: [4, 4]\n    :return: mean 2d projection distance in pixel\n\n    synset_names = ['BG',  # 0\n                    'bottle',  # 1\n                    'bowl',  # 2\n                    'camera',  # 3\n                    'can',  # 4\n                    'laptop',  # 5\n                    'mug'  # 6\n                    ]\n    '''", "\n", "\n", "## make sure the last row is [0, 0, 0, 1]", "\n", "if", "RT_1", "is", "None", "or", "RT_2", "is", "None", ":", "\n", "        ", "return", "-", "1", "\n", "", "try", ":", "\n", "        ", "assert", "np", ".", "array_equal", "(", "RT_1", "[", "3", ",", ":", "]", ",", "RT_2", "[", "3", ",", ":", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "RT_1", "[", "3", ",", ":", "]", ",", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "1", "]", ")", ")", "\n", "", "except", "AssertionError", ":", "\n", "        ", "print", "(", "RT_1", "[", "3", ",", ":", "]", ",", "RT_2", "[", "3", ",", ":", "]", ")", "\n", "exit", "(", ")", "\n", "\n", "", "RT_1", "[", ":", "3", ",", ":", "3", "]", "=", "RT_1", "[", ":", "3", ",", ":", "3", "]", "/", "np", ".", "cbrt", "(", "np", ".", "linalg", ".", "det", "(", "RT_1", "[", ":", "3", ",", ":", "3", "]", ")", ")", "\n", "R1", "=", "RT_1", "[", ":", "3", ",", ":", "3", "]", "\n", "#T1 = RT_1[:3, 3]", "\n", "\n", "RT_2", "[", ":", "3", ",", ":", "3", "]", "=", "RT_2", "[", ":", "3", ",", ":", "3", "]", "/", "np", ".", "cbrt", "(", "np", ".", "linalg", ".", "det", "(", "RT_2", "[", ":", "3", ",", ":", "3", "]", ")", ")", "\n", "R2", "=", "RT_2", "[", ":", "3", ",", ":", "3", "]", "\n", "#T2 = RT_2[:3, 3]", "\n", "try", ":", "\n", "        ", "assert", "np", ".", "abs", "(", "np", ".", "linalg", ".", "det", "(", "R1", ")", "-", "1", ")", "<", "0.01", "\n", "assert", "np", ".", "abs", "(", "np", ".", "linalg", ".", "det", "(", "R2", ")", "-", "1", ")", "<", "0.01", "\n", "", "except", "AssertionError", ":", "\n", "        ", "print", "(", "np", ".", "linalg", ".", "det", "(", "R1", ")", ",", "np", ".", "linalg", ".", "det", "(", "R2", ")", ")", "\n", "\n", "# check the vertices are in meter unit", "\n", "", "vertices", "=", "np", ".", "copy", "(", "mesh_vertices", ")", "/", "1000", "\n", "assert", "np", ".", "amax", "(", "vertices", ")", "<", "0.5", ",", "np", ".", "amax", "(", "vertices", ")", "\n", "assert", "np", ".", "amax", "(", "vertices", ")", ">", "0", ",", "np", ".", "amax", "(", "vertices", ")", "\n", "assert", "np", ".", "amin", "(", "vertices", ")", "<", "0", ",", "np", ".", "amin", "(", "vertices", ")", "\n", "assert", "np", ".", "amin", "(", "vertices", ")", ">", "-", "0.5", ",", "np", ".", "amin", "(", "vertices", ")", "\n", "\n", "assert", "vertices", ".", "shape", "[", "0", "]", "==", "3", "\n", "num_vertices", "=", "vertices", ".", "shape", "[", "1", "]", "\n", "\n", "coords_3d_1", "=", "transform_coordinates_3d", "(", "vertices", ",", "RT_1", ")", "\n", "projected_1", "=", "calculate_2d_projections", "(", "coords_3d_1", ",", "intrinsics", ")", "\n", "coords_3d_2", "=", "transform_coordinates_3d", "(", "vertices", ",", "RT_2", ")", "\n", "projected_2", "=", "calculate_2d_projections", "(", "coords_3d_2", ",", "intrinsics", ")", "\n", "\n", "# calculate reprojection 2d error", "\n", "dists", "=", "np", ".", "linalg", ".", "norm", "(", "projected_1", "-", "projected_2", ",", "axis", "=", "1", ")", "\n", "assert", "len", "(", "dists", ")", "==", "num_vertices", "\n", "min_mean_dist", "=", "np", ".", "mean", "(", "dists", ")", "\n", "\n", "\n", "## take care of symmetry categories", "\n", "\n", "# freely rotate around y axis", "\n", "if", "(", "synset_names", "[", "class_id", "]", "in", "[", "'bottle'", ",", "'can'", ",", "'bowl'", "]", ")", "or", "(", "synset_names", "[", "class_id", "]", "==", "'mug'", "and", "handle_visibility", "==", "0", ")", ":", "\n", "\n", "        ", "def", "y_rotation_matrix", "(", "theta", ")", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "theta", ")", ",", "0", ",", "np", ".", "sin", "(", "theta", ")", "]", ",", "\n", "[", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "-", "np", ".", "sin", "(", "theta", ")", ",", "0", ",", "np", ".", "cos", "(", "theta", ")", "]", "]", ")", "\n", "", "for", "i", "in", "range", "(", "1", ",", "num_rotation", ")", ":", "\n", "            ", "theta", "=", "2", "*", "math", ".", "pi", "*", "i", "/", "float", "(", "num_rotation", ")", "\n", "coords_3d_2", "=", "transform_coordinates_3d", "(", "y_rotation_matrix", "(", "theta", ")", "@", "vertices", ",", "RT_2", ")", "\n", "projected_2", "=", "calculate_2d_projections", "(", "coords_3d_2", ",", "intrinsics", ")", "\n", "\n", "dists", "=", "np", ".", "linalg", ".", "norm", "(", "projected_1", "-", "projected_2", ",", "axis", "=", "1", ")", "\n", "assert", "len", "(", "dists", ")", "==", "num_vertices", "\n", "min_mean_dist", "=", "min", "(", "min_mean_dist", ",", "np", ".", "mean", "(", "dists", ")", ")", "\n", "\n", "# rotate 180 around y axis", "\n", "", "", "elif", "synset_names", "[", "class_id", "]", "in", "[", "'phone'", "]", ":", "\n", "        ", "y_180_RT", "=", "np", ".", "diag", "(", "[", "-", "1.0", ",", "1.0", ",", "-", "1.0", "]", ")", "\n", "\n", "coords_3d_2", "=", "transform_coordinates_3d", "(", "y_180_RT", "@", "vertices", ",", "RT_2", ")", "\n", "projected_2", "=", "calculate_2d_projections", "(", "coords_3d_2", ",", "intrinsics", ")", "\n", "dists", "=", "np", ".", "linalg", ".", "norm", "(", "projected_1", "-", "projected_2", ",", "axis", "=", "1", ")", "\n", "assert", "len", "(", "dists", ")", "==", "num_vertices", "\n", "min_mean_dist", "=", "min", "(", "min_mean_dist", ",", "np", ".", "mean", "(", "dists", ")", ")", "\n", "\n", "# rotate 180 around z axis", "\n", "", "elif", "synset_names", "[", "class_id", "]", "in", "[", "'eggbox'", ",", "'glue'", "]", ":", "\n", "        ", "z_180_RT", "=", "np", ".", "diag", "(", "[", "-", "1.0", ",", "-", "1.0", ",", "1.0", "]", ")", "\n", "coords_3d_2", "=", "transform_coordinates_3d", "(", "z_180_RT", "@", "vertices", ",", "RT_2", ")", "\n", "projected_2", "=", "calculate_2d_projections", "(", "coords_3d_2", ",", "intrinsics", ")", "\n", "dists", "=", "np", ".", "linalg", ".", "norm", "(", "projected_1", "-", "projected_2", ",", "axis", "=", "1", ")", "\n", "assert", "len", "(", "dists", ")", "==", "num_vertices", "\n", "min_mean_dist", "=", "min", "(", "min_mean_dist", ",", "np", ".", "mean", "(", "dists", ")", ")", "\n", "\n", "", "else", ":", "## normal asymmetric objects        ", "\n", "        ", "min_mean_dist", "=", "min_mean_dist", "\n", "\n", "\n", "", "return", "min_mean_dist", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.non_max_suppression": [[522, 557], ["numpy.array", "boxes.astype.astype", "scores.argsort", "len", "pick.append", "utils.compute_iou", "numpy.delete", "numpy.delete", "numpy.where"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_iou"], ["", "def", "non_max_suppression", "(", "boxes", ",", "scores", ",", "threshold", ")", ":", "\n", "    ", "\"\"\"Performs non-maximum suppression and returns indices of kept boxes.\n    boxes: [N, (y1, x1, y2, x2)]. Notice that (y2, x2) lays outside the box.\n    scores: 1-D array of box scores.\n    threshold: Float. IoU threshold to use for filtering.\n    \"\"\"", "\n", "assert", "boxes", ".", "shape", "[", "0", "]", ">", "0", "\n", "if", "boxes", ".", "dtype", ".", "kind", "!=", "\"f\"", ":", "\n", "        ", "boxes", "=", "boxes", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# Compute box areas", "\n", "", "y1", "=", "boxes", "[", ":", ",", "0", "]", "\n", "x1", "=", "boxes", "[", ":", ",", "1", "]", "\n", "y2", "=", "boxes", "[", ":", ",", "2", "]", "\n", "x2", "=", "boxes", "[", ":", ",", "3", "]", "\n", "area", "=", "(", "y2", "-", "y1", ")", "*", "(", "x2", "-", "x1", ")", "\n", "\n", "# Get indicies of boxes sorted by scores (highest first)", "\n", "ixs", "=", "scores", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "pick", "=", "[", "]", "\n", "while", "len", "(", "ixs", ")", ">", "0", ":", "\n", "# Pick top box and add its index to the list", "\n", "        ", "i", "=", "ixs", "[", "0", "]", "\n", "pick", ".", "append", "(", "i", ")", "\n", "# Compute IoU of the picked box with the rest", "\n", "iou", "=", "compute_iou", "(", "boxes", "[", "i", "]", ",", "boxes", "[", "ixs", "[", "1", ":", "]", "]", ",", "area", "[", "i", "]", ",", "area", "[", "ixs", "[", "1", ":", "]", "]", ")", "\n", "# Identify boxes with IoU over the threshold. This", "\n", "# returns indicies into ixs[1:], so add 1 to get", "\n", "# indicies into ixs.", "\n", "remove_ixs", "=", "np", ".", "where", "(", "iou", ">", "threshold", ")", "[", "0", "]", "+", "1", "\n", "# Remove indicies of the picked and overlapped boxes.", "\n", "ixs", "=", "np", ".", "delete", "(", "ixs", ",", "remove_ixs", ")", "\n", "ixs", "=", "np", ".", "delete", "(", "ixs", ",", "0", ")", "\n", "", "return", "np", ".", "array", "(", "pick", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.apply_box_deltas": [[559, 581], ["boxes.astype.astype", "numpy.exp", "numpy.exp", "numpy.stack"], "function", ["None"], ["", "def", "apply_box_deltas", "(", "boxes", ",", "deltas", ")", ":", "\n", "    ", "\"\"\"Applies the given deltas to the given boxes.\n    boxes: [N, (y1, x1, y2, x2)]. Note that (y2, x2) is outside the box.\n    deltas: [N, (dy, dx, log(dh), log(dw))]\n    \"\"\"", "\n", "boxes", "=", "boxes", ".", "astype", "(", "np", ".", "float32", ")", "\n", "# Convert to y, x, h, w", "\n", "height", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "width", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "center_y", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "height", "\n", "center_x", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "width", "\n", "# Apply deltas", "\n", "center_y", "+=", "deltas", "[", ":", ",", "0", "]", "*", "height", "\n", "center_x", "+=", "deltas", "[", ":", ",", "1", "]", "*", "width", "\n", "height", "*=", "np", ".", "exp", "(", "deltas", "[", ":", ",", "2", "]", ")", "\n", "width", "*=", "np", ".", "exp", "(", "deltas", "[", ":", ",", "3", "]", ")", "\n", "# Convert back to y1, x1, y2, x2", "\n", "y1", "=", "center_y", "-", "0.5", "*", "height", "\n", "x1", "=", "center_x", "-", "0.5", "*", "width", "\n", "y2", "=", "y1", "+", "height", "\n", "x2", "=", "x1", "+", "width", "\n", "return", "np", ".", "stack", "(", "[", "y1", ",", "x1", ",", "y2", ",", "x2", "]", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.box_refinement_graph": [[583, 607], ["tensorflow.cast", "tensorflow.cast", "tensorflow.log", "tensorflow.log", "tensorflow.stack"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log"], ["", "def", "box_refinement_graph", "(", "box", ",", "gt_box", ")", ":", "\n", "    ", "\"\"\"Compute refinement needed to transform box to gt_box.\n    box and gt_box are [N, (y1, x1, y2, x2)]\n    \"\"\"", "\n", "box", "=", "tf", ".", "cast", "(", "box", ",", "tf", ".", "float32", ")", "\n", "gt_box", "=", "tf", ".", "cast", "(", "gt_box", ",", "tf", ".", "float32", ")", "\n", "\n", "height", "=", "box", "[", ":", ",", "2", "]", "-", "box", "[", ":", ",", "0", "]", "\n", "width", "=", "box", "[", ":", ",", "3", "]", "-", "box", "[", ":", ",", "1", "]", "\n", "center_y", "=", "box", "[", ":", ",", "0", "]", "+", "0.5", "*", "height", "\n", "center_x", "=", "box", "[", ":", ",", "1", "]", "+", "0.5", "*", "width", "\n", "\n", "gt_height", "=", "gt_box", "[", ":", ",", "2", "]", "-", "gt_box", "[", ":", ",", "0", "]", "\n", "gt_width", "=", "gt_box", "[", ":", ",", "3", "]", "-", "gt_box", "[", ":", ",", "1", "]", "\n", "gt_center_y", "=", "gt_box", "[", ":", ",", "0", "]", "+", "0.5", "*", "gt_height", "\n", "gt_center_x", "=", "gt_box", "[", ":", ",", "1", "]", "+", "0.5", "*", "gt_width", "\n", "\n", "dy", "=", "(", "gt_center_y", "-", "center_y", ")", "/", "height", "\n", "dx", "=", "(", "gt_center_x", "-", "center_x", ")", "/", "width", "\n", "dh", "=", "tf", ".", "log", "(", "gt_height", "/", "height", ")", "\n", "dw", "=", "tf", ".", "log", "(", "gt_width", "/", "width", ")", "\n", "\n", "result", "=", "tf", ".", "stack", "(", "[", "dy", ",", "dx", ",", "dh", ",", "dw", "]", ",", "axis", "=", "1", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.box_refinement": [[609, 633], ["box.astype.astype", "gt_box.astype.astype", "numpy.log", "numpy.log", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.model.log"], ["", "def", "box_refinement", "(", "box", ",", "gt_box", ")", ":", "\n", "    ", "\"\"\"Compute refinement needed to transform box to gt_box.\n    box and gt_box are [N, (y1, x1, y2, x2)]. (y2, x2) is\n    assumed to be outside the box.\n    \"\"\"", "\n", "box", "=", "box", ".", "astype", "(", "np", ".", "float32", ")", "\n", "gt_box", "=", "gt_box", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "height", "=", "box", "[", ":", ",", "2", "]", "-", "box", "[", ":", ",", "0", "]", "\n", "width", "=", "box", "[", ":", ",", "3", "]", "-", "box", "[", ":", ",", "1", "]", "\n", "center_y", "=", "box", "[", ":", ",", "0", "]", "+", "0.5", "*", "height", "\n", "center_x", "=", "box", "[", ":", ",", "1", "]", "+", "0.5", "*", "width", "\n", "\n", "gt_height", "=", "gt_box", "[", ":", ",", "2", "]", "-", "gt_box", "[", ":", ",", "0", "]", "\n", "gt_width", "=", "gt_box", "[", ":", ",", "3", "]", "-", "gt_box", "[", ":", ",", "1", "]", "\n", "gt_center_y", "=", "gt_box", "[", ":", ",", "0", "]", "+", "0.5", "*", "gt_height", "\n", "gt_center_x", "=", "gt_box", "[", ":", ",", "1", "]", "+", "0.5", "*", "gt_width", "\n", "\n", "dy", "=", "(", "gt_center_y", "-", "center_y", ")", "/", "height", "\n", "dx", "=", "(", "gt_center_x", "-", "center_x", ")", "/", "width", "\n", "dh", "=", "np", ".", "log", "(", "gt_height", "/", "height", ")", "\n", "dw", "=", "np", ".", "log", "(", "gt_width", "/", "width", ")", "\n", "\n", "return", "np", ".", "stack", "(", "[", "dy", ",", "dx", ",", "dh", ",", "dw", "]", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.get_3d_bbox": [[635, 665], ["hasattr", "bbox_3d.transpose.transpose", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "get_3d_bbox", "(", "scale", ",", "shift", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Input: \n        scale: [3] or scalar\n        shift: [3] or scalar\n    Return \n        bbox_3d: [3, N]\n\n    \"\"\"", "\n", "if", "hasattr", "(", "scale", ",", "\"__iter__\"", ")", ":", "\n", "        ", "bbox_3d", "=", "np", ".", "array", "(", "[", "[", "scale", "[", "0", "]", "/", "2", ",", "+", "scale", "[", "1", "]", "/", "2", ",", "scale", "[", "2", "]", "/", "2", "]", ",", "\n", "[", "scale", "[", "0", "]", "/", "2", ",", "+", "scale", "[", "1", "]", "/", "2", ",", "-", "scale", "[", "2", "]", "/", "2", "]", ",", "\n", "[", "-", "scale", "[", "0", "]", "/", "2", ",", "+", "scale", "[", "1", "]", "/", "2", ",", "scale", "[", "2", "]", "/", "2", "]", ",", "\n", "[", "-", "scale", "[", "0", "]", "/", "2", ",", "+", "scale", "[", "1", "]", "/", "2", ",", "-", "scale", "[", "2", "]", "/", "2", "]", ",", "\n", "[", "+", "scale", "[", "0", "]", "/", "2", ",", "-", "scale", "[", "1", "]", "/", "2", ",", "scale", "[", "2", "]", "/", "2", "]", ",", "\n", "[", "+", "scale", "[", "0", "]", "/", "2", ",", "-", "scale", "[", "1", "]", "/", "2", ",", "-", "scale", "[", "2", "]", "/", "2", "]", ",", "\n", "[", "-", "scale", "[", "0", "]", "/", "2", ",", "-", "scale", "[", "1", "]", "/", "2", ",", "scale", "[", "2", "]", "/", "2", "]", ",", "\n", "[", "-", "scale", "[", "0", "]", "/", "2", ",", "-", "scale", "[", "1", "]", "/", "2", ",", "-", "scale", "[", "2", "]", "/", "2", "]", "]", ")", "+", "shift", "\n", "", "else", ":", "\n", "        ", "bbox_3d", "=", "np", ".", "array", "(", "[", "[", "scale", "/", "2", ",", "+", "scale", "/", "2", ",", "scale", "/", "2", "]", ",", "\n", "[", "scale", "/", "2", ",", "+", "scale", "/", "2", ",", "-", "scale", "/", "2", "]", ",", "\n", "[", "-", "scale", "/", "2", ",", "+", "scale", "/", "2", ",", "scale", "/", "2", "]", ",", "\n", "[", "-", "scale", "/", "2", ",", "+", "scale", "/", "2", ",", "-", "scale", "/", "2", "]", ",", "\n", "[", "+", "scale", "/", "2", ",", "-", "scale", "/", "2", ",", "scale", "/", "2", "]", ",", "\n", "[", "+", "scale", "/", "2", ",", "-", "scale", "/", "2", ",", "-", "scale", "/", "2", "]", ",", "\n", "[", "-", "scale", "/", "2", ",", "-", "scale", "/", "2", ",", "scale", "/", "2", "]", ",", "\n", "[", "-", "scale", "/", "2", ",", "-", "scale", "/", "2", ",", "-", "scale", "/", "2", "]", "]", ")", "+", "shift", "\n", "\n", "", "bbox_3d", "=", "bbox_3d", ".", "transpose", "(", ")", "\n", "return", "bbox_3d", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d": [[668, 682], ["numpy.vstack", "numpy.ones"], "function", ["None"], ["", "def", "transform_coordinates_3d", "(", "coordinates", ",", "RT", ")", ":", "\n", "    ", "\"\"\"\n    Input: \n        coordinates: [3, N]\n        RT: [4, 4]\n    Return \n        new_coordinates: [3, N]\n\n    \"\"\"", "\n", "assert", "coordinates", ".", "shape", "[", "0", "]", "==", "3", "\n", "coordinates", "=", "np", ".", "vstack", "(", "[", "coordinates", ",", "np", ".", "ones", "(", "(", "1", ",", "coordinates", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", "]", ")", "\n", "new_coordinates", "=", "RT", "@", "coordinates", "\n", "new_coordinates", "=", "new_coordinates", "[", ":", "3", ",", ":", "]", "/", "new_coordinates", "[", "3", ",", ":", "]", "\n", "return", "new_coordinates", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections": [[684, 698], ["np.array.transpose", "numpy.array"], "function", ["None"], ["", "def", "calculate_2d_projections", "(", "coordinates_3d", ",", "intrinsics", ")", ":", "\n", "    ", "\"\"\"\n    Input: \n        coordinates: [3, N]\n        intrinsics: [3, 3]\n    Return \n        projected_coordinates: [N, 2]\n    \"\"\"", "\n", "projected_coordinates", "=", "intrinsics", "@", "coordinates_3d", "\n", "projected_coordinates", "=", "projected_coordinates", "[", ":", "2", ",", ":", "]", "/", "projected_coordinates", "[", "2", ",", ":", "]", "\n", "projected_coordinates", "=", "projected_coordinates", ".", "transpose", "(", ")", "\n", "projected_coordinates", "=", "np", ".", "array", "(", "projected_coordinates", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "return", "projected_coordinates", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_rotation": [[705, 755], ["tuple", "numpy.vstack", "numpy.matrix", "max", "min", "max", "min", "int", "int", "numpy.matrix", "abs", "abs", "numpy.array", "cv2.getRotationMatrix2D", "numpy.matrix", "numpy.matrix", "int", "int", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "calculate_rotation", "(", "image_size", ",", "angle", ")", ":", "\n", "    ", "image_center", "=", "tuple", "(", "np", ".", "array", "(", "image_size", ")", "/", "2", ")", "\n", "\n", "# Convert the OpenCV 3x2 rotation matrix to 3x3", "\n", "rot_mat", "=", "np", ".", "vstack", "(", "\n", "[", "cv2", ".", "getRotationMatrix2D", "(", "image_center", ",", "angle", ",", "1.0", ")", ",", "[", "0", ",", "0", ",", "1", "]", "]", "\n", ")", "\n", "\n", "rot_mat_notranslate", "=", "np", ".", "matrix", "(", "rot_mat", "[", "0", ":", "2", ",", "0", ":", "2", "]", ")", "\n", "\n", "# Shorthand for below calcs", "\n", "image_w2", "=", "image_size", "[", "0", "]", "*", "0.5", "\n", "image_h2", "=", "image_size", "[", "1", "]", "*", "0.5", "\n", "\n", "# Obtain the rotated coordinates of the image corners", "\n", "rotated_coords", "=", "[", "\n", "(", "np", ".", "array", "(", "[", "-", "image_w2", ",", "image_h2", "]", ")", "*", "rot_mat_notranslate", ")", ".", "A", "[", "0", "]", ",", "\n", "(", "np", ".", "array", "(", "[", "image_w2", ",", "image_h2", "]", ")", "*", "rot_mat_notranslate", ")", ".", "A", "[", "0", "]", ",", "\n", "(", "np", ".", "array", "(", "[", "-", "image_w2", ",", "-", "image_h2", "]", ")", "*", "rot_mat_notranslate", ")", ".", "A", "[", "0", "]", ",", "\n", "(", "np", ".", "array", "(", "[", "image_w2", ",", "-", "image_h2", "]", ")", "*", "rot_mat_notranslate", ")", ".", "A", "[", "0", "]", "\n", "]", "\n", "\n", "# Find the size of the new image", "\n", "x_coords", "=", "[", "pt", "[", "0", "]", "for", "pt", "in", "rotated_coords", "]", "\n", "x_pos", "=", "[", "x", "for", "x", "in", "x_coords", "if", "x", ">", "0", "]", "\n", "x_neg", "=", "[", "x", "for", "x", "in", "x_coords", "if", "x", "<", "0", "]", "\n", "\n", "y_coords", "=", "[", "pt", "[", "1", "]", "for", "pt", "in", "rotated_coords", "]", "\n", "y_pos", "=", "[", "y", "for", "y", "in", "y_coords", "if", "y", ">", "0", "]", "\n", "y_neg", "=", "[", "y", "for", "y", "in", "y_coords", "if", "y", "<", "0", "]", "\n", "\n", "right_bound", "=", "max", "(", "x_pos", ")", "\n", "left_bound", "=", "min", "(", "x_neg", ")", "\n", "top_bound", "=", "max", "(", "y_pos", ")", "\n", "bot_bound", "=", "min", "(", "y_neg", ")", "\n", "\n", "new_w", "=", "int", "(", "abs", "(", "right_bound", "-", "left_bound", ")", ")", "\n", "new_h", "=", "int", "(", "abs", "(", "top_bound", "-", "bot_bound", ")", ")", "\n", "\n", "# We require a translation matrix to keep the image centred", "\n", "trans_mat", "=", "np", ".", "matrix", "(", "[", "\n", "[", "1", ",", "0", ",", "int", "(", "new_w", "*", "0.5", "-", "image_w2", ")", "]", ",", "\n", "[", "0", ",", "1", ",", "int", "(", "new_h", "*", "0.5", "-", "image_h2", ")", "]", ",", "\n", "[", "0", ",", "0", ",", "1", "]", "\n", "]", ")", "\n", "\n", "# Compute the tranform for the combined rotation and translation", "\n", "affine_mat", "=", "(", "np", ".", "matrix", "(", "trans_mat", ")", "*", "np", ".", "matrix", "(", "rot_mat", ")", ")", "[", "0", ":", "2", ",", ":", "]", "\n", "\n", "return", "new_w", ",", "new_h", ",", "affine_mat", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.rotate_image": [[758, 777], ["cv2.warpAffine", "cv2.INTER_LINEAR", "cv2.INTER_NEAREST", "cv2.INTER_NEAREST"], "function", ["None"], ["", "def", "rotate_image", "(", "image", ",", "new_w", ",", "new_h", ",", "affine_mat", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", ":", "\n", "    ", "\"\"\"\n    Rotates an OpenCV 2 / NumPy image about it's centre by the given angle\n    (in degrees). The returned image will be large enough to hold the entire\n    new image, with a black background\n    \"\"\"", "\n", "\n", "# Get the image size", "\n", "# No that's not an error - NumPy stores image matricies backwards", "\n", "\n", "# Apply the transform", "\n", "result", "=", "cv2", ".", "warpAffine", "(", "\n", "image", ",", "\n", "affine_mat", ",", "\n", "(", "new_w", ",", "new_h", ")", ",", "\n", "flags", "=", "interpolation", "\n", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.largest_rotated_rect": [[779, 812], ["int", "math.atan2", "math.atan2", "math.cos", "math.sin", "math.cos", "math.tan", "math.floor", "math.cos", "math.sin", "math.sin", "math.cos", "math.sin"], "function", ["None"], ["", "def", "largest_rotated_rect", "(", "w", ",", "h", ",", "angle", ")", ":", "\n", "    ", "\"\"\"\n    Given a rectangle of size wxh that has been rotated by 'angle' (in\n    radians), computes the width and height of the largest possible\n    axis-aligned rectangle within the rotated rectangle.\n\n    Original JS code by 'Andri' and Magnus Hoff from Stack Overflow\n\n    Converted to Python by Aaron Snoswell\n    \"\"\"", "\n", "\n", "quadrant", "=", "int", "(", "math", ".", "floor", "(", "angle", "/", "(", "math", ".", "pi", "/", "2", ")", ")", ")", "&", "3", "\n", "sign_alpha", "=", "angle", "if", "(", "(", "quadrant", "&", "1", ")", "==", "0", ")", "else", "math", ".", "pi", "-", "angle", "\n", "alpha", "=", "(", "sign_alpha", "%", "math", ".", "pi", "+", "math", ".", "pi", ")", "%", "math", ".", "pi", "\n", "\n", "bb_w", "=", "w", "*", "math", ".", "cos", "(", "alpha", ")", "+", "h", "*", "math", ".", "sin", "(", "alpha", ")", "\n", "bb_h", "=", "w", "*", "math", ".", "sin", "(", "alpha", ")", "+", "h", "*", "math", ".", "cos", "(", "alpha", ")", "\n", "\n", "gamma", "=", "math", ".", "atan2", "(", "bb_w", ",", "bb_w", ")", "if", "(", "w", "<", "h", ")", "else", "math", ".", "atan2", "(", "bb_w", ",", "bb_w", ")", "\n", "\n", "delta", "=", "math", ".", "pi", "-", "alpha", "-", "gamma", "\n", "\n", "length", "=", "h", "if", "(", "w", "<", "h", ")", "else", "w", "\n", "\n", "d", "=", "length", "*", "math", ".", "cos", "(", "alpha", ")", "\n", "a", "=", "d", "*", "math", ".", "sin", "(", "alpha", ")", "/", "math", ".", "sin", "(", "delta", ")", "\n", "\n", "y", "=", "a", "*", "math", ".", "cos", "(", "gamma", ")", "\n", "x", "=", "y", "*", "math", ".", "tan", "(", "gamma", ")", "\n", "\n", "return", "(", "\n", "bb_w", "-", "2", "*", "x", ",", "\n", "bb_h", "-", "2", "*", "y", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.crop_around_center": [[815, 836], ["int", "int", "int", "int", "int", "int"], "function", ["None"], ["", "def", "crop_around_center", "(", "image", ",", "width", ",", "height", ")", ":", "\n", "    ", "\"\"\"\n    Given a NumPy / OpenCV 2 image, crops it to the given width and height,\n    around it's centre point\n    \"\"\"", "\n", "\n", "image_size", "=", "(", "image", ".", "shape", "[", "1", "]", ",", "image", ".", "shape", "[", "0", "]", ")", "\n", "image_center", "=", "(", "int", "(", "image_size", "[", "0", "]", "*", "0.5", ")", ",", "int", "(", "image_size", "[", "1", "]", "*", "0.5", ")", ")", "\n", "\n", "if", "(", "width", ">", "image_size", "[", "0", "]", ")", ":", "\n", "        ", "width", "=", "image_size", "[", "0", "]", "\n", "\n", "", "if", "(", "height", ">", "image_size", "[", "1", "]", ")", ":", "\n", "        ", "height", "=", "image_size", "[", "1", "]", "\n", "\n", "", "x1", "=", "int", "(", "image_center", "[", "0", "]", "-", "width", "*", "0.5", ")", "\n", "x2", "=", "int", "(", "image_center", "[", "0", "]", "+", "width", "*", "0.5", ")", "\n", "y1", "=", "int", "(", "image_center", "[", "1", "]", "-", "height", "*", "0.5", ")", "\n", "y2", "=", "int", "(", "image_center", "[", "1", "]", "+", "height", "*", "0.5", ")", "\n", "\n", "return", "image", "[", "y1", ":", "y2", ",", "x1", ":", "x2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.rotate_and_crop": [[837, 853], ["utils.calculate_rotation", "utils.rotate_image", "utils.crop_around_center", "utils.largest_rotated_rect", "math.radians"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_rotation", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.rotate_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.crop_around_center", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.largest_rotated_rect"], ["", "def", "rotate_and_crop", "(", "image", ",", "rotate_degree", ",", "interpolation", ")", ":", "\n", "    ", "image_height", ",", "image_width", "=", "image", ".", "shape", "[", "0", ":", "2", "]", "\n", "\n", "\n", "new_w", ",", "new_h", ",", "affine_mat", "=", "calculate_rotation", "(", "image", ".", "shape", "[", "0", ":", "2", "]", "[", ":", ":", "-", "1", "]", ",", "rotate_degree", ")", "\n", "image_rotated", "=", "rotate_image", "(", "image", ",", "new_w", ",", "new_h", ",", "affine_mat", ",", "interpolation", ")", "\n", "image_rotated_cropped", "=", "crop_around_center", "(", "\n", "image_rotated", ",", "\n", "*", "largest_rotated_rect", "(", "\n", "image_width", ",", "\n", "image_height", ",", "\n", "math", ".", "radians", "(", "rotate_degree", ")", "\n", ")", "\n", ")", "\n", "\n", "return", "image_rotated_cropped", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.rotate_and_crop_images": [[855, 883], ["utils.calculate_rotation", "utils.rotate_image", "utils.rotate_image", "utils.largest_rotated_rect", "utils.crop_around_center", "utils.crop_around_center", "cv2.resize", "cv2.resize", "math.radians", "utils.rotate_image", "utils.crop_around_center", "cv2.resize"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_rotation", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.rotate_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.rotate_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.largest_rotated_rect", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.crop_around_center", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.crop_around_center", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.rotate_image", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.crop_around_center"], ["", "def", "rotate_and_crop_images", "(", "image", ",", "masks", ",", "coords", ",", "rotate_degree", ")", ":", "\n", "\n", "    ", "image_height", ",", "image_width", "=", "image", ".", "shape", "[", "0", ":", "2", "]", "\n", "new_w", ",", "new_h", ",", "affine_mat", "=", "calculate_rotation", "(", "image", ".", "shape", "[", "0", ":", "2", "]", "[", ":", ":", "-", "1", "]", ",", "rotate_degree", ")", "\n", "\n", "image_rotated", "=", "rotate_image", "(", "image", ",", "new_w", ",", "new_h", ",", "affine_mat", ",", "cv2", ".", "INTER_LINEAR", ")", "\n", "mask_rotated", "=", "rotate_image", "(", "masks", ",", "new_w", ",", "new_h", ",", "affine_mat", ",", "cv2", ".", "INTER_NEAREST", ")", "\n", "\n", "rect", "=", "largest_rotated_rect", "(", "\n", "image_width", ",", "\n", "image_height", ",", "\n", "math", ".", "radians", "(", "rotate_degree", ")", "\n", ")", "\n", "\n", "image_rotated_cropped", "=", "crop_around_center", "(", "image_rotated", ",", "*", "rect", ")", "\n", "mask_rotated_cropped", "=", "crop_around_center", "(", "mask_rotated", ",", "*", "rect", ")", "\n", "\n", "image_rotated_cropped", "=", "cv2", ".", "resize", "(", "image_rotated_cropped", ",", "(", "image_width", ",", "image_height", ")", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", "\n", "mask_rotated_cropped", "=", "cv2", ".", "resize", "(", "mask_rotated_cropped", ",", "(", "image_width", ",", "image_height", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "\n", "if", "coords", "is", "not", "None", ":", "\n", "        ", "coord_rotated", "=", "rotate_image", "(", "coords", ",", "new_w", ",", "new_h", ",", "affine_mat", ",", "cv2", ".", "INTER_NEAREST", ")", "\n", "coord_rotated_cropped", "=", "crop_around_center", "(", "coord_rotated", ",", "*", "rect", ")", "\n", "coord_rotated_cropped", "=", "cv2", ".", "resize", "(", "coord_rotated_cropped", ",", "(", "image_width", ",", "image_height", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "\n", "return", "image_rotated_cropped", ",", "mask_rotated_cropped", ",", "coord_rotated_cropped", "\n", "", "else", ":", "\n", "        ", "return", "image_rotated_cropped", ",", "mask_rotated_cropped", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.resize_image": [[1069, 1116], ["max", "max", "scipy.misc.imresize", "numpy.pad", "round", "min", "round", "round"], "function", ["None"], ["", "", "def", "resize_image", "(", "image", ",", "min_dim", "=", "None", ",", "max_dim", "=", "None", ",", "padding", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Resizes an image keeping the aspect ratio.\n    min_dim: if provided, resizes the image such that it's smaller\n        dimension == min_dim\n    max_dim: if provided, ensures that the image longest side doesn't\n        exceed this value.\n    padding: If true, pads image with zeros so it's size is max_dim x max_dim\n    Returns:\n    image: the resized image\n    window: (y1, x1, y2, x2). If max_dim is provided, padding might\n        be inserted in the returned image. If so, this window is the\n        coordinates of the image part of the full image (excluding\n        the padding). The x2, y2 pixels are not included.\n    scale: The scale factor used to resize the image\n    padding: Padding added to the image [(top, bottom), (left, right), (0, 0)]\n    \"\"\"", "\n", "# Default window (y1, x1, y2, x2) and default scale == 1.", "\n", "h", ",", "w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "window", "=", "(", "0", ",", "0", ",", "h", ",", "w", ")", "\n", "scale", "=", "1", "\n", "\n", "# Scale?", "\n", "if", "min_dim", ":", "\n", "# Scale up but not down", "\n", "        ", "scale", "=", "max", "(", "1", ",", "min_dim", "/", "min", "(", "h", ",", "w", ")", ")", "\n", "# Does it exceed max dim?", "\n", "", "if", "max_dim", ":", "\n", "        ", "image_max", "=", "max", "(", "h", ",", "w", ")", "\n", "if", "round", "(", "image_max", "*", "scale", ")", ">", "max_dim", ":", "\n", "            ", "scale", "=", "max_dim", "/", "image_max", "\n", "# Resize image and mask", "\n", "", "", "if", "scale", "!=", "1", ":", "\n", "        ", "image", "=", "scipy", ".", "misc", ".", "imresize", "(", "\n", "image", ",", "(", "round", "(", "h", "*", "scale", ")", ",", "round", "(", "w", "*", "scale", ")", ")", ")", "\n", "# Need padding?", "\n", "", "if", "padding", ":", "\n", "# Get new height and width", "\n", "        ", "h", ",", "w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "top_pad", "=", "(", "max_dim", "-", "h", ")", "//", "2", "\n", "bottom_pad", "=", "max_dim", "-", "h", "-", "top_pad", "\n", "left_pad", "=", "(", "max_dim", "-", "w", ")", "//", "2", "\n", "right_pad", "=", "max_dim", "-", "w", "-", "left_pad", "\n", "padding", "=", "[", "(", "top_pad", ",", "bottom_pad", ")", ",", "(", "left_pad", ",", "right_pad", ")", ",", "(", "0", ",", "0", ")", "]", "\n", "image", "=", "np", ".", "pad", "(", "image", ",", "padding", ",", "mode", "=", "'constant'", ",", "constant_values", "=", "0", ")", "\n", "window", "=", "(", "top_pad", ",", "left_pad", ",", "h", "+", "top_pad", ",", "w", "+", "left_pad", ")", "\n", "", "return", "image", ",", "window", ",", "scale", ",", "padding", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.resize_mask": [[1118, 1141], ["numpy.pad", "len", "scipy.ndimage.zoom", "len", "scipy.ndimage.zoom"], "function", ["None"], ["", "def", "resize_mask", "(", "mask", ",", "scale", ",", "padding", ")", ":", "\n", "    ", "\"\"\"Resizes a mask using the given scale and padding.\n    Typically, you get the scale and padding from resize_image() to\n    ensure both, the image, the mask, and the coordinate map are resized consistently.\n    scale: mask scaling factor\n    padding: Padding to add to the mask in the form\n            [(top, bottom), (left, right), (0, 0)]\n    \"\"\"", "\n", "h", ",", "w", "=", "mask", ".", "shape", "[", ":", "2", "]", "\n", "# for instance mask", "\n", "if", "len", "(", "mask", ".", "shape", ")", "==", "3", ":", "\n", "        ", "mask", "=", "scipy", ".", "ndimage", ".", "zoom", "(", "mask", ",", "zoom", "=", "[", "scale", ",", "scale", ",", "1", "]", ",", "order", "=", "0", ")", "\n", "new_padding", "=", "padding", "\n", "# for coordinate map", "\n", "", "elif", "len", "(", "mask", ".", "shape", ")", "==", "4", ":", "\n", "        ", "mask", "=", "scipy", ".", "ndimage", ".", "zoom", "(", "mask", ",", "zoom", "=", "[", "scale", ",", "scale", ",", "1", ",", "1", "]", ",", "order", "=", "0", ")", "\n", "new_padding", "=", "padding", "+", "[", "(", "0", ",", "0", ")", "]", "\n", "", "else", ":", "\n", "        ", "assert", "False", "\n", "\n", "", "mask", "=", "np", ".", "pad", "(", "mask", ",", "new_padding", ",", "mode", "=", "'constant'", ",", "constant_values", "=", "0", ")", "\n", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.minimize_mask": [[1143, 1173], ["len", "numpy.zeros", "range", "scipy.misc.imresize", "numpy.where", "len", "numpy.zeros", "range", "scipy.misc.imresize.astype", "scipy.misc.imresize", "scipy.misc.imresize.astype", "scipy.misc.imresize.astype"], "function", ["None"], ["", "def", "minimize_mask", "(", "bbox", ",", "mask", ",", "mini_shape", ")", ":", "\n", "    ", "\"\"\"Resize masks to a smaller version to cut memory load.\n    Mini-masks can then resized back to image scale using expand_masks()\n    See inspect_data.ipynb notebook for more details.\n    \"\"\"", "\n", "# for instance mask", "\n", "if", "len", "(", "mask", ".", "shape", ")", "==", "3", ":", "\n", "        ", "mini_mask", "=", "np", ".", "zeros", "(", "mini_shape", "+", "(", "mask", ".", "shape", "[", "-", "1", "]", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "            ", "m", "=", "mask", "[", ":", ",", ":", ",", "i", "]", "\n", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "bbox", "[", "i", "]", "[", ":", "4", "]", "\n", "m", "=", "m", "[", "y1", ":", "y2", ",", "x1", ":", "x2", "]", "*", "255", "\n", "m", "=", "scipy", ".", "misc", ".", "imresize", "(", "m", ".", "astype", "(", "np", ".", "uint8", ")", ",", "mini_shape", ",", "interp", "=", "'nearest'", ")", "\n", "mini_mask", "[", ":", ",", ":", ",", "i", "]", "=", "np", ".", "where", "(", "m", ">=", "128", ",", "1", ",", "0", ")", "\n", "\n", "# for coordinate map", "\n", "", "", "elif", "len", "(", "mask", ".", "shape", ")", "==", "4", ":", "\n", "        ", "assert", "mask", ".", "shape", "[", "-", "1", "]", "==", "3", "## coordinate map", "\n", "\n", "mini_mask", "=", "np", ".", "zeros", "(", "mini_shape", "+", "mask", ".", "shape", "[", "-", "2", ":", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "2", "]", ")", ":", "\n", "            ", "m", "=", "mask", "[", ":", ",", ":", ",", "i", ",", ":", "]", "\n", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "bbox", "[", "i", "]", "[", ":", "4", "]", "\n", "m", "=", "m", "[", "y1", ":", "y2", ",", "x1", ":", "x2", ",", ":", "]", "*", "255", "\n", "m", "=", "scipy", ".", "misc", ".", "imresize", "(", "m", ".", "astype", "(", "np", ".", "uint8", ")", ",", "mini_shape", "+", "(", "mask", ".", "shape", "[", "-", "1", "]", ",", ")", ",", "interp", "=", "'nearest'", ")", "\n", "mini_mask", "[", ":", ",", ":", ",", "i", ",", ":", "]", "=", "m", ".", "astype", "(", "float", ")", "/", "255", "\n", "\n", "", "", "else", ":", "\n", "        ", "assert", "False", "\n", "", "return", "mini_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.expand_mask": [[1175, 1202], ["len", "numpy.zeros", "range", "scipy.misc.imresize", "numpy.where", "len", "numpy.zeros", "range", "scipy.misc.imresize.astype", "scipy.misc.imresize", "scipy.misc.imresize.astype"], "function", ["None"], ["", "def", "expand_mask", "(", "bbox", ",", "mini_mask", ",", "image_shape", ")", ":", "\n", "    ", "\"\"\"Resizes mini masks back to image size. Reverses the change\n    of minimize_mask().\n    See inspect_data.ipynb notebook for more details.\n    \"\"\"", "\n", "# for instance mask", "\n", "if", "len", "(", "mini_mask", ".", "shape", ")", "==", "3", ":", "\n", "        ", "mask", "=", "np", ".", "zeros", "(", "image_shape", "[", ":", "2", "]", "+", "(", "mini_mask", ".", "shape", "[", "-", "1", "]", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "            ", "m", "=", "mini_mask", "[", ":", ",", ":", ",", "i", "]", "\n", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "bbox", "[", "i", "]", "[", ":", "4", "]", "\n", "h", "=", "y2", "-", "y1", "\n", "w", "=", "x2", "-", "x1", "\n", "m", "=", "scipy", ".", "misc", ".", "imresize", "(", "m", ".", "astype", "(", "float", ")", ",", "(", "h", ",", "w", ")", ",", "interp", "=", "'bilinear'", ")", "\n", "mask", "[", "y1", ":", "y2", ",", "x1", ":", "x2", ",", "i", "]", "=", "np", ".", "where", "(", "m", ">=", "128", ",", "1", ",", "0", ")", "\n", "", "", "elif", "len", "(", "mini_mask", ".", "shape", ")", "==", "4", ":", "\n", "        ", "assert", "mini_mask", ".", "shape", "[", "-", "1", "]", "==", "3", "## coordinate map", "\n", "mask", "=", "np", ".", "zeros", "(", "image_shape", "[", ":", "2", "]", "+", "mini_mask", ".", "shape", "[", "-", "2", ":", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "mask", ".", "shape", "[", "-", "2", "]", ")", ":", "\n", "            ", "m", "=", "mini_mask", "[", ":", ",", ":", ",", "i", ",", ":", "]", "\n", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "bbox", "[", "i", "]", "[", ":", "4", "]", "\n", "h", "=", "y2", "-", "y1", "\n", "w", "=", "x2", "-", "x1", "\n", "m", "=", "scipy", ".", "misc", ".", "imresize", "(", "m", ".", "astype", "(", "float", ")", ",", "(", "h", ",", "w", ",", "mini_mask", ".", "shape", "[", "-", "1", "]", ")", ",", "interp", "=", "'nearest'", ")", "\n", "mask", "[", "y1", ":", "y2", ",", "x1", ":", "x2", ",", "i", ",", ":", "]", "=", "m", "\n", "\n", "", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.mold_mask": [[1205, 1207], ["None"], "function", ["None"], ["", "def", "mold_mask", "(", "mask", ",", "config", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.unmold_mask": [[1209, 1226], ["numpy.where().astype", "numpy.zeros", "scipy.misc.imresize().astype", "numpy.where", "scipy.misc.imresize"], "function", ["None"], ["", "def", "unmold_mask", "(", "mask", ",", "bbox", ",", "image_shape", ")", ":", "\n", "    ", "\"\"\"Converts a mask generated by the neural network into a format similar\n    to it's original shape.\n    mask: [height, width] of type float. A small, typically 28x28 mask.\n    bbox: [y1, x1, y2, x2]. The box to fit the mask in.\n    Returns a binary mask with the same size as the original image.\n    \"\"\"", "\n", "threshold", "=", "0.5", "\n", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "bbox", "\n", "mask", "=", "scipy", ".", "misc", ".", "imresize", "(", "\n", "mask", ",", "(", "y2", "-", "y1", ",", "x2", "-", "x1", ")", ",", "interp", "=", "'bilinear'", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.0", "\n", "mask", "=", "np", ".", "where", "(", "mask", ">=", "threshold", ",", "1", ",", "0", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "# Put the mask in the right location.", "\n", "full_mask", "=", "np", ".", "zeros", "(", "image_shape", "[", ":", "2", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "full_mask", "[", "y1", ":", "y2", ",", "x1", ":", "x2", "]", "=", "mask", "\n", "return", "full_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.unmold_coord": [[1227, 1260], ["cv2.resize", "numpy.zeros"], "function", ["None"], ["", "def", "unmold_coord", "(", "coord", ",", "bbox", ",", "image_shape", ")", ":", "\n", "    ", "\"\"\"Converts a mask generated by the neural network into a format similar\n    to it's original shape.\n    coord: [height, width, 3] of type float. A small, typically 28x28 mask.\n    bbox: [y1, x1, y2, x2]. The box to fit the mask in.\n    Returns a coordinate map with the same size as the original image.\n    \"\"\"", "\n", "y1", ",", "x1", ",", "y2", ",", "x2", "=", "bbox", "\n", "\n", "#max_coord_x = np.amax(coord[:, :, 0])", "\n", "#max_coord_y = np.amax(coord[:, :, 1])", "\n", "#max_coord_z = np.amax(coord[:, :, 2])", "\n", "\n", "#print('before resize:')", "\n", "#print(max_coord_x, max_coord_y, max_coord_z)", "\n", "\n", "#coord = scipy.misc.imresize(", "\n", "#    coord, (y2 - y1, x2 - x1, 3), interp='nearest').astype(np.float32)/ 255.0", "\n", "#    #coord, (y2 - y1, x2 - x1, 3), interp='bilinear').astype(np.uint8)", "\n", "coord", "=", "cv2", ".", "resize", "(", "coord", ",", "(", "x2", "-", "x1", ",", "y2", "-", "y1", ")", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", "\n", "\n", "#max_coord_x_resize = np.amax(coord[:, :, 0])", "\n", "#max_coord_y_resize = np.amax(coord[:, :, 1])", "\n", "#max_coord_z_resize = np.amax(coord[:, :, 2])", "\n", "\n", "#print('after resize:')", "\n", "#print(max_coord_x_resize, max_coord_y_resize, max_coord_z_resize)", "\n", "\n", "\n", "# Put the mask in the right location.", "\n", "full_coord", "=", "np", ".", "zeros", "(", "image_shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "full_coord", "[", "y1", ":", "y2", ",", "x1", ":", "x2", ",", ":", "]", "=", "coord", "\n", "return", "full_coord", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.annToRLE": [[1262, 1280], ["isinstance", "pycocotools.mask.frPyObjects", "pycocotools.mask.merge", "isinstance", "pycocotools.mask.frPyObjects"], "function", ["None"], ["", "def", "annToRLE", "(", "ann", ",", "height", ",", "width", ")", ":", "\n", "    ", "\"\"\"\n    Convert annotation which can be polygons, uncompressed RLE to RLE.\n    :return: binary mask (numpy 2D array)\n    \"\"\"", "\n", "segm", "=", "ann", "[", "'segmentation'", "]", "\n", "if", "isinstance", "(", "segm", ",", "list", ")", ":", "\n", "# polygon -- a single object might consist of multiple parts", "\n", "# we merge all parts into one mask rle code", "\n", "        ", "rles", "=", "maskUtils", ".", "frPyObjects", "(", "segm", ",", "height", ",", "width", ")", "\n", "rle", "=", "maskUtils", ".", "merge", "(", "rles", ")", "\n", "", "elif", "isinstance", "(", "segm", "[", "'counts'", "]", ",", "list", ")", ":", "\n", "# uncompressed RLE", "\n", "        ", "rle", "=", "maskUtils", ".", "frPyObjects", "(", "segm", ",", "height", ",", "width", ")", "\n", "", "else", ":", "\n", "# rle", "\n", "        ", "rle", "=", "ann", "[", "'segmentation'", "]", "\n", "", "return", "rle", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.annToMask": [[1281, 1289], ["utils.annToRLE", "pycocotools.mask.decode"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.annToRLE"], ["", "def", "annToMask", "(", "ann", ",", "height", ",", "width", ")", ":", "\n", "    ", "\"\"\"\n    Convert annotation which can be polygons, uncompressed RLE, or RLE to binary mask.\n    :return: binary mask (numpy 2D array)\n    \"\"\"", "\n", "rle", "=", "annToRLE", "(", "ann", ",", "height", ",", "width", ")", "\n", "m", "=", "maskUtils", ".", "decode", "(", "rle", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.generate_anchors": [[1295, 1332], ["numpy.meshgrid", "scales.flatten.flatten", "ratios.flatten.flatten", "numpy.meshgrid", "numpy.meshgrid", "numpy.meshgrid", "numpy.stack().reshape", "numpy.stack().reshape", "numpy.concatenate", "numpy.array", "numpy.array", "numpy.sqrt", "numpy.sqrt", "numpy.arange", "numpy.arange", "numpy.stack", "numpy.stack"], "function", ["None"], ["", "def", "generate_anchors", "(", "scales", ",", "ratios", ",", "shape", ",", "feature_stride", ",", "anchor_stride", ")", ":", "\n", "    ", "\"\"\"\n    scales: 1D array of anchor sizes in pixels. Example: [32, 64, 128]\n    ratios: 1D array of anchor ratios of width/height. Example: [0.5, 1, 2]\n    shape: [height, width] spatial shape of the feature map over which\n            to generate anchors.\n    feature_stride: Stride of the feature map relative to the image in pixels.\n    anchor_stride: Stride of anchors on the feature map. For example, if the\n        value is 2 then generate anchors for every other feature map pixel.\n    \"\"\"", "\n", "# Get all combinations of scales and ratios", "\n", "scales", ",", "ratios", "=", "np", ".", "meshgrid", "(", "np", ".", "array", "(", "scales", ")", ",", "np", ".", "array", "(", "ratios", ")", ")", "\n", "scales", "=", "scales", ".", "flatten", "(", ")", "\n", "ratios", "=", "ratios", ".", "flatten", "(", ")", "\n", "\n", "# Enumerate heights and widths from scales and ratios", "\n", "heights", "=", "scales", "/", "np", ".", "sqrt", "(", "ratios", ")", "\n", "widths", "=", "scales", "*", "np", ".", "sqrt", "(", "ratios", ")", "\n", "\n", "# Enumerate shifts in feature space", "\n", "shifts_y", "=", "np", ".", "arange", "(", "0", ",", "shape", "[", "0", "]", ",", "anchor_stride", ")", "*", "feature_stride", "\n", "shifts_x", "=", "np", ".", "arange", "(", "0", ",", "shape", "[", "1", "]", ",", "anchor_stride", ")", "*", "feature_stride", "\n", "shifts_x", ",", "shifts_y", "=", "np", ".", "meshgrid", "(", "shifts_x", ",", "shifts_y", ")", "\n", "\n", "# Enumerate combinations of shifts, widths, and heights", "\n", "box_widths", ",", "box_centers_x", "=", "np", ".", "meshgrid", "(", "widths", ",", "shifts_x", ")", "\n", "box_heights", ",", "box_centers_y", "=", "np", ".", "meshgrid", "(", "heights", ",", "shifts_y", ")", "\n", "\n", "# Reshape to get a list of (y, x) and a list of (h, w)", "\n", "box_centers", "=", "np", ".", "stack", "(", "\n", "[", "box_centers_y", ",", "box_centers_x", "]", ",", "axis", "=", "2", ")", ".", "reshape", "(", "[", "-", "1", ",", "2", "]", ")", "\n", "box_sizes", "=", "np", ".", "stack", "(", "[", "box_heights", ",", "box_widths", "]", ",", "axis", "=", "2", ")", ".", "reshape", "(", "[", "-", "1", ",", "2", "]", ")", "\n", "\n", "# Convert to corner coordinates (y1, x1, y2, x2)", "\n", "boxes", "=", "np", ".", "concatenate", "(", "[", "box_centers", "-", "0.5", "*", "box_sizes", ",", "\n", "box_centers", "+", "0.5", "*", "box_sizes", "]", ",", "axis", "=", "1", ")", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.generate_pyramid_anchors": [[1334, 1351], ["range", "numpy.concatenate", "len", "anchors.append", "utils.generate_anchors"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.generate_anchors"], ["", "def", "generate_pyramid_anchors", "(", "scales", ",", "ratios", ",", "feature_shapes", ",", "feature_strides", ",", "\n", "anchor_stride", ")", ":", "\n", "    ", "\"\"\"Generate anchors at different levels of a feature pyramid. Each scale\n    is associated with a level of the pyramid, but each ratio is used in\n    all levels of the pyramid.\n    Returns:\n    anchors: [N, (y1, x1, y2, x2)]. All generated anchors in one array. Sorted\n        with the same order of the given scales. So, anchors of scale[0] come\n        first, then anchors of scale[1], and so on.\n    \"\"\"", "\n", "# Anchors", "\n", "# [anchor_count, (y1, x1, y2, x2)]", "\n", "anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "scales", ")", ")", ":", "\n", "        ", "anchors", ".", "append", "(", "generate_anchors", "(", "scales", "[", "i", "]", ",", "ratios", ",", "feature_shapes", "[", "i", "]", ",", "\n", "feature_strides", "[", "i", "]", ",", "anchor_stride", ")", ")", "\n", "", "return", "np", ".", "concatenate", "(", "anchors", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.trim_zeros": [[1357, 1371], ["len", "numpy.all"], "function", ["None"], ["", "def", "trim_zeros", "(", "x", ")", ":", "\n", "    ", "\"\"\"It's common to have tensors larger than the available data and\n    pad with zeros. This function removes rows that are all zeros.\n    x: [rows, columns].\n    \"\"\"", "\n", "\n", "pre_shape", "=", "x", ".", "shape", "\n", "assert", "len", "(", "x", ".", "shape", ")", "==", "2", ",", "x", ".", "shape", "\n", "new_x", "=", "x", "[", "~", "np", ".", "all", "(", "x", "==", "0", ",", "axis", "=", "1", ")", "]", "\n", "post_shape", "=", "new_x", ".", "shape", "\n", "assert", "pre_shape", "[", "0", "]", "==", "post_shape", "[", "0", "]", "\n", "assert", "pre_shape", "[", "1", "]", "==", "post_shape", "[", "1", "]", "\n", "\n", "return", "new_x", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_matches": [[1373, 1443], ["len", "utils.trim_zeros", "len", "len", "utils.trim_zeros", "len", "utils.compute_overlaps_masks", "range", "numpy.argsort", "numpy.ones", "numpy.ones", "len", "len", "len", "numpy.zeros", "numpy.argsort", "numpy.where", "numpy.ones", "numpy.ones", "len", "len"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.trim_zeros", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.trim_zeros", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_overlaps_masks"], ["", "def", "compute_matches", "(", "gt_boxes", ",", "gt_class_ids", ",", "gt_masks", ",", "\n", "pred_boxes", ",", "pred_class_ids", ",", "pred_scores", ",", "pred_masks", ",", "\n", "iou_threshold", "=", "0.5", ",", "score_threshold", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"Finds matches between prediction and ground truth instances.\n    Returns:\n        gt_match: 1-D array. For each GT box it has the index of the matched\n                  predicted box.\n        pred_match: 1-D array. For each predicted box, it has the index of\n                    the matched ground truth box.\n        overlaps: [pred_boxes, gt_boxes] IoU overlaps.\n    \"\"\"", "\n", "# Trim zero padding", "\n", "# TODO: cleaner to do zero unpadding upstream", "\n", "if", "len", "(", "gt_class_ids", ")", "==", "0", "or", "len", "(", "pred_class_ids", ")", "==", "0", ":", "\n", "        ", "return", "-", "1", "*", "np", ".", "ones", "(", "[", "len", "(", "gt_class_ids", ")", "]", ")", ",", "-", "1", "*", "np", ".", "ones", "(", "[", "len", "(", "pred_class_ids", ")", "]", ")", ",", "None", ",", "np", ".", "zeros", "(", "[", "0", "]", ")", "\n", "\n", "", "pre_len", "=", "len", "(", "gt_boxes", ")", "\n", "gt_boxes", "=", "trim_zeros", "(", "gt_boxes", ")", "\n", "after_len", "=", "len", "(", "gt_boxes", ")", "\n", "assert", "pre_len", "==", "after_len", "\n", "gt_masks", "=", "gt_masks", "[", "...", ",", ":", "gt_boxes", ".", "shape", "[", "0", "]", "]", "\n", "\n", "pre_len", "=", "len", "(", "pred_boxes", ")", "\n", "pred_boxes", "=", "trim_zeros", "(", "pred_boxes", ")", "\n", "after_len", "=", "len", "(", "pred_boxes", ")", "\n", "assert", "pre_len", "==", "after_len", "\n", "pred_scores", "=", "pred_scores", "[", ":", "pred_boxes", ".", "shape", "[", "0", "]", "]", "\n", "\n", "# Sort predictions by score from high to low", "\n", "indices", "=", "np", ".", "argsort", "(", "pred_scores", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "pred_boxes", "=", "pred_boxes", "[", "indices", "]", "\n", "pred_class_ids", "=", "pred_class_ids", "[", "indices", "]", "\n", "pred_scores", "=", "pred_scores", "[", "indices", "]", "\n", "pred_masks", "=", "pred_masks", "[", "...", ",", "indices", "]", "\n", "\n", "# Compute IoU overlaps [pred_masks, gt_masks]", "\n", "overlaps", "=", "compute_overlaps_masks", "(", "pred_masks", ",", "gt_masks", ")", "\n", "\n", "# Loop through predictions and find matching ground truth boxes", "\n", "match_count", "=", "0", "\n", "pred_match", "=", "-", "1", "*", "np", ".", "ones", "(", "[", "pred_boxes", ".", "shape", "[", "0", "]", "]", ")", "\n", "gt_match", "=", "-", "1", "*", "np", ".", "ones", "(", "[", "gt_boxes", ".", "shape", "[", "0", "]", "]", ")", "\n", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "pred_boxes", ")", ")", ":", "\n", "# Find best matching ground truth box", "\n", "# 1. Sort matches by score", "\n", "        ", "sorted_ixs", "=", "np", ".", "argsort", "(", "overlaps", "[", "i", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "# 2. Remove low scores", "\n", "low_score_idx", "=", "np", ".", "where", "(", "overlaps", "[", "i", ",", "sorted_ixs", "]", "<", "score_threshold", ")", "[", "0", "]", "\n", "if", "low_score_idx", ".", "size", ">", "0", ":", "\n", "            ", "sorted_ixs", "=", "sorted_ixs", "[", ":", "low_score_idx", "[", "0", "]", "]", "\n", "# 3. Find the match", "\n", "", "for", "j", "in", "sorted_ixs", ":", "\n", "# If ground truth box is already matched, go to next one", "\n", "            ", "if", "gt_match", "[", "j", "]", ">", "-", "1", ":", "\n", "                ", "continue", "\n", "# If we reach IoU smaller than the threshold, end the loop", "\n", "", "iou", "=", "overlaps", "[", "i", ",", "j", "]", "\n", "if", "iou", "<", "iou_threshold", ":", "\n", "                ", "break", "\n", "# Do we have a match?", "\n", "", "if", "pred_class_ids", "[", "i", "]", "==", "gt_class_ids", "[", "j", "]", ":", "\n", "                ", "match_count", "+=", "1", "\n", "gt_match", "[", "j", "]", "=", "i", "\n", "pred_match", "[", "i", "]", "=", "j", "\n", "break", "\n", "\n", "", "", "", "return", "gt_match", ",", "pred_match", ",", "overlaps", ",", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_3d_matches": [[1445, 1534], ["len", "len", "numpy.zeros", "numpy.zeros", "range", "len", "enumerate", "trim_zeros().copy", "pred_scores[].copy", "pred_boxes[].copy", "pred_class_ids[].copy", "pred_scores[].copy", "pred_scales[].copy", "pred_RTs[].copy", "range", "numpy.ones", "numpy.ones", "range", "numpy.argsort", "utils.compute_3d_iou_new", "len", "utils.trim_zeros", "numpy.argsort", "numpy.where"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_3d_iou_new", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.trim_zeros"], ["", "def", "compute_3d_matches", "(", "gt_class_ids", ",", "gt_RTs", ",", "gt_scales", ",", "gt_handle_visibility", ",", "synset_names", ",", "\n", "pred_boxes", ",", "pred_class_ids", ",", "pred_scores", ",", "pred_RTs", ",", "pred_scales", ",", "\n", "iou_3d_thresholds", ",", "score_threshold", "=", "0", ")", ":", "\n", "    ", "\"\"\"Finds matches between prediction and ground truth instances.\n    Returns:\n        gt_matches: 2-D array. For each GT box it has the index of the matched\n                  predicted box.\n        pred_matches: 2-D array. For each predicted box, it has the index of\n                    the matched ground truth box.\n        overlaps: [pred_boxes, gt_boxes] IoU overlaps.\n    \"\"\"", "\n", "# Trim zero padding", "\n", "# TODO: cleaner to do zero unpadding upstream", "\n", "num_pred", "=", "len", "(", "pred_class_ids", ")", "\n", "num_gt", "=", "len", "(", "gt_class_ids", ")", "\n", "indices", "=", "np", ".", "zeros", "(", "0", ")", "\n", "\n", "if", "num_pred", ":", "\n", "        ", "pred_boxes", "=", "trim_zeros", "(", "pred_boxes", ")", ".", "copy", "(", ")", "\n", "pred_scores", "=", "pred_scores", "[", ":", "pred_boxes", ".", "shape", "[", "0", "]", "]", ".", "copy", "(", ")", "\n", "\n", "# Sort predictions by score from high to low", "\n", "indices", "=", "np", ".", "argsort", "(", "pred_scores", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "pred_boxes", "=", "pred_boxes", "[", "indices", "]", ".", "copy", "(", ")", "\n", "pred_class_ids", "=", "pred_class_ids", "[", "indices", "]", ".", "copy", "(", ")", "\n", "pred_scores", "=", "pred_scores", "[", "indices", "]", ".", "copy", "(", ")", "\n", "pred_scales", "=", "pred_scales", "[", "indices", "]", ".", "copy", "(", ")", "\n", "pred_RTs", "=", "pred_RTs", "[", "indices", "]", ".", "copy", "(", ")", "\n", "\n", "\n", "# pred_3d_bboxs = []", "\n", "# for i in range(num_pred):", "\n", "#     noc_cube = get_3d_bbox(pred_scales[i, :], 0)", "\n", "#     pred_bbox_3d = transform_coordinates_3d(noc_cube, pred_RTs[i])", "\n", "#     pred_3d_bboxs.append(pred_bbox_3d)", "\n", "\n", "# # compute 3d bbox for ground truths", "\n", "# # print('Compute gt bboxes...')", "\n", "# gt_3d_bboxs = []", "\n", "# for j in range(num_gt):", "\n", "#     noc_cube = get_3d_bbox(gt_scales[j], 0)", "\n", "#     gt_3d_bbox = transform_coordinates_3d(noc_cube, gt_RTs[j])", "\n", "#     gt_3d_bboxs.append(gt_3d_bbox)", "\n", "\n", "# Compute IoU overlaps [pred_bboxs gt_bboxs]", "\n", "#overlaps = [[0 for j in range(num_gt)] for i in range(num_pred)]", "\n", "", "overlaps", "=", "np", ".", "zeros", "(", "(", "num_pred", ",", "num_gt", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "num_pred", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_gt", ")", ":", "\n", "#overlaps[i, j] = compute_3d_iou(pred_3d_bboxs[i], gt_3d_bboxs[j], gt_handle_visibility[j], ", "\n", "#    synset_names[pred_class_ids[i]], synset_names[gt_class_ids[j]])", "\n", "            ", "overlaps", "[", "i", ",", "j", "]", "=", "compute_3d_iou_new", "(", "pred_RTs", "[", "i", "]", ",", "gt_RTs", "[", "j", "]", ",", "pred_scales", "[", "i", ",", ":", "]", ",", "gt_scales", "[", "j", "]", ",", "gt_handle_visibility", "[", "j", "]", ",", "synset_names", "[", "pred_class_ids", "[", "i", "]", "]", ",", "synset_names", "[", "gt_class_ids", "[", "j", "]", "]", ")", "\n", "\n", "# Loop through predictions and find matching ground truth boxes", "\n", "", "", "num_iou_3d_thres", "=", "len", "(", "iou_3d_thresholds", ")", "\n", "pred_matches", "=", "-", "1", "*", "np", ".", "ones", "(", "[", "num_iou_3d_thres", ",", "num_pred", "]", ")", "\n", "gt_matches", "=", "-", "1", "*", "np", ".", "ones", "(", "[", "num_iou_3d_thres", ",", "num_gt", "]", ")", "\n", "\n", "for", "s", ",", "iou_thres", "in", "enumerate", "(", "iou_3d_thresholds", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "pred_boxes", ")", ")", ":", "\n", "# Find best matching ground truth box", "\n", "# 1. Sort matches by score", "\n", "            ", "sorted_ixs", "=", "np", ".", "argsort", "(", "overlaps", "[", "i", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "# 2. Remove low scores", "\n", "low_score_idx", "=", "np", ".", "where", "(", "overlaps", "[", "i", ",", "sorted_ixs", "]", "<", "score_threshold", ")", "[", "0", "]", "\n", "if", "low_score_idx", ".", "size", ">", "0", ":", "\n", "                ", "sorted_ixs", "=", "sorted_ixs", "[", ":", "low_score_idx", "[", "0", "]", "]", "\n", "# 3. Find the match", "\n", "", "for", "j", "in", "sorted_ixs", ":", "\n", "# If ground truth box is already matched, go to next one", "\n", "#print('gt_match: ', gt_match[j])", "\n", "                ", "if", "gt_matches", "[", "s", ",", "j", "]", ">", "-", "1", ":", "\n", "                    ", "continue", "\n", "# If we reach IoU smaller than the threshold, end the loop", "\n", "", "iou", "=", "overlaps", "[", "i", ",", "j", "]", "\n", "#print('iou: ', iou)", "\n", "if", "iou", "<", "iou_thres", ":", "\n", "                    ", "break", "\n", "# Do we have a match?", "\n", "", "if", "not", "pred_class_ids", "[", "i", "]", "==", "gt_class_ids", "[", "j", "]", ":", "\n", "                    ", "continue", "\n", "\n", "", "if", "iou", ">", "iou_thres", ":", "\n", "                    ", "gt_matches", "[", "s", ",", "j", "]", "=", "i", "\n", "pred_matches", "[", "s", ",", "i", "]", "=", "j", "\n", "break", "\n", "\n", "", "", "", "", "return", "gt_matches", ",", "pred_matches", ",", "overlaps", ",", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_ap_from_matches_scores": [[1536, 1562], ["numpy.concatenate", "numpy.concatenate", "range", "numpy.sum", "numpy.argsort", "numpy.cumsum", "numpy.cumsum().astype", "len", "numpy.maximum", "numpy.arange", "len", "numpy.where", "len", "numpy.cumsum"], "function", ["None"], ["", "def", "compute_ap_from_matches_scores", "(", "pred_match", ",", "pred_scores", ",", "gt_match", ")", ":", "\n", "# sort the scores from high to low", "\n", "# print(pred_match.shape, pred_scores.shape)", "\n", "    ", "assert", "pred_match", ".", "shape", "[", "0", "]", "==", "pred_scores", ".", "shape", "[", "0", "]", "\n", "\n", "score_indices", "=", "np", ".", "argsort", "(", "pred_scores", ")", "[", ":", ":", "-", "1", "]", "\n", "pred_scores", "=", "pred_scores", "[", "score_indices", "]", "\n", "pred_match", "=", "pred_match", "[", "score_indices", "]", "\n", "\n", "precisions", "=", "np", ".", "cumsum", "(", "pred_match", ">", "-", "1", ")", "/", "(", "np", ".", "arange", "(", "len", "(", "pred_match", ")", ")", "+", "1", ")", "\n", "recalls", "=", "np", ".", "cumsum", "(", "pred_match", ">", "-", "1", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "len", "(", "gt_match", ")", "\n", "\n", "# Pad with start and end values to simplify the math", "\n", "precisions", "=", "np", ".", "concatenate", "(", "[", "[", "0", "]", ",", "precisions", ",", "[", "0", "]", "]", ")", "\n", "recalls", "=", "np", ".", "concatenate", "(", "[", "[", "0", "]", ",", "recalls", ",", "[", "1", "]", "]", ")", "\n", "\n", "# Ensure precision values decrease but don't increase. This way, the", "\n", "# precision value at each recall threshold is the maximum it can be", "\n", "# for all following recall thresholds, as specified by the VOC paper.", "\n", "for", "i", "in", "range", "(", "len", "(", "precisions", ")", "-", "2", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "        ", "precisions", "[", "i", "]", "=", "np", ".", "maximum", "(", "precisions", "[", "i", "]", ",", "precisions", "[", "i", "+", "1", "]", ")", "\n", "\n", "# Compute mean AP over recall range", "\n", "", "indices", "=", "np", ".", "where", "(", "recalls", "[", ":", "-", "1", "]", "!=", "recalls", "[", "1", ":", "]", ")", "[", "0", "]", "+", "1", "\n", "ap", "=", "np", ".", "sum", "(", "(", "recalls", "[", "indices", "]", "-", "recalls", "[", "indices", "-", "1", "]", ")", "*", "precisions", "[", "indices", "]", ")", "\n", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_overlaps": [[1564, 1588], ["len", "len", "numpy.zeros", "range", "range", "utils.compute_RT_degree_cm_symmetry"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_degree_cm_symmetry"], ["", "def", "compute_RT_overlaps", "(", "gt_class_ids", ",", "gt_RTs", ",", "gt_handle_visibility", ",", "\n", "pred_class_ids", ",", "pred_RTs", ",", "\n", "synset_names", ")", ":", "\n", "    ", "\"\"\"Finds overlaps between prediction and ground truth instances.\n    Returns:\n        overlaps: [pred_boxes, gt_boxes] IoU overlaps.\n    \"\"\"", "\n", "# print('num of gt instances: {}, num of pred instances: {}'.format(len(gt_class_ids), len(gt_class_ids)))", "\n", "num_pred", "=", "len", "(", "pred_class_ids", ")", "\n", "num_gt", "=", "len", "(", "gt_class_ids", ")", "\n", "\n", "# Compute IoU overlaps [pred_bboxs gt_bboxs]", "\n", "#overlaps = [[0 for j in range(num_gt)] for i in range(num_pred)]", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "num_pred", ",", "num_gt", ",", "2", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_pred", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_gt", ")", ":", "\n", "            ", "overlaps", "[", "i", ",", "j", ",", ":", "]", "=", "compute_RT_degree_cm_symmetry", "(", "pred_RTs", "[", "i", "]", ",", "\n", "gt_RTs", "[", "j", "]", ",", "\n", "gt_class_ids", "[", "j", "]", ",", "\n", "gt_handle_visibility", "[", "j", "]", ",", "\n", "synset_names", ")", "\n", "\n", "", "", "return", "overlaps", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_projection_2d_overlaps": [[1590, 1616], ["len", "len", "numpy.zeros", "range", "range", "utils.compute_RT_projection_2d_symmetry"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_projection_2d_symmetry"], ["", "def", "compute_RT_projection_2d_overlaps", "(", "gt_class_ids", ",", "gt_RTs", ",", "gt_handle_visibility", ",", "\n", "pred_class_ids", ",", "pred_RTs", ",", "\n", "meshes", ",", "intrinsics", ",", "synset_names", ")", ":", "\n", "    ", "\"\"\"Finds overlaps between prediction and ground truth instances.\n    Returns:\n        overlaps: [pred_boxes, gt_boxes] IoU overlaps.\n    \"\"\"", "\n", "# print('num of gt instances: {}, num of pred instances: {}'.format(len(gt_class_ids), len(gt_class_ids)))", "\n", "num_pred", "=", "len", "(", "pred_class_ids", ")", "\n", "num_gt", "=", "len", "(", "gt_class_ids", ")", "\n", "\n", "# Compute IoU overlaps [pred_bboxs gt_bboxs]", "\n", "#overlaps = [[0 for j in range(num_gt)] for i in range(num_pred)]", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "num_pred", ",", "num_gt", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_pred", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_gt", ")", ":", "\n", "            ", "overlaps", "[", "i", ",", "j", "]", "=", "compute_RT_projection_2d_symmetry", "(", "pred_RTs", "[", "i", "]", ",", "\n", "gt_RTs", "[", "j", "]", ",", "\n", "gt_class_ids", "[", "j", "]", ",", "\n", "gt_handle_visibility", "[", "j", "]", ",", "\n", "meshes", "[", "gt_class_ids", "[", "j", "]", "]", ",", "\n", "intrinsics", ",", "\n", "synset_names", ")", "\n", "\n", "", "", "return", "overlaps", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_match_from_projection_2d_dist": [[1618, 1660], ["len", "len", "len", "enumerate", "numpy.ones", "numpy.ones", "range", "numpy.argsort"], "function", ["None"], ["", "def", "compute_match_from_projection_2d_dist", "(", "overlaps", ",", "pred_class_ids", ",", "gt_class_ids", ",", "projection_thres_list", ")", ":", "\n", "    ", "num_projection_thres", "=", "len", "(", "projection_thres_list", ")", "\n", "\n", "num_pred", "=", "len", "(", "pred_class_ids", ")", "\n", "num_gt", "=", "len", "(", "gt_class_ids", ")", "\n", "\n", "pred_matches", "=", "-", "1", "*", "np", ".", "ones", "(", "(", "num_projection_thres", ",", "num_pred", ")", ")", "\n", "gt_matches", "=", "-", "1", "*", "np", ".", "ones", "(", "(", "num_projection_thres", ",", "num_gt", ")", ")", "\n", "\n", "if", "num_pred", "==", "0", "or", "num_gt", "==", "0", ":", "\n", "        ", "return", "gt_matches", ",", "pred_matches", "\n", "\n", "\n", "", "assert", "num_pred", "==", "overlaps", ".", "shape", "[", "0", "]", "\n", "assert", "num_gt", "==", "overlaps", ".", "shape", "[", "1", "]", "\n", "\n", "\n", "\n", "for", "p", ",", "projection_thres", "in", "enumerate", "(", "projection_thres_list", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "num_pred", ")", ":", "\n", "# Find best matching ground truth box", "\n", "# 1. Sort matches by scores from low to high", "\n", "            ", "sorted_ixs", "=", "np", ".", "argsort", "(", "overlaps", "[", "i", ",", ":", "]", ")", "\n", "# 2. Remove low scores", "\n", "# low_score_idx = np.where(sum_degree_shift >= 100)[0]", "\n", "# if low_score_idx.size > 0:", "\n", "#     sorted_ixs = sorted_ixs[:low_score_idx[0]]", "\n", "# 3. Find the match", "\n", "for", "j", "in", "sorted_ixs", ":", "\n", "# If ground truth box is already matched, go to next one", "\n", "#print(j, len(gt_match), len(pred_class_ids), len(gt_class_ids))", "\n", "                ", "if", "gt_matches", "[", "p", ",", "j", "]", ">", "-", "1", "or", "pred_class_ids", "[", "i", "]", "!=", "gt_class_ids", "[", "j", "]", ":", "\n", "                    ", "continue", "\n", "# If we reach IoU smaller than the threshold, end the loop", "\n", "", "if", "overlaps", "[", "i", ",", "j", "]", ">", "projection_thres", ":", "\n", "                    ", "continue", "\n", "\n", "", "gt_matches", "[", "p", ",", "j", "]", "=", "i", "\n", "pred_matches", "[", "p", ",", "i", "]", "=", "j", "\n", "break", "\n", "\n", "", "", "", "return", "gt_matches", ",", "pred_matches", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_match_from_degree_cm": [[1662, 1708], ["len", "len", "len", "len", "enumerate", "numpy.ones", "numpy.ones", "enumerate", "range", "numpy.sum", "numpy.argsort"], "function", ["None"], ["", "def", "compute_match_from_degree_cm", "(", "overlaps", ",", "pred_class_ids", ",", "gt_class_ids", ",", "degree_thres_list", ",", "shift_thres_list", ")", ":", "\n", "    ", "num_degree_thres", "=", "len", "(", "degree_thres_list", ")", "\n", "num_shift_thres", "=", "len", "(", "shift_thres_list", ")", "\n", "\n", "\n", "num_pred", "=", "len", "(", "pred_class_ids", ")", "\n", "num_gt", "=", "len", "(", "gt_class_ids", ")", "\n", "\n", "pred_matches", "=", "-", "1", "*", "np", ".", "ones", "(", "(", "num_degree_thres", ",", "num_shift_thres", ",", "num_pred", ")", ")", "\n", "gt_matches", "=", "-", "1", "*", "np", ".", "ones", "(", "(", "num_degree_thres", ",", "num_shift_thres", ",", "num_gt", ")", ")", "\n", "\n", "if", "num_pred", "==", "0", "or", "num_gt", "==", "0", ":", "\n", "        ", "return", "gt_matches", ",", "pred_matches", "\n", "\n", "\n", "", "assert", "num_pred", "==", "overlaps", ".", "shape", "[", "0", "]", "\n", "assert", "num_gt", "==", "overlaps", ".", "shape", "[", "1", "]", "\n", "assert", "overlaps", ".", "shape", "[", "2", "]", "==", "2", "\n", "\n", "\n", "for", "d", ",", "degree_thres", "in", "enumerate", "(", "degree_thres_list", ")", ":", "\n", "        ", "for", "s", ",", "shift_thres", "in", "enumerate", "(", "shift_thres_list", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "num_pred", ")", ":", "\n", "# Find best matching ground truth box", "\n", "# 1. Sort matches by scores from low to high", "\n", "                ", "sum_degree_shift", "=", "np", ".", "sum", "(", "overlaps", "[", "i", ",", ":", ",", ":", "]", ",", "axis", "=", "-", "1", ")", "\n", "sorted_ixs", "=", "np", ".", "argsort", "(", "sum_degree_shift", ")", "\n", "# 2. Remove low scores", "\n", "# low_score_idx = np.where(sum_degree_shift >= 100)[0]", "\n", "# if low_score_idx.size > 0:", "\n", "#     sorted_ixs = sorted_ixs[:low_score_idx[0]]", "\n", "# 3. Find the match", "\n", "for", "j", "in", "sorted_ixs", ":", "\n", "# If ground truth box is already matched, go to next one", "\n", "#print(j, len(gt_match), len(pred_class_ids), len(gt_class_ids))", "\n", "                    ", "if", "gt_matches", "[", "d", ",", "s", ",", "j", "]", ">", "-", "1", "or", "pred_class_ids", "[", "i", "]", "!=", "gt_class_ids", "[", "j", "]", ":", "\n", "                        ", "continue", "\n", "# If we reach IoU smaller than the threshold, end the loop", "\n", "", "if", "overlaps", "[", "i", ",", "j", ",", "0", "]", ">", "degree_thres", "or", "overlaps", "[", "i", ",", "j", ",", "1", "]", ">", "shift_thres", ":", "\n", "                        ", "continue", "\n", "\n", "", "gt_matches", "[", "d", ",", "s", ",", "j", "]", "=", "i", "\n", "pred_matches", "[", "d", ",", "s", ",", "i", "]", "=", "j", "\n", "break", "\n", "\n", "", "", "", "", "return", "gt_matches", ",", "pred_matches", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_degree_cm_mAP": [[1711, 2011], ["len", "len", "len", "list", "len", "numpy.zeros", "numpy.zeros", "enumerate", "matplotlib.figure", "matplotlib.subplot", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.xlabel", "os.path.join", "os.path.join", "range", "numpy.mean", "plt.subplot.plot", "plt.subplot.legend", "plt.figure.savefig", "matplotlib.close", "os.path.join", "enumerate", "range", "matplotlib.figure", "matplotlib.subplot", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.xlim", "matplotlib.imshow", "os.path.join", "matplotlib.colorbar", "matplotlib.savefig", "matplotlib.close", "matplotlib.figure", "matplotlib.subplot", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.xlabel", "range", "plt.subplot.plot", "os.path.join", "plt.subplot.legend", "plt.figure.savefig", "matplotlib.close", "matplotlib.figure", "matplotlib.subplot", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.xlabel", "range", "plt.subplot.plot", "os.path.join", "plt.subplot.legend", "plt.figure.savefig", "matplotlib.close", "print", "print", "print", "print", "print", "print", "print", "print", "list", "list", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "print", "result[].astype", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "range", "print", "enumerate", "plt.subplot.plot", "open", "_pickle.dump", "enumerate", "open", "_pickle.dump", "print", "matplotlib.figure", "matplotlib.subplot", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.xlim", "matplotlib.imshow", "os.path.join", "matplotlib.colorbar", "matplotlib.savefig", "matplotlib.close", "print", "plt.subplot.plot", "print", "plt.subplot.plot", "range", "range", "range", "range", "range", "range", "len", "utils.compute_3d_matches", "len", "numpy.concatenate", "numpy.tile", "numpy.concatenate", "numpy.concatenate", "utils.compute_RT_overlaps", "utils.compute_match_from_degree_cm", "numpy.concatenate", "numpy.tile", "numpy.concatenate", "numpy.concatenate", "utils.compute_ap_from_matches_scores", "range", "numpy.mean", "len", "len", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "numpy.ones_like", "list().index", "utils.compute_ap_from_matches_scores", "len", "numpy.ones", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "list", "len", "len", "len", "len", "len", "len", "len", "list.index", "list.index", "degree_thres_list.index", "shift_thres_list.index", "degree_thres_list.index", "shift_thres_list.index", "degree_thres_list.index", "shift_thres_list.index", "degree_thres_list.index", "shift_thres_list.index", "degree_thres_list.index", "shift_thres_list.index", "degree_thres_list.index", "shift_thres_list.index"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_3d_matches", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_overlaps", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_match_from_degree_cm", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_ap_from_matches_scores", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_ap_from_matches_scores"], ["", "def", "compute_degree_cm_mAP", "(", "final_results", ",", "synset_names", ",", "log_dir", ",", "degree_thresholds", "=", "[", "360", "]", ",", "shift_thresholds", "=", "[", "100", "]", ",", "iou_3d_thresholds", "=", "[", "0.1", "]", ",", "iou_pose_thres", "=", "0.1", ",", "use_matches_for_pose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute Average Precision at a set IoU threshold (default 0.5).\n    Returns:\n    mAP: Mean Average Precision\n    precisions: List of precisions at different class score thresholds.\n    recalls: List of recall values at different class score thresholds.\n    overlaps: [pred_boxes, gt_boxes] IoU overlaps.\n    \"\"\"", "\n", "\n", "num_classes", "=", "len", "(", "synset_names", ")", "\n", "degree_thres_list", "=", "list", "(", "degree_thresholds", ")", "+", "[", "360", "]", "\n", "num_degree_thres", "=", "len", "(", "degree_thres_list", ")", "\n", "\n", "shift_thres_list", "=", "list", "(", "shift_thresholds", ")", "+", "[", "100", "]", "\n", "num_shift_thres", "=", "len", "(", "shift_thres_list", ")", "\n", "\n", "iou_thres_list", "=", "list", "(", "iou_3d_thresholds", ")", "\n", "num_iou_thres", "=", "len", "(", "iou_thres_list", ")", "\n", "\n", "if", "use_matches_for_pose", ":", "\n", "        ", "assert", "iou_pose_thres", "in", "iou_thres_list", "\n", "\n", "", "iou_3d_aps", "=", "np", ".", "zeros", "(", "(", "num_classes", "+", "1", ",", "num_iou_thres", ")", ")", "\n", "iou_pred_matches_all", "=", "[", "np", ".", "zeros", "(", "(", "num_iou_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "iou_pred_scores_all", "=", "[", "np", ".", "zeros", "(", "(", "num_iou_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "iou_gt_matches_all", "=", "[", "np", ".", "zeros", "(", "(", "num_iou_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "\n", "pose_aps", "=", "np", ".", "zeros", "(", "(", "num_classes", "+", "1", ",", "num_degree_thres", ",", "num_shift_thres", ")", ")", "\n", "pose_pred_matches_all", "=", "[", "np", ".", "zeros", "(", "(", "num_degree_thres", ",", "num_shift_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "pose_gt_matches_all", "=", "[", "np", ".", "zeros", "(", "(", "num_degree_thres", ",", "num_shift_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "pose_pred_scores_all", "=", "[", "np", ".", "zeros", "(", "(", "num_degree_thres", ",", "num_shift_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "\n", "# loop over results to gather pred matches and gt matches for iou and pose metrics", "\n", "progress", "=", "0", "\n", "for", "progress", ",", "result", "in", "enumerate", "(", "final_results", ")", ":", "\n", "        ", "print", "(", "progress", ",", "len", "(", "final_results", ")", ")", "\n", "gt_class_ids", "=", "result", "[", "'gt_class_ids'", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "gt_RTs", "=", "np", ".", "array", "(", "result", "[", "'gt_RTs'", "]", ")", "\n", "gt_scales", "=", "np", ".", "array", "(", "result", "[", "'gt_scales'", "]", ")", "\n", "gt_handle_visibility", "=", "result", "[", "'gt_handle_visibility'", "]", "\n", "\n", "pred_bboxes", "=", "np", ".", "array", "(", "result", "[", "'pred_bboxes'", "]", ")", "\n", "pred_class_ids", "=", "result", "[", "'pred_class_ids'", "]", "\n", "pred_scales", "=", "result", "[", "'pred_scales'", "]", "\n", "pred_scores", "=", "result", "[", "'pred_scores'", "]", "\n", "pred_RTs", "=", "np", ".", "array", "(", "result", "[", "'pred_RTs'", "]", ")", "\n", "#print(pred_bboxes.shape[0], pred_class_ids.shape[0], pred_scores.shape[0], pred_RTs.shape[0])", "\n", "\n", "if", "len", "(", "gt_class_ids", ")", "==", "0", "and", "len", "(", "pred_class_ids", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "\n", "", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "# get gt and predictions in this class", "\n", "            ", "cls_gt_class_ids", "=", "gt_class_ids", "[", "gt_class_ids", "==", "cls_id", "]", "if", "len", "(", "gt_class_ids", ")", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_gt_scales", "=", "gt_scales", "[", "gt_class_ids", "==", "cls_id", "]", "if", "len", "(", "gt_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "3", ")", ")", "\n", "cls_gt_RTs", "=", "gt_RTs", "[", "gt_class_ids", "==", "cls_id", "]", "if", "len", "(", "gt_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", "\n", "\n", "cls_pred_class_ids", "=", "pred_class_ids", "[", "pred_class_ids", "==", "cls_id", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_pred_bboxes", "=", "pred_bboxes", "[", "pred_class_ids", "==", "cls_id", ",", ":", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", "\n", "cls_pred_scores", "=", "pred_scores", "[", "pred_class_ids", "==", "cls_id", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_pred_RTs", "=", "pred_RTs", "[", "pred_class_ids", "==", "cls_id", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", "\n", "cls_pred_scales", "=", "pred_scales", "[", "pred_class_ids", "==", "cls_id", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "3", ")", ")", "\n", "\n", "\n", "# if len(cls_gt_class_ids) == 0 and len(cls_pred_class_ids) == 0:", "\n", "#     continue", "\n", "\n", "# elif len(cls_gt_class_ids) > 0 and len(cls_pred_class_ids) == 0:", "\n", "#     iou_gt_matches_all[cls_id] = np.concatenate((iou_gt_matches_all[cls_id], -1*np.ones((num_iou_thres, len(cls_gt_class_ids)))), axis=-1)", "\n", "#     if not use_matches_for_pose:", "\n", "#         pose_gt_matches_all[cls_id] = np.concatenate((pose_gt_matches_all[cls_id], -1*np.ones((num_degree_thres, num_shift_thres, len(cls_gt_class_ids)))), axis=-1)", "\n", "#     continue", "\n", "\n", "# elif len(cls_pred_class_ids)>0 and len(cls_gt_class_ids)==0:", "\n", "#     assert iou_pred_matches_all[cls_id].shape[1] == iou_pred_scores_all[cls_id].shape[1]", "\n", "\n", "#     iou_pred_matches_all[cls_id] = np.concatenate((iou_pred_matches_all[cls_id], -1*np.ones((num_iou_thres, len(cls_pred_class_ids)))),  axis=-1)", "\n", "#     cls_pred_scores_tile = np.tile(cls_pred_scores, (num_iou_thres, 1))", "\n", "#     iou_pred_scores_all[cls_id] = np.concatenate((iou_pred_scores_all[cls_id], cls_pred_scores_tile), axis=-1)", "\n", "\n", "#     assert iou_pred_matches_all[cls_id].shape[1] == iou_pred_scores_all[cls_id].shape[1]", "\n", "\n", "#     if not use_matches_for_pose:", "\n", "#         pose_pred_matches_all[cls_id] = np.concatenate((pose_pred_matches_all[cls_id], -1*np.ones((num_degree_thres, num_shift_thres, len(cls_pred_class_ids)))), axis=-1)", "\n", "#         cls_pred_scores_tile = np.tile(cls_pred_scores, (num_degree_thres, num_shift_thres, 1))", "\n", "#         pose_pred_scores_all[cls_id] = np.concatenate((pose_pred_scores_all[cls_id], cls_pred_scores_tile), axis=-1)", "\n", "#     continue", "\n", "\n", "\n", "\n", "# calculate the overlap between each gt instance and pred instance", "\n", "if", "synset_names", "[", "cls_id", "]", "!=", "'mug'", ":", "\n", "                ", "cls_gt_handle_visibility", "=", "np", ".", "ones_like", "(", "cls_gt_class_ids", ")", "\n", "", "else", ":", "\n", "                ", "cls_gt_handle_visibility", "=", "gt_handle_visibility", "[", "gt_class_ids", "==", "cls_id", "]", "if", "len", "(", "gt_class_ids", ")", "else", "np", ".", "ones", "(", "0", ")", "\n", "\n", "\n", "", "iou_cls_gt_match", ",", "iou_cls_pred_match", ",", "_", ",", "iou_pred_indices", "=", "compute_3d_matches", "(", "cls_gt_class_ids", ",", "cls_gt_RTs", ",", "cls_gt_scales", ",", "cls_gt_handle_visibility", ",", "synset_names", ",", "\n", "cls_pred_bboxes", ",", "cls_pred_class_ids", ",", "cls_pred_scores", ",", "cls_pred_RTs", ",", "cls_pred_scales", ",", "\n", "iou_thres_list", ")", "\n", "if", "len", "(", "iou_pred_indices", ")", ":", "\n", "                ", "cls_pred_class_ids", "=", "cls_pred_class_ids", "[", "iou_pred_indices", "]", "\n", "cls_pred_RTs", "=", "cls_pred_RTs", "[", "iou_pred_indices", "]", "\n", "cls_pred_scores", "=", "cls_pred_scores", "[", "iou_pred_indices", "]", "\n", "cls_pred_bboxes", "=", "cls_pred_bboxes", "[", "iou_pred_indices", "]", "\n", "\n", "\n", "", "iou_pred_matches_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "iou_pred_matches_all", "[", "cls_id", "]", ",", "iou_cls_pred_match", ")", ",", "axis", "=", "-", "1", ")", "\n", "cls_pred_scores_tile", "=", "np", ".", "tile", "(", "cls_pred_scores", ",", "(", "num_iou_thres", ",", "1", ")", ")", "\n", "iou_pred_scores_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "iou_pred_scores_all", "[", "cls_id", "]", ",", "cls_pred_scores_tile", ")", ",", "axis", "=", "-", "1", ")", "\n", "assert", "iou_pred_matches_all", "[", "cls_id", "]", ".", "shape", "[", "1", "]", "==", "iou_pred_scores_all", "[", "cls_id", "]", ".", "shape", "[", "1", "]", "\n", "iou_gt_matches_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "iou_gt_matches_all", "[", "cls_id", "]", ",", "iou_cls_gt_match", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "if", "use_matches_for_pose", ":", "\n", "                ", "thres_ind", "=", "list", "(", "iou_thres_list", ")", ".", "index", "(", "iou_pose_thres", ")", "\n", "\n", "iou_thres_pred_match", "=", "iou_cls_pred_match", "[", "thres_ind", ",", ":", "]", "\n", "\n", "\n", "cls_pred_class_ids", "=", "cls_pred_class_ids", "[", "iou_thres_pred_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_pred_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_pred_RTs", "=", "cls_pred_RTs", "[", "iou_thres_pred_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_pred_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", "\n", "cls_pred_scores", "=", "cls_pred_scores", "[", "iou_thres_pred_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_pred_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_pred_bboxes", "=", "cls_pred_bboxes", "[", "iou_thres_pred_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_pred_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", "\n", "\n", "\n", "iou_thres_gt_match", "=", "iou_cls_gt_match", "[", "thres_ind", ",", ":", "]", "\n", "cls_gt_class_ids", "=", "cls_gt_class_ids", "[", "iou_thres_gt_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_gt_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_gt_RTs", "=", "cls_gt_RTs", "[", "iou_thres_gt_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_gt_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", "\n", "cls_gt_handle_visibility", "=", "cls_gt_handle_visibility", "[", "iou_thres_gt_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_gt_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "0", ")", "\n", "\n", "\n", "\n", "", "RT_overlaps", "=", "compute_RT_overlaps", "(", "cls_gt_class_ids", ",", "cls_gt_RTs", ",", "cls_gt_handle_visibility", ",", "\n", "cls_pred_class_ids", ",", "cls_pred_RTs", ",", "\n", "synset_names", ")", "\n", "\n", "\n", "pose_cls_gt_match", ",", "pose_cls_pred_match", "=", "compute_match_from_degree_cm", "(", "RT_overlaps", ",", "\n", "cls_pred_class_ids", ",", "\n", "cls_gt_class_ids", ",", "\n", "degree_thres_list", ",", "\n", "shift_thres_list", ")", "\n", "\n", "\n", "pose_pred_matches_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "pose_pred_matches_all", "[", "cls_id", "]", ",", "pose_cls_pred_match", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "cls_pred_scores_tile", "=", "np", ".", "tile", "(", "cls_pred_scores", ",", "(", "num_degree_thres", ",", "num_shift_thres", ",", "1", ")", ")", "\n", "pose_pred_scores_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "pose_pred_scores_all", "[", "cls_id", "]", ",", "cls_pred_scores_tile", ")", ",", "axis", "=", "-", "1", ")", "\n", "assert", "pose_pred_scores_all", "[", "cls_id", "]", ".", "shape", "[", "2", "]", "==", "pose_pred_matches_all", "[", "cls_id", "]", ".", "shape", "[", "2", "]", ",", "'{} vs. {}'", ".", "format", "(", "pose_pred_scores_all", "[", "cls_id", "]", ".", "shape", ",", "pose_pred_matches_all", "[", "cls_id", "]", ".", "shape", ")", "\n", "pose_gt_matches_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "pose_gt_matches_all", "[", "cls_id", "]", ",", "pose_cls_gt_match", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "\n", "\n", "# draw iou 3d AP vs. iou thresholds", "\n", "", "", "fig_iou", "=", "plt", ".", "figure", "(", ")", "\n", "ax_iou", "=", "plt", ".", "subplot", "(", "111", ")", "\n", "plt", ".", "ylabel", "(", "'AP'", ")", "\n", "plt", ".", "ylim", "(", "(", "0", ",", "1", ")", ")", "\n", "plt", ".", "xlabel", "(", "'3D IoU thresholds'", ")", "\n", "iou_output_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "'IoU_3D_AP_{}-{}.png'", ".", "format", "(", "iou_thres_list", "[", "0", "]", ",", "iou_thres_list", "[", "-", "1", "]", ")", ")", "\n", "iou_dict_pkl_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "'IoU_3D_AP_{}-{}.pkl'", ".", "format", "(", "iou_thres_list", "[", "0", "]", ",", "iou_thres_list", "[", "-", "1", "]", ")", ")", "\n", "\n", "iou_dict", "=", "{", "}", "\n", "iou_dict", "[", "'thres_list'", "]", "=", "iou_thres_list", "\n", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "        ", "class_name", "=", "synset_names", "[", "cls_id", "]", "\n", "print", "(", "class_name", ")", "\n", "for", "s", ",", "iou_thres", "in", "enumerate", "(", "iou_thres_list", ")", ":", "\n", "            ", "iou_3d_aps", "[", "cls_id", ",", "s", "]", "=", "compute_ap_from_matches_scores", "(", "iou_pred_matches_all", "[", "cls_id", "]", "[", "s", ",", ":", "]", ",", "\n", "iou_pred_scores_all", "[", "cls_id", "]", "[", "s", ",", ":", "]", ",", "\n", "iou_gt_matches_all", "[", "cls_id", "]", "[", "s", ",", ":", "]", ")", "\n", "", "ax_iou", ".", "plot", "(", "iou_thres_list", ",", "iou_3d_aps", "[", "cls_id", ",", ":", "]", ",", "label", "=", "class_name", ")", "\n", "\n", "", "iou_3d_aps", "[", "-", "1", ",", ":", "]", "=", "np", ".", "mean", "(", "iou_3d_aps", "[", "1", ":", "-", "1", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "ax_iou", ".", "plot", "(", "iou_thres_list", ",", "iou_3d_aps", "[", "-", "1", ",", ":", "]", ",", "label", "=", "'mean'", ")", "\n", "ax_iou", ".", "legend", "(", ")", "\n", "fig_iou", ".", "savefig", "(", "iou_output_path", ")", "\n", "plt", ".", "close", "(", "fig_iou", ")", "\n", "\n", "iou_dict", "[", "'aps'", "]", "=", "iou_3d_aps", "\n", "with", "open", "(", "iou_dict_pkl_path", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "cPickle", ".", "dump", "(", "iou_dict", ",", "f", ")", "\n", "\n", "\n", "# draw pose AP vs. thresholds", "\n", "", "if", "use_matches_for_pose", ":", "\n", "        ", "prefix", "=", "'Pose_Only_'", "\n", "", "else", ":", "\n", "        ", "prefix", "=", "'Pose_Detection_'", "\n", "\n", "\n", "", "pose_dict_pkl_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "prefix", "+", "'AP_{}-{}degree_{}-{}cm.pkl'", ".", "format", "(", "degree_thres_list", "[", "0", "]", ",", "degree_thres_list", "[", "-", "2", "]", ",", "\n", "shift_thres_list", "[", "0", "]", ",", "shift_thres_list", "[", "-", "2", "]", ")", ")", "\n", "pose_dict", "=", "{", "}", "\n", "pose_dict", "[", "'degree_thres'", "]", "=", "degree_thres_list", "\n", "pose_dict", "[", "'shift_thres_list'", "]", "=", "shift_thres_list", "\n", "\n", "for", "i", ",", "degree_thres", "in", "enumerate", "(", "degree_thres_list", ")", ":", "\n", "        ", "for", "j", ",", "shift_thres", "in", "enumerate", "(", "shift_thres_list", ")", ":", "\n", "# print(i, j)", "\n", "            ", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "                ", "cls_pose_pred_matches_all", "=", "pose_pred_matches_all", "[", "cls_id", "]", "[", "i", ",", "j", ",", ":", "]", "\n", "cls_pose_gt_matches_all", "=", "pose_gt_matches_all", "[", "cls_id", "]", "[", "i", ",", "j", ",", ":", "]", "\n", "cls_pose_pred_scores_all", "=", "pose_pred_scores_all", "[", "cls_id", "]", "[", "i", ",", "j", ",", ":", "]", "\n", "\n", "pose_aps", "[", "cls_id", ",", "i", ",", "j", "]", "=", "compute_ap_from_matches_scores", "(", "cls_pose_pred_matches_all", ",", "\n", "cls_pose_pred_scores_all", ",", "\n", "cls_pose_gt_matches_all", ")", "\n", "\n", "", "pose_aps", "[", "-", "1", ",", "i", ",", "j", "]", "=", "np", ".", "mean", "(", "pose_aps", "[", "1", ":", "-", "1", ",", "i", ",", "j", "]", ")", "\n", "\n", "", "", "pose_dict", "[", "'aps'", "]", "=", "pose_aps", "\n", "with", "open", "(", "pose_dict_pkl_path", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "cPickle", ".", "dump", "(", "pose_dict", ",", "f", ")", "\n", "\n", "\n", "", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "        ", "class_name", "=", "synset_names", "[", "cls_id", "]", "\n", "print", "(", "class_name", ")", "\n", "# print(np.amin(aps[i, :, :]), np.amax(aps[i, :, :]))", "\n", "\n", "#ap_image = cv2.resize(pose_aps[cls_id, :, :]*255, (320, 320), interpolation = cv2.INTER_LINEAR)", "\n", "fig_iou", "=", "plt", ".", "figure", "(", ")", "\n", "ax_iou", "=", "plt", ".", "subplot", "(", "111", ")", "\n", "plt", ".", "ylabel", "(", "'Rotation thresholds/degree'", ")", "\n", "plt", ".", "ylim", "(", "(", "degree_thres_list", "[", "0", "]", ",", "degree_thres_list", "[", "-", "2", "]", ")", ")", "\n", "plt", ".", "xlabel", "(", "'translation/cm'", ")", "\n", "plt", ".", "xlim", "(", "(", "shift_thres_list", "[", "0", "]", ",", "shift_thres_list", "[", "-", "2", "]", ")", ")", "\n", "plt", ".", "imshow", "(", "pose_aps", "[", "cls_id", ",", ":", "-", "1", ",", ":", "-", "1", "]", ",", "cmap", "=", "'jet'", ",", "interpolation", "=", "'bilinear'", ")", "\n", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "prefix", "+", "'AP_{}_{}-{}degree_{}-{}cm.png'", ".", "format", "(", "class_name", ",", "\n", "degree_thres_list", "[", "0", "]", ",", "degree_thres_list", "[", "-", "2", "]", ",", "\n", "shift_thres_list", "[", "0", "]", ",", "shift_thres_list", "[", "-", "2", "]", ")", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "plt", ".", "savefig", "(", "output_path", ")", "\n", "plt", ".", "close", "(", "fig_iou", ")", "\n", "\n", "#ap_mean_image = cv2.resize(pose_aps[-1, :, :]*255, (320, 320), interpolation = cv2.INTER_LINEAR) ", "\n", "\n", "", "fig_pose", "=", "plt", ".", "figure", "(", ")", "\n", "ax_pose", "=", "plt", ".", "subplot", "(", "111", ")", "\n", "plt", ".", "ylabel", "(", "'Rotation thresholds/degree'", ")", "\n", "plt", ".", "ylim", "(", "(", "degree_thres_list", "[", "0", "]", ",", "degree_thres_list", "[", "-", "2", "]", ")", ")", "\n", "plt", ".", "xlabel", "(", "'translation/cm'", ")", "\n", "plt", ".", "xlim", "(", "(", "shift_thres_list", "[", "0", "]", ",", "shift_thres_list", "[", "-", "2", "]", ")", ")", "\n", "plt", ".", "imshow", "(", "pose_aps", "[", "-", "1", ",", ":", "-", "1", ",", ":", "-", "1", "]", ",", "cmap", "=", "'jet'", ",", "interpolation", "=", "'bilinear'", ")", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "prefix", "+", "'mAP_{}-{}degree_{}-{}cm.png'", ".", "format", "(", "degree_thres_list", "[", "0", "]", ",", "degree_thres_list", "[", "-", "2", "]", ",", "\n", "shift_thres_list", "[", "0", "]", ",", "shift_thres_list", "[", "-", "2", "]", ")", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "plt", ".", "savefig", "(", "output_path", ")", "\n", "plt", ".", "close", "(", "fig_pose", ")", "\n", "\n", "\n", "fig_rot", "=", "plt", ".", "figure", "(", ")", "\n", "ax_rot", "=", "plt", ".", "subplot", "(", "111", ")", "\n", "plt", ".", "ylabel", "(", "'AP'", ")", "\n", "plt", ".", "ylim", "(", "(", "0", ",", "1.05", ")", ")", "\n", "plt", ".", "xlabel", "(", "'translation/cm'", ")", "\n", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "        ", "class_name", "=", "synset_names", "[", "cls_id", "]", "\n", "print", "(", "class_name", ")", "\n", "ax_rot", ".", "plot", "(", "shift_thres_list", "[", ":", "-", "1", "]", ",", "pose_aps", "[", "cls_id", ",", "-", "1", ",", ":", "-", "1", "]", ",", "label", "=", "class_name", ")", "\n", "\n", "", "ax_rot", ".", "plot", "(", "shift_thres_list", "[", ":", "-", "1", "]", ",", "pose_aps", "[", "-", "1", ",", "-", "1", ",", ":", "-", "1", "]", ",", "label", "=", "'mean'", ")", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "prefix", "+", "'mAP_{}-{}cm.png'", ".", "format", "(", "shift_thres_list", "[", "0", "]", ",", "shift_thres_list", "[", "-", "2", "]", ")", ")", "\n", "ax_rot", ".", "legend", "(", ")", "\n", "fig_rot", ".", "savefig", "(", "output_path", ")", "\n", "plt", ".", "close", "(", "fig_rot", ")", "\n", "\n", "fig_trans", "=", "plt", ".", "figure", "(", ")", "\n", "ax_trans", "=", "plt", ".", "subplot", "(", "111", ")", "\n", "plt", ".", "ylabel", "(", "'AP'", ")", "\n", "plt", ".", "ylim", "(", "(", "0", ",", "1.05", ")", ")", "\n", "\n", "plt", ".", "xlabel", "(", "'Rotation/degree'", ")", "\n", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "        ", "class_name", "=", "synset_names", "[", "cls_id", "]", "\n", "print", "(", "class_name", ")", "\n", "ax_trans", ".", "plot", "(", "degree_thres_list", "[", ":", "-", "1", "]", ",", "pose_aps", "[", "cls_id", ",", ":", "-", "1", ",", "-", "1", "]", ",", "label", "=", "class_name", ")", "\n", "\n", "", "ax_trans", ".", "plot", "(", "degree_thres_list", "[", ":", "-", "1", "]", ",", "pose_aps", "[", "-", "1", ",", ":", "-", "1", ",", "-", "1", "]", ",", "label", "=", "'mean'", ")", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "prefix", "+", "'mAP_{}-{}degree.png'", ".", "format", "(", "degree_thres_list", "[", "0", "]", ",", "degree_thres_list", "[", "-", "2", "]", ")", ")", "\n", "\n", "ax_trans", ".", "legend", "(", ")", "\n", "fig_trans", ".", "savefig", "(", "output_path", ")", "\n", "plt", ".", "close", "(", "fig_trans", ")", "\n", "\n", "iou_aps", "=", "iou_3d_aps", "\n", "print", "(", "'3D IoU at 25: {:.1f}'", ".", "format", "(", "iou_aps", "[", "-", "1", ",", "iou_thres_list", ".", "index", "(", "0.25", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'3D IoU at 50: {:.1f}'", ".", "format", "(", "iou_aps", "[", "-", "1", ",", "iou_thres_list", ".", "index", "(", "0.5", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'5 degree, 5cm: {:.1f}'", ".", "format", "(", "pose_aps", "[", "-", "1", ",", "degree_thres_list", ".", "index", "(", "5", ")", ",", "shift_thres_list", ".", "index", "(", "5", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'5 degree, 100cm: {:.1f}'", ".", "format", "(", "pose_aps", "[", "-", "1", ",", "degree_thres_list", ".", "index", "(", "5", ")", ",", "shift_thres_list", ".", "index", "(", "100", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'10 degree, 5cm: {:.1f}'", ".", "format", "(", "pose_aps", "[", "-", "1", ",", "degree_thres_list", ".", "index", "(", "10", ")", ",", "shift_thres_list", ".", "index", "(", "5", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'10 degree, 10cm: {:.1f}'", ".", "format", "(", "pose_aps", "[", "-", "1", ",", "degree_thres_list", ".", "index", "(", "10", ")", ",", "shift_thres_list", ".", "index", "(", "10", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'15 degree, 5cm: {:.1f}'", ".", "format", "(", "pose_aps", "[", "-", "1", ",", "degree_thres_list", ".", "index", "(", "15", ")", ",", "shift_thres_list", ".", "index", "(", "5", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'15 degree, 10cm: {:.1f}'", ".", "format", "(", "pose_aps", "[", "-", "1", ",", "degree_thres_list", ".", "index", "(", "15", ")", ",", "shift_thres_list", ".", "index", "(", "10", ")", "]", "*", "100", ")", ")", "\n", "\n", "\n", "return", "iou_3d_aps", ",", "pose_aps", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_2D_projection_mAP": [[2013, 2283], ["len", "list", "len", "list", "len", "numpy.zeros", "numpy.zeros", "enumerate", "matplotlib.figure", "matplotlib.subplot", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.xlabel", "os.path.join", "os.path.join", "range", "numpy.mean", "plt.subplot.plot", "plt.subplot.legend", "plt.figure.savefig", "matplotlib.close", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "matplotlib.rc", "os.path.join", "enumerate", "matplotlib.subplots", "enumerate", "print", "matplotlib.savefig", "print", "matplotlib.figure", "matplotlib.subplot", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.xlim", "matplotlib.xlabel", "range", "plt.subplot.plot", "os.path.join", "plt.figure.legend", "plt.figure.savefig", "matplotlib.close", "print", "print", "print", "print", "print", "print", "print", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "print", "result[].astype", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "range", "print", "enumerate", "plt.subplot.plot", "open", "_pickle.dump", "range", "numpy.mean", "open", "_pickle.dump", "axarr[].set_title", "axarr[].set", "axarr[].set_xlim", "axarr[].set_ylim", "axarr[].plot", "glob.glob", "axarr[].legend", "ax.label_outer", "ax.set", "ax.grid", "os.path.join", "print", "plt.subplot.plot", "range", "range", "range", "range", "range", "range", "len", "utils.compute_3d_matches", "len", "numpy.concatenate", "numpy.tile", "numpy.concatenate", "numpy.concatenate", "utils.compute_RT_projection_2d_overlaps", "utils.compute_match_from_projection_2d_dist", "numpy.concatenate", "numpy.tile", "numpy.concatenate", "numpy.concatenate", "utils.compute_ap_from_matches_scores", "utils.compute_ap_from_matches_scores", "numpy.loadtxt", "axarr[].plot", "len", "len", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "len", "numpy.zeros", "numpy.ones_like", "list().index", "os.path.basename", "len", "numpy.ones", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "list", "len", "len", "len", "len", "len", "len", "len", "list.index", "list.index", "list.index", "list.index", "list.index", "list.index", "list.index"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_3d_matches", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_projection_2d_overlaps", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_match_from_projection_2d_dist", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_ap_from_matches_scores", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_ap_from_matches_scores"], ["", "def", "compute_2D_projection_mAP", "(", "final_results", ",", "synset_names", ",", "log_dir", ",", "meshes", ",", "intrinsics", ",", "iou_3d_thresholds", "=", "[", "0.1", "]", ",", "iou_pose_thres", "=", "0.1", ",", "projection_2d_thresholds", "=", "[", "5", "]", ",", "use_matches_for_pose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute Average Precision at a set IoU threshold (default 0.5).\n    Returns:\n    mAP: Mean Average Precision\n    precisions: List of precisions at different class score thresholds.\n    recalls: List of recall values at different class score thresholds.\n    overlaps: [pred_boxes, gt_boxes] IoU overlaps.\n    \"\"\"", "\n", "\n", "num_classes", "=", "len", "(", "synset_names", ")", "\n", "\n", "iou_thres_list", "=", "list", "(", "iou_3d_thresholds", ")", "\n", "num_iou_thres", "=", "len", "(", "iou_thres_list", ")", "\n", "\n", "projection_thres_list", "=", "list", "(", "projection_2d_thresholds", ")", "\n", "num_projection_thres", "=", "len", "(", "projection_thres_list", ")", "\n", "\n", "if", "use_matches_for_pose", ":", "\n", "        ", "assert", "iou_pose_thres", "in", "iou_thres_list", "\n", "\n", "", "iou_3d_aps", "=", "np", ".", "zeros", "(", "(", "num_classes", "+", "1", ",", "num_iou_thres", ")", ")", "\n", "iou_pred_matches_all", "=", "[", "np", ".", "zeros", "(", "(", "num_iou_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "iou_pred_scores_all", "=", "[", "np", ".", "zeros", "(", "(", "num_iou_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "iou_gt_matches_all", "=", "[", "np", ".", "zeros", "(", "(", "num_iou_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "\n", "\n", "projection_2d_aps", "=", "np", ".", "zeros", "(", "(", "num_classes", "+", "1", ",", "num_projection_thres", ")", ")", "\n", "projection_pred_matches_all", "=", "[", "np", ".", "zeros", "(", "(", "num_projection_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "projection_pred_scores_all", "=", "[", "np", ".", "zeros", "(", "(", "num_projection_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "projection_gt_matches_all", "=", "[", "np", ".", "zeros", "(", "(", "num_projection_thres", ",", "0", ")", ")", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "\n", "\n", "# loop over results to gather pred matches and gt matches for iou and pose metrics", "\n", "progress", "=", "0", "\n", "for", "progress", ",", "result", "in", "enumerate", "(", "final_results", ")", ":", "\n", "        ", "print", "(", "progress", ",", "len", "(", "final_results", ")", ")", "\n", "gt_class_ids", "=", "result", "[", "'gt_class_ids'", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "gt_RTs", "=", "np", ".", "array", "(", "result", "[", "'gt_RTs'", "]", ")", "\n", "gt_scales", "=", "np", ".", "array", "(", "result", "[", "'gt_scales'", "]", ")", "\n", "gt_handle_visibility", "=", "result", "[", "'gt_handle_visibility'", "]", "\n", "\n", "pred_bboxes", "=", "np", ".", "array", "(", "result", "[", "'pred_bboxes'", "]", ")", "\n", "pred_class_ids", "=", "result", "[", "'pred_class_ids'", "]", "\n", "pred_scales", "=", "result", "[", "'pred_scales'", "]", "\n", "pred_scores", "=", "result", "[", "'pred_scores'", "]", "\n", "pred_RTs", "=", "np", ".", "array", "(", "result", "[", "'pred_RTs'", "]", ")", "\n", "#print(pred_bboxes.shape[0], pred_class_ids.shape[0], pred_scores.shape[0], pred_RTs.shape[0])", "\n", "\n", "if", "len", "(", "gt_class_ids", ")", "==", "0", "and", "len", "(", "pred_class_ids", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "\n", "", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "# get gt and predictions in this class", "\n", "            ", "cls_gt_class_ids", "=", "gt_class_ids", "[", "gt_class_ids", "==", "cls_id", "]", "if", "len", "(", "gt_class_ids", ")", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_gt_scales", "=", "gt_scales", "[", "gt_class_ids", "==", "cls_id", "]", "if", "len", "(", "gt_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "3", ")", ")", "\n", "cls_gt_RTs", "=", "gt_RTs", "[", "gt_class_ids", "==", "cls_id", "]", "if", "len", "(", "gt_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", "\n", "\n", "cls_pred_class_ids", "=", "pred_class_ids", "[", "pred_class_ids", "==", "cls_id", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_pred_bboxes", "=", "pred_bboxes", "[", "pred_class_ids", "==", "cls_id", ",", ":", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", "\n", "cls_pred_scores", "=", "pred_scores", "[", "pred_class_ids", "==", "cls_id", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_pred_RTs", "=", "pred_RTs", "[", "pred_class_ids", "==", "cls_id", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", "\n", "cls_pred_scales", "=", "pred_scales", "[", "pred_class_ids", "==", "cls_id", "]", "if", "len", "(", "pred_class_ids", ")", "else", "np", ".", "zeros", "(", "(", "0", ",", "3", ")", ")", "\n", "\n", "\n", "# calculate the overlap between each gt instance and pred instance", "\n", "if", "synset_names", "[", "cls_id", "]", "!=", "'mug'", ":", "\n", "                ", "cls_gt_handle_visibility", "=", "np", ".", "ones_like", "(", "cls_gt_class_ids", ")", "\n", "", "else", ":", "\n", "                ", "cls_gt_handle_visibility", "=", "gt_handle_visibility", "[", "gt_class_ids", "==", "cls_id", "]", "if", "len", "(", "gt_class_ids", ")", "else", "np", ".", "ones", "(", "0", ")", "\n", "\n", "\n", "", "iou_cls_gt_match", ",", "iou_cls_pred_match", ",", "_", ",", "iou_pred_indices", "=", "compute_3d_matches", "(", "cls_gt_class_ids", ",", "cls_gt_RTs", ",", "cls_gt_scales", ",", "cls_gt_handle_visibility", ",", "synset_names", ",", "\n", "cls_pred_bboxes", ",", "cls_pred_class_ids", ",", "cls_pred_scores", ",", "cls_pred_RTs", ",", "cls_pred_scales", ",", "\n", "iou_thres_list", ")", "\n", "if", "len", "(", "iou_pred_indices", ")", ":", "\n", "                ", "cls_pred_class_ids", "=", "cls_pred_class_ids", "[", "iou_pred_indices", "]", "\n", "cls_pred_RTs", "=", "cls_pred_RTs", "[", "iou_pred_indices", "]", "\n", "cls_pred_scores", "=", "cls_pred_scores", "[", "iou_pred_indices", "]", "\n", "cls_pred_bboxes", "=", "cls_pred_bboxes", "[", "iou_pred_indices", "]", "\n", "\n", "\n", "", "iou_pred_matches_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "iou_pred_matches_all", "[", "cls_id", "]", ",", "iou_cls_pred_match", ")", ",", "axis", "=", "-", "1", ")", "\n", "cls_pred_scores_tile", "=", "np", ".", "tile", "(", "cls_pred_scores", ",", "(", "num_iou_thres", ",", "1", ")", ")", "\n", "iou_pred_scores_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "iou_pred_scores_all", "[", "cls_id", "]", ",", "cls_pred_scores_tile", ")", ",", "axis", "=", "-", "1", ")", "\n", "assert", "iou_pred_matches_all", "[", "cls_id", "]", ".", "shape", "[", "1", "]", "==", "iou_pred_scores_all", "[", "cls_id", "]", ".", "shape", "[", "1", "]", "\n", "iou_gt_matches_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "iou_gt_matches_all", "[", "cls_id", "]", ",", "iou_cls_gt_match", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "if", "use_matches_for_pose", ":", "\n", "                ", "thres_ind", "=", "list", "(", "iou_thres_list", ")", ".", "index", "(", "iou_pose_thres", ")", "\n", "\n", "iou_thres_pred_match", "=", "iou_cls_pred_match", "[", "thres_ind", ",", ":", "]", "\n", "\n", "\n", "cls_pred_class_ids", "=", "cls_pred_class_ids", "[", "iou_thres_pred_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_pred_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_pred_RTs", "=", "cls_pred_RTs", "[", "iou_thres_pred_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_pred_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", "\n", "cls_pred_scores", "=", "cls_pred_scores", "[", "iou_thres_pred_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_pred_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_pred_bboxes", "=", "cls_pred_bboxes", "[", "iou_thres_pred_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_pred_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", "\n", "\n", "\n", "iou_thres_gt_match", "=", "iou_cls_gt_match", "[", "thres_ind", ",", ":", "]", "\n", "cls_gt_class_ids", "=", "cls_gt_class_ids", "[", "iou_thres_gt_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_gt_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "0", ")", "\n", "cls_gt_RTs", "=", "cls_gt_RTs", "[", "iou_thres_gt_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_gt_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", "\n", "cls_gt_handle_visibility", "=", "cls_gt_handle_visibility", "[", "iou_thres_gt_match", ">", "-", "1", "]", "if", "len", "(", "iou_thres_gt_match", ")", ">", "0", "else", "np", ".", "zeros", "(", "0", ")", "\n", "\n", "\n", "\n", "", "RT_projection_2d_overlaps", "=", "compute_RT_projection_2d_overlaps", "(", "cls_gt_class_ids", ",", "cls_gt_RTs", ",", "cls_gt_handle_visibility", ",", "\n", "cls_pred_class_ids", ",", "cls_pred_RTs", ",", "\n", "meshes", ",", "intrinsics", ",", "synset_names", ")", "\n", "\n", "\n", "projection_cls_gt_match", ",", "projection_cls_pred_match", "=", "compute_match_from_projection_2d_dist", "(", "RT_projection_2d_overlaps", ",", "\n", "cls_pred_class_ids", ",", "\n", "cls_gt_class_ids", ",", "\n", "projection_thres_list", ")", "\n", "\n", "\n", "projection_pred_matches_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "projection_pred_matches_all", "[", "cls_id", "]", ",", "projection_cls_pred_match", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "cls_pred_scores_tile", "=", "np", ".", "tile", "(", "cls_pred_scores", ",", "(", "num_projection_thres", ",", "1", ")", ")", "\n", "projection_pred_scores_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "projection_pred_scores_all", "[", "cls_id", "]", ",", "cls_pred_scores_tile", ")", ",", "axis", "=", "-", "1", ")", "\n", "assert", "projection_pred_scores_all", "[", "cls_id", "]", ".", "shape", "[", "1", "]", "==", "projection_pred_matches_all", "[", "cls_id", "]", ".", "shape", "[", "1", "]", ",", "'{} vs. {}'", ".", "format", "(", "projection_pred_scores_all", "[", "cls_id", "]", ".", "shape", ",", "projection_pred_matches_all", "[", "cls_id", "]", ".", "shape", ")", "\n", "projection_gt_matches_all", "[", "cls_id", "]", "=", "np", ".", "concatenate", "(", "(", "projection_gt_matches_all", "[", "cls_id", "]", ",", "projection_cls_gt_match", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "\n", "\n", "# draw iou 3d AP vs. iou thresholds", "\n", "", "", "fig_iou", "=", "plt", ".", "figure", "(", ")", "\n", "ax_iou", "=", "plt", ".", "subplot", "(", "111", ")", "\n", "plt", ".", "ylabel", "(", "'AP'", ")", "\n", "plt", ".", "ylim", "(", "(", "0", ",", "1", ")", ")", "\n", "plt", ".", "xlabel", "(", "'3D IoU thresholds'", ")", "\n", "iou_output_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "'IoU_3D_AP_{}-{}.png'", ".", "format", "(", "iou_thres_list", "[", "0", "]", ",", "iou_thres_list", "[", "-", "1", "]", ")", ")", "\n", "iou_dict_pkl_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "'IoU_3D_AP_{}-{}.pkl'", ".", "format", "(", "iou_thres_list", "[", "0", "]", ",", "iou_thres_list", "[", "-", "1", "]", ")", ")", "\n", "\n", "iou_dict", "=", "{", "}", "\n", "iou_dict", "[", "'thres_list'", "]", "=", "iou_thres_list", "\n", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "        ", "class_name", "=", "synset_names", "[", "cls_id", "]", "\n", "print", "(", "class_name", ")", "\n", "for", "s", ",", "iou_thres", "in", "enumerate", "(", "iou_thres_list", ")", ":", "\n", "            ", "iou_3d_aps", "[", "cls_id", ",", "s", "]", "=", "compute_ap_from_matches_scores", "(", "iou_pred_matches_all", "[", "cls_id", "]", "[", "s", ",", ":", "]", ",", "\n", "iou_pred_scores_all", "[", "cls_id", "]", "[", "s", ",", ":", "]", ",", "\n", "iou_gt_matches_all", "[", "cls_id", "]", "[", "s", ",", ":", "]", ")", "\n", "", "ax_iou", ".", "plot", "(", "iou_thres_list", ",", "iou_3d_aps", "[", "cls_id", ",", ":", "]", ",", "label", "=", "class_name", ")", "\n", "\n", "", "iou_3d_aps", "[", "-", "1", ",", ":", "]", "=", "np", ".", "mean", "(", "iou_3d_aps", "[", "1", ":", "-", "1", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "ax_iou", ".", "plot", "(", "iou_thres_list", ",", "iou_3d_aps", "[", "-", "1", ",", ":", "]", ",", "label", "=", "'mean'", ")", "\n", "ax_iou", ".", "legend", "(", ")", "\n", "fig_iou", ".", "savefig", "(", "iou_output_path", ")", "\n", "plt", ".", "close", "(", "fig_iou", ")", "\n", "\n", "iou_dict", "[", "'aps'", "]", "=", "iou_3d_aps", "\n", "with", "open", "(", "iou_dict_pkl_path", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "cPickle", ".", "dump", "(", "iou_dict", ",", "f", ")", "\n", "\n", "\n", "# draw pose AP vs. thresholds", "\n", "", "if", "use_matches_for_pose", ":", "\n", "        ", "prefix", "=", "'Pose_Only_'", "\n", "", "else", ":", "\n", "        ", "prefix", "=", "'Pose_Detection_'", "\n", "\n", "\n", "", "LINE_WIDTH", "=", "3.0", "\n", "AXES_TITLE_SIZE", "=", "28", "\n", "XTICK_SIZE", "=", "28", "\n", "YTICK_SIZE", "=", "28", "\n", "LEGEND_SIZE", "=", "24", "\n", "TITLE_SIZE", "=", "32", "\n", "\n", "# plt.rc('font', size=SMALL_SIZE)          # controls default text sizes", "\n", "plt", ".", "rc", "(", "'axes'", ",", "titlesize", "=", "TITLE_SIZE", ")", "# fontsize of the axes title", "\n", "plt", ".", "rc", "(", "'axes'", ",", "labelsize", "=", "AXES_TITLE_SIZE", ")", "# fontsize of the x and y labels", "\n", "plt", ".", "rc", "(", "'xtick'", ",", "labelsize", "=", "XTICK_SIZE", ")", "# fontsize of the tick labels", "\n", "plt", ".", "rc", "(", "'ytick'", ",", "labelsize", "=", "YTICK_SIZE", ")", "# fontsize of the tick labels", "\n", "plt", ".", "rc", "(", "'legend'", ",", "fontsize", "=", "LEGEND_SIZE", ")", "# legend fontsize", "\n", "plt", ".", "rc", "(", "'figure'", ",", "titlesize", "=", "TITLE_SIZE", ")", "# fontsize of the figure title", "\n", "\n", "plt", ".", "rcParams", "[", "'font.family'", "]", "=", "'Bahnschrift'", "\n", "\n", "\n", "projection_dict_pkl_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "prefix", "+", "'Projection_2D_AP_{}-{}pixel.pkl'", ".", "format", "(", "projection_thres_list", "[", "0", "]", ",", "projection_thres_list", "[", "-", "1", "]", ")", ")", "\n", "pose_dict", "=", "{", "}", "\n", "pose_dict", "[", "'projection_thres_list'", "]", "=", "projection_thres_list", "\n", "\n", "for", "i", ",", "projection_thres", "in", "enumerate", "(", "projection_thres_list", ")", ":", "\n", "        ", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "            ", "projection_2d_aps", "[", "cls_id", ",", "i", "]", "=", "compute_ap_from_matches_scores", "(", "projection_pred_matches_all", "[", "cls_id", "]", "[", "i", ",", ":", "]", ",", "\n", "projection_pred_scores_all", "[", "cls_id", "]", "[", "i", ",", ":", "]", ",", "\n", "projection_gt_matches_all", "[", "cls_id", "]", "[", "i", ",", ":", "]", ")", "\n", "\n", "\n", "", "projection_2d_aps", "[", "-", "1", ",", "i", "]", "=", "np", ".", "mean", "(", "projection_2d_aps", "[", "1", ":", "-", "1", ",", "i", "]", ")", "\n", "\n", "", "pose_dict", "[", "'aps'", "]", "=", "projection_2d_aps", "\n", "with", "open", "(", "projection_dict_pkl_path", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "cPickle", ".", "dump", "(", "pose_dict", ",", "f", ")", "\n", "\n", "", "plot_data_dir", "=", "'data/linemod/plots'", "\n", "f", ",", "axarr", "=", "plt", ".", "subplots", "(", "2", ",", "4", ",", "figsize", "=", "(", "20", ",", "8", ")", ",", "dpi", "=", "50", ")", "\n", "for", "i", ",", "cls_id", "in", "enumerate", "(", "[", "1", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", "]", ")", ":", "\n", "\n", "        ", "class_name", "=", "synset_names", "[", "cls_id", "]", "\n", "\n", "axarr", "[", "i", "]", ".", "set_title", "(", "class_name", ")", "\n", "axarr", "[", "i", "]", ".", "set", "(", "xlabel", "=", "'Pixel threshold'", ",", "ylabel", "=", "'AP %'", ")", "\n", "axarr", "[", "i", "]", ".", "set_xlim", "(", "[", "0", ",", "25", "]", ")", "\n", "axarr", "[", "i", "]", ".", "set_ylim", "(", "[", "0", ",", "101", "]", ")", "\n", "axarr", "[", "i", "]", ".", "plot", "(", "projection_thres_list", ",", "projection_2d_aps", "[", "cls_id", ",", ":", "]", "*", "100", ",", "label", "=", "'Ours'", ",", "linewidth", "=", "LINE_WIDTH", ")", "\n", "\n", "others_data_dir", "=", "plot_data_dir", "+", "'/'", "+", "class_name", "\n", "curve_data", "=", "glob", ".", "glob", "(", "others_data_dir", ",", "'*.txt'", ")", "\n", "for", "curve_path", "in", "curve_data", ":", "\n", "            ", "curve_name", "=", "os", ".", "path", ".", "basename", "(", "curve_path", ")", "[", ":", "-", "4", "]", "\n", "if", "curve_name", "==", "'bb8'", ":", "\n", "                ", "curve_name", "=", "'BB8'", "\n", "", "elif", "curve_name", "==", "'posecnn'", ":", "\n", "                ", "curve_name", "=", "'PoseCNN'", "\n", "", "elif", "curve_name", "==", "'tekin'", ":", "\n", "                ", "curve_name", "=", "'Tekin et al.'", "\n", "", "else", ":", "\n", "                ", "assert", "False", ",", "curve_name", "\n", "", "curve", "=", "np", ".", "loadtxt", "(", "curve_path", ")", "\n", "axarr", "[", "i", "]", ".", "plot", "(", "curve", "[", ":", ",", "0", "]", ",", "curve", "[", ":", ",", "1", "]", ",", "label", "=", "curve_name", ",", "linewidth", "=", "LINE_WIDTH", ")", "\n", "\n", "", "axarr", "[", "i", "]", ".", "legend", "(", "loc", "=", "'lower right'", ")", "\n", "\n", "\n", "\n", "", "for", "ax", "in", "axarr", ".", "flat", ":", "\n", "        ", "ax", ".", "label_outer", "(", ")", "\n", "ax", ".", "set", "(", "ylim", "=", "(", "0", ",", "101", ")", ")", "\n", "ax", ".", "grid", "(", "True", ")", "\n", "\n", "\n", "", "print", "(", "output_dir", ")", "\n", "plt", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'result.png'", ")", ")", "\n", "print", "(", "'saved.'", ")", "\n", "\n", "fig_pose", "=", "plt", ".", "figure", "(", ")", "\n", "ax_pose", "=", "plt", ".", "subplot", "(", "111", ")", "\n", "plt", ".", "ylabel", "(", "'AP'", ")", "\n", "plt", ".", "ylim", "(", "(", "0", ",", "1.02", ")", ")", "\n", "plt", ".", "xlim", "(", "(", "projection_thres_list", "[", "0", "]", ",", "projection_thres_list", "[", "-", "1", "]", ")", ")", "\n", "plt", ".", "xlabel", "(", "'Reprojection error thresholds/pixel'", ")", "\n", "\n", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "        ", "class_name", "=", "synset_names", "[", "cls_id", "]", "\n", "print", "(", "class_name", ")", "\n", "ax_pose", ".", "plot", "(", "projection_thres_list", ",", "projection_2d_aps", "[", "cls_id", ",", ":", "]", ",", "label", "=", "class_name", ")", "\n", "", "ax_pose", ".", "plot", "(", "projection_thres_list", ",", "projection_2d_aps", "[", "-", "1", ",", ":", "]", ",", "label", "=", "'mean'", ")", "\n", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "prefix", "+", "'Projection_2D_AP_{}-{}pixel.png'", ".", "format", "(", "projection_thres_list", "[", "0", "]", ",", "projection_thres_list", "[", "-", "1", "]", ")", ")", "\n", "fig_pose", ".", "legend", "(", ")", "\n", "fig_pose", ".", "savefig", "(", "output_path", ")", "\n", "plt", ".", "close", "(", "fig_pose", ")", "\n", "\n", "\n", "print", "(", "'3D IoU at 25: {:.1f}'", ".", "format", "(", "iou_3d_aps", "[", "-", "1", ",", "iou_thres_list", ".", "index", "(", "0.25", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'3D IoU at 50: {:.1f}'", ".", "format", "(", "iou_3d_aps", "[", "-", "1", ",", "iou_thres_list", ".", "index", "(", "0.5", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'2D Projection at 2.5 pixel: {:.1f}'", ".", "format", "(", "projection_2d_aps", "[", "-", "1", ",", "projection_thres_list", ".", "index", "(", "2.5", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'2D Projection at 5 pixel: {:.1f}'", ".", "format", "(", "projection_2d_aps", "[", "-", "1", ",", "projection_thres_list", ".", "index", "(", "5", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'2D Projection at 10 pixel: {:.1f}'", ".", "format", "(", "projection_2d_aps", "[", "-", "1", ",", "projection_thres_list", ".", "index", "(", "10", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'2D Projection at 15 pixel: {:.1f}'", ".", "format", "(", "projection_2d_aps", "[", "-", "1", ",", "projection_thres_list", ".", "index", "(", "15", ")", "]", "*", "100", ")", ")", "\n", "print", "(", "'2D Projection at 20 pixel: {:.1f}'", ".", "format", "(", "projection_2d_aps", "[", "-", "1", ",", "projection_thres_list", ".", "index", "(", "20", ")", "]", "*", "100", ")", ")", "\n", "\n", "\n", "return", "iou_3d_aps", ",", "projection_2d_aps", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_coords_aps": [[2285, 2389], ["len", "len", "len", "range", "enumerate", "range", "print", "result[].astype", "numpy.array", "numpy.array", "numpy.array", "result[].astype", "numpy.array", "numpy.array", "numpy.array", "range", "numpy.array", "print", "len", "len", "len", "utils.compute_matches", "len", "len", "range", "numpy.mean", "len", "int", "utils.compute_mean_l1_coord_diff", "mean_coord_dist_cls[].append"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_matches", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_mean_l1_coord_diff"], ["", "def", "compute_coords_aps", "(", "final_results", ",", "synset_names", ",", "iou_thresholds", ",", "coord_thresholds", ")", ":", "\n", "    ", "\"\"\"Compute Average Precision at a set IoU threshold (default 0.5).\n    Returns:\n    mAP: Mean Average Precision\n    precisions: List of precisions at different class score thresholds.\n    recalls: List of recall values at different class score thresholds.\n    overlaps: [pred_boxes, gt_boxes] IoU overlaps.\n    \"\"\"", "\n", "\n", "num_classes", "=", "len", "(", "synset_names", ")", "\n", "num_iou_thres", "=", "len", "(", "iou_thresholds", ")", "\n", "num_coord_thres", "=", "len", "(", "coord_thresholds", ")", "\n", "\n", "mean_coord_dist_cls", "=", "{", "}", "\n", "\n", "#     pred_matches_all = {}", "\n", "#     pred_scores_all = {}", "\n", "#     gt_matches_all = {}", "\n", "\n", "\n", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "        ", "mean_coord_dist_cls", "[", "cls_id", "]", "=", "[", "]", "\n", "#         pred_matches_all[cls_id] = [[[] for _ in range(num_shift_thres)] for _ in range(num_degree_thres)]", "\n", "#         gt_matches_all[cls_id] = [[[] for _ in range(num_shift_thres)] for _ in range(num_degree_thres)]", "\n", "#         pred_scores_all[cls_id] = [[[] for _ in range(num_shift_thres)] for _ in range(num_degree_thres)]", "\n", "\n", "", "progress", "=", "0", "\n", "for", "progress", ",", "result", "in", "enumerate", "(", "final_results", ")", ":", "\n", "        ", "print", "(", "progress", ",", "len", "(", "final_results", ")", ")", "\n", "\n", "gt_class_ids", "=", "result", "[", "'gt_class_ids'", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "gt_bboxes", "=", "np", ".", "array", "(", "result", "[", "'gt_bboxes'", "]", ")", "\n", "gt_masks", "=", "np", ".", "array", "(", "result", "[", "'gt_masks'", "]", ")", "\n", "gt_coords", "=", "np", ".", "array", "(", "result", "[", "'gt_coords'", "]", ")", "\n", "\n", "#print(gt_class_ids.shape, gt_bboxes.shape, gt_masks.shape, gt_coords.shape)", "\n", "#gt_scales = result['gt_scale']", "\n", "\n", "pred_class_ids", "=", "result", "[", "'pred_class_ids'", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "pred_bboxes", "=", "np", ".", "array", "(", "result", "[", "'pred_bboxes'", "]", ")", "\n", "pred_masks", "=", "np", ".", "array", "(", "result", "[", "'pred_masks'", "]", ")", "\n", "pred_coords", "=", "np", ".", "array", "(", "result", "[", "'pred_coords'", "]", ")", "\n", "pred_scores", "=", "result", "[", "'pred_scores'", "]", "\n", "#print(pred_class_ids.shape, pred_bboxes.shape, pred_masks.shape, pred_coords.shape)", "\n", "\n", "\n", "\n", "\n", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "# get gt and predictions in this class", "\n", "            ", "if", "(", "len", "(", "gt_class_ids", ")", ")", ":", "\n", "                ", "cls_gt_class_ids", "=", "gt_class_ids", "[", "gt_class_ids", "==", "cls_id", "]", "\n", "cls_gt_bboxes", "=", "gt_bboxes", "[", "gt_class_ids", "==", "cls_id", "]", "\n", "cls_gt_masks", "=", "gt_masks", "[", "...", ",", "gt_class_ids", "==", "cls_id", "]", "\n", "cls_gt_coords", "=", "gt_coords", "[", "...", ",", "gt_class_ids", "==", "cls_id", ",", ":", "]", "\n", "", "else", ":", "\n", "                ", "cls_gt_class_ids", "=", "[", "]", "\n", "cls_gt_bboxes", "=", "[", "]", "\n", "cls_gt_masks", "=", "[", "]", "\n", "cls_gt_coords", "=", "[", "]", "\n", "\n", "", "if", "(", "len", "(", "pred_class_ids", ")", ")", ":", "\n", "                ", "cls_pred_class_ids", "=", "pred_class_ids", "[", "pred_class_ids", "==", "cls_id", "]", "\n", "cls_pred_bboxes", "=", "pred_bboxes", "[", "pred_class_ids", "==", "cls_id", "]", "\n", "cls_pred_scores", "=", "pred_scores", "[", "pred_class_ids", "==", "cls_id", "]", "\n", "cls_pred_masks", "=", "pred_masks", "[", ":", ",", ":", ",", "pred_class_ids", "==", "cls_id", "]", "\n", "cls_pred_coords", "=", "pred_coords", "[", ":", ",", ":", ",", "pred_class_ids", "==", "cls_id", ",", ":", "]", "\n", "", "else", ":", "\n", "                ", "cls_pred_class_ids", "=", "[", "]", "\n", "cls_pred_bboxes", "=", "[", "]", "\n", "cls_pred_scores", "=", "[", "]", "\n", "cls_pred_masks", "=", "[", "]", "\n", "cls_pred_coords", "=", "[", "]", "\n", "\n", "# calculate the overlap between each gt instance and pred instance", "\n", "\n", "", "gt_match", ",", "pred_match", ",", "overlaps", ",", "pred_indices", "=", "compute_matches", "(", "cls_gt_bboxes", ",", "cls_gt_class_ids", ",", "cls_gt_masks", ",", "\n", "cls_pred_bboxes", ",", "cls_pred_class_ids", ",", "cls_pred_scores", ",", "\n", "cls_pred_masks", ",", "0.5", ")", "\n", "\n", "if", "len", "(", "gt_match", ")", "and", "len", "(", "pred_match", ")", ":", "\n", "\n", "                ", "cls_pred_masks_sorted", "=", "cls_pred_masks", "[", "...", ",", "pred_indices", "]", "\n", "cls_pred_coords_sorted", "=", "cls_pred_coords", "[", "...", ",", "pred_indices", ",", ":", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "pred_match", ")", ")", ":", "\n", "                    ", "if", "pred_match", "[", "i", "]", ">", "-", "1", ":", "\n", "                        ", "j", "=", "int", "(", "pred_match", "[", "i", "]", ")", "\n", "mean_coord_dist", "=", "compute_mean_l1_coord_diff", "(", "cls_pred_masks_sorted", "[", "...", ",", "i", "]", ",", "\n", "cls_gt_masks", "[", "...", ",", "j", "]", ",", "\n", "cls_pred_coords_sorted", "[", "...", ",", "i", ",", ":", "]", ",", "\n", "cls_gt_coords", "[", "...", ",", "j", ",", ":", "]", ",", "\n", "synset_names", ",", "\n", "cls_id", ")", "\n", "#print(mean_coord_dist)", "\n", "\n", "mean_coord_dist_cls", "[", "cls_id", "]", ".", "append", "(", "mean_coord_dist", ")", "\n", "#print(mean_coord_dist_cls[cls_id])", "\n", "\n", "\n", "\n", "", "", "", "", "", "for", "cls_id", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "        ", "mean_coord_dist_cls", "[", "cls_id", "]", "=", "np", ".", "array", "(", "mean_coord_dist_cls", "[", "cls_id", "]", ")", "\n", "print", "(", "'mean coord dist of {} class: {}'", ".", "format", "(", "synset_names", "[", "cls_id", "]", ",", "np", ".", "mean", "(", "mean_coord_dist_cls", "[", "cls_id", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_3d_matches_degree_cm": [[2391, 2466], ["len", "len", "len", "numpy.zeros", "range", "range", "len", "utils.trim_zeros", "len", "range", "numpy.ones", "numpy.ones", "len", "numpy.argsort", "numpy.argsort", "compute_RT_upper_bound_symmetry"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.trim_zeros"], ["", "", "def", "compute_3d_matches_degree_cm", "(", "gt_class_ids", ",", "gt_RTs", ",", "gt_scales", ",", "\n", "pred_boxes", ",", "pred_class_ids", ",", "pred_scores", ",", "pred_RTs", ",", "\n", "synset_names", ",", "\n", "thres_shift", "=", "5", ",", "\n", "thres_degree", "=", "5", ",", "\n", "bound_threshold", "=", "5", ")", ":", "\n", "    ", "\"\"\"Finds matches between prediction and ground truth instances.\n    Returns:\n        gt_match: 1-D array. For each GT box it has the index of the matched\n                  predicted box.\n        pred_match: 1-D array. For each predicted box, it has the index of\n                    the matched ground truth box.\n        overlaps: [pred_boxes, gt_boxes] IoU overlaps.\n    \"\"\"", "\n", "# Trim zero padding", "\n", "# TODO: cleaner to do zero unpadding upstream", "\n", "if", "len", "(", "pred_boxes", ")", ":", "\n", "        ", "pre_len", "=", "len", "(", "pred_boxes", ")", "\n", "pred_boxes", "=", "trim_zeros", "(", "pred_boxes", ")", "\n", "after_len", "=", "len", "(", "pred_boxes", ")", "\n", "assert", "pre_len", "==", "after_len", "\n", "pred_scores", "=", "pred_scores", "[", ":", "pred_boxes", ".", "shape", "[", "0", "]", "]", "\n", "# Sort predictions by score from high to low", "\n", "indices", "=", "np", ".", "argsort", "(", "pred_scores", ")", "[", ":", ":", "-", "1", "]", "\n", "pred_boxes", "=", "pred_boxes", "[", "indices", "]", "\n", "pred_class_ids", "=", "pred_class_ids", "[", "indices", "]", "\n", "pred_scores", "=", "pred_scores", "[", "indices", "]", "\n", "\n", "# print('num of gt instances: {}, num of pred instances: {}'.format(len(gt_class_ids), len(gt_class_ids)))", "\n", "", "num_pred", "=", "len", "(", "pred_boxes", ")", "\n", "num_gt", "=", "len", "(", "gt_class_ids", ")", "\n", "\n", "# Compute IoU overlaps [pred_bboxs gt_bboxs]", "\n", "#overlaps = [[0 for j in range(num_gt)] for i in range(num_pred)]", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "num_pred", ",", "num_gt", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_pred", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_gt", ")", ":", "\n", "            ", "overlaps", "[", "i", ",", "j", "]", "=", "compute_RT_upper_bound_symmetry", "(", "pred_RTs", "[", "i", "]", ",", "\n", "gt_RTs", "[", "j", "]", ",", "\n", "gt_class_ids", "[", "j", "]", ",", "\n", "synset_names", ",", "\n", "thres_shift", "=", "thres_shift", ",", "\n", "thres_theta", "=", "thres_degree", ")", "\n", "\n", "# Loop through predictions and find matching ground truth boxes", "\n", "# multi-level: 5, 10, 15, 20", "\n", "", "", "pred_match", "=", "-", "1", "*", "np", ".", "ones", "(", "num_pred", ")", "\n", "gt_match", "=", "-", "1", "*", "np", ".", "ones", "(", "num_gt", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "pred_boxes", ")", ")", ":", "\n", "# Find best matching ground truth box", "\n", "# 1. Sort matches by bound from low to high", "\n", "        ", "sorted_ixs", "=", "np", ".", "argsort", "(", "overlaps", "[", "i", "]", ")", "\n", "# 2. Remove low scores", "\n", "# low_score_idx = np.where(overlaps[i, sorted_ixs] >= bound_threshold)[0]", "\n", "# if low_score_idx.size > 0:", "\n", "#     sorted_ixs = sorted_ixs[:low_score_idx[0]]", "\n", "# 3. Find the match", "\n", "for", "j", "in", "sorted_ixs", ":", "\n", "# If ground truth box is already matched, go to next one", "\n", "            ", "if", "gt_match", "[", "j", "]", ">", "-", "1", "or", "pred_class_ids", "[", "i", "]", "!=", "gt_class_ids", "[", "j", "]", ":", "\n", "                ", "continue", "\n", "# If we reach IoU smaller than the threshold, end the loop", "\n", "", "min_bound", "=", "overlaps", "[", "i", ",", "j", "]", "\n", "if", "min_bound", ">", "1", ":", "\n", "                ", "break", "\n", "", "elif", "min_bound", "==", "1.0", ":", "\n", "                ", "gt_match", "[", "j", "]", "=", "i", "\n", "pred_match", "[", "i", "]", "=", "j", "\n", "break", "\n", "", "else", ":", "\n", "                ", "assert", "False", ",", "'Invalid overlaps {}'", ".", "format", "(", "min_bound", ")", "\n", "\n", "", "", "", "return", "gt_match", ",", "pred_match", ",", "pred_class_ids", ",", "pred_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_ap": [[2468, 2504], ["utils.compute_matches", "numpy.concatenate", "numpy.concatenate", "range", "numpy.sum", "numpy.cumsum", "numpy.cumsum().astype", "len", "numpy.maximum", "numpy.arange", "len", "numpy.where", "len", "numpy.cumsum"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_matches"], ["", "def", "compute_ap", "(", "gt_boxes", ",", "gt_class_ids", ",", "gt_masks", ",", "\n", "pred_boxes", ",", "pred_class_ids", ",", "pred_scores", ",", "pred_masks", ",", "\n", "iou_threshold", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"Compute Average Precision at a set IoU threshold (default 0.5).\n    Returns:\n    mAP: Mean Average Precision\n    precisions: List of precisions at different class score thresholds.\n    recalls: List of recall values at different class score thresholds.\n    overlaps: [pred_boxes, gt_boxes] IoU overlaps.\n    \"\"\"", "\n", "# Get matches and overlaps", "\n", "gt_match", ",", "pred_match", ",", "overlaps", "=", "compute_matches", "(", "\n", "gt_boxes", ",", "gt_class_ids", ",", "gt_masks", ",", "\n", "pred_boxes", ",", "pred_class_ids", ",", "pred_scores", ",", "pred_masks", ",", "\n", "iou_threshold", ")", "\n", "\n", "# Compute precision and recall at each prediction box step", "\n", "precisions", "=", "np", ".", "cumsum", "(", "pred_match", ">", "-", "1", ")", "/", "(", "np", ".", "arange", "(", "len", "(", "pred_match", ")", ")", "+", "1", ")", "\n", "recalls", "=", "np", ".", "cumsum", "(", "pred_match", ">", "-", "1", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "len", "(", "gt_match", ")", "\n", "\n", "# Pad with start and end values to simplify the math", "\n", "precisions", "=", "np", ".", "concatenate", "(", "[", "[", "0", "]", ",", "precisions", ",", "[", "0", "]", "]", ")", "\n", "recalls", "=", "np", ".", "concatenate", "(", "[", "[", "0", "]", ",", "recalls", ",", "[", "1", "]", "]", ")", "\n", "\n", "# Ensure precision values decrease but don't increase. This way, the", "\n", "# precision value at each recall threshold is the maximum it can be", "\n", "# for all following recall thresholds, as specified by the VOC paper.", "\n", "for", "i", "in", "range", "(", "len", "(", "precisions", ")", "-", "2", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "        ", "precisions", "[", "i", "]", "=", "np", ".", "maximum", "(", "precisions", "[", "i", "]", ",", "precisions", "[", "i", "+", "1", "]", ")", "\n", "\n", "# Compute mean AP over recall range", "\n", "", "indices", "=", "np", ".", "where", "(", "recalls", "[", ":", "-", "1", "]", "!=", "recalls", "[", "1", ":", "]", ")", "[", "0", "]", "+", "1", "\n", "mAP", "=", "np", ".", "sum", "(", "(", "recalls", "[", "indices", "]", "-", "recalls", "[", "indices", "-", "1", "]", ")", "*", "\n", "precisions", "[", "indices", "]", ")", "\n", "\n", "return", "mAP", ",", "precisions", ",", "recalls", ",", "overlaps", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_ap_range": [[2507, 2529], ["numpy.array().mean", "numpy.arange", "utils.compute_ap", "np.array().mean.append", "print", "print", "numpy.array"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_ap"], ["", "def", "compute_ap_range", "(", "gt_box", ",", "gt_class_id", ",", "gt_mask", ",", "\n", "pred_box", ",", "pred_class_id", ",", "pred_score", ",", "pred_mask", ",", "\n", "iou_thresholds", "=", "None", ",", "verbose", "=", "1", ")", ":", "\n", "    ", "\"\"\"Compute AP over a range or IoU thresholds. Default range is 0.5-0.95.\"\"\"", "\n", "# Default is 0.5 to 0.95 with increments of 0.05", "\n", "iou_thresholds", "=", "iou_thresholds", "or", "np", ".", "arange", "(", "0.5", ",", "1.0", ",", "0.05", ")", "\n", "\n", "# Compute AP over range of IoU thresholds", "\n", "AP", "=", "[", "]", "\n", "for", "iou_threshold", "in", "iou_thresholds", ":", "\n", "        ", "ap", ",", "precisions", ",", "recalls", ",", "overlaps", "=", "compute_ap", "(", "gt_box", ",", "gt_class_id", ",", "gt_mask", ",", "\n", "pred_box", ",", "pred_class_id", ",", "pred_score", ",", "pred_mask", ",", "\n", "iou_threshold", "=", "iou_threshold", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"AP @{:.2f}:\\t {:.3f}\"", ".", "format", "(", "iou_threshold", ",", "ap", ")", ")", "\n", "", "AP", ".", "append", "(", "ap", ")", "\n", "", "AP", "=", "np", ".", "array", "(", "AP", ")", ".", "mean", "(", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"AP @{:.2f}-{:.2f}:\\t {:.3f}\"", ".", "format", "(", "\n", "iou_thresholds", "[", "0", "]", ",", "iou_thresholds", "[", "-", "1", "]", ",", "AP", ")", ")", "\n", "", "return", "AP", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_recall": [[2531, 2546], ["utils.compute_overlaps", "numpy.max", "numpy.argmax", "numpy.where", "len", "set"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_overlaps"], ["", "def", "compute_recall", "(", "pred_boxes", ",", "gt_boxes", ",", "iou", ")", ":", "\n", "    ", "\"\"\"Compute the recall at the given IoU threshold. It's an indication\n    of how many GT boxes were found by the given prediction boxes.\n    pred_boxes: [N, (y1, x1, y2, x2)] in image coordinates\n    gt_boxes: [N, (y1, x1, y2, x2)] in image coordinates\n    \"\"\"", "\n", "# Measure overlaps", "\n", "overlaps", "=", "compute_overlaps", "(", "pred_boxes", ",", "gt_boxes", ")", "\n", "iou_max", "=", "np", ".", "max", "(", "overlaps", ",", "axis", "=", "1", ")", "\n", "iou_argmax", "=", "np", ".", "argmax", "(", "overlaps", ",", "axis", "=", "1", ")", "\n", "positive_ids", "=", "np", ".", "where", "(", "iou_max", ">=", "iou", ")", "[", "0", "]", "\n", "matched_gt_boxes", "=", "iou_argmax", "[", "positive_ids", "]", "\n", "\n", "recall", "=", "len", "(", "set", "(", "matched_gt_boxes", ")", ")", "/", "gt_boxes", ".", "shape", "[", "0", "]", "\n", "return", "recall", ",", "positive_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.batch_slice": [[2555, 2589], ["range", "list", "isinstance", "graph_fn", "list.append", "zip", "tensorflow.stack", "len", "isinstance", "len", "zip"], "function", ["None"], ["", "def", "batch_slice", "(", "inputs", ",", "graph_fn", ",", "batch_size", ",", "names", "=", "None", ")", ":", "\n", "    ", "\"\"\"Splits inputs into slices and feeds each slice to a copy of the given\n    computation graph and then combines the results. It allows you to run a\n    graph on a batch of inputs even if the graph is written to support one\n    instance only.\n    inputs: list of tensors. All must have the same first dimension length\n    graph_fn: A function that returns a TF tensor that's part of a graph.\n    batch_size: number of slices to divide the data into.\n    names: If provided, assigns names to the resulting tensors.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "inputs", ",", "list", ")", ":", "\n", "        ", "inputs", "=", "[", "inputs", "]", "\n", "\n", "", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "inputs_slice", "=", "[", "x", "[", "i", "]", "for", "x", "in", "inputs", "]", "\n", "output_slice", "=", "graph_fn", "(", "*", "inputs_slice", ")", "\n", "if", "not", "isinstance", "(", "output_slice", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "            ", "output_slice", "=", "[", "output_slice", "]", "\n", "", "outputs", ".", "append", "(", "output_slice", ")", "\n", "# Change outputs from a list of slices where each is", "\n", "# a list of outputs to a list of outputs and each has", "\n", "# a list of slices", "\n", "", "outputs", "=", "list", "(", "zip", "(", "*", "outputs", ")", ")", "\n", "\n", "if", "names", "is", "None", ":", "\n", "        ", "names", "=", "[", "None", "]", "*", "len", "(", "outputs", ")", "\n", "\n", "", "result", "=", "[", "tf", ".", "stack", "(", "o", ",", "axis", "=", "0", ",", "name", "=", "n", ")", "\n", "for", "o", ",", "n", "in", "zip", "(", "outputs", ",", "names", ")", "]", "\n", "if", "len", "(", "result", ")", "==", "1", ":", "\n", "        ", "result", "=", "result", "[", "0", "]", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.load_mesh": [[2594, 2635], ["numpy.array", "numpy.array", "open", "f.readlines", "l.strip.strip", "l.strip.split", "numpy.amax", "numpy.amin", "numpy.savetxt", "np.array.append", "np.array.append", "numpy.linalg.norm", "mesh_path.replace", "float", "float", "float", "x.split", "int", "int", "int"], "function", ["None"], ["", "def", "load_mesh", "(", "mesh_path", ",", "is_save", "=", "False", ",", "is_normalized", "=", "False", ",", "is_flipped", "=", "False", ")", ":", "\n", "    ", "with", "open", "(", "mesh_path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "# mesh = []", "\n", "# for line in lines:", "\n", "#     if line[:2] == 'v ':", "\n", "#         vertex = line[2:].split(' ')", "\n", "#         vertex = vertex[:3]", "\n", "#         mesh += [[float(x) for x in vertex]]", "\n", "# mesh = np.array(mesh, dtype=np.float32)", "\n", "\n", "", "vertices", "=", "[", "]", "\n", "faces", "=", "[", "]", "\n", "for", "l", "in", "lines", ":", "\n", "        ", "l", "=", "l", ".", "strip", "(", ")", "\n", "words", "=", "l", ".", "split", "(", "' '", ")", "\n", "if", "words", "[", "0", "]", "==", "'v'", ":", "\n", "            ", "vertices", ".", "append", "(", "[", "float", "(", "words", "[", "1", "]", ")", ",", "float", "(", "words", "[", "2", "]", ")", ",", "float", "(", "words", "[", "3", "]", ")", "]", ")", "\n", "", "if", "words", "[", "0", "]", "==", "'f'", ":", "\n", "            ", "face_words", "=", "[", "x", ".", "split", "(", "'/'", ")", "[", "0", "]", "for", "x", "in", "words", "]", "\n", "faces", ".", "append", "(", "[", "int", "(", "face_words", "[", "1", "]", ")", "-", "1", ",", "int", "(", "face_words", "[", "2", "]", ")", "-", "1", ",", "int", "(", "face_words", "[", "3", "]", ")", "-", "1", "]", ")", "\n", "\n", "\n", "", "", "vertices", "=", "np", ".", "array", "(", "vertices", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "# flip mesh to unity rendering", "\n", "if", "is_flipped", ":", "\n", "        ", "vertices", "[", ":", ",", "2", "]", "=", "-", "vertices", "[", ":", ",", "2", "]", "\n", "", "faces", "=", "np", ".", "array", "(", "faces", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "if", "is_normalized", ":", "\n", "        ", "maxs", "=", "np", ".", "amax", "(", "vertices", ",", "axis", "=", "0", ")", "\n", "mins", "=", "np", ".", "amin", "(", "vertices", ",", "axis", "=", "0", ")", "\n", "diffs", "=", "maxs", "-", "mins", "\n", "assert", "diffs", ".", "shape", "[", "0", "]", "==", "3", "\n", "vertices", "=", "vertices", "/", "np", ".", "linalg", ".", "norm", "(", "diffs", ")", "\n", "\n", "", "if", "is_save", ":", "\n", "        ", "np", ".", "savetxt", "(", "mesh_path", ".", "replace", "(", "'.obj'", ",", "'_vertices.txt'", ")", ",", "X", "=", "vertices", ")", "\n", "\n", "", "return", "vertices", ",", "faces", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw": [[2637, 2665], ["numpy.int32().reshape", "zip", "zip", "zip", "cv2.line", "cv2.line", "cv2.line", "int", "int", "int", "cv2.line", "int", "int", "int", "range", "range", "cv2.line", "cv2.line", "tuple", "tuple", "tuple", "tuple", "tuple", "tuple", "numpy.int32", "tuple", "tuple", "tuple", "tuple", "tuple", "tuple"], "function", ["None"], ["", "def", "draw", "(", "img", ",", "imgpts", ",", "axes", ",", "color", ")", ":", "\n", "    ", "imgpts", "=", "np", ".", "int32", "(", "imgpts", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "\n", "\n", "# draw ground layer in darker color", "\n", "color_ground", "=", "(", "int", "(", "color", "[", "0", "]", "*", "0.3", ")", ",", "int", "(", "color", "[", "1", "]", "*", "0.3", ")", ",", "int", "(", "color", "[", "2", "]", "*", "0.3", ")", ")", "\n", "for", "i", ",", "j", "in", "zip", "(", "[", "4", ",", "5", ",", "6", ",", "7", "]", ",", "[", "5", ",", "7", ",", "4", ",", "6", "]", ")", ":", "\n", "        ", "img", "=", "cv2", ".", "line", "(", "img", ",", "tuple", "(", "imgpts", "[", "i", "]", ")", ",", "tuple", "(", "imgpts", "[", "j", "]", ")", ",", "color_ground", ",", "3", ")", "\n", "\n", "\n", "# draw pillars in blue color", "\n", "", "color_pillar", "=", "(", "int", "(", "color", "[", "0", "]", "*", "0.6", ")", ",", "int", "(", "color", "[", "1", "]", "*", "0.6", ")", ",", "int", "(", "color", "[", "2", "]", "*", "0.6", ")", ")", "\n", "for", "i", ",", "j", "in", "zip", "(", "range", "(", "4", ")", ",", "range", "(", "4", ",", "8", ")", ")", ":", "\n", "        ", "img", "=", "cv2", ".", "line", "(", "img", ",", "tuple", "(", "imgpts", "[", "i", "]", ")", ",", "tuple", "(", "imgpts", "[", "j", "]", ")", ",", "color_pillar", ",", "3", ")", "\n", "\n", "\n", "# finally, draw top layer in color", "\n", "", "for", "i", ",", "j", "in", "zip", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "[", "1", ",", "3", ",", "0", ",", "2", "]", ")", ":", "\n", "        ", "img", "=", "cv2", ".", "line", "(", "img", ",", "tuple", "(", "imgpts", "[", "i", "]", ")", ",", "tuple", "(", "imgpts", "[", "j", "]", ")", ",", "color", ",", "3", ")", "\n", "\n", "\n", "# draw axes", "\n", "", "img", "=", "cv2", ".", "line", "(", "img", ",", "tuple", "(", "axes", "[", "0", "]", ")", ",", "tuple", "(", "axes", "[", "1", "]", ")", ",", "(", "0", ",", "0", ",", "255", ")", ",", "3", ")", "\n", "img", "=", "cv2", ".", "line", "(", "img", ",", "tuple", "(", "axes", "[", "0", "]", ")", ",", "tuple", "(", "axes", "[", "3", "]", ")", ",", "(", "255", ",", "0", ",", "0", ")", ",", "3", ")", "\n", "img", "=", "cv2", ".", "line", "(", "img", ",", "tuple", "(", "axes", "[", "0", "]", ")", ",", "tuple", "(", "axes", "[", "2", "]", ")", ",", "(", "0", ",", "255", ",", "0", ")", ",", "3", ")", "## y last", "\n", "\n", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw_coord_mask": [[2668, 2743], ["cdll.LoadLibrary", "numpy.zeros", "cdll.LoadLibrary.InitializeZBuffer", "enumerate", "cv2.imwrite", "cv2.imwrite", "copy.deepcopy().astype", "Vs[].transpose", "numpy.vstack", "projected_pixels.transpose().astype.transpose().astype", "Vs[].copy", "range", "numpy.ones_like", "projected_pixels[].copy", "projected_pixels[].copy", "projected_pixels[].copy", "coordinate[].copy", "coordinate[].copy", "coordinate[].copy", "cdll.LoadLibrary.DrawTriangle", "copy.deepcopy", "numpy.ones", "projected_pixels.transpose().astype.transpose", "c_void_p", "c_void_p", "c_void_p", "c_void_p", "c_void_p", "c_void_p", "c_void_p", "c_void_p"], "function", ["None"], ["", "def", "draw_coord_mask", "(", "image", ",", "class_ids", ",", "RTs", ",", "Vs", ",", "Fs", ",", "intrinsics", ",", "output_path", ",", "is_overlay", "=", "True", ")", ":", "\n", "    ", "Rasterizer", "=", "cdll", ".", "LoadLibrary", "(", "'./libRasterizer.so'", ")", "\n", "# coords = np.copy(image).astype(np.float64)", "\n", "# image = cv2.imread(image_path)[:, :, :3]", "\n", "# image_1 = copy.deepcopy(image)", "\n", "# image_2 = copy.deepcopy(image[:, :, ::-1])", "\n", "\n", "# print(type(image_1), image_1.dtype)", "\n", "# print(type(image_2), image_2.dtype)", "\n", "\n", "# print(np.unique(np.equal(image_1, image_2)))", "\n", "\n", "if", "is_overlay", ":", "\n", "#coords = copy.deepcopy(image[:, :, (0, 1, 2)]).astype(np.float64)", "\n", "        ", "coords", "=", "copy", ".", "deepcopy", "(", "image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "", "else", ":", "\n", "        ", "coords", "=", "255", "*", "np", ".", "ones_like", "(", "image", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "", "masks", "=", "np", ".", "zeros", "(", "(", "image", ".", "shape", "[", "0", "]", ",", "image", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "masks", "[", ":", ",", ":", "]", "=", "255", "\n", "\n", "Rasterizer", ".", "InitializeZBuffer", "(", "image", ".", "shape", "[", "1", "]", ",", "image", ".", "shape", "[", "0", "]", ",", "image", ".", "shape", "[", "2", "]", ")", "\n", "\n", "for", "ind", ",", "RT", "in", "enumerate", "(", "RTs", ")", ":", "\n", "        ", "cls_id", "=", "class_ids", "[", "ind", "]", "\n", "vertices", "=", "Vs", "[", "ind", "]", ".", "transpose", "(", ")", "\n", "number_of_vertex", "=", "vertices", ".", "shape", "[", "1", "]", "\n", "vertices_homogeneous", "=", "np", ".", "vstack", "(", "[", "vertices", ",", "np", ".", "ones", "(", "(", "1", ",", "number_of_vertex", ")", ")", "]", ")", "\n", "\n", "transformed_vertices", "=", "RTs", "[", "ind", "]", "@", "vertices_homogeneous", "\n", "transformed_vertices", "=", "transformed_vertices", "[", ":", "3", ",", ":", "]", "/", "transformed_vertices", "[", "3", ",", ":", "]", "\n", "projected_pixels", "=", "intrinsics", "@", "transformed_vertices", "\n", "projected_pixels", "[", "2", ",", ":", "]", "=", "1.0", "/", "projected_pixels", "[", "2", ",", ":", "]", "\n", "projected_pixels", "[", ":", "2", ",", ":", "]", "=", "projected_pixels", "[", ":", "2", ",", ":", "]", "*", "projected_pixels", "[", "2", ",", ":", "]", "\n", "projected_pixels", "=", "projected_pixels", ".", "transpose", "(", ")", ".", "astype", "(", "np", ".", "float64", ")", "# shape: N*2", "\n", "\n", "\n", "# for pixel in projected_pixels:", "\n", "#     c_x = int(pixel[0])", "\n", "#     c_y = int(pixel[1])", "\n", "#     cv2.circle(image, (c_x, c_y), 1, (0, 0, 255))", "\n", "\n", "# post processing", "\n", "coordinate", "=", "Vs", "[", "ind", "]", ".", "copy", "(", ")", "\n", "coordinate", "+=", "0.5", "# Range 0-1", "\n", "coordinate", "[", ":", ",", "2", "]", "=", "1", "-", "coordinate", "[", ":", ",", "2", "]", "# left coordinate system in coord map", "\n", "\n", "# cv2 imwrite is in order of BGR", "\n", "coordinate", "=", "coordinate", "[", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "\n", "coordinate", "=", "coordinate", "*", "255", "\n", "\n", "F", "=", "Fs", "[", "ind", "]", ";", "\n", "for", "j", "in", "range", "(", "F", ".", "shape", "[", "0", "]", ")", ":", "\n", "#print(F[j, :])", "\n", "            ", "p0", "=", "projected_pixels", "[", "F", "[", "j", ",", "0", "]", "]", ".", "copy", "(", ")", "\n", "p1", "=", "projected_pixels", "[", "F", "[", "j", ",", "1", "]", "]", ".", "copy", "(", ")", "\n", "p2", "=", "projected_pixels", "[", "F", "[", "j", ",", "2", "]", "]", ".", "copy", "(", ")", "\n", "prop0", "=", "coordinate", "[", "F", "[", "j", ",", "0", "]", "]", ".", "copy", "(", ")", "\n", "prop1", "=", "coordinate", "[", "F", "[", "j", ",", "1", "]", "]", ".", "copy", "(", ")", "\n", "prop2", "=", "coordinate", "[", "F", "[", "j", ",", "2", "]", "]", ".", "copy", "(", ")", "\n", "\n", "Rasterizer", ".", "DrawTriangle", "(", "\n", "c_void_p", "(", "p0", ".", "ctypes", ".", "data", ")", ",", "\n", "c_void_p", "(", "p1", ".", "ctypes", ".", "data", ")", ",", "\n", "c_void_p", "(", "p2", ".", "ctypes", ".", "data", ")", ",", "\n", "c_void_p", "(", "prop0", ".", "ctypes", ".", "data", ")", ",", "\n", "c_void_p", "(", "prop1", ".", "ctypes", ".", "data", ")", ",", "\n", "c_void_p", "(", "prop2", ".", "ctypes", ".", "data", ")", ",", "\n", "c_void_p", "(", "coords", ".", "ctypes", ".", "data", ")", ",", "\n", "ind", "+", "1", ",", "\n", "c_void_p", "(", "masks", ".", "ctypes", ".", "data", ")", ")", "\n", "\n", "", "", "mask_output_path", "=", "output_path", "+", "'_mask.png'", "\n", "cv2", ".", "imwrite", "(", "mask_output_path", ",", "masks", ")", "\n", "coord_output_path", "=", "output_path", "+", "'_coord.jpg'", "\n", "cv2", ".", "imwrite", "(", "coord_output_path", ",", "coords", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw_text": [[2745, 2782], ["cv2.getTextSize", "cv2.rectangle", "cv2.rectangle", "cv2.putText", "min", "min", "cv2.rectangle"], "function", ["None"], ["", "def", "draw_text", "(", "draw_image", ",", "bbox", ",", "text", ",", "draw_box", "=", "False", ")", ":", "\n", "    ", "fontFace", "=", "cv2", ".", "FONT_HERSHEY_TRIPLEX", "\n", "fontScale", "=", "1", "\n", "thickness", "=", "1", "\n", "\n", "\n", "retval", ",", "baseline", "=", "cv2", ".", "getTextSize", "(", "text", ",", "fontFace", ",", "fontScale", ",", "thickness", ")", "\n", "\n", "bbox_margin", "=", "10", "\n", "text_margin", "=", "10", "\n", "\n", "text_box_pos_tl", "=", "(", "min", "(", "bbox", "[", "1", "]", "+", "bbox_margin", ",", "635", "-", "retval", "[", "0", "]", "-", "2", "*", "text_margin", ")", ",", "min", "(", "bbox", "[", "2", "]", "+", "bbox_margin", ",", "475", "-", "retval", "[", "1", "]", "-", "2", "*", "text_margin", ")", ")", "\n", "text_box_pos_br", "=", "(", "text_box_pos_tl", "[", "0", "]", "+", "retval", "[", "0", "]", "+", "2", "*", "text_margin", ",", "text_box_pos_tl", "[", "1", "]", "+", "retval", "[", "1", "]", "+", "2", "*", "text_margin", ")", "\n", "\n", "# text_pose is the bottom-left corner of the text", "\n", "text_pos", "=", "(", "text_box_pos_tl", "[", "0", "]", "+", "text_margin", ",", "text_box_pos_br", "[", "1", "]", "-", "text_margin", "-", "3", ")", "\n", "\n", "if", "draw_box", ":", "\n", "        ", "cv2", ".", "rectangle", "(", "draw_image", ",", "\n", "(", "bbox", "[", "1", "]", ",", "bbox", "[", "0", "]", ")", ",", "\n", "(", "bbox", "[", "3", "]", ",", "bbox", "[", "2", "]", ")", ",", "\n", "(", "255", ",", "0", ",", "0", ")", ",", "2", ")", "\n", "\n", "", "cv2", ".", "rectangle", "(", "draw_image", ",", "\n", "text_box_pos_tl", ",", "\n", "text_box_pos_br", ",", "\n", "(", "255", ",", "0", ",", "0", ")", ",", "-", "1", ")", "\n", "\n", "cv2", ".", "rectangle", "(", "draw_image", ",", "\n", "text_box_pos_tl", ",", "\n", "text_box_pos_br", ",", "\n", "(", "0", ",", "0", ",", "0", ")", ",", "1", ")", "\n", "\n", "cv2", ".", "putText", "(", "draw_image", ",", "text", ",", "text_pos", ",", "\n", "fontFace", ",", "fontScale", ",", "(", "255", ",", "255", ",", "255", ")", ",", "thickness", ")", "\n", "\n", "return", "draw_image", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw_detections": [[2784, 2952], ["os.path.join", "image.copy", "len", "range", "cv2.imwrite", "os.path.join", "image.copy", "cv2.imwrite", "print", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "image.copy", "len", "range", "cv2.imwrite", "os.path.join", "image.copy", "range", "cv2.imwrite", "numpy.where", "gt_coord[].copy", "range", "enumerate", "image.copy", "image.copy", "image.copy", "numpy.where", "pred_coord[].copy", "range", "cv2.imwrite", "cv2.imwrite", "cv2.imwrite", "utils.compute_matches", "len", "utils.transform_coordinates_3d", "utils.calculate_2d_projections", "utils.get_3d_bbox", "utils.transform_coordinates_3d", "utils.calculate_2d_projections", "utils.draw", "image.copy.copy", "utils.draw_text", "cv2.addWeighted", "utils.transform_coordinates_3d", "utils.calculate_2d_projections", "utils.get_3d_bbox", "utils.transform_coordinates_3d", "utils.calculate_2d_projections", "utils.draw", "image.copy.copy", "utils.draw_text", "cv2.addWeighted", "int", "numpy.array().transpose", "range", "numpy.array().transpose", "int", "draw.copy", "utils.compute_RT_degree_cm_symmetry", "utils.draw_text", "cv2.addWeighted", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_matches", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.get_3d_bbox", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw_text", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.get_3d_bbox", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.transform_coordinates_3d", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.calculate_2d_projections", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw_text", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.compute_RT_degree_cm_symmetry", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw_text"], ["", "def", "draw_detections", "(", "image", ",", "save_dir", ",", "data_name", ",", "image_id", ",", "intrinsics", ",", "synset_names", ",", "draw_rgb_coord", ",", "\n", "gt_bbox", ",", "gt_class_ids", ",", "gt_mask", ",", "gt_coord", ",", "gt_RTs", ",", "gt_scales", ",", "gt_handle_visibility", ",", "\n", "pred_bbox", ",", "pred_class_ids", ",", "pred_mask", ",", "pred_coord", ",", "pred_RTs", ",", "pred_scores", ",", "pred_scales", ",", "\n", "draw_gt", "=", "True", ",", "draw_pred", "=", "True", ",", "draw_tag", "=", "False", ")", ":", "\n", "\n", "    ", "alpha", "=", "0.5", "\n", "\n", "if", "draw_gt", ":", "\n", "        ", "output_path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{}_coord_gt.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "draw_image", "=", "image", ".", "copy", "(", ")", "\n", "num_gt_instances", "=", "len", "(", "gt_class_ids", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_gt_instances", ")", ":", "\n", "            ", "mask", "=", "gt_mask", "[", ":", ",", ":", ",", "i", "]", "\n", "#mask = mask[:, :, np.newaxis]", "\n", "#mask = np.repeat(mask, 3, axis=-1)", "\n", "cind", ",", "rind", "=", "np", ".", "where", "(", "mask", "==", "1", ")", "\n", "coord_data", "=", "gt_coord", "[", ":", ",", ":", ",", "i", ",", ":", "]", ".", "copy", "(", ")", "\n", "coord_data", "[", ":", ",", ":", ",", "2", "]", "=", "1", "-", "coord_data", "[", ":", ",", ":", ",", "2", "]", "# undo the z axis flipping to match original data        ", "\n", "draw_image", "[", "cind", ",", "rind", "]", "=", "coord_data", "[", "cind", ",", "rind", "]", "*", "255", "\n", "\n", "", "if", "draw_tag", ":", "\n", "            ", "for", "i", "in", "range", "(", "num_gt_instances", ")", ":", "\n", "                ", "overlay", "=", "draw_image", ".", "copy", "(", ")", "\n", "overlay", "=", "draw_text", "(", "overlay", ",", "gt_bbox", "[", "i", "]", ",", "synset_names", "[", "gt_class_ids", "[", "i", "]", "]", ",", "draw_box", "=", "True", ")", "\n", "cv2", ".", "addWeighted", "(", "overlay", ",", "alpha", ",", "draw_image", ",", "1", "-", "alpha", ",", "0", ",", "draw_image", ")", "\n", "\n", "# #if draw_tag:", "\n", "# for i in range(num_gt_instances):", "\n", "#     print('a', synset_names[gt_class_ids[i]])", "\n", "#     if synset_names[gt_class_ids[i]] == 'camera':", "\n", "#         overlay = draw_image.copy()", "\n", "#         cv2.rectangle(overlay, ", "\n", "#               (gt_bbox[i][1], gt_bbox[i][0]),", "\n", "#               (gt_bbox[i][3], gt_bbox[i][2]),", "\n", "#               (255, 0, 0), 2)", "\n", "\n", "#         cv2.addWeighted(overlay, alpha, draw_image, 1 - alpha, 0, draw_image)", "\n", "\n", "\n", "", "", "cv2", ".", "imwrite", "(", "output_path", ",", "draw_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{}_bbox_gt.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "draw_image_bbox", "=", "image", ".", "copy", "(", ")", "\n", "\n", "if", "gt_RTs", "is", "not", "None", ":", "\n", "            ", "for", "ind", ",", "RT", "in", "enumerate", "(", "gt_RTs", ")", ":", "\n", "                ", "cls_id", "=", "gt_class_ids", "[", "ind", "]", "\n", "\n", "xyz_axis", "=", "0.3", "*", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", ",", "[", "1", ",", "0", ",", "0", "]", "]", ")", ".", "transpose", "(", ")", "\n", "transformed_axes", "=", "transform_coordinates_3d", "(", "xyz_axis", ",", "RT", ")", "\n", "projected_axes", "=", "calculate_2d_projections", "(", "transformed_axes", ",", "intrinsics", ")", "\n", "\n", "\n", "bbox_3d", "=", "get_3d_bbox", "(", "gt_scales", "[", "ind", "]", ",", "0", ")", "\n", "transformed_bbox_3d", "=", "transform_coordinates_3d", "(", "bbox_3d", ",", "RT", ")", "\n", "projected_bbox", "=", "calculate_2d_projections", "(", "transformed_bbox_3d", ",", "intrinsics", ")", "\n", "draw_image_bbox", "=", "draw", "(", "draw_image_bbox", ",", "projected_bbox", ",", "projected_axes", ",", "(", "255", ",", "0", ",", "0", ")", ")", "\n", "\n", "", "", "cv2", ".", "imwrite", "(", "output_path", ",", "draw_image_bbox", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "\n", "\n", "", "if", "draw_pred", ":", "\n", "        ", "print", "(", "'a'", "*", "50", ")", "\n", "# Vs, Fs = dataset.load_objs(image_id, is_normalized=True) ## scale is estimated in RT", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{}_coord_pred.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "output_path_r", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{}_coord_pred_r.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "output_path_g", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{}_coord_pred_g.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "output_path_b", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{}_coord_pred_b.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "# utils.draw_coord_mask(image, r['class_ids'], pred_RTs, Vs, Fs, intrinsics, output_path)", "\n", "draw_image", "=", "image", ".", "copy", "(", ")", "\n", "if", "draw_rgb_coord", ":", "\n", "            ", "r_image", "=", "image", ".", "copy", "(", ")", "\n", "g_image", "=", "image", ".", "copy", "(", ")", "\n", "b_image", "=", "image", ".", "copy", "(", ")", "\n", "\n", "\n", "", "num_pred_instances", "=", "len", "(", "pred_class_ids", ")", "\n", "for", "i", "in", "range", "(", "num_pred_instances", ")", ":", "\n", "\n", "            ", "mask", "=", "pred_mask", "[", ":", ",", ":", ",", "i", "]", "\n", "#mask = mask[:, :, np.newaxis]", "\n", "#mask = np.repeat(mask, 3, axis=-1)", "\n", "cind", ",", "rind", "=", "np", ".", "where", "(", "mask", "==", "1", ")", "\n", "coord_data", "=", "pred_coord", "[", ":", ",", ":", ",", "i", ",", ":", "]", ".", "copy", "(", ")", "\n", "coord_data", "[", ":", ",", ":", ",", "2", "]", "=", "1", "-", "coord_data", "[", ":", ",", ":", ",", "2", "]", "# undo the z axis flipping to match original data", "\n", "draw_image", "[", "cind", ",", "rind", "]", "=", "coord_data", "[", "cind", ",", "rind", "]", "*", "255", "\n", "if", "draw_rgb_coord", ":", "\n", "                ", "b_image", "[", "cind", ",", "rind", ",", "2", "]", "=", "coord_data", "[", "cind", ",", "rind", ",", "2", "]", "*", "255", "\n", "b_image", "[", "cind", ",", "rind", ",", "0", ":", "2", "]", "=", "0", "\n", "\n", "g_image", "[", "cind", ",", "rind", ",", "1", "]", "=", "coord_data", "[", "cind", ",", "rind", ",", "1", "]", "*", "255", "\n", "g_image", "[", "cind", ",", "rind", ",", "0", "]", "=", "0", "\n", "g_image", "[", "cind", ",", "rind", ",", "2", "]", "=", "0", "\n", "\n", "r_image", "[", "cind", ",", "rind", ",", "0", "]", "=", "coord_data", "[", "cind", ",", "rind", ",", "0", "]", "*", "255", "\n", "r_image", "[", "cind", ",", "rind", ",", "1", ":", "3", "]", "=", "0", "\n", "\n", "", "", "if", "draw_tag", ":", "\n", "            ", "for", "i", "in", "range", "(", "num_pred_instances", ")", ":", "\n", "                ", "overlay", "=", "draw_image", ".", "copy", "(", ")", "\n", "text", "=", "synset_names", "[", "pred_class_ids", "[", "i", "]", "]", "+", "'({:.2f})'", ".", "format", "(", "pred_scores", "[", "i", "]", ")", "\n", "overlay", "=", "draw_text", "(", "overlay", ",", "pred_bbox", "[", "i", "]", ",", "text", ",", "draw_box", "=", "True", ")", "\n", "cv2", ".", "addWeighted", "(", "overlay", ",", "alpha", ",", "draw_image", ",", "1", "-", "alpha", ",", "0", ",", "draw_image", ")", "\n", "\n", "", "", "cv2", ".", "imwrite", "(", "output_path", ",", "draw_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "\n", "\n", "\n", "if", "draw_rgb_coord", ":", "\n", "            ", "cv2", ".", "imwrite", "(", "output_path_r", ",", "r_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "cv2", ".", "imwrite", "(", "output_path_g", ",", "g_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "cv2", ".", "imwrite", "(", "output_path_b", ",", "b_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "\n", "\n", "", "output_path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{}_bbox_pred.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "draw_image_bbox", "=", "image", ".", "copy", "(", ")", "\n", "\n", "if", "gt_class_ids", "is", "not", "None", ":", "\n", "            ", "gt_match", ",", "pred_match", ",", "_", ",", "pred_indices", "=", "compute_matches", "(", "gt_bbox", ",", "gt_class_ids", ",", "gt_mask", ",", "\n", "pred_bbox", ",", "pred_class_ids", ",", "pred_scores", ",", "pred_mask", ",", "\n", "0.5", ")", "\n", "\n", "if", "len", "(", "pred_indices", ")", ":", "\n", "                ", "pred_class_ids", "=", "pred_class_ids", "[", "pred_indices", "]", "\n", "pred_scores", "=", "pred_scores", "[", "pred_indices", "]", "\n", "pred_RTs", "=", "pred_RTs", "[", "pred_indices", "]", "\n", "\n", "\n", "", "", "for", "ind", "in", "range", "(", "num_pred_instances", ")", ":", "\n", "            ", "RT", "=", "pred_RTs", "[", "ind", "]", "\n", "cls_id", "=", "pred_class_ids", "[", "ind", "]", "\n", "\n", "if", "gt_class_ids", "is", "not", "None", ":", "## if gt exists, skip instances that fail to match", "\n", "                ", "gt_ind", "=", "int", "(", "pred_match", "[", "ind", "]", ")", "\n", "if", "gt_ind", "==", "-", "1", ":", "\n", "                    ", "continue", "\n", "\n", "", "", "xyz_axis", "=", "0.3", "*", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", ",", "[", "1", ",", "0", ",", "0", "]", "]", ")", ".", "transpose", "(", ")", "\n", "transformed_axes", "=", "transform_coordinates_3d", "(", "xyz_axis", ",", "RT", ")", "\n", "projected_axes", "=", "calculate_2d_projections", "(", "transformed_axes", ",", "intrinsics", ")", "\n", "\n", "\n", "bbox_3d", "=", "get_3d_bbox", "(", "pred_scales", "[", "ind", ",", ":", "]", ",", "0", ")", "\n", "transformed_bbox_3d", "=", "transform_coordinates_3d", "(", "bbox_3d", ",", "RT", ")", "\n", "projected_bbox", "=", "calculate_2d_projections", "(", "transformed_bbox_3d", ",", "intrinsics", ")", "\n", "draw_image_bbox", "=", "draw", "(", "draw_image_bbox", ",", "projected_bbox", ",", "projected_axes", ",", "(", "255", ",", "0", ",", "0", ")", ")", "\n", "\n", "", "if", "draw_tag", ":", "\n", "            ", "if", "gt_class_ids", "is", "not", "None", ":", "## if gt exists, draw rotation and translation error", "\n", "                ", "for", "ind", "in", "range", "(", "num_pred_instances", ")", ":", "\n", "                    ", "gt_ind", "=", "int", "(", "pred_match", "[", "ind", "]", ")", "\n", "if", "gt_ind", "==", "-", "1", ":", "\n", "                        ", "continue", "\n", "\n", "", "overlay", "=", "draw_image_bbox", ".", "copy", "(", ")", "\n", "RT", "=", "pred_RTs", "[", "ind", "]", "\n", "gt_RT", "=", "gt_RTs", "[", "gt_ind", "]", "\n", "cls_id", "=", "pred_class_ids", "[", "ind", "]", "\n", "\n", "degree", ",", "cm", "=", "compute_RT_degree_cm_symmetry", "(", "RT", ",", "gt_RT", ",", "cls_id", ",", "gt_handle_visibility", ",", "synset_names", ")", "\n", "text", "=", "'{}({:.1f}, {:.1f})'", ".", "format", "(", "synset_names", "[", "cls_id", "]", ",", "degree", ",", "cm", ")", "\n", "overlay", "=", "draw_text", "(", "overlay", ",", "pred_bbox", "[", "ind", "]", ",", "text", ")", "\n", "cv2", ".", "addWeighted", "(", "overlay", ",", "alpha", ",", "draw_image_bbox", ",", "1", "-", "alpha", ",", "0", ",", "draw_image_bbox", ")", "\n", "\n", "\n", "\n", "", "", "", "cv2", ".", "imwrite", "(", "output_path", ",", "draw_image_bbox", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw_coco_detections": [[2955, 3013], ["os.path.join", "cv2.imwrite", "os.path.join", "image.copy", "range", "cv2.imwrite", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "image.copy", "range", "cv2.imwrite", "len", "numpy.where", "utils.draw_text", "image.copy", "image.copy", "image.copy", "len", "numpy.where", "pred_coord[].copy", "utils.draw_text", "cv2.imwrite", "cv2.imwrite", "cv2.imwrite", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw_text", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.draw_text"], ["", "", "def", "draw_coco_detections", "(", "image", ",", "save_dir", ",", "data_name", ",", "image_id", ",", "synset_names", ",", "draw_rgb_coord", ",", "\n", "gt_bbox", ",", "gt_class_ids", ",", "gt_mask", ",", "\n", "pred_bbox", ",", "pred_class_ids", ",", "pred_mask", ",", "pred_coord", ",", "pred_scores", ")", ":", "\n", "\n", "    ", "output_path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{:04d}_image.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "cv2", ".", "imwrite", "(", "output_path", ",", "image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "\n", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{:04d}_mask_gt.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "draw_image", "=", "image", ".", "copy", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "gt_class_ids", ")", ")", ":", "\n", "        ", "mask", "=", "gt_mask", "[", ":", ",", ":", ",", "i", "]", "\n", "#mask = mask[:, :, np.newaxis]", "\n", "#mask = np.repeat(mask, 3, axis=-1)", "\n", "cind", ",", "rind", "=", "np", ".", "where", "(", "mask", "==", "1", ")", "\n", "draw_image", "[", "cind", ",", "rind", "]", "=", "np", ".", "random", ".", "rand", "(", "3", ")", "*", "255", "\n", "draw_image", "=", "draw_text", "(", "draw_image", ",", "gt_bbox", "[", "i", "]", ",", "synset_names", "[", "gt_class_ids", "[", "i", "]", "]", ",", "draw_box", "=", "True", ")", "\n", "", "cv2", ".", "imwrite", "(", "output_path", ",", "draw_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "\n", "\n", "# Vs, Fs = dataset.load_objs(image_id, is_normalized=True) ## scale is estimated in RT", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{:04d}_coord_pred.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "output_path_r", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{:04d}_coord_pred_r.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "output_path_g", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{:04d}_coord_pred_g.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "output_path_b", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "'{}_{:04d}_coord_pred_b.png'", ".", "format", "(", "data_name", ",", "image_id", ")", ")", "\n", "# utils.draw_coord_mask(image, r['class_ids'], pred_RTs, Vs, Fs, intrinsics, output_path)", "\n", "draw_image", "=", "image", ".", "copy", "(", ")", "\n", "if", "draw_rgb_coord", ":", "\n", "        ", "r_image", "=", "image", ".", "copy", "(", ")", "\n", "g_image", "=", "image", ".", "copy", "(", ")", "\n", "b_image", "=", "image", ".", "copy", "(", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "pred_class_ids", ")", ")", ":", "\n", "\n", "        ", "mask", "=", "pred_mask", "[", ":", ",", ":", ",", "i", "]", "\n", "#mask = mask[:, :, np.newaxis]", "\n", "#mask = np.repeat(mask, 3, axis=-1)", "\n", "cind", ",", "rind", "=", "np", ".", "where", "(", "mask", "==", "1", ")", "\n", "coord_data", "=", "pred_coord", "[", ":", ",", ":", ",", "i", ",", ":", "]", ".", "copy", "(", ")", "\n", "coord_data", "[", ":", ",", ":", ",", "2", "]", "=", "1", "-", "coord_data", "[", ":", ",", ":", ",", "2", "]", "# undo the z axis flipping to match original data", "\n", "draw_image", "[", "cind", ",", "rind", "]", "=", "coord_data", "[", "cind", ",", "rind", "]", "*", "255", "\n", "draw_image", "=", "draw_text", "(", "draw_image", ",", "pred_bbox", "[", "i", "]", ",", "synset_names", "[", "pred_class_ids", "[", "i", "]", "]", ",", "draw_box", "=", "True", ")", "\n", "if", "draw_rgb_coord", ":", "\n", "            ", "b_image", "[", "cind", ",", "rind", ",", "2", "]", "=", "coord_data", "[", "cind", ",", "rind", ",", "2", "]", "*", "255", "\n", "b_image", "[", "cind", ",", "rind", ",", "0", ":", "2", "]", "=", "0", "\n", "\n", "g_image", "[", "cind", ",", "rind", ",", "1", "]", "=", "coord_data", "[", "cind", ",", "rind", ",", "1", "]", "*", "255", "\n", "g_image", "[", "cind", ",", "rind", ",", "0", "]", "=", "0", "\n", "g_image", "[", "cind", ",", "rind", ",", "2", "]", "=", "0", "\n", "\n", "r_image", "[", "cind", ",", "rind", ",", "0", "]", "=", "coord_data", "[", "cind", ",", "rind", ",", "0", "]", "*", "255", "\n", "r_image", "[", "cind", ",", "rind", ",", "1", ":", "3", "]", "=", "0", "\n", "\n", "", "", "cv2", ".", "imwrite", "(", "output_path", ",", "draw_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "if", "draw_rgb_coord", ":", "\n", "        ", "cv2", ".", "imwrite", "(", "output_path_r", ",", "r_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "cv2", ".", "imwrite", "(", "output_path_g", ",", "g_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "cv2", ".", "imwrite", "(", "output_path_b", ",", "b_image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.backproject": [[3017, 3051], ["numpy.linalg.inv", "numpy.arange", "numpy.arange", "numpy.logical_and", "numpy.where", "numpy.array", "numpy.ones", "numpy.concatenate", "numpy.transpose", "pycocotools.mask", "pycocotools.mask"], "function", ["None"], ["", "", "def", "backproject", "(", "depth", ",", "intrinsics", ",", "instance_mask", ")", ":", "\n", "    ", "intrinsics_inv", "=", "np", ".", "linalg", ".", "inv", "(", "intrinsics", ")", "\n", "image_shape", "=", "depth", ".", "shape", "\n", "width", "=", "image_shape", "[", "1", "]", "\n", "height", "=", "image_shape", "[", "0", "]", "\n", "\n", "x", "=", "np", ".", "arange", "(", "width", ")", "\n", "y", "=", "np", ".", "arange", "(", "height", ")", "\n", "\n", "#non_zero_mask = np.logical_and(depth > 0, depth < 5000)", "\n", "non_zero_mask", "=", "(", "depth", ">", "0", ")", "\n", "final_instance_mask", "=", "np", ".", "logical_and", "(", "instance_mask", ",", "non_zero_mask", ")", "\n", "\n", "idxs", "=", "np", ".", "where", "(", "final_instance_mask", ")", "\n", "grid", "=", "np", ".", "array", "(", "[", "idxs", "[", "1", "]", ",", "idxs", "[", "0", "]", "]", ")", "\n", "\n", "# shape: height * width", "\n", "# mesh_grid = np.meshgrid(x, y) #[height, width, 2]", "\n", "# mesh_grid = np.reshape(mesh_grid, [2, -1])", "\n", "length", "=", "grid", ".", "shape", "[", "1", "]", "\n", "ones", "=", "np", ".", "ones", "(", "[", "1", ",", "length", "]", ")", "\n", "uv_grid", "=", "np", ".", "concatenate", "(", "(", "grid", ",", "ones", ")", ",", "axis", "=", "0", ")", "# [3, num_pixel]", "\n", "\n", "xyz", "=", "intrinsics_inv", "@", "uv_grid", "# [3, num_pixel]", "\n", "xyz", "=", "np", ".", "transpose", "(", "xyz", ")", "#[num_pixel, 3]", "\n", "\n", "z", "=", "depth", "[", "idxs", "[", "0", "]", ",", "idxs", "[", "1", "]", "]", "\n", "\n", "# print(np.amax(z), np.amin(z))", "\n", "pts", "=", "xyz", "*", "z", "[", ":", ",", "np", ".", "newaxis", "]", "/", "xyz", "[", ":", ",", "-", "1", ":", "]", "\n", "pts", "[", ":", ",", "0", "]", "=", "-", "pts", "[", ":", ",", "0", "]", "\n", "pts", "[", ":", ",", "1", "]", "=", "-", "pts", "[", ":", ",", "1", "]", "\n", "\n", "return", "pts", ",", "idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.align": [[3053, 3126], ["len", "numpy.zeros", "numpy.ones", "range", "numpy.abs", "utils.backproject", "numpy.zeros", "numpy.diag", "numpy.zeros", "numpy.ones", "numpy.amax", "numpy.linalg.norm", "time.time", "aligning.estimateSimilarityTransform", "numpy.zeros", "print", "elapses.append", "rotation.transpose", "coord_pts_rotated.transpose.transpose", "numpy.savetxt", "numpy.savetxt", "numpy.savetxt", "print", "print", "print", "print", "time.time", "print", "numpy.identity", "rotation.transpose", "rotation.transpose", "str", "numpy.diag", "coord_pts.transpose"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.backproject", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.aligning.estimateSimilarityTransform"], ["", "def", "align", "(", "class_ids", ",", "masks", ",", "coords", ",", "depth", ",", "intrinsics", ",", "synset_names", ",", "image_path", ",", "save_path", "=", "None", ",", "if_norm", "=", "False", ",", "with_scale", "=", "True", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "num_instances", "=", "len", "(", "class_ids", ")", "\n", "error_messages", "=", "''", "\n", "elapses", "=", "[", "]", "\n", "if", "num_instances", "==", "0", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", ",", "np", ".", "ones", "(", "(", "0", ",", "3", ")", ")", ",", "error_messages", ",", "elapses", "\n", "\n", "", "RTs", "=", "np", ".", "zeros", "(", "(", "num_instances", ",", "4", ",", "4", ")", ")", "\n", "bbox_scales", "=", "np", ".", "ones", "(", "(", "num_instances", ",", "3", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "#class_name = synset_names[class_ids[i]]", "\n", "        ", "class_id", "=", "class_ids", "[", "i", "]", "\n", "mask", "=", "masks", "[", ":", ",", ":", ",", "i", "]", "\n", "coord", "=", "coords", "[", ":", ",", ":", ",", "i", ",", ":", "]", "\n", "abs_coord_pts", "=", "np", ".", "abs", "(", "coord", "[", "mask", "==", "1", "]", "-", "0.5", ")", "\n", "bbox_scales", "[", "i", ",", ":", "]", "=", "2", "*", "np", ".", "amax", "(", "abs_coord_pts", ",", "axis", "=", "0", ")", "\n", "\n", "pts", ",", "idxs", "=", "backproject", "(", "depth", ",", "intrinsics", ",", "mask", ")", "\n", "coord_pts", "=", "coord", "[", "idxs", "[", "0", "]", ",", "idxs", "[", "1", "]", ",", ":", "]", "-", "0.5", "\n", "\n", "if", "if_norm", ":", "\n", "            ", "scale", "=", "np", ".", "linalg", ".", "norm", "(", "bbox_scales", "[", "i", ",", ":", "]", ")", "\n", "bbox_scales", "[", "i", ",", ":", "]", "/=", "scale", "\n", "coord_pts", "/=", "scale", "\n", "\n", "\n", "", "try", ":", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "scales", ",", "rotation", ",", "translation", ",", "outtransform", "=", "estimateSimilarityTransform", "(", "coord_pts", ",", "pts", ",", "False", ")", "\n", "\n", "aligned_RT", "=", "np", ".", "zeros", "(", "(", "4", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "with_scale", ":", "\n", "                ", "aligned_RT", "[", ":", "3", ",", ":", "3", "]", "=", "np", ".", "diag", "(", "scales", ")", "/", "1000", "@", "rotation", ".", "transpose", "(", ")", "\n", "", "else", ":", "\n", "                ", "aligned_RT", "[", ":", "3", ",", ":", "3", "]", "=", "rotation", ".", "transpose", "(", ")", "\n", "", "aligned_RT", "[", ":", "3", ",", "3", "]", "=", "translation", "/", "1000", "\n", "aligned_RT", "[", "3", ",", "3", "]", "=", "1", "\n", "\n", "if", "save_path", "is", "not", "None", ":", "\n", "                ", "coord_pts_rotated", "=", "aligned_RT", "[", ":", "3", ",", ":", "3", "]", "@", "coord_pts", ".", "transpose", "(", ")", "+", "aligned_RT", "[", ":", "3", ",", "3", ":", "]", "\n", "coord_pts_rotated", "=", "coord_pts_rotated", ".", "transpose", "(", ")", "\n", "np", ".", "savetxt", "(", "save_path", "+", "'_{}_{}_depth_pts.txt'", ".", "format", "(", "i", ",", "class_name", ")", ",", "pts", ")", "\n", "np", ".", "savetxt", "(", "save_path", "+", "'_{}_{}_coord_pts.txt'", ".", "format", "(", "i", ",", "class_name", ")", ",", "coord_pts", ")", "\n", "np", ".", "savetxt", "(", "save_path", "+", "'_{}_{}_coord_pts_aligned.txt'", ".", "format", "(", "i", ",", "class_name", ")", ",", "coord_pts_rotated", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "                ", "print", "(", "'Mask ID: '", ",", "i", ")", "\n", "print", "(", "'Scale: '", ",", "scales", "/", "1000", ")", "\n", "print", "(", "'Rotation: '", ",", "rotation", ".", "transpose", "(", ")", ")", "\n", "print", "(", "'Translation: '", ",", "translation", "/", "1000", ")", "\n", "\n", "", "elapsed", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "print", "(", "'elapsed: '", ",", "elapsed", ")", "\n", "elapses", ".", "append", "(", "elapsed", ")", "\n", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "message", "=", "'[ Error ] aligning instance {} in {} fails. Message: {}.'", ".", "format", "(", "synset_names", "[", "class_id", "]", ",", "image_path", ",", "str", "(", "e", ")", ")", "\n", "print", "(", "message", ")", "\n", "error_messages", "+=", "message", "+", "'\\n'", "\n", "aligned_RT", "=", "np", ".", "identity", "(", "4", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# print('Estimation takes {:03f}s.'.format(time.time() - start))", "\n", "# from camera world to computer vision frame", "\n", "", "z_180_RT", "=", "np", ".", "zeros", "(", "(", "4", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "z_180_RT", "[", ":", "3", ",", ":", "3", "]", "=", "np", ".", "diag", "(", "[", "-", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "z_180_RT", "[", "3", ",", "3", "]", "=", "1", "\n", "\n", "RTs", "[", "i", ",", ":", ",", ":", "]", "=", "z_180_RT", "@", "aligned_RT", "\n", "\n", "", "return", "RTs", ",", "bbox_scales", ",", "error_messages", ",", "elapses", "\n", "\n"]], "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.align_ICP": [[3128, 3224], ["len", "print", "numpy.zeros", "numpy.ones", "range", "numpy.array", "numpy.reshape", "utils.backproject", "print", "glob.glob", "print", "random.shuffle", "numpy.loadtxt", "print", "numpy.array", "numpy.zeros", "numpy.diag", "numpy.zeros", "numpy.ones", "ICP.doICP", "numpy.zeros", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.amax", "numpy.amin", "numpy.diag", "coord_pts_rotated.transpose.transpose", "numpy.savetxt", "numpy.savetxt", "numpy.savetxt", "print", "print", "print", "print", "numpy.sin", "coord_pts.transpose"], "function", ["home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.utils.backproject", "home.repos.pwc.inspect_result.hughw19_NOCS_CVPR2019.None.ICP.doICP"], ["", "def", "align_ICP", "(", "class_ids", ",", "masks", ",", "depth", ",", "intrinsics", ",", "synset_names", ",", "image_path", ",", "save_path", "=", "None", ",", "if_norm", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "num_instances", "=", "len", "(", "class_ids", ")", "\n", "error_messages", "=", "''", "\n", "\n", "print", "(", "intrinsics", ")", "\n", "if", "num_instances", "==", "0", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "0", ",", "4", ",", "4", ")", ")", ",", "np", ".", "ones", "(", "(", "0", ",", "3", ")", ")", ",", "error_messages", "\n", "\n", "", "RTs", "=", "np", ".", "zeros", "(", "(", "num_instances", ",", "4", ",", "4", ")", ")", "\n", "bbox_scales", "=", "np", ".", "ones", "(", "(", "num_instances", ",", "3", ")", ")", "\n", "\n", "def", "rotation_y_matrix", "(", "theta", ")", ":", "\n", "            ", "rotation_matrix", "=", "np", ".", "array", "(", "[", "np", ".", "cos", "(", "theta", ")", ",", "0", ",", "np", ".", "sin", "(", "theta", ")", ",", "\n", "0", ",", "1", ",", "0", ",", "\n", "-", "np", ".", "sin", "(", "theta", ")", ",", "0", ",", "np", ".", "cos", "(", "theta", ")", "]", ")", "\n", "rotation_matrix", "=", "np", ".", "reshape", "(", "rotation_matrix", ",", "(", "3", ",", "3", ")", ")", "\n", "return", "rotation_matrix", "\n", "\n", "", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "#class_name = synset_names[class_ids[i]]", "\n", "        ", "class_id", "=", "class_ids", "[", "i", "]", "\n", "mask", "=", "masks", "[", ":", ",", ":", ",", "i", "]", "\n", "# coord = coords[:, :, i, :]", "\n", "# abs_coord_pts = np.abs(coord[mask==1] - 0.5)", "\n", "# bbox_scales[i, :] = 2*np.amax(abs_coord_pts, axis=0)", "\n", "\n", "depth_pts", ",", "idxs", "=", "backproject", "(", "depth", ",", "intrinsics", ",", "mask", ")", "\n", "# coord_pts = coord[idxs[0], idxs[1], :] - 0.5", "\n", "\n", "# if if_norm:", "\n", "#     scale = np.linalg.norm(bbox_scales[i, :])", "\n", "#     bbox_scales[i, :] /= scale", "\n", "#     coord_pts /= scale", "\n", "\n", "glob_paths", "=", "'/home/hewang/Projects/CoordRCNN/data/pts/real_test/{}*.txt'", ".", "format", "(", "synset_names", "[", "class_ids", "[", "i", "]", "]", ")", "\n", "print", "(", "glob_paths", ")", "\n", "shape_paths", "=", "glob", ".", "glob", "(", "glob_paths", ")", "\n", "print", "(", "shape_paths", ")", "\n", "\n", "\n", "random", ".", "shuffle", "(", "shape_paths", ")", "\n", "shape_pts", "=", "np", ".", "loadtxt", "(", "shape_paths", "[", "0", "]", ")", "\n", "print", "(", "shape_pts", ".", "shape", ")", "\n", "bbox_scales", "[", "i", ",", ":", "]", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", "]", ")", "\n", "\n", "\n", "\n", "# depth_pts = rotation_y_matrix(0.01)@shape_pts.transpose() + 0.01", "\n", "# depth_pts = depth_pts.transpose()", "\n", "\n", "#try:", "\n", "if", "True", ":", "\n", "            ", "scales", ",", "rotation", ",", "translation", "=", "ICP", ".", "doICP", "(", "shape_pts", ",", "\n", "depth_pts", ",", "\n", "threshold", "=", "5", ",", "isViz", "=", "False", ")", "\n", "\n", "scales", "=", "np", ".", "amax", "(", "shape_pts", ",", "axis", "=", "0", ")", "-", "np", ".", "amin", "(", "shape_pts", ",", "axis", "=", "0", ")", "\n", "# scales, rotation, translation, outtransform = estimateSimilarityTransform(coord_pts, pts, False)", "\n", "#scales = np.diag(bbox_scales[i, :])", "\n", "aligned_RT", "=", "np", ".", "zeros", "(", "(", "4", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "aligned_RT", "[", ":", "3", ",", ":", "3", "]", "=", "np", ".", "diag", "(", "scales", ")", "@", "rotation", "#.transpose()", "\n", "aligned_RT", "[", ":", "3", ",", "3", "]", "=", "translation", "/", "1000", "\n", "aligned_RT", "[", "3", ",", "3", "]", "=", "1", "\n", "\n", "#bbox_scales[i, :] = scales@bbox_scales[i, :]/1000", "\n", "\n", "if", "save_path", "is", "not", "None", ":", "\n", "                ", "coord_pts_rotated", "=", "aligned_RT", "[", ":", "3", ",", ":", "3", "]", "@", "coord_pts", ".", "transpose", "(", ")", "+", "aligned_RT", "[", ":", "3", ",", "3", ":", "]", "\n", "coord_pts_rotated", "=", "coord_pts_rotated", ".", "transpose", "(", ")", "\n", "np", ".", "savetxt", "(", "save_path", "+", "'_{}_{}_depth_pts.txt'", ".", "format", "(", "i", ",", "class_name", ")", ",", "pts", ")", "\n", "np", ".", "savetxt", "(", "save_path", "+", "'_{}_{}_coord_pts.txt'", ".", "format", "(", "i", ",", "class_name", ")", ",", "coord_pts", ")", "\n", "np", ".", "savetxt", "(", "save_path", "+", "'_{}_{}_coord_pts_aligned.txt'", ".", "format", "(", "i", ",", "class_name", ")", ",", "coord_pts_rotated", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "                ", "print", "(", "'Mask ID: '", ",", "i", ")", "\n", "print", "(", "'Scale: '", ",", "scales", ")", "\n", "print", "(", "'Rotation: '", ",", "rotation", ")", "\n", "print", "(", "'Translation: '", ",", "translation", ")", "\n", "\n", "\n", "# except Exception as e:", "\n", "#     message = '[ Error ] aligning instance {} in {} fails. Message: {}.'.format(synset_names[class_id], image_path, str(e))", "\n", "#     print(message)", "\n", "#     error_messages += message + '\\n'", "\n", "#     aligned_RT = np.identity(4, dtype=np.float32) ", "\n", "\n", "# print('Estimation takes {:03f}s.'.format(time.time() - start))", "\n", "# from camera world to computer vision frame", "\n", "", "", "z_180_RT", "=", "np", ".", "zeros", "(", "(", "4", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "z_180_RT", "[", ":", "3", ",", ":", "3", "]", "=", "np", ".", "diag", "(", "[", "-", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "z_180_RT", "[", "3", ",", "3", "]", "=", "1", "\n", "\n", "RTs", "[", "i", ",", ":", ",", ":", "]", "=", "z_180_RT", "@", "aligned_RT", "\n", "\n", "", "return", "RTs", ",", "bbox_scales", ",", "error_messages", "\n", "", ""]]}